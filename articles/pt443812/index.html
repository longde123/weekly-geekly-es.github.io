<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöØ üßìüèª üñêÔ∏è Como implementar uma linguagem de programa√ß√£o em JavaScript. Parte 2: Int√©rprete üê° ‚úåüèº üöÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Apresento a voc√™ a segunda parte da minha tradu√ß√£o do guia para implementar sua linguagem de programa√ß√£o JavaScript - PL Tutorial . 
 Do tradutor ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como implementar uma linguagem de programa√ß√£o em JavaScript. Parte 2: Int√©rprete</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443812/"><p>  Ol√°  Apresento a voc√™ a segunda parte da minha tradu√ß√£o do guia para implementar sua linguagem de programa√ß√£o JavaScript - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PL Tutorial</a> . </p><br><h1 id="ot-perevodchika">  Do tradutor </h1><br><p>  Criaremos nossa pr√≥pria linguagem de programa√ß√£o - <strong>linguagem Œª</strong> (no original - <strong>linguagem Œª</strong> ).  No processo de cria√ß√£o, usaremos muitas t√©cnicas interessantes, como descida recursiva, estilo de transfer√™ncia de controle e t√©cnicas b√°sicas de otimiza√ß√£o.  Ser√£o criadas duas vers√µes do int√©rprete - o regular e o CPS, o transcompilador em JavaScript. </p><br><p>  O autor do original √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mihai Bazon</a> , o autor da famosa biblioteca UglifyJS (uma ferramenta para minimizar e formatar o c√≥digo JS). </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Conte√∫do</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como implementar uma linguagem de programa√ß√£o em JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1: Analisador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como implementar uma linguagem de programa√ß√£o em JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2: Int√©rprete</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como implementar uma linguagem de programa√ß√£o em JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3: Int√©rprete de CPS</a> </li><li>  Como implementar uma linguagem de programa√ß√£o em JavaScript.  Parte 4: Trans Compilando em JS </li></ol></div></div><br><p> PS Existe um erro no interpretador e compilador: em express√µes como <code>a() &amp;&amp; b()</code> ou <code>a() || b()</code>  <code>a() || b()</code> ambas as partes s√£o sempre executadas.  Obviamente, isso est√° errado porque <code>a()</code> falso para o operador <code>&amp;&amp;</code> ou falso para o <code>||</code>  , o valor de <code>b()</code> n√£o desempenha nenhum papel.  Isso n√£o √© dif√≠cil de corrigir. </p><br><h1 id="prostoy-interpretator">  Int√©rprete simples </h1><br><p>  Na parte anterior, escrevemos 3 fun√ß√µes: <code>InputStream</code> , <code>TokenStream</code> e <code>parse</code> .  Para obter o AST do c√≥digo, usamos o seguinte c√≥digo: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ast = parse(TokenStream(InputStream(code)));</code> </pre> <br><p>  Escrever um int√©rprete √© mais f√°cil do que um analisador: apenas percorremos recursivamente a √°rvore e executamos as express√µes em sua ordem normal. </p><br><h2 id="kontekst-environment">  Contexto ( <code>Environment</code> ) </h2><br><p>  Para a execu√ß√£o correta do c√≥digo, precisamos de um contexto - um objeto contendo todas as vari√°veis ‚Äã‚Äãem um determinado local.  Ser√° passado como argumento para a fun√ß√£o de <code>evaluate</code> . </p><br><p>  Cada vez que entramos no n√≥ <code>lambda</code> , devemos adicionar novas vari√°veis ‚Äã‚Äãaos argumentos da fun√ß√£o de contexto.  Se o argumento sobrepuser a vari√°vel do bloco externo, devemos restaurar o valor antigo da vari√°vel ap√≥s sair da fun√ß√£o. </p><br><p>  A maneira mais f√°cil de fazer isso √© usar a heran√ßa de prot√≥tipo do JavaScript.  Quando inserimos uma nova fun√ß√£o, criamos um novo contexto, definimos o contexto externo como seu prot√≥tipo e chamamos a fun√ß√£o no novo contexto.  Gra√ßas a isso, n√£o temos nada - no contexto externo todas as suas vari√°veis ‚Äã‚Äãpermanecer√£o. </p><br><p>  Aqui est√° a implementa√ß√£o do objeto <code>Environment</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Environment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(parent ? parent.vars : <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent = parent; } Environment.prototype = { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Environment(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">lookup</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (scope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.hasOwnProperty.call(scope.vars, name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scope; scope = scope.parent; } }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars[name]; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Undefined variable "</span></span> + name); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lookup(name); <span class="hljs-comment"><span class="hljs-comment">//          if (!scope &amp;&amp; this.parent) throw new Error("Undefined variable " + name); return (scope || this).vars[name] = value; }, def: function(name, value) { return this.vars[name] = value; } };</span></span></code> </pre> <br><p>  O objeto <code>Environment</code> possui um campo <code>parent</code> que aponta para o contexto externo.  Ser√° <code>null</code> para o contexto global.  Possui um campo <code>vars</code> no qual existem todas as vari√°veis ‚Äã‚Äãque pertencem a esse contexto.  Para um contexto global, √© imediatamente igual a um objeto vazio ( <code>Object.create(null)</code> ) e uma c√≥pia das vari√°veis ‚Äã‚Äãdo contexto pai <code>Object.create(parent.vars)</code> ) para um n√£o global. </p><br><p>  Tem v√°rios m√©todos: </p><br><ul><li>  <code>extend()</code> - copia o contexto atual. </li><li>  <code>lookup(name)</code> - encontre o contexto em que a vari√°vel denominada <code>name</code> definida. </li><li>  <code>get(name)</code> - obt√©m o valor de uma vari√°vel chamada <code>name</code> .  Lan√ßa uma exce√ß√£o se a vari√°vel n√£o tiver sido definida. </li><li>  <code>set(name, value)</code> - define o valor de uma vari√°vel.  Este m√©todo procura o contexto em que a vari√°vel est√° definida.  Se n√£o estiver definido e n√£o estivermos em um contexto global, uma exce√ß√£o ser√° lan√ßada. </li><li>  <code>def(name, value)</code> - cria (ou sobrep√µe ou substitui) uma vari√°vel no contexto atual. </li></ul><br><h2 id="funkciya-evaluate">  <code>evaluate</code> fun√ß√£o </h2><br><p>  Agora que temos o objeto <code>Environment</code> , podemos prosseguir para solucionar o problema principal.  Esta fun√ß√£o ser√° um bloco de <code>switch</code> grande, que executar√° alguma a√ß√£o dependendo do tipo do n√≥ transmitido: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (exp.type) {</code> </pre> <br><p>  Para literais, simplesmente retornamos seu valor: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"str"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.value;</code> </pre> <br><p>  As vari√°veis ‚Äã‚Äãs√£o obtidas do contexto (o nome da vari√°vel est√° contido no campo de <code>value</code> ): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"var"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.get(exp.value);</code> </pre> <br><p>  Para atribuir, devemos garantir que, no lado esquerdo, tenhamos o nome da vari√°vel (n√≥ <code>var</code> ).  Caso contr√°rio, simplesmente lan√ßamos uma exce√ß√£o (n√£o apoiamos a atribui√ß√£o a nada al√©m de vari√°veis).  Em seguida, definimos o valor da vari√°vel usando <code>env.set</code> .  Observe que o lado direito da express√£o deve ser calculado usando a chamada recursiva para <code>evaluate</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"assign"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.left.type != <span class="hljs-string"><span class="hljs-string">"var"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot assign to "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(exp.left)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.set(exp.left.value, evaluate(exp.right, env));</code> </pre> <br><p>  Para um n√≥ do tipo <code>binary</code> devemos aplicar o operador para ambos os operandos.  Escreveremos a fun√ß√£o <code>apply_op</code> mais tarde.  Al√©m disso, chamamos <code>evaluate</code> para ambas as partes da express√£o: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"binary"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply_op(exp.operator, evaluate(exp.left, env), evaluate(exp.right, env));</code> </pre> <br><p>  Um n√≥ do tipo <code>lambda</code> retornar√° um fechamento normal do JavaScript, para que possa ser chamado como uma fun√ß√£o regular, mesmo a partir do JavaScript.  Eu adicionei a fun√ß√£o <code>make_lambda</code> , que mostrarei mais tarde: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_lambda(env, exp);</code> </pre> <br><p>  A execu√ß√£o do n√≥ <code>if</code> bastante simples: primeiro encontramos o valor da condi√ß√£o.  Se n√£o for falso, retorne o valor da ramifica√ß√£o <code>then</code> .  Caso contr√°rio, se houver um ramo <code>else</code> , seu valor ou <code>false</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"if"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cond = evaluate(exp.cond, env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.then, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.else ? evaluate(exp.else, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><p>  O n√≥ <code>prog</code> √© uma sequ√™ncia de express√µes.  Simplesmente executamos todas as express√µes em ordem e pegamos o valor desta √∫ltima (o valor da sequ√™ncia vazia √© <code>false</code> ): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"prog"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; exp.prog.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp</span></span></span><span class="hljs-function">)</span></span>{ val = evaluate(exp, env) }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val;</code> </pre> <br><p>  Para um n√≥ do tipo <code>call</code> precisamos chamar uma fun√ß√£o.  Antes disso, encontraremos o valor da pr√≥pria fun√ß√£o, encontraremos os valores de todos os argumentos e chamaremos a fun√ß√£o usando <code>apply</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"call"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func = evaluate(exp.func, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, exp.args.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(arg, env); }));</code> </pre> <br><p>  N√≥s nunca chegaremos aqui, mas no caso de adicionarmos um novo tipo de n√≥ ao analisador e esquecermos de adicion√°-lo ao int√©rprete: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know how to evaluate "</span></span> + exp.type); } }</code> </pre> <br><p>  Esta foi a parte principal do int√©rprete.  Acima, usamos duas fun√ß√µes que ainda n√£o implementamos, ent√£o vamos come√ßar: </p><br><h4 id="apply_op">  <code>apply_op</code> : </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_op</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op, a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> x != <span class="hljs-string"><span class="hljs-string">"number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Expected number but got "</span></span> + x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num(x) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Divide by zero"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"+"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) + num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) - num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) * num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"/"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) / div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"%"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) % div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&amp;&amp;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"||"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> ? a : b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"=="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a === b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"!="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== b; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Can't apply operator "</span></span> + op); }</code> </pre> <br><p>  Ele recebe o tipo e os argumentos do operador.  <code>switch</code> simples e intuitivo.  Ao contr√°rio do JavaScript, que pode assumir qualquer valor, como vari√°veis, mesmo aquelas que n√£o fazem sentido.  Exigimos que os operandos dos operadores aritm√©ticos sejam n√∫meros e n√£o permitam a divis√£o por zero.  Para strings, apresentaremos algo mais tarde. </p><br><h4 id="make_lambda">  <code>make_lambda</code> : </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = exp.vars; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; names.length; ++i) scope.def(names[i], i &lt; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length ? <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[i] : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, scope); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lambda; }</code> </pre> <br><p>  Como voc√™ pode ver acima, ele retorna uma fun√ß√£o JavaScript regular que usa o contexto passado e as fun√ß√µes AST.  Todo o trabalho √© realizado apenas quando a pr√≥pria fun√ß√£o √© chamada: um contexto √© criado, argumentos s√£o definidos (se n√£o forem suficientes, tornam-se <code>false</code> ).  Em seguida, o corpo da fun√ß√£o √© simplesmente executado em um novo contexto. </p><br><h4 id="nativnye-funkcii">  Fun√ß√µes nativas </h4><br><p>  Como voc√™ pode ver, n√£o tivemos como interagir com o JavaScript em nosso idioma.  Eu costumava usar as fun√ß√µes <code>print</code> e <code>println</code> , mas n√£o as defini em lugar nenhum.  Precisamos escrev√™-los em JavaScript e apenas adicion√°-los ao contexto global. </p><br><p>  Aqui est√° um exemplo desse c√≥digo: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  -   var code = "sum = lambda(x, y) x + y; print(sum(2, 3));"; // ,  parse  TokenStream,      InputStream var ast = parse(TokenStream(InputStream(code))); //    var globalEnv = new Environment(); //  ""  "print" globalEnv.def("print", function(txt){ console.log(txt); }); //  evaluate(ast, globalEnv); //  5</span></span></code> </pre> <br><h4 id="ves-kod">  C√≥digo inteiro </h4><br><p>  Voc√™ pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">baixar todo o c√≥digo</a> que escrevemos esse tempo todo.  Pode ser iniciado usando o NodeJS.  Basta passar o c√≥digo para o fluxo padr√£o: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'sum = lambda(x, y) x + y; println(sum(2, 3));'</span></span> | node lambda-eval1.js</code> </pre> <br><h1 id="primery-koda">  Exemplos de c√≥digo </h1><br><p>  Nossa linguagem de programa√ß√£o, embora simples, pode (teoricamente) resolver qualquer problema que possa ser resolvido por um computador.  Isso ocorre porque alguns caras mais espertos do que eu jamais serei - Alonzo Church e Alan Turing - uma vez provaram que o Œª-c√°lculo (lambda calculus) √© equivalente a uma m√°quina de Turing, e nossa linguagem Œª implementa Œª-c√°lculo. </p><br><p>  Isso significa que, mesmo que nosso idioma n√£o tenha nenhuma oportunidade, todos n√≥s podemos realiz√°-los usando o que j√° temos.  Ou, se isso for dif√≠cil, podemos escrever um int√©rprete para outro idioma. </p><br><h4 id="cikly">  Ciclos </h4><br><p>  Loops n√£o s√£o um problema se tivermos recurs√£o.  Eu j√° mostrei um exemplo de loop implementado em cima da recurs√£o.  Vamos tentar novamente. </p><br><pre> <code class="python hljs">print_range = Œª(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b { print(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= b { print(<span class="hljs-string"><span class="hljs-string">", "</span></span>); print_range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> println(<span class="hljs-string"><span class="hljs-string">""</span></span>); }; print_range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  Mas aqui temos um problema: se aumentarmos o n√∫mero de itera√ß√µes, digamos, para 1000. Por exemplo, recebo o erro ‚ÄúTamanho m√°ximo da pilha de chamadas excedido‚Äù ap√≥s 600. Isso acontece porque o int√©rprete √© recursivo e a recurs√£o atinge a profundidade m√°xima. </p><br><p>  Este √© um problema s√©rio, mas h√° uma solu√ß√£o.  Eu gostaria de adicionar novas constru√ß√µes para itera√ß√£o ( <code>for</code> ou <code>while</code> ), mas vamos tentar ficar sem elas.  A recurs√£o est√° linda, ent√£o vamos deixar.  Veremos mais adiante como contornar essa limita√ß√£o. </p><br><h4 id="struktury-dannyh-ih-otsutstvie">  Estruturas de dados (falta dela) </h4><br><p>  Existem tr√™s tipos de dados em nosso idioma Œª: n√∫meros, seq√º√™ncias de caracteres e tipos booleanos.  Pode parecer que voc√™ n√£o pode criar tipos complexos, como matrizes ou objetos.  Mas isso n√£o √© um problema, temos mais um tipo: function.  Acontece que, se seguirmos o c√°lculo Œª, podemos criar qualquer estrutura de dados, incluindo objetos, mesmo com heran√ßa. </p><br><p>  Vou mostr√°-lo no exemplo de listas.  Vamos imaginar que temos uma fun√ß√£o <code>cons</code> que cria um objeto contendo dois valores.  Vamos chamar esse objeto de "c√©lula" ou "par".  Vamos nomear um dos valores "carro" e o outro "cdr".  S√≥ porque eles s√£o chamados no Lisp.  Agora, se tivermos um objeto "cell", podemos obter seus valores usando as fun√ß√µes <code>car</code> e <code>cdr</code> : </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); print(car(x)); <span class="hljs-comment"><span class="hljs-comment">#  10 print(cdr(x)); #  20</span></span></code> </pre> <br><p>  Agora podemos definir facilmente uma lista: </p><br><blockquote>  Uma lista √© um par que cont√©m o primeiro elemento em `car` e os demais elementos em` cdr`.  Mas `cdr` pode conter apenas um valor!  Este valor ser√° uma lista.  Uma lista √© um par que cont√©m o primeiro elemento em `car` e os demais elementos em` cdr`.  Mas `cdr` pode conter apenas um valor!  Este valor ser√° uma lista.  [...] <br></blockquote><p>  Este √© um tipo de dados recursivo.  Mas um problema permanece: quando voc√™ precisa parar?  Logicamente, devemos parar quando <code>cdr</code> √© uma lista vazia.  Mas o que √© uma lista vazia?  Para fazer isso, vamos adicionar um novo objeto chamado "NIL".  Pode ser usado em casal (podemos usar o <code>car</code> e os <code>cdr</code> , mas o resultado ser√° o pr√≥prio <code>NIL</code> ).  Agora vamos criar uma lista dos itens 1, 2, 3, 4, 5: </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); print(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 print(car(cdr(x))); # 2  Lisp  . cadr print(car(cdr(cdr(x)))); # 3 caddr print(car(cdr(cdr(cdr(x))))); # 4 cadddr print(car(cdr(cdr(cdr(cdr(x)))))); # 5     .</span></span></code> </pre> <br><p>  Parece horr√≠vel quando n√£o h√° sintaxe especial para isso.  Mas eu s√≥ queria mostrar que isso pode ser feito usando os recursos existentes da linguagem Œª.  Aqui est√° a implementa√ß√£o: </p><br><pre> <code class="python hljs">cons = Œª(a, b) Œª(f) f(a, b); car = Œª(cell) cell(Œª(a, b) a); cdr = Œª(cell) cell(Œª(a, b) b); NIL = Œª(f) f(NIL, NIL);</code> </pre> <br><p>  Quando vi pela primeira vez <code>cons</code> / <code>car</code> / <code>cdr</code> feitos dessa maneira, fiquei surpreso que eles n√£o precisassem de um √∫nico <code>if</code> (mas isso √© estranho, considerando o fato de que ele n√£o est√° no Œª-c√°lculo original).  Obviamente, nenhuma linguagem de programa√ß√£o faz isso desta maneira, porque √© extremamente ineficiente, mas n√£o torna os c√°lculos Œª menos bonitos.  Em uma linguagem clara, esse c√≥digo faz o seguinte: </p><br><ul><li>  a fun√ß√£o <code>cons</code> usa dois valores ( <code>b</code> ) e retorna a fun√ß√£o que os mant√©m.  Essa fun√ß√£o √© o pr√≥prio objeto do par.  Ela pega uma discuss√£o e a chama pelos dois valores do par. </li><li>  A fun√ß√£o <code>car</code> chama o argumento passado, passando uma fun√ß√£o que retorna o primeiro argumento. </li><li>  a fun√ß√£o <code>cdr</code> faz o mesmo que a fun√ß√£o <code>car</code> , mas com a √∫nica diferen√ßa √© que a fun√ß√£o passada retorna o segundo argumento. </li><li>  a fun√ß√£o <code>NIL</code> funciona da mesma forma que <code>cons</code> , mas retorna um par com dois valores iguais a NIL. </li></ul><br><pre> <code class="python hljs">cons = Œª(a, b) Œª(f) f(a, b); car = Œª(cell) cell(Œª(a, b) a); cdr = Œª(cell) cell(Œª(a, b) b); NIL = Œª(f) f(NIL, NIL); x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); println(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 println(car(cdr(x))); # 2 println(car(cdr(cdr(x)))); # 3 println(car(cdr(cdr(cdr(x))))); # 4 println(car(cdr(cdr(cdr(cdr(x)))))); # 5</span></span></code> </pre> <br><p>  Existem muitos algoritmos nas listas que podem ser implementados recursivamente e parecem l√≥gicos.  Por exemplo, aqui est√° uma fun√ß√£o que chama a fun√ß√£o passada para cada item da lista: </p><br><pre> <code class="python hljs">foreach = Œª(list, f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> list != NIL { f(car(list)); foreach(cdr(list), f); }; foreach(x, println);</code> </pre> <br><p>  E aqui est√° outra que cria uma lista para um intervalo de n√∫meros: </p><br><pre> <code class="python hljs">range = Œª(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b then cons(a, range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> NIL; <span class="hljs-comment"><span class="hljs-comment">#     1  8 foreach(range(1, 8), Œª(x) println(x * x));</span></span></code> </pre> <br><p>  As listas que implementamos acima s√£o imut√°veis ‚Äã‚Äã(n√£o podemos mudar de <code>car</code> ou <code>cdr</code> ap√≥s a cria√ß√£o da lista).  A maioria dos Lisp tem fun√ß√µes para alterar um par.  No esquema, eles s√£o chamados de <code>set-car!</code>  / <code>set-cdr!</code>  .  No Common Lisp, <code>rplaca</code> / <code>rplacd</code> .  Desta vez, usamos os nomes do esquema: </p><br><pre> <code class="python hljs">cons = Œª(x, y) Œª(a, i, v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-string"><span class="hljs-string">"get"</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x = v <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y = v; car = Œª(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); cdr = Œª(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); set-car! = Œª(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, val); set-cdr! = Œª(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, val); <span class="hljs-comment"><span class="hljs-comment">#  NIL     NIL = cons(0, 0); set-car!(NIL, NIL); set-cdr!(NIL, NIL); ## : x = cons(1, 2); println(car(x)); # 1 println(cdr(x)); # 2 set-car!(x, 10); set-cdr!(x, 20); println(car(x)); # 10 println(cdr(x)); # 20</span></span></code> </pre> <br><p>  Isso mostra que podemos implementar estruturas de dados mut√°veis.  N√£o vou me aprofundar em como isso funciona, est√° claro no c√≥digo. </p><br><p>  Podemos ir al√©m e implementar os objetos, mas sem altera√ß√µes na sintaxe, ser√° dif√≠cil fazer isso.  Outra maneira √© implementar uma nova sintaxe no tokenizer / analisador e adicionar seu processamento no int√©rprete.  Todas as principais linguagens de programa√ß√£o fazem isso e √© necess√°rio obter desempenho normal.  Adicionaremos nova sintaxe na pr√≥xima parte do artigo. </p><br><p>  [Do tradutor: se voc√™ estiver interessado em c√°lculo lambda, h√° um artigo interessante sobre Habr√© dedicado a este t√≥pico: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√°lculo lambda em JavaScript</a> .] </p><br><h1 id="novye-sintaksicheskie-konstrukcii">  Novas constru√ß√µes de sintaxe </h1><br><p>  Nossa linguagem Œª possui algumas constru√ß√µes sint√°ticas.  Por exemplo, n√£o h√° maneira direta de adicionar novas vari√°veis.  Como eu disse antes, devemos usar o IIFE, ent√£o fica algo assim: </p><br><pre> <code class="python hljs">(Œª(x, y){ (Œª(z){ <span class="hljs-comment"><span class="hljs-comment">## it gets worse when one of the vars depends on another print(x + y + z); })(x + y); })(2, 3);</span></span></code> </pre> <br><p>  Adicionaremos a palavra-chave <code>let</code> .  Isso nos permitir√° escrever algo como isto: </p><br><pre> <code class="python hljs">let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = <span class="hljs-number"><span class="hljs-number">3</span></span>, z = x + y) print(x + y + z);</code> </pre> <br><p>  Para cada vari√°vel no bloco <code>let</code> , as vari√°veis ‚Äã‚Äãanteriores devem estar dispon√≠veis mesmo no mesmo bloco.  Portanto, o c√≥digo acima ser√° equivalente ao seguinte: </p><br><pre> <code class="python hljs">(Œª(x){ (Œª(y){ (Œª(z){ print(x + y + z); })(x + y); })(<span class="hljs-number"><span class="hljs-number">3</span></span>); })(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  Essas altera√ß√µes podem ser feitas diretamente no analisador e, em seguida, n√£o exigir√£o altera√ß√µes no int√©rprete.  Em vez de adicionar um novo n√≥ <code>let</code> , podemos transform√°-lo em n√≥s de <code>call</code> e <code>lambda</code> .  Isso significa que n√£o fizemos altera√ß√µes sem√¢nticas em nossa linguagem - isso √© chamado de "a√ß√∫car sint√°tico", e a opera√ß√£o de converter isso em n√≥s AST que existia antes √© chamada de "sem a√ß√∫car" (original: "desugaring"). </p><br><p>  No entanto, devemos alterar o analisador de qualquer maneira.  Vamos adicionar um novo n√≥ "let", porque ele pode ser interpretado com mais efici√™ncia (n√£o h√° necessidade de criar fechamentos e cham√°-los imediatamente, basta copiar e alterar o contexto). </p><br><p>  Al√©m disso, adicionaremos suporte para "let named", que estava no esquema.  Isso facilita a cria√ß√£o de loops: </p><br><pre> <code class="python hljs">print(let loop (n = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Este √© um loop "recursivo" que conta a soma de 10 + 9 + ... + 0. Anteriormente, ter√≠amos que fazer o seguinte: </p><br><pre> <code class="python hljs">print((Œª(loop){ loop = Œª(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; loop(<span class="hljs-number"><span class="hljs-number">10</span></span>); })());</code> </pre> <br><p>  Al√©m disso, para facilitar isso, adicionaremos a sintaxe de "fun√ß√µes com um nome".  Ficar√° assim: </p><br><pre> <code class="python hljs">print((Œª loop (n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-number"><span class="hljs-number">10</span></span>));</code> </pre> <br><p>  Modifica√ß√µes que precisam ser feitas para isso: </p><br><ul><li>  Suporte para o nome opcional ap√≥s a palavra-chave <code>lambda</code> .  Se estiver presente, devemos adicionar uma vari√°vel ao contexto atual que apontar√° para a pr√≥pria fun√ß√£o.  √â exatamente o mesmo que fun√ß√µes com um nome em JavaScript. </li><li>  Suporte para a nova palavra-chave <code>let</code> .  A seguir, vem um nome opcional e uma lista (possivelmente vazia) de defini√ß√µes de vari√°veis ‚Äã‚Äãneste formato: <code>foo = EXPRESSION</code> , separadas por v√≠rgulas.  O corpo de uma express√£o <code>let</code> √© uma express√£o (que, √© claro, pode ser uma sequ√™ncia de express√µes). </li></ul><br><h4 id="izmeneniya-v-parsere">  Altera√ß√µes do analisador </h4><br><p>  Primeiro, uma pequena altera√ß√£o no tokenizer, adicione a palavra-chave <code>let</code> √† lista de palavras-chave: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keywords = <span class="hljs-string"><span class="hljs-string">" let if then else lambda Œª true false "</span></span>;</code> </pre> <br><p>  Altere a fun√ß√£o <code>parse_lambda</code> que leia um nome opcional: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span> ? input.next().value : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   vars: delimited("(", ")", ",", parse_varname), body: parse_expression() }; }</span></span></code> </pre> <br><p>  Agora adicione uma fun√ß√£o que analise a express√£o <code>let</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_let</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ skip_kw(<span class="hljs-string"><span class="hljs-string">"let"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = input.next().value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defs = delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"call"</span></span>, <span class="hljs-attr"><span class="hljs-attr">func</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.name }), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.def || FALSE }) }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"let"</span></span>, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }; }</code> </pre> <br><p>  Isso lida com dois casos.  Se depois de <code>let</code> existir um token do tipo <code>var</code> , isso ser√° <code>let</code> com um nome.  Al√©m disso, lemos a lista de defini√ß√µes usando a fun√ß√£o <code>delimited</code> , pois est√£o entre colchetes e separadas por v√≠rgulas, e usamos a fun√ß√£o <code>parse_vardef</code> , mostrada abaixo.  Em seguida, retornamos um n√≥ do tipo <code>call</code> , que chama imediatamente uma fun√ß√£o denominada (IIFE).  Os argumentos para a fun√ß√£o s√£o as vari√°veis ‚Äã‚Äãdefinidas por <code>let</code> e o n√≥ de <code>call</code> passar√° os valores como argumentos.  E, √© claro, o corpo da fun√ß√£o √© lido usando <code>parse_expression()</code> . </p><br><p>  Se for um simples <code>let</code> , retornamos um n√≥ do tipo <code>let</code> com os campos <code>vars</code> e <code>body</code> .  O campo <code>vars</code> cont√©m uma matriz de vari√°veis ‚Äã‚Äãno seguinte formato: <code>{ name: VARIABLE, def: AST }</code> , que s√£o analisados ‚Äã‚Äãpela seguinte fun√ß√£o: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_vardef</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = parse_varname(), def; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_op(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) { input.next(); def = parse_expression(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">def</span></span>: def }; }</code> </pre> <br><p>  Al√©m disso, voc√™ precisa adicionar uma verifica√ß√£o para um novo tipo de express√£o na fun√ß√£o <code>parse_atom</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      parse_if if (is_kw("let")) return parse_let();</span></span></code> </pre> <br><h4 id="izmeneniya-v-interpretatore">  Altera√ß√µes de int√©rpretes </h4><br><p>  Como decidimos alterar a estrutura do AST em vez de "quebr√°-lo" nos tipos antigos de n√≥s, devemos adicionar o processamento da nova l√≥gica ao int√©rprete. </p><br><p>  Para adicionar suporte ao nome da fun√ß√£o opcional, modificamos a fun√ß√£o <code>make_lambda</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.name) { <span class="hljs-comment"><span class="hljs-comment">//  env = env.extend(); //  env.def(exp.name, lambda); //  } //  function lambda() { var names = exp.vars; var scope = env.extend(); for (var i = 0; i &lt; names.length; ++i) scope.def(names[i], i &lt; arguments.length ? arguments[i] : false); return evaluate(exp.body, scope); } return lambda; }</span></span></code> </pre> <br><p>  Se a fun√ß√£o tiver um nome, quando criamos o fechamento, fazemos uma c√≥pia do contexto e adicionamos a fun√ß√£o ao contexto.  O resto permanece o mesmo. </p><br><p>  E, finalmente, para processar um n√≥ do tipo <code>let</code> , adicionamos o seguinte caso ao int√©rprete: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"let"</span></span>: exp.vars.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, v.def ? evaluate(v.def, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); env = scope; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, env);</code> </pre> <br><p>  Observe que para cada vari√°vel √© criado um novo contexto no qual uma nova vari√°vel √© adicionada.  Depois disso, simplesmente executamos o corpo no √∫ltimo contexto. </p><br><h4 id="primery">  Exemplos </h4><br><pre> <code class="python hljs">println(let loop (n = <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>); let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = x + <span class="hljs-number"><span class="hljs-number">1</span></span>, z = x + y) println(x + y + z); <span class="hljs-comment"><span class="hljs-comment">#   ..     let # print(x + y + z); let (x = 10) { let (x = x * 2, y = x * x) { println(x); ## 20 println(y); ## 400 }; println(x); ## 10 };</span></span></code> </pre> <br><h4 id="proizvoditelnost-interpretatora">   </h4><br><p>   ‚Äî  . </p><br><p>   .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> , ,           ,     .        JavaScript    Œª. </p><br><p>    : </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"fibJS"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibJS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fibJS(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fibJS(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); }); globalEnv.def(<span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ret = fn(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); println(<span class="hljs-string"><span class="hljs-string">"Time: "</span></span> + (t2 - t1) + <span class="hljs-string"><span class="hljs-string">"ms"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; });</code> </pre> <br><p>  <code>time</code>  ,       ,  ,    . </p><br><pre> <code class="python hljs">fib = Œª(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> then n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); print(<span class="hljs-string"><span class="hljs-string">"fib(10): "</span></span>); time( Œª() println(fib(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); print(<span class="hljs-string"><span class="hljs-string">"fibJS(10): "</span></span>); time( Œª() println(fibJS(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); println(<span class="hljs-string"><span class="hljs-string">"---"</span></span>);</code> </pre> <br><p>   ,   Google Chrome,   n (27),  Œª  ,  ,   JS   4 . , ,  . </p><br><p>       Œª  JavaScript.    ,      <code>for</code> / <code>while</code> ;          JS.        ?  JS   ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>  . </p><br><p> ,         ,          <em> </em> JavaScript,    ,    JavaScript. </p><br><p>    ,  ,  .   ,     . </p><br><h4 id="zaklyuchenie">  Conclus√£o </h4><br><p>       ,       .  ,       - ;  ,       ,            ?   ‚Äî JavaScript. ,         JavaScript ‚Äî     ? ,       ,    JavaScript,        , ,    .  JavaScript    ( ,       ). </p><br><p>  ,    ,  Lisp ‚Äî   :            //.    ,  ,        ..  Lisp  .    Lisp        <code>let</code> ,        ,                Lisp. </p><br><p>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3: Int√©rprete de CPS</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443812/">https://habr.com/ru/post/pt443812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443794/index.html">As principais orienta√ß√µes para startups de TI no campo da venda de im√≥veis</a></li>
<li><a href="../pt443798/index.html">Zotero hacks: armazenamento sincronizado ilimitado e seu uso suave com o rmarkdown</a></li>
<li><a href="../pt443804/index.html">C # √© uma linguagem de baixo n√≠vel?</a></li>
<li><a href="../pt443808/index.html">An√°lise de garotas com baixa responsabilidade social (Cobrada com Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../pt443810/index.html">Quanto ganham os desenvolvedores de diferentes qualifica√ß√µes, 2018</a></li>
<li><a href="../pt443814/index.html">Dar √© o meu "antigo neg√≥cio"</a></li>
<li><a href="../pt443816/index.html">Minist√©rio das Comunica√ß√µes insiste em um √∫nico operador 5G</a></li>
<li><a href="../pt443818/index.html">Resumo dos eventos de TI de mar√ßo (parte dois)</a></li>
<li><a href="../pt443820/index.html">Como o Aeroporto de Fukuoka descobriu quais medidas seriam eficazes para reduzir filas</a></li>
<li><a href="../pt443822/index.html">Orquestra de Performance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>