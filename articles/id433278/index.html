<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰 🐴 🎟️ WebGL-wind dan pemrograman GPU. Kuliah di FrontTalks 2018 🐛 🤸🏼 🐎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk rendering grafik yang kompleks pada halaman web, ada Web Graphics Library, disingkat sebagai WebGL. Perancang antarmuka Dmitry Vasiliev berbicar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebGL-wind dan pemrograman GPU. Kuliah di FrontTalks 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/433278/">  Untuk rendering grafik yang kompleks pada halaman web, ada Web Graphics Library, disingkat sebagai WebGL.  Perancang antarmuka Dmitry Vasiliev berbicara tentang pemrograman GPU dari sudut pandang perancang tata letak, tentang apa itu WebGL dan bagaimana kami memecahkan masalah memvisualisasikan data cuaca besar menggunakan teknologi ini. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-yvY4-ovavo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Saya sedang mengembangkan antarmuka di kantor Yekaterinburg Yandex.  Saya mulai dalam kelompok Olahraga.  Kami sedang mengembangkan proyek olahraga khusus ketika ada Kejuaraan Dunia dalam hoki, sepak bola, Olimpiade, Paralimpiade dan acara keren lainnya.  Saya juga bekerja pada pengembangan hasil pencarian khusus, yang didedikasikan untuk trek Sochi baru. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/5p/l2/e_/5pl2e_nhpyefyjt0q3wfspflpyc.jpeg"><br><br><img src="https://habrastorage.org/webt/qw/zy/xd/qwzyxdlvu0jukewd-9prrerk-a8.jpeg"><br><br><img src="https://habrastorage.org/webt/uy/7b/mp/uy7bmpkufgne4mck5yiawv3mj1o.jpeg"><br><br><img src="https://habrastorage.org/webt/q6/cu/kw/q6cukwvmpmwru6iew_ranhk7mwo.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sup></sub> </h5><br>  Selain itu, dalam satu setengah helm, kami memulai kembali layanan Work on Errors.  Dan kemudian pekerjaan dimulai di Pogoda, di mana saya terlibat dalam mendukung pengoperasian API, pengembangannya, menulis infrastruktur di sekitar API ini dan menulis pengikat simpul untuk formula pembelajaran mesin yang terlatih. <br><br><img src="https://habrastorage.org/webt/sz/xs/zy/szxszynumbssi9qyhkxwalfmsdy.jpeg"><br><br>  Kemudian pekerjaan mulai lebih menarik.  Berpartisipasi dalam desain ulang layanan cuaca kami.  Desktop, gerobak dorong. <br><br><img src="https://habrastorage.org/webt/io/q4/cw/ioq4cwweh1vbjyqonlto5yuo_1e.jpeg"><br><br><img src="https://habrastorage.org/webt/ij/er/w6/ijerw62hpfkj2kvph4wvuag_www.jpeg"><br><br>  Setelah kami menyusun prakiraan standar, kami memutuskan untuk membuat prakiraan yang tidak dimiliki siapa pun.  Prakiraan ini adalah ramalan untuk pergerakan curah hujan di seluruh wilayah. <br><br><img src="https://habrastorage.org/webt/xc/n_/cf/xcn_cfakd_xnyoxaazxgc4bvmso.jpeg"><br><br>  Ada radar cuaca khusus yang mendeteksi curah hujan dalam radius 2000 km, mereka tahu kepadatan dan jaraknya. <br><br><img src="https://habrastorage.org/webt/as/ea/av/aseaavvwl0v3lqhex1kx_dvsr1w.jpeg"><br><br>  Dengan menggunakan data ini dan memprediksi dengan bantuan mesin mempelajari pergerakan mereka selanjutnya, kami membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">visualisasi</a> pada peta.  Anda bisa bergerak maju dan mundur. <br><br><img src="https://habrastorage.org/webt/jt/qo/fj/jtqofjz8eo8wrjybcydczpxse0a.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sup></sub> </h5><br>  Kami melihat ulasan orang.  Orang-orang menyukainya.  Semua jenis meme mulai muncul, dan ada foto-foto keren ketika Moskow membanjiri neraka. <br><br>  Karena semua orang menyukai formatnya, kami memutuskan untuk melanjutkan dan mencurahkan ramalan berikut ke angin. <br><br><img src="https://habrastorage.org/webt/kl/mc/_f/klmc_fqnedxn-okos6d6bhmlszs.jpeg"><br><br>  Layanan yang menunjukkan perkiraan angin sudah ada di sana.  Ini adalah beberapa yang berkelas yang menonjol. <br><br><img src="https://habrastorage.org/webt/vo/vc/4k/vovc4kev5lhxvyph9t46z4uhei8.jpeg"><br><br>  Melihat mereka, kami menyadari bahwa kami ingin melakukan hal yang sama - atau setidaknya tidak lebih buruk. <br><br>  Oleh karena itu, kami memutuskan untuk memvisualisasikan partikel yang bergerak dengan lancar di peta tergantung pada kecepatan angin, dan meninggalkan semacam lingkaran sehingga mereka dapat dilihat, lintasan angin dapat terlihat. <br><br>  Karena kami sudah hebat dan membuat peta keren dengan curah hujan menggunakan kanvas 2D, kami memutuskan untuk melakukan hal yang sama dengan partikel. <br><br><img src="https://habrastorage.org/webt/hz/jd/yi/hzjdyivbulbjmfod7n2-nix8uca.jpeg"><br><br>  Setelah berkonsultasi dengan perancang, kami menyadari bahwa kami perlu mengisi sekitar 6% layar dengan partikel untuk mendapatkan efek keren. <br><br>  Untuk menggambar sejumlah partikel menggunakan pendekatan standar, kami memiliki waktu minimum 5 ms. <br><br><img src="https://habrastorage.org/webt/yu/l1/7n/yul17ngn7dfm6cadtcy2dpkf6zu.jpeg"><br><br>  Jika Anda berpikir bahwa kita masih perlu menggerakkan partikel dan membawa beberapa jenis keindahan seperti menggambar ekor partikel, kita dapat mengasumsikan bahwa kita akan jatuh untuk waktu minimum 40 ms untuk menampilkan animasi yang halus untuk menghasilkan setidaknya 25 frame per detik. <br><br>  Masalahnya adalah bahwa di sini setiap partikel akan diproses secara berurutan.  Tetapi bagaimana jika Anda memprosesnya secara paralel? <br><br>  Perbedaan yang jelas antara pengoperasian prosesor sentral dan grafis ditunjukkan oleh "Legend Destroyers" di salah satu konferensi.  Mereka meluncurkan mesin tempat penanda paintball dipasang, tugasnya adalah menggambar smiley dalam satu warna.  Dalam sekitar 10 detik, dia menggambar seperti itu.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan ke video</a> - kira-kira.) <br><br><img src="https://habrastorage.org/webt/kk/pi/cw/kkpicwfdskxnicbu0jb7sowhgfq.jpeg"><br><br><img src="https://habrastorage.org/webt/zd/ka/3a/zdka3al72tgfcavb5yvww_qx2ug.jpeg"><br><br><img src="https://habrastorage.org/webt/i9/tm/kh/i9tmkhykoiz8vkim-vzftxjjl44.jpeg"><br><br>  Kemudian orang-orang meluncurkan sampan, yang merupakan GPU, dan beberapa meludah melukis Mona Lisa.  Inilah perbedaan kecepatan komputasi CPU dan GPU. <br><br><img src="https://habrastorage.org/webt/dm/x-/hc/dmx-hckqzdlztdat2wm-j88cj-k.jpeg"><br><br><img src="https://habrastorage.org/webt/zg/pa/3m/zgpa3m281vzirvjqotbuoqnmms8.jpeg"><br><br><img src="https://habrastorage.org/webt/hq/lf/uj/hqlfujoqgr4mhgxucjpx7xnmedu.jpeg"><br><br><img src="https://habrastorage.org/webt/qb/zo/xz/qbzoxzq0tywqxi0pc2xifdnvnds.jpeg"><br><br><img src="https://habrastorage.org/webt/d6/z5/kq/d6z5kq5c23fjmb2uzfx4aqqj3ec.jpeg"><br><br>  Untuk memanfaatkan fitur-fitur tersebut di browser, teknologi WebGL diciptakan. <br><br>  Apa ini  Dengan pertanyaan ini, saya naik ke Internet.  Menambahkan beberapa kata dengan animasi partikel dan angin, saya menemukan beberapa artikel. <br><br><img src="https://habrastorage.org/webt/ob/d-/w_/obd-w_edp80lvmzlh3xmh437itw.jpeg"><br><h5>  <sub><sup>Tautan dari slide: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a></sup></sub> </h5><br>  Salah satunya adalah demo Vladimir Agafonkin, seorang insinyur dari Mapbox, yang membuat angin di WebGL dan merujuk ke blog Chris Wellons, yang berbicara tentang cara memindahkan dan menyimpan keadaan partikel pada GPU. <br><br>  Kami mengambil dan menyalin.  Kami mengharapkan hasil seperti itu.  Di sini partikel-partikel bergerak dengan lancar. <br><br><img src="https://habrastorage.org/webt/s6/5t/7-/s65t7-020jphv-fvyzbk5vpkmoq.jpeg"><br><br>  Kami tidak mengerti apa. <br><br><img src="https://habrastorage.org/webt/7n/8i/t1/7n8it1gwmfklms2akt9nydmgima.jpeg"><br><br>  Mencoba mencari tahu kodenya.  Meningkatkan, sekali lagi mendapatkan hasil yang tidak memuaskan.  Kami mendaki lebih dalam lagi - kami mendapat hujan alih-alih angin. <br><br><img src="https://habrastorage.org/webt/n4/bd/b1/n4bdb1-ar38mb8lokfjfgjqbrue.jpeg"><br><br>  Oke, kami memutuskan untuk melakukannya sendiri. <br><br><img src="https://habrastorage.org/webt/lw/ue/kv/lwuekvj_c1996sjj2q1c2fl4pyk.jpeg"><br><br>  Untuk bekerja dengan WebGL, ada kerangka kerja.  Hampir semuanya ditujukan untuk bekerja dengan objek 3D.  Kami tidak membutuhkan kemampuan 3D ini.  Kita hanya perlu menggambar partikel dan memindahkannya.  Karena itu, kami memutuskan untuk melakukan segalanya dengan tangan kami. <br><br><img src="https://habrastorage.org/webt/rt/db/4z/rtdb4zokw74ivcedzljp4t3fu_g.jpeg"><br><br>  Saat ini ada dua versi teknologi WebGL.  Versi kedua, yang keren, memiliki versi bahasa pemrograman modern yang tinggi di mana program dijalankan dalam adapter grafis, dapat langsung melakukan perhitungan, dan tidak hanya menggambar.  Tetapi memiliki kompatibilitas yang buruk. <br><br><img src="https://habrastorage.org/webt/yk/gr/ty/ykgrtypkwclnix0f4pat1retheu.jpeg"><br><br>  Yah, kami memutuskan untuk menggunakan WebGL 1 yang sudah terbukti lama, yang memiliki dukungan yang baik selain Opera Mini, yang tidak diperlukan siapa pun. <br><br><img src="https://habrastorage.org/webt/sr/1q/xr/sr1qxr_ch7enl9z1rjwuv1hshpg.jpeg"><br><br>  WebGL adalah hal dua komponen.  Ini adalah JS yang menjalankan status program yang berjalan pada kartu grafis.  Dan ada komponen yang berjalan langsung di kartu grafis. <br><br>  Mari kita mulai dengan JS.  WebGL hanyalah konteks yang tepat untuk elemen kanvas.  Selain itu, setelah menerima konteks ini, bukan hanya objek spesifik yang dialokasikan, sumber daya besi dialokasikan.  Dan jika kita menjalankan sesuatu yang indah di WebGL di browser, dan kemudian memutuskan untuk bermain Quake, maka sangat mungkin bahwa sumber daya ini akan hilang, dan konteksnya bisa hilang, dan seluruh program Anda akan rusak. <br><br><img src="https://habrastorage.org/webt/y3/bm/p0/y3bmp0fddy1vkxkktxantfrfcdw.jpeg"><br><br>  Karena itu, ketika bekerja dengan WebGL, Anda juga harus mendengarkan hilangnya konteks dan dapat memulihkannya.  Karena itu, saya menekankan bahwa init adalah. <br><br><img src="https://habrastorage.org/webt/aj/iu/zk/ajiuzkpsukwyhrhvte4oduqivri.jpeg"><br><br>  Selanjutnya, semua pekerjaan JS bermuara pada mengumpulkan program yang berjalan pada GPU, mengirimkannya kartu grafis, mengatur beberapa parameter dan mengatakan "menggambar". <br><br><img src="https://habrastorage.org/webt/3k/2m/zd/3k2mzdhdejzpaxjrx_upik6fdeu.jpeg"><br><br>  Di WebGL, jika Anda melihat elemen konteks itu sendiri, Anda melihat sekelompok konstanta.  Konstanta ini merujuk ke alamat dalam memori.  Mereka tidak benar-benar konstan dalam proses program.  Karena jika konteksnya hilang dan dikembalikan lagi, kumpulan alamat lain mungkin dialokasikan, dan konstanta ini akan berbeda untuk konteks saat ini.  Oleh karena itu, hampir semua operasi di WebGL di sisi JS dilakukan melalui utilitas.  Tidak ada yang ingin melakukan pekerjaan rutin untuk menemukan alamat dan sampah lainnya. <br><br><img src="https://habrastorage.org/webt/ii/o7/sa/iio7sahs5z0gt5bccxesgiict44.jpeg"><br><br>  Kami beralih ke apa yang dilakukan pada kartu video itu sendiri - sebuah program yang terdiri dari dua set instruksi yang ditulis dalam bahasa C-like GLSL.  Instruksi ini disebut vertex shader dan fragment shader.  Suatu program dibuat dari pasangannya. <br><br><img src="https://habrastorage.org/webt/qg/fu/lb/qgfulbs6almqwpkmutcsxv38-cm.jpeg"><br><br>  Apa perbedaan antara shader ini?  Vertex shader menetapkan permukaan tempat sesuatu harus ditarik.  Setelah primitif diatur, yang harus dicat, shader fragmen yang termasuk dalam kisaran ini disebut. <br><br><img src="https://habrastorage.org/webt/up/h_/ya/uph_yasoh3q-99otxdym43zykmw.jpeg"><br><br><img src="https://habrastorage.org/webt/u7/vi/qb/u7viqbviwm76x4ovlvion5mm2o8.jpeg"><br><br>  Dalam kode, tampilannya seperti ini.  Shader memiliki bagian untuk mendeklarasikan variabel yang ditetapkan secara eksternal dari JS, tipe dan namanya ditentukan.  Serta bagian utama, yang mengeksekusi kode yang diperlukan untuk iterasi ini. <br><br>  Vertex shader dalam kebanyakan kasus diharapkan untuk mengatur variabel gl_Position ke beberapa koordinat dalam ruang empat dimensi.  Ini adalah x, y, z dan lebar ruang, yang tidak perlu diketahui saat ini. <br><br>  Shader fragmen berharap untuk mengatur warna piksel tertentu. <br><br>  Dalam contoh ini, kami memiliki warna piksel yang dipilih dari tekstur yang terhubung. <br><br><img src="https://habrastorage.org/webt/y8/nw/1y/y8nw1y1gnwstkv2rgqxatduyuni.jpeg"><br><br>  Untuk mentransfer ini ke JS, cukup bungkus kode sumber shader dalam variabel. <br><br><img src="https://habrastorage.org/webt/ax/fz/ou/axfzouj0xwui47sftwgdhlcadd0.jpeg"><br><br>  Selanjutnya variabel-variabel ini ditransformasikan menjadi shader.  Ini adalah konteks WebGL, kami membuat shader dari kode sumber, membuat program secara paralel, dan kami melampirkan beberapa shader ke program.  Kami mendapatkan program yang bisa diterapkan. <br><br>  Dalam perjalanan, kami memverifikasi bahwa kompilasi shader berhasil, bahwa program berhasil dibuat.  Kami mengatakan bahwa Anda perlu menggunakan program ini, karena mungkin ada beberapa program untuk nilai rendering yang berbeda. <br><br>  Atur dan katakan gambar.  Ternyata semacam gambar. <br><br><img src="https://habrastorage.org/webt/oz/py/ri/ozpyrifyoft_invjrawmmz-_fjg.jpeg"><br><br>  Naik lebih dalam.  Di vertex shader, semua perhitungan dilakukan dalam ruang dari -1 hingga 1, terlepas dari ukuran titik output Anda.  Misalnya, ruang dari -1 hingga 1 dapat menempati seluruh layar 1920x1080. Untuk menggambar segitiga di tengah layar, Anda perlu menggambar permukaan yang mencakup koordinat 0, 0. <br><br><img src="https://habrastorage.org/webt/4q/yp/ex/4qypexiothorcvzkrk9y_p5v9tk.jpeg"><br><br>  Shader fragmen bekerja di ruang dari 0 hingga 1, dan warna ditampilkan oleh empat komponen: R, G, B, Alpha. <br><br>  Menggunakan CSS sebagai contoh, Anda mungkin menemukan notasi warna yang sama saat menggunakan persentase. <br><br><img src="https://habrastorage.org/webt/ys/cn/kn/yscnkn-8x_yg0bl_zknm-42l17q.jpeg"><br><br>  Untuk menggambar sesuatu, Anda perlu mengatakan data apa yang perlu diambil.  Khusus untuk segitiga, kita mendefinisikan larik yang diketik dari tiga simpul, masing-masing terdiri dari tiga komponen, x, y dan cukup. <br><br>  Untuk kasus ini, vertex shader terlihat seperti mendapatkan pasangan titik saat ini, koordinat, serta mengatur koordinat ini di layar.  Di sini, sebagaimana adanya, tanpa transformasi, kami menempatkan titik di layar. <br><br><img src="https://habrastorage.org/webt/up/h_/ya/uph_yasoh3q-99otxdym43zykmw.jpeg"><br><br>  Shader fragmen dapat mewarnai konstanta yang dilewatkan dari JS dengan warna, juga tanpa perhitungan tambahan.  Selain itu, jika beberapa variabel dalam fragmen shader ditransfer dari luar atau dari shader sebelumnya, maka akurasi harus ditentukan.  Dalam hal ini, akurasi sedang sudah cukup, dan hampir selalu sudah cukup. <br><br><img src="https://habrastorage.org/webt/dx/9v/jb/dx9vjbxuiz_swlbl1hlmlb5hmys.jpeg"><br><br>  Kami lolos ke JS.  Kami menetapkan shader yang sama ke variabel dan mendeklarasikan fungsi yang akan membuat shader ini.  Yaitu, shader dibuat, sumber dituangkan ke dalamnya, dan kemudian dikompilasi. <br><br><img src="https://habrastorage.org/webt/jf/x3/eg/jfx3eg-hhqsdbmpc378peyi6tym.jpeg"><br><br>  Kami membuat dua shader, vertex dan fragmen. <br><br><img src="https://habrastorage.org/webt/jh/pb/um/jhpbumsovp4-rkstmx9dldtg7ug.jpeg"><br><br>  Setelah itu, buat program, unggah shader yang sudah dikompilasi ke dalamnya.  Kami mengikat program karena shader dapat bertukar variabel antara satu sama lain.  Dan pada tahap ini, korespondensi dari jenis-jenis variabel yang ditukar dengan shader diperiksa. <br><br>  Kami mengatakan bahwa gunakan program ini. <br><br><img src="https://habrastorage.org/webt/7i/hm/rc/7ihmrctum2gyy9cuybn5pr6hcbu.jpeg"><br><br>  Selanjutnya, kita membuat daftar simpul yang ingin kita visualisasikan.  WebGL memiliki fitur menarik untuk beberapa variabel.  Untuk mengubah tipe data tertentu, Anda perlu mengatur konteks global untuk mengedit array_buffer, dan kemudian mengunggah sesuatu ke alamat ini.  Tidak ada tugas eksplisit dari data apa pun untuk variabel.  Semuanya dilakukan melalui dimasukkannya beberapa konteks. <br><br>  Anda juga perlu menetapkan aturan untuk membaca dari buffer ini.  Dapat dilihat bahwa kami menetapkan array dari enam elemen, tetapi program perlu menjelaskan bahwa setiap vertex terdiri dari dua komponen, tipe yang float, ini dilakukan pada baris terakhir. <br><br><img src="https://habrastorage.org/webt/js/_j/qe/js_jqevmwlq0fmo_n6-vbdwsr-k.jpeg"><br><br>  Untuk mengatur warna, program mencari alamat untuk variabel u_color dan menetapkan nilai untuk variabel ini.  Kami mengatur warna, merah 255, 0,8 dari hijau, 0 biru dan piksel yang sepenuhnya buram - berubah menjadi kuning.  Dan kami katakan untuk menjalankan program ini menggunakan segitiga primitif, di WebGL Anda dapat menggambar titik, garis, segitiga, segitiga bentuk kompleks, dan sebagainya.  Dan buat tiga puncak. <br><br><img src="https://habrastorage.org/webt/lk/pz/xe/lkpzxe_tur-bgozsoj47kohstty.jpeg"><br><br>  Anda juga dapat menentukan bahwa array yang kita render harus dihitung sejak awal. <br><br><img src="https://habrastorage.org/webt/p4/1f/_k/p41f_kioprwkxx7ommkzz7tcclw.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sup></sub> </h5><br>  Jika Anda sedikit menyulitkan contoh, Anda dapat menambahkan ketergantungan warna pada posisi kursor.  Pada saat yang sama, fps melewati atap. <br><br><img src="https://habrastorage.org/webt/sl/eu/zl/sleuzlnxn8s1tlflhawo5obsrg8.jpeg"><br><br>  Untuk menggambar partikel di seluruh dunia, Anda perlu mengetahui kecepatan angin di setiap titik di dunia ini. <br><br>  Untuk memperbesar dan memindahkan peta, Anda harus membuat wadah yang cocok dengan posisi peta saat ini. <br><br>  Untuk memindahkan partikelnya sendiri, Anda harus membuat format data yang dapat diperbarui menggunakan GPU.  Buat gambar itu sendiri dan gambar lingkaran. <br><br><img src="https://habrastorage.org/webt/2o/vf/o_/2ovfo_hqaimoyygbbcpkbupf_cu.jpeg"><br><br>  Kami melakukan semua data melalui tekstur.  Kami menggunakan 22 saluran untuk menentukan kecepatan horizontal dan vertikal, di mana kecepatan angin nol sesuai dengan bagian tengah rentang warna.  Ini sekitar 128.  Karena kecepatannya bisa negatif dan positif, kami mengatur warna relatif ke tengah kisaran. <br><br>  Ternyata gambar seperti itu. <br><br><img src="https://habrastorage.org/webt/3-/qu/i8/3-qui8mkzufp6hucltuzpampili.jpeg"><br><br>  Untuk memuatnya di kartu, kita perlu memotongnya.  Untuk menghubungkan gambar ke peta, kita akan menggunakan alat Lapisan Yandex.Map standar, di mana kita menentukan alamat dari mana untuk memotong ubin, dan menambahkan lapisan ini ke peta. <br><br><img src="https://habrastorage.org/webt/jo/zj/a8/jozja8duysio2wljyezgjnhfn64.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sup></sub> </h5><br>  Kami mendapatkan gambar di mana warna hijau yang tidak menyenangkan diberi kode kecepatan angin. <br><br><img src="https://habrastorage.org/webt/uh/nk/jh/uhnkjh1e8sxzgzp-myix3xxyjn4.jpeg"><br><br>  Selanjutnya, Anda perlu mendapatkan tempat di mana kami akan menggambar animasi itu sendiri, sementara tempat ini harus sesuai dengan koordinat peta, gerakannya dan tindakan lainnya. <br><br>  Secara default, kita dapat mengasumsikan bahwa kita akan menggunakan Layer, tetapi Layer kartu menciptakan kanvas dari mana ia segera menangkap konteks 2D yang dapat ditangkap.  Tetapi jika kita mencoba untuk mengambil dari kanvas, yang sudah memiliki konteks dari tipe yang berbeda, dan mengambil darinya konteks GL, kita mendapatkan null sebagai hasilnya.  Jika Anda mengaksesnya, program macet. <br><br><img src="https://habrastorage.org/webt/lg/9a/mn/lg9amncxtx9ndmnc7bjqkzcs_lw.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sup></sub> </h5><br>  Oleh karena itu, kami menggunakan Pane, ini adalah wadah untuk tata letak, dan menambahkan kanvas kami di sana, dari mana kami telah mengambil konteks yang kami butuhkan. <br><br><img src="https://habrastorage.org/webt/v9/on/pb/v9onpb5gnorqq05kg0og8bd6wvq.jpeg"><br><br>  Untuk mengatur partikel di layar dan memindahkannya, format posisi partikel dalam tekstur digunakan. <br><br>  Bagaimana cara kerjanya?  Tekstur persegi dibuat untuk optimasi, dan di sini ukuran sisinya diketahui. <br><br><img src="https://habrastorage.org/webt/ov/hm/qg/ovhmqgdfgbzg3k5wua7se3l-scm.jpeg"><br><br>  Dengan menggambar partikel secara berurutan dan mengetahui nomor seri partikel dan ukuran tekstur tempat penyimpanannya, Anda dapat menghitung piksel tertentu tempat posisi pada layar nyata dikodekan. <br><br><img src="https://habrastorage.org/webt/xw/6c/ly/xw6clysjjqrtppxzih0cm4q3sis.jpeg"><br><br><img src="https://habrastorage.org/webt/a_/jt/9m/a_jt9ml9jdjn0vxxk7riv9sbkw8.jpeg"><br><br>  Dalam shader itu sendiri, sepertinya membaca indeks yang diberikan, tekstur dengan posisi partikel saat ini dan ukuran sisi.  Selanjutnya, kita menentukan koordinat x, y untuk partikel ini, membaca nilai ini dan mendekodekannya.  Macam apa sihir ini: rg / 255 + ba? <br><br>  Untuk posisi partikel kami menggunakan 20 saluran ganda.  Saluran warna memiliki nilai dari 0 hingga 255, dan untuk layar 1080 kami tidak dapat menempatkan partikel pada posisi layar sedikitpun, karena kami dapat menempatkan maksimum pada 255 piksel paling banyak.  Oleh karena itu, dalam satu saluran kami menyimpan pengetahuan tentang berapa kali sebuah partikel telah melewati 255 piksel, dan di saluran kedua kami menyimpan nilai persis berapa banyak partikel yang dilewatinya. <br><br>  Selanjutnya, vertex shader harus mengonversi nilai-nilai ini ke ruang kerjanya, yaitu dari -1 hingga 1, dan mengatur titik ini pada tampilan. <br><br><img src="https://habrastorage.org/webt/g2/ht/g_/g2htg_vqu8k5fdnn_zx6xtl82fs.jpeg"><br><br>  Untuk melihat partikel-partikel kita, cat saja dengan warna putih.  GLSL memiliki gula sedemikian rupa sehingga jika kita mendefinisikan jenis variabel dan meneruskannya menjadi konstanta, maka konstanta ini akan didistribusikan ke keempat komponen, misalnya. <br><br><img src="https://habrastorage.org/webt/ee/h-/hz/eeh-hzn9oaitmm7k7gwfpzin8rq.jpeg"><br><br>  Setelah menggambar program seperti itu, kami melihat satu set kotak yang identik.  Mari kita coba tambahkan keindahan pada mereka. <br><br><img src="https://habrastorage.org/webt/-r/ud/i1/-rudi16ytlwsw-_fvafdhqmqync.jpeg"><br><br>  Pertama, tambahkan ketergantungan kotak ini pada kecepatan angin saat ini.  Kami cukup membaca kecepatan saat ini dan tekstur yang sesuai untuk setiap partikel.  Kami mendapatkan panjang vektor, yang sesuai dengan kecepatan absolut pada titik tersebut, dan menambahkan kecepatan ini ke ukuran partikel. <br><br><img src="https://habrastorage.org/webt/or/v-/qs/orv-qs0vwvlrcxadmlpvbywokdw.jpeg"><br><br>  Selanjutnya, agar tidak menggambar kotak, dalam fragmen shader kami memotong semua piksel yang berada di luar jari-jari, yang tidak termasuk dalam jari-jari lingkaran yang tertulis.  Artinya, shader kita berubah menjadi hal seperti itu. <br><br><img src="https://habrastorage.org/webt/t4/rx/ah/t4rxahmunedzb3k0jamjxiikvia.jpeg"><br><br>  Kami menghitung jarak ke piksel yang diberikan dari pusat.  Jika melebihi setengah ruang, maka kami tidak menunjukkannya. <br><br><img src="https://habrastorage.org/webt/nr/do/ma/nrdomaus-zdhgroynefo3qacxck.jpeg"><br><br>  Kami mendapatkan gambaran yang lebih beragam. <br><br>  Selanjutnya, Anda harus memindahkan barang-barang ini.  Karena WebGL 1 tidak tahu cara menghitung sesuatu, bekerja secara langsung dengan data, kami akan mengambil keuntungan dari kemampuan untuk membuat program menjadi komponen khusus, bingkai buffer. <br><br>  Frame buffer dapat dipetakan, misalnya, ke tekstur yang dapat diperbarui.  Jika frame buffer tidak dideklarasikan, maka menggambar secara default dilakukan di layar. <br><br>  Mengubah output dari satu posisi tekstur ke posisi lain, kita dapat memperbaruinya satu per satu dan kemudian menggunakannya untuk rendering. <br><br><img src="https://habrastorage.org/webt/j7/-j/tn/j7-jtnjwzj-8pav52t-ngiolwji.jpeg"><br><br><img src="https://habrastorage.org/webt/8y/me/ey/8ymeey1havzw-wavn5x8ztr87em.jpeg"><br><br>  Prosedur untuk memperbarui posisi itu sendiri terlihat seperti ini: baca posisi saat ini, tambahkan ke vektor kecepatan saat ini dan tambahkan, disandikan dengan warna baru. <br><br><img src="https://habrastorage.org/webt/t7/up/wj/t7upwjpzr8ubgig0cwr1_hn7npa.jpeg"><br><br>  Dalam kode, sepertinya membaca posisi saat ini, decoding, membaca kecepatan saat ini, membawa kecepatan ke normal, melipat dua komponen, mengkode warna. <br><br><img src="https://habrastorage.org/webt/uo/cc/qo/uoccqo8i2fubmgay3oi90teclzw.jpeg"><br><br>  Ternyata gambar seperti itu.  Keadaan partikel terus berubah, dan beberapa jenis animasi muncul. <br><br>  Jika Anda menjalankan animasi seperti itu selama 5-10 menit, akan jelas bahwa semua partikel akan tiba di tujuan akhir mereka.  Mereka semua meluncur ke corong.  Anda mendapatkan gambar seperti itu. <br><br><img src="https://habrastorage.org/webt/be/m0/bx/bem0bxbrxar_it9lgdjdc2fk91y.jpeg"><br><br>  Untuk menghindari ini, kami memperkenalkan faktor permutasi partikel di tempat acak. <br><br>  Itu tergantung pada kecepatan angin saat ini, pada posisi partikel saat ini dan nomor acak yang kami transmisikan dari JS - karena versi pertama WebGL tidak memiliki fungsi pengacakan dan beberapa jenis fungsi noise. <br><br><img src="https://habrastorage.org/webt/zt/ur/_b/ztur_bhp_epcyqk1kzaz9b1r0a0.jpeg"><br><br>  Dalam contoh ini, kami menghitung posisi partikel yang diprediksi, posisi acak, dan memilih salah satu atau yang lain, tergantung pada faktor reset. <br><br><img src="https://habrastorage.org/webt/6o/qq/m8/6oqqm8iswgovcsguseunzhwxauc.jpeg"><br><h5>  <sub><sup>Tautan dari slide: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ketiga</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keempat</a></sup></sub> </h5><br>  Untuk memahami apa yang ada di slide terakhir, Anda dapat membaca artikel ini.  Yang pertama memberikan dorongan besar dalam memahami apa yang disediakan WebGL, terdiri dari apa dan bagaimana tidak membuat kesalahan di dalamnya.  Di Khronos, ini adalah kelompok yang terlibat dalam pengembangan standar, ada deskripsi semua fungsi. <br><br><img src="https://habrastorage.org/webt/5u/qi/st/5uqistm5t05pqha9xfm1oqdnxfu.jpeg"><br><br>  Poin terakhir dari tugas kita adalah menggambar jejak partikel.   ,   ,     ,         ,      ,    ,     ,            . <br><br><img src="https://habrastorage.org/webt/es/-8/oa/es-8oakhvm9ds8uh-e7teuivgnk.jpeg"><br><br>      . <br><br><img src="https://habrastorage.org/webt/qv/2s/hi/qv2shigmfokikarpx9kzdx0vsck.jpeg"><br><br><img src="https://habrastorage.org/webt/mu/3s/x2/mu3sx2aovopotm_gnyln8to95rm.jpeg"><br><br>      WebGL         2D canvas,      .   64 .   2D canvas,    25 ,     WebGL     0,3 .     . <br><br>  ,  WebGL     ,        ,      . <br><br>   , ,    ,   - break points, -  ,   . WebGL —  . <br><br><img src="https://habrastorage.org/webt/6l/ke/u_/6lkeu_xuquuzt8pjc1uj8ckv1fa.jpeg"><br><br>    ,     . ,  Firefox    «»,        WebGL-,    ,    ,     . ,          . <br><br><img src="https://habrastorage.org/webt/w1/0j/vs/w10jvskiqvyvfrvhqwr4mpnu2uk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alat kedua yang membuat hidup jauh lebih mudah adalah ekstensi browser Spector.js. </font><font style="vertical-align: inherit;">Ini juga menangkap kanvas dari konteks WebGL dan memungkinkan Anda untuk melihat semua operasi yang dilakukan pada kanvas ini, pengaturan waktu dan variabel lewat. </font></font><br><br><img src="https://habrastorage.org/webt/o-/gm/sa/o-gmsa_uu9gddh7qzrept9418ne.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total selama seminggu bekerja, dari awal kami mendapat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solusi turnkey</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di angin. </font><font style="vertical-align: inherit;">Saya harap saya bisa mengetahui jenis teknologi ini, WebGL, terdiri dari apa, dan memberikan contoh nyata penggunaannya dalam produk. </font><font style="vertical-align: inherit;">Itu saja.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433278/">https://habr.com/ru/post/id433278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433268/index.html">Klien PHP Telegram (dan menerima pesan menggunakan MadelineProto)</a></li>
<li><a href="../id433270/index.html">Pemecahan Masalah MapStruct dengan ManyToMany</a></li>
<li><a href="../id433272/index.html">Wawancara dengan David Gobel</a></li>
<li><a href="../id433274/index.html">Oleg Dokuka tentang pengembangan reaktif di jug.msk.ru</a></li>
<li><a href="../id433276/index.html">Tentang manfaat menanamkan CSS di JS</a></li>
<li><a href="../id433280/index.html">Konferensi DEFCON 18. Teknik Reverse Trollim Menggunakan Matematika</a></li>
<li><a href="../id433282/index.html">Gateway protokol pertukaran industri di Linux. Kumpulkan dirimu</a></li>
<li><a href="../id433286/index.html">10 rapat IT dan hackathon terdekat di Moskow</a></li>
<li><a href="../id433288/index.html">Keamanan Web: Pengantar HTTP</a></li>
<li><a href="../id433292/index.html">Intisari materi menarik untuk pengembang ponsel # 279 (pada 10 - 16 Desember)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>