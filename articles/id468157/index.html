<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ½ ğŸµ ğŸ¤ŸğŸ½ Perspektif EcmaScript pada teori umum OOP ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¾ ğŸ¹ ğŸšœ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Sampai hari ini, saya hanya menerjemahkan artikel yang menarik menurut penulis berbahasa Inggris. Dan sekarang saatnya untuk menulis se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perspektif EcmaScript pada teori umum OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468157/"> Halo, Habr! <br><br>  Sampai hari ini, saya hanya menerjemahkan artikel yang menarik menurut penulis berbahasa Inggris.  Dan sekarang saatnya untuk menulis sesuatu sendiri.  Untuk artikel pertama, saya memilih topik yang, saya yakin, akan bermanfaat bagi pengembang junior yang ingin berkembang ke "menengah", karena  itu akan menganalisis kesamaan / perbedaan antara JavaScript dan bahasa pemrograman klasik (C ++, C #, Java) dalam hal OOP.  Jadi mari kita mulai! <br><br><h3>  Ketentuan umum paradigma </h3><br>  Jika kita melihat definisi JavaScript di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> , kita akan melihat konsep berikut: <br><blockquote>  JavaScript (/ ËˆdÊ’É‘ËvÉ‘ËËŒskrÉªpt /; abbr. JS /ËˆdÊ’eÉª.É›s./) adalah bahasa pemrograman multi-paradigma.  Mendukung gaya berorientasi objek, imperatif dan fungsional.  Ini adalah implementasi dari bahasa ECMAScript (standar ECMA-262). </blockquote><br>  Sebagai berikut dari definisi ini, JavaScript tidak ada dengan sendirinya, tetapi merupakan implementasi dari beberapa spesifikasi EcmaScript.  Selain itu, bahasa lain menerapkan spesifikasi ini. <br><a name="habracut"></a><br>  Paradigma berikut ini hadir dalam EcmaScript (selanjutnya disebut ES): <br><br><ul><li>  struktural </li><li>  OOP </li><li>  fungsional </li><li>  sangat penting </li><li>  berorientasi pada aspek (dalam kasus yang jarang terjadi) </li></ul><br>  OOP dalam ES diimplementasikan pada <i>organisasi prototipe</i> .  Dari pengembang pemula menanggapi pertanyaan: "Bagaimana OOP di JS berbeda dari OOP dalam bahasa klasik."  Sebagai aturan, mereka menjadi sangat samar: "Kelas dalam bahasa klasik, dan prototipe dalam JS". <br><br>  Pada kenyataannya, situasinya sedikit lebih rumit.  Dalam hal perilaku, perbedaan antara <i>Organisasi Kelas Dinamis</i> dan <i>Organisasi Prototipe</i> kecil (pasti ada, tetapi tidak begitu global). <br><br>  Lihatlah Python atau Ruby.  Dalam bahasa-bahasa ini, OOP didasarkan pada organisasi kelas yang dinamis.  Dalam kedua bahasa ini, kita dapat secara dinamis mengubah kelas suatu objek saat program berlangsung dan perubahan di dalam kelas juga secara dinamis memengaruhi entitas yang dihasilkannya.  Sama seperti di JS, tetapi di JS, OOP didasarkan pada prototipe. <br><br>  Perbedaan signifikan antara bahasa dengan organisasi kelas statis dan organisasi Prototipe.  Perbedaannya sendiri adalah â€œada kelas.  di sini prototipe â€tidak begitu signifikan. <br><cut></cut><br><h4>  Apa yang dimaksud dengan Organisasi Kelas Statis? </h4><br>  Dasar dari tipe OOP ini adalah konsep "Kelas" dan "Esensi".  <i>Kelas</i> adalah seperangkat karakteristik umum terformalisasi tertentu yang dapat dihasilkannya.  Yaitu  ini adalah rencana umum tertentu dari semua objek yang dihasilkannya. <br><br>  Karakteristik ada dua jenis.  Properti (deskripsi entitas) dan metode (aktivitas entitas, perilaku mereka). <br><br>  <i>Entitas yang</i> dihasilkan oleh suatu kelas adalah salinan dari kelas ini, tetapi dengan properti yang diinisialisasi.  Seperti yang kita lihat, kelas secara ketat mengatur deskripsi suatu entitas (menyediakan seperangkat properti yang didefinisikan secara ketat) dan perilakunya (memberikan daftar metode yang didefinisikan secara ketat). <br><br>  Berikut adalah contoh kecil di JAWA: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>{ String name; <span class="hljs-comment"><span class="hljs-comment">//  int age; //  void displayInfo(){ System.out.printf("Name: %s \tAge: %d\n", name, age); } }</span></span></code> </pre> <cut></cut><br>  Sekarang buat instance kelas: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Program</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Person tom; } }</code> </pre><br>  Entitas <u>tom</u> kami memiliki semua karakteristik kelas <u>Person</u> , ia juga memiliki semua metode kelasnya. <br><br>  Paradigma OOP menyediakan palet yang sangat luas kemungkinan untuk menggunakan kembali kode, salah satu fitur ini adalah <b>Warisan</b> . <br><br>  Satu kelas dapat memperluas kelas lain, sehingga menciptakan hubungan generalisasi-spesialisasi.  Dalam hal ini, sifat-sifat kelas umum (superclass) disalin ke esensi kelas turunan ketika mereka dibuat, dan metode tersedia dengan referensi (oleh rantai pewarisan hirarkis).  Dalam hal pengetikan kelas statis, rantai ini bersifat <b>statis</b> , dan dalam kasus pengetikan dinamis, rantai ini dapat berubah selama eksekusi program.  Inilah perbedaan terpenting.  Saya menyarankan Anda sekarang untuk mengingat momen ini.  Lebih jauh, ketika kita sampai di organisasi Prototipe, esensi dari masalah jawaban "ada kelas, lalu prototipe" akan menjadi jelas. <br><br>  Apa kerugian dari pendekatan ini? <br><br>  Saya pikir sudah jelas bahwa: <br><br><ul><li>  Intinya, mungkin ada karakteristik yang tidak akan pernah berguna. </li><li>  Kelas tidak dapat secara dinamis mengubah, menambah, menghapus properti dan metode yang disediakannya untuk entitas yang dihasilkan, yaitu  tidak dapat mengubah tanda tangannya. </li><li>  Pada dasarnya, properti atau metode yang tidak ada di kelas induk (atau rantai hierarkis orang tua) tidak bisa ada </li><li>  Konsumsi memori sebanding dengan jumlah tautan dalam hierarki warisan (karena menyalin properti) </li></ul><br><h4>  Apa yang menjadi dasar organisasi prototipe? </h4><br>  Konsep kunci dari organisasi prototipe adalah objek yang dapat berubah dinamis (dmo).  DMO tidak membutuhkan kelas.  Dia sendiri dapat menyimpan semua properti dan metodenya. <br><br>  Saat menetapkan DMO properti, ia memeriksa keberadaan properti ini di dalamnya.  Jika ada properti, maka itu hanya ditugaskan, jika tidak, maka properti ditambahkan dan diinisialisasi dengan nilai yang diteruskan.  DMO dapat mengubah tanda tangan mereka selama program sesering mungkin. <br><br>  Berikut ini sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const Person = { name: null, age: null, sayHi() { return `Hi! My name is ${this.name}. I'm ${this.age} years old.` } } const Tom = { //-       } Tom.__proto__ = Person;</span></span></code> </pre><br>  Saya pikir semua orang dalam subjek tahu bahwa sintaksis kelas telah muncul dalam ES6, tetapi ini tidak lebih dari gula sintaksis, yaitu.  prototipe di bawah tenda.  Kode di atas tidak boleh dianggap sebagai praktik pengkodean yang baik.  Ini tidak lebih dari sebuah ilustrasi, itu disajikan dalam bentuk ini (sekarang semua orang normal menggunakan kelas ES6) agar tidak membingungkan pembaca dan menekankan perbedaan dalam konsep-konsep teoritis. <br><br>  Jika kita menampilkan objek Tom ke konsol, kita akan melihat bahwa objek itu sendiri hanya memiliki tautan _proto_, yang selalu ada di dalamnya secara default.  Referensi menunjuk ke objek Person, yang merupakan prototipe dari objek Tom. <br><br>  <b>Prototipe</b> adalah objek yang berfungsi sebagai prototipe untuk objek lain atau objek di mana objek lain dapat menggambar properti dan metode jika diperlukan. <br><br>  Prototipe untuk suatu objek dapat berupa objek apa saja, apalagi, objek dapat menugaskan kembali prototipe selama program. <br><br>  Mari kita kembali ke Tom kita: <br><br><pre> <code class="javascript hljs">Tom.name = <span class="hljs-string"><span class="hljs-string">'Tom'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    Tom.surname = 'Williams'; //    Tom.age = 28;//    Tom.sayHi();//  sayHi,      ,    ,       const tomSon = { name: 'John', age: 5, sayHi() { return this.__proto__.sayHi.call(this) + `My father is ${this.__proto__.name} ${this.surname}`; } } //,     tomSon.__proto__ = Tom; tomSon.sayHi();//  "Hi! My name is John. I'm 5 years old.My father is Tom Williams"</span></span></code> </pre><br>  Perhatikan bahwa nama, properti usia dan metode sayHi adalah properti dari objek tomSon.  Pada saat yang sama, kami di tomSon sayHi secara eksplisit memanggil metode prototipe sayHi seolah-olah itu ada di objek Tom, tetapi sebenarnya tidak ada di sana, dan mengembalikan secara implisit dari prototipe Person. Kami juga secara eksplisit beroperasi pada nama properti prototipe dan secara implisit mendapatkan properti marga, yang kita sebut sebagai milik kita sendiri dari objek tomSon, tetapi sebenarnya tidak ada di sana.  Properti marga secara implisit ditarik melalui tautan <b>__proto__</b> dari prototipe. <br><br>  Kami melanjutkan perkembangan sejarah Tom dan putranya John. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,    (  ) //  ,   ,    , //      const Ben = { name: 'Ben', surname: 'Silver', age: 42, sayHi() { return `Hello! I'm ${this.name} ${this.surname}. `; } } tomSon.nativeFather = Tom; tomSon.__proto__= Ben; tomSon.sayHi(); //    (),     () //   'Hello! I'm John Silver. My father is Ben Silver'</span></span></code> </pre><br>  Harap dicatat bahwa selama program kami mengubah prototipe objek yang sudah dibuat.  Ini adalah kesamaan <b>Organisasi Prototipe</b> dan <b>Organisasi Kelas Dinamis</b> .  Itu sebabnya jawaban "ada kelas, ada prototipe" untuk pertanyaan "apa perbedaan antara bahasa klasik dan JavaScript?"  tidak cukup benar dan menunjukkan beberapa kesalahpahaman tentang teori OOP dan implementasinya pada kelas dan / atau prototipe. <br><br>  Dengan organisasi Prototipe, tidak seperti kelas Static, kami memiliki kesempatan untuk membuat perubahan pada prototipe setelah membuat entitas yang mewarisi properti dari prototipe ini, dan perubahan ini akan memengaruhi entitas yang sudah dibuat. <br><br><pre> <code class="javascript hljs">Ben.hobbies = [<span class="hljs-string"><span class="hljs-string">'chess'</span></span>, <span class="hljs-string"><span class="hljs-string">'badminton'</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// tomSon   ,             ,      tomSon.sayAboutFathersHobies = function () { const reducer = (accumulator, current) =&gt; {`${accumulator} and ${current}`} return `My Father play ${this.hobbies.reduce(reducer)}` } tomSon.sayAboutFathersHobies(); //  'My Father play chess and badminton'</span></span></code> </pre><br>  Ini disebut <i>model pendelegasian organisasi</i> <i>prototipe</i> atau <i>pewarisan prototipe</i> . <br><br><h4>  Bagaimana kemampuan suatu entitas untuk menerapkan perilaku tertentu ditentukan? </h4><br>  Dalam organisasi kelas statis, operasi ini melibatkan memeriksa entitas untuk keanggotaan dalam kelas tertentu yang mengimplementasikan perilaku yang diperlukan.  Dalam organisasi prototipe, ada konsep <i>mengetik bebek</i> .  Dalam kasus mengetik bebek, memeriksa entitas untuk kemampuan menerapkan perilaku tertentu berarti secara langsung menguji entitas untuk kemampuan menerapkan perilaku ini pada titik waktu tertentu, yaitu.  di berbagai bagian program, hasil pemeriksaan mungkin berlawanan secara diametral. <br><br>  Apa keuntungan dari pendekatan prototipe? <br><br><ul><li>  Lebih banyak fleksibilitas </li><li>  Entitas tidak memiliki properti yang tidak mereka butuhkan. </li></ul><br>  Apa kerugiannya? <br><br><ul><li>  Kurang jelas </li><li>  Tidak selalu mudah untuk melacak apa yang berfungsi sebagai titik awal untuk perilaku entitas yang tidak diinginkan, yaitu.  prototipe kurang dapat diprediksi daripada organisasi kelas statis </li><li>  Komunitas pengembangan perangkat lunak tidak cukup akrab dengannya, terlepas dari popularitas dan prevalensi JavaScript </li></ul><br><h3>  Kesimpulan </h3><br>  Kita akan mengakhiri hari ini.  Saya harap saya dapat menyampaikan gagasan bahwa perbedaan antara bahasa klasik dan JavaScript tidak terkait dengan ada / tidaknya kelas dan ada / tidaknya prototipe, tetapi lebih kepada sifat statis / dinamis organisasi. <br><br>  Tentu saja, banyak yang belum dipertimbangkan.  Saya tidak ingin menulis artikel yang terlalu panjang, jadi kami akan membahas fitur Model Cascade di organisasi prototipe dan alat OOP (Polimorfisme, Enkapsulasi, Abstraksi, dll.) Di artikel selanjutnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468157/">https://habr.com/ru/post/id468157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468139/index.html">Aftershokz Xtrainerz Berenang Headphone dengan Suara Berperforma Tulang - Keren</a></li>
<li><a href="../id468141/index.html">Tugas: untuk mengekstraksi ekspresi kunci dari teks dalam bahasa Rusia. Python NLP</a></li>
<li><a href="../id468143/index.html">466 terabit: lalu lintas Internet global terus bertambah, bisakah satelit bersaing dengan kabel bawah laut?</a></li>
<li><a href="../id468145/index.html">Tes atau tipe? - Versi karat</a></li>
<li><a href="../id468151/index.html">Kerentanan GeekBrains: Mengapa membayar uang untuk kursus jika Anda bisa mengunduhnya?</a></li>
<li><a href="../id468161/index.html">Para termasyhur serakah: mengapa energi matahari tidak menaklukkan dunia dan bagaimana "mineral Rusia" dapat menyelamatkannya</a></li>
<li><a href="../id468163/index.html">Oracle VM Server untuk SPARC for Dummies (How-to)</a></li>
<li><a href="../id468165/index.html">Cara menggambar browser. Laporan Yandex</a></li>
<li><a href="../id468167/index.html">Hidup dan belajar. Bagian 4. Belajar sambil bekerja?</a></li>
<li><a href="../id468169/index.html">Sejarah dan warisan JQuery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>