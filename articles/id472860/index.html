<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👩🏼 🔧 👩🏼‍🚒 Cascading cache invalidation. Bagian 1 👪 👨🏾‍🚀 🥕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama beberapa tahun sekarang, karena hampir setiap artikel tentang pendekatan lanjutan untuk caching merekomendasikan penggunaan teknik berikut dala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cascading cache invalidation. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472860/">  Selama beberapa tahun sekarang, karena hampir setiap artikel tentang pendekatan lanjutan untuk caching merekomendasikan penggunaan teknik berikut dalam produksi: <br><br><ul><li>  Menambahkan informasi nama file tentang versi data yang terkandung di dalamnya (biasanya dalam bentuk hash data dalam file). </li><li> Menyetel tajuk HTTP <code>Cache-Control: max-age</code> dan <code>Expires</code> , yang mengontrol waktu caching materi (yang menghilangkan validasi ulang materi yang relevan bagi pengunjung yang kembali ke sumber daya). </li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/0d/fi/12/0dfi12ooly3mmtiq05otewvw4du.jpeg"></a> <br><br>  Semua alat untuk membangun proyek yang saya tahu mendukung menambahkan ke file hash nama isinya.  Ini dilakukan dengan menggunakan aturan konfigurasi sederhana (seperti yang ditunjukkan di bawah): <br><br><pre> <code class="javascript hljs">filename: <span class="hljs-string"><span class="hljs-string">'[name]-[contenthash].js'</span></span></code> </pre> <br>  Dukungan luas seperti ini untuk teknologi ini telah mengarah pada fakta bahwa praktik ini telah menjadi sangat umum. <br><a name="habracut"></a><br>  Pakar kinerja proyek web juga merekomendasikan menggunakan teknik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemisahan kode</a> .  Teknik-teknik ini memungkinkan memecah kode JavaScript menjadi bundel terpisah.  Kumpulan tersebut dapat diunduh oleh browser secara paralel, atau bahkan hanya jika diperlukan, atas permintaan browser. <br><br>  Salah satu dari banyak keuntungan pemisahan kode, khususnya, terkait dengan teknik caching terbaik, adalah bahwa perubahan yang dilakukan pada file terpisah dengan kode sumber tidak menyebabkan pembatalan cache seluruh bundel.  Dengan kata lain, jika pembaruan keamanan dirilis untuk paket npm yang dibuat oleh pengembang "X", dan konten <code>node_modules</code> difragmentasi oleh pengembang, maka hanya fragmen yang berisi paket yang dibuat oleh "X" yang harus diubah. <br><br>  Masalahnya di sini adalah jika semua ini digabungkan, maka ini jarang mengarah pada peningkatan efisiensi caching data jangka panjang. <br><br>  Dalam praktiknya, perubahan pada salah satu file kode sumber hampir selalu mengakibatkan pembatalan lebih dari satu file output dari sistem paket rakitan.  Dan ini justru karena fakta bahwa hash telah ditambahkan ke nama file yang mencerminkan versi isi file-file ini. <br><br><h2>  <font color="#3AC1EF">Masalah Versi Nama File</font> </h2><br>  Bayangkan Anda telah membuat dan menggunakan situs web.  Anda telah menggunakan pemisahan kode, sebagai akibatnya, sebagian besar kode JavaScript situs Anda dimuat berdasarkan permintaan. <br><br>  Di diagram dependensi berikutnya, Anda dapat melihat titik entri basis kode - fragmen root <code>main</code> , serta tiga fragmen dependensi yang dimuat secara tidak sinkron - <code>dep1</code> , <code>dep3</code> dan <code>dep3</code> .  Ada juga fragmen <code>vendor</code> berisi semua dependensi situs dari <code>node_modules</code> .  Semua nama file, sesuai dengan pedoman caching, termasuk hash dari isi file-file ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/828/7ad/f78/8287adf785b9ac4b9843fa5f1b81e543.png"></div><br>  <i><font color="#999999">Pohon dependensi modul JavaScript tipikal</font></i> <br><br>  Karena <code>dep3</code> dan <code>dep3</code> mengimpor modul dari fragmen <code>vendor</code> , maka di bagian atas kode mereka dihasilkan oleh <code>dep3</code> proyek, kami kemungkinan besar akan menemukan perintah impor yang terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/vendor-5e6f.mjs'</span></span>;</code> </pre> <br>  Sekarang mari kita pikirkan tentang apa yang akan terjadi jika isi dari fragmen <code>vendor</code> berubah. <br><br>  Jika ini terjadi, hash dalam nama file yang sesuai juga akan berubah.  Dan karena tautan ke nama file ini ada di perintah impor untuk <code>dep3</code> dan <code>dep3</code> , maka perintah-perintah impor ini perlu diubah: <br><br><pre> <code class="javascript hljs">-<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/vendor-5e6f.mjs'</span></span>; +<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/vendor-d4a1.mjs'</span></span>;</code> </pre> <br>  Namun, karena perintah impor ini adalah bagian dari isi dari <code>dep3</code> dan <code>dep3</code> , mengubahnya berarti bahwa hash dari isi file <code>dep3</code> dan <code>dep3</code> juga <code>dep2</code> <code>dep3</code> .  Dan itu berarti bahwa nama-nama file ini juga akan berubah. <br><br>  Tetapi ini tidak berakhir di sana.  Karena fragmen <code>main</code> mengimpor fragmen <code>dep3</code> dan <code>dep3</code> , dan nama file mereka telah berubah, perintah impor di <code>main</code> juga akan berubah: <br><br><pre> <code class="javascript hljs">-<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/dep2-3c4d.mjs'</span></span>; +<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/dep2-2be5.mjs'</span></span>; -<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/dep3-d4e5.mjs'</span></span>; +<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/dep3-3c6f.mjs'</span></span>;</code> </pre> <br>  Dan akhirnya, karena isi file <code>main</code> telah berubah, nama file ini juga harus diubah. <br><br>  Beginilah diagram dependensi sekarang akan terlihat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c3/4e7/1c4/1c34e71c45d94977d5445366abe26bec.png"></div><br>  <i><font color="#999999">Modul di pohon ketergantungan dipengaruhi oleh perubahan tunggal dalam kode salah satu simpul daun pohon</font></i> <br><br>  Contoh ini menunjukkan bagaimana perubahan kode kecil yang dibuat hanya dalam satu file menyebabkan pembatalan cache 80% dari fragmen bundel. <br><br>  Meskipun memang benar bahwa tidak semua perubahan menyebabkan konsekuensi yang menyedihkan (misalnya, membatalkan cache node daun menyebabkan validasi cache semua node hingga ke root, tetapi membatalkan cache root tidak menyebabkan cascading invalidation mencapai tangkapan daun), di dunia yang ideal kami tidak perlu berurusan dengan pembatalan cache yang tidak perlu. <br><br>  Ini membawa kita pada pertanyaan berikut: "Apakah mungkin untuk mendapatkan manfaat dari sumber daya yang tidak dapat diubah dan caching jangka panjang, sementara tidak menderita cascading cache invalidations?" <br><br><h2>  <font color="#3AC1EF">Pendekatan Pemecahan Masalah</font> </h2><br>  Masalah dengan hash dari isi file dalam nama file, dari sudut pandang teknis, bukanlah bahwa hash ada dalam nama.  Itu terletak pada fakta bahwa hash ini muncul di dalam file lain.  Akibatnya, cache dari file-file ini dinonaktifkan ketika mengubah hash dalam nama-nama file di mana mereka bergantung. <br><br>  Solusi untuk masalah ini adalah dengan menggunakan bahasa contoh di atas untuk memungkinkan untuk mengimpor fragmen <code>vendor</code> oleh <code>dep3</code> dan <code>dep3</code> tanpa menentukan informasi versi file fragmen <code>vendor</code> .  Dengan demikian, Anda harus memastikan bahwa versi <code>vendor</code> diunduh sudah benar, dengan mempertimbangkan versi <code>dep3</code> dan <code>dep3</code> . <br><br>  Ternyata, ada beberapa cara untuk mencapai tujuan ini: <br><br><ul><li>  Kartu impor. </li><li>  Pekerja Layanan. </li><li>  Skrip asli untuk memuat sumber daya. </li></ul><br>  Pertimbangkan mekanisme ini. <br><br><h2>  <font color="#3AC1EF">Pendekatan # 1: Impor Kartu</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengimpor peta</a> adalah solusi paling sederhana untuk cascading invalidation cache.  Selain itu, mekanisme ini paling mudah diterapkan.  Tetapi, sayangnya, hanya didukung di Chrome (fitur ini, terlebih lagi, harus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diaktifkan</a> secara eksplisit). <br><br>  Meskipun demikian, saya ingin memulai dengan cerita tentang kartu impor, karena saya yakin keputusan ini akan menjadi yang paling umum di masa depan.  Selain itu, deskripsi bekerja dengan kartu impor akan membantu menjelaskan fitur-fitur pendekatan lain untuk menyelesaikan masalah kita. <br><br>  Menggunakan peta impor untuk mencegah cascading invalidation terdiri dari tiga langkah. <br><br><h3>  <font color="#3AC1EF">▍Langkah 1</font> </h3><br>  Anda perlu mengkonfigurasi bundler sehingga ketika membangun proyek itu tidak termasuk hash dari isi file dalam nama mereka. <br><br>  Jika Anda merakit proyek yang modulnya diperlihatkan dalam diagram dari contoh sebelumnya, tanpa menyertakan hash dari isinya dalam nama file, file-file dalam direktori output proyek akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs">dep1.mjs dep2.mjs dep3.mjs main.mjs vendor.mjs</code> </pre> <br>  Perintah impor dalam modul yang sesuai juga tidak akan menyertakan hash: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/vendor.mjs'</span></span>;</code> </pre> <br><h3>  <font color="#3AC1EF">▍Langkah 2</font> </h3><br>  Anda perlu menggunakan alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rev-hash</a> , dan menggunakannya untuk menghasilkan salinan setiap file dengan hash yang ditambahkan ke namanya yang menunjukkan versi isinya. <br>  Setelah bagian pekerjaan ini selesai, isi direktori keluaran akan terlihat seperti yang ditunjukkan di bawah ini (perhatikan bahwa sekarang ada dua opsi untuk setiap file): <br><br><pre> <code class="javascript hljs">dep1-b2c3.mjs<span class="hljs-string"><span class="hljs-string">", dep1.mjs dep2-3c4d.mjs"</span></span>, dep2.mjs dep3-d4e5.mjs<span class="hljs-string"><span class="hljs-string">", dep3.mjs main-1a2b.mjs"</span></span>, main.mjs vendor<span class="hljs-number"><span class="hljs-number">-5e6</span></span>f.mjs<span class="hljs-string"><span class="hljs-string">", vendor.mjs</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Langkah 3</font> </h3><br>  Anda perlu membuat objek JSON yang menyimpan informasi tentang korespondensi setiap file yang namanya tidak ada hash untuk setiap file yang namanya hash.  Objek ini perlu ditambahkan ke templat HTML. <br><br>  Objek JSON ini adalah peta impor.  Begini tampilannya: <br><br><pre> <code class="javascript hljs">&lt;script type=<span class="hljs-string"><span class="hljs-string">"importmap"</span></span>&gt; {  <span class="hljs-string"><span class="hljs-string">"imports"</span></span>: {    <span class="hljs-string"><span class="hljs-string">"/main.mjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"/main-1a2b.mjs"</span></span>,    <span class="hljs-string"><span class="hljs-string">"/dep1.mjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"/dep1-b2c3.mjs"</span></span>,    <span class="hljs-string"><span class="hljs-string">"/dep2.mjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"/dep2-3c4d.mjs"</span></span>,    <span class="hljs-string"><span class="hljs-string">"/dep3.mjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"/dep3-d4e5.mjs"</span></span>,    <span class="hljs-string"><span class="hljs-string">"/vendor.mjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"/vendor-5e6f.mjs"</span></span>,  } } &lt;<span class="hljs-regexp"><span class="hljs-regexp">/script&gt;</span></span></code> </pre> <br>  Setelah itu, setiap kali browser melihat perintah impor file yang terletak di alamat yang sesuai dengan salah satu kunci peta impor, browser akan mengimpor file yang cocok dengan nilai kunci. <br><br>  Jika Anda menggunakan peta impor ini sebagai contoh, Anda dapat mengetahui bahwa perintah impor yang mereferensikan file <code>/vendor.mjs</code> sebenarnya akan meminta dan memuat file <code>/vendor-5e6f.mjs</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    `/vendor.mjs`,  `/vendor-5e6f.mjs`. import {...} from '/vendor.mjs';</span></span></code> </pre> <br>  Ini berarti bahwa kode sumber modul dapat dengan mudah merujuk pada nama file dari modul yang tidak mengandung hash, dan browser akan selalu mengunduh file yang namanya berisi informasi tentang versi kontennya.  Dan, karena tidak ada hash dalam kode sumber modul (mereka hanya hadir di peta impor), perubahan hash ini tidak akan menyebabkan pembatalan modul selain dari mereka yang isinya telah benar-benar berubah. <br><br>  Mungkin Anda sekarang bertanya-tanya mengapa saya membuat salinan setiap file alih-alih hanya mengganti nama file.  Ini diperlukan untuk mendukung browser yang tidak dapat berfungsi dengan impor peta.  Pada contoh sebelumnya, browser semacam itu hanya akan melihat file <code>/vendor.mjs</code> dan cukup mengunduh file ini, melakukan seperti biasanya, menemui konstruksi yang serupa.  Akibatnya, ternyata kedua file tersebut harus ada di server. <br><br>  Jika Anda ingin melihat impor peta dalam aksi, berikut adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekumpulan contoh</a> yang menunjukkan semua cara untuk menyelesaikan masalah pembatalan cache cascading yang ditunjukkan pada artikel ini.  Juga, lihat <a href="">konfigurasi perakitan proyek</a> , jika Anda tertarik mempelajari bagaimana saya membuat peta impor dan hash versi untuk setiap file. <br><br>  Dilanjutkan ... <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda mengetahui cascading invalidation cache? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472860/">https://habr.com/ru/post/id472860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472850/index.html">Profesi atau Kehidupan: Menangkan Kursus Netologi Jika Anda Tidak Takut</a></li>
<li><a href="../id472852/index.html">GitLab membuat perubahan untuk pengguna produk cloud dan komersial</a></li>
<li><a href="../id472854/index.html">Profiling Unity UI: Siapa yang merusak Batching Saya?</a></li>
<li><a href="../id472856/index.html">Bagaimana saya membuat layanan kontrol kualitas dari tabel dan stik</a></li>
<li><a href="../id472858/index.html">Python dan klien HTTP cepat</a></li>
<li><a href="../id472862/index.html">Cascading cache invalidation. Bagian 2</a></li>
<li><a href="../id472866/index.html">Jimat untuk komunikasi yang stabil</a></li>
<li><a href="../id472868/index.html">Manajemen server telepon: Klien seluler RUVDS</a></li>
<li><a href="../id472870/index.html">Mengapa Agile terhenti tanpa mengubah arsitektur dan alat pengembangan - presentasi konferensi</a></li>
<li><a href="../id472872/index.html">Bagaimana meningkatkan startup hingga 50 karyawan tanpa kehilangan budaya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>