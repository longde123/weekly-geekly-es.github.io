<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏾 🌮 🍷 Nomor latensi pada iPhone 👲🏾 ㊙️ 🛫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nomor Latensi yang Harus Diketahui Setiap Programmer - tabel "penundaan yang harus diketahui oleh setiap programmer." Ini berisi nilai rata-rata waktu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nomor latensi pada iPhone</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/437590/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nomor Latensi yang Harus Diketahui Setiap Programmer</a> - tabel "penundaan yang harus diketahui oleh setiap programmer."  Ini berisi nilai rata-rata waktu untuk melakukan operasi komputer dasar pada 2012.  Ada beberapa pandangan alternatif untuk tabel ini, dan ini adalah salah satunya. <br><br><img src="https://habrastorage.org/webt/oa/i4/ho/oai4hogxseqehs_ciso1lz9q_io.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan</a> ke sumber skema</i> <br><br>  Tetapi apa manfaatnya bagi pengembang seluler dari informasi ini pada tahun 2019?  Tampaknya tidak, tetapi <b>Dmitry Kurkin</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">SClown</a> ) dari tim Yandex.Navigator berpikir: "Seperti apa meja itu untuk iPhone modern?"  Apa yang terjadi, dalam versi teks revisi laporan Dmitry di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cyzo48f0exw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Untuk apa ini? </h2><br>  Mengapa programmer harus tahu angka-angka ini?  Dan apakah itu relevan untuk pengembang seluler?  Ada dua tugas utama yang bisa diselesaikan dengan bantuan angka-angka ini. <br><a name="habracut"></a><br><h3>  Memahami skala waktu di komputer </h3> <br>  Ambil situasi sederhana - percakapan telepon.  Kita dapat dengan mudah mengetahui kapan proses ini cepat dan kapan: beberapa detik sangat cepat, beberapa menit adalah percakapan rata-rata, dan satu jam atau lebih sangat lama.  Dengan memuat halaman, itu serupa: dalam waktu kurang dari satu detik - cepat, beberapa detik - tertahankan, dan satu menit adalah bencana, pengguna mungkin tidak menunggu untuk mengunduh. <br><br>  Tapi bagaimana dengan operasi seperti menambahkan nomor ke array - "insert cepat" yang kadang-kadang orang suka bicarakan dalam wawancara?  Berapa yang dibutuhkan untuk smartphone?  Nanodetik, mikrodetik, atau milidetik?  Saya telah bertemu beberapa orang yang bisa mengatakan bahwa 1 milidetik adalah waktu yang lama, tetapi dalam kasus kami begitu. <br><br><h3>  Rasio kecepatan berbagai komponen komputer </h3><br>  Waktu pelaksanaan operasi pada berbagai perangkat dapat bervariasi hingga puluhan atau ratusan kali.  Misalnya, waktu akses ke memori utama adalah 100 kali berbeda dari mengakses cache L1.  Ini adalah perbedaan besar, tetapi tidak terbatas.  Jika kita memiliki makna khusus untuk ini, maka ketika mengoptimalkan aplikasi kita, kita dapat mengevaluasi apakah akan ada penambahan waktu atau tidak. <br><br><img src="https://habrastorage.org/webt/km/q5/ze/kmq5zekztqx_yhwcoyrjomhjcy4.png"><br><br><h2>  "Nomor latensi" dalam kehidupan nyata </h2><br>  Ketika saya melihat angka-angka ini, saya menjadi tertarik pada perbedaan antara cache dan akses memori.  Jika saya hati-hati memasukkan data saya dalam 64 Kbytes, yang tidak terlalu kecil, maka kode saya akan bekerja 100 kali lebih cepat - cepat, semuanya akan terbang! <br><br><img src="https://habrastorage.org/webt/-p/oh/fh/-pohfhloth8e4c-8sl2i5jdmbi4.png"><br><br>  Saya segera ingin memeriksanya, menunjukkannya kepada kolega saya, dan menerapkannya sedapat mungkin.  Saya memutuskan untuk memulai dengan alat standar yang ditawarkan Apple - XCTest dengan MeasBlock.  Tes diatur sebagai berikut: mengalokasikan array, mengisinya dengan angka, XOR'il mereka dan mengulangi algoritme 10 kali, pasti.  Setelah itu, saya melihat berapa banyak waktu yang dibutuhkan untuk satu elemen. <br><br><table><tbody><tr><td>  <b>Ukuran penyangga</b> </td><td>  <b>Total waktu</b> </td><td>  <b>Waktunya untuk operasi</b> </td></tr><tr><td>  50 kb </td><td>  1,5 ms </td><td>  30 ns </td></tr><tr><td>  500 kb </td><td>  12 md </td><td>  24 ns </td></tr><tr><td>  5000 kb </td><td>  85 ms </td><td>  17 ns </td></tr></tbody></table><br>  Ukuran buffer meningkat 100 kali, dan waktu untuk operasi tidak hanya meningkat 100 kali, tetapi menurun hampir 2 kali.  <i>Tuan-tuan, petugas, mereka mengkhianati kita ?!</i> <br><br>  Setelah hasil seperti itu, keraguan besar merayapi saya bahwa angka-angka ini dapat dilihat dalam kehidupan nyata.  Mungkin tidak mungkin bagi aplikasi reguler untuk merasakan perbedaan ini.  Atau mungkin pada platform seluler semuanya berbeda. <br><br>  Saya mulai mencari cara untuk melihat perbedaan kinerja antara cache dan memori utama.  Selama pencarian, saya menemukan sebuah artikel di mana penulis mengeluh bahwa ia memiliki benchmark yang berjalan di Mac dan iPhone-nya dan tidak menunjukkan penundaan ini.  Saya mengambil alat ini dan mendapatkan hasilnya - seperti di apotek.  Waktu akses memori meningkat cukup jelas ketika ukuran buffer melebihi ukuran cache yang sesuai. <br><br><img src="https://habrastorage.org/webt/he/_q/k8/he_qk85tbetz4emjxbp5znbqidc.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LMbench</a> membantu saya mendapatkan hasil ini.  Ini adalah patokan yang dibuat oleh Larry McVoy, salah satu pengembang kernel Linux, yang memungkinkan Anda untuk mengukur waktu akses memori, biaya beralih thread dan operasi sistem file, dan bahkan waktu yang dibutuhkan oleh operasi prosesor utama: penambahan, pengurangan, dll. Menurut patokan ini Texas Instruments menyajikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">data</a> pengukuran yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menarik</a> untuk prosesornya.  LMBench ditulis dalam C, jadi tidak sulit untuk menjalankannya di iOS. <br><br><h2>  Biaya Memori </h2><br>  Berbekal alat yang luar biasa, saya memutuskan untuk melakukan pengukuran serupa, tetapi untuk perangkat seluler yang sebenarnya - untuk iPhone.  Pengukuran utama dilakukan pada 5S, dan kemudian saya mendapatkan hasilnya ketika perangkat lain jatuh ke tangan saya.  Karena itu, jika perangkat tidak ditentukan, maka itu adalah 5S. <br><br><h3>  Akses memori </h3><br>  Untuk tes ini, array khusus digunakan, yang diisi dengan elemen yang saling referensi.  Setiap elemen adalah penunjuk ke elemen lain.  Array tidak dilalui oleh indeks, tetapi dengan transisi dari satu node ke yang lain.  Elemen-elemen ini tersebar di array sehingga, ketika mengakses elemen baru, sesering mungkin itu tidak ada dalam cache, tetapi diturunkan dari RAM.  Pengaturan ini mengganggu cache sebanyak mungkin. <br><br>  Anda sudah melihat hasil awal.  Dalam kasus cache L1, itu kurang dari 10 nanodetik, untuk L2 itu adalah beberapa puluhan nanodetik, dan dalam kasus memori utama, waktu naik menjadi ratusan nanodetik. <br><br><img src="https://habrastorage.org/webt/6u/dk/f0/6udkf0ihlo3lgfqhntfkzp3vshm.png"><br><br><h3>  Kecepatan baca dan tulis </h3><br>  Tiga operasi utama diukur: <br><br><ul><li>  reading ( <em>p [i] +</em> ) - kita membaca elemen dan menambahkannya ke jumlah total; </li><li>  record ( <em>p [i] = 1</em> ) - angka konstan ditulis di setiap elemen; </li><li>  membaca dan menulis ( <em>p [i] = p [i] * 2</em> ) - kita mengambil elemen, mengubahnya dan menulis nilai baru kembali. </li></ul><br>  Ketika bekerja dengan buffer, 2 pendekatan digunakan: dalam kasus pertama, hanya setiap elemen keempat yang digunakan, dan yang kedua, semua elemen berurutan. <br><br><img src="https://habrastorage.org/webt/yr/ke/ia/yrkeiaf0vzc47trw7wc_hypse-s.png"><br><br>  Kecepatan tertinggi diperoleh dengan ukuran buffer kecil, dan kemudian ada langkah-langkah yang jelas, sesuai dengan ukuran cache L1 dan L2.  Yang paling menarik adalah ketika data dibaca berurutan, tidak ada pengurangan kecepatan.  Namun dalam hal operan, langkah yang jelas terlihat. <br><br><img src="https://habrastorage.org/webt/2t/-d/_6/2t-d_68-oyjigkraj2mpirwjzfw.png"><br><br>  Selama pembacaan berurutan, OS mengatur untuk memuat data yang diperlukan ke dalam cache, jadi untuk ukuran buffer apa pun saya tidak perlu mengakses memori - semua data yang diperlukan diperoleh dari cache.  Ini menjelaskan mengapa saya tidak melihat perbedaan waktu dalam tes dasar saya. <br><br>  Hasil pengukuran operasi baca dan tulis menunjukkan bahwa dalam aplikasi normal cukup sulit untuk memperoleh estimasi percepatan 100 kali.  Di satu sisi, sistem itu sendiri menyimpan data dengan cukup baik, dan bahkan dengan array besar kita sangat mungkin menemukan data dalam cache.  Dan di sisi lain, bekerja dengan berbagai variabel dapat dengan mudah memerlukan akses ke memori dan hilangnya ratusan nanodetik yang dimenangkan. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>Memori</b> </td></tr><tr><td>  Nomor latensi </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td></tr><tr><td>  iPhone X </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td></tr></tbody></table><br><h2>  Biaya Threading </h2><br>  Selanjutnya, saya ingin mendapatkan data serupa untuk bekerja dengan utas untuk <strong>memahami biaya penggunaan multithreading</strong> : berapa biaya untuk membuat utas dan beralih dari satu utas ke yang lain.  Bagi kami, ini adalah operasi yang sering, dan saya ingin memahami kerugiannya. <br><br><h3>  Instrumen.  Jejak sistem </h3><br>  System Trace banyak membantu untuk melacak pekerjaan utas dalam aplikasi.  Alat ini dijelaskan secara rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WWDC 2016</a> .  Alat ini membantu untuk melihat transisi dengan kondisi aliran dan menyajikan data tentang aliran dalam tiga kategori utama: panggilan sistem, bekerja dengan memori dan kondisi aliran. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hs/gx/kq/hsgxkqsh5khfclg4gncfbksihya.png" width="500"></div><br><br><ol><li>  <strong>Panggilan sistem</strong>  Mereka disajikan dalam bentuk "sosis" merah.  Ketika Anda mengarahkan mereka, Anda dapat melihat nama metode sistem dan durasi eksekusi.  Seringkali dalam aplikasi aplikasi, panggilan sistem seperti itu tidak terjadi secara langsung: kami menggunakan sesuatu, yang pada gilirannya sudah memanggil metode sistem.  Anda seharusnya tidak mengandalkan fakta bahwa di sini metode dari kode Anda akan terlihat. </li><li>  <strong>Operasi memori</strong> .  Mereka disajikan dalam bentuk "sosis" biru.  Ini termasuk operasi seperti alokasi memori, pembebasan, pengenolan, dll. </li><li>  <strong>Keadaan aliran</strong> .  Warna biru - utas sedang berjalan, sebagian prosesor menjalankan kode dari utas ini.  Abu-abu - utas diblokir karena alasan tertentu dan tidak dapat melanjutkan eksekusi.  Merah - utas siap bekerja, tetapi saat ini tidak ada kernel gratis untuk mengeksekusi kodenya.  Warna oranye - aliran terputus untuk pekerjaan dengan prioritas lebih tinggi. </li><li> <strong>Tempat menarik</strong> .  Ini adalah label khusus yang dapat diatur oleh kode dengan memanggil <code>kdebug_signpost</code> .  Label bisa tunggal (tempat tertentu dalam kode) atau sebagai rentang (untuk menyorot seluruh prosedur).  Dengan menggunakan label semacam itu, jauh lebih mudah untuk menghubungkan mikrodetik dan panggilan sistem dengan aplikasi Anda. </li></ol><br><h3>  Streaming biaya pembuatan </h3><br>  Tes pertama adalah <strong>pelaksanaan tugas di utas baru</strong> .  Kami membuat utas dengan prosedur tertentu dan menunggu untuk menyelesaikan pekerjaannya.  Membandingkan total waktu dengan waktu untuk prosedur itu sendiri, kami mendapatkan total kerugian untuk memulai prosedur di utas baru. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m3/ln/wa/m3lnwaf0zdjx7b7suyujhp9eywu.png" width="600"></div><br><br>  Di System Trace Anda dapat dengan jelas melihat bagaimana semuanya benar-benar terjadi: <br><br><img src="https://habrastorage.org/webt/wh/ta/qd/whtaqdwmfal7dyi4d-fs_22oir0.png"><br><br><ol><li>  Buat aliran. </li><li>  Utas baru tempat prosedur kami berjalan.  Zona merah di awal mengatakan bahwa utas dibuat, tetapi untuk beberapa waktu tidak dapat dijalankan, karena tidak ada inti bebas. </li><li>  Selesainya aliran.  Menariknya, prosedur penyelesaian utas itu sendiri bahkan lebih besar dari penciptaannya.  Meskipun tampaknya menghapus selalu lebih cepat. </li><li>  Menunggu penyelesaian prosedur, yang berada dalam skema asli, dan berakhir setelah aliran berakhir - untuk sementara waktu metode ini menyadari hal ini dan, setelah itu, melaporkan.  Waktu ini sedikit lebih lama dari penyelesaian aliran. </li></ol><br>  Akibatnya, membuat aliran memerlukan biaya yang cukup signifikan: iPhone 5S - 230 mikrodetik, 6S - 50 mikrodetik.  <b>Penyelesaian aliran memakan waktu hampir 2 kali lebih banyak dari pada pembuatannya</b> , bergabung juga membutuhkan waktu yang nyata.  Ketika bekerja dengan memori, kami mendapat ratusan nanodetik, yang 100 kali lebih kecil dari puluhan mikrodetik. <br><br><table><tbody><tr><td></td><td>  <b>overhead</b> </td><td>  <b>buat</b> </td><td>  <b>akhir</b> </td><td>  <b>bergabunglah</b> </td></tr><tr><td>  iPhone 5s </td><td>  230 μs </td><td>  40 μs </td><td>  70 μs </td><td>  30 μs </td></tr><tr><td>  iPhone 6s Plus </td><td>  50 μs </td><td>  12 μs </td><td>  20 μs </td><td>  7 μs </td></tr></tbody></table><br><h3>  Semaphore switching time </h3><br>  Tes selanjutnya adalah <strong>pengukuran pada karya semaphore</strong> .  Kami memiliki 2 utas yang telah dibuat sebelumnya, dan untuk masing-masingnya ada semafor.  Streaming secara bergantian menandakan semafor tetangga dan menunggu untuk mereka sendiri.  Melewati sinyal satu sama lain, stream bermain ping-pong, saling menghidupkan kembali.  Iterasi ganda ini memberikan waktu switching semafor ganda. <br><br><img src="https://habrastorage.org/webt/nf/de/iq/nfdeiqezf1edyugn_lkccjocndy.png"><br><br>  Di System Trace, semuanya terlihat mirip: <br><br><ol><li>  Sinyal diberikan untuk semafor aliran kedua.  Dapat dilihat bahwa operasi ini sangat singkat. </li><li>  Utas kedua tidak dikunci, menunggu di ujung semafornya. </li><li>  Sinyal diberikan untuk semafor aliran pertama. </li><li>  Utas pertama tidak diblokir, penantian di ujung semafornya. </li></ol><br><img src="https://habrastorage.org/webt/0e/jn/mb/0ejnmb3dxvozsz-h0zaijdl_3xm.png"><br><br>  Waktu switching dalam 10 mikrodetik.  Perbedaan dengan membuat utas sebanyak 50 kali persis alasan mengapa kumpulan utas dibuat, dan bukan utas baru untuk setiap prosedur. <br><br><h3>  Kerugian pada pengalihan konteks thread sistem </h3><br>  Dalam dua tes sebelumnya, transfer kontrol antara utas sepenuhnya dikontrol - kami memahami dengan jelas di mana dan di mana transisi harus terjadi.  Namun, sering terjadi bahwa sistem itu sendiri berpindah dari satu utas ke utas lainnya.  Ketika kami menjalankan lebih banyak tugas secara paralel dari inti pada perangkat, sistem operasi harus dapat beralih sendiri untuk memberikan waktu prosesor kepada semua orang. <br><br>  Dalam tes ini, saya ingin mengukur hilangnya memulai terlalu banyak utas.  Untuk melakukan ini, kumpulan 16 thread dibuat, masing-masing menunggu semaphore, dan, segera setelah menerima sinyal, melakukan prosedur tertentu dan memberi sinyal semaphore kembali.  Utas utama memulai keseluruhan kumpulan, memberikan 16 sinyal, dan setelah itu menunggu 16 sinyal sebagai respons. <br><br><img src="https://habrastorage.org/webt/fv/ki/an/fvkiang1lid-dgw6bmddnudyjro.png"><br><br>  Dalam System Trace Anda dapat melihat bahwa blok tersebar secara acak, beberapa di antaranya jauh lebih lama daripada yang lain.  Jika banyak peralihan menyebabkan peningkatan waktu eksekusi operasi, maka waktu eksekusi rata-rata akan meningkat sebagai hasilnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ar/0b/r6/ar0br6h-8hm8qwmlyokuots92au.png" width="500"></div><br>  <b>Namun, dengan peningkatan jumlah utas, waktu operasi rata-rata tidak meningkat.</b> <br><br>  Secara teori, waktu rata-rata harus dijaga selama beban sesuai dengan kekuatan pemrosesan.  Artinya, jumlah tugas sesuai dengan jumlah core. <br><br><img src="https://habrastorage.org/webt/9r/8l/-p/9r8l-p83_ad6ibrit6ee2d67cwa.png"><br><br>  Jika Anda menjalankan banyak tugas secara paralel, maka OS, beralih dari satu tugas ke tugas lain, akan menimbulkan penundaan tambahan.  Ini harus tercermin dalam hasilnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fe/0x/ko/fe0xko9wqlkfu5nt4n0fonqcrfs.png"></div><br>  Dalam praktiknya, tidak hanya aplikasi kita berfungsi pada perangkat, tetapi masih memiliki banyak proses paralel dan sistem.  Bahkan satu-satunya utas dalam aplikasi kita akan terpengaruh oleh peralihan, yang mengarah pada gangguan dan penundaan.  Oleh karena itu, dalam semua situasi ada penundaan, dan tidak ada perbedaan apakah akan membangun tugas secara seri atau berjalan secara paralel. <br><br><img src="https://habrastorage.org/webt/by/io/c4/byioc4ax6qgcuwxpkmjhpfyaaeg.png"><br><br>  Di bawah ini adalah tabel Nomor Latensi kami dengan data tentang arus dan semafor. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>Memori</b> </td><td>  <b>Semaphore</b> </td></tr><tr><td>  Nomor latensi </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td><td>  25 ns </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td><td>  8 μs </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td><td>  5 μs </td></tr><tr><td>  iPhone X </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td><td>  3,2 μs </td></tr></tbody></table><br><h2>  Biaya File </h2><br>  Kami sudah memiliki memori dan utas - untuk kelengkapannya kami hanya perlu operasi sistem file. <br><br><h3>  Baca file </h3><br>  Tes pertama adalah <strong>kecepatan membaca</strong> - berapa biaya untuk membaca file.  Tes terdiri dari dua bagian.  Yang pertama, kami <strong>mengukur kecepatan membaca</strong> dengan mempertimbangkan pembukaan, pembacaan, dan penutupan file.  Yang kedua, kita <strong>mengasumsikan bahwa file itu selalu terbuka</strong> : kita menempatkan diri kita di suatu tempat dan membaca sebanyak yang kita inginkan. <br><br>  Hasilnya dilihat dengan benar dari dua sudut pandang.  <strong>Ketika file kecil</strong> , ada beberapa waktu minimal untuk membaca data dari file.  Hingga satu kilobyte adalah 5,3 mikrodetik - tidak masalah: 1 byte, 2 atau 1 KB - untuk semua 5,3 μs.  Oleh karena itu, Anda dapat berbicara tentang kecepatan hanya dalam kasus file besar, ketika waktu tetap sudah dapat diabaikan.  Operasi untuk membuka dan menutup file membutuhkan waktu yang hampir sama untuk ukuran file apa pun - dalam kasus 5S, sekitar 50 mikrodetik. <br><br><img src="https://habrastorage.org/webt/zv/na/-2/zvna-2en_axstzffeo9iru-bpuo.png"><br><br>  Untuk kecepatan membaca, grafik tersebut diperoleh. <br><br><img src="https://habrastorage.org/webt/h4/2g/ri/h42griw_vpjjlfgkpxdbty3c8yw.png"><br><br>  Untuk iPhone X dan file 1 MB, kecepatannya bisa mencapai 20 MB / s.  Menariknya, membaca file 1 MB lebih efisien.  Dengan ukuran file yang besar, ukuran cache sepertinya terpengaruh.  Itulah sebabnya kecepatan turun lebih jauh dan merata di wilayah 10 Mb. <br><br><h3>  Buat dan hapus file </h3><br>  Tes terdiri dari langkah <strong>membuat file dan menulis data</strong> , dan <strong>menghapus</strong> file yang dibuat.  Hasilnya adalah bertahap: pada ukuran kecil, waktunya stabil - sekitar 7 μs, dan terus berkembang.  Skala tersebut adalah logaritmik. <br><br><img src="https://habrastorage.org/webt/da/xn/sp/daxnspzyy0raugagyluwnkwjqhs.png"><br><br>  Saya terkejut bahwa waktu yang diperlukan untuk menghapus file besar sepadan dengan waktu yang dibutuhkan untuk membuat, karena saya berasumsi bahwa menghapus adalah operasi cepat.  Ternyata tidak, untuk iPhone, menghapus waktu sebanding dengan membuat file.  Tabel ringkasan terlihat seperti ini. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>Memori</b> </td><td>  <b>Semaphore</b> </td><td>  <b>Disk</b> </td></tr><tr><td>  Nomor latensi </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td><td>  25 ns </td><td>  150 μs </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td><td>  8 μs </td><td>  5 μs </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td><td>  5 μs </td><td>  4 μs </td></tr><tr><td>  iPhone X </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td><td>  3,2 μs </td><td>  1,3 μs </td></tr></tbody></table><br><h2>  Kesimpulan </h2><br>  Berdasarkan pengukuran ini, kami sekarang memiliki gagasan tentang berapa banyak waktu yang dibutuhkan operasi iOS dasar: mengakses memori adalah nanodetik, bekerja dengan file adalah mikrodetik, membuat aliran adalah puluhan mikrodetik, dan beralih hanya beberapa mikrodetik. <br><br>  Untuk mendapatkan hang yang terlihat secara fisik dalam aplikasi, waktu pelaksanaan prosedur harus melebihi 15 milidetik (waktu yang dibutuhkan untuk memperbarui layar pada 60fps).  Ini hampir seribu kali lebih besar dari kebanyakan pengukuran yang dilakukan dalam artikel.  Pada skala seperti itu, satu milidetik cukup banyak, dan yang kedua sudah "selamanya." <br><br>  Pengujian menunjukkan bahwa meskipun ada perbedaan besar dalam waktu akses ke memori dan cache, langsung menggunakan rasio ini cukup sulit.  Sebelum mengkompilasi semua data Anda di bawah L1, Anda perlu memastikan bahwa dalam kasus Anda itu benar-benar akan memberikan hasil. <br><br>  Menurut pengujian operasi dengan utas, kami dapat memastikan bahwa membuat dan menghancurkan utas membutuhkan banyak waktu, tetapi melakukan sejumlah besar operasi paralel tidak membawa biaya tambahan. <br><br>  Kesimpulannya, saya ingin mengingatkan Anda aturan paling penting saat mengerjakan kinerja - <b>pengukuran pertama dan baru setelah itu optimasi</b> ! <br><br>  Pembicara profil Dmitry Kurkin di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br><blockquote>  Konversi dan transformasi laporan AppsConf 2018 menjadi artikel sejalan dengan <b>persiapan konferensi</b> 2019 yang <b>semuanya baru</b> .  Hanya ada 7 topik dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar laporan yang diterima</a> sejauh ini, tetapi daftar ini akan berkembang setiap saat sehingga konferensi keren untuk para pengembang ponsel berlangsung <b>pada 22-23 April</b> . <br><br>  Ikuti publikasi, berlangganan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran youtube</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buletin</a> dan kali ini akan terbang dengan cepat. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437590/">https://habr.com/ru/post/id437590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437580/index.html">Bagaimana cara mengingat buku teks JavaScript dalam 5 hari, atau "Istana Memori" dalam kehidupan sehari-hari seorang programmer</a></li>
<li><a href="../id437582/index.html">Tinjauan umum tentang Vue.js 2.6</a></li>
<li><a href="../id437584/index.html">Dasar-Dasar Matematika dari Tata Letak Otomatis</a></li>
<li><a href="../id437586/index.html">Kami membuat aplikasi suara menggunakan contoh Google Assistant</a></li>
<li><a href="../id437588/index.html">Apakah lebih menyenangkan untuk dikembangkan untuk ponsel daripada untuk web?</a></li>
<li><a href="../id437592/index.html">Arsitektur Lapisan Eksekusi Tugas Asinkron</a></li>
<li><a href="../id437594/index.html">Bagaimana saya menghilangkan penyebab kegagapan dan melewatkan bingkai di semua game, dan juga secara tidak sengaja menurunkan suhu hingga 15 derajat</a></li>
<li><a href="../id437596/index.html">OTRS: Otentikasi, otorisasi, dan sinkronisasi LDAP (FreeIPA, AD)</a></li>
<li><a href="../id437598/index.html">Bagaimana cara menyimpan sistem gim dari PC rumahan dengan cara virtualisasi</a></li>
<li><a href="../id437600/index.html">opencv4arts: Gambarkan kotaku, Vincent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>