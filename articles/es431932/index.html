<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇüèª ü•á üë¨ Fort Byte Coche (y m√°s) Nativos americanos üö® üßöüèº üéä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="S√≠, s√≠, es el "byte" y est√° en indio (no indio). Comenzar√© en orden. Recientemente aqu√≠, en Habr√©, comenzaron a aparecer art√≠culos sobre bytecode. Y u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fort Byte Coche (y m√°s) Nativos americanos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431932/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="imagen"><br><br>  S√≠, s√≠, es el "byte" y est√° en indio (no indio).  Comenzar√© en orden.  Recientemente aqu√≠, en Habr√©, comenzaron a aparecer art√≠culos sobre bytecode.  Y una vez, me divert√≠ escribiendo sistemas Fort.  Por supuesto, en ensamblador.  Eran de 16 bits.  Nunca program√© en x86-64.  Incluso con 32 no pudo jugar.  Entonces vino la idea: ¬øpor qu√© no?  ¬øPor qu√© no agitar el fuerte de 64 bits, e incluso con el c√≥digo de bytes?  S√≠, y en Linux, donde tampoco escrib√≠ nada del sistema. <br><br>  Tengo un servidor dom√©stico con Linux.  En general, busqu√© en Google un poco y descubr√≠ que el ensamblador en Linux se llama GAS y el comando as.  Me estoy conectando a trav√©s de SSH al servidor, escribiendo como - ¬°s√≠!  Ya lo tengo instalado.  Todav√≠a necesita un enlazador, escriba ld, ¬°s√≠!  Entonces, e intente escribir algo interesante en ensamblador.  Sin civilizaci√≥n, solo un bosque, como los verdaderos indios :) Sin un entorno de desarrollo, solo una l√≠nea de comando y Midnight Commander.  El editor ser√° Nano, que cuelga de mi F4 en mc.  ¬øC√≥mo est√° cantando el grupo "Zero"?  Un verdadero indio solo necesita una cosa ... ¬øQu√© m√°s necesita un verdadero indio?  Por supuesto, un depurador.  Escribimos gdb - is!  Bueno, presiona Shift + F4 y listo. <br><a name="habracut"></a><br><h2>  Arquitectura </h2><br>  Para empezar, decidamos sobre arquitectura.  Con profundidades de bits ya determinadas, 64 bits.  En las implementaciones cl√°sicas de Fort, el segmento de datos y c√≥digo es el mismo.  Pero trataremos de hacerlo bien.  Solo tendremos el c√≥digo en el segmento de c√≥digo, los datos en el segmento de datos.  Como resultado, obtenemos un n√∫cleo para la plataforma y un c√≥digo de bytes completamente independiente de la plataforma. <br><br>  Tratemos de hacer la m√°quina de bytes apilada m√°s r√°pida (pero sin JIT).  Entonces, tendremos una tabla que contiene 256 direcciones, una para cada comando de byte.  Menos que nada: una verificaci√≥n adicional, estas son 1-2 instrucciones del procesador.  Y necesitamos r√°pidamente, sin compromiso. <br><br><h4>  Pilas </h4><br>  Por lo general, en las implementaciones de Fort, la pila de retorno del procesador (* SP) se usa como una pila de datos, y la pila de retorno del sistema fort se implementa utilizando otros medios.  De hecho, nuestra m√°quina estar√° apilada, y el trabajo principal est√° en la pila de datos.  Por lo tanto, hagamos lo mismo: RSP ser√° una pila de datos.  Bueno, deje que la pila de retorno sea RBP, que tambi√©n, por defecto, funciona con el segmento de pila.  Por lo tanto, tendremos tres segmentos de memoria: un segmento de c√≥digo, un segmento de datos y un segmento de pila (tendr√° una pila de datos y una pila de retorno). <br><br><h4>  Registros </h4><br>  Entro en la descripci√≥n de los registros x86-64, y ¬°Uy!  Hay hasta 8 registros adicionales de prop√≥sito general (R8 - R16), en comparaci√≥n con los modos de 32 o 16 bits. No est√° mal ... <br><br>  Ya decid√≠ que necesitar√°n RSP y RBP.  Todav√≠a necesita un puntero (contador) de los comandos de bytecode.  De las operaciones en este registro, solo se necesita la lectura de memoria.  Los registros principales (RAX, RBX, RCX, RDX, RSI, RDI) son m√°s flexibles, universales, con ellos hay muchos comandos especiales.  Nos ser√°n √∫tiles para diversas tareas, y para el contador de instrucciones de bytecode tomamos uno de los nuevos registros para m√≠, que sea R8. <br><br><h2>  Empecemos </h2><br>  No tengo experiencia programando en Linux en lenguaje ensamblador.  Por lo tanto, para empezar, encontraremos el "Hola, mundo" terminado para comprender c√≥mo se inicia el programa y muestra el texto.  Inesperadamente para m√≠, encontr√© opciones con una sintaxis extra√±a donde incluso la fuente y el receptor est√°n reorganizados.  Result√≥ que esta es la sintaxis de AT&amp;T, y est√° escrita principalmente bajo GAS.  Pero se admite otra opci√≥n de sintaxis, se llama sintaxis Intel.  Pensando, decid√≠ usarlo de todos modos.  Bueno, escriba al principio de .intel_syntax noprefix. <br><br>  Compile y ejecute "Hola, mundo" para asegurarse de que todo funcione.  Al leer la ayuda y los experimentos, comenc√© a usar el siguiente comando para compilar: <br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt</code> <br>  Aqu√≠, el modificador -o indica el archivo de resultados, el modificador -g indica que genere informaci√≥n de depuraci√≥n y el modificador -ahlsm establece el formato de listado.  Y mantengo la salida en la lista, en ella puedes ver muchas cosas √∫tiles.  Admito que, al comienzo del trabajo, no hice el listado y ni siquiera especifiqu√© el modificador -g.  Comenc√© a usar el modificador -g despu√©s del primer uso del depurador y comenc√© a hacer la lista despu√©s de que aparecieran las macros en el c√≥digo :) <br><br>  Despu√©s de eso, usamos el enlazador, pero aqu√≠ no hay nada m√°s simple: <br><br> <code>$ ld forth.o -o forth</code> <br>  Bueno, corre! <br> <code>$ ./forth <br> Hello, world!</code> <br>  Funciona <br><br><div class="spoiler">  <b class="spoiler_title">Esta fue la primera cuarta vez. Asm (en realidad es 'Hellow, world!', Por supuesto)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix .section .data msg: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> len = . - msg #  len    .section .text .global _start #     _start: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, OFFSET FLAT:msg #     mov edx, len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit xor ebx, ebx #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> <br>  Por cierto, m√°s tarde descubr√≠ que en x86-64 es m√°s correcto usar syscall para una llamada al sistema, en lugar de int 0x80.  La llamada 0x80 se considera obsoleta para esta arquitectura, aunque es compatible. <br></div></div><br>  Se ha comenzado y ahora ... <br><br><h2>  Vamos! </h2><br>  Para que haya al menos algunos detalles, escribiremos el c√≥digo de un comando de byte.  Deje que sea la palabra Fort "0", poniendo 0 en la parte superior de la pila: <br><br><pre> <code class="cpp hljs">bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br>  En el momento en que se ejecuta este comando, R8 ya apunta al siguiente comando de byte.  Es necesario leerlo, aumentar R8, determinar la direcci√≥n ejecutable por el c√≥digo del comando byte y transferirle el control. <br><br>  Pero ... ¬øqu√© profundidad de bits ser√° la tabla de direcciones de byte-command?  Luego tuve que profundizar en el nuevo sistema de comando x86-64 para m√≠.  Por desgracia, no encontr√© comandos que le permitan ir al desplazamiento en la memoria.  Por lo tanto, calcule la direcci√≥n o la direcci√≥n estar√° lista: 64 bits.  No hay tiempo para que calculemos, lo que significa - 64 bits.  En este caso, el tama√±o de la tabla ser√° 256 * 8 = 4096 bytes.  Bueno, finalmente, codifique la llamada _next: <br><br><pre> <code class="cpp hljs">_next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-meta"><span class="hljs-meta"># bcmd -   -</span></span></code> </pre><br>  No est√° mal, me parece ... Solo hay tres instrucciones de procesador, cuando se cambia de un comando de byte a otro. <br><br>  De hecho, estos comandos no fueron tan f√°ciles para m√≠.  Tuve que profundizar en el sistema de comando 0x86-64 nuevamente y encontrar un nuevo comando MOVZX para m√≠.  De hecho, este comando convierte un valor de 8, 16 o 32 bits en un registro de 64 bits.  Hay dos variantes de este comando: sin signo, donde los d√≠gitos m√°s altos se rellenan con ceros, y el firmado es MOVSX.  En la versi√≥n firmada, el signo se expande, es decir, para los n√∫meros positivos, los ceros ir√°n a los d√≠gitos m√°s altos, y para los negativos, los n√∫meros.  Esta opci√≥n tambi√©n nos es √∫til para el comando de byte iluminado. <br><br>  Por cierto, ¬øes esta opci√≥n la m√°s r√°pida?  ¬øQuiz√°s alguien sugiera a√∫n m√°s r√°pido? <br><br>  Bueno, ahora tenemos una m√°quina de bytes que puede ejecutar una secuencia de comandos de bytes y ejecutarlos.  Es necesario probarlo en la pr√°ctica, para forzar la ejecuci√≥n de al menos un equipo.  Pero cual?  Cero en la pila?  Pero aqu√≠ ni siquiera sabe el resultado, si no mira la pila debajo del depurador ... Pero si el programa comenz√≥, se puede completar :) <br><br>  Escribimos un comando bye que completa el programa y escribe sobre √©l, especialmente porque tenemos "Hellow, world!". <br><br><pre> <code class="cpp hljs">bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre><br>  Lo √∫nico que queda es crear una tabla de direcciones de comando de bytes, inicializar los registros e iniciar la m√°quina de bytes.  Entonces ... hay 256 valores en la tabla, y hay dos comandos.  ¬øQu√© hay en las otras celdas? <br>  El resto tendr√° un c√≥digo de operaci√≥n no v√°lido.  Pero no puede verificarlo, estos son equipos adicionales, tenemos tres ahora y con el cheque ser√°n cinco.  Por lo tanto, haremos un comando tan dif√≠cil: un mal equipo.  Primero, completamos toda la tabla y luego comenzamos a ocupar las celdas con comandos √∫tiles.  Deje que el equipo malo tenga el c√≥digo 0x00, el equipo adi√≥s - 0x01, y el '0' tendr√° el c√≥digo 0x02, una vez que ya est√© escrito.  El equipo malo por ahora har√° lo mismo que adi√≥s, solo que con un c√≥digo de finalizaci√≥n y texto diferentes (lo pondr√© en el spoiler, casi lo mismo que adi√≥s): <br><br><div class="spoiler">  <b class="spoiler_title">bcmd_bad</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> </div></div>  Ahora dibuja una tabla de direcciones.  Para mayor comodidad, colocaremos ocho en cada fila, habr√° 16 filas. La tabla es bastante grande: <br><br><div class="spoiler">  <b class="spoiler_title">Tabla de direcciones de comando de bytes</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad</code> </pre> </div></div>  Escribimos el cuerpo del programa de bytes.  Para hacer esto, asigne c√≥digos de comando a las variables de ensamblador.  Tendremos los siguientes acuerdos: <br><br><ul><li>  Las direcciones para ejecutar comandos de bytes comenzar√°n en bcmd_ </li><li>  Los c√≥digos de comando se almacenar√°n en variables que comienzan con b_ </li></ul><br>  Por lo tanto, el cuerpo del programa de bytes ser√° as√≠: <br><br><pre> <code class="cpp hljs">start: .byte b_bye</code> </pre><br>  Declare el tama√±o de la pila de datos como stack_size.  Que sea hasta ahora 1024. En la inicializaci√≥n, haremos RBP = RSP - stack_size. <br><br><div class="spoiler">  <b class="spoiler_title">En realidad, obtenemos un c√≥digo de programa de este tipo (forth.asm)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br></div></div><br>  Compilar, ejecutar: <br><br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt <br> $ ld forth.o -o forth <br> $ ./forth <br> bye! <br></code> <br>  Funciona!  Nuestro primer programa de bytecode de un byte fue lanzado :) <br>  Por supuesto, esto ser√° as√≠ si todo se hace correctamente.  Y si no, entonces el resultado probablemente sea este: <br><br> <code>$ ./forth <br>   <br></code> <br>  Por supuesto, otras opciones son posibles, pero me he encontrado con esto con mayor frecuencia.  Y necesitamos un depurador. <br><br><div class="spoiler">  <b class="spoiler_title">Letras de Debugger</b> <div class="spoiler_text">  Como ya se mencion√≥, us√© GDB.  Este es un depurador bastante potente, pero con una interfaz de l√≠nea de comandos.  Ejecutarlo es muy simple: <br><br><pre> <code class="plaintext hljs">$ gdb ./forth GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1 Copyright (C) 2016 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type "show copying" and "show warranty" for details. This GDB was configured as "x86_64-linux-gnu". Type "show configuration" for configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;. For help, type "help". Type "apropos word" to search for commands related to "word"... Reading symbols from ./forth...done. (gdb)</code> </pre> <br>  Luego, al ingresar comandos, depuramos.  Ten√≠a suficientes horas para encontrar algunos comandos necesarios y aprender a usarlos para la depuraci√≥n.  Aqu√≠ est√°n: <br>  b &lt;etiqueta&gt; - establece un punto de interrupci√≥n <br>  l &lt;etiqueta&gt; - ver c√≥digo fuente <br>  r - inicia o reinicia el programa <br>  ir - ver el estado de los registros del procesador <br>  s - paso <br><br>  Por cierto, ¬ørecuerdas que necesitas compilar el programa con el modificador -g?  De lo contrario, las etiquetas y el c√≥digo fuente no estar√°n disponibles.  En este caso, ser√° posible depurar solo mediante c√≥digo desmontado y usar las direcciones en la memoria.  Nosotros, por supuesto, somos indios, pero no en la misma medida ... </div></div><br>  Pero de alguna manera el programa hace muy poco.  Solo le decimos "Hola" e inmediatamente ella dice "¬°Adi√≥s!".  Hagamos el verdadero "¬°Hola mundo!"  en bytecode.  Para hacer esto, coloque la direcci√≥n y la longitud de la cadena en la pila, luego ejecute el comando que muestra la cadena y luego el comando bye.  Para hacer todo esto, se requieren nuevos comandos: escriba para generar la cadena y se enciende para poner la direcci√≥n y la longitud de la cadena.  Primero escribimos tipo, dejemos que su c√≥digo sea 0x80.  Nuevamente, necesitamos ese c√≥digo con la llamada sys_write: <br><br><pre> <code class="cpp hljs">b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br>  Aqu√≠ tomamos la direcci√≥n y la longitud de la cadena de la pila de datos usando comandos POP.  Llamar a int 0x80 puede cambiar el registro de R8, por lo que lo guardamos.  No hicimos esto antes porque el programa estaba terminando.  El contenido de estos registros no le importaba.  Ahora, este es un comando de byte normal, despu√©s del cual el c√≥digo de byte contin√∫a ejecut√°ndose, y debe comportarse bien. <br><br>  Ahora escribamos el encendido.  Este ser√° nuestro primer equipo con par√°metros.  Despu√©s del byte con el c√≥digo para este comando, habr√° bytes que contienen el n√∫mero que colocar√° en la pila.  La pregunta surge de inmediato: ¬øqu√© profundidad de bits se necesita aqu√≠?  Para poner cualquier n√∫mero, necesitas 64 bits.  Pero, cada vez que el comando ocupar√° 9 bytes, ¬øqu√© pondr√≠a un n√∫mero?  As√≠ que perdemos compacidad, una de las principales propiedades del c√≥digo de bytes, y el c√≥digo de Fort tambi√©n ... <br><br>  La soluci√≥n es simple: crearemos varios comandos para diferentes profundidades de bits.  Estos ser√°n lit8, lit16, lit32 y lit64.  Para n√∫meros peque√±os usaremos lit8 y lit16, para n√∫meros m√°s grandes: lit32 y lit64.  Los n√∫meros peque√±os se usan con mayor frecuencia, y para ellos habr√° el comando m√°s corto, que toma dos bytes.  ¬°No est√° mal! .. Haremos que los c√≥digos de estos comandos sean 0x08 - 0x0B. <br><br><pre> <code class="cpp hljs">b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next</code> </pre> <br>  Aqu√≠ usamos el comando MOVSX: esta es una versi√≥n ic√≥nica del comando MOVZX que ya conocemos.  R8 tenemos un contador de comando de bytes.  Cargamos el valor del tama√±o deseado en √©l, lo movemos al siguiente comando y colocamos el valor convertido a 64 bits en la pila. <br><br>  <b>No olvide agregar las direcciones de los nuevos equipos en la tabla a las posiciones deseadas.</b> <br><br>  Todo est√° listo para escribir su primer programa "¬°Hola, mundo!"  en nuestro bytecode.  ¬°Trabajemos con el compilador!  :) <br><br><pre> <code class="cpp hljs">start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye</code> </pre> <br>  Utilizamos dos comandos iluminados diferentes: lit64, que colocar√≠a la direcci√≥n de la cadena en la pila, y lit8, con el que colocamos la longitud en la pila.  A continuaci√≥n, ejecutamos dos comandos de byte m√°s: type y bye. <br>  Compilar, ejecutar: <br><br><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! bye!</code> </pre><br>  Gan√≥ nuestro bytecode!  Este es el resultado que deber√≠a ser, si todo est√° bien. <br><br><div class="spoiler">  <b class="spoiler_title">Fuente completa</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre> <br></div></div><br>  Pero las posibilidades siguen siendo muy primitivas, no se puede hacer una condici√≥n, un ciclo. <br><br>  Como es imposible  ¬°Puedes, todo est√° en nuestras manos!  Hagamos esta l√≠nea en el bucle 10 veces.  Esto requerir√° un comando de ramificaci√≥n condicional, as√≠ como un poco de aritm√©tica de pila: un comando que disminuye el valor en la pila en 1 (en fort "1-") y un comando de duplicaci√≥n de v√©rtices ("dup"). <br><br>  Con la aritm√©tica, todo es simple, ni siquiera comentar√©: <br><br><pre> <code class="cpp hljs">b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next</code> </pre> <br>  Ahora un salto condicional.  Para empezar, simplifiquemos la tarea: una transici√≥n incondicional.  Est√° claro que solo necesita cambiar el valor del registro R8.  Lo primero que viene a la mente es un comando de bytes, seguido de un par√°metro: la direcci√≥n de transici√≥n es de 64 bits.  De nuevo nueve bytes.  ¬øNecesitamos estos nueve bytes?  Las transiciones generalmente ocurren en distancias cortas, a menudo dentro de unos pocos cientos de bytes.  Por lo tanto, no utilizaremos la direcci√≥n, sino el desplazamiento. <br><br>  ¬øProfundidad de bits?  En muchos casos, 8 bits (127 hacia adelante / hacia atr√°s) ser√°n suficientes, pero a veces esto no ser√° suficiente.  Por lo tanto, haremos lo mismo que con el comando encendido, haremos dos opciones: 8 y 16 d√≠gitos, los c√≥digos de comando ser√°n 0x10 y 0x11: <br><br><pre> <code class="cpp hljs">b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next</code> </pre>  Ahora la transici√≥n condicional es f√°cil de implementar.  Si la pila es 0, vaya a _next, y si no, vaya al comando de bifurcaci√≥n. <br><pre> <code class="cpp hljs">b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora tenemos todo para hacer un bucle: </font></font><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los dos primeros comandos: colocamos el contador de bucles en la pila. </font><font style="vertical-align: inherit;">A continuaci√≥n, imprima la cadena Hola. </font><font style="vertical-align: inherit;">Luego restamos 1 del contador, lo duplicamos y realizamos (o no realizamos) la transici√≥n. </font><font style="vertical-align: inherit;">El comando de duplicaci√≥n es necesario porque el comando de ramificaci√≥n condicional toma el valor de la parte superior de la pila. </font><font style="vertical-align: inherit;">La transici√≥n aqu√≠ es de ocho bits, ya que la distancia es de solo unos pocos bytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ponemos las direcciones de los nuevos comandos en una tabla, compilamos y ejecutamos.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo pondr√© en un spoiler, de lo contrario nuestro programa se ha vuelto detallado)</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bueno, ya podemos hacer condiciones y ciclos! </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente completa</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero hasta que a la m√°quina de bytes completada le falte otra funci√≥n muy importante. </font><font style="vertical-align: inherit;">No podemos llamar a otro desde el c√≥digo de bytes. </font><font style="vertical-align: inherit;">No tenemos lo que se llama rutinas, procedimientos, etc. </font><font style="vertical-align: inherit;">Y en el fuerte, sin esto, no podemos usar palabras que no sean palabras del n√∫cleo en algunas palabras. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llevamos el trabajo al final. </font><font style="vertical-align: inherit;">Aqu√≠ por primera vez necesitamos una pila de devoluciones. </font><font style="vertical-align: inherit;">Se necesitan dos comandos: el comando de llamada y el comando de retorno (llamar y salir).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El comando de llamada, en principio, hace lo mismo que la rama: transfiere el control a otro c√≥digo de bytes. </font><font style="vertical-align: inherit;">Pero, a diferencia de la rama, a√∫n necesita guardar la direcci√≥n de retorno en la pila de retorno para poder regresar y continuar la ejecuci√≥n. </font><font style="vertical-align: inherit;">Hay otra diferencia: tales llamadas pueden ocurrir a distancias mucho mayores. </font><font style="vertical-align: inherit;">Por lo tanto, hacemos el comando de llamada en forma de rama, pero en tres versiones: 8, 16 y 32 bits.</font></font><br><br><pre> <code class="cpp hljs">b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver, aqu√≠, a diferencia de las transiciones, se agregan 3 equipos. Uno de ellos reorganiza R8 al siguiente comando de byte, y los dos restantes almacenan el valor recibido en la pila de retorno. Por cierto, aqu√≠ intent√© no poner las instrucciones del procesador una al lado de la otra, de modo que el transportador del procesador pudiera ejecutar los comandos en paralelo. Pero no s√© cu√°nto esto da un efecto. Si lo desea, puede verificar las pruebas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debe tenerse en cuenta que la formaci√≥n de un argumento para el comando de llamada es algo diferente que para la rama. Para la bifurcaci√≥n, el desplazamiento se calcula como la diferencia entre la direcci√≥n de la bifurcaci√≥n y la direcci√≥n del byte que sigue al comando de byte. Y para el comando de llamada, esta es la diferencia entre la direcci√≥n de salto y la direcci√≥n del siguiente comando.</font></font> ¬øPor qu√© se necesita esto?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto da como resultado menos instrucciones del procesador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora el comando de retorno. </font><font style="vertical-align: inherit;">En realidad, su trabajo es solo restaurar R8 de la pila de retorno y transferir el control a la m√°quina de bytes:</font></font><br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estos comandos se utilizar√°n con mucha frecuencia y deben optimizarse al m√°ximo. </font><font style="vertical-align: inherit;">El comando de byte de salida ocupa tres instrucciones de m√°quina. </font><font style="vertical-align: inherit;">¬øEs posible reducir algo aqu√≠? </font><font style="vertical-align: inherit;">Resulta que puedes! </font><font style="vertical-align: inherit;">Simplemente puede eliminar el comando de transici√≥n :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer esto, col√≥quelo sobre el punto de entrada de la m√°quina _next byte:</font></font><br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por cierto, los comandos m√°s importantes y de uso m√°s frecuente (por ejemplo, llamada) deben colocarse m√°s cerca de la m√°quina de bytes para que el compilador pueda formar un comando de salto corto. </font><font style="vertical-align: inherit;">Esto es claramente visible en el listado. </font><font style="vertical-align: inherit;">Aqu√≠ hay un ejemplo.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">262</span></span> <span class="hljs-number"><span class="hljs-number">0084</span></span> <span class="hljs-number"><span class="hljs-number">490F</span></span>BE00 bcmd_lit8: movsx rax, byte ptr [r8] <span class="hljs-number"><span class="hljs-number">263</span></span> <span class="hljs-number"><span class="hljs-number">0088</span></span> <span class="hljs-number"><span class="hljs-number">49F</span></span>FC0 inc r8 <span class="hljs-number"><span class="hljs-number">264</span></span> <span class="hljs-number"><span class="hljs-number">008b</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">265</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>c EB90 jmp _next <span class="hljs-number"><span class="hljs-number">266</span></span> <span class="hljs-number"><span class="hljs-number">267</span></span> b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> <span class="hljs-number"><span class="hljs-number">268</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>e <span class="hljs-number"><span class="hljs-number">490F</span></span>BF00 bcmd_lit16: movsx rax, word ptr [r8] <span class="hljs-number"><span class="hljs-number">269</span></span> <span class="hljs-number"><span class="hljs-number">0092</span></span> <span class="hljs-number"><span class="hljs-number">4983</span></span>C002 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span> <span class="hljs-number"><span class="hljs-number">0096</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">271</span></span> <span class="hljs-number"><span class="hljs-number">0097</span></span> EB85 jmp _next <span class="hljs-number"><span class="hljs-number">272</span></span> <span class="hljs-number"><span class="hljs-number">273</span></span> b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> <span class="hljs-number"><span class="hljs-number">274</span></span> <span class="hljs-number"><span class="hljs-number">0099</span></span> <span class="hljs-number"><span class="hljs-number">496300</span></span> bcmd_lit32: movsx rax, dword ptr [r8] <span class="hljs-number"><span class="hljs-number">275</span></span> <span class="hljs-number"><span class="hljs-number">009</span></span>c <span class="hljs-number"><span class="hljs-number">4983</span></span>C004 add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">276</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a0 <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a1 E978FFFF jmp _next <span class="hljs-number"><span class="hljs-number">277</span></span> FF <span class="hljs-number"><span class="hljs-number">278</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠, en la l√≠nea 265 y 271, el comando jmp toma 2 bytes cada uno, y en la l√≠nea 277, el mismo comando ya est√° compilado a 5 bytes, ya que la distancia de salto excedi√≥ la longitud del comando corto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, los comandos de byte como bad, bye, type se reorganizan a√∫n m√°s, y como call, branch, lit est√°n m√°s cerca. Desafortunadamente, no hay mucho que pueda caber en una transici√≥n de 127 bytes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregamos nuevos comandos a la tabla de direcciones de comandos de acuerdo con sus c√≥digos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, ahora tenemos un desaf√≠o y un retorno, ¬°los probaremos! Para hacer esto, seleccione la impresi√≥n de l√≠nea en un procedimiento separado, y lo llamaremos en un bucle dos veces. Y el n√∫mero de repeticiones del ciclo se reduce a tres.</font></font><br><br><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call8 podr√≠a usarse aqu√≠, pero decid√≠ usar call16 como el m√°s usado. </font><font style="vertical-align: inherit;">El valor 2 se resta debido a las peculiaridades de calcular la direcci√≥n para el comando de byte de llamada sobre el que escrib√≠. </font><font style="vertical-align: inherit;">Para call8, 1 se deducir√° aqu√≠, para call32, respectivamente, 4. Compilamos </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y llamamos:</font></font><br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Bad byte code!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vaya ... como dicen, algo sali√≥ mal :) Bueno, lanzamos GDB y vemos qu√© sucede all√≠. </font><font style="vertical-align: inherit;">Establec√≠ un punto de interrupci√≥n inmediatamente en bcmd_exit, ya que est√° claro que la llamada sub_hello est√° pasando, y el cuerpo de la rutina se ejecuta ... comenz√≥ ... y el programa no alcanz√≥ el punto de interrupci√≥n. </font><font style="vertical-align: inherit;">Inmediatamente hubo una sospecha de un c√≥digo de comando de byte. </font><font style="vertical-align: inherit;">Y, de hecho, la raz√≥n estaba en √©l. </font><font style="vertical-align: inherit;">b_exit Asigne el valor 0x1f, y la direcci√≥n en s√≠ se coloc√≥ en el n√∫mero de celda de la tabla 0x17. </font><font style="vertical-align: inherit;">Bueno, entonces corregir√© el valor de b_exit a 0x17 e intentar√© nuevamente:</font></font><br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exactamente seis veces saludo, y una vez adi√≥s. </font><font style="vertical-align: inherit;">Como deber√≠a ser :)</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente completa</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next b_exit = <span class="hljs-number"><span class="hljs-number">0x17</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br></div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cual es el resultado </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hicimos y probamos una m√°quina de bytes de pila completa y bastante r√°pida de 64 bits. En velocidad, quiz√°s esta m√°quina de bytes sea una de las m√°s r√°pidas de su clase (una m√°quina de bytes de pila sin JIT). Ella sabe c√≥mo ejecutar comandos secuencialmente, hacer saltos condicionales e incondicionales, llamar a procedimientos y regresar de ellos. Al mismo tiempo, el c√≥digo de bytes utilizado es razonablemente compacto. B√°sicamente, los comandos de bytes toman 1-3 bytes, m√°s es muy raro (solo n√∫meros grandes y llamadas a procedimientos muy distantes). Tambi√©n se dibuja un peque√±o conjunto de comandos de bytes, que es f√°cil de expandir. Supongamos que todos los comandos b√°sicos para trabajar con la pila (drop, swap, over, root, etc. se pueden escribir en 20 minutos, la misma cantidad se destinar√° a los comandos de enteros aritm√©ticos).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro punto importante. El bytecode, a diferencia del cl√°sico c√≥digo de costura directa fuerte, no contiene instrucciones de la m√°quina, por lo que puede transferirse sin recompilaci√≥n a otra plataforma. Es suficiente reescribir el n√∫cleo una vez en el sistema de instrucciones del nuevo procesador, y esto se puede hacer muy r√°pidamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La versi√≥n actual de la m√°quina de bytes no es espec√≠fica de ning√∫n idioma en particular. Pero quiero implementar el lenguaje Fort en √©l porque tengo experiencia con √©l y el compilador se puede hacer muy r√°pidamente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si hay inter√©s en esto, en base a esta m√°quina, en el pr√≥ximo art√≠culo, har√© entradas y salidas de cadenas y n√∫meros, un diccionario fuerte y un int√©rprete. Puede "tocar" al equipo con las manos. Bueno, en el tercer art√≠culo haremos un compilador y obtendremos un sistema fort casi completo. Entonces ser√° posible escribir y compilar algunos algoritmos est√°ndar y comparar el rendimiento con otros lenguajes y sistemas. Puede usar, por ejemplo, el tamiz de Erat√≥stenes, y similares.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es interesante experimentar con opciones. </font><font style="vertical-align: inherit;">Por ejemplo, cree la tabla de comandos de 16 bits y vea c√≥mo esto afectar√° el rendimiento. </font><font style="vertical-align: inherit;">Tambi√©n puede convertir el punto de entrada _next en una macro, en cuyo caso el c√≥digo de m√°quina de cada comando de byte aumentar√° de tama√±o en dos comandos (menos la transici√≥n y m√°s tres comandos de _next). </font><font style="vertical-align: inherit;">Es decir, al final no habr√° transici√≥n a _next, pero el contenido del _next apunta en s√≠ mismo (esto es 14 bytes). </font><font style="vertical-align: inherit;">Es interesante saber c√≥mo esto afectar√° el rendimiento. </font><font style="vertical-align: inherit;">Tambi√©n puede intentar hacer la optimizaci√≥n usando registros. </font><font style="vertical-align: inherit;">Por ejemplo, un bucle est√°ndar con un contador en el fuerte almacena el contador en la pila de devoluci√≥n. </font><font style="vertical-align: inherit;">Puede hacer una versi√≥n de registro y tambi√©n probarla. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n puede hacer un compilador de expresiones escritas en la forma cl√°sica (por ejemplo, A = 5 + (B + C * 4)).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬°En general, hay espacio para la experimentaci√≥n! </font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuaci√≥n: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte-m√°quina para el fuerte (y no solo) en nativos americanos (parte 2)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431932/">https://habr.com/ru/post/es431932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431920/index.html">Frontend Mix: informes sobre Node.js, escalabilidad y web nativa</a></li>
<li><a href="../es431922/index.html">¬øQu√© son los manejadores de m√©todos en Java?</a></li>
<li><a href="../es431924/index.html">Sistema de gesti√≥n de almacenes mediante CQRS y Event Sourcing. Proceso de desarrollo</a></li>
<li><a href="../es431928/index.html">Fatiga por art√≠culos desechables. O la oda A.S. Makarenko</a></li>
<li><a href="../es431930/index.html">Reuni√≥n de DevOps en San Petersburgo</a></li>
<li><a href="../es431934/index.html">¬øC√≥mo ayuda la inteligencia artificial a trabajar con documentos legales? Conferencia de Egor Budnikov de ABBYY</a></li>
<li><a href="../es431936/index.html">Resultados del concurso TechnoText</a></li>
<li><a href="../es431938/index.html">Ra√≠z de cubo entero en Verilog</a></li>
<li><a href="../es431940/index.html">Las personas se agotan si no sienten su val√≠a. ¬øQu√© hacer al respecto?</a></li>
<li><a href="../es431942/index.html">Inyecci√≥n de dependencia jer√°rquica en React y MobX State Tree como modelo de dominio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>