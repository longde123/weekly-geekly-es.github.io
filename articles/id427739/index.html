<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♀️ 💇🏻 🍙 DDD, Hexagonal, Bawang, Bersih, CQRS ... bagaimana saya menggabungkan semuanya 👊 👨🏽‍🎤 📬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini adalah bagian dari Kronik Arsitektur Perangkat Lunak , serangkaian artikel tentang arsitektur perangkat lunak. Di dalamnya saya menulis te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DDD, Hexagonal, Bawang, Bersih, CQRS ... bagaimana saya menggabungkan semuanya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427739/"> <a href=""><img src="https://habrastorage.org/webt/mm/07/bx/mm07bx1u2dxlgab0prkzllunvf8.png"></a> <br><br>  Artikel ini adalah bagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kronik Arsitektur Perangkat Lunak</a> , serangkaian artikel tentang arsitektur perangkat lunak.  Di dalamnya saya menulis tentang apa yang saya pelajari tentang arsitektur perangkat lunak, apa yang saya pikirkan dan bagaimana saya menggunakan pengetahuan.  Konten artikel ini mungkin lebih masuk akal jika Anda membaca artikel sebelumnya dalam seri. <br><br>  Setelah lulus dari universitas, saya mulai bekerja sebagai guru sekolah menengah, tetapi beberapa tahun yang lalu saya berhenti dan pergi ke pengembang perangkat lunak penuh waktu. <br><br>  Sejak itu, saya selalu merasa bahwa saya harus memulihkan waktu yang "hilang" dan mencari tahu sebanyak mungkin, secepat mungkin.  Oleh karena itu, saya mulai terlibat dalam eksperimen sedikit, banyak membaca dan menulis, memberikan perhatian khusus pada desain dan arsitektur perangkat lunak.  Itulah sebabnya saya menulis artikel ini untuk membantu diri saya sendiri dalam studi saya. <br><a name="habracut"></a><br>  Dalam artikel terakhir, saya berbicara tentang banyak konsep dan prinsip yang saya pelajari, dan sedikit tentang bagaimana saya memikirkannya.  Tapi saya membayangkan mereka sebagai pecahan dari satu teka-teki besar. <br><br>  Artikel ini adalah tentang bagaimana saya mengumpulkan semua fragmen ini.  Saya pikir saya harus memberi mereka nama, jadi saya akan memanggil mereka <b>arsitektur eksplisit</b> .  Selain itu, semua konsep ini <i>"diuji dalam pertempuran"</i> dan digunakan dalam produksi pada platform yang sangat andal.  Salah satunya adalah platform e-commerce SaaS dengan ribuan toko online di seluruh dunia, yang lainnya adalah platform perdagangan yang beroperasi di dua negara dengan bus pesan yang memproses lebih dari 20 juta pesan per bulan. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blok mendasar dari sistem</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alat-alatnya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghubungkan alat dan mekanisme pengiriman ke inti aplikasi</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pelabuhan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Adaptor primer atau kontrol</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Adaptor Sekunder atau Terkelola</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kontrol inversi</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Organisasi inti aplikasi</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tingkat aplikasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tingkat domain</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan Domain</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Model domain</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komponen</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Putuskan Komponen</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memicu logika pada komponen lain</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengambil data dari komponen lain</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penyimpanan data bersama untuk komponen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pisahkan penyimpanan data untuk komponen</a> </li></ul></li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengontrol aliran</a> </li></ul><br><a name="1"></a><h1>  Blok mendasar dari sistem </h1><br>  Mari kita mulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengingat</a> arsitektur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EBI</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ports &amp; Adapters</a> .  Keduanya jelas memisahkan kode internal dan eksternal aplikasi, serta adaptor untuk menghubungkan kode internal dan eksternal. <br><br>  Selain itu, arsitektur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ports &amp; Adapters</a> secara eksplisit mendefinisikan tiga blok kode mendasar dalam sistem: <br><br><ul><li>  Itu memungkinkan Anda untuk menjalankan <b>antarmuka pengguna</b> , terlepas dari jenisnya. </li><li>  <b>Logika bisnis</b> sistem atau <b>inti aplikasi</b> .  Ini digunakan oleh UI untuk melakukan transaksi nyata. </li><li>  Kode <b>infrastruktur</b> yang menghubungkan inti aplikasi kita ke alat-alat seperti database, mesin pencari, atau API pihak ketiga. </li></ul><br> <a href=""><img src="https://habrastorage.org/webt/7q/gt/h5/7qgth5e95mntgholpnrryv4zbm4.png"></a> <br><br>  Inti dari aplikasi adalah hal yang paling penting untuk dipikirkan.  Kode ini memungkinkan Anda untuk melakukan tindakan nyata dalam sistem, yaitu, ini adalah aplikasi kami.  Beberapa antarmuka pengguna (aplikasi web progresif, aplikasi seluler, CLI, API, dll.) Dapat bekerja dengannya, semuanya berjalan pada satu inti. <br><br>  Seperti yang dapat Anda bayangkan, alur eksekusi yang umum terjadi dari kode di UI melalui inti aplikasi ke kode infrastruktur, kembali ke inti aplikasi dan, akhirnya, respons dikirim ke UI. <br><br> <a href=""><img src="https://habrastorage.org/webt/vn/7q/5u/vn7q5usrs1m2ftgkfmzagymrlfw.png"></a> <br><br><a name="2"></a><h1>  Alat-alatnya </h1><br>  Jauh dari kode kernel yang paling penting, masih ada alat yang digunakan aplikasi.  Misalnya, mesin basis data, mesin pencari, server web, dan konsol CLI (meskipun dua yang terakhir juga merupakan mekanisme pengiriman). <br><br> <a href=""><img src="https://habrastorage.org/webt/_o/aj/rn/_oajrnom8cuphtclxgw-m-sgars.png"></a> <br><br>  Rasanya aneh menempatkan konsol CLI di bagian tematik yang sama dengan DBMS, karena mereka memiliki tujuan yang berbeda.  Namun pada kenyataannya, keduanya adalah alat yang digunakan oleh aplikasi.  Perbedaan utama adalah bahwa konsol CLI dan server web <b>memberi tahu aplikasi untuk melakukan sesuatu</b> , sebaliknya DBMS kernel, <b>menerima perintah dari aplikasi</b> .  Ini adalah perbedaan yang sangat penting, karena sangat memengaruhi cara kita menulis kode untuk menghubungkan alat-alat ini ke inti aplikasi. <br><br><a name="3"></a><h1>  Menghubungkan alat dan mekanisme pengiriman ke inti aplikasi </h1><br>  Blok alat penghubung kode ke inti aplikasi disebut adapter ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur Ports &amp; Adapters</a> ).  Mereka memungkinkan logika bisnis untuk berinteraksi dengan alat tertentu, dan sebaliknya. <br><br>  Adaptor yang memberi tahu aplikasi untuk melakukan sesuatu disebut <b>adaptor primer atau kontrol</b> , sedangkan adaptor yang memberi tahu aplikasi untuk melakukan sesuatu disebut <b>adaptor sekunder atau terkelola</b> . <br><br><a name="4"></a><h2>  Pelabuhan </h2><br>  Namun, <i>adaptor</i> ini tidak dibuat secara kebetulan, tetapi untuk menyesuaikan dengan titik masuk tertentu di inti aplikasi, <i><b>port</b></i> .  Port <b>tidak lebih dari spesifikasi</b> bagaimana alat dapat menggunakan inti aplikasi atau sebaliknya.  Dalam sebagian besar bahasa dan dalam bentuknya yang paling sederhana, port ini akan menjadi antarmuka, tetapi sebenarnya ia dapat terdiri dari beberapa antarmuka dan DTO. <br><br>  Penting untuk dicatat bahwa <b>port (antarmuka) ada di dalam logika bisnis</b> , dan adaptor ada di luar.  Agar templat ini berfungsi dengan baik, sangat penting untuk membuat port sesuai dengan kebutuhan inti aplikasi, dan tidak hanya meniru API alat. <br><br><a name="5"></a><h2>  Adaptor primer atau kontrol </h2><br>  Adaptor primer atau kontrol <b>membungkus port</b> dan menggunakannya untuk memberi tahu kernel aplikasi apa yang harus dilakukan.  <b>Mereka mengubah semua data dari mekanisme pengiriman menjadi panggilan metode dalam inti aplikasi.</b> <br><br> <a href=""><img src="https://habrastorage.org/webt/p3/6x/rc/p36xrcnsvtfgxpmnpb2f48vtguw.png"></a> <br><br>  Dengan kata lain, adaptor kontrol kami adalah pengontrol atau perintah konsol, mereka tertanam dalam konstruktor mereka dengan beberapa objek yang kelasnya mengimplementasikan antarmuka (port) yang diperlukan oleh perintah pengontrol atau konsol. <br><br>  Dalam contoh yang lebih spesifik, port mungkin adalah antarmuka layanan atau antarmuka repositori yang dibutuhkan pengontrol.  Implementasi spesifik dari layanan, repositori, atau permintaan kemudian diimplementasikan dan digunakan dalam controller. <br><br>  Selain itu, port bisa berupa bus perintah atau antarmuka bus permintaan.  Dalam hal ini, implementasi spesifik dari perintah atau bus permintaan dimasukkan ke dalam controller, yang kemudian membuat perintah atau permintaan dan meneruskannya ke bus yang sesuai. <br><br><a name="6"></a><h2>  Adaptor Sekunder atau Terkelola </h2><br>  Tidak seperti control Adapters yang membungkus port, <b>Adaptor yang dikelola</b> mengimplementasikan port, sebuah interface, dan kemudian memasukkan inti aplikasi di mana port diperlukan (dengan tipe). <br><br> <a href=""><img src="https://habrastorage.org/webt/rw/hz/bo/rwhzboewldt79asfbycnq9pwii0.png"></a> <br><br>  Misalnya, kami memiliki aplikasi asli yang perlu menyimpan data.  Kami membuat antarmuka persistensi dengan metode <i>menyimpan</i> array data dan metode <i>menghapus</i> baris dalam tabel dengan ID-nya.  Mulai sekarang, di mana pun aplikasi perlu menyimpan atau menghapus data, kami akan meminta dalam konstruktor sebuah objek yang mengimplementasikan antarmuka kegigihan yang kami tetapkan. <br><br>  Sekarang buat adaptor khusus MySQL yang akan mengimplementasikan antarmuka ini.  Ini akan memiliki metode untuk menyimpan array dan menghapus baris dalam tabel, dan kami akan memperkenalkannya di mana pun antarmuka persisten diperlukan. <br><br>  Jika pada suatu saat kami memutuskan untuk mengubah penyedia basis data, misalnya, ke PostgreSQL atau MongoDB, kami hanya perlu membuat adaptor baru yang mengimplementasikan antarmuka persistensi khusus untuk PostgreSQL dan memperkenalkan adaptor baru alih-alih yang lama. <br><br><a name="7"></a><h2>  Kontrol inversi </h2><br>  Fitur karakteristik templat ini adalah bahwa adaptor bergantung pada alat tertentu dan port tertentu (dengan mengimplementasikan antarmuka).  Tetapi logika bisnis kami hanya bergantung pada port (antarmuka), yang dirancang untuk memenuhi kebutuhan logika bisnis dan tidak bergantung pada adaptor atau alat tertentu. <br><br> <a href=""><img src="https://habrastorage.org/webt/lz/8c/8m/lz8c8mla7fg4vuq9piocz1rb4ko.png"></a> <br><br>  Ini berarti bahwa ketergantungan diarahkan ke pusat, yaitu, ada <b>inversi dari prinsip kontrol di tingkat arsitektur</b> . <br><br>  Meskipun, sekali lagi, <b>sangat penting bahwa port dibuat sesuai dengan kebutuhan inti aplikasi, dan tidak hanya meniru API alat</b> . <br><br><a name="8"></a><h1>  Organisasi inti aplikasi </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur Onion</a> mengambil lapisan DDD dan menggabungkannya ke dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur port dan adaptor</a> .  Level-level ini dirancang untuk menghadirkan logika bisnis, bagian dalam "segi enam" port dan adaptor.  Seperti sebelumnya, arah ketergantungan menuju pusat. <br><br><a name="9"></a><h2>  Lapisan Aplikasi (Lapisan Aplikasi) </h2><br>  Use cases adalah proses yang dapat diluncurkan dalam kernel dengan satu atau lebih antarmuka pengguna.  Misalnya, CMS mungkin memiliki satu UI untuk pengguna biasa, UI independen lainnya untuk administrator CMS, CLI lain, dan API web.  UI (aplikasi) ini dapat memicu kasus penggunaan yang unik atau umum. <br><br>  Use case didefinisikan pada level aplikasi - level pertama DDD dan arsitektur Onion. <br><br> <a href=""><img src="https://habrastorage.org/webt/en/x2/97/enx297n0fviyyevojd6u3y_mx3q.png"></a> <br><br>  Lapisan ini berisi layanan aplikasi (dan antarmuka mereka) sebagai objek kelas satu, dan juga berisi antarmuka port dan adaptor (port), yang mencakup antarmuka ORM, antarmuka mesin pencari, antarmuka pengiriman pesan, dll. Dalam kasus di mana kami menggunakan bus perintah dan / atau bus permintaan, pada level ini adalah perintah dan penangan permintaan yang sesuai. <br><br>  Layanan aplikasi dan / atau penangan perintah berisi logika penggunaan kasus penggunaan, proses bisnis.  Sebagai aturan, peran mereka adalah sebagai berikut: <br><br><ol><li>  gunakan repositori untuk mencari satu atau lebih entitas; </li><li>  minta entitas ini untuk menjalankan beberapa logika domain; </li><li>  dan menggunakan penyimpanan untuk menyimpan kembali entitas, secara efektif menyimpan perubahan data. </li></ol><br>  Penangan perintah dapat digunakan dalam dua cara: <br><br><ol><li>  Mereka mungkin berisi logika untuk mengeksekusi use case; </li><li>  Mereka dapat digunakan sebagai bagian sederhana dari koneksi dalam arsitektur kita yang menerima perintah dan hanya memanggil logika yang ada di layanan aplikasi. </li></ol><br>  Pendekatan mana yang digunakan tergantung pada konteksnya, misalnya: <br><br><ul><li>  Kami sudah memiliki layanan aplikasi dan sekarang bus perintah sedang ditambahkan? </li><li>  Apakah bus perintah memungkinkan Anda untuk menentukan kelas / metode sebagai penangan, atau apakah Anda perlu memperluas atau mengimplementasikan kelas atau antarmuka yang ada? </li></ul><br>  Lapisan ini juga mengandung <b>peristiwa aplikasi</b> pemicu yang mewakili beberapa hasil dari use case.  Peristiwa ini memicu logika yang merupakan efek samping dari use case, seperti mengirim email, memberi tahu API pihak ketiga, mengirim pemberitahuan push, atau bahkan meluncurkan use case lain yang merupakan komponen aplikasi lainnya. <br><br><a name="10"></a><h2>  Tingkat domain </h2><br>  Lebih jauh di dalam ada tingkat domain.  Objek pada level ini berisi data dan logika untuk mengelola data ini, yang khusus untuk domain itu sendiri dan tidak tergantung pada proses bisnis yang memicu logika ini.  Mereka independen dan sama sekali tidak mengetahui tingkat aplikasi. <br><br> <a href=""><img src="https://habrastorage.org/webt/sm/tl/z2/smtlz2wmhuiysntbvasfqotc7zs.png"></a> <br><br><a name="11"></a><h3>  Layanan Domain </h3><br>  Seperti yang saya sebutkan di atas, peran layanan aplikasi: <br><br><ol><li>  gunakan repositori untuk mencari satu atau lebih entitas; </li><li>  minta entitas ini untuk menjalankan beberapa logika domain; </li><li>  dan menggunakan penyimpanan untuk menyimpan kembali entitas, secara efektif menyimpan perubahan data. </li></ol><br>  Tetapi kadang-kadang kita menemukan beberapa logika domain, yang mencakup berbagai entitas dari jenis yang sama atau berbeda, dan logika domain ini bukan milik entitas itu sendiri, yaitu, logika bukan tanggung jawab langsung mereka. <br><br>  Oleh karena itu, reaksi pertama kami mungkin menempatkan logika ini di luar entitas dalam layanan aplikasi.  Namun, ini berarti bahwa dalam kasus lain, logika domain tidak akan digunakan kembali: logika domain harus tetap berada di luar level aplikasi! <br><br>  Solusinya adalah membuat layanan domain, yang perannya adalah untuk memperoleh seperangkat entitas dan menjalankan beberapa logika bisnis pada mereka.  Layanan domain milik tingkat domain dan karenanya tidak tahu apa-apa tentang kelas di tingkat aplikasi, seperti layanan aplikasi atau repositori.  Di sisi lain, ia dapat menggunakan layanan domain lain dan, tentu saja, objek model domain. <br><br><a name="12"></a><h3>  Model domain </h3><br>  Di pusat adalah model domain.  Itu tidak bergantung pada apa pun di luar lingkaran ini dan berisi objek bisnis yang mewakili sesuatu dalam domain.  Contoh objek tersebut adalah, pertama-tama, entitas, serta nilai objek, enum, dan objek apa pun yang digunakan dalam model domain. <br><br>  Peristiwa domain juga hidup dalam model domain.  Ketika kumpulan data tertentu berubah, peristiwa ini dipicu, yang berisi nilai baru dari properti yang diubah.  Acara-acara ini ideal, misalnya, untuk digunakan dalam modul sumber acara. <br><br><a name="13"></a><h1>  Komponen </h1><br>  Sejauh ini, kami telah mengisolasi kode dalam lapisan, tetapi ini adalah isolasi kode yang terlalu terperinci.  Sama pentingnya untuk melihat gambar dengan tampilan yang lebih umum.  Kita berbicara tentang membagi kode menjadi subdomain dan <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konteks terkait</a></b></i> sesuai dengan ide-ide Robert Martin yang diungkapkan dalam <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur berteriak</a></b></i> [yaitu, arsitektur harus "berteriak" tentang aplikasi itu sendiri, dan bukan tentang kerangka mana yang digunakannya - kira-kira.  trans.].  Mereka berbicara tentang mengatur paket berdasarkan fungsi atau komponen, bukan demi lapisan, dan Simon Brown menjelaskannya dengan sangat baik dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Paket komponen dan pengujian arsitektur"</a> di blognya: <br><br> <a href=""><img src="https://habrastorage.org/webt/mf/n5/un/mfn5unjrsm8lmkufaoj55mfyqk0.png"></a> <br><br>  Saya seorang pendukung pengorganisasian paket komponen dan ingin mengubah diagram Simon Brown tanpa malu-malu sebagai berikut: <br><br> <a href=""><img src="https://habrastorage.org/webt/xn/ng/nd/xnngndzw3fq5rcvzvitudp-kpns.png"></a> <br><br>  Bagian-bagian kode ini saling memotong untuk semua lapisan yang dijelaskan sebelumnya, dan ini adalah <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen dari</a></b></i> aplikasi kita.  Contoh komponen adalah penagihan, pengguna, verifikasi, atau akun, tetapi mereka selalu dikaitkan dengan domain.  Konteks terbatas, seperti otorisasi dan / atau otentikasi, harus dianggap sebagai alat eksternal yang kami buat adaptor dan bersembunyi di balik port. <br><br> <a href=""><img src="https://habrastorage.org/webt/9v/kd/ou/9vkdouyaegscibkngn0ui0ltbko.png"></a> <br><br><a name="14"></a><h2>  Putuskan Komponen </h2><br>  Seperti halnya dalam unit kode yang halus (kelas, antarmuka, sifat, mixin, dll.), Unit besar (komponen) mendapat manfaat dari kopling yang lemah dan konektivitas yang ketat. <br><br>  Untuk memisahkan kelas, kami menggunakan injeksi dependensi, memperkenalkan dependensi ke dalam kelas, daripada membuatnya di dalam kelas, dan juga membalik dependensi, membuat kelas bergantung pada abstraksi (antarmuka dan / atau kelas abstrak) alih-alih kelas tertentu.  Ini berarti bahwa kelas dependen tidak tahu apa-apa tentang kelas spesifik yang akan digunakan, itu tidak memiliki referensi ke nama lengkap dari kelas-kelas di mana ia bergantung. <br><br>  Demikian pula, dalam komponen yang benar-benar terputus, setiap komponen tidak tahu apa-apa tentang komponen lainnya.  Dengan kata lain, ia tidak memiliki tautan ke blok kode berbutir halus dari komponen lain, bahkan ke antarmuka!  Ini berarti injeksi ketergantungan dan inversi ketergantungan tidak cukup untuk memisahkan komponen, kita akan memerlukan semacam konstruksi arsitektur.  Peristiwa, inti umum, konsistensi akhirnya, dan bahkan layanan pencarian mungkin diperlukan! <br><br> <a href=""><img src="https://habrastorage.org/webt/wp/gk/2w/wpgk2wxy5fgyjtrwuzctapvv19y.png"></a> <br><br><a name="15"></a><h3>  Memicu logika pada komponen lain </h3><br>  Ketika salah satu komponen kami (komponen B) perlu melakukan sesuatu setiap kali sesuatu yang lain terjadi di komponen lain (komponen A), kami tidak bisa langsung melakukan panggilan langsung dari komponen A ke kelas / metode komponen B, karena maka A akan terhubung ke B. <br><br>  Namun, kita dapat menggunakan event manager untuk mengirimkan acara aplikasi, yang akan dikirim ke komponen yang mendengarkannya, termasuk B, dan pendengar acara di B akan memicu tindakan yang diinginkan.  Ini berarti bahwa komponen A akan tergantung pada manajer acara, tetapi akan terpisah dari komponen B. <br><br>  Namun, jika peristiwa itu sendiri "hidup" di A, ini berarti bahwa B tahu tentang keberadaan A dan terkait dengannya.  Untuk menghapus ketergantungan ini, kita dapat membuat perpustakaan dengan serangkaian fungsionalitas inti aplikasi yang akan dibagikan oleh semua komponen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inti bersama</a> .  Ini berarti bahwa kedua komponen akan tergantung pada inti bersama, tetapi akan dipisahkan satu sama lain.  Inti umum berisi fungsionalitas seperti peristiwa aplikasi dan domain, tetapi juga dapat berisi objek spesifikasi dan apa pun yang masuk akal untuk dibagikan.  Pada saat yang sama, itu harus berukuran minimum, karena setiap perubahan dalam kernel yang sama akan mempengaruhi semua komponen aplikasi.  Selain itu, jika kita memiliki sistem polyglot, katakanlah, ekosistem layanan microser dalam berbagai bahasa, maka inti bersama tidak boleh bergantung pada bahasa sehingga semua komponen memahaminya.  Sebagai contoh, alih-alih kernel umum dengan kelas peristiwa, itu akan berisi deskripsi peristiwa (yaitu, nama, properti, bahkan metode, meskipun mereka akan lebih berguna dalam objek spesifikasi) dalam bahasa universal seperti JSON sehingga semua komponen / layanan mikro dapat menafsirkannya dan bahkan mungkin secara otomatis menghasilkan implementasi spesifik mereka sendiri. <br><br>  Pendekatan ini bekerja baik dalam aplikasi monolitik maupun terdistribusi, seperti ekosistem layanan mikro.  Tetapi jika peristiwa dapat disampaikan hanya secara tidak sinkron, maka pendekatan ini tidak cukup untuk konteks di mana logika pemicu dalam komponen lain harus segera bekerja!  Di sini, komponen A perlu membuat panggilan HTTP langsung ke komponen B. Dalam hal ini, untuk memutuskan komponen, kita memerlukan layanan pencarian.  Komponen A akan menanyakan ke mana dia mengirim permintaan untuk memulai tindakan yang diinginkan.  Atau, buat permintaan ke layanan penemuan, yang akan meneruskannya ke layanan yang sesuai dan pada akhirnya mengembalikan respons kepada pemohon.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pendekatan ini mengaitkan komponen dengan layanan penemuan, tetapi tidak menghubungkannya satu sama lain. </font></font><br><br><a name="16"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengambil data dari komponen lain </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti yang saya lihat, komponen tidak diperbolehkan untuk mengubah data yang tidak "dimiliki", tetapi dapat meminta dan menggunakan data apa pun. </font></font><br><br><a name="17"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penyimpanan data bersama untuk komponen </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika komponen harus menggunakan data milik komponen lain (misalnya, komponen penagihan harus menggunakan nama klien yang termasuk dalam komponen akun), maka komponen tersebut berisi objek permintaan ke penyimpanan data. </font><font style="vertical-align: inherit;">Artinya, komponen penagihan dapat mengetahui tentang kumpulan data apa pun, tetapi harus menggunakan data hanya baca dari negara lain.</font></font><br><br><a name="18"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pisahkan penyimpanan data untuk komponen </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, templat yang sama diterapkan, tetapi tingkat penyimpanan data menjadi lebih rumit. </font><font style="vertical-align: inherit;">Kehadiran komponen dengan gudang data mereka sendiri berarti bahwa setiap gudang data berisi:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperangkat data yang dimiliki dan dapat diubah oleh suatu komponen, menjadikannya satu-satunya sumber kebenaran; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dataset yang merupakan salinan data komponen lain yang tidak dapat diubah dengan sendirinya, tetapi diperlukan untuk fungsionalitas komponen. </font><font style="vertical-align: inherit;">Data ini harus diperbarui setiap kali ada perubahan dalam komponen pemilik.</font></font></li></ul><br>           ,     .     ,   ,      ,   . ,    ,            . <br><br><a name="19"></a><h1>   </h1><br>     ,        ,   ,      —    .      ?    ?    ? <br><br>        «»  (Clean Architecture),       UMLish… <br><br><h2>   / </h2><br>      ,       ,    Query. <br><br> <sup>[ 18.11.2017]    DTO,       ,    .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MorphineAdministered</a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  .</sup> <br> <a href=""><img src="https://habrastorage.org/webt/hg/ak/_p/hgak_pjjk5jb-5klihtccnlb7dy.png"></a> <br>          ,   ,       ,         .      ,      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek kueri berisi kueri yang dioptimalkan yang hanya mengembalikan beberapa data mentah yang akan ditampilkan kepada pengguna. Data ini dikembalikan ke DTO, yang tertanam dalam ViewModel. ViewModel ini mungkin memiliki semacam logika tampilan dan akan digunakan untuk mengisi tampilan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sisi lain, layanan aplikasi berisi logika use-case yang menyala ketika kita ingin melakukan sesuatu pada sistem, dan tidak hanya melihat beberapa data. Layanan aplikasi tergantung pada repositori yang mengembalikan entitas yang berisi logika yang perlu dimulai. Mungkin juga tergantung pada layanan domain untuk mengoordinasikan proses domain di beberapa entitas, tetapi ini adalah kasus yang jarang terjadi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menguraikan kasus penggunaan, layanan aplikasi dapat memberi tahu seluruh sistem bahwa kasus penggunaan telah terjadi, maka itu akan tergantung pada pengirim acara untuk memicu acara tersebut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sangat menarik untuk dicatat bahwa kami memiliki antarmuka pada mesin persistensi dan repositori. </font><font style="vertical-align: inherit;">Ini mungkin tampak berlebihan, tetapi mereka melayani tujuan yang berbeda:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Antarmuka Persistence adalah lapisan abstraksi di atas ORM, sehingga kita dapat menukar ORM tanpa mengubah inti aplikasi. </font></font></li><li>       persistence-. ,     MySQL  MongoDB.    persistence-    ,         ORM,       .   ,    ,      ,        ,       ,   ,    MongoDB  SQL. </li></ul><br><h2> C  / </h2><br>  ,      /,     ,   ,      ,      .         ,         . <br><br>         .     ,           .           ,          . <br><br> <sup>[ 18.11.2017]    DTO,       ,    .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MorphineAdministered</a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  .</sup> <br> <a href=""><img src="https://habrastorage.org/webt/dh/vh/c1/dhvhc1qxek9af6wc2ztmfqq4m4u.png"></a> <br>   ,      , ,   .  ,       ,    .               . <br><br>      — ,      —  .   ,     Ports &amp; Adapters,  Onion    Clean. <br><br> <a href=""><img src="https://habrastorage.org/webt/la/3y/qs/la3yqsseqajawy91dvvrzcgzuku.png"></a> <br><br><h1>  Kesimpulan </h1><br>  ,    ,        ,    ,      . <br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rencana tidak berguna, tetapi perencanaan adalah segalanya. </font><font style="vertical-align: inherit;">- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eisenhower</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infografis ini adalah peta konsep. </font><font style="vertical-align: inherit;">Mengetahui dan memahami semua konsep ini membantu Anda merencanakan arsitektur yang sehat dan aplikasi yang bisa diterapkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta bukan wilayah. </font><font style="vertical-align: inherit;">- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alfred Korzybsky</font></font></i> </blockquote><br>  , <b>   !  —  , ,   ,     ,    ,     !</b> <br><br> <b>     ,       ,     ,         .</b>      ,     ,    ,   ,      . <br><br>        . <br><br>        : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«,    »</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427739/">https://habr.com/ru/post/id427739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427729/index.html">Bagaimana cara mengkonfigurasi Firewall di server dengan Zimbra?</a></li>
<li><a href="../id427731/index.html">Linus Torvalds kembali beroperasi setelah rilis versi kernel 4,19</a></li>
<li><a href="../id427733/index.html">Cyberpunk 2000: Deus Ex Creation Tools</a></li>
<li><a href="../id427735/index.html">Analisis game dari Classmates di Joker 2018</a></li>
<li><a href="../id427737/index.html">Perjalanan ke Negeri Raksasa: Ulasan ONYX BOOX Gulliver</a></li>
<li><a href="../id427741/index.html">Pembuat kode untuk Laravel - untuk input OAS, untuk output JSON-API</a></li>
<li><a href="../id427743/index.html">Lucu dan aneh: kami telah mengumpulkan permintaan pencarian yang kami sukai</a></li>
<li><a href="../id427745/index.html">Kiat & trik Kubernetes: akses ke situs dev</a></li>
<li><a href="../id427747/index.html">Siapa yang menabrak mobil tak berawak: Hasil percobaan Mesin Moral</a></li>
<li><a href="../id427749/index.html">Apple dan Samsung untuk pertama kalinya didenda karena memperlambat ponsel lama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>