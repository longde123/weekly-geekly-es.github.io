<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ö üë©üèº‚Äçüé§ üé° Creamos un juego de plataforma port√°til en el microcontrolador Cortex M0 + üòë üéôÔ∏è üèòÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 (Los enlaces al c√≥digo fuente y al proyecto KiCAD se proporcionan al final del art√≠culo). 

 Aunque nacimos en la era de los 8 bits, nu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creamos un juego de plataforma port√°til en el microcontrolador Cortex M0 +</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466323/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mg/8v/j_/mg8vj_mlkkh99th0jwxuun5mudk.png"></div><br><h2>  Introduccion </h2><br>  <em>(Los enlaces al c√≥digo fuente y al proyecto KiCAD se proporcionan al final del art√≠culo).</em> <br><br>  Aunque nacimos en la era de los 8 bits, nuestra primera computadora fue la Amiga 500. Esta es una gran m√°quina de 16 bits con gr√°ficos y sonido incre√≠bles, lo que la hace ideal para jugar.  Las plataformas se han convertido en un g√©nero de juego muy popular en esta computadora.  Muchos de ellos eran muy coloridos y ten√≠an un desplazamiento de paralaje muy suave.  Esto fue posible gracias a programadores talentosos que utilizaron ingeniosamente los coprocesadores Amiga para aumentar la cantidad de colores de pantalla.  ¬°Eche un vistazo a LionHeart por ejemplo! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/0f4/c54/5670f4c541f76158b62e57d951a0f83f.png"></div><br>  <i>Lionheart en Amiga.</i>  <i>Esta imagen est√°tica no transmite la belleza de los gr√°ficos.</i> <br><br>  Desde los a√±os 90, la electr√≥nica ha cambiado mucho, y ahora hay muchos microcontroladores peque√±os que le permiten crear cosas incre√≠bles. <br><br>  Siempre nos han encantado los juegos de plataformas, y hoy, por unos pocos d√≥lares, puedes comprar Raspberry Zero, instalar Linux y escribir un juego de plataformas "bastante f√°cil". <br><br>  Pero esta tarea no es para nosotros, ¬°no queremos disparar gorriones desde un ca√±√≥n! <br><br>  ¬°Queremos usar microcontroladores con memoria limitada y no un sistema potente en un chip con una GPU integrada!  En otras palabras, ¬°queremos dificultades! <br><a name="habracut"></a><br>  Por cierto, sobre las posibilidades del video: algunas personas logran exprimir todos los jugos del microcontrolador AVR en sus proyectos (por ejemplo, en el proyecto Uzebox o Craft del desarrollador lft).  Sin embargo, para lograr esto, los microcontroladores AVR nos obligan a escribir en ensamblador, y aunque algunos juegos son muy buenos, encontrar√° serias limitaciones que no le permiten crear un juego en un estilo de 16 bits. <br><br>  Por lo tanto, decidimos usar un microcontrolador / placa m√°s equilibrado, lo que nos permite escribir c√≥digo completamente en C. <br><br>  No es tan poderoso como Arduino Due, pero no tan d√©bil como Arduino Uno.  Curiosamente, "Debido" significa "dos" y "Uno" significa "uno".  Microsoft nos ense√±√≥ a contar correctamente (1, 2, 3, 95, 98, ME, 2000, XP, Vista, 7, 8, 10), ¬°y Arduino tambi√©n fue de esta manera!  Utilizaremos el Arduino Zero, que est√° en el medio entre 1 y 2. <br><br>  S√≠, seg√∫n Arduino, 1 &lt;0 &lt;2. <br><br>  En particular, no estamos interesados ‚Äã‚Äãen la placa en s√≠, sino en su serie de procesadores.  El Arduino Zero tiene un microcontrolador de la serie ATSAMD21 con Cortex M0 + (48 MHz), memoria flash de 256 KB y 32 KB de RAM. <br><br>  Aunque el Cortex M0 + de 48 MHz supera significativamente el rendimiento del antiguo MC68000 de 7 MHz, el Amiga 500 ten√≠a 512 KB de RAM, sprites de hardware, un tablero de juego dual integrado, Blitter (un motor de transferencia de bloques de imagen basado en DMA con un sistema de reconocimiento de colisi√≥n con precisi√≥n de p√≠xel incorporado) y transparencia) y Cobre (un coprocesador r√°ster que le permite realizar operaciones con registros basados ‚Äã‚Äãen la posici√≥n de barrido para crear muchos efectos muy bonitos).  SAMD21 no tiene todo este hardware (con la excepci√≥n de uno bastante simple en comparaci√≥n con Blitter DMA), por lo que mucho se representar√° mediante programaci√≥n. <br><br>  Queremos lograr los siguientes par√°metros: <br><br><ul><li>  Resoluci√≥n 160 x 128 p√≠xeles en una pantalla SPI de 1.8 pulgadas. </li><li>  Gr√°ficos con 16 bits por p√≠xel; </li><li>  La velocidad de fotogramas m√°s alta.  Al menos 25 fps a 12 MHz SPI, o 40 fps a 24 MHz; </li><li>  doble campo de juego con desplazamiento de paralaje; </li><li>  todo est√° escrito en C. Sin c√≥digo de ensamblador; </li><li>  Reconocimiento de colisiones con precisi√≥n de p√≠xeles; </li><li>  superposici√≥n de pantalla. </li></ul><br>  Parece que lograr estos objetivos es bastante dif√≠cil.  ¬°Lo es, especialmente si rechazamos el c√≥digo en asm! <br><br>  Por ejemplo, con color de 16 bits, un tama√±o de pantalla de 160 √ó 128 p√≠xeles requerir√° 40 KB para el b√∫fer de pantalla, ¬°pero solo tenemos 32 KB de RAM!  ¬°Y todav√≠a necesitamos desplazamiento de paralaje en un campo de juego doble y mucho m√°s, con una frecuencia de al menos 25/40 fps! <br><br>  Pero nada es imposible para nosotros, ¬øverdad? <br><br>  ¬°Usamos trucos y funciones integradas de ATSAMD21!  Como "hardware" tomamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uChip</a> , que se puede comprar en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tienda Itaca</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/e77/4aa/9ffe774aac84e2df3534d9ac2f16724b.jpg"></div><br>  <i>uChip: el coraz√≥n de nuestro proyecto!</i> <br><br>  Tiene las mismas caracter√≠sticas que el Arduino Zero, pero es mucho m√°s peque√±o y tambi√©n m√°s barato que el Arduino Zero original (s√≠, puedes comprar un Arduino Zero falso por $ 10 en AliExpress ... pero queremos construir sobre el original).  Esto nos permitir√° crear una peque√±a consola port√°til.  Puede adaptar este proyecto para Arduino Zero casi sin esfuerzo, solo el resultado ser√° bastante engorroso. <br><br>  Tambi√©n creamos un peque√±o tablero de prueba que implementa una consola port√°til para los pobres.  Detalles a continuaci√≥n! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8a/c34/04e/a8ac3404e35351c6e02368763ef985a5.jpg"></div><br>  No usaremos el marco Arduino.  No es adecuado para optimizar y gestionar equipos.  (¬°Y no hablemos del IDE!) <br><br>  En este art√≠culo, describiremos c√≥mo llegamos a la versi√≥n final del juego, describiremos todas las optimizaciones y criterios utilizados.  El juego en s√≠ a√∫n no est√° completo, carece de sonido, niveles, etc.  ¬°Sin embargo, se puede usar como punto de partida para muchos tipos diferentes de juegos! <br><br>  Adem√°s, hay muchas m√°s opciones de optimizaci√≥n, ¬°incluso sin ensamblador! <br><br>  Entonces, ¬°comencemos nuestro viaje! <br><br><h2>  Dificultades </h2><br>  De hecho, el proyecto tiene dos aspectos complejos: tiempos y memoria (RAM y almacenamiento). <br><br><h3>  El recuerdo </h3><br>  Comencemos con la memoria.  Primero, en lugar de almacenar una imagen de gran nivel, usamos mosaicos.  De hecho, si analiza cuidadosamente la mayor√≠a de los juegos de plataformas, notar√° que se crean a partir de una peque√±a cantidad de elementos gr√°ficos (mosaicos) que se repiten muchas veces. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f36/950/80a/f3695080a0bfe4d7f1ce6809c8efe275.png"></div><br>  <i>Turrican 2 en Amiga.</i>  <i>Uno de los mejores juegos de plataformas de todos los tiempos.</i>  <i>¬°Puedes ver f√°cilmente las fichas en √©l!</i> <br><br>  El mundo / nivel parece diverso gracias a varias combinaciones de fichas.  Esto ahorra mucha memoria en el disco, pero no resuelve el problema de un enorme buffer de cuadros. <br><br>  ¬°El segundo truco que utilizamos es posible debido al gran poder computacional de uC y la presencia de DMA!  En lugar de almacenar todos los datos del cuadro en la RAM (¬øy por qu√© es necesario?) Crearemos una escena en cada cuadro desde cero.  En particular, continuaremos usando buffers, pero de manera que quepan en un bloque horizontal de gr√°ficos de datos con una altura de 16 p√≠xeles. <br><br><h3>  Tiempos - CPU </h3><br>  Cuando un ingeniero necesita crear algo, primero verifica si esto es posible.  ¬°Por supuesto, al principio realizamos esta prueba! <br><br>  Por lo tanto, necesitamos al menos 25 fps en una pantalla de 160 √ó 128 p√≠xeles.  Eso es 512,000 p√≠xeles / s.  Como el microcontrolador funciona a una frecuencia de 48 MHz, tenemos al menos 93 ciclos de reloj por p√≠xel.  Este valor cae a 58 ciclos si apuntamos a 40 fps. <br><br>  De hecho, nuestro microcontrolador es capaz de procesar hasta 2 p√≠xeles a la vez, porque cada p√≠xel ocupa 16 bits, y el ATSAMD21 tiene un bus interno de 32 bits, es decir, ¬°el rendimiento ser√° a√∫n mejor! <br><br>  ¬°Un valor de 93 ciclos de reloj nos dice que la tarea es completamente factible!  De hecho, podemos concluir que la CPU sola puede manejar todas las tareas de representaci√≥n sin DMA.  Lo m√°s probable es que esto sea cierto, especialmente cuando se trabaja con ensamblador.  Sin embargo, el c√≥digo ser√° muy dif√≠cil de manejar.  ¬°Y en C tiene que estar muy optimizado!  De hecho, Cortex M0 + no es tan amigable con C como Cortex M3, y carece de muchas instrucciones (¬°ni siquiera carga / guarda con un incremento / decremento posterior / preliminar!), Que debe implementarse con dos o m√°s instrucciones simples. <br><br>  Veamos qu√© debemos hacer para dibujar dos campos de juego (suponiendo que ya conozcamos las coordenadas x e y, etc.). <br><br><ul><li>  Calcule la ubicaci√≥n del p√≠xel de primer plano en la memoria flash. </li><li>  Obtenga el valor de p√≠xel. </li><li>  Si es transparente, calcule la posici√≥n del p√≠xel de fondo en el flash. </li><li>  Obtenga el valor de p√≠xel. </li><li>  Calcule la ubicaci√≥n del objetivo. </li><li>  Guardar p√≠xeles en el b√∫fer. </li></ul><br>  Adem√°s, para cada sprite que puede ingresar al b√∫fer, se deben realizar las siguientes operaciones: <br><br><ul><li>  Calcule la posici√≥n de un p√≠xel de sprite en la memoria flash. </li><li>  Obteniendo el valor del p√≠xel. </li><li>  Si no es transparente, calcule la ubicaci√≥n del b√∫fer de destino. </li><li>  Guardar un p√≠xel en el b√∫fer. </li></ul><br>  Todas estas operaciones no solo no se implementan como una sola instrucci√≥n ASM, sino que cada instrucci√≥n ASM requiere dos ciclos al acceder a la memoria RAM / flash. <br><br>  Adem√°s, todav√≠a no tenemos l√≥gica de juego (que, afortunadamente, lleva una peque√±a cantidad de tiempo, ya que se calcula una vez por fotograma), reconocimiento de colisi√≥n, procesamiento de b√∫fer e instrucciones necesarias para enviar datos a trav√©s de SPI. <br><br>  Por ejemplo, aqu√≠ est√° el pseudoc√≥digo de lo que tenemos que hacer (por ahora, suponemos que el juego no tiene desplazamiento, ¬°y el campo de juego tiene un fondo de color constante!) Solo para el primer plano. <br><br>  Deje que cameraY y cameraX sean las coordenadas de la esquina superior izquierda de la pantalla en el mundo del juego. <br><br>  Deje que xTilepos e yTilepos sean la posici√≥n del mosaico actual en el mapa. <br><br><pre><code class="cpp hljs">xTilepos = cameraX / <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is a rightward shift of 4 bits. yTilepos = cameraY / 16; destBufferAddress = &amp;buffer[0][0]; for tile = 0...9 nTile = gameMap[yTilepos][xTilepos]; tileDataAddress = &amp;tileData[nTile]; xTilepos = xTilepos + 1; for y = 0‚Ä¶15 for x = 0‚Ä¶15 pixel = *tileDataAddress; tileDataAddress = tileDataAddress + 1; *destBufferAddress = pixel; destBufferAddress = destBufferAddress + 1; next destBufferAddress = destBufferAddress + 144; // point to next row next destBufferAddress = destBufferAddress ‚Äì ( 160 * 16 - 16); // now point to the position where the next tile will be saved. next</span></span></code> </pre> <br>  El n√∫mero de instrucciones para 2560 p√≠xeles (160 x 16) es de aproximadamente 16k, es decir.  6 por p√≠xel.  De hecho, puede dibujar dos p√≠xeles a la vez.  Esto reduce a la mitad el n√∫mero real de instrucciones por p√≠xel, es decir, el n√∫mero de instrucciones de alto nivel por p√≠xel es aproximadamente 3. Sin embargo, algunas de estas instrucciones de alto nivel se dividir√°n en dos o m√°s instrucciones de ensamblador, o requerir√°n al menos dos ciclos para completar porque acceden a la memoria  Adem√°s, no consideramos restablecer la canalizaci√≥n de la CPU debido a saltos y estados de espera para la memoria flash.  S√≠, todav√≠a estamos lejos de los 58-93 ciclos a nuestra disposici√≥n, pero a√∫n debemos tener en cuenta los antecedentes del campo de juego y los sprites. <br><br>  Aunque vemos que el problema se puede resolver en una CPU, DMA ser√° mucho m√°s r√°pido.  El acceso directo a la memoria deja a√∫n m√°s espacio para los sprites de pantalla o mejores efectos gr√°ficos (por ejemplo, podemos implementar la mezcla alfa). <br><br>  ¬°Veremos que para configurar el DMA para cada mosaico, necesitamos menos de 100 instrucciones C, es decir, menos de 0.5 por p√≠xel!  Por supuesto, DMA todav√≠a tendr√° que realizar la misma cantidad de transferencias en la memoria, pero el incremento de direcci√≥n y la transmisi√≥n se realizan sin la intervenci√≥n de la CPU, que puede hacer algo m√°s (por ejemplo, calcular y generar sprites). <br><br>  Usando el temporizador SysTick, descubrimos que el tiempo requerido para preparar el DMA para todo el bloque, y luego para completar el DMA, es de aproximadamente 12k ciclos de reloj.  Nota: ciclos de reloj!  ¬°No son instrucciones de alto nivel!  El n√∫mero de ciclos es bastante alto para solo 2560 p√≠xeles, es decir  1.280 palabras de 32 bits.  De hecho, obtenemos unos 10 ciclos por palabra de 32 bits.  Sin embargo, debe considerar el tiempo requerido para preparar el DMA, as√≠ como el tiempo que le toma al DMA cargar los descriptores de transferencia desde la RAM (que esencialmente contienen punteros y la cantidad de bytes transferidos).  Adem√°s, siempre hay alg√∫n tipo de cambio en el bus de memoria (para que la CPU no permanezca inactiva sin datos), y la memoria flash requiere al menos un estado de espera. <br><br><h3>  Tiempos - SPI </h3><br>  Otro cuello de botella es el SPI.  ¬øSon suficientes 12 MHz para 25 fps?  La respuesta es s√≠: 12 MHz corresponde a aproximadamente 36 cuadros por segundo.  Si usamos 24 MHz, ¬°entonces el l√≠mite se duplicar√°! <br><br>  Por cierto, las especificaciones de la pantalla y el microcontrolador dicen que la velocidad m√°xima de SPI es, respectivamente, de 15 y 12 MHz.  Probamos y nos aseguramos de que se puede aumentar a 24 MHz sin problemas, al menos en la "direcci√≥n" que necesitamos (el microcontrolador escribe en la pantalla). <br><br>  Utilizaremos la popular pantalla SPI de 1.8 pulgadas.  Nos aseguramos de que tanto ILI9163 como ST7735 funcionen normalmente con una frecuencia de 12 MHz (al menos con 12 MHz. Se verifica que el ST7735 funciona con una frecuencia de hasta 24 MHz).  Si desea utilizar la misma pantalla que en el tutorial "C√≥mo reproducir videos en Arduino Uno", le recomendamos modificarlo en caso de que desee agregar soporte SD en el futuro.  Estamos utilizando la versi√≥n de la tarjeta SD para tener mucho espacio para otros elementos, como el sonido o niveles adicionales. <br><br><h2>  Gr√°ficos </h2><br>  Como ya se mencion√≥, el juego usa fichas.  Cada nivel consistir√° en fichas que se repiten de acuerdo con la tabla, que llamamos "gameMap".  ¬øQu√© tan grande ser√° cada azulejo?  El tama√±o de cada mosaico afecta en gran medida el consumo de memoria, los detalles y la flexibilidad (y, como veremos m√°s adelante, la velocidad tambi√©n).  Los mosaicos demasiado grandes requerir√°n la creaci√≥n de un mosaico nuevo para cada peque√±a variaci√≥n que necesitemos.  Esto ocupar√° mucho espacio en el disco. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/a66/32a/a96a6632abfec9bef7341e42bed6cf45.png" width="580" height="165"></div><br>  <i>Dos mosaicos de 32 √ó 32 p√≠xeles de tama√±o (izquierdo y central), que difieren en una peque√±a parte (la parte superior derecha del p√≠xel es 16 √ó 16).</i>  <i>Por lo tanto, necesitamos almacenar dos mosaicos diferentes con un tama√±o de 32 √ó 32 p√≠xeles.</i>  <i>Si usamos un mosaico de 16 √ó 16 p√≠xeles (a la derecha), entonces necesitamos almacenar solo dos mosaicos de 16 √ó 16 (un mosaico completamente blanco y un mosaico a la derecha).</i>  <i>Sin embargo, cuando usamos mosaicos de 16 √ó 16, obtenemos 4 elementos de mapa.</i> <br><br>  Sin embargo, se requieren menos fichas por pantalla, lo que aumenta la velocidad (ver m√°s abajo) y reduce el tama√±o del mapa (es decir, el n√∫mero de filas y columnas en la tabla) de cada nivel.  Las fichas demasiado peque√±as crean el problema opuesto.  Las tablas de mapas son cada vez m√°s grandes y la velocidad es m√°s lenta.  Por supuesto, no tomaremos decisiones est√∫pidas.  por ejemplo, seleccione mosaicos con un tama√±o de 17 √ó 31 p√≠xeles.  Nuestro fiel amigo - grados dos!  El tama√±o 16 √ó 16 es casi la "regla de oro", se usa en muchos juegos, ¬°y lo elegiremos! <br><br>  Nuestra pantalla tiene un tama√±o de 160 √ó 128.  En otras palabras, necesitamos 10 √ó 8 mosaicos por pantalla, es decir  80 entradas en la tabla.  Para un gran nivel de pantallas de 10 √ó 10 (o pantallas de 100 √ó 1), solo se requerir√°n 8,000 registros (16 KB si usamos 16 bits para la grabaci√≥n. M√°s adelante mostraremos por qu√© decidimos elegir 16 bits para la grabaci√≥n). <br><br>  Compare esto con la cantidad de memoria que puede estar ocupada por una imagen grande en toda la pantalla: 40 KB * 100 = 4 MB.  Esto es una locura! <br><br>  Hablemos del sistema de renderizado. <br><br>  Cada cuadro debe contener (en orden de dibujo): <br><br><ul><li>  gr√°ficos de fondo (campo de juego posterior) </li><li>  el gr√°fico de nivel en s√≠ mismo (primer plano). </li><li>  sprites </li><li>  texto / superposici√≥n superior. </li></ul><br>  En particular, realizaremos secuencialmente las siguientes operaciones: <br><br><ol><li>  Dibujo de fondo + primer plano (mosaicos) </li><li>  dibujo de azulejos transl√∫cidos + sprites + superposici√≥n superior </li><li>  enviando datos por SPI. </li></ol><br>  DMA dibujar√° el fondo y los mosaicos completamente opacos.  Un mosaico completamente opaco es un mosaico en el que no hay p√≠xeles transparentes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/1dd/417/2da1dd41756746a4b387988c191ca673.png"></div><br>  <i>Azulejo parcialmente transparente (izquierda) y completamente opaco (derecha).</i>  <i>En un mosaico parcialmente transparente, algunos p√≠xeles (en la parte inferior izquierda) son transparentes y, por lo tanto, se puede ver un fondo a trav√©s de esta √°rea.</i> <br><br>  DMA no puede representar eficazmente mosaicos, sprites y superposiciones parcialmente transparentes.  En realidad, el sistema de chip DMA ATSAMD21 simplemente copia los datos y, a diferencia del Amiga Blitter, no verifica la transparencia (establecida por el valor del color).  Todos los elementos parcialmente transparentes son dibujados por la CPU. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/8a2/950/7bb8a29500f57268d62dae5b1de2a9ea.png"></div><br>  Los datos se transmiten a la pantalla usando DMA. <br><br><h3>  Crear una tuber√≠a </h3><br>  Como puede ver, si realizamos estas operaciones secuencialmente en un b√∫fer, tomar√° mucho tiempo.  De hecho, mientras DMA se est√° ejecutando, la CPU no estar√° ocupada, ¬°excepto esperar a que se complete DMA!  Esta es una mala manera de implementar un motor gr√°fico.  Adem√°s, cuando DMA env√≠a datos a un dispositivo SPI, no utiliza su ancho de banda completo.  De hecho, incluso cuando SPI opera a una frecuencia de 24 MHz, los datos se transmiten solo a una frecuencia de 3 MHz, que es bastante peque√±a.  En otras palabras, DMA no est√° acostumbrado a su m√°ximo potencial: DMA puede realizar otras tareas sin perder realmente el rendimiento. <br><br>  Es por eso que implementamos la tuber√≠a, que es el desarrollo de la idea del doble buffer (¬°usamos tres buffers!).  Por supuesto, al final, las operaciones siempre se realizan de forma secuencial.  Pero la CPU y DMA realizan simult√°neamente diferentes tareas, sin (especialmente) afectarse entre s√≠. <br><br>  Esto es lo que sucede al mismo tiempo: <br><br><ul><li>  El buffer se usa para dibujar datos de fondo usando el canal DMA 1; </li><li>  En otro b√∫fer (que anteriormente estaba lleno de datos de fondo), la CPU dibuja sprites y mosaicos parcialmente transparentes; </li><li>  Luego, se usa otro b√∫fer (que contiene un bloque de datos horizontal completo) para enviar datos a la pantalla a trav√©s de SPI usando el canal DMA 0. Por supuesto, el b√∫fer usado para enviar datos a trav√©s de SPI se llen√≥ previamente con sprites mientras que SPI envi√≥ el bloque anterior y mientras otro b√∫fer lleno de azulejos </li></ul><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a75/56e/a95/a7556ea9572df04f967fae2035275c01.png"></div><br><h3>  DMA </h3><br>  El sistema de chip DMA ATSAMD21 no es comparable a Blitter, pero tiene sus propias caracter√≠sticas √∫tiles.  Gracias a DMA, podemos proporcionar una frecuencia de actualizaci√≥n muy alta, a pesar de tener un campo de juego dual. <br><br>  La configuraci√≥n de la transferencia de DMA se almacena en la RAM, en "descriptores de DMA", que le indican a DMA c√≥mo y d√≥nde debe realizar la transferencia actual.  Estos descriptores se pueden unir: si hay una conexi√≥n (es decir, no hay un puntero nulo), luego de que se complete la transferencia, el DMA recibir√° autom√°ticamente el siguiente descriptor.  Mediante el uso de m√∫ltiples descriptores, DMA puede realizar "transferencias complejas" que son √∫tiles cuando, por ejemplo, el b√∫fer de origen es una secuencia de segmentos no contiguos de bytes contiguos.  Sin embargo, lleva tiempo obtener y escribir descriptores, porque necesita guardar / cargar 16 bytes de descriptor desde la RAM. <br><br>  DMA puede trabajar con datos de diferentes longitudes: bytes, medias palabras (16 bits) y palabras (32 bits).  En la especificaci√≥n, esta longitud se llama "tama√±o de latido".  Para SPI, nos vemos obligados a utilizar la transferencia de bytes (aunque la especificaci√≥n REVD actual establece que los chips ATSAMD21 SERCOM tienen FIFO, que, seg√∫n Microchip, puede aceptar datos de 32 bits, de hecho, parece que no tienen FIFO. La especificaci√≥n REVD tambi√©n menciona Registro SERCOM CTRLC, que est√° ausente tanto en los archivos de encabezado como en la secci√≥n de descripci√≥n del registro. Afortunadamente, a diferencia de AVR, ATSAMD21 al menos tiene un registro de datos de transmisi√≥n amortiguado, por lo que no habr√° pausas en la transmisi√≥n.  Para dibujar fichas, nosotros, por supuesto, usamos 32 bits.  Esto le permite copiar dos p√≠xeles por latido.  El chip ATSAMD21 DMA tambi√©n permite que cada latido de origen aumente la direcci√≥n de origen o destino en un n√∫mero fijo de tama√±os de latido. <br><br>  Estos dos aspectos son muy importantes y determinan la forma en que dibujamos los mosaicos. <br><br>  En primer lugar, si renderizamos un p√≠xel por latido (16 bits), reducir√≠amos a la mitad el rendimiento de nuestro sistema.  ¬°No podemos rechazar el ancho de banda completo! <br><br>  Sin embargo, si dibujamos dos p√≠xeles por latido, el campo del juego solo podr√° desplazarse un n√∫mero par de p√≠xeles, lo que provocar√° un movimiento suave.  Para manejar esto, puede usar un b√∫fer que sea dos o m√°s p√≠xeles m√°s grande.  Al enviar datos a la pantalla, utilizaremos el desplazamiento correcto (0 o 1 p√≠xel), dependiendo de si necesitamos mover la "c√°mara" en un n√∫mero par o impar de p√≠xeles. <br><br>  Sin embargo, en aras de la simplicidad, reservamos espacio para 11 mosaicos completos (160 + 16 p√≠xeles), y no para 160 + 2 p√≠xeles.  Este enfoque tiene una gran ventaja: no tenemos que calcular y actualizar la direcci√≥n del destinatario de cada descriptor de DMA (esto requerir√≠a varias instrucciones, lo que podr√≠a generar demasiados c√°lculos por mosaico).  Por supuesto, dibujaremos solo el n√∫mero m√≠nimo de p√≠xeles, es decir, no m√°s de 162. S√≠, al final, gastaremos un poco de memoria adicional (teniendo en cuenta tres buffers, esto es aproximadamente 1500 bytes) para mayor velocidad y simplicidad.  Tambi√©n puede realizar m√°s optimizaciones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/061/899/2ee/0618992eedba5d01c4d00da2aceec886.gif"></div><br>  Todos los b√∫feres de bloque de 16 l√≠neas (sin descriptores) son visibles en esta animaci√≥n GIF.  A la derecha est√° lo que realmente se muestra.  Los primeros 32 cuadros se muestran en GIF, en el que nos movemos 1 p√≠xel a la derecha en cada cuadro.  El √°rea negra del b√∫fer es la parte que no se actualiza, y su contenido simplemente permanece de operaciones anteriores.  Cuando la pantalla desplaza un n√∫mero impar de fotogramas, se dibuja un √°rea de 162 p√≠xeles de ancho en el b√∫fer.  Sin embargo, la primera y la √∫ltima columna de ellas (que se resaltan en la animaci√≥n) se descartan.  Cuando el valor de desplazamiento es un m√∫ltiplo de 16 p√≠xeles, las operaciones de dibujo en el b√∫fer comienzan desde la primera columna (x = 0). <br><br>  ¬øQu√© pasa con el desplazamiento vertical? <br><br>  Lo trataremos despu√©s de mostrar un m√©todo para almacenar mosaicos en la memoria flash. <br><br><h3>  C√≥mo almacenar azulejos </h3><br>  Un enfoque ingenuo (que nos convendr√≠a si solo proces√°ramos a trav√©s de la CPU) ser√≠a almacenar los mosaicos en la memoria flash como una secuencia de colores de p√≠xeles.  El primer p√≠xel de la primera l√≠nea, el segundo, y as√≠ sucesivamente, hasta el decimosexto.  Luego guardamos el primer p√≠xel de la segunda fila, el segundo, etc. <br><br>  ¬øPor qu√© es una decisi√≥n tan ingenua?  ¬°Porque en este caso, DMA solo puede representar 16 p√≠xeles por descriptor de DMA!  Por lo tanto, necesitamos 16 descriptores, cada uno de los cuales necesita 4 + 4 operaciones de acceso a memoria (es decir, para transferir 32 bytes - 8 operaciones de lectura de memoria + 8 operaciones de escritura de memoria - DMA debe realizar 4 lecturas m√°s + 4 escrituras).  ¬°Esto es bastante ineficiente! <br><br>  De hecho, para cada descriptor, DMA solo puede incrementar las direcciones de origen y destino en un n√∫mero fijo de palabras.  Despu√©s de copiar la primera l√≠nea del mosaico en el b√∫fer, la direcci√≥n del destinatario no debe aumentarse en 1 palabra, sino en un valor tal que apunte a la siguiente l√≠nea del b√∫fer.  Esto no es posible porque cada descriptor de transmisi√≥n indica solo el incremento de transmisi√≥n de tiempo, que no se puede cambiar. <br><br>  Ser√° mucho m√°s inteligente enviar los primeros dos p√≠xeles de cada l√≠nea del mosaico secuencialmente, es decir, los p√≠xeles 0 y 1 de la l√≠nea 0, los p√≠xeles 0 y 1 de la l√≠nea 1, etc., hasta los p√≠xeles 0 y 1 de la l√≠nea 15. Luego enviamos los p√≠xeles 2 y 3 de la l√≠nea 0, y as√≠ sucesivamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fee/f1a/2ee/feef1a2eea76233cd37000f8643f098f.png"></div><br>  <i>¬øC√≥mo se almacena un mosaico?</i> <br><br>  En la figura anterior, cada n√∫mero indica el orden en que se almacena el p√≠xel de 16 bits en la matriz de mosaicos. <br><br>  Esto se puede hacer con un descriptor, pero necesitamos dos cosas: <br><br><ul><li>  Los mosaicos deben almacenarse de modo que cuando incrementemos la fuente en una palabra, siempre apuntemos a las posiciones correctas de p√≠xeles.  En otras palabras, si (r, c) es un p√≠xel en la fila r y la columna c, entonces debemos guardar los p√≠xeles (0,0) (0,1) (1,0) (1,1) (2,0) secuencialmente (2.1) ... (15.0) (15.1) (0.2) (0.3) (1.2) (1.3) ... </li><li>  El b√∫fer debe tener 256 p√≠xeles de ancho (no 160) </li></ul><br>  El primer objetivo es muy f√°cil de lograr: simplemente cambie el orden de los datos, puede hacerlo al exportar gr√°ficos a un archivo c (vea la imagen de arriba). <br><br>  El segundo problema se puede resolver porque DMA le permite aumentar la direcci√≥n del destinatario despu√©s de cada latido en 512 bytes.  Esto tiene dos consecuencias: <br><br><ul><li>  No podemos enviar datos utilizando un descriptor √∫nico sobre un bloque SPI.  Este no es un problema muy serio, porque al final leemos un descriptor a trav√©s de 160 p√≠xeles.  El impacto en el rendimiento ser√° m√≠nimo. </li><li>  El bloque debe tener un tama√±o de 256 * 2 * 16 bytes = 8 KB, y habr√° un mont√≥n de "espacio no utilizado" en √©l. </li></ul><br>  Sin embargo, este espacio todav√≠a se puede usar, por ejemplo, para descriptores. <br><br>  De hecho, cada descriptor tiene un tama√±o de 16 bytes.  Necesitamos al menos 10 * 8 (¬°y en realidad 11 * 8!) Descriptores para mosaicos y 16 descriptores para SPI. <br><br>  Es por eso que mientras m√°s fichas, mayor es la velocidad.  De hecho, si us√°ramos, por ejemplo, un mosaico de 32 x 32, necesitar√≠amos menos descriptores por pantalla (320 en lugar de 640).  Esto reducir√≠a el desperdicio de recursos. <br><br><h3>  Mostrar bloque de datos </h3><br>  El b√∫fer de bloque, los descriptores y otros datos se almacenan en un tipo de estructura, que llamamos displayBlock_t. <br><br>  displayBlock es una matriz de 16 elementos displayLineData_t.  Los datos de DisplayLine contienen 176 p√≠xeles m√°s 80 palabras.  En estas 80 palabras, almacenamos descriptores de visualizaci√≥n u otros datos de visualizaci√≥n √∫tiles (mediante uni√≥n). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/817/4cc/f0b/8174ccf0b746674367693a5c6bcd47a5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/539/677/0a2539677818cc593c80aba690af6679.png"></div><br>  Como tenemos 16 l√≠neas, cada mosaico en la posici√≥n X usa los primeros 8 descriptores DMA (0 a 7) de las l√≠neas X. Dado que tenemos un m√°ximo de 11 mosaicos (la l√≠nea de visualizaci√≥n tiene 176 p√≠xeles de ancho), los mosaicos usan solo los primeros descriptores DMA 11 filas de datos.  Los descriptores 8‚Äì9 de todas las l√≠neas y los descriptores 0‚Äì9 de las l√≠neas 11‚Äì15 son gratuitos. <br><br>  De estos, los descriptores 8 y 9 de las l√≠neas 0..7 se utilizar√°n para SPI. <br><br>  Descriptores 0..9 l√≠neas 11-15 (hasta 50 descriptores, aunque usaremos solo 48 de ellos) se utilizar√°n para el campo de juego de fondo. <br><br>  La siguiente figura muestra su estructura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e38/017/7c0/e380177c03a9a6ca50538e438bb0552f.png"></div><br><h3>  Campo de juego de fondo </h3><br>  El campo de juego de fondo se maneja de manera diferente.  En primer lugar, si necesitamos un desplazamiento suave, tendremos que volver al formato de dos p√≠xeles, ya que el primer plano y el fondo se desplazar√°n a diferentes velocidades.  Por lo tanto, el ritmo estar√° a la mitad.  Aunque esto es una desventaja en t√©rminos de velocidad, este enfoque facilita la integraci√≥n.  Solo nos queda un peque√±o n√∫mero de descriptores, por lo que no se pueden usar mosaicos peque√±os.  Adem√°s, para simplificar el trabajo y agregar r√°pidamente paralaje, utilizaremos largos "sectores". <br><br>  El fondo se dibuja solo si hay al menos un p√≠xel parcialmente transparente.  Esto significa que si solo hay un mosaico transparente, se dibujar√° el fondo.  Por supuesto, esto es una p√©rdida de ancho de banda, pero simplifica todo. <br><br>  Compare el fondo y los campos de juego frontales: <br><br><ul><li>  En el fondo, se utilizan sectores, que son mosaicos largos almacenados de forma "ingenua". </li><li>  El fondo tiene su propio mapa, pero horizontalmente se repite.  Gracias a esto, se usa menos memoria. </li><li>  El fondo tiene paralaje para cada sector. </li></ul><br><h3>  Campo de juego delantero </h3><br>  Como se dijo, en cada bloque tenemos hasta 11 mosaicos (10 mosaicos completos, o 9 mosaicos completos y 2 archivos parciales).  Cada uno de estos mosaicos, si no est√° marcado como transparente, se dibuja DMA.  Si no es completamente opaco, se agrega a la lista, que se analizar√° m√°s adelante, cuando se renderizan sprites. <br><br><h3>  Conectamos dos campos de juego </h3><br>  Los descriptores del campo de juego de fondo (que siempre se calculan) y el campo de juego frontal forman una lista enlazada muy larga.  La primera parte dibuja un campo de juego de fondo.  La segunda parte dibuja mosaicos sobre el fondo.  La longitud de la segunda parte puede ser variable, porque los descriptores DMA de mosaicos parcialmente transparentes est√°n excluidos de la lista.  Si el bloque contiene solo mosaicos opacos, DMA se configura de la siguiente manera.  para comenzar directamente desde el primer descriptor del primer mosaico. <br><br><h3>  Sprites y azulejos con transparencia </h3><br>  Las baldosas con transparencia y sprites se procesan casi de la misma manera.  Se realiza el an√°lisis de p√≠xeles de mosaico / sprite.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si es negro, entonces es transparente y, por lo tanto, el mosaico de fondo no cambia. </font><font style="vertical-align: inherit;">Si no es negro, el p√≠xel de fondo se reemplaza por un p√≠xel de sprite / mosaico.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desplazamiento vertical </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al trabajar con desplazamiento horizontal, dibujamos hasta 11 mosaicos, incluso si al dibujar 11 mosaicos, el primero y el √∫ltimo solo se dibujan parcialmente. </font><font style="vertical-align: inherit;">Tal representaci√≥n parcial es posible debido al hecho de que cada descriptor dibuja dos columnas del mosaico, por lo que podemos establecer f√°cilmente el comienzo y el final de la lista vinculada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando trabajamos con desplazamiento vertical, necesitamos calcular tanto el registro del receptor como el volumen de transmisi√≥n. </font><font style="vertical-align: inherit;">Deben configurarse varias veces por cuadro. </font><font style="vertical-align: inherit;">Para evitar este alboroto, simplemente podemos dibujar hasta 9 bloques completos por cuadro (8 si el desplazamiento es un m√∫ltiplo de 16).</font></font><br><br><h2>  Equipo </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como dijimos, el coraz√≥n del sistema es uChip. </font><font style="vertical-align: inherit;">¬øQu√© hay del resto? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ hay un diagrama! </font><font style="vertical-align: inherit;">Vale la pena mencionar algunos aspectos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb1/b94/910/bb1b94910b94dc1289cc67f4f3e0022d.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Llaves </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para optimizar el uso de E / S, usamos un peque√±o truco. </font><font style="vertical-align: inherit;">Tendremos 4 buses de sensores L1-L4 y un cable LC com√∫n. </font><font style="vertical-align: inherit;">1 y 0 se aplican alternativamente al cable com√∫n. En consecuencia, los buses de sensores se tirar√°n hacia abajo o hacia arriba alternativamente con la ayuda de resistencias de tracci√≥n internas. </font><font style="vertical-align: inherit;">Dos llaves est√°n conectadas entre cada uno de los buses de teclas y un bus com√∫n. </font><font style="vertical-align: inherit;">Se inserta un diodo en serie con estas dos teclas. </font><font style="vertical-align: inherit;">Cada uno de estos diodos se conmuta en la direcci√≥n opuesta, de modo que cada vez que solo se "lee" una tecla.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que no hay un controlador de teclado incorporado (y ning√∫n controlador de teclado incorporado utiliza este m√©todo interesante), se sondean r√°pidamente ocho teclas al comienzo de cada cuadro. Dado que las entradas se deben tirar hacia arriba y hacia abajo, no podemos (y no queremos) usar resistencias externas, por lo que debemos usar las integradas, que pueden tener una resistencia bastante alta (60 kOhm). Esto significa que cuando el bus com√∫n cambia de estado, y los buses de datos cambian su estado de extracci√≥n hacia arriba / abajo, debe insertar alg√∫n retraso para que la resistencia incorporada hacia arriba / abajo cambie el contrato y establezca la capacitancia par√°sita al nivel deseado. ¬°Pero no queremos esperar! Por lo tanto, colocamos el bus com√∫n en un estado de alta impedancia (para que no haya desacuerdo), y primero cambiamos los buses del sensor a valores l√≥gicos 1 o 0,configur√°ndolos temporalmente como salida. M√°s tarde se configuran como entrada tirando hacia arriba o hacia abajo. Dado que la resistencia de salida es del orden de decenas de ohmios, el estado cambia en unos pocos nanosegundos, es decir, cuando el bus del sensor vuelve a la entrada, ya estar√° en el estado deseado. Despu√©s de eso, el bus com√∫n cambia a la salida con la polaridad opuesta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esto mejora enormemente la velocidad de escaneo y elimina la necesidad de retrasos / instrucciones de nop. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conexi√≥n SPI </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conectamos la SD y la pantalla para que se comuniquen entre s√≠ sin transferir datos al ATSAMD21. </font><font style="vertical-align: inherit;">Esto puede ser √∫til si desea reproducir el video. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las resistencias que conectan MISO y MOSI deben ser bajas. </font><font style="vertical-align: inherit;">Si son demasiado grandes, entonces el SPI no funcionar√°, porque la se√±al ser√° demasiado d√©bil.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimizaci√≥n y desarrollo posterior </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uno de los mayores problemas es el uso de RAM. Tres bloques ocupan 8 KB cada uno, dejando solo 8 KB por pila y otras variables. Por el momento, tenemos solo 1.3 KB de RAM libre + 4 KB de pila (4 KB por pila; esto es mucho, tal vez lo reduzcamos). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, puede usar bloques con una altura no de 16, sino de 8 p√≠xeles. Esto aumentar√° el desperdicio de recursos en los descriptores DMA, pero casi reducir√° a la mitad la cantidad de memoria ocupada por el b√∫fer de bloque (tenga en cuenta que el n√∫mero de descriptores no cambiar√° si continuamos usando mosaicos de 16 √ó 16, por lo que tendremos que cambiar la estructura del bloque). Esto puede liberar aproximadamente 7.5 KB de RAM, lo que ser√° muy √∫til para implementar funciones como una tarjeta modificable con secretos o agregar sonido (aunque el sonido se puede agregar incluso con 1 KB de RAM).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro problema es el sprite, pero esta modificaci√≥n es mucho m√°s simple de realizar, y solo necesita la funci√≥n createNextFrameScene () para ello. De hecho, estamos creando en RAM una gran matriz con el estado de todos los sprites. Luego, para cada sprite, calculamos si su posici√≥n est√° dentro del √°rea de la pantalla, y luego lo animamos y lo agregamos a la lista de renderizado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En cambio, puede realizar la optimizaci√≥n. Por ejemplo, en gameMap puedes almacenar no solo el valor del mosaico, sino tambi√©n una bandera que indica la transparencia del mosaico, establecida en el editor. Esto nos permitir√° verificar r√°pidamente si el mosaico debe representarse: DMA o CPU. Es por eso que utilizamos registros de 16 bits para la tarjeta de mosaico. Si suponemos que tenemos un conjunto de 256 mosaicos (en este momento tenemos menos de 128 mosaicos, pero hay suficiente espacio en la memoria flash para agregar nuevos), entonces hay 7 bits libres que se pueden usar para otros fines. Tres de estos siete bits se pueden usar para indicar si se est√° almacenando un objeto / objeto.</font></font> Por ejemplo: <br><br> <code>0b000 =    <br> 0b001 =  <br> 0b010 =  <br> 0b011 =  <br> 0b100 =  <br> 0b101 =  <br> 0b110 =  <br> 0b111 =    , ,   .</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego, puede crear una tabla de bits en la RAM en la que cada bit significa si se detecta (por ejemplo, un enemigo) / si (por ejemplo, una bonificaci√≥n) se recoge / si se activa un determinado objeto (interruptor). </font><font style="vertical-align: inherit;">En un nivel de 10 √ó 10 pantallas, esto requerir√° 8000 bits, es decir </font><font style="vertical-align: inherit;">1 KB de RAM. </font><font style="vertical-align: inherit;">El bit se restablece cuando se detecta un enemigo o se recoge una bonificaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En createNextFrameScene (), debemos verificar los bits correspondientes a los mosaicos en el √°rea visible actual. </font><font style="vertical-align: inherit;">Si tienen un valor de 1:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si esto es un bono, simplemente agr√©guelo a la lista de sprites para renderizar. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si este es un enemigo, crea un sprite din√°mico y reinicia la bandera. </font><font style="vertical-align: inherit;">En el siguiente cuadro, la escena contendr√° un sprite din√°mico hasta que el enemigo abandone la pantalla o sea asesinado.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este enfoque tiene desventajas. </font></font><br><br><ol><li> -,           (       ).      . </li><li> -,       80  ,  ,    .      ,            32 .          ,   ¬´/¬ª (      ¬´¬ª, ..        0!).           ¬´¬ª,          ¬´¬ª (           ). </li><li> -,      .       (    ),     .  ,      . </li><li> -,   ,   ,    ,     .     ,       ,     .          ,     ,   ,     ,   ! </li><li>     ,          (,    Unreal Tournament   ,        ). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, de esta manera podemos almacenar y procesar sprites a un nivel mucho m√°s eficiente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, esta t√©cnica es m√°s relevante para la "l√≥gica del juego" que para el motor gr√°fico del juego. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiz√°s en el futuro implementaremos esta funci√≥n.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para resumir </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esperamos que hayas disfrutado este art√≠culo introductorio. Necesitamos explicar muchos m√°s aspectos que ser√°n los temas de futuros art√≠culos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mientras tanto, puedes descargar el c√≥digo fuente completo del juego. Si te gusta, puedes apoyar financieramente al artista </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ansimuz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que dibuj√≥ todos los gr√°ficos y se los dio al mundo de forma gratuita. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n aceptamos donaciones</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El juego a√∫n no ha terminado. Queremos agregar sonido, muchos niveles, objetos con los que pueda interactuar y similares. ¬°Puedes crear tus propias modificaciones! ¬°Esperamos ver nuevos juegos con nuevos gr√°ficos y niveles! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pronto lanzaremos un editor de mapas, ¬°pero por ahora es demasiado rudimentario mostrarlo a la comunidad!</font></font><br><br><h2>  Video </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Nota: ¬°debido a la poca iluminaci√≥n, el video se grab√≥ a una velocidad de cuadro mucho m√°s baja! ¬°Pronto actualizaremos el video para que pueda estimar la velocidad m√°xima a 40 fps!) </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1ekTeCCWKNI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gratitud </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los gr√°ficos del juego (y los mosaicos que se muestran en algunas im√°genes) est√°n tomados del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">activo gratuito "Sunny Land" creado por ansimuz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Materiales descargables </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El c√≥digo fuente del proyecto es de dominio p√∫blico, es decir, se proporciona de forma gratuita. </font><font style="vertical-align: inherit;">Lo compartimos con la esperanza de que sea √∫til para alguien. </font><font style="vertical-align: inherit;">¬°No garantizamos que debido a cualquier error / error en el c√≥digo no habr√° problemas! </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagrama esquem√°tico </font></font></a> <font style="vertical-align: inherit;"><a href=""><font style="vertical-align: inherit;">Proyecto </font></a></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KiCad </font></font></a> <br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyecto Atmel Studio 7 (fuente)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466323/">https://habr.com/ru/post/466323/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466307/index.html">¬øC√≥mo dise√±o SCS?</a></li>
<li><a href="../466311/index.html">Taller SLS 6 de septiembre</a></li>
<li><a href="../466315/index.html">Compilaci√≥n @Pythonetc, agosto de 2019</a></li>
<li><a href="../466317/index.html">Consejos y trucos de mi canal de Telegram @pythonetc, agosto de 2019</a></li>
<li><a href="../466319/index.html">Oferta: VMware compra inicio basado en la nube</a></li>
<li><a href="../466329/index.html">Mapa electr√≥nico de la vinificaci√≥n en Rusia. Dise√±o y contenido.</a></li>
<li><a href="../466333/index.html">C√≥mo organizar un lugar de trabajo para ti</a></li>
<li><a href="../466335/index.html">Crear una aplicaci√≥n Slack usando las caracter√≠sticas de 8base</a></li>
<li><a href="../466337/index.html">¬øDe qu√© color es tu funci√≥n?</a></li>
<li><a href="../466341/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D√≠a 33. Preparaci√≥n para el examen ICND1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>