<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍✈️ 📛 💶 Partie 1: RISC-V / RocketChip dans un habitat non naturel 🎿 🔘 ⚗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Récemment, un article a été publié sur Habr sur la façon d'expérimenter avec l'architecture RISC-V sans le coût du matériel. Mais que faire si vous fa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Partie 1: RISC-V / RocketChip dans un habitat non naturel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455391/"><img src="https://habrastorage.org/webt/it/on/yz/itonyz90xq9l_bvyih5h20xhuds.png" alt="Configuration de fusée" align="left"><br><p>  Récemment, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article a été</a> publié sur Habr sur la façon d'expérimenter avec l'architecture RISC-V sans le coût du matériel.  Mais que faire si vous faites cela sur le tableau de débogage?  Rappelez-vous des mèmes sur le générateur de jeu: environ 20 cases à cocher dans le style "Les graphiques ne sont pas pires que la crise", "Vous pouvez voler des corovans" et le bouton "Générer".  Le générateur RocketChip SoC est organisé à peu près de la même manière, seulement il n'y a pas de fenêtre avec des coches, mais un code Scala et un peu d'assembleur et de fichiers Make.  Dans cet article, je vais montrer à quel point il est facile de porter ce RocketChip de son Xilinx natif vers Altera / Intel. </p><a name="habracut"></a><br><p> <strong>AVERTISSEMENT: l'</strong> auteur n'est pas responsable de la carte «brûlée» - regardez attentivement comment vous configurez les broches, ce que vous connectez physiquement, etc.  Eh bien, respectez également les consignes de sécurité.  Vous ne devriez pas penser que puisque tout est connecté via USB, c'est définitivement sans danger pour une personne: comme je l'ai compris dans mes expériences précédentes, même si vous travaillez avec une carte USB, vous n'avez toujours pas à toucher la batterie chauffante avec votre pied, car la différence de potentiel ... Oh oui , Je ne suis pas un ingénieur en plisovode ou en électronique - je suis juste un programmeur Scala. </p><br><p> Pour autant que je sache, la plate-forme initiale de débogage de RocketChip était le FPGA Xilinx.  A en juger par le référentiel, que nous allons bientôt cloner, il a également été porté sur Microsemi.  Quelque part, j'ai entendu parler de l'utilisation d'Altera, mais je n'ai pas vu la source.  Il s'est avéré que ce n'était pas un gros problème: à partir du moment où nous avons reçu la carte et commencé à étudier le référentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SiFive Freedom</a> vers un système «sans mémoire» (c'est-à-dire n'ayant que des registres de processeur, BootROM et des registres mappés en mémoire) «microcontrôleur» 32 bits (bien que ce soit déjà ce que quelque chose que le <em>nanocontrôleur</em> s'avère ...) 3 jours de repos et 4 soirs de semaine se sont écoulés, et il aurait fallu encore moins s'il m'était venu immédiatement de définir définir <code>SYNTHESIS</code> globalement. </p><br><h1 id="materialy">  Matériaux </h1><br><p>  Pour commencer - une liste de <em>matériaux</em> au sens large du terme.  Nous avons besoin du logiciel suivant: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RocketChip</a> - contient le processeur lui-même et l'environnement d'assemblage (y compris, décrit plusieurs sous-référentiels).  Capable de créer RocketChip avec le processeur dans l'ordre du noyau Rocket. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SiFive Freedom</a> - obligatoire pour diverses cartes de débogage - nous y ajouterons la prise en charge de notre </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rocket-tools</a> - outils de construction de code et de débogage pour les architectures RISC-V 32 et 64 bits </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">openocd-riscv</a> - Port <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenOCD</a> pour travailler sur JTAG avec les noyaux RISC-V (au moins RocketChip) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IntelliJ IDEA Community</a> pour l'édition du code Scala, qui est la majorité dans RocketChip </li><li>  La chaîne d'outils pré-assemblée de SiFive peut également être utile, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> vers lequel j'ai vu dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> déjà mentionné </li></ul><br><p>  Ce dont le fer a besoin: </p><br><ul><li>  Kit Zeowaa d'Aliexpress: carte avec Cyclone 4 EP4CE115 et (clone?) USB Blaster </li><li>  RaspberryPi comme débogueur JTAG pour soft core </li></ul><br><p>  La machine hôte est supposée être un ordinateur relativement puissant avec Ubuntu et Quartus Lite 18 installés. </p><br><p>  En fait, il y a une option pour lancer dans le cloud Amazon sur leurs instances FPGA à partir du même SiFive, appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FireSim</a> , mais ce n'est pas si intéressant, <del>  Oui, et les LED sont mal visibles </del>  .  De plus, dans ce cas, vous devrez spécifier votre clé API sur l'instance de contrôle pour démarrer d'autres machines virtuelles, et vous devez en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prendre grand soin</a> , sinon, selon les rumeurs, vous pouvez vous réveiller un jour avec une dette de dizaines de milliers de dollars ... </p><br><h1 id="izuchaem-obstanovku">  Nous étudions la situation </h1><br><p>  Pour commencer, j'ai pris le projet de test <code>read_write_1G</code> du fournisseur de la carte et j'ai essayé d'y ajouter les sources requises.  Pourquoi ne pas en créer un nouveau?  Parce que je suis nouveau, et dans ce projet, les noms des broches ont déjà été mappés.  Donc, vous devez prendre le code source quelque part.  Pour ce faire, nous aurons besoin du référentiel de <code>freedom</code> déjà spécifié (à ne pas confondre avec <code>freedom-e-sdk</code> ).  Pour obtenir au moins quelque chose, nous allons collecter <code>rocket-tools</code> selon les instructions (lancer littéralement deux scripts et beaucoup d'attente), puis exécuter </p><br><pre> <code class="plaintext hljs">RISCV=$(pwd)/../rocket-tools make -f Makefile.e300artydevkit verilog mcs</code> </pre> <br><p>  Le <code>verilog</code> cible <code>verilog</code> un énorme fichier Verilog avec des sources de processeur, et <code>mcs</code> compilera BootROM.  Pas besoin de s'inquiéter de l'échec de <code>mcs</code> - nous n'avons tout simplement pas Xilinx Vivado, donc la BootROM compilée ne peut pas être convertie au format dont Vivado a besoin. </p><br><p>  Via l'élément de menu <strong>Projet</strong> Quartus <strong>-&gt; Ajouter / Supprimer des fichiers dans le projet ...</strong> ajoutez <code>freedom/builds/e300artydevkit/sifive.freedom.everywhere.e300artydevkit.E300ArtyDevKitConfig.v</code> , définissez l'entité de niveau supérieur: <strong>E300ArtyDevKitFPGAChip</strong> sur l'onglet Général et lancez la compilation (éventuellement , la liste d'auto-complétion d'entité de niveau supérieur n'apparaîtra qu'après la première compilation).  En conséquence, nous obtenons des tonnes d'erreurs nous informant de l'absence de modules <code>AsyncResetReg</code> , <code>IOBUF</code> , etc.  S'il n'y a aucune erreur, vous avez oublié de modifier l'entité de niveau supérieur.  Si vous fouillez la source, vous pouvez trouver directement le fichier <code>AsyncResetReg.v</code> , mais <code>IOBUF</code> est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liaison</a> avec le noyau IP de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Xilinx</a> .  Tout d'abord, ajoutez <code>freedom/rocket-chip/src/main/resources/vsrc/AsyncResetReg.v</code> .  Et <code>plusarg_reader.v</code> sera également ajouté. </p><br><p>  Exécutez la compilation et obtenez une autre erreur: </p><br><pre> <code class="plaintext hljs">Error (10174): Verilog HDL Unsupported Feature error at plusarg_reader.v(18): system function "$value$plusargs" is not supported for synthesis</code> </pre> <br><p>  En principe, des constructions non synthétisées peuvent être attendues d'un fichier avec un nom similaire. </p><br><div class="spoiler">  <b class="spoiler_title">plusarg_reader.v</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// See LICENSE.SiFive for license details. //VCS coverage exclude_file // No default parameter values are intended, nor does IEEE 1800-2012 require them (clause A.2.4 param_assignment), // but Incisive demands them. These default values should never be used. module plusarg_reader #(parameter FORMAT="borked=%d", DEFAULT=0) ( output [31:0] out ); `ifdef SYNTHESIS assign out = DEFAULT; `else reg [31:0] myplus; assign out = myplus; initial begin if (!$value$plusargs(FORMAT, myplus)) myplus = DEFAULT; end `endif endmodule</code> </pre> </div></div><br><p>  Comme nous pouvons le voir, ce module lit probablement les options de simulation à partir de la ligne de commande, et lors de sa synthèse, il renvoie simplement la valeur par défaut.  Le problème est que notre projet ne définit pas de définition nommée <code>SYNTHESIS</code> .  Il serait possible d' <code>ifdef</code> <code>`define SYNTHESIS</code> sur la ligne précédente juste avant l' <code>ifdef</code> , puis passer une demi-semaine à essayer de comprendre pourquoi le noyau ne démarre pas (et après tout, l'infection est synthétisée ...).  Ne répétez pas mes erreurs, mais ouvrez simplement à nouveau les propriétés du projet et dans l'onglet <strong>Paramètres</strong> du <strong>compilateur-&gt; Verilog HDL Input</strong> , définissez la macro <code>SYNTHESIS</code> , et au moins 1, pas dans <code>&lt;NONE&gt;</code> (ligne vide). </p><br><p>  Ici!  Quartus jure désormais des liaisons manquantes - il est temps de configurer un projet dans Idea et de commencer le portage. </p><br><h1 id="znakomimsya-s-proektom">  Connaître le projet </h1><br><p>  Nous indiquons l'idée du projet d'importation, spécifions le chemin d'accès au référentiel de <code>freedom</code> , indiquons le type de projet sbt, vérifions l'utilisation du shell sbt pour les importations, pour les cases à cocher des builds.  Ici, le conte de fées se termine, semble-t-il, mais il ne trouve pas l'idée d'un demi-projet - tous les codes source sont marqués en rouge.  Sur la base des informations <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'ici</a> , j'ai obtenu la procédure suivante: </p><br><ul><li>  ouvrir la fenêtre du shell sbt </li><li>  entrer <code>clean</code> </li><li>  appuyez sur le bouton de redémarrage vert à gauche </li><li>  après avoir redémarré sbt, entrez la première commande <code>++2.12.4</code> , basculant ainsi tous les sous-projets vers Scala version 2.12.4, puis nous exécuterons la <code>compile</code> </li><li>  cliquez sur Actualiser tous les projets sbt Idée </li><li>  PROFIT!, Maintenant le rétroéclairage fonctionne correctement </li></ul><br><p>  Jusqu'à présent, je vais essayer de monter le projet en quelque sorte, au moins en mode semi-manuel.  <strong>Soit dit en passant, quelqu'un, dites- <code>quartus_ipcreate</code> , est-ce que <code>quartus_ipcreate</code> est dans Lite Edition?</strong>  Nous allons créer des variantes IP manuellement pour l'instant, et les liaisons ne seront sur Scala que sous la forme d'une BlackBox. </p><br><p>  Dans ce cas, nous nous intéressons à la hiérarchie de répertoires suivante: </p><br><pre> <code class="plaintext hljs">fpga-shells () | +-src/main/scala | +- ip/intel &lt;--     IP Variations | | | +- Intel.scala | +- shell/intel &lt;--       | +- ZeowaaShell.scala src/main/scala | +- everywhere.e300artydevkit &lt;--   "" ,    | +- zeowaa/e115 &lt;--      "" SoC | +- Config +- FPGAChip +- Platform +- System</code> </pre> <br><p>  Vous devez également ajouter un Makefile similaire à <code>Makefile.e300artydevkit</code> , quelque chose comme ceci: </p><br><p>  <strong>Makefile.zeowaa-e115:</strong> </p><br><pre> <code class="plaintext hljs"># See LICENSE for license details. base_dir := $(patsubst %/,%,$(dir $(abspath $(lastword $(MAKEFILE_LIST))))) BUILD_DIR := $(base_dir)/builds/zeowaa-e115 FPGA_DIR := $(base_dir)/fpga-shells/intel MODEL := FPGAChip PROJECT := sifive.freedom.zeowaa.e115 export CONFIG_PROJECT := sifive.freedom.zeowaa.e115 export CONFIG := ZeowaaConfig export BOARD := zeowaa export BOOTROM_DIR := $(base_dir)/bootrom/xip rocketchip_dir := $(base_dir)/rocket-chip sifiveblocks_dir := $(base_dir)/sifive-blocks include common.mk</code> </pre> <br><h1 id="bindingi">  Liaisons </h1><br><p>  Pour commencer, nous mettons en œuvre cet <code>IOBUF</code> - ce ne sera guère difficile.  A en juger par le code Scala, il s'agit d'un module qui contrôle la «jambe» physique (balle?) Du microcircuit: il peut être allumé, peut être allumé ou peut être complètement désactivé.  Dans la partie droite de la fenêtre Quartus, nous entrerons «IOBUF» dans le catalogue IP et obtiendrons immédiatement un composant nommé <code>ALTIOBUF</code> .  Définissons un nom pour le fichier de variantes, sélectionnez «En tant que tampon bidirectionnel».  Après cela, un module appelé <code>iobuf</code> apparaîtra dans notre projet: </p><br><pre> <code class="plaintext hljs">// ... module obuf ( datain, oe, dataout); input [0:0] datain; input [0:0] oe; output [0:0] dataout; wire [0:0] sub_wire0; wire [0:0] dataout = sub_wire0[0:0]; obuf_iobuf_out_d5t obuf_iobuf_out_d5t_component ( .datain (datain), .oe (oe), .dataout (sub_wire0)); endmodule // ...</code> </pre> <br><p>  Écrivons un module blackbox pour cela: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ip.intel <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chisel3._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chisel3.core.{<span class="hljs-type"><span class="hljs-type">Analog</span></span>, <span class="hljs-type"><span class="hljs-type">BlackBox</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> freechips.rocketchip.jtag.<span class="hljs-type"><span class="hljs-type">Tristate</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOBUF</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlackBox</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> datain = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataout = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> oe = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataio = <span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">desiredName</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"iobuf"</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOBUF</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">Analog</span></span>, t: <span class="hljs-type"><span class="hljs-type">Tristate</span></span>): <span class="hljs-type"><span class="hljs-type">IOBUF</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> res = <span class="hljs-type"><span class="hljs-type">Module</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">IOBUF</span></span>) res.io.datain := t.data res.io.oe := t.driven a &lt;&gt; res.io.dataio res } }</code> </pre> <br><p>  Nous décrivons le Verilogue <code>inout</code> type <code>Analog</code> , et la méthode <code>desiredName</code> permet de changer le nom de classe du module.  Ceci est particulièrement important car nous générons des classeurs, pas des implémentations. </p><br><p>  Nous avons également besoin de BootROM - pour cela, nous créons une variante de la <strong>ROM: 1-PORT</strong> (mots 2048 x 32 bits, seul registre d'adresse, créez le port <code>rden</code> ).  Nous créons un bloc avec le nom <code>rom</code> , car alors nous devrons écrire un adaptateur pour l'interface que la classe <code>ROMGenerator</code> : <code>ROMGenerator</code> au lieu de <code>me</code> et <code>oe</code> manquant de nous (il est toujours attaché à 1): </p><br><p>  <strong>BootROM.v:</strong> </p><br><pre> <code class="plaintext hljs">module BootROM( input wire [10:0] address, input wire clock, input wire me, input wire oe, output wire [31:0] q ); rom r( .address(address), .clock(clock), .rden(me), .q(q) ); endmodule</code> </pre><br><p>  Un autre problème est immédiatement découvert: les fichiers hex générés par le collecteur, pour une raison quelconque, s'avèrent incompatibles avec Quartus.  Après une légère recherche sur le sujet des fichiers Intel HEX (Intel était bien avant l'achat de cet Intel Altera, si je comprends bien), nous arrivons à une telle commande qui convertit les fichiers binaires en HEX: </p><br><pre> <code class="plaintext hljs">srec_cat -Output builds/zeowaa-e115/xip.hex -Intel builds/zeowaa-e115/xip.bin -Binary -Output_Block_Size 128</code> </pre> <br><p>  Par conséquent, notre Makefile sera un peu transformé: </p><br><div class="spoiler">  <b class="spoiler_title">Texte masqué</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">base_dir := $(patsubst %/,%,$(dir $(abspath $(lastword $(MAKEFILE_LIST))))) BUILD_DIR := $(base_dir)/builds/zeowaa-e115 FPGA_DIR := $(base_dir)/fpga-shells/intel MODEL := FPGAChip PROJECT := sifive.freedom.zeowaa.e115 export CONFIG_PROJECT := sifive.freedom.zeowaa.e115 export CONFIG := ZeowaaConfig export BOARD := zeowaa export BOOTROM_DIR := $(base_dir)/bootrom/xip rocketchip_dir := $(base_dir)/rocket-chip sifiveblocks_dir := $(base_dir)/sifive-blocks all: verilog $(MAKE) -C $(BOOTROM_DIR) clean romgen || true srec_cat -Output $(BUILD_DIR)/xip.hex -Intel $(BUILD_DIR)/xip.bin -Binary -Output_Block_Size 128 include common.mk</code> </pre> </div></div><br><h1 id="ono-shevelitsyaw-sinteziruetsya">  Il bouge ^ W est synthétisé </h1><br><p>  Donc, le projet dans son ensemble est synthétisé, maintenant la chose la plus intéressante est le débogage.  Le chat est d'abord autorisé à entrer dans la maison, et peut-être le JTAG dans le microcontrôleur.  Créons un système de débogage presque minimal: BootROM pour démarrer, GPIO pour clignoter les voyants et JTAG pour comprendre pourquoi rien ne se charge et ne clignote pas.  Par analogie avec <code>E300ArtyDevKit</code> créez un package contenant quatre fichiers.  Tout d'abord </p><br><p>  <strong>Config.scala:</strong> </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultZeowaaConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> new </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">WithNBreakpoints</span></span></span></span><span class="hljs-class"><span class="hljs-params">(2</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">++</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithNExtTopInterrupts</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">0</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">++</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithJtagDTM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">++</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TinyConfig</span></span></span><span class="hljs-class"> ) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Peripherals</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(site, here, up</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">=&gt;</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PeripheryGPIOKey</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">List</span></span>( <span class="hljs-type"><span class="hljs-type">GPIOParams</span></span>(address = <span class="hljs-type"><span class="hljs-type">BigInt</span></span>(<span class="hljs-number"><span class="hljs-number">0x64002000</span></span>L), width = <span class="hljs-number"><span class="hljs-number">6</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PeripheryMaskROMKey</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">List</span></span>( <span class="hljs-type"><span class="hljs-type">MaskROMParams</span></span>(address = <span class="hljs-number"><span class="hljs-number">0x10000</span></span>, name = <span class="hljs-string"><span class="hljs-string">"BootROM"</span></span>)) }) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeowaaConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> new </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Peripherals</span></span></span></span><span class="hljs-class"><span class="hljs-params"> ++ new </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">DefaultZeowaaConfig</span></span></span></span><span class="hljs-class"><span class="hljs-params">(</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alter</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(site, here, up</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">=&gt;</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">JtagDTMKey</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">JtagDTMConfig</span></span> ( idcodeVersion = <span class="hljs-number"><span class="hljs-number">2</span></span>, idcodePartNum = <span class="hljs-number"><span class="hljs-number">0xe31</span></span>, idcodeManufId = <span class="hljs-number"><span class="hljs-number">0x489</span></span>, debugIdleCycles = <span class="hljs-number"><span class="hljs-number">5</span></span>) }) )</code> </pre> <br><p>  La description est pour la plupart copiée et tronquée à partir de l'E300: nous demandons en quoi consiste notre noyau et où il se trouvera dans l'espace d'adressage.  Veuillez noter que bien que nous n'ayons pas de RAM (c'est le <code>TinyConfig</code> par défaut dans <code>TinyConfig</code> ), il y a en plus un espace d'adressage 32 bits! </p><br><p>  Il existe également un fichier contenant une certaine quantité de passe-partout. <br>  <strong>System.scala:</strong> </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">System</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">implicit p: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Parameters</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RocketSubsystem</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasPeripheryMaskROMSlave</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasPeripheryDebug</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasPeripheryGPIO</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> module = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SystemModule</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SystemModule</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L</span></span></span><span class="hljs-class"> &lt;: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">System</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">_outer: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">L</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RocketSubsystemModuleImp</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">_outer</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasPeripheryDebugModuleImp</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasPeripheryGPIOModuleImp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Reset vector is set to the location of the mask rom val maskROMParams = p(PeripheryMaskROMKey) global_reset_vector := maskROMParams(0).address.U }</span></span></code> </pre> <br><p>  En fait, la disposition de notre "carte mère" est en trois (simples) fichiers simples: <br>  <strong>Platform.scala:</strong> </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlatformIO</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">implicit val p: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Parameters</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jtag = <span class="hljs-type"><span class="hljs-type">Flipped</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">JTAGIO</span></span>(hasTRSTn = <span class="hljs-literal"><span class="hljs-literal">false</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jtag_reset = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gpio = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">GPIOPins</span></span>(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">BasePin</span></span>(), p(<span class="hljs-type"><span class="hljs-type">PeripheryGPIOKey</span></span>)(<span class="hljs-number"><span class="hljs-number">0</span></span>)) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Platform</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">implicit p: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Parameters</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sys = <span class="hljs-type"><span class="hljs-type">Module</span></span>(<span class="hljs-type"><span class="hljs-type">LazyModule</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">System</span></span>).module) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">PlatformIO</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sjtag = sys.debug.systemjtag.get sjtag.reset := io.jtag_reset sjtag.mfr_id := p(<span class="hljs-type"><span class="hljs-type">JtagDTMKey</span></span>).idcodeManufId.<span class="hljs-type"><span class="hljs-type">U</span></span>(<span class="hljs-number"><span class="hljs-number">11.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>) sjtag.jtag &lt;&gt; io.jtag io.gpio &lt;&gt; sys.gpio.head }</code> </pre> <br><p>  <strong>FPGAChip.scala:</strong> </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FPGAChip</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">override implicit val p: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Parameters</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeowaaShell</span></span></span><span class="hljs-class"> </span></span>{ withClockAndReset(cpu_clock, cpu_rst) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dut = <span class="hljs-type"><span class="hljs-type">Module</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Platform</span></span>) dut.io.jtag.<span class="hljs-type"><span class="hljs-type">TCK</span></span> := jtag_tck dut.io.jtag.<span class="hljs-type"><span class="hljs-type">TDI</span></span> := jtag_tdi <span class="hljs-type"><span class="hljs-type">IOBUF</span></span>(jtag_tdo, dut.io.jtag.<span class="hljs-type"><span class="hljs-type">TDO</span></span>) dut.io.jtag.<span class="hljs-type"><span class="hljs-type">TMS</span></span> := jtag_tms dut.io.jtag_reset := jtag_rst <span class="hljs-type"><span class="hljs-type">Seq</span></span>(led_0, led_1, led_2, led_3) zip dut.io.gpio.pins foreach { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (led, pin) =&gt; led := <span class="hljs-type"><span class="hljs-type">Mux</span></span>(pin.o.oe, pin.o.oval, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } dut.io.gpio.pins.foreach(_.i.ival := <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) dut.io.gpio.pins(<span class="hljs-number"><span class="hljs-number">4</span></span>).i.ival := key1 dut.io.gpio.pins(<span class="hljs-number"><span class="hljs-number">5</span></span>).i.ival := key2 } }</code> </pre> <br><p>  Comme vous pouvez le voir, vous pouvez écrire des générateurs dans Chisel dans un style fonctionnel (un cas très simple est illustré ici).  Mais vous pouvez écrire et clairement chaque fil: </p><br><div class="spoiler">  <b class="spoiler_title">ZeowaaShell.scala</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeowaaShell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemIf</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_addr = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">14.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_ba = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">3.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_cas_n = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_cke = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">2.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_clk = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">2.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_clk_n = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">2.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_cs_n = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">2.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_dm = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">8.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_dq = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">64.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_dqs = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">8.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_odt = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">2.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_ras_n = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mem_we_n = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeowaaShell</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">implicit val p: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Parameters</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RawModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clk25 = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clk27 = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clk48 = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key1 = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key2 = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key3 = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> led_0 = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> led_1 = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> led_2 = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> led_3 = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jtag_tdi = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jtag_tdo = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jtag_tck = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jtag_tms = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uart_rx = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uart_tx = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-type"><span class="hljs-type">Analog</span></span>(<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// Internal wiring val cpu_clock = Wire(Clock()) val cpu_rst = Wire(Bool()) val jtag_rst = Wire(Bool()) withClockAndReset(cpu_clock, false.B) { val counter = Reg(UInt(64.W)) counter := counter + 1.U cpu_rst := (counter &gt; 1000.U) &amp;&amp; (counter &lt; 2000.U) jtag_rst := (counter &gt; 3000.U) &amp;&amp; (counter &lt; 4000.U) } cpu_clock &lt;&gt; clk25 }</span></span></code> </pre> </div></div><br><p>  Pourquoi est-il divisé en trois fichiers?  Eh bien, tout d'abord, c'était comme ça dans le prototype :) La logique de séparation de <code>Shell</code> de <code>FPGAChip</code> , apparemment, était que Shell est une description de l'interface avec le monde extérieur: quelles conclusions nous avons sur un tableau spécifique (et comment elles seront affichées sur conclusions de la puce!), et <code>FPGAChip</code> est dicté par le fait que nous voulons entrer dans un SoC spécifique.  Eh bien, la plate-forme est séparée de façon assez logique: remarque: <code>ZeowaaShell</code> (et, par conséquent, la <code>Platform</code> - <code>Platform</code> ) est un <code>RawModule</code> , en particulier, ils n'ont pas d' <code>clock</code> implicite et de <code>reset</code> - cela est naturel pour «câbler la carte», mais peu pratique pour le travail (et, probablement, chargé d’erreurs délicates avec des domaines fréquentiels prolifiques).  Eh bien, Platform est déjà un module Chisel ordinaire, dans lequel vous pouvez décrire en toute sécurité les registres, etc. </p><br><h1 id="jtag">  Jtag </h1><br><p>  Quelques mots sur la configuration de JTAG.  Comme j'avais déjà le RaspberryPi 3 Model B +, la solution évidente était d'essayer en quelque sorte d'utiliser son GPIO.  Heureusement, <em>tout a déjà été implémenté avant nous</em> : dans le nouveau OpenOCD, il y a une description de l' <code>interface/sysfsgpio-raspberrypi.cfg</code> , avec laquelle vous pouvez dire au débogueur de se connecter via le bloc (TCK = 11, TMS = 25, TDI = 10, TDO = 9, et GND congé comme exercice) - brochage <a href="">ici</a> . </p><br><p>  De plus, en prenant <a href="">Freedom.cfg</a> comme base à partir du <code>riscv-tests</code> , j'ai obtenu ce qui suit: </p><br><pre> <code class="plaintext hljs">adapter_khz 10000 source [find interface/sysfsgpio-raspberrypi.cfg] set _CHIPNAME riscv jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id 0x20e31913 set _TARGETNAME $_CHIPNAME.cpu target create $_TARGETNAME riscv -chain-position $_TARGETNAME -rtos riscv init halt echo "Ready for Remote Connections"</code> </pre> <br><p>  Pour fonctionner, vous aurez besoin du port <a href="">riscv-openocd</a> construit sous ARM, donc <del>  le cadeau n'est pas passé </del>  au lieu de la version pré-assemblée de SiFive, vous devez cloner le référentiel et collecter: </p><br><pre> <code class="plaintext hljs">./configure --enable-remote-bitbang --enable-sysfsgpio</code> </pre> <br><p>  Si quelqu'un sait comment exécuter un bitbang distant, vous n'aurez peut-être pas besoin de créer un port personnalisé pour ARM ... </p><br><p>  En conséquence, nous lançons depuis la racine sur Malinka </p><br><pre> <code class="plaintext hljs">root@ubuntu:~/riscv-openocd# ./src/openocd -s tcl -f ../riscv.tcl Open On-Chip Debugger 0.10.0+dev-00614-g998fed1fe-dirty (2019-06-03-10:27) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html adapter speed: 10000 kHz SysfsGPIO nums: tck = 11, tms = 25, tdi = 10, tdo = 9 SysfsGPIO nums: swclk = 11, swdio = 25 Info : auto-selecting first available session transport "jtag". To override use 'transport select &lt;transport&gt;'. Info : SysfsGPIO JTAG/SWD bitbang driver Info : JTAG and SWD modes enabled Warn : gpio 11 is already exported Warn : gpio 25 is already exported Info : This adapter doesn't support configurable speed Info : JTAG tap: riscv.cpu tap/device found: 0x20e31913 (mfg: 0x489 (SiFive, Inc.), part: 0x0e31, ver: 0x2) Info : datacount=1 progbufsize=16 Info : Disabling abstract command reads from CSRs. Info : Examined RISC-V core; found 1 harts Info : hart 0: XLEN=32, misa=0x40001105 Info : Listening on port 3333 for gdb connections Ready for Remote Connections Info : Listening on port 6666 for tcl connections Info : Listening on port 4444 for telnet connections</code> </pre> <br><p>  Après vous être connecté sur SSH avec la redirection de port 3333, en remplaçant l'adresse IP souhaitée: </p><br><pre> <code class="plaintext hljs">ssh -L 3333:127.0.0.1:3333 ubuntu@192.168.1.104</code> </pre> <br><p>  Maintenant sur l'hôte, vous pouvez exécuter GDB <strong>sous l'architecture riscv32</strong> : </p><br><pre> <code class="plaintext hljs">$ ../../rocket-tools/bin/riscv32-unknown-elf-gdb -q (gdb) target remote :3333 Remote debugging using :3333 warning: No executable has been specified and target does not support determining executable automatically. Try using the "file" command. 0x00000000 in ?? ()</code> </pre> <br><p>  Nous ignorerons un débogage aveugle du JTAG non collant car la macro <code>SYNTHESIS</code> est activement utilisée dans le fichier généré principal, et rembobinerons la situation à l'état "JTAG est accroché, mais les voyants ne clignotent pas". </p><br><h1 id="pervyy-kod">  Premier code </h1><br><p>  Comme nous l'avons vu dans le Makefile, le code de bootrom <code>bootrom/xip/xip.S</code>  Maintenant, cela ressemble à ceci: </p><br><pre> <code class="plaintext hljs">// See LICENSE for license details. // Execute in place // Jump directly to XIP_TARGET_ADDR .section .text.init .option norvc .globl _start _start: csrr a0, mhartid la a1, dtb li t0, XIP_TARGET_ADDR jr t0 .section .rodata dtb: .incbin DEVICE_TREE</code> </pre> <br><p>  Je comprends qu'il doit y avoir une arborescence de périphériques (le contenu du fichier dtb) à lire par le système d'exploitation, mais quel type de système d'exploitation existe-t-il sans RAM.  Par conséquent, remplacez-le temporairement avec audace par des ampoules clignotantes: </p><br><div class="spoiler">  <b class="spoiler_title">Texte masqué</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> .section .text.init .option norvc .globl _start _start: li a5, 0x64002000 li a1, 0x0F li a2, 0x01 li a3, 0x30 li a6, 0x10 li a7, 0x20 sw zero, 0x38(a5) // iof_en sw a1, 0x08(a5) // output_en sw a2, 0x00(a5) // value sw a1, 0x14(a5) // drive sw a3, 0x04(a5) // input_en // a0 &lt;- timer // a1 &lt;- 0x0F // a2 &lt;- [state] // a3 &lt;- 0x30 // a4 &lt;- [buttons] // a5 &lt;- [gpio addr] // a6 &lt;- 0x10 // a7 &lt;- 0x20 loop: li a4, 0x1000 add a0, a0, a4 bgtu a0, zero, loop lw a4, 0x00(a5) // value beq a4, a6, plus beq a4, a7, minus j store plus: srai a2, a2, 1 beq a2, zero, pzero j store pzero: li a2, 0x08 j store minus: slli a2, a2, 1 beq a2, a6, mzero j store mzero: li a2, 0x01 store: sw a2, 0x0c(a5) // value j loop</code> </pre> </div></div><br><p>  Ce code a été développé de manière itérative, alors veuillez m'excuser pour l'étrange numérotation des registres.  De plus, j'ai honnêtement étudié l'assembleur RISC-V en utilisant la méthode «compiler un morceau de code dans un fichier objet, démonter, voir».  Il y a quelques années, lorsque j'ai lu un livre sur l'électronique, il parlait de la programmation d'ATTiny en langage assembleur.  "Voici les choses ennuyeuses et la routine, probablement", pensai-je, mais maintenant, apparemment, l' <em>effet d'un magasin suédois est apparu</em> : <del>  casier </del>  processeur assemblé à partir de pièces de rechange, même l'assembleur semble être natif et intéressant.  À la suite de l'exécution de ce code, la LED allumée doit «fonctionner» à gauche ou à droite, selon le bouton enfoncé. </p><br><p>  Nous commençons ... Et rien: toutes les lumières sont allumées, elles ne répondent pas aux boutons.  Connectons-nous via JTAG: programme counter = 0x00000000 - en quelque sorte, tout est triste.  Mais à <code>0x64002000</code> nous avons des registres GPIO disponibles: </p><br><div class="spoiler">  <b class="spoiler_title">GPIOCtrlRegs.scala</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// See LICENSE for license details. package sifive.blocks.devices.gpio object GPIOCtrlRegs { val value = 0x00 val input_en = 0x04 val output_en = 0x08 val port = 0x0c val pullup_en = 0x10 val drive = 0x14 val rise_ie = 0x18 val rise_ip = 0x1c val fall_ie = 0x20 val fall_ip = 0x24 val high_ie = 0x28 val high_ip = 0x2c val low_ie = 0x30 val low_ip = 0x34 val iof_en = 0x38 val iof_sel = 0x3c val out_xor = 0x40 }</span></span></code> </pre> </div></div><br><p>  Essayons de les déplacer manuellement: </p><br><pre> <code class="plaintext hljs">(gdb) set variable *0x64002038=0 (gdb) set variable *0x64002008=0xF (gdb) set variable *0x64002000=0x1 (gdb) set variable *0x64002014=0xF (gdb) set variable *0x6400200c=0x1</code> </pre> <br><p>  Alors ... Une des LED s'est éteinte ... Et sinon <code>0x1</code> , mais <code>0x5</code> ... C'est vrai, maintenant les LED sont allumées à travers une seule.  Il est également devenu clair qu'ils doivent être inversés, mais vous n'avez pas besoin d'écrire dans le registre 0x00 - vous devez lire à partir de là. </p><br><pre> <code class="plaintext hljs">(gdb) x/x 0x64002000 0x64002000: 0x00000030 //    (gdb) x/x 0x64002000 0x64002000: 0x00000020 //   (gdb) x/x 0x64002000 0x64002000: 0x00000010 //   (gdb) x/x 0x64002000 0x64002000: 0x00000000</code> </pre> <br><p>  Les grands registres mappés en mémoire sont mis à jour sans démarrer le processeur, vous ne pouvez pas appuyer sur cont + Ctrl-C à chaque fois - une bagatelle, mais agréable. </p><br><p>  Mais pourquoi ne tournons-nous pas en boucle, mais sommes-nous à <code>$pc=0x0000000</code> ? </p><br><pre> <code class="plaintext hljs">(gdb) x/10i 0x10000 0x10000: addi s1,sp,12 0x10002: fsd ft0,-242(ra) 0x10006: srli a4,a4,0x21 0x10008: addi s0,sp,32 0x1000a: slli t1,t1,0x21 0x1000c: lb zero,-1744(a2) 0x10010: nop 0x10012: addi a0,sp,416 0x10014: c.slli zero,0x0 0x10016: 0x9308</code> </pre> <br><p>  QU'EST-CE QUE LE Pokémon ???  Je n'ai pas écrit de telles instructions, ils m'ont jeté!  Examinons de plus près: </p><br><pre> <code class="plaintext hljs">(gdb) x/10x 0x10000 0x10000: 0xb7270064 0x9305f000 0x13061000 0x93060003 0x10010: 0x13080001 0x93080002 0x23ac0702 0x23a4b700 0x10020: 0x23a0c700 0x23aab700</code> </pre> <br><p>  D'un autre côté, que devrait-il y avoir? </p><br><pre> <code class="plaintext hljs">$ ../../rocket-tools/bin/riscv32-unknown-elf-objdump -d builds/zeowaa-e115/xip.elf builds/zeowaa-e115/xip.elf:   elf32-littleriscv   .text: 00010054 &lt;_start&gt;: 10054: 640027b7 lui a5,0x64002 10058: 00f00593 li a1,15 1005c: 00100613 li a2,1 10060: 03000693 li a3,48 10064: 01000813 li a6,16 10068: 02000893 li a7,32 1006c: 0207ac23 sw zero,56(a5) # 64002038 &lt;__global_pointer$+0x63ff0770&gt; 10070: 00b7a423 sw a1,8(a5) 10074: 00c7a023 sw a2,0(a5) 10078: 00b7aa23 sw a1,20(a5) 1007c: 00d7a223 sw a3,4(a5) ...</code> </pre> <br><p>  Comme vous pouvez le voir, Quartus a honnêtement mis les mêmes mots que dans le fichier d'initialisation, mais a changé leur endianité.  Vous pouvez chercher sur Google pendant longtemps comment le résoudre, mais <em>je suis programmeur</em> , les béquilles sont à nous, donc je vais juste réécrire </p><br><div class="spoiler">  <b class="spoiler_title">BootROM.v</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module BootROM( input wire [10:0] address, input wire clock, input wire me, input wire oe, output wire [31:0] q ); wire [31:0] q_r; rom r( .address(address), .clock(clock), .rden(me), .q(q_r) ); assign q[31:24] = q_r[7:0]; assign q[23:16] = q_r[15:8]; assign q[15:8] = q_r[23:16]; assign q[7:0] = q_r[31:24]; endmodule</code> </pre> </div></div><br><p>  Donc, on collectionne, on commence, ça ne brille pas.   JTAG: <code>$pc</code>   -  ,    = 4,  ,   <code>output_en</code> : <code>set variable *0x64002008=0xF</code> ,  <code>c</code> (continue) —  ! ,      . -,        ,  …        ,   <code>output_en</code>    . </p><br><p>      : </p><br><pre> <code class="plaintext hljs">Total logic elements 17,370 / 114,480 ( 15 % ) Total registers 8357 Total pins 16 / 281 ( 6 % ) Total virtual pins 0 Total memory bits 264,000 / 3,981,312 ( 7 % ) Embedded Multiplier 9-bit elements 4 / 532 ( &lt; 1 % )</code> </pre> <br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  Chisel</a> </p><br><p> <em> ...</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455391/">https://habr.com/ru/post/fr455391/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455377/index.html">Architecture IoT</a></li>
<li><a href="../fr455379/index.html">(Statique) Sélection de conteneurs optimaux dans les programmes C ++</a></li>
<li><a href="../fr455381/index.html">Le support technique de 3CX répond: capturez le trafic SIP sur le serveur PBX</a></li>
<li><a href="../fr455387/index.html">Comprendre l'apprentissage automatique dans Elastic Stack (aka Elasticsearch, aka ELK)</a></li>
<li><a href="../fr455389/index.html">Haxe 4: Quoi de neuf?</a></li>
<li><a href="../fr455393/index.html">Sur l'utilisation des méthodes paramétriques d'estimation spectrale en radar - la méthode MUSIC. Ajout à l'article</a></li>
<li><a href="../fr455397/index.html">Comment nous avons conçu et mis en œuvre le nouveau réseau sur Huawei dans le bureau de Moscou, partie 1</a></li>
<li><a href="../fr455401/index.html">Tcl pour Cisco IOS dans des exemples simples</a></li>
<li><a href="../fr455403/index.html">De cinq cents au jeu des divinités</a></li>
<li><a href="../fr455405/index.html">Comment un petit programme a transformé un petit bureau en une entreprise fédérale avec un bénéfice de plus de 100 millions de roubles / mois</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>