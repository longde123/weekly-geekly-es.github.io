<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåΩ üë≠ üîπ Erstellen des ELF-Dateipackers x86_64 f√ºr Linux üòµ ü•Ä üíù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einleitung 
 Dieser Beitrag beschreibt die Erstellung eines einfachen ausf√ºhrbaren Datei-Packers f√ºr Linux x86_64. Es wird davon ausgegangen, dass der...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen des ELF-Dateipackers x86_64 f√ºr Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483368/"><h2>  Einleitung </h2><br>  Dieser Beitrag beschreibt die Erstellung eines einfachen ausf√ºhrbaren Datei-Packers f√ºr Linux x86_64.  Es wird davon ausgegangen, dass der Leser mit der Programmiersprache C, der Assemblersprache f√ºr die x86_64-Architektur und den Ger√§te-ELF-Dateien vertraut ist.  Um die √úbersichtlichkeit zu gew√§hrleisten, wurde die Fehlerbehandlung aus dem Code im Artikel entfernt und die Implementierungen einiger Funktionen wurden nicht angezeigt. Den vollst√§ndigen Code finden Sie, indem Sie auf die Links zu github ( <a href="https://github.com/cyberfined/cryload">loader</a> , packer) klicken. <br><br>  Die Idee ist folgende: Wir √ºbertragen die ELF-Datei auf den Packer und erhalten am Ausgang eine neue mit der folgenden Struktur: <br><div class="scrollable-table"><table><tbody><tr><td colspan="2">  ELF-Header </td></tr><tr><td colspan="2">  Programmtitel </td></tr><tr><td rowspan="3">  Codesegment </td><td>  Paketierter ELF-Datei-Downloader </td></tr><tr><td>  Gepackte ELF-Datei <br></td></tr><tr><td>  256 Bytes zuf√§lliger Daten </td></tr></tbody></table></div><a name="habracut"></a><br>  F√ºr die Komprimierung wurde entschieden, den Huffman-Algorithmus f√ºr die Verschl√ºsselung zu verwenden - AES-CTR mit einem 256-Bit-Schl√ºssel, n√§mlich die Implementierung von kokke <a href="https://github.com/kokke/tiny-AES-c">tiny-AES-c</a> .  256 Bytes Zufallsdaten werden verwendet, um den AES-Schl√ºssel und den Initialisierungsvektor unter Verwendung eines Pseudozufallszahlengenerators wie folgt zu initialisieren: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; i++) { seed = (<span class="hljs-number"><span class="hljs-number">1103515245</span></span>*seed + <span class="hljs-number"><span class="hljs-number">12345</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span>; key[i] = buf[seed]; }</code> </pre> <br>  Diese Entscheidung wurde durch den Wunsch verursacht, das Reverse Engineering zu erschweren.  Bisher wurde mir klar, dass Komplikationen unbedeutend sind, aber ich habe nicht damit begonnen, sie zu beseitigen, da ich keine Zeit und Energie darauf verwenden wollte. <br><br><h2>  Bootloader </h2><br>  Zun√§chst wird die Arbeit des Bootloaders betrachtet.  Der Loader sollte keine Abh√§ngigkeiten haben, daher m√ºssen alle erforderlichen Funktionen aus der Standard-C-Bibliothek unabh√§ngig geschrieben werden (die Implementierung dieser Funktionen ist per <a href="">Referenz</a> verf√ºgbar).  Es sollte auch positionsunabh√§ngig sein. <br><br><h3>  _Startfunktion </h3><br>  Der Bootloader startet mit der Funktion _start, die argc und argv einfach an main √ºbergibt: <br><br><pre> <code class="plaintext hljs">.extern main .globl _start .text _start: movq (%rsp), %rdi movq %rsp, %rsi addq $8, %rsi call main</code> </pre><br><h3>  Hauptfunktion </h3><br>  Die Datei main.c definiert zun√§chst mehrere externe Variablen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* loader_end; <span class="hljs-comment"><span class="hljs-comment">//    , .   //  ELF . extern size_t payload_size; //   ELF  extern size_t key_seed; //     // -   . extern size_t iv_seed; //     // -    </span></span></code> </pre><br>  Alle von ihnen werden als extern deklariert, um die Position der Zeichen zu finden, die den Variablen (Elf64_Sym) im Packer entsprechen, und um ihre Werte zu √§ndern. <br><br>  Die Hauptfunktion selbst ist recht einfach.  Der erste Schritt ist das Initialisieren von Zeigern auf eine gepackte ELF-Datei, einen 256-Byte-Puffer und auf den oberen Bereich des Stapels.  Dann wird die ELF-Datei entschl√ºsselt und erweitert, dann wird sie mit der Funktion load_elf an der richtigen Stelle im Speicher abgelegt, und schlie√ülich kehrt der Wert des Registers rsp in den urspr√ºnglichen Zustand zur√ºck, und es erfolgt ein Sprung zum Programmeinstiegspunkt: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SET_STACK(sp) __asm__ __volatile__ (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %0, %%rsp"</span></span></span><span class="hljs-meta">::</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta">(sp)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JMP(addr) __asm__ __volatile__ (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmp *%0"</span></span></span><span class="hljs-meta">::</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta">(addr)) int main(int argc, char **argv) { uint8_t *payload = (uint8_t*)&amp;loader_end; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    // ELF  uint8_t *entropy_buf = payload + payload_size; //   256- //  void *rsp = argv-1; //     struct AES_ctx ctx; AES_init_ctx_iv(&amp;ctx, entropy_buf, key_seed, iv_seed); //  AES AES_CTR_xcrypt_buffer(&amp;ctx, payload, payload_size); //  ELF memset(&amp;ctx, 0, sizeof(ctx)); //   AES size_t decoded_payload_size; //  ELF char *decoded_payload = huffman_decode((char*)payload, payload_size, &amp;decoded_payload_size); //     ELF  , //   ET_EXEC  NULL. void *load_addr = elf_load_addr(rsp, decoded_payload, decoded_payload_size); load_addr = load_elf(load_addr, decoded_payload); //  ELF  , //    //  . memset(decoded_payload, 0, decoded_payload_size); //   ELF munmap(decoded_payload, decoded_payload_size); //   //    //  ELF     AES AES_init_ctx_iv(&amp;ctx, entropy_buf, key_seed, iv_seed); AES_CTR_xcrypt_buffer(&amp;ctx, payload, payload_size); memset(&amp;ctx, 0, sizeof(ctx)); SET_STACK(rsp); //    JMP(load_addr); //       }</span></span></span></span></code> </pre><br>  Das Zur√ºcksetzen des AES-Status und der dekomprimierten ELF-Datei erfolgt aus Sicherheitsgr√ºnden, sodass der Schl√ºssel und die entschl√ºsselten Daten nur f√ºr die Dauer der Verwendung im Speicher gespeichert werden. <br><br>  Als n√§chstes betrachten wir die Implementierung einiger Funktionen. <br><br><h3>  load_elf </h3><br>  Ich habe diese Funktion vom github-Benutzer mit dem Spitznamen bediger aus seinem userlandexec-Repository genommen und finalisiert, da die urspr√ºngliche Funktion bei Dateien wie ET_DYN abgest√ºrzt ist.  Der Fehler trat auf, weil der Wert des ersten Arguments des mmap-Systemaufrufs auf NULL gesetzt war und die Adresse ziemlich nahe am Hauptprogramm zur√ºckgegeben wurde. Bei nachfolgenden Aufrufen von mmap und beim Kopieren von Segmenten an die von ihnen zur√ºckgegebenen Adressen wurde der Code des Hauptprogramms √ºberschrieben, und es trat ein Fehler auf.  Aus diesem Grund wurde beschlossen, die Startadresse als Parameter zur Funktion load_elf hinzuzuf√ºgen.  Die Funktion selbst durchl√§uft alle Programm-Header, weist den PT_LOAD-Segmenten der ELF-Datei Speicher zu (seine Nummer muss ein Vielfaches der Seitengr√∂√üe sein), kopiert deren Inhalt in die zugewiesenen Speicherbereiche und legt die entsprechenden Lese-, Schreib- und Ausf√ºhrungsrechte f√ºr diese Bereiche fest: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      #define PAGEUP(x) (((unsigned long)x + 4095)&amp;(~4095)) //      #define PAGEDOWN(x) ((unsigned long)x&amp;(~4095)) void* load_elf(void *load_addr, void *mapped) { Elf64_Ehdr *ehdr = mapped; Elf64_Phdr *phdr = mapped + ehdr-&gt;e_phoff; void *text_segment = NULL; unsigned long initial_vaddr = 0; unsigned long brk_addr = 0; for(size_t i = 0; i &lt; ehdr-&gt;e_phnum; i++, phdr++) { unsigned long rounded_len, k; void *segment; //   PT_LOAD,    if(phdr-&gt;p_type != PT_LOAD) continue; if(text_segment != 0 &amp;&amp; ehdr-&gt;e_type == ET_DYN) { //  ET_DYN phdr-&gt;p_vaddr    , //        //    ,      //     load_addr = text_segment + phdr-&gt;p_vaddr - initial_vaddr; load_addr = (void*)PAGEDOWN(load_addr); } else if(ehdr-&gt;e_type == ET_EXEC) { //  ET_EXEC phdr-&gt;p_vaddr     load_addr = (void*)PAGEDOWN(phdr-&gt;p_vaddr); } //        rounded_len = phdr-&gt;p_memsz + (phdr-&gt;p_vaddr % 4096); rounded_len = PAGEUP(rounded_len); //        segment = mmap(load_addr, rounded_len, PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0); if(ehdr-&gt;e_type == ET_EXEC) load_addr = (void*)phdr-&gt;p_vaddr; else load_addr = segment + (phdr-&gt;p_vaddr % 4096); //         memcpy(load_addr, mapped + phdr-&gt;p_offset, phdr-&gt;p_filesz); if(!text_segment) { text_segment = segment; initial_vaddr = phdr-&gt;p_vaddr; } unsigned int protflags = 0; if(phdr-&gt;p_flags &amp; PF_R) protflags |= PROT_READ; if(phdr-&gt;p_flags &amp; PF_W) protflags |= PROT_WRITE; if(phdr-&gt;p_flags &amp; PF_X) protflags |= PROT_EXEC; mprotect(segment, rounded_len, protflags); //   // , ,  k = phdr-&gt;p_vaddr + phdr-&gt;p_memsz; if(k &gt; brk_addr) brk_addr = k; } if (ehdr-&gt;e_type == ET_EXEC) { brk(PAGEUP(brk_addr)); //  ET_EXEC ehdr-&gt;e_entry     load_addr = (void*)ehdr-&gt;e_entry; } else { //  ET_DYN ehdr-&gt;e_entry    , //           load_addr = (void*)ehdr + ehdr-&gt;e_entry; } return load_addr; //       }</span></span></code> </pre><br><h3>  elf_load_addr </h3><br>  Diese Funktion f√ºr ET_EXEC-ELF-Dateien gibt NULL zur√ºck, da sich Dateien dieses Typs an den darin angegebenen Adressen befinden sollten.  F√ºr ET_DYN-Dateien werden zuerst die Adresse berechnet, die der Differenz zwischen der Basisadresse des Hauptprogramms (d. H. Dem Bootloader), der zum Platzieren der ELF im Speicher erforderlichen Speichermenge und 4096, 4096 - der L√ºcke, die erforderlich ist, um die ELF-Datei nicht direkt neben dem Hauptprogramm zu platzieren.  Nach der Berechnung dieser Adresse wird gepr√ºft, ob sich der Speicherbereich von der angegebenen Adresse bis zur Basisadresse des Hauptprogramms mit dem Bereich vom Anfang der entpackten ELF-Datei bis zu ihrem Ende √ºberschneidet.  Im Falle einer √úberschneidung wird die Adresse zur√ºckgegeben, die der Differenz zwischen der Startadresse des entpackten ELF und der zum Platzieren erforderlichen Speichermenge entspricht, andernfalls wird die zuvor berechnete Adresse zur√ºckgegeben. <br><br>  Die Basisadresse des Programms wird ermittelt, indem die Adresse der Programmheader aus dem Hilfsvektor (ELF-Hilfsvektor) extrahiert wird, der sich hinter den Zeigern auf die Umgebungsvariablen im Stapel befindet, und die Gr√∂√üe des ELF-Headers davon subtrahiert wird: <br><br><pre> <code class="plaintext hljs">      ---------------------------------------------------------------------------    -&gt; [ argc ] 8 [ argv[0] ] 8 [ argv[1] ] 8 [ argv[..] ] 8 * x [ argv[n ‚Äì 1] ] 8 [ argv[n] ] 8 (= NULL) [ envp[0] ] 8 [ envp[1] ] 8 [ envp[..] ] 8 [ envp[term] ] 8 (= NULL) [ auxv[0] (Elf64_auxv_t) ] 16 [ auxv[1] (Elf64_auxv_t) ] 16 [ auxv[..] (Elf64_auxv_t) ] 16 [ auxv[term] (Elf64_auxv_t) ] 16 (= AT_NULL) [  ] 0 - 16 [    ] &gt;= 0 [   ] &gt;= 0 [   ] 8 (= NULL) &lt;    &gt; 0 ---------------------------------------------------------------------------</code> </pre><br>  Die Struktur, mit der jedes Element des Hilfsvektors beschrieben wird, hat die Form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> a_type; <span class="hljs-comment"><span class="hljs-comment">//   union { uint64_t a_val; //  } a_un; } Elf64_auxv_t;</span></span></code> </pre><br>  Einer der g√ºltigen Werte f√ºr a_type ist AT_PHDR. A_val zeigt dann auf die Programmheader.  Das Folgende ist der Code f√ºr die Funktion elf_load_addr: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf_base_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *rsp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *base_addr = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> argc = *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)rsp; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **envp = rsp + (argc+<span class="hljs-number"><span class="hljs-number">2</span></span>)*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    //   while(*envp++); //        Elf64_auxv_t *aux = (Elf64_auxv_t*)envp; //    //  for(; aux-&gt;a_type != AT_NULL; aux++) { //        if(aux-&gt;a_type == AT_PHDR) { //   ELF ,     //      base_addr = (void*)(aux-&gt;a_un.a_val ‚Äì sizeof(Elf64_Ehdr)); break; } } return base_addr; } size_t elf_memory_size(void *mapped) { Elf64_Ehdr *ehdr = mapped; Elf64_Phdr *phdr = mapped + ehdr-&gt;e_phoff; size_t mem_size = 0, segment_len; for(size_t i = 0; i &lt; ehdr-&gt;e_phnum; i++, phdr++) { if(phdr-&gt;p_type != PT_LOAD) continue; segment_len = phdr-&gt;p_memsz + (phdr-&gt;p_vaddr % 4096); mem_size += PAGEUP(segment_len); } return mem_size; } void* elf_load_addr(void *rsp, void *mapped, size_t mapped_size) { Elf64_Ehdr *ehdr = mapped; if(ehdr-&gt;e_type == ET_EXEC) return NULL; size_t mem_size = elf_memory_size(mapped) + 0x1000; void *load_addr = elf_base_addr(rsp); if(mapped &lt; load_addr &amp;&amp; mapped + mapped_size &gt; load_addr - mem_size) load_addr = mapped; return load_addr - mem_size; }</span></span></code> </pre><br><h3>  Linker-Skript-Beschreibung </h3><br>  Es ist erforderlich, die Zeichen f√ºr die oben beschriebenen externen Variablen zu definieren und sicherzustellen, dass sich der Code und die Ladedaten nach dem Kompilieren im selben Textabschnitt befinden.  Dies ist erforderlich, um den Maschinencode des Ladeger√§ts bequem zu extrahieren, indem der Inhalt dieses Abschnitts einfach aus der Datei ausgeschnitten wird.  Um diese Ziele zu erreichen, wurde das folgende Linker-Skript geschrieben: <br><br><pre> <code class="plaintext hljs">ENTRY(_start) SECTIONS { . = 0; .text :{ *(.text) *(.text.startup) *(.data) *(.rodata) payload_size = .; QUAD(0) key_seed = .; QUAD(0) iv_seed = .; QUAD(0) loader_end = .; } }</code> </pre><br>  Es ist erw√§hnenswert, dass QUAD (0) 8 Bytes mit Nullen platziert, anstatt bestimmte Werte durch den Packer zu ersetzen.  Um den Maschinencode auszuschneiden, wurde ein kleines Dienstprogramm geschrieben, das auch die Verschiebung des Einstiegspunkts zum Bootloader vom Start des Bootloaders an, den Versatz der Werte von payload_size, key_seed und iv_seed vom Start des Bootloaders an an den Anfang des Maschinencodes schreibt.  Den Code f√ºr dieses Dienstprogramm finden Sie <a href="">hier</a> .  Damit ist die Bootloader-Beschreibung beendet. <br><br><h2>  Direkter Packer </h2><br>  Betrachten Sie die Hauptfunktion des Packers.  Es werden zwei Befehlszeilenargumente verwendet: Der Name der Eingabedatei lautet argv [1] und der Name der Ausgabedatei lautet argv [2].  Zun√§chst wird die Eingabedatei im Speicher angezeigt und auf Kompatibilit√§t mit dem Packer √ºberpr√ºft.  Der Packer funktioniert nur mit zwei Arten von ELF-Dateien: ET_EXEC und ET_DYN und nur mit statisch kompilierten.  Der Grund f√ºr die Einf√ºhrung dieser Einschr√§nkung war die Tatsache, dass verschiedene Linux-Systeme unterschiedliche Versionen von gemeinsam genutzten Bibliotheken haben, d. H.  Die Wahrscheinlichkeit, dass ein dynamisch kompiliertes Programm nicht auf einem anderen System als dem √ºbergeordneten System gestartet wird, ist sehr hoch.  Der entsprechende Code in der Hauptfunktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mapped_size; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *mapped = map_file(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>], &amp;mapped_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(check_elf(mapped) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Wenn die Eingabedatei danach die Kompatibilit√§tspr√ºfung besteht, wird sie komprimiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> comp_size; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *comp_buf = huffman_encode(mapped, &amp;comp_size);</code> </pre><br>  Als n√§chstes wird der AES-Status generiert und die komprimierte ELF-Datei wird verschl√ºsselt.  Der Zustand von AES wird durch die folgende Struktur bestimmt: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AES_ENTROPY_BUFSIZE 256 typedef struct { uint8_t entropy_buf[AES_ENTROPY_BUFSIZE]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 256-  size_t key_seed; //      size_t iv_seed; //       struct AES_ctx ctx; //  AES-CTR } AES_state_t;</span></span></span></span></code> </pre><br>  Entsprechender Code in main: <br><br><pre> <code class="cpp hljs">AES_state_t aes_st; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; AES_ENTROPY_BUFSIZE; i++) state.entropy_buf[i] = rand() % <span class="hljs-number"><span class="hljs-number">256</span></span>; state.key_seed = rand(); state.iv_seed = rand(); AES_init_ctx_iv(&amp;state.ctx, state.entropy_buf, state.key_seed, state.iv_seed); AES_CTR_xcrypt_buffer(&amp;aes_st.ctx, comp_buf, comp_size);</code> </pre><br>  Danach wird die Struktur, in der Informationen zum Bootloader gespeichert sind, initialisiert. Die Werte f√ºr payload_size, key_seed und iv_seed im Bootloader werden in die Werte ge√§ndert, die im vorherigen Schritt generiert wurden. Anschlie√üend wird der AES-Status zur√ºckgesetzt.  Informationen zum Bootloader sind in der folgenden Struktur gespeichert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *loader_begin; <span class="hljs-comment"><span class="hljs-comment">//      size_t entry_offset; //       size_t *payload_size_patch_offset; //     // ELF    size_t *key_seed_pacth_offset; //     //       size_t *iv_seed_patch_offset; //     //     //    size_t loader_size; //     } loader_t;</span></span></code> </pre><br>  Entsprechender Code in main: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">loader_t</span></span> loader; init_loader(&amp;loader); *loader.payload_size_patch_offset = comp_size; *loader.key_seed_pacth_offset = aes_st.key_seed; *loader.iv_seed_patch_offset = aes_st.iv_seed; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;aes_st.ctx, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(aes_st.ctx));</code> </pre><br>  Im letzten Teil erstellen wir eine Ausgabedatei, schreiben einen ELF-Header, einen Programm-Header, einen Loader-Code, eine komprimierte und verschl√ºsselte ELF-Datei und einen 256-Byte-Puffer hinein: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> out_fd = open(argv[<span class="hljs-number"><span class="hljs-number">2</span></span>], O_WRONLY | O_CREAT | O_TRUNC, <span class="hljs-number"><span class="hljs-number">0755</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  //   write_elf_ehdr(out_fd, &amp;loader); //  ELF  write_elf_phdr(out_fd, &amp;loader, comp_size); //    write(out_fd, loader.loader_begin, loader.loader_size); //   write(out_fd, comp_buf, comp_size); //     ELF write(out_fd, aes_st.entropy_buf, AES_ENTROPY_BUFSIZE); //  // 256- </span></span></code> </pre><br>  Der Hauptcode des Packers endet hier, dann werden die folgenden Funktionen betrachtet: die Funktion zum Initialisieren von Informationen √ºber den Bootloader, die Funktion zum Schreiben des ELF-Headers und die Funktion zum Schreiben des Programm-Headers. <br><br><h3>  Bootloader-Informationen werden initialisiert </h3><br>  Der Loader-Maschinencode wird mithilfe des folgenden einfachen Codes in die ausf√ºhrbare Packer-Datei eingebettet: <br><br><pre> <code class="plaintext hljs">.data .globl _loader_begin .globl _loader_end _loader_begin: .incbin "loader" _loader_end:</code> </pre><br>  Um die Adresse im Speicher zu ermitteln, werden die folgenden Variablen in der Datei main.c deklariert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* _loader_begin; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* _loader_end;</code> </pre><br>  Betrachten Sie als N√§chstes die Funktion init_loader.  Zun√§chst werden die folgenden Werte sequentiell eingelesen: Der Offset des Einstiegspunkts vom Start des Bootloaders (entry_offset), die Verschiebung der Gr√∂√üe der gepackten ELF-Datei vom Start des Bootloaders (payload_size_patch_offset), die Verschiebung des Anfangswerts des Generators f√ºr den Schl√ºssel vom Start des Bootloaders (key_seed_offset) Initialisierung ab dem Start des Bootloaders (iv_seed_patch_offset).  Dann wird die Loader-Adresse zu den letzten drei Werten hinzugef√ºgt. Wenn also Zeiger dereferenziert und ihnen Werte zugewiesen werden, werden die im Layout zugewiesenen Nullen (QUAD (0)) durch die ben√∂tigten Werte ersetzt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_loader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">loader_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *loader_begin = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)&amp;_loader_begin; l-&gt;entry_offset = *(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>*)loader_begin; loader_begin += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>); l-&gt;payload_size_patch_offset = *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)loader_begin; loader_begin += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*); l-&gt;key_seed_pacth_offset = *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)loader_begin; loader_begin += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*); l-&gt;iv_seed_patch_offset = *(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)loader_begin; loader_begin += <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*); l-&gt;payload_size_patch_offset = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)l-&gt;payload_size_patch_offset + loader_begin; l-&gt;key_seed_pacth_offset = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)l-&gt;key_seed_pacth_offset + loader_begin; l-&gt;iv_seed_patch_offset = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)l-&gt;iv_seed_patch_offset + loader_begin; l-&gt;loader_begin = loader_begin; l-&gt;loader_size = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)&amp;_loader_end - loader_begin; }</code> </pre><br><br><h3>  write_elf_ehdr </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_elf_ehdr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">loader_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *loader)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ELF  Elf64_Ehdr ehdr; memset(ehdr.e_ident, 0, sizeof(ehdr.e_ident)); memcpy(ehdr.e_ident, ELFMAG, SELFMAG); ehdr.e_ident[EI_CLASS] = ELFCLASS64; ehdr.e_ident[EI_DATA] = ELFDATA2LSB; ehdr.e_ident[EI_VERSION] = EV_CURRENT; ehdr.e_ident[EI_OSABI] = ELFOSABI_NONE; ehdr.e_type = ET_DYN; ehdr.e_machine = EM_X86_64; ehdr.e_version = EV_CURRENT; ehdr.e_entry = sizeof(Elf64_Ehdr) + sizeof(Elf64_Phdr) + loader-&gt;entry_offset; ehdr.e_phoff = sizeof(Elf64_Ehdr); ehdr.e_shoff = 0; ehdr.e_flags = 0; ehdr.e_ehsize = sizeof(Elf64_Ehdr); ehdr.e_phentsize = sizeof(Elf64_Phdr); ehdr.e_phnum = 1; ehdr.e_shentsize = sizeof(Elf64_Shdr); ehdr.e_shnum = 0; ehdr.e_shstrndx = 0; write(fd, &amp;ehdr, sizeof(ehdr)); //     return 0; }</span></span></code> </pre><br>  Hier erfolgt die Standardinitialisierung des ELF-Headers und das anschlie√üende Schreiben in eine Datei. Beachten Sie nur, dass in ET_DYN-ELF-Dateien das vom ersten Programm-Header beschriebene Segment nicht nur den ausf√ºhrbaren Code, sondern auch den ELF-Header und alle Header enth√§lt Programme.  Daher sollte sein Versatz von Anfang an gleich Null sein, die Gr√∂√üe sollte die Summe der Gr√∂√üe des ELF-Headers, aller Programmheader und des ausf√ºhrbaren Codes sein, und der Eintrittspunkt wird als die Summe der Gr√∂√üe des ELF-Headers, der Gr√∂√üe aller Programmheader und des Versatzes von Anfang an des ausf√ºhrbaren Codes bestimmt. <br><br><h3>  write_elf_phdr </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_elf_phdr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">loader_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *loader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> payload_size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    Elf64_Phdr phdr; phdr.p_type = PT_LOAD; phdr.p_offset = 0; phdr.p_vaddr = 0; phdr.p_paddr = 0; phdr.p_filesz = sizeof(Elf64_Ehdr) + sizeof(Elf64_Phdr) + loader-&gt;loader_size + payload_size + AES_ENTROPY_BUFSIZE; phdr.p_memsz = phdr.p_filesz; phdr.p_flags = PF_R | PF_W | PF_X; phdr.p_align = 0x1000; write(fd, &amp;phdr, sizeof(phdr)); //      }</span></span></code> </pre><br>  Hier wird der Programmkopf initialisiert und dann in eine Datei geschrieben.  Beachten Sie den Versatz zum Dateianfang und die Gr√∂√üe des durch den Programmkopf beschriebenen Segments.  Wie im vorherigen Absatz beschrieben, enth√§lt das von diesem Header beschriebene Segment nicht nur den ausf√ºhrbaren Code, sondern auch den ELF-Header und den Programm-Header.  Wir machen das Segment auch mit ausf√ºhrbarem Code zum Schreiben zug√§nglich. Dies liegt an der Tatsache, dass die im Bootloader verwendete AES-Implementierung Daten ‚Äûan Ort und Stelle‚Äú verschl√ºsselt und entschl√ºsselt. <br><br><h2>  Einige Fakten √ºber die Arbeit des Packers </h2><br>  W√§hrend des Tests wurde festgestellt, dass die mit glibc statisch kompilierten Programme beim Start auf segfault gehen. <br><br><pre>  movq% fs: 0x28,% rax </pre><br>  Ich konnte nicht herausfinden, warum dies passiert. Ich freue mich, wenn Sie Informationen zu diesem Thema weitergeben.  Anstelle von glibc kann auch musl-libc verwendet werden, alles funktioniert einwandfrei.  Au√üerdem wurde der Packer mit statisch kompilierten Golang-Programmen getestet, beispielsweise einem http-Server.  F√ºr vollst√§ndige statische Abst√ºrze von Golang-Programmen m√ºssen die folgenden Flags verwendet werden: <br><br><pre>  CGO_ENABLED = 0 go build -a -ldflags '-extldflags "-static"'. </pre><br>  Das letzte, mit dem der Packer getestet wurde, waren ET_DYN-ELF-Dateien ohne dynamischen Linker.  Wenn Sie mit diesen Dateien arbeiten, schl√§gt die Funktion elf_load_addr m√∂glicherweise fehl.  In der Praxis kann es vom Bootloader getrennt werden und eine feste Adresse verwenden, zum Beispiel 0x10000. <br><br><h2>  Fazit </h2><br>  Dieser Packer ist offensichtlich nicht sinnvoll f√ºr den vorgesehenen Zweck zu verwenden, da die von ihm gesch√ºtzten Dateien ziemlich leicht entschl√ºsselt werden k√∂nnen.  Ziel dieses Projekts war es, die Arbeit mit ELF-Dateien besser zu beherrschen, sie zu generieren und sich auf die Erstellung eines vollst√§ndigeren Packers vorzubereiten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483368/">https://habr.com/ru/post/de483368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483354/index.html">Fluch des zweiten Monats</a></li>
<li><a href="../de483356/index.html">Community-Z√§hlung "Was?" Wo? Wann? ‚Äú(ChGK) oder wie viele Handshakes vor einem Freund?</a></li>
<li><a href="../de483360/index.html">Elektrische Antriebssteuerung. Amateur Erfahrung</a></li>
<li><a href="../de483364/index.html">Sie k√∂nnen Code bei der Arbeit schreiben, um Ihre Freizeit zu sparen.</a></li>
<li><a href="../de483366/index.html">Internet History: Vernetzung</a></li>
<li><a href="../de483372/index.html">So trainieren Sie ein DeepPavlov-neuronales Netzwerk auf einem Laptop mit einer GPU</a></li>
<li><a href="../de483374/index.html">REST-API-Empfehlungen - Beispiele f√ºr den Entwurf von Webdiensten in Java und Spring</a></li>
<li><a href="../de483376/index.html">Auf der Oberfl√§che eines Schwarzen Lochs</a></li>
<li><a href="../de483378/index.html">Typensicheres Arbeiten mit Registern ohne Overhead in C ++ 17: Wertebasierte Metaprogrammierung</a></li>
<li><a href="../de483380/index.html">Microservices: Wie wird der Vertrag eingehalten?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>