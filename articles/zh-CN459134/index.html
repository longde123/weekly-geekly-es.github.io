<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📏 Ⓜ️ ☕️ 使用BDD的经验 🏇🏼 🏬 🐴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大约七年前，Dan North在他的文章中描述了BDD方法的实际应用，它使您可以通过建立内部通信来使开发过程更易于理解和管理。 业界每天都对这种方法越来越感兴趣，其目的是使标准团队进行有效的互动，例如“分析-开发-测试”。 


 但是，现在只有一小部分公司决定使用BDD。 怎么了 


 所以，让...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用BDD的经验</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/459134/"><p><img src="https://habrastorage.org/webt/oo/ze/t3/oozet3hyz1ptfa9q11me-mgcgh4.jpeg"></p><br><p> 大约七年前，Dan North在他的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章中</a>描述了BDD方法的实际应用，它使您可以通过建立内部通信来使开发过程更易于理解和管理。 业界每天都对这种方法越来越感兴趣，其目的是使标准团队进行有效的互动，例如“分析-开发-测试”。 </p><br><p> 但是，现在只有一小部分公司决定使用BDD。 怎么了 </p><a name="habracut"></a><br><p> 所以，让我们弄清楚。  BDD（行为驱动开发）是一种与TDD（测试驱动开发-“通过测试开发”）紧密相关的灵活方法。 根据经验，即使是经验丰富的测试人员也常常看不到这些方法之间的差异。 的确，乍看之下很难隔离：这两种方法都涉及在开发阶段开始之前编写文档和测试。 区别在于：在BDD中，为了描述测试，您需要使用每个项目参与者都可以理解的自然语言，以便实际上将问题说明，测试和文档组合在一起。 换句话说，先定义DSL（面向特定主题的语言），然后创建一组标准的受限短语来描述必要元素的行为。 然后，在他们的帮助下，使用新功能开发了一个方案，每个人都可以理解。 </p><br><p> 让我们看一下区别，它将变得显而易见： </p><br><p><img src="https://habrastorage.org/webt/fg/s3/_e/fgs3_e71mp3t_ynlkbvbh-d6olw.png"></p><br><p> 我们将讨论这个示例，但首先，让我们看一下当前与非零相关性的所有方法。 </p><br><h2 id="sravnim-neskolko-metodologiy"> 比较几种方法 </h2><br><p> 下图显示了三种方法的比较：TDD，TLD（测试最新开发）和BDD： </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lv/xz/st/lvxzstichnozebdmzcfl7wncxt8.png"></div><br><ul><li>当我们按照BDD方法进行工作时，自动测试和起草规范会伴随软件开发周期的每个阶段，从而确保自动测试和文档的持续相关性。 </li><li>  TDD和ATDD（验收测试）方法在一个图中合并在一起，因为 写在分析阶段。 如上所述，TDD基于在开发功能之前编写测试。 开发人员必须编写测试才能编写测试功能。 </li><li>  TLD（测试最新开发）包括在功能实施后进行的测试。 </li><li>  BDD是通用的，可以包含在开发的任何阶段。 </li></ul><br><p> 第二张图显示了开发人员在编写脚本时的参与程度。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/b_/ao/uqb_aoyi3-7jdr651-sdk6nmmzc.png"></div><br><ul><li> 在BDD中，团队的任何成员都可以在任何阶段连接到测试，例如分析师，业务用户，开发人员和测试人员，因为测试对于流程中的所有参与者都是清楚的。 </li><li>  BDD也很有用，因为您不需要花费大量时间来编写各种文档。 经典的开发方案至少需要通常由不同人员编写的规范和测试脚本。 在BDD中，规范既是测试案例，又是自动测试。 测试人员不需要编写单独的测试文档-分析师已经为他们完成了这些工作，他们从自然语言构造中编写了规范（团队的任何成员都可以理解和理解）。 </li></ul><br><p> 毫无疑问，BDD是实现产品质量的好工具。 测试和文档编写速度更快。 对于一家企业来说，由于自然语言构造使项目变得更加透明，而自然语言构造对于任何人来说都是可以理解的，而无需编程。 </p><br><p> 这是关于优点。 然而，正如已经说过的，尽管有很多优点，但是很少有人采用这种方法。 </p><br><h2 id="bdd-vsem-horosh-no-pochemu-ego-ne-ispolzuyut">  BDD对所有人都有好处，但是为什么不使用它呢？ </h2><br><p> 答案很简单：它既长又昂贵。 大多数IT公司都同意这一说法。 首先，我们也不例外。  BDD带来了不便，即使它需要在制定要求的阶段已经由测试专家参与。 </p><br><p>  BDD颠倒了经典的开发指南（TLD）。 由于执行困难，因此执行不佳。 开发周期正在延长。 </p><br><p>  BDD无疑是一种获得质量的方法。 但是并不是每个人都愿意为此花费时间和专家。 </p><br><p> 但是，如果我仍然想实现BDD怎么办？ </p><br><p> 您可以尝试使用现成的框架。 例如黄瓜，南瓜，Yulup。 </p><br><p>  BDD复杂性的主要问题不在过程中，而是在实现和现有工具中。 以WEB为例，开发公司信息系统。 通过Web实现，我们遇到了一个WebDriver，它是当前用于自动运行在Web浏览器中的应用程序的标准。 他有很多机会。 为了考虑页面元素的各种自定义，您需要提供用于访问它们的选项。 在这里，为了促进测试的开发，需要使用各种库（例如Selenide等），它会创建您自己需要了解的生态系统。 要使用WebDriver，您需要程序员或测试员自动化，因为 一切都使用代码和狡猾的设计来实现。 </p><br><h2 id="nachalo-raboty-s-bdd-freymvorkom---slozhno-i-dolgo">  BDD框架的入门既困难又耗时。 </h2><br><p> 我们的重点是一种称为仪表的仪器。 这是一个灵活且轻量级的框架，在免费许可下分发。 坦白说，我们并未真正研究替代方案，因为 我们的客户积极要求使用仪表。 </p><br><p> 在仪表中，测试以规范文件（扩展名为.spec的文件）编写。 规范包含以自然语言编写的测试步骤。 这些步骤以编程语言（我们使用Java编程语言）实现。 在执行步骤时，在脚本和实现文件的名称以及脚本的实现方法和步骤的名称中都必须遵守命名约定，这一点很重要。 该工具的另一个灵活性是步骤可以具有参数。 </p><br><p> 仪表使我们能够使用BDD的好处。 但是，我们仍然遇到实施复杂性的问题：工具和流程实施的问题。 </p><br><p> 事实证明，测试人员在早期阶段的参与会对最终结果产生不良影响。 开发测试的时间增加。 使用任何框架都需要测试人员付出巨大的努力，而测试人员无疑必须具有良好的编程命令。 最初，使用脚本的过程如下：分析师将测试告诉测试人员，然后技术编写者将其写下来。 当测试人员处理软件实现时，被测试功能的含义发生了变化。 这会影响入口点的分隔，应该将它分隔为一个，这是因为该过程被划分为一个“正常”过程，我只是想离开该过程。 即 切入点被分割了，沟通层出不穷，测试人员全心投入测试的实施，技术作家以他自己的方式理解，分析师重写了他的坞站并改变了主意，开发人员进入了“他的世界”）。 </p><br><p> 测试人员在代码上花费了大量时间。 但是，同一位测试人员仍然必须考虑在页面上搜索元素。 这种情况使人想起了著名的儿童游戏：“被破坏的电话”。 发生崩溃。 我们决定：只有分析人员可以编写测试，BDD才能工作。 有必要降低编写测试的复杂度，以简化测试。 但是为此，您需要大大简化测试界面。 测试工具，与所有方法和库一起执行的过程应该更简单。 </p><br><p> 首先，测试人员的工作如下所示： </p><br><ol><li>  <em>检查文件（如果有）；</em> </li><li> 拟定清单； </li><li> 临时测试 </li><li> 制定测试计划； </li><li>  <em>完善分析师的世界观；</em> </li><li>  <em>开发人员完善世界的图片；</em> </li><li>  <em>如果一切都一起发展，请在进行测试的同时编写测试文档；</em> </li><li> 等待修复错误，测试错误； </li><li>  <em>页面说明，控件，使用Web-Driver搜索页面上的元素。</em>  <em>搜索测试系统中已经实现的内容；</em> </li><li> 编写测试逻辑； </li><li> 放行 </li><li> 支持错误/回归错误； </li><li>  <em>规格更新；</em> </li><li> 修正错误 </li><li>  <em>自动测试更新，更新大量已更改的控件；</em> </li><li> 放行 </li><li>  ... <br>  <em>斜体</em>项<em>（1、5、6、7、9、13、15</em> ）导致时间成本。 它们可以并且应该被优化。 </li></ol><br><p> 此列表在开发流程图中作了简要说明： </p><br><img src="https://habrastorage.org/webt/si/7y/m8/si7ym8xktulzmpgsvtsogu-5bfe.png"><br><p> 我们公司专门从事具有Web界面实现的项目。 基于此，我们使用Web驱动程序工具与Web浏览器进行交互。 </p><br><p> 实际上，Selenium Web Driver是标准，它用于描述任何框架上的Web对象，包括Gauge，jUnit，Masquerade库等。 他在执行不同任务时具有很大的灵活性，这会在局部类型的问题上造成过多的工作量。 我们需要找到一种降低复杂性的解决方案。 </p><br><p> 例如，让我们在图中显示Selenium Web Driver，Gauge框架，Masquerade库和Java编程语言之间的关系。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ki/md/ib/kimdibdn1wmo8au4ubirnrbwsta.png"></div><br><p> 在此方案中，可以使用jUnit，TestNG或任何其他替代BDD框架的方法，根据需要，可以使用任何捆绑软件。 硒和化装舞会依然存在，可以更改编程语言。 </p><br><h2 id="uskorenie-processa-napisaniya-koda--podklyuchenie-masquerade"> 加快代码编写速度-连接化装舞会 </h2><br><p> 我们公司正在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CUBA平台</a>上开发。 特别是针对该平台，开发了一种用于自动测试的工具： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Masquerade</a>是一个库，提供了简洁，方便的API，用于在使用WebDriver实施测试时使用代码。 该库可在Selenium Web Driver上使用，是selenide和任何框架的朋友。 </p><br><p> 在CUBA项目中，网页的每个元素都包含cuba-id，但不会更改。  CUBA使用一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">组件</a>方法，而Masquerade库简化了与网页元素的交互。 该库可以以更简单的方式对使用CUBA实现的网页元素执行操作。 因此，在页面上搜索元素时，无需像以前那样将笨重的结构与XPath结合使用： </p><br><pre><code class="plaintext hljs">$(new By.ByXPath("//*/div/div[2]/div/div[2]/div/div/div[3]/div/div/div[3).click();</code> </pre> <br><p> 或更简单的Java构造，但是仍然很麻烦： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String cssClass, String caption)</span></span></span><span class="hljs-function"> </span></span>{ $(By.cssSelector(cssClass) .$(byText(caption)) .closest(<span class="hljs-string"><span class="hljs-string">".v-button"</span></span>) .click(); }</code> </pre> <br><p> 连接Masquerade库后，嵌入式控件的描述看起来很简单并且易于访问。 您甚至不必在页面上查找控件，因为 他已经在项目中拥有它。 这是应用程序中授权表单的按钮描述示例： </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7m/up/og/7mupog9cgkybpr5of9kctzreplg.png"></div><br><p> 在页面代码中，我们看到一个清晰可辨的元素<code>cuba-id=”loginButton”</code> </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/8e/v-/ey8ev-vzpxdicfy1uohlen2eahg.png"></div><br><p> 让我们使用Masquerade库描述按钮： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"WebHBoxLayout"</span></span>, <span class="hljs-string"><span class="hljs-string">"loginButton"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button loginButton;</code> </pre> <br><p>  jUnit框架上的一个简单测试实现是在每次测试之前运行的授权块： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginAdm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Tests loginTest = _$(Tests.class); loginTest.login(); }</code> </pre> <br><p> 在登录方法的主体中，以下代码： </p><br><pre> <code class="java hljs">LoginWindow loginWindow = _$(LoginWindow.class); assertNotNull(loginWindow.getLoginField()); loginWindow.getLoginField() .shouldBe(EDITABLE) .shouldBe(ENABLED); loginWindow.loginField.setValue(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>); loginWindow.passwordField.setValue(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>); loginWindow.rememberMeCheckBox.setChecked(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); loginWindow.loginButton().click();</code> </pre> <br><p> 最重要的是我们如何描述页面，如何引用元素。  LoginWindow页面的描述： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginWindow</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Composite</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginWindow</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"loginField"</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TextField loginField; <span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"passwordField"</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PasswordField passwordField; <span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"rememberMeCheckBox"</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CheckBox rememberMeCheckBox; <span class="hljs-meta"><span class="hljs-meta">@Wire</span></span>(path = {<span class="hljs-string"><span class="hljs-string">"loginFormLayout"</span></span>, <span class="hljs-string"><span class="hljs-string">"loginButton"</span></span>} ) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button loginButton; }</code> </pre> <br><p> 查找物品只是Masquerade库的一部分。 访问网页的元素使您可以使用这些元素执行各种操作。 例如，您可以从下拉列表中选择一个项目： </p><br><pre> <code class="java hljs">getMaxResultsLayout().openOptionsPopup().select(<span class="hljs-string"><span class="hljs-string">"5000"</span></span>)</code> </pre> <br><p> 或排序表格： </p><br><pre> <code class="java hljs">Table tb1 = client.getPaymentsTable(); tb1.sort(<span class="hljs-string"><span class="hljs-string">"column_year"</span></span>, Table.SortDirection.ASCENDING);</code> </pre> <br><p> 请参阅以下屏幕截图，以获取一些表操作的列表： </p><br><p><img src="https://habrastorage.org/webt/a_/yb/xi/a_ybxiqn6tnamitezd8ytoeu5tq.png"></p><br><p><img src="https://habrastorage.org/webt/zj/n8/0l/zjn80lwr-gurcycna9onk9bhgxk.png"></p><br><p><img src="https://habrastorage.org/webt/ui/gz/6i/uigz6imouut0epktbr8vsmunlj4.png"></p><br><p> 使用Masquerade大大简化了测试的编写，现在要编写新功能的测试，您需要： </p><br><ol><li> 使用伪装来描述页面很容易，不需要特殊的编程技能。 </li><li> 将检查功能时使用的所有页面收集在一个类中。 </li><li> 从现成的自然语言构造中，收集测试脚本（在其中替换必要元素的名称），即编写一个Gauge规范。 </li></ol><br><h2 id="integriruem-masquerade-i-gauge"> 整合化妆舞会和量具 </h2><br><p> 在使用BDD之前，使用了TLD方法，并且为了与其一起使用，我们还优化了编写测试代码的过程。 二手的jUnit / TestNG + WebDriver + Selenide + Masquerade捆绑包。 </p><br><p> 现在，为了使用Gauge，我们向intellij IDEA添加了相应的插件。 之后，可以创建一种新型的测试-规范。 </p><br><p> 现在，我们创建规范（脚本）并使用WebDriver，Masquerade和Java的功能实施步骤。 </p><br><p><img src="https://habrastorage.org/webt/en/7c/sk/en7cskb3yo2k5cbwcnp_alqlfyq.png"></p><br><p> 我们单击脚本的步骤，然后转到实现： </p><br><p><img src="https://habrastorage.org/webt/lh/rx/zq/lhrxzqa-9gsnfzbson9w4hqndce.png"></p><br><p> 在实现中，您可以使用现有的login（）方法。 </p><br><h2 id="kak-zhe-vyglyadit-eto-sovershenstvo"> 这种完美是什么样的？ </h2><br><p> 回想一下我们在本文开头所研究的示例： </p><br><p><img src="https://habrastorage.org/webt/fg/s3/_e/fgs3_e71mp3t_ynlkbvbh-d6olw.png"></p><br><p>  <code>"Navigation.openMenu(menu)”</code>包含使用Masquerade库打开菜单的实现。 </p><br><p> 库随后进行了扩展，并且出现了可用于任何CUBA应用程序的通用步骤。 这些步骤使您可以使用程序元素：按钮，字段，表格。 这些通用步骤已成为我们在BDD中用于编写脚本的一组标准短语。 </p><br><p> 多亏了Masquerade + Gauge，我们大大降低了创建测试的复杂性。 现在，那些没有特殊编程技能的人可以编写测试。 测试可以由一个人编写（以前，脚本是由一个人发明的，但由另一个人实施，从而导致混乱）。 因此，我们已经实现了我们的目标-简化了界面，分析人员编写测试脚本将不难。 </p><br><p> 流程更改如下所示： </p><br><h6 id="bylo"> 那是： </h6><br><p><img src="https://habrastorage.org/webt/si/7y/m8/si7ym8xktulzmpgsvtsogu-5bfe.png" alt="是"></p><br><h6 id="stalo"> 它变成了： </h6><br><p><img src="https://habrastorage.org/webt/7d/vv/-a/7dvv-awtowdnlwwhifgz7_njoac.png" alt="已成为"></p><br><p> 相比之下，可以看出，要求，规范和测试文档合并在一个段落中。 除执行特定测试步骤外，测试文档也是一种自动测试。 </p><br><h2 id="itogi"> 总结 </h2><br><p> 目前，我们正在根据上述方案成功开发。 而且，我们设法摆脱了BDD的主要问题-由于实现的复杂性，工具的添加和最终确定，BDD的严重增加。 但是，产品交付的质量有所提高。 </p><br><p> 维护文档所需的时间与更改的规范数量成比例地减少，因为 规格（系统逻辑）的一项更改会自动导致一次迭代中的自动测试更改。 即 测试人员不需要进入文档系统（例如Confluence等）进行更新，其他团队成员也是如此。 </p><br><p> 与使用通常的干净Web驱动程序一起工作和重建XP链接的成本相比，在存在简化了页面对象工作的库的情况下实施和支持测试的时间减少了一半。 </p><br><p> 在任何业务解决方案的开发和质量管理中，消除需求收集和分析中的错误的成本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">呈指数增长</a> 。 因此，根据迭代开发中的现有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">条款</a>和进度表，与产品变更相关的问题的可能性以及对问题的早期研究（对需求的良好研究）可以很好地降低开发成本，具体取决于项目。 它既可以是0％，也可以是〜40％。 通过引入BDD可以实现这种改进。 可以在不将其称为BDD的情况下实现此功能，但它确实存在于BDD中。 能够解决问题是质量保证的重要组成部分。 </p><br><p> 最后，我想指出的是，该开发方案还与持续集成和我们公司开发的QA Lens测试管理系统集成在一起。 在QA Lens中，您可以使用面向主题的语言编写与IDEA中相同的脚本。 该语言由先前编译的词汇表组成，该词汇表先前已实施。 当从开发人员的机器或CI对Gauge执行自动测试时，QA Lens会自动记录哪些脚本步骤已完成，哪些未完成。 因此，在运行了由分析师编写的脚本的自动测试之后，测试部门会立即收到有关产品状态的完整最新信息。 </p><br><p> 作者：Sunagatov Ildar和Yushkova Julia（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Yushkova</a> ） <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN459134/">https://habr.com/ru/post/zh-CN459134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN459120/index.html">UNO-1000 / 2000系列模块化嵌入式计算机</a></li>
<li><a href="../zh-CN459122/index.html">Aleksey Savvateev：因分析不完善的市场（2014年）和集体声誉而获得Jean Tyrol的诺贝尔奖</a></li>
<li><a href="../zh-CN459126/index.html">带有Intel Neural Computer Stick 2的Raspberry Pi机器人储物箱</a></li>
<li><a href="../zh-CN459128/index.html">现实世界中的日语界面</a></li>
<li><a href="../zh-CN459130/index.html">微服务中的温和错误处理</a></li>
<li><a href="../zh-CN459136/index.html">假蓝丸</a></li>
<li><a href="../zh-CN459138/index.html">华为密钥如何进入思科路由器固件</a></li>
<li><a href="../zh-CN459140/index.html">植入物放置：如何完成？</a></li>
<li><a href="../zh-CN459142/index.html">在R中建立动画的移动平均线形图。通过NBA API检索数据</a></li>
<li><a href="../zh-CN459144/index.html">前端每周摘要（2019年7月1日至7日）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>