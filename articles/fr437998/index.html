<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚èèÔ∏è üç´ üòª Des philosophes de la restauration "modernes" en C ++ √† travers des acteurs et CSP üßëüèª üî† üíú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelque temps, un lien vers l'article "Les philosophes de la restauration moderne" s'est r√©pandu sur des ressources comme Reddit et HackerNews....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Des philosophes de la restauration "modernes" en C ++ √† travers des acteurs et CSP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437998/"><p>  Il y a quelque temps, un lien vers l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">"Les philosophes de la restauration moderne"</a> s'est r√©pandu sur des ressources comme Reddit et HackerNews.  L'article est int√©ressant, il montre plusieurs solutions √† cette t√¢che bien connue, impl√©ment√©e en C ++ moderne en utilisant une approche bas√©e sur les t√¢ches.  Si quelqu'un n'a pas encore lu cet article, alors il est logique de passer du temps et de le lire. </p><br><p>  Cependant, je ne peux pas dire que les solutions pr√©sent√©es dans l'article me paraissent simples et compr√©hensibles.  Cela est probablement d√ª √† l'utilisation de t√¢ches.  Un trop grand nombre d'entre eux sont cr√©√©s et distribu√©s par le biais de divers r√©partiteurs / s√©rialiseurs.  Il n'est donc pas toujours clair o√π, quand et quelles t√¢ches sont effectu√©es. </p><br><p>  De plus, l'approche bas√©e sur les t√¢ches n'est pas la seule possible pour r√©soudre de tels probl√®mes.  Pourquoi ne pas voir comment la t√¢che des ¬´philosophes de la restauration¬ª est r√©solue √† travers les mod√®les des acteurs et du CSP? </p><br><p>  Par cons√©quent, j'ai essay√© de rechercher et de mettre en ≈ìuvre plusieurs solutions √† ce probl√®me en utilisant √† la fois Acteurs et CSP.  Le code de ces solutions se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">dans le r√©f√©rentiel sur GitHub</a> .  Et sous le cutter, des explications et des explications, donc toute personne int√©ress√©e, bienvenue sous le cut. </p><a name="habracut"></a><br><h1 id="neskolko-obschih-slov">  Quelques mots courants </h1><br><p>  Je n'avais pas pour objectif de r√©p√©ter exactement les d√©cisions pr√©sent√©es dans l'article m√™me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">"Les philosophes de la restauration moderne"</a> , d'autant plus que je d√©teste fondamentalement une chose importante: en fait, le philosophe ne fait rien sur ces d√©cisions.  Il dit seulement "je veux manger", puis soit quelqu'un lui donne des fourchettes comme par magie, soit il dit "maintenant √ßa ne marchera pas". </p><br><p>  Il est clair pourquoi l'auteur a eu recours √† un tel comportement: il permet d'utiliser la m√™me impl√©mentation du ¬´philosophe¬ª en conjonction avec diff√©rentes impl√©mentations des ¬´protocoles¬ª.  Cependant, il me semble personnellement que c'est plus int√©ressant lorsque le ¬´philosophe¬ª essaie de prendre une prise d'abord, puis une autre.  Et lorsque le "philosophe" est contraint de g√©rer les tentatives infructueuses de capture des fourches. </p><br><p>  Ce sont pr√©cis√©ment ces r√©alisations de la t√¢che des ¬´philosophes culinaires¬ª que j'ai tent√© de r√©aliser.  Dans le m√™me temps, certaines solutions ont utilis√© les m√™mes approches que dans l'article mentionn√© (par exemple, impl√©ment√©es par les protocoles ForkLevelPhilosopherProtocol et WaiterFair). </p><br><p>  J'ai construit mes d√©cisions sur la base de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> , ce qui ne surprendra probablement pas ceux qui ont lu mes articles auparavant.  Si quelqu'un n'a pas encore entendu parler de SObjectizer, en bref: c'est l'un des rares "frameworks d'acteurs" OpenSource en d√©veloppement pour C ++ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">CAF</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">QP / C ++</a> peuvent √©galement √™tre mentionn√©s entre autres).  J'esp√®re que les exemples ci-dessus avec mes commentaires seront suffisamment clairs m√™me pour ceux qui ne connaissent pas SObjectizer.  Sinon, je serai heureux de r√©pondre aux questions dans les commentaires. </p><br><h1 id="resheniya-na-baze-aktorov">  Solutions d'acteurs </h1><br><p>  Nous allons commencer la discussion des solutions mises en ≈ìuvre avec celles bas√©es sur les Acteurs.  Tout d'abord, consid√©rez la mise en ≈ìuvre de la solution Edsger Dijkstra, puis passez √† plusieurs autres solutions et voyez comment le comportement de chacune des solutions diff√®re. </p><br><h2 id="reshenie-deykstry">  D√©cision de Dijkstra </h2><br><p>  Edsger Dijkstra, non seulement a-t-il formul√© la t√¢che de "manger du phylophos" (la formulation de celui-ci en utilisant des "fourchettes" et des "spaghettis" a √©t√© exprim√©e par Tony Hoar), il a √©galement propos√© une solution tr√®s simple et tr√®s belle.  A savoir: les philosophes ne devraient saisir les fourchettes que dans le but d'augmenter le nombre de fourchettes, et si le philosophe a r√©ussi √† prendre la premi√®re fourchette, il ne la l√¢chera pas avant d'avoir re√ßu la deuxi√®me fourchette. </p><br><p>  Par exemple, si un philosophe a besoin d'utiliser des fourchettes avec les nombres 5 et 6, alors le philosophe doit d'abord prendre une fourchette du nombre 5. Ce n'est qu'apr√®s cela qu'il peut prendre une fourchette du nombre 6. Ainsi, si les fourchettes avec des nombres inf√©rieurs sont √† la gauche des philosophes, alors le philosophe devrait prenez d'abord la fourche gauche et alors seulement il peut prendre la fourche droite. </p><br><p>  Le dernier philosophe de la liste, qui doit g√©rer les fourches aux num√©ros (N-1) et 0, fait le contraire: il prend d'abord la fourche droite avec le num√©ro 0, puis la fourche gauche avec le num√©ro (N-1). </p><br><p>  Pour mettre en ≈ìuvre cette approche, deux types d'acteurs seront n√©cessaires: un pour les fourches et un pour les philosophes.  Si le philosophe veut manger, il envoie un message √† l'acteur fork correspondant pour capturer la fork, et l'acteur fork r√©pond avec un message de r√©ponse. </p><br><p>  Le code pour impl√©menter cette approche peut √™tre vu <a href="" rel="nofollow">ici</a> . </p><br><h3 id="soobscheniya">  Des messages </h3><br><p>  Avant de parler des acteurs, vous devez regarder les messages que les acteurs √©changeront: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">take_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">taken_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">put_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><p>  Lorsque l'acteur-philosophe veut prendre la prise, il envoie le message <code>take_t</code> √† l' <code>take_t</code> fork, et l'acteur fork r√©pond avec le message <code>taken_t</code> .  Lorsque l'acteur-philosophe a fini de manger et veut remettre les fourchettes sur la table, il envoie des messages put_t √† l' <code>put_t</code> fourches. </p><br><p>  Dans le message <code>take_t</code> , le champ <code>take_t</code> d√©signe la bo√Æte aux lettres (aka mbox) de l'acteur philosophe.  Un message de r√©ponse <code>taken_t</code> doit √™tre envoy√© √† cette <code>taken_t</code> .  Le deuxi√®me champ de <code>take_t</code> n'est pas utilis√© dans cet exemple, nous en aurons besoin lorsque nous arriverons aux impl√©mentations de waiter_with_queue et waiter_with_timestamps. </p><br><h3 id="aktor-vilka">  Fourchette d'acteur </h3><br><p>  Maintenant, nous pouvons voir ce qu'est un acteur fork.  Voici son code: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     'free'. this &gt;&gt;= st_free; //   'free'    . st_free .event( [this]( mhood_t&lt;take_t&gt; cmd ) { this &gt;&gt;= st_taken; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } ); //   'taken'   . st_taken .event( [this]( mhood_t&lt;take_t&gt; cmd ) { //     . m_queue.push( cmd-&gt;m_who ); } ) .event( [this]( mhood_t&lt;put_t&gt; ) { if( m_queue.empty() ) //     . this &gt;&gt;= st_free; else { //      . const auto who = m_queue.front(); m_queue.pop(); so_5::send&lt; taken_t &gt;( who ); } } ); } private : //    . const state_t st_free{ this, "free" }; const state_t st_taken{ this, "taken" }; //   . std::queue&lt; so_5::mbox_t &gt; m_queue; };</span></span></code> </pre> <br><p>  Chaque acteur dans SObjectizer doit √™tre d√©riv√© de la classe de base <code>agent_t</code> .  Ce que nous voyons ici pour le type <code>fork_t</code> . </p><br><p>  La m√©thode <code>so_define_agent()</code> est remplac√©e dans la classe <code>so_define_agent()</code> .  Il s'agit d'une m√©thode sp√©ciale, elle est automatiquement appel√©e par le SObjectizer lors de l'enregistrement d'un nouvel agent.  Dans la m√©thode <code>so_define_agent()</code> , l' <code>so_define_agent()</code> est "configur√©" pour fonctionner dans SObjectizer: l'√©tat de d√©marrage change, les messages n√©cessaires sont souscrits. </p><br><p>  Chaque acteur dans SObjectizer est une machine √† √©tats avec des √©tats (m√™me si un acteur n'utilise qu'un seul √©tat par d√©faut).  L'acteur <code>fork_t</code> a deux √©tats: <em>libre</em> et <em>pris</em> .  Lorsqu'un acteur est <em>libre</em> , la prise peut √™tre ¬´captur√©e¬ª par le philosophe.  Et apr√®s avoir captur√© le "fork", l'acteur <code>fork_t</code> devrait passer dans l'√©tat <em>pris</em> .  Dans la classe <code>fork_t</code> √©tats sont repr√©sent√©s par des instances de <code>st_free</code> et <code>st_taken</code> type sp√©cial <code>state_t</code> . </p><br><p>  Les √©tats vous permettent de traiter les messages entrants de diff√©rentes mani√®res.  Par exemple, √† l'√©tat <em>libre</em> , l'agent ne r√©pond qu'√† <code>take_t</code> et cette r√©action est tr√®s simple: l'√©tat de l'acteur change et la r√©ponse <code>taken_t</code> : </p><br><pre> <code class="cpp hljs">st_free .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_taken; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( cmd-&gt;m_who ); } );</code> </pre> <br><p>  Alors que tous les autres messages, y compris <code>put_t</code> √† l'√©tat <em>libre</em> , sont simplement ignor√©s. </p><br><p>  √Ä l'√©tat <em>pris</em> , l'acteur traite deux messages, et m√™me le message <code>take_t</code> il traite diff√©remment: </p><br><pre> <code class="cpp hljs">st_taken .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { m_queue.push( cmd-&gt;m_who ); } ) .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span>&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_queue.empty() ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_free; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> who = m_queue.front(); m_queue.pop(); so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( who ); } } );</code> </pre> <br><p>  Le gestionnaire de <code>put_t</code> plus int√©ressant <code>put_t</code> : si la file d'attente des philosophes en attente est vide, alors nous pouvons revenir √† <em>free</em> , mais si elle n'est pas vide, alors le premier d'entre eux doit √™tre envoy√© √† <code>taken_t</code> . </p><br><h3 id="aktor-filosof">  Acteur philosophe </h3><br><p>  <a href="" rel="nofollow">Le code de l'acteur-philosophe est</a> beaucoup plus volumineux, donc je ne le donnerai pas ici en entier.  Nous ne discuterons que des fragments les plus significatifs. </p><br><p>  Un acteur-philosophe a un peu plus d'√©tats: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_thinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"thinking.normal"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_wait_left{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_wait_right{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_eating{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"eating"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_done{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span> };</code> </pre> <br><p>  L'acteur commence son travail dans un √©tat de <em>r√©flexion</em> , puis passe √† <em>wait_left</em> , puis √† <em>wait_right</em> , puis √† <em>manger</em> .  En <em>mangeant, un</em> acteur peut revenir √† la <em>pens√©e</em> ou aller √† l'action si le philosophe a mang√© tout ce qu'il devrait avoir. </p><br><p>  Le diagramme d'√©tat d'un acteur-philosophe peut √™tre repr√©sent√© comme suit: </p><br><p><img src="https://habrastorage.org/webt/ir/j0/sm/irj0smrzaedcsud20y71aynfqb4.png" alt="image"></p><br><p>  La logique du comportement de l'acteur est d√©crite dans l'impl√©mentation de sa m√©thode <code>so_define_agent()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   thinking     stop_thinking. st_thinking .event( [=]( mhood_t&lt;stop_thinking_t&gt; ) { //    . this &gt;&gt;= st_wait_left; so_5::send&lt; take_t &gt;( m_left_fork, so_direct_mbox(), m_index ); } ); //        taken. st_wait_left .event( [=]( mhood_t&lt;taken_t&gt; ) { //     .   . this &gt;&gt;= st_wait_right; so_5::send&lt; take_t &gt;( m_right_fork, so_direct_mbox(), m_index ); } ); //    ,    taken. st_wait_right .event( [=]( mhood_t&lt;taken_t&gt; ) { //    ,  . this &gt;&gt;= st_eating; } ); //      stop_eating. st_eating // 'stop_eating'        'eating'. .on_enter( [=] { so_5::send_delayed&lt; stop_eating_t &gt;( *this, eat_pause() ); } ) .event( [=]( mhood_t&lt;stop_eating_t&gt; ) { //      . so_5::send&lt; put_t &gt;( m_right_fork ); so_5::send&lt; put_t &gt;( m_left_fork ); //     . ++m_meals_eaten; if( m_meals_count == m_meals_eaten ) this &gt;&gt;= st_done; //  ,  ,  . else think(); } ); st_done .on_enter( [=] { //   ,   . completion_watcher_t::done( so_environment(), m_index ); } ); }</span></span></code> </pre> <br><p>  Le seul point qui devrait √™tre particuli√®rement soulign√© est peut-√™tre l'approche consistant √† imiter les processus de ¬´penser¬ª et de ¬´manger¬ª.  Il n'y a pas <code>this_thread::sleep_for</code> dans le code de l'acteur ou de toute autre mani√®re pour bloquer le thread de travail actuel.  √Ä la place, les messages en attente sont utilis√©s.  Par exemple, lorsqu'un acteur entre en √©tat de <em>manger</em> , il s'envoie un message <code>stop_eating_t</code> attente.  Ce message est transmis au temporisateur SObjectizer et le temporisateur remet le message √† l'acteur le moment venu. </p><br><p>  L'utilisation de messages diff√©r√©s vous permet d'ex√©cuter tous les acteurs dans le contexte d'un seul thread de travail.  En gros, un thread lit les messages d'une file d'attente et tire le gestionnaire de messages suivant de l'acteur destinataire correspondant.  Plus d'informations sur les contextes de travail des acteurs seront discut√©es ci-dessous. </p><br><h3 id="rezultaty">  R√©sultats </h3><br><p>  Les r√©sultats de cette impl√©mentation peuvent ressembler √† ceci (un petit fragment): </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttttLRRRRRRRRRRRRRREEEEEEEttttttttLRRRRRRRRRRRRRREEEEEEEEEEEEE Plato: ttttttttttEEEEEEEEEEEEEEEEttttttttttRRRRRREEEEEEEEEEEEEEttttttttttLLL Aristotle: ttttEEEEEtttttttttttLLLLLLRRRREEEEEEEEEEEEttttttttttttLLEEEEEEEEEEEEE Descartes: tttttLLLLRRRRRRRREEEEEEEEEEEEEtttLLLLLLLLLRRRRREEEEEEttttttttttLLLLLL Spinoza: ttttEEEEEEEEEEEEEttttttttttLLLRRRREEEEEEEEEEEEEttttttttttRRRREEEEEEtt Kant: ttttttttttLLLLLLLRREEEEEEEEEEEEEEEttttttttttLLLEEEEEEEEEEEEEEtttttttt Schopenhauer: ttttttEEEEEEEEEEEEEttttttLLLLLLLLLEEEEEEEEEttttttttLLLLLLLLLLRRRRRRRR Nietzsche: tttttttttLLLLLLLLLLEEEEEEEEEEEEEttttttttLLLEEEEEEEEEttttttttRRRRRRRRE Wittgenstein: ttttEEEEEEEEEEtttttLLLLLLLLLLLLLEEEEEEEEEttttttttttttRRRREEEEEEEEEEEt Heidegger: tttttttttttLLLEEEEEEEEEEEEEEtttttttLLLLLLREEEEEEEEEEEEEEEtttLLLLLLLLR Sartre: tttEEEEEEEEEttttLLLLLLLLLLLLRRRRREEEEEEEEEtttttttLLLLLLLLRRRRRRRRRRRR</code> </pre> <br><p>  Lisez ceci comme suit: </p><br><ul><li>  <code>t</code> indique que le philosophe "pense"; </li><li>  <code>L</code> signifie que le philosophe s'attend √† capturer la fourche gauche (est dans l'√©tat <em>wait_left</em> ); </li><li>  <code>R</code> signifie que le philosophe s'attend √† capturer la fourche droite (est dans l'√©tat <em>wait_right</em> ); </li><li>  <code>E</code> signifie que le philosophe "mange". </li></ul><br><p>  On voit que Socrate ne peut prendre la fourche √† gauche qu'apr√®s que Sartre l'ait c√©d√©e.  Apr√®s quoi, Socrate attendra que Platon lib√®re la bonne fourche.  Ce n'est qu'apr√®s que Socrate pourra manger. </p><br><h2 id="prostoe-reshenie-bez-arbitra-oficianta">  Une d√©cision simple sans arbitre (serveur) </h2><br><p>  Si nous analysons le r√©sultat de la d√©cision de Dijkstra, nous verrons que les philosophes passent beaucoup de temps √† attendre la capture des fourches.  Ce qui n'est pas bon, car  ce temps peut √©galement √™tre consacr√© √† la r√©flexion.  Ce n'est pas pour rien qu'il y a une opinion que si vous pensez √† jeun, vous pouvez obtenir des r√©sultats beaucoup plus int√©ressants et inattendus;) </p><br><p>  Examinons la solution la plus simple dans laquelle le philosophe retourne la premi√®re fourchette captur√©e s'il ne peut pas capturer la seconde (dans l'article "Modern Dining philosophers" mentionn√© ci-dessus, cette solution est impl√©ment√©e par ForkLevelPhilosopherProtocol). </p><br><p>  Le code source de cette impl√©mentation peut √™tre vu <a href="" rel="nofollow">ici</a> , et le code de l'acteur philosophe correspondant <a href="" rel="nofollow">ici</a> . </p><br><h3 id="soobscheniya-1">  Des messages </h3><br><p>  Cette solution utilise presque le m√™me ensemble de messages: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">take_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">busy_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">taken_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">put_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><p>  La seule diff√©rence est la pr√©sence du signal <code>busy_t</code> .  L'acteur-fork envoie ce signal en r√©ponse au philosophe-acteur si le fork est d√©j√† capt√© par un autre philosophe. </p><br><h3 id="aktor-vilka-1">  Fourchette d'acteur </h3><br><p>  L'acteur fork de cette solution est encore plus simple que dans la solution de Dijkstra: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>( ctx ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_free; st_free.event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_taken; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( cmd-&gt;m_who ); } ); st_taken.event( []( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( cmd-&gt;m_who ); } ) .just_switch_to&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( st_free ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_taken{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; };</code> </pre> <br><p>  Ici, nous n'avons m√™me pas besoin de garder la file d'attente des philosophes en attente. </p><br><h3 id="aktor-filosof-1">  Acteur philosophe </h3><br><p>  Le philosophe-acteur dans cette impl√©mentation est similaire √† celui de la solution de Dijkstra, mais ici le philosophe-acteur doit √©galement traiter <code>busy_t</code> , donc le diagramme d'√©tat ressemble √† ceci: </p><br><p><img src="https://habrastorage.org/webt/xa/ek/c8/xaekc8xbxewoj1e7myao4le6jn0.png" alt="image"></p><br><p>  De m√™me, toute la logique d'un acteur-philosophe est d√©finie dans <code>so_define_agent()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ st_thinking .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_thinking_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_wait_left; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( m_left_fork, so_direct_mbox(), m_index ); } ); st_wait_left .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_wait_right; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( m_right_fork, so_direct_mbox(), m_index ); } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( [=] { think( st_hungry_thinking ); } ); st_wait_right .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_eating; } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( [=] { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_left_fork ); think( st_hungry_thinking ); } ); st_eating .on_enter( [=] { so_5::send_delayed&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_eating_t</span></span> &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, eat_pause() ); } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_eating_t</span></span> &gt;( [=] { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_right_fork ); so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_left_fork ); ++m_meals_eaten; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_meals_count == m_meals_eaten ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_done; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> think( st_normal_thinking ); } ); st_done .on_enter( [=] { <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span>::done( so_environment(), m_index ); } ); }</code> </pre> <br><p>  En g√©n√©ral, c'est presque le m√™me code que dans la solution de Dijkstra, √† l'exception de quelques gestionnaires pour <code>busy_t</code> . </p><br><h3 id="rezultaty-1">  R√©sultats </h3><br><p>  Les r√©sultats du travail sont diff√©rents: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttL..R.....EEEEEEEEEEEEttttttttttR...LL..EEEEEEEttEEEEEE Plato: ttttEEEEEEEEEEEttttttL.....L..EEEEEEEEEEEEEEEttttttttttL....L.... Aristotle: ttttttttttttL..LR.EEEEEEtttttttttttL..L....L....R.....EEEEEEEEE Descartes: ttttttttttEEEEEEEEttttttttttttEEEEEEEEttttEEEEEEEEEEEttttttL..L.. Spinoza: ttttttttttL.....L...EEEEEEtttttttttL.L......L....L..L...R...R...E Kant: tttttttEEEEEEEttttttttL.L.....EEEEEEEEttttttttR...R..R..EEEEEtttt Schopenhauer: tttR..R..L.....EEEEEEEttttttR.....L...EEEEEEEEEEEEEEEEttttttttttt Nietzsche: tttEEEEEEEEEEtttttttttEEEEEEEEEEEEEEEttttL....L...L..L....EEEEEEE Wittgenstein: tttttL.L..L.....RR....L.....L....L...EEEEEEEEEEEEEEEtttttttttL. Heidegger: ttttR..R......EEEEEEEEEEEEEttttttttttR..L...L...L..L...EEEEtttttt Sartre: tttEEEEEEEtttttttL..L...L....R.EEEEEEEtttttEEEEtttttttR.....R..R.</code> </pre> <br><p>  Nous voyons ici un nouveau symbole, ce qui signifie que l'acteur-philosophe est dans ¬´des pens√©es affam√©es¬ª. </p><br><p>  M√™me dans ce court fragment, on peut voir qu'il y a de longues p√©riodes de temps pendant lesquelles le philosophe ne peut pas manger.  En effet, cette solution est prot√©g√©e contre le probl√®me de blocage, mais n'a pas de protection contre la famine. </p><br><h2 id="reshenie-s-oficiantom-i-ocheredyu">  La d√©cision avec le serveur et la file d'attente </h2><br><p>  La solution la plus simple pr√©sent√©e ci-dessus sans arbitre ne prot√®ge pas contre la famine.  L'article "Modern Dining Philosophers" mentionn√© ci-dessus contient une solution au probl√®me du je√ªne sous la forme d'un protocole WaiterFair.  L'essentiel, c'est qu'il y a un arbitre (serveur), auquel les philosophes se tournent quand ils veulent manger.  Et le serveur a une file d'attente d'applications de philosophes.  Et le philosophe n'obtient les fourches que si les deux fourchettes sont libres maintenant, et qu'aucun des voisins du philosophe ne s'est tourn√© vers le serveur dans la file d'attente. </p><br><p>  Voyons √† quoi pourrait ressembler cette m√™me solution pour les acteurs. </p><br><p>  Le code source de cette impl√©mentation peut √™tre trouv√© <a href="" rel="nofollow">ici</a> . </p><br><h3 id="tryuk">  Trick </h3><br><p>  Le moyen le plus simple serait d'introduire un nouvel ensemble de messages √† travers lequel les philosophes pourraient communiquer avec le serveur.  Mais je voulais enregistrer non seulement l'ensemble de messages d√©j√† existant (c'est-√†-dire <code>take_t</code> , <code>taken_t</code> , <code>busy_t</code> , <code>put_t</code> ).  Je voulais aussi que le m√™me acteur-philosophe soit utilis√© comme dans la solution pr√©c√©dente.  Par cons√©quent, j'ai d√ª r√©soudre un probl√®me d√©licat: comment faire communiquer l'acteur-philosophe avec le seul acteur-serveur, mais en m√™me temps, j'ai pens√© qu'il interagissait directement avec les acteurs-fourches (qui ont d√©j√† disparu). </p><br><p>  Ce probl√®me a √©t√© r√©solu √† l'aide d'une astuce simple: un acteur-serveur cr√©e un ensemble de mbox-s, dont les liens sont donn√©s √† des philosophe-acteurs sous forme de liens vers des mbox-s d'acteurs fork.  Dans le m√™me temps, l'acteur-serveur s'abonne aux messages de toutes ces mbox (ce qui est facilement impl√©ment√© dans SObjectizer, car SObjectizer est une impl√©mentation non seulement / autant de mod√®les d'acteurs, mais aussi Pub / Sub est pris en charge hors de la bo√Æte) . </p><br><p>  Dans le code, cela ressemble √† ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">waiter_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">waiter_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> forks_count ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) } , m_fork_states( forks_count, <span class="hljs-keyword"><span class="hljs-keyword">fork_state_t</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//  mbox-   "" m_fork_mboxes.reserve( forks_count ); for( std::size_t i{}; i != forks_count; ++i ) m_fork_mboxes.push_back( so_environment().create_mbox() ); } ... void so_define_agent() override { //      "". for( std::size_t i{}; i != m_fork_mboxes.size(); ++i ) { //     .   . //          //    . so_subscribe( fork_mbox( i ) ) .event( [i, this]( mhood_t&lt;take_t&gt; cmd ) { on_take_fork( std::move(cmd), i ); } ) .event( [i, this]( mhood_t&lt;put_t&gt; cmd ) { on_put_fork( std::move(cmd), i ); } ); } } private : ... //     "". std::vector&lt; so_5::mbox_t &gt; m_fork_mboxes;</span></span></code> </pre> <br><p>  C'est-√†-dire  Cr√©ez d'abord un vecteur de mbox-s pour les "fourches" inexistantes, puis abonnez-vous √† chacune d'elles.  Oui, nous nous abonnons pour savoir √† quelle fiche particuli√®re se rapporte la demande. </p><br><p>  Le v√©ritable gestionnaire de la demande entrante <code>on_take_fork()</code> est la m√©thode <code>on_take_fork()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_take_fork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">take_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; cmd, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_index )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,       //    . if( fork_index == cmd-&gt;m_philosopher_index ) handle_take_left_fork( std::move(cmd), fork_index ); else handle_take_right_fork( std::move(cmd), fork_index ); }</span></span></code> </pre> <br><p>  Au fait, c'est ici que nous avions besoin du deuxi√®me champ du message <code>take_t</code> . </p><br><p>  Ainsi, dans <code>on_take_fork()</code> nous avons la requ√™te d'origine et l'index du fork auquel se rapporte la requ√™te.  Par cons√©quent, nous pouvons d√©terminer si le philosophe demande une fourche gauche ou une droite.  Et, en cons√©quence, nous pouvons les traiter diff√©remment (et nous devons les traiter diff√©remment). </p><br><p>  Puisque le philosophe demande toujours d'abord la fourche gauche, nous devons alors faire toutes les v√©rifications n√©cessaires en ce moment m√™me.  Et nous pouvons nous retrouver dans l'une des situations suivantes: </p><br><ol><li>  Les deux fourchettes sont gratuites et peuvent √™tre remises au philosophe qui a envoy√© la demande.  Dans ce cas, nous <code>taken_t</code> philosophe et marquons la fourche droite comme r√©serv√©e pour que personne d'autre ne puisse la prendre. </li><li>  On ne peut pas donner de fourchettes au philosophe.  Peu importe pourquoi.  Peut-√™tre que certains d'entre eux sont occup√©s en ce moment.  Ou en ligne est l'un des voisins du philosophe.  Quoi qu'il en soit, nous mettons le philosophe qui a envoy√© la demande dans la file d'attente, apr√®s quoi nous lui <code>busy_t</code> . </li></ol><br><p>  Gr√¢ce √† cette logique de travail, le philosophe qui a re√ßu <code>taken_t</code> pour la fourche gauche peut en toute s√©curit√© envoyer une demande <code>take_t</code> pour la fourche droite.  Cette demande sera imm√©diatement satisfaite,  la fourchette est d√©j√† r√©serv√©e √† ce philosophe. </p><br><h3 id="rezultaty-2">  R√©sultats </h3><br><p>  Si vous ex√©cutez la solution r√©sultante, vous pouvez voir quelque chose comme: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttttL....EEEEEEEEEEEEEEttttttttttL...L...EEEEEEEEEEEEEtttttL. Plato: tttttttttttL....L..L..L...L...EEEEEEEEEEEEEtttttL.....L....L.....EEE Aristotle: tttttttttL.....EEEEEEEEEttttttttttL.....L.....EEEEEEEEEEEtttL....LL Descartes: ttEEEEEEEEEEtttttttL.L..EEEEEEEEEEEEtttL..L....L....L.....EEEEEEEEEE Spinoza: tttttttttL.....EEEEEEEEEttttttttttL.....L.....EEEEEEEEEEEtttL....LL Kant: ttEEEEEEEEEEEEEtttttttL...L.....L.....EEEEEttttL....L...L..L...EEEEE Schopenhauer: ttttL...L.....L.EEEEEEEEEEEEEEEEEtttttttttttL..L...L..EEEEEEEttttttt Nietzsche: tttttttttttL....L..L..L...L...L.....L....EEEEEEEEEEEEttL.....L...L.. Wittgenstein: tttttttttL....L...L....L....L...EEEEEEEttttL......L.....L.....EEEEEE Heidegger: ttttttL..L...L.....EEEEEEEEEEEEtttttL...L..L.....EEEEEEEEEEEttttttL. Sartre: ttEEEEEEEEEEEEEttttttttL.....L...EEEEEEEEEEEEttttttttttttL.....EEEEE</code> </pre> <br><p>  Vous pouvez faire attention au manque de caract√®res <code>R</code>  En effet, les √©checs ou les attentes ne peuvent pas se produire sur une demande de fourche droite. </p><br><h2 id="esche-odno-reshenie-s-ispolzovaniem-arbitra-oficianta">  Une autre d√©cision en utilisant un arbitre (serveur) </h2><br><p>  Dans certains cas, la solution waiter_with_queue pr√©c√©dente peut afficher des r√©sultats similaires √† celui-ci: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttEEEEEEEEEEEEEEtttL.....LL...L....EEEEEEEEEttttttttttL....L.....EE Plato: tttttL..L..L....LL...EEEEEEEEEEEEEEEttttttttttttL.....EEEEEEEEEttttttt Aristotle: tttttttttttL..L...L.....L.....L....L.....EEEEEEEEEEEEtttttttttttL....L.. Descartes: ttttttttttEEEEEEEEEEttttttL.....L....L..L.....L.....L..L...L..EEEEEEEEtt Spinoza: tttttttttttL..L...L.....L.....L....L.....L..L..L....EEEEEEEEEEtttttttttt Kant: tttttttttL....L....L...L...L....L..L...EEEEEEEEEEEttttttttttL...L......E Schopenhauer: ttttttL....L..L...L...LL...L...EEEEEtttttL....L...L.....EEEEEEEEEttttt Nietzsche: tttttL..L..L....EEEEEEEEEEEEEttttttttttttEEEEEEEEEEEEEEEttttttttttttL... Wittgenstein: tttEEEEEEEEEEEEtttL....L....L..EEEEEEEEEtttttL..L..L....EEEEEEEEEEEEEEEE Heidegger: tttttttttL...L..EEEEEEEEttttL..L.....L...EEEEEEEEEtttL.L..L...L....L...L Sartre: ttttttttttL..L....L...L.EEEEEEEEEEEtttttL...L..L....EEEEEEEEEEtttttttttt</code> </pre> <br><p>  Vous pouvez voir la pr√©sence de p√©riodes suffisamment longues o√π les philosophes ne peuvent pas manger, m√™me en pr√©sence de fourchettes gratuites.  Par exemple, les fourches gauche et droite pour Kant sont libres pendant longtemps, mais Kant ne peut pas les prendre, car  ses voisins attendent d√©j√† en ligne.  Qui attendent leurs voisins.  Qui attendent leurs voisins, etc. </p><br><p>  Par cons√©quent, la mise en ≈ìuvre de waiter_with_queue discut√©e ci-dessus prot√®ge contre la famine dans le sens o√π t√¥t ou tard le philosophe mangera.  Cela lui est garanti.  Mais les p√©riodes de je√ªne peuvent √™tre assez longues.  Et l'utilisation des ressources peut parfois ne pas √™tre optimale. </p><br><p>  Afin de r√©soudre ce probl√®me, j'ai impl√©ment√© une autre solution, waiter_with_timestamp (son code peut √™tre trouv√© <a href="" rel="nofollow">ici</a> ).  Au lieu de faire la queue, ils priorisent les demandes des philosophes en tenant compte de l'heure de leur je√ªne.  Plus le philosophe a faim, plus sa demande est prioritaire. </p><br><p>  Nous ne consid√©rerons pas le code de cette solution, car  dans l'ensemble, l'essentiel est la m√™me astuce avec un ensemble de mbox pour les "fourches" inexistantes, dont nous avons d√©j√† discut√© dans la conversation sur la mise en ≈ìuvre de waiter_with_queue. </p><br><h2 id="neskolko-detaley-realizacii-na-kotorye-hotelos-by-obratit-vnimanie">  Quelques d√©tails de mise en ≈ìuvre sur lesquels je voudrais attirer l'attention </h2><br><p>  Il y a plusieurs d√©tails dans les impl√©mentations bas√©es sur les acteurs que je voudrais faire attention, car  ces d√©tails pr√©sentent des fonctionnalit√©s int√©ressantes de SObjectizer. </p><br><h3 id="rabochiy-kontekst-dlya-aktorov">  Contexte de travail des acteurs </h3><br><p>  Dans les impl√©mentations consid√©r√©es, tous les principaux acteurs ( <code>fork_t</code> , <code>philosopher_t</code> , <code>waiter_t</code> ) ont travaill√© sur le contexte d'un thread de travail commun.  Ce qui ne signifie pas du tout que dans SObjectizer tous les acteurs travaillent sur un seul thread.  Dans SObjectizer, vous pouvez lier des acteurs √† diff√©rents contextes, ce qui peut √™tre vu, par exemple, dans le code de la fonction <code>run_simulation()</code> dans la solution no_waiter_simple. </p><br><div class="spoiler">  <b class="spoiler_title">Run_simulation code de no_waiter_simple</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span></span>{ env.introduce_coop( [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop ) { coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() ); coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = names.size(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * &gt; forks( count, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != count; ++i ) forks[ i ] = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span> &gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != count; ++i ) coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span> &gt;( i, forks[ i ]-&gt;so_direct_mbox(), forks[ (i + <span class="hljs-number"><span class="hljs-number">1</span></span>) % count ]-&gt;so_direct_mbox(), default_meals_count ); }); }</code> </pre> </div></div><br><p>  Dans cette fonction, des acteurs suppl√©mentaires des types <code>trace_maker_t</code> et <code>completion_watcher_t</code> .  Ils travailleront sur des contextes de travail individuels.  Pour ce faire, deux instances du r√©partiteur de type <code>one_thread</code> sont <code>one_thread</code> et les acteurs sont li√©s √† ces instances de r√©partiteurs.  Ce qui signifie que ces acteurs fonctionneront comme <em>des objets actifs</em> : chacun poss√©dera son propre fil de travail. </p><br><p>  SObjectizer fournit un ensemble de plusieurs r√©partiteurs diff√©rents qui peuvent √™tre utilis√©s d√®s la sortie de la bo√Æte.  Dans ce cas, le d√©veloppeur peut cr√©er dans son application autant d'instances de r√©partiteurs que le d√©veloppeur en a besoin. </p><br><p>    ,        ,       . ,      <code>fork_t</code>     ,   <code>philosopher_t</code>   . </p><br><div class="spoiler"> <b class="spoiler_title"> run_simulation  no_waiter_simple_tp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span></span>{ env.introduce_coop( [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop ) { coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() ); coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = names.size(); <span class="hljs-comment"><span class="hljs-comment">//     thread_pool-. so_5::disp::thread_pool::bind_params_t bind_params; bind_params.fifo( so_5::disp::thread_pool::fifo_t::individual ); std::vector&lt; so_5::agent_t * &gt; forks( count, nullptr ); //     -. auto fork_disp = so_5::disp::thread_pool::create_private_disp( env, 3u //  . ); for( std::size_t i{}; i != count; ++i ) //      . forks[ i ] = coop.make_agent_with_binder&lt; fork_t &gt;( fork_disp-&gt;binder( bind_params ) ); //     -. auto philosopher_disp = so_5::disp::thread_pool::create_private_disp( env, 6u //  . ); for( std::size_t i{}; i != count; ++i ) coop.make_agent_with_binder&lt; philosopher_t &gt;( philosopher_disp-&gt;binder( bind_params ), i, forks[ i ]-&gt;so_direct_mbox(), forks[ (i + 1) % count ]-&gt;so_direct_mbox(), default_meals_count ); }); }</span></span></code> </pre> </div></div><br><p>            <code>fork_t</code>  <code>philosopher_t</code> . </p><br><h3 id="trassirovka-smeny-sostoyaniy-aktorov">     </h3><br><p>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Modern dining philosophers</a>    ,     , : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doEat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ eventLog_.startActivity(ActivityType::eat); wait(randBetween(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>)); eventLog_.endActivity(ActivityType::eat);</code> </pre> <br><p>          SObjectizer   .  ,   , .  √Ä cause de quoi? </p><br><p>   ,   SObjectizer-   :   .       <code>agent_state_listener_t</code> .     ,  SObjectizer        . </p><br><p>        <code>greedy_philosopher_t</code>  <code>philosopher_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>(...) ... { so_add_destroyable_listener( <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>::make( so_environment(), index ) ); }</code> </pre> <br><p>  <code>state_watcher_t</code> ‚Äî       . </p><br><div class="spoiler"> <b class="spoiler_title"> state_watcher_t</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_watcher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_state_listener_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_mbox; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_index; <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> mbox, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_state_listener_unique_ptr_t</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span>::make_mbox(env), index } }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">agent_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">state_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; state )</span></span></span><span class="hljs-function"> override</span></span>; };</code> </pre> </div></div><br><p>   <code>state_watcher_t</code>    SObjectizer   <code>changed()</code>    .    <code>state_watcher_t::changed</code>      -. </p><br><div class="spoiler"> <b class="spoiler_title">  state_watcher_t::changed</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>::changed( so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> &amp; state ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> detect_label = []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; name ) {...}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> state_label = detect_label( state.query_name() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-string"><span class="hljs-string">'?'</span></span> == state_label ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; so_5::send&lt; trace::<span class="hljs-keyword"><span class="hljs-keyword">state_changed_t</span></span> &gt;( m_mbox, m_index, state_label ); }</code> </pre> </div></div><br><h1 id="resheniya-na-baze-csp">    CSP </h1><br><p>     ,     .       (no_waiter_dijkstra, no_waiter_simple, waiter_with_timestamps)     <code>std::thread</code>  SObjectizer- mchain- (,  ,  CSP- ). ,  ,  CSP-        (   <code>take_t</code> , <code>taken_t</code> , <code>busy_t</code> , <code>put_t</code> ). </p><br><p>  CSP-  ""   .   ,         <code>std::thread</code> . </p><br><h2 id="reshenie-deykstry-1">   </h2><br><p>       <a href="" rel="nofollow"></a> . </p><br><h3 id="nit-dlya-vilki">    </h3><br><p>         :       +    <code>take_t</code>  <code>put_t</code> .    <code>fork_process</code>  : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fork_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_ch )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  :   . bool taken = false; //   . std::queue&lt; so_5::mbox_t &gt; wait_queue; //        . so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::mhood_t&lt;take_t&gt; cmd ) { if( taken ) //  ,     . wait_queue.push( cmd-&gt;m_who ); else { //    . taken = true; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } }, [&amp;]( so_5::mhood_t&lt;put_t&gt; ) { if( wait_queue.empty() ) taken = false; //     . else { //       . const auto who = wait_queue.front(); wait_queue.pop(); so_5::send&lt; taken_t &gt;( who ); } } ); }</span></span></code> </pre> <br><p>   <code>fork_process</code>   :  ,   -   . </p><br><p>    <code>fork_process</code> ‚Äî  ""       ,     .        <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) {...}, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span>&gt; ) {...} );</code> </pre> <br><p>  SObjectizer-     <code>receive()</code>       .           .      .   ,      .   ,    . </p><br><p>      -.           <code>fork_t</code>     . ,  ,  . </p><br><h3 id="nit-dlya-filosofa">    </h3><br><p>       <code>philosopher_process</code> .      ,        . </p><br><div class="spoiler"> <b class="spoiler_title">  philosopher_process</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">oid </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span> pause_generator; <span class="hljs-comment"><span class="hljs-comment">//         . auto self_ch = so_5::create_mchain( control_ch-&gt;environment() ); while( meals_eaten &lt; meals_count ) { tracer.thinking_started( philosopher_index, thinking_type_t::normal ); //    . std::this_thread::sleep_for( pause_generator.think_pause( thinking_type_t::normal ) ); //    . tracer.take_left_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //   ,   . tracer.take_right_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( right_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //    .  . tracer.eating_started( philosopher_index ); //     . std::this_thread::sleep_for( pause_generator.eat_pause() ); //     . ++meals_eaten; //     . so_5::send&lt; put_t &gt;( right_fork ); } ); //     . so_5::send&lt; put_t &gt;( left_fork ); } ); } //   ,   . tracer.philosopher_done( philosopher_index ); so_5::send&lt; philosopher_done_t &gt;( control_ch, philosopher_index ); }</span></span></code> </pre> </div></div><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span></span></code> </pre> <br><p>         . </p><br><p>     SObjectizer- ,             ,       Actor-.         : </p><br><pre> <code class="cpp hljs">tracer.thinking_started( philosopher_index, <span class="hljs-keyword"><span class="hljs-keyword">thinking_type_t</span></span>::normal );</code> </pre> <br><p>   <code>tracer</code>      ,     . </p><br><p>  <code>control_ch</code>  ,       <code>philosopher_done_t</code>  ,    ,   .            . </p><br><p>  <code>left_fork</code>  <code>right_fork</code>      .        <code>take_t</code>  <code>put_t</code> .    ,     <code>mbox_t</code>  <code>mchain_t</code> ? </p><br><p>   !       ,    .    ,  mchain ‚Äî  -   mbox-,    mchain-     <code>mbox_t</code> . </p><br><p>    ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span> pause_generator; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> self_ch = so_5::create_mchain( control_ch-&gt;environment() );</code> </pre> <br><p>     ‚Äî  <code>self_ch</code> .    ,         . </p><br><p>           .  C'est-√†-dire       ,     . </p><br><p>  ,        ,       <code>this_thread::sleep_for</code>   . </p><br><p>       ,      : </p><br><pre> <code class="cpp hljs">so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index );</code> </pre> <br><p>       <code>take_t</code> .       <code>mbox_t</code> ,   <code>self_ch</code>   <code>mchain_t</code> .              <code>as_mbox()</code> . </p><br><p>     <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} );</code> </pre> <br><p>         <code>taken_t</code>    .      .  ,         . </p><br><p>  -   ,       <code>philosopher_process</code> .        <code>receive()</code>      : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) { ... so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} ); ... } );</code> </pre> <br><p>           -  . </p><br><h3 id="funkciya-zapuska-simulyacii">    </h3><br><p>             <code>run_simulation()</code> ,         .      CSP-  <code>run_simulation()</code>   .     ,       ,       (      ). </p><br><div class="spoiler"> <b class="spoiler_title">   run_simulation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> table_size = names.size(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> join_all = []( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread&gt; &amp; threads ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; t : threads ) t.join(); }; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> tracer{ env, names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() }; <span class="hljs-comment"><span class="hljs-comment">//  . std::vector&lt; so_5::mchain_t &gt; fork_chains; std::vector&lt; std::thread &gt; fork_threads( table_size ); for( std::size_t i{}; i != table_size; ++i ) { //     . fork_chains.emplace_back( so_5::create_mchain(env) ); //     . fork_threads[ i ] = std::thread{ fork_process, fork_chains.back() }; } //      . auto control_ch = so_5::create_mchain( env ); //  . const auto philosopher_maker = [&amp;](auto index, auto left_fork_idx, auto right_fork_idx) { return std::thread{ philosopher_process, std::ref(tracer), control_ch, index, fork_chains[ left_fork_idx ]-&gt;as_mbox(), fork_chains[ right_fork_idx ]-&gt;as_mbox(), default_meals_count }; }; std::vector&lt; std::thread &gt; philosopher_threads( table_size ); for( std::size_t i{}; i != table_size - 1u; ++i ) { //      . philosopher_threads[ i ] = philosopher_maker( i, i, i+1u ); } //        . philosopher_threads[ table_size - 1u ] = philosopher_maker( table_size - 1u, table_size - 1u, 0u ); //     . so_5::receive( so_5::from( control_ch ).handle_n( table_size ), [&amp;names]( so_5::mhood_t&lt;philosopher_done_t&gt; cmd ) { fmt::print( "{}: done\n", names[ cmd-&gt;m_philosopher_index ] ); } ); //     . join_all( philosopher_threads ); //     . for( auto &amp; ch : fork_chains ) so_5::close_drop_content( ch ); //       . join_all( fork_threads ); //  . tracer.done(); //   SObjectizer. env.stop(); }</span></span></code> </pre> </div></div><br><p>  ,    <code>run_simulation()</code>   - .      . </p><br><p>      .        : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> &gt; fork_chains; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; fork_threads( table_size ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size; ++i ) { fork_chains.emplace_back( so_5::create_mchain(env) ); fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, fork_chains.back() }; }</code> </pre> <br><p>       ,   ,    .         .      ,    <code>join</code>  . </p><br><p>                , ..      <code>join</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; philosopher_threads( table_size ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>; ++i ) { philosopher_threads[ i ] = philosopher_maker( i, i, i+<span class="hljs-number"><span class="hljs-number">1u</span></span> ); } philosopher_threads[ table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span> ] = philosopher_maker( table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>, table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>, <span class="hljs-number"><span class="hljs-number">0u</span></span> );</code> </pre> <br><p>          .        : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( control_ch ).handle_n( table_size ), [&amp;names]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_done_t</span></span>&gt; cmd ) { fmt::print( <span class="hljs-string"><span class="hljs-string">"{}: done\n"</span></span>, names[ cmd-&gt;m_philosopher_index ] ); } );</code> </pre> <br><p>   <code>receive()</code>      <code>table_size</code>   <code>philosopher_done_t</code> . </p><br><p>      <code>philosopher_done_t</code>    . </p><br><p>  <code>join</code>     : </p><br><pre> <code class="cpp hljs">join_all( philosopher_threads );</code> </pre> <br><p>     <code>join</code>    .    <code>join</code> , ..    .        <code>receive()</code>     .              <code>join</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ch : fork_chains ) so_5::close_drop_content( ch ); join_all( fork_threads );</code> </pre> <br><p>          . </p><br><h4 id="neskolko-slov-o-noexcept">    noexcept </h4><br><p> ,   <code>run_simulation</code>        ,      <em>noexcept</em> .   ,    exception-safety     .            ‚Äî     . </p><br><p>   <code>run_simulation</code>       ? </p><br><p>  ,                .    - exception-safety      ,    .  -  ,            : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size; ++i ) { fork_chains.emplace_back( so_5::create_mchain(env) ); fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, fork_chains.back() }; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( ... ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != fork_chains.size(); ++i ) { so_5::close_drop_content( fork_chains[ i ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fork_threads[ i ].joinable() ) fork_threads[ i ].join(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; }</code> </pre> <br><p>  ,     .  Parce que         ,       .    -   : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_threads_stuff_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> &gt; m_fork_chains; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; m_fork_threads; <span class="hljs-keyword"><span class="hljs-keyword">fork_threads_stuff_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> table_size ) : m_fork_threads( table_size ) {} ~<span class="hljs-keyword"><span class="hljs-keyword">fork_threads_stuff_t</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != m_fork_chains.size(); ++i ) { so_5::close_drop_content( m_fork_chains[ i ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_fork_threads[ i ].joinable() ) m_fork_threads[ i ].join(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != m_fork_threads.size(); ++i ) { m_fork_chains.emplace_back( so_5::create_mchain(env) ); m_fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, m_fork_chains.back() }; } } } fork_threads_stuff{ table_size }; <span class="hljs-comment"><span class="hljs-comment">//   . fork_threads_stuff.run(); //     . //       fork_threads_stuff.</span></span></code> </pre> <br><p>     ,           (, Boost- ScopeExit-, GSL- finally()   ). </p><br><p>         .       . </p><br><p> ,        exception-safety  <code>run_simulation()</code> ,   <code>run_simulation()</code>   ,    .      ,          -.       exception-safety  <code>run_simulation()</code>     <em>noexcept</em> ,     <code>std::terminate</code>    . ,          . </p><br><p>   ,   ,       ,       ,   .    ,     <code>join</code> ,            <code>join</code> .         . </p><br><h2 id="prostoe-reshenie-bez-ispolzovaniya-arbitra-oficianta">      () </h2><br><p>    ,   CSP-          ,   . </p><br><p>       <a href="" rel="nofollow"></a> . </p><br><h3 id="nit-dlya-vilki-1">    </h3><br><p>      <code>fork_process</code> ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fork_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_ch )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  :   . bool taken = false; //      . so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::mhood_t&lt;take_t&gt; cmd ) { if( taken ) so_5::send&lt; busy_t &gt;( cmd-&gt;m_who ); else { taken = true; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } }, [&amp;]( so_5::mhood_t&lt;put_t&gt; ) { if( taken ) taken = false; } ); }</span></span></code> </pre> <br><p>  ,   <code>fork_process</code> ,      (      ,      ). </p><br><h3 id="nit-dlya-filosofa-1">    </h3><br><p>      <code>philosopher_process</code> ,    ,      . </p><br><div class="spoiler"> <b class="spoiler_title">  philosopher_process</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//       . thinking_type_t thinking_type{ thinking_type_t::normal }; random_pause_generator_t pause_generator; //      . auto self_ch = so_5::create_mchain( control_ch-&gt;environment() ); while( meals_eaten &lt; meals_count ) { tracer.thinking_started( philosopher_index, thinking_type ); //    . std::this_thread::sleep_for( pause_generator.think_pause( thinking_type ) ); //  ,     . thinking_type = thinking_type_t::hungry; //    . tracer.take_left_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), []( so_5::mhood_t&lt;busy_t&gt; ) { /*     */ }, [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //   ,   . tracer.take_right_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( right_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), []( so_5::mhood_t&lt;busy_t&gt; ) { /*     */ }, [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //    ,  . tracer.eating_started( philosopher_index ); //     . std::this_thread::sleep_for( pause_generator.eat_pause() ); //     . ++meals_eaten; //      . so_5::send&lt; put_t &gt;( right_fork ); //        "normal". thinking_type = thinking_type_t::normal; } ); //       . so_5::send&lt; put_t &gt;( left_fork ); } ); } //    . tracer.philosopher_done( philosopher_index ); so_5::send&lt; philosopher_done_t &gt;( control_ch, philosopher_index ); }</span></span></code> </pre> </div></div><br><p>  -  <code>philosopher_process</code>     <code>philosopher_process</code>   .     . </p><br><p> -,   <code>thinking_type</code> .    ,      ,     ,      "" . </p><br><p> -,     <code>busy_t</code> .       <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span>&gt; ) { <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> }, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) { ... so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span>&gt; ) { <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> }, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} );</code> </pre> <br><p> ,   <code>busy_t</code> ,   ,           <code>receive()</code> ,       <code>receive()</code> .    <code>busy_t</code>    .      , ..    <code>receive()</code>   <code>busy_t</code>  .     <code>receive()</code>        <code>busy_t</code> . </p><br><h2 id="reshenie-s-oficiantom-i-vremennymi-otmetkami">       </h2><br><p>   CSP-     ,       .            ():    waiter_with_queue,      ,      waiter_with_timestamps.         :    mbox-   ,  mbox-  ,    mbox-  . </p><br><p>      CSP-  ,        <code>philosopher_process</code>   no_waiter_simple.       mchain-           ,  ? </p><br><p>  , . </p><br><p>   mchain-  .   ,       mchain-. </p><br><p>  SObjectizer-   <code>select()</code> ,    , ,    : </p><br><pre> <code class="cpp hljs">so_5::select( so_5::from_all(), case_(ch1, one_handler_1, one_handler_2, one_handler_3, ...), case_(ch2, two_handler_1, two_handler_2, two_handler_3, ...), ...);</code> </pre> <br><p>   <code>select()</code> ,            -.       " "        .   CSP-           . </p><br><p>     . </p><br><p> ,   ,     <code>take_t</code>  <code>put_t</code>      .     -   .         <code>take_t</code>  <code>put_t</code> ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extended_take_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_fork_index; <span class="hljs-keyword"><span class="hljs-keyword">extended_take_t</span></span>( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> who, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> philosopher_index, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fork_index ) : m_who{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(who) } , m_philosopher_index{ philosopher_index } , m_fork_index{ fork_index } {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extended_put_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_fork_index; <span class="hljs-keyword"><span class="hljs-keyword">extended_put_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fork_index ) : m_fork_index{ fork_index } {} };</code> </pre> <br><blockquote>  ,       <code>so_5::message_t</code> ,         (     ).         ,      SObjectizer- . </blockquote><p>    ,         .       <code>take_t</code>  <code>put_t</code> ,    <code>extended_take_t</code>  <code>extended_put_t</code> ,    . </p><br><p>      mbox.   :) </p><br><div class="spoiler"> <b class="spoiler_title">  mbox-</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wrapping_mbox_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::extra::mboxes::proxy::<span class="hljs-keyword"><span class="hljs-keyword">simple_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span> = so_5::extra::mboxes::proxy::<span class="hljs-keyword"><span class="hljs-keyword">simple_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    . const so_5::mbox_t m_target; //  ,      . const std::size_t m_fork_index; //    . static std::type_index original_take_type; static std::type_index original_put_type; public : wrapping_mbox_t( const so_5::mbox_t &amp; target, std::size_t fork_index ) : base_type_t{ target } , m_target{ target } , m_fork_index{ fork_index } {} //    so_5::abstract_message_box_t   . //       . void do_deliver_message( const std::type_index &amp; msg_type, const so_5::message_ref_t &amp; message, unsigned int overlimit_reaction_deep ) const override { if( original_take_type == msg_type ) { //     . const auto &amp; original_msg = so_5::message_payload_type&lt;::take_t&gt;:: payload_reference( *message ); //     . so_5::send&lt; extended_take_t &gt;( m_target, original_msg.m_who, original_msg.m_philosopher_index, m_fork_index ); } else if( original_put_type == msg_type ) { //     . so_5::send&lt; extended_put_t &gt;( m_target, m_fork_index ); } else base_type_t::do_deliver_message( msg_type, message, overlimit_reaction_deep ); } //       wrapping_mbox_t. static auto make( const so_5::mbox_t &amp; target, std::size_t fork_index ) { return so_5::mbox_t{ new wrapping_mbox_t{ target, fork_index } }; } }; std::type_index wrapping_mbox_t::original_take_type{ typeid(::take_t) }; std::type_index wrapping_mbox_t::original_put_type{ typeid(::put_t) };</span></span></code> </pre> </div></div><br><p>        mbox-:    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">so_5_extra</a>  ,        .           <code>so_5::abstract_message_box_t</code>      . </p><br><p>     ,    <code>wrapping_mbox_t</code> .          ,       .      wrapping_mbox,          mchain .   <code>waiter_process</code> ,      ,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waiter_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waiter_ch, details::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">waiter_logic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; logic )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        . so_5::receive( so_5::from( waiter_ch ), [&amp;]( so_5::mhood_t&lt;details::extended_take_t&gt; cmd ) { logic.on_take_fork( std::move(cmd) ); }, [&amp;]( so_5::mhood_t&lt;details::extended_put_t&gt; cmd ) { logic.on_put_fork( std::move(cmd) ); } ); }</span></span></code> </pre> <br><p>  ,               ,      .      waiter_with_timestamps <a href="" rel="nofollow"></a> . </p><br><p>       : "      <code>philosopher_process</code>  mbox-?"  ,    waiter_with_timestamps    mbox,   mchain. </p><br><p>  ,       mchain.       , ..  so_5_extra        mchain- (    ).          mbox-  mchain-. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p> , ,  ,          CSP .       ,     .   ,  ,     . ,  -   . </p><br><p>     ,   SObjectizer-.    ,         ""  SObjectizer ‚Äî  5.6,     5.5.        ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"></a> ). -   ,    SO-5.6   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"></a> (      ). </p><br><p>     ,          ! </p><br><p>  PS.  ""      ,       .        C++14. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437998/">https://habr.com/ru/post/fr437998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437988/index.html">Tutoriel React, Partie 12: Atelier, Application TODO Phase 3</a></li>
<li><a href="../fr437990/index.html">Tutoriel React Partie 13: Composants bas√©s sur les classes</a></li>
<li><a href="../fr437992/index.html">Microservices. Versioning dans les syst√®mes d'int√©gration et de d√©ploiement continus √âtude de cas CI / CD utilisant TFS</a></li>
<li><a href="../fr437994/index.html">Traite automatique et serres automatiques: comment fonctionne une petite ferme de haute technologie</a></li>
<li><a href="../fr437996/index.html">SITIS CTF: comment le phoque a aid√© CTF √† gagner</a></li>
<li><a href="../fr438000/index.html">Succ√®s et √©chec dans la cr√©ation de votre projet (d√©marrage)</a></li>
<li><a href="../fr438002/index.html">Configurer le proxy inverse pour Nextcloud et ONLYOFFICE</a></li>
<li><a href="../fr438004/index.html">Apple ou Soul Electronics: d√©fis et leadership pour les √©couteurs de fitness sans fil</a></li>
<li><a href="../fr438006/index.html">Small Business CRM: les secrets d'une mise en ≈ìuvre r√©ussie</a></li>
<li><a href="../fr438008/index.html">Configuration de l'√©quipement intelligent Zyxel en modes autonome et cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>