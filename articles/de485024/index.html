<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜé üïµüèº üò¨ Was verbirgt sich hinter den Optimierungen des GraalVM-Compilers? üñêÔ∏è üõë üë©‚Äçüë©‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir besch√§ftigen uns weiterhin mit der Arbeit von GraalVM und dieses Mal haben wir eine √úbersetzung des Artikels von Aleksandar Prokopec "Unter der Ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was verbirgt sich hinter den Optimierungen des GraalVM-Compilers?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/485024/"><p>  Wir besch√§ftigen uns weiterhin mit der Arbeit von GraalVM und dieses Mal haben wir eine √úbersetzung des Artikels von Aleksandar Prokopec "Unter der Haube von GraalVM JIT-Optimierungen", der urspr√ºnglich im <a href="https://medium.com/graalvm/under-the-hood-of-graalvm-jit-optimizations-d6e931394797">Blog auf Medium ver√∂ffentlicht wurde</a> .  Der Artikel enth√§lt einige interessante Links. Sp√§ter werden wir versuchen, diese Artikel ebenfalls zu √ºbersetzen. </p><br><p><img src="https://habrastorage.org/webt/k-/0k/fz/k-0kfzbwnfrk_hswloa6dyyftjc.jpeg"></p><br><hr><br><p>  <a href="https://medium.com/graalvm/stream-api-performance-with-graalvm-be6cfe7fbb52">Das letzte Mal bei Medium haben</a> wir uns mit Java Streams API-Leistungsproblemen bei GraalVM verglichen mit Java HotSpot VM befasst.  <a href="https://www.graalvm.org/">GraalVM</a> zeichnet sich durch hohe Leistung aus, und in diesen Experimenten haben wir eine Beschleunigung von 1,7 auf das 5-fache erreicht.  Die spezifischen Werte f√ºr die Leistungssteigerung h√§ngen nat√ºrlich immer vom ausgef√ºhrten Code und den Ladedaten ab. Bevor Sie also eine Schlussfolgerung ziehen, sollten Sie versuchen, Ihren Code auf GraalVM selbst auszuf√ºhren. </p><br><p>  In diesem Artikel werden wir uns eingehender mit GraalVM befassen und sehen, wie die JIT-Kompilierung abl√§uft. </p><br><a name="habracut"></a><br><h2>  <font color="#D93740">JIT-Optimierungen in GraalVM</font> </h2><br><p>  Schauen wir uns einige allgemeine Optimierungen an, die der GraalVM-Compiler verwendet.  In diesem Artikel werden wir nur die interessantesten Optimierungen zusammen mit spezifischen Beispielen ihrer Arbeit ansprechen.  Ein guter √úberblick √ºber die Optimierungen des GraalVM-Compilers finden Sie in der Arbeit <a href="https://www.researchgate.net/publication/320359502_Making_collection_operations_optimal_with_aggressive_JIT_compilation">‚ÄûOptimale Erfassungsvorg√§nge durch aggressive JIT-Kompilierung‚Äú</a> . </p><br><h2>  <font color="#D93740">Inlining</font> </h2><br><p>  Wenn Sie die Assembly nicht vorzeitig ber√ºhren, f√ºhren die meisten JIT-Compiler in modernen virtuellen Maschinen eine interne Analyse durch.  Dies bedeutet, dass zu jedem bestimmten Zeitpunkt eine Analyse einer Methode vorliegt.  Aus diesem Grund ist die intraprocedurale Analyse viel schneller als die interprocedurale Analyse des gesamten Programms, f√ºr die in der f√ºr die Arbeit des JIT-Compilers vorgesehenen Zeit normalerweise keine Zeit zur Verf√ºgung steht.  In einem Compiler, der prozedurale Optimierungen verwendet (z. B. jeweils eine Methode optimieren), ist Inlining eine der wichtigsten grundlegenden Optimierungen.  Inlining ist wichtig, da es die Methode effektiv erh√∂ht, was bedeutet, dass der Compiler mehr M√∂glichkeiten zur gleichzeitigen Optimierung mehrerer Codeteile sieht, die in scheinbar nicht verwandten Methoden verwendet werden. </p><br><p> Nehmen Sie zum Beispiel die <code>volleyballStars</code> Methode aus einem vorherigen Artikel: </p><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volleyballStars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.stream(people) .map(p -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(p.hair, p.age + <span class="hljs-number"><span class="hljs-number">1</span></span>, p.height)) .filter(p -&gt; p.height &gt; <span class="hljs-number"><span class="hljs-number">198</span></span>) .filter(p -&gt; p.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span> &amp;&amp; p.age &lt;= <span class="hljs-number"><span class="hljs-number">21</span></span>) .mapToInt(p -&gt; p.age) .average().getAsDouble(); }</code> </pre> <br><p>  In diesem Diagramm sehen wir Teile der Intermediate Representation (IR) dieser Methode in GraalVM, unmittelbar nach dem Parsen des entsprechenden Java-Bytecodes. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1cb/b4f/fd1/1cbb4ffd15a4c171de823accd8830071.png"></p><br><p>  Sie k√∂nnen sich diese IR als eine Art <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstrakten Syntaxbaum</a> f√ºr Steroide vorstellen - dank ihr sind einige Optimierungen einfacher durchzuf√ºhren.  Es spielt keine Rolle, wie diese IR funktioniert, aber wenn Sie dieses Thema genauer verstehen m√∂chten, k√∂nnen Sie sich ein Dokument mit dem Titel <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.726.5496%26amp%3Brep%3Drep1%26amp%3Btype%3Dpdf">"Graal IR: Eine erweiterbare deklarative Zwischendarstellung"</a> ansehen. </p><br><p>  Die Hauptschlussfolgerung hier ist, dass der Steuerfluss der Methode, der durch die gelben Knoten des Diagramms und die roten Linien angegeben wird, die Methoden der <code>Stream</code> Schnittstelle sequentiell ausf√ºhrt: <code>Stream.filter</code> , <code>Stream.mapToInt</code> , <code>IntStream.average</code> .  Der Compiler ist nicht in der Lage, die Methode zu vereinfachen, da er nicht genau wei√ü, was im Code dieser Methoden enthalten ist - und hier hilft Inlining! </p><br><p>  Eine Transformation namens Inlining ist sehr verst√§ndlich: Sie sucht nur nach Orten, an denen Methoden aufgerufen werden, ersetzt diese durch den Text der entsprechenden Inline-Methode und bettet sie ein.  Schauen wir uns das IR der <code>volleyballStars</code> Methode an, nachdem wir einen Teil der Methoden eingef√ºgt haben.  Hier wird nur der Teil <code>IntStream.average</code> , der auf den <code>IntStream.average</code> Aufruf folgt: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d5a/717/c71/d5a717c711a64a653ae7784f5557a2e5.png"></p><br><p>  Das Diagramm zeigt, dass der Aufruf von <code>getAsDouble</code> (Knotennummer 71) aus dem IR verschwunden ist.  Beachten Sie, dass die <code>getAsDouble</code> Methode des von <code>IntStream.average</code> (dem letzten Aufruf der <code>volleyballStars</code> Methode) zur√ºckgegebenen <code>getAsDouble</code> Objekts im JDK wie folgt definiert ist: </p><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAsDouble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPresent) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"No value present"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; }</code> </pre> <br><p>  Hier finden wir das Laden des <code>isPresent</code> Feldes (Knotennummer 190, <code>LoadField</code> ) und das Lesen des <code>LoadField</code> .  Von der <code>NoSuchElementException</code> Ausnahme ist jedoch keine Spur mehr <code>NoSuchElementException</code> , und es gibt keinen Code mehr, der sie <code>NoSuchElementException</code> . </p><br><p>  Dies liegt daran, dass der GraalVM-Compiler vermutet, dass die <code>volleyballStars</code> Methode niemals eine Ausnahme ausl√∂st.  Dieses Wissen ist normalerweise w√§hrend der <code>getAsDouble</code> Kompilierung nicht verf√ºgbar - es kann von vielen verschiedenen Stellen im Programm aufgerufen werden, und in anderen F√§llen funktioniert die Ausnahme weiterhin.  Bei einer bestimmten <code>volleyballStars</code> Methode ist es jedoch unwahrscheinlich, dass eine Ausnahme auftritt, da die Menge der potenziellen Volleyballsterne niemals leer ist.  Aus diesem Grund entfernt GraalVM die Verzweigung und f√ºgt <code>FixedGuard</code> - einen Knoten, der den Code im Falle eines Versto√ües gegen unsere Annahme <code>FixedGuard</code> .  Dies ist ein ziemlich minimalistisches Beispiel, und im wirklichen Leben gibt es viel kompliziertere F√§lle, in denen Inlining anderen Optimierungen hilft. </p><br><p>  Wir wissen, dass der Programmaufrufbaum normalerweise sehr tief oder sogar endlos ist.  Das Inlining muss also irgendwann gestoppt werden - es unterliegt ganz bestimmten Einschr√§nkungen in Bezug auf Betriebszeit und Speichergr√∂√üe.  Wenn man das wei√ü, wird klar: Es ist sehr schwierig zu bestimmen, was und wann inline zu stellen ist. </p><br><h2>  <font color="#D93740">Polymorphes Inlining</font> </h2><br><p>  Inlining funktioniert nur, wenn der Compiler die bestimmte Methode ermitteln kann, auf die sich die Methodenaufrufoperation bezieht.  In Java gibt es jedoch in der Regel viele indirekte Aufrufe f√ºr Methoden, deren Implementierungen in der Statik unbekannt sind und die zur Laufzeit mithilfe von Virtual Dispatch durchsucht werden. </p><br><p>  Nehmen Sie zum Beispiel die <code>IntStream.average</code> Methode.  Die typische Implementierung sieht folgenderma√üen aus: </p><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> OptionalDouble </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[] avg = collect( () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>], (ll, i) -&gt; { ll[<span class="hljs-number"><span class="hljs-number">0</span></span>]++; ll[<span class="hljs-number"><span class="hljs-number">1</span></span>] += i; }, (ll, rr) -&gt; { ll[<span class="hljs-number"><span class="hljs-number">0</span></span>] += rr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ll[<span class="hljs-number"><span class="hljs-number">1</span></span>] += rr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> avg[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? OptionalDouble.of((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) avg[<span class="hljs-number"><span class="hljs-number">1</span></span>] / avg[<span class="hljs-number"><span class="hljs-number">0</span></span>]) : OptionalDouble.empty(); }</code> </pre> <br><p>  Lassen Sie sich nicht von der scheinbaren Einfachheit des Codes t√§uschen!  Diese Methode ist in Bezug auf das <code>collect</code> Anrufen definiert, und die Magie geschieht hier.  Der Aufrufbaum dieser Methode (z. B. die Aufrufhierarchie) w√§chst schnell, je tiefer wir in das <code>collect</code> .  Schauen Sie sich einfach dieses Diagramm an: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/584/306/ce3/584306ce380584ae1266e1026040389f.png"></p><br><p>  Ab einem bestimmten Zeitpunkt beim Durchlaufen des <code>opWrapSink</code> wird der Inliner mit dem <code>opWrapSink</code> Aufruf aus dem Java- <code>opWrapSink</code> Framework in Verbindung gebracht. <code>opWrapSink</code> ist eine abstrakte Methode: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/be4/43b/b46/be443bb464f938c962b8649ef26de75d.png"></p><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function">&lt;P_IN&gt; Sink&lt;P_IN&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapSink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sink&lt;P_OUT&gt; sink)</span></span></span></span>;</code> </pre> <br><p>  Normalerweise geht ein Inliner nicht weiter, da es sich um einen indirekten Aufruf handelt.  Die Bestimmung einer bestimmten Methode erfolgt nur w√§hrend der Ausf√ºhrung des Programms, und jetzt wei√ü der Inlayner einfach nicht, woran er als n√§chstes arbeiten soll. </p><br><p>  Im Fall von GraalVM passiert noch etwas anderes: F√ºr jeden Peer mit indirekter Wahl wird ein Typprofil der Zielmethode gespeichert.  Dieses Profil ist im Wesentlichen nur eine Tabelle, die <code>wrapSink</code> , wie oft die einzelnen <code>wrapSink</code> Implementierungen <code>wrapSink</code> .  In unserem Fall kennt das Profil drei verschiedene Implementierungen in anonymen Klassen: <code>ReferencePipeline$2</code> , <code>ReferencePipeline$3</code> , <code>ReferencePipeline$4</code> .  Diese Implementierungen werden mit einer Wahrscheinlichkeit von 50%, 25% bzw. 25% aufgerufen. </p><br><br><pre> <code class="plaintext hljs">0.500000: Ljava/util/stream/ReferencePipeline$2; 0.250000: Ljava/util/stream/ReferencePipeline$4; 0.250000: Ljava/util/stream/ReferencePipeline$3; notRecorded: 0.000000</code> </pre><br><p>  Diese Informationen sind f√ºr den Compiler von unsch√§tzbarem Wert. Sie erm√∂glichen es Ihnen, einen <em>Typwechsel</em> zu generieren - eine kurze <code>switch</code> , die den Typ der Methode zur Laufzeit √ºberpr√ºft und dann f√ºr jeden der oben genannten F√§lle eine bestimmte Methode aufruft.  Das folgende Bild zeigt einen Teil der Zwischenansicht, in der der Typschalter (drei <code>if</code> Knoten) mit einer √úberpr√ºfung angezeigt wird, ob der Empf√§ngertyp eine Person aus <code>ReferencePipeline$2</code> , <code>ReferencePipeline$3</code> oder <code>ReferencePipeline$4</code> .  Jeder direkte Aufruf in der erfolgreichen Verzweigung jeder der <code>InstanceOf</code> Pr√ºfungen kann jetzt inline erfolgen oder einige zus√§tzliche Optimierungen damit verbinden.  Wenn keiner der Typen den Test besteht, wird der Code im Knoten <code>Deopt</code> deoptimiert (alternativ k√∂nnen Sie den virtuellen Versand ausf√ºhren). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/26e/688/ca8/26e688ca89ea6c397b72f9acaba08ff3.png"></p><br><p>  Wenn Sie mehr √ºber polymorphes Inlining erfahren m√∂chten, empfehle ich die klassische Arbeit zu diesem Thema, <a href="https://dl.acm.org/citation.cfm%3Fid%3D679839">"Inlining von virtuellen Methoden"</a> . </p><br><h2>  <font color="#D93740">Partielle Fluchtanalyse</font> </h2><br><p>  Kehren wir zu unserem Volleyball-Beispiel zur√ºck.  Beachten Sie, dass keines der im Lambda zugewiesenen <code>Person</code> die an die <code>map</code> dem Geltungsbereich der <code>volleyballStars</code> Methode entgeht.  Mit anderen Worten, zum Zeitpunkt des Endes der <code>volleyballStars</code> Methode gibt es keinen Speicherbereich, der auf Objekte vom Typ <code>Person</code> verweisen w√ºrde.  Insbesondere wird der Datensatz des <code>getHeight</code> Werts nur f√ºr die <code>getHeight</code> verwendet. </p><br><p>  Irgendwann w√§hrend der Erstellung der <code>volleyballStars</code> Methode kommen wir zu dem in der folgenden Abbildung gezeigten IR.  Der Block, der mit dem <code>Begin</code> Knoten -1621 beginnt, beginnt mit der Zuweisung des <code>Person</code> Objekts (im <code>Alloc</code> Knoten), das sowohl mit dem Wert des <code>Alloc</code> mit einem Inkrement von 1 als auch mit dem vorherigen Wert des <code>height</code> initialisiert wird.  Das <code>height</code> zuvor im <code>LoadField</code> -1539-Knoten gelesen.  Das Ergebnis der Zuordnung wird in AllocatedObject -2137 gekapselt und an den Methodenaufruf <code>accept</code> -1625 gesendet.  Der Compiler kann im Moment nichts mehr tun - aus seiner Sicht ist das Objekt der <code>volleyballStars</code> Methode entkommen.  ( <em>Anmerkung des √úbersetzers: ‚ÄûEin Objekt weglaufen lassen‚Äú wird im Englischen als ‚ÄûEscape‚Äú bezeichnet, daher lautet der Name der Optimierung ‚ÄûEscape-Analyse‚Äú.</em> ) </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a02/cca/495/a02cca495ad607770a0111040e0a724a.png"></p><br><p>  Danach beschlie√üt der Compiler, den Aufruf <code>accept</code> inline zu setzen - dies scheint sinnvoll.  Als Ergebnis kommen wir zu folgendem IR: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/334/5b9/029/3345b90295b77a64ded506f3042a146a.png"></p><br><p>  Und hier startet der JIT-Compiler eine partielle Escape-Analyse: Er stellt fest, dass <code>AllocatedObject</code> nur zum Lesen des <code>height</code> wird (R√ºckruf, <code>height</code> nur unter Filterbedingungen verwendet, pr√ºfen Sie, ob die H√∂he gr√∂√üer als 198 ist).  Daher kann der Compiler den Wert des Felds <code>height</code> -2167 neu zuweisen, um direkt mit dem Knoten zu arbeiten, der zuvor in das Objekt <code>Person</code> (Knoten <code>Alloc</code> -2136). Dies ist unser <code>LoadField</code> -1539.  Dar√ºber hinaus wird der <code>Alloc</code> Knoten nicht an die Eingabe eines anderen Knotens weitergeleitet, sodass Sie ihn einfach l√∂schen k√∂nnen - dies ist toter Code! </p><br><p>  Diese Optimierung ist in der Tat der Hauptgrund, warum das <code>volleyballStars</code> Beispiel nach dem Wechsel zu GraalVM eine f√ºnffache Beschleunigung erfahren hat.  Auch wenn nicht alle <code>Person</code> ben√∂tigt werden und sofort nach der Erstellung verworfen werden, m√ºssen sie dennoch auf dem Heap zugewiesen werden, ihr Speicher muss jedoch noch initialisiert werden.  Mithilfe der partiellen Escape-Analyse k√∂nnen Sie Zuweisungen aufheben oder verschieben, indem Sie sie in die Codezweige verschieben, in denen Objekte wirklich weglaufen und die viel seltener vorkommen. </p><br><p>  In einem Artikel mit dem Titel <a href="http://www.ssw.uni-linz.ac.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf">Partial Escape Analysis und Scalar Replacement for Java</a> erhalten Sie ein tieferes Verst√§ndnis der partiellen Escape-Analyse. </p><br><h2>  <font color="#D93740">Zusammenfassung</font> </h2><br><p>  In diesem Artikel haben wir uns drei GraalVM-Optimierungen angesehen: Inlining, polymorphes Inlining und partielle Escape-Analyse.  Es gibt noch viele weitere Optimierungen: Heraufstufen und Aufteilen von Zyklen, Duplizieren von Pfaden, Nummerieren von globalen Werten, Faltung von Konstanten, Entfernen von totem Code, spekulative Ausf√ºhrung und so weiter. </p><br><p>  Wenn Sie mehr √ºber die Funktionsweise von GraalVM erfahren m√∂chten, z√∂gern Sie nicht, die <a href="http://www.graalvm.org/community/publications/">Publikationsseite</a> zu √∂ffnen.  Wenn Sie sicherstellen m√∂chten, dass GraalVM Ihren Code beschleunigt, k√∂nnen Sie <a href="https://www.graalvm.org/downloads/">die Bin√§rdateien herunterladen</a> und selbst ausprobieren. </p><br><hr><br><h2>  <font color="#D93740">Vom √úbersetzer: zus√§tzliche Materialien</font> </h2><br>  JPoint und Joker sprechen auf Konferenzen h√§ufig √ºber GraalVM.  So besuchten uns zuletzt im JPoint 2019 Thomas W√ºrthinger (Research Director bei Oracle Labs, verantwortlich f√ºr GraalVM) und Oleg Shelaev, einer der beiden offiziellen Technologieevangelisten. <br><br>  Sie k√∂nnen diese und andere Videos auf unserem YouTube-Kanal ansehen: <br><br><ul><li>  Thomas W√ºrthinger: <a href="https://www.youtube.com/watch%3Fv%3DR_SeDk16PLY">‚ÄûLeistung maximieren mit GraalVM‚Äú</a> </li><li>  Oleg Shelaev: <a href="https://www.youtube.com/watch%3Fv%3DC5fATKdVxZ0">"Supercompilation, Teilevaluation, Futamura-Projektionen und wie GraalVM die Welt retten wird"</a> </li><li>  Roberto Cortez: <a href="https://www.youtube.com/watch%3Fv%3DoY8sfg7A1kg">‚ÄûGraalVM und MicroProfile: Eine L√∂sung f√ºr mehrsprachige Microservices‚Äú</a> </li><li>  Ionut Balosin: <a href="https://www.youtube.com/watch%3Fv%3DRYLEIRHWsVo">‚ÄûEin Rennen zweier Compiler: GraalVM JIT gegen HotSpot JIT C2.</a>  <a href="https://www.youtube.com/watch%3Fv%3DRYLEIRHWsVo">Welches bietet eine bessere Laufzeitleistung? ‚Äú</a> </li></ul><br><blockquote>  Wir erinnern Sie daran, dass der n√§chste JPoint vom 15. bis 16. Mai 2020 in Moskau stattfindet und Tickets bereits <a href="https://jpoint.ru/registration/%3Futm_source%3Dhabr%26utm_medium%3D485024%26utm_campaign%3Djpoint20">auf der offiziellen Website gekauft werden k√∂nnen</a> . </blockquote><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485024/">https://habr.com/ru/post/de485024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485012/index.html">Verwendung von Control Inversion in JavaScript und Reactjs zur Vereinfachung der Codebehandlung</a></li>
<li><a href="../de485014/index.html">Soll ich mich √ºber Interviews beschweren?</a></li>
<li><a href="../de485016/index.html">Verwaltete Datenbanken bei Selectel: Willkommen bei Beta</a></li>
<li><a href="../de485018/index.html">Schreiben von Shadern mit Code in Unity LWRP</a></li>
<li><a href="../de485022/index.html">Playme Sigma: Funktioneller und erschwinglicher DVR</a></li>
<li><a href="../de485026/index.html">Georgiens Chancen f√ºr IT-Profis</a></li>
<li><a href="../de485028/index.html">CRM 2020</a></li>
<li><a href="../de485030/index.html">Top 8 IEO Geb√ºhren und deren Aktivierung jetzt</a></li>
<li><a href="../de485032/index.html">Schnelleres Reagieren mit staatlichem Co-Hosting</a></li>
<li><a href="../de485034/index.html">Automatisieren der Erstellung eines Qt-Projekts unter Windows in Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>