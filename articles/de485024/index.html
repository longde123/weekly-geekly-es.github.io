<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆎 🕵🏼 😬 Was verbirgt sich hinter den Optimierungen des GraalVM-Compilers? 🖐️ 🛑 👩‍👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir beschäftigen uns weiterhin mit der Arbeit von GraalVM und dieses Mal haben wir eine Übersetzung des Artikels von Aleksandar Prokopec "Unter der Ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was verbirgt sich hinter den Optimierungen des GraalVM-Compilers?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/485024/"><p>  Wir beschäftigen uns weiterhin mit der Arbeit von GraalVM und dieses Mal haben wir eine Übersetzung des Artikels von Aleksandar Prokopec "Unter der Haube von GraalVM JIT-Optimierungen", der ursprünglich im <a href="https://medium.com/graalvm/under-the-hood-of-graalvm-jit-optimizations-d6e931394797">Blog auf Medium veröffentlicht wurde</a> .  Der Artikel enthält einige interessante Links. Später werden wir versuchen, diese Artikel ebenfalls zu übersetzen. </p><br><p><img src="https://habrastorage.org/webt/k-/0k/fz/k-0kfzbwnfrk_hswloa6dyyftjc.jpeg"></p><br><hr><br><p>  <a href="https://medium.com/graalvm/stream-api-performance-with-graalvm-be6cfe7fbb52">Das letzte Mal bei Medium haben</a> wir uns mit Java Streams API-Leistungsproblemen bei GraalVM verglichen mit Java HotSpot VM befasst.  <a href="https://www.graalvm.org/">GraalVM</a> zeichnet sich durch hohe Leistung aus, und in diesen Experimenten haben wir eine Beschleunigung von 1,7 auf das 5-fache erreicht.  Die spezifischen Werte für die Leistungssteigerung hängen natürlich immer vom ausgeführten Code und den Ladedaten ab. Bevor Sie also eine Schlussfolgerung ziehen, sollten Sie versuchen, Ihren Code auf GraalVM selbst auszuführen. </p><br><p>  In diesem Artikel werden wir uns eingehender mit GraalVM befassen und sehen, wie die JIT-Kompilierung abläuft. </p><br><a name="habracut"></a><br><h2>  <font color="#D93740">JIT-Optimierungen in GraalVM</font> </h2><br><p>  Schauen wir uns einige allgemeine Optimierungen an, die der GraalVM-Compiler verwendet.  In diesem Artikel werden wir nur die interessantesten Optimierungen zusammen mit spezifischen Beispielen ihrer Arbeit ansprechen.  Ein guter Überblick über die Optimierungen des GraalVM-Compilers finden Sie in der Arbeit <a href="https://www.researchgate.net/publication/320359502_Making_collection_operations_optimal_with_aggressive_JIT_compilation">„Optimale Erfassungsvorgänge durch aggressive JIT-Kompilierung“</a> . </p><br><h2>  <font color="#D93740">Inlining</font> </h2><br><p>  Wenn Sie die Assembly nicht vorzeitig berühren, führen die meisten JIT-Compiler in modernen virtuellen Maschinen eine interne Analyse durch.  Dies bedeutet, dass zu jedem bestimmten Zeitpunkt eine Analyse einer Methode vorliegt.  Aus diesem Grund ist die intraprocedurale Analyse viel schneller als die interprocedurale Analyse des gesamten Programms, für die in der für die Arbeit des JIT-Compilers vorgesehenen Zeit normalerweise keine Zeit zur Verfügung steht.  In einem Compiler, der prozedurale Optimierungen verwendet (z. B. jeweils eine Methode optimieren), ist Inlining eine der wichtigsten grundlegenden Optimierungen.  Inlining ist wichtig, da es die Methode effektiv erhöht, was bedeutet, dass der Compiler mehr Möglichkeiten zur gleichzeitigen Optimierung mehrerer Codeteile sieht, die in scheinbar nicht verwandten Methoden verwendet werden. </p><br><p> Nehmen Sie zum Beispiel die <code>volleyballStars</code> Methode aus einem vorherigen Artikel: </p><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volleyballStars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.stream(people) .map(p -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(p.hair, p.age + <span class="hljs-number"><span class="hljs-number">1</span></span>, p.height)) .filter(p -&gt; p.height &gt; <span class="hljs-number"><span class="hljs-number">198</span></span>) .filter(p -&gt; p.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span> &amp;&amp; p.age &lt;= <span class="hljs-number"><span class="hljs-number">21</span></span>) .mapToInt(p -&gt; p.age) .average().getAsDouble(); }</code> </pre> <br><p>  In diesem Diagramm sehen wir Teile der Intermediate Representation (IR) dieser Methode in GraalVM, unmittelbar nach dem Parsen des entsprechenden Java-Bytecodes. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1cb/b4f/fd1/1cbb4ffd15a4c171de823accd8830071.png"></p><br><p>  Sie können sich diese IR als eine Art <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstrakten Syntaxbaum</a> für Steroide vorstellen - dank ihr sind einige Optimierungen einfacher durchzuführen.  Es spielt keine Rolle, wie diese IR funktioniert, aber wenn Sie dieses Thema genauer verstehen möchten, können Sie sich ein Dokument mit dem Titel <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.726.5496%26amp%3Brep%3Drep1%26amp%3Btype%3Dpdf">"Graal IR: Eine erweiterbare deklarative Zwischendarstellung"</a> ansehen. </p><br><p>  Die Hauptschlussfolgerung hier ist, dass der Steuerfluss der Methode, der durch die gelben Knoten des Diagramms und die roten Linien angegeben wird, die Methoden der <code>Stream</code> Schnittstelle sequentiell ausführt: <code>Stream.filter</code> , <code>Stream.mapToInt</code> , <code>IntStream.average</code> .  Der Compiler ist nicht in der Lage, die Methode zu vereinfachen, da er nicht genau weiß, was im Code dieser Methoden enthalten ist - und hier hilft Inlining! </p><br><p>  Eine Transformation namens Inlining ist sehr verständlich: Sie sucht nur nach Orten, an denen Methoden aufgerufen werden, ersetzt diese durch den Text der entsprechenden Inline-Methode und bettet sie ein.  Schauen wir uns das IR der <code>volleyballStars</code> Methode an, nachdem wir einen Teil der Methoden eingefügt haben.  Hier wird nur der Teil <code>IntStream.average</code> , der auf den <code>IntStream.average</code> Aufruf folgt: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d5a/717/c71/d5a717c711a64a653ae7784f5557a2e5.png"></p><br><p>  Das Diagramm zeigt, dass der Aufruf von <code>getAsDouble</code> (Knotennummer 71) aus dem IR verschwunden ist.  Beachten Sie, dass die <code>getAsDouble</code> Methode des von <code>IntStream.average</code> (dem letzten Aufruf der <code>volleyballStars</code> Methode) zurückgegebenen <code>getAsDouble</code> Objekts im JDK wie folgt definiert ist: </p><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAsDouble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPresent) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"No value present"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; }</code> </pre> <br><p>  Hier finden wir das Laden des <code>isPresent</code> Feldes (Knotennummer 190, <code>LoadField</code> ) und das Lesen des <code>LoadField</code> .  Von der <code>NoSuchElementException</code> Ausnahme ist jedoch keine Spur mehr <code>NoSuchElementException</code> , und es gibt keinen Code mehr, der sie <code>NoSuchElementException</code> . </p><br><p>  Dies liegt daran, dass der GraalVM-Compiler vermutet, dass die <code>volleyballStars</code> Methode niemals eine Ausnahme auslöst.  Dieses Wissen ist normalerweise während der <code>getAsDouble</code> Kompilierung nicht verfügbar - es kann von vielen verschiedenen Stellen im Programm aufgerufen werden, und in anderen Fällen funktioniert die Ausnahme weiterhin.  Bei einer bestimmten <code>volleyballStars</code> Methode ist es jedoch unwahrscheinlich, dass eine Ausnahme auftritt, da die Menge der potenziellen Volleyballsterne niemals leer ist.  Aus diesem Grund entfernt GraalVM die Verzweigung und fügt <code>FixedGuard</code> - einen Knoten, der den Code im Falle eines Verstoßes gegen unsere Annahme <code>FixedGuard</code> .  Dies ist ein ziemlich minimalistisches Beispiel, und im wirklichen Leben gibt es viel kompliziertere Fälle, in denen Inlining anderen Optimierungen hilft. </p><br><p>  Wir wissen, dass der Programmaufrufbaum normalerweise sehr tief oder sogar endlos ist.  Das Inlining muss also irgendwann gestoppt werden - es unterliegt ganz bestimmten Einschränkungen in Bezug auf Betriebszeit und Speichergröße.  Wenn man das weiß, wird klar: Es ist sehr schwierig zu bestimmen, was und wann inline zu stellen ist. </p><br><h2>  <font color="#D93740">Polymorphes Inlining</font> </h2><br><p>  Inlining funktioniert nur, wenn der Compiler die bestimmte Methode ermitteln kann, auf die sich die Methodenaufrufoperation bezieht.  In Java gibt es jedoch in der Regel viele indirekte Aufrufe für Methoden, deren Implementierungen in der Statik unbekannt sind und die zur Laufzeit mithilfe von Virtual Dispatch durchsucht werden. </p><br><p>  Nehmen Sie zum Beispiel die <code>IntStream.average</code> Methode.  Die typische Implementierung sieht folgendermaßen aus: </p><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> OptionalDouble </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[] avg = collect( () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>], (ll, i) -&gt; { ll[<span class="hljs-number"><span class="hljs-number">0</span></span>]++; ll[<span class="hljs-number"><span class="hljs-number">1</span></span>] += i; }, (ll, rr) -&gt; { ll[<span class="hljs-number"><span class="hljs-number">0</span></span>] += rr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ll[<span class="hljs-number"><span class="hljs-number">1</span></span>] += rr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> avg[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? OptionalDouble.of((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) avg[<span class="hljs-number"><span class="hljs-number">1</span></span>] / avg[<span class="hljs-number"><span class="hljs-number">0</span></span>]) : OptionalDouble.empty(); }</code> </pre> <br><p>  Lassen Sie sich nicht von der scheinbaren Einfachheit des Codes täuschen!  Diese Methode ist in Bezug auf das <code>collect</code> Anrufen definiert, und die Magie geschieht hier.  Der Aufrufbaum dieser Methode (z. B. die Aufrufhierarchie) wächst schnell, je tiefer wir in das <code>collect</code> .  Schauen Sie sich einfach dieses Diagramm an: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/584/306/ce3/584306ce380584ae1266e1026040389f.png"></p><br><p>  Ab einem bestimmten Zeitpunkt beim Durchlaufen des <code>opWrapSink</code> wird der Inliner mit dem <code>opWrapSink</code> Aufruf aus dem Java- <code>opWrapSink</code> Framework in Verbindung gebracht. <code>opWrapSink</code> ist eine abstrakte Methode: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/be4/43b/b46/be443bb464f938c962b8649ef26de75d.png"></p><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function">&lt;P_IN&gt; Sink&lt;P_IN&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapSink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sink&lt;P_OUT&gt; sink)</span></span></span></span>;</code> </pre> <br><p>  Normalerweise geht ein Inliner nicht weiter, da es sich um einen indirekten Aufruf handelt.  Die Bestimmung einer bestimmten Methode erfolgt nur während der Ausführung des Programms, und jetzt weiß der Inlayner einfach nicht, woran er als nächstes arbeiten soll. </p><br><p>  Im Fall von GraalVM passiert noch etwas anderes: Für jeden Peer mit indirekter Wahl wird ein Typprofil der Zielmethode gespeichert.  Dieses Profil ist im Wesentlichen nur eine Tabelle, die <code>wrapSink</code> , wie oft die einzelnen <code>wrapSink</code> Implementierungen <code>wrapSink</code> .  In unserem Fall kennt das Profil drei verschiedene Implementierungen in anonymen Klassen: <code>ReferencePipeline$2</code> , <code>ReferencePipeline$3</code> , <code>ReferencePipeline$4</code> .  Diese Implementierungen werden mit einer Wahrscheinlichkeit von 50%, 25% bzw. 25% aufgerufen. </p><br><br><pre> <code class="plaintext hljs">0.500000: Ljava/util/stream/ReferencePipeline$2; 0.250000: Ljava/util/stream/ReferencePipeline$4; 0.250000: Ljava/util/stream/ReferencePipeline$3; notRecorded: 0.000000</code> </pre><br><p>  Diese Informationen sind für den Compiler von unschätzbarem Wert. Sie ermöglichen es Ihnen, einen <em>Typwechsel</em> zu generieren - eine kurze <code>switch</code> , die den Typ der Methode zur Laufzeit überprüft und dann für jeden der oben genannten Fälle eine bestimmte Methode aufruft.  Das folgende Bild zeigt einen Teil der Zwischenansicht, in der der Typschalter (drei <code>if</code> Knoten) mit einer Überprüfung angezeigt wird, ob der Empfängertyp eine Person aus <code>ReferencePipeline$2</code> , <code>ReferencePipeline$3</code> oder <code>ReferencePipeline$4</code> .  Jeder direkte Aufruf in der erfolgreichen Verzweigung jeder der <code>InstanceOf</code> Prüfungen kann jetzt inline erfolgen oder einige zusätzliche Optimierungen damit verbinden.  Wenn keiner der Typen den Test besteht, wird der Code im Knoten <code>Deopt</code> deoptimiert (alternativ können Sie den virtuellen Versand ausführen). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/26e/688/ca8/26e688ca89ea6c397b72f9acaba08ff3.png"></p><br><p>  Wenn Sie mehr über polymorphes Inlining erfahren möchten, empfehle ich die klassische Arbeit zu diesem Thema, <a href="https://dl.acm.org/citation.cfm%3Fid%3D679839">"Inlining von virtuellen Methoden"</a> . </p><br><h2>  <font color="#D93740">Partielle Fluchtanalyse</font> </h2><br><p>  Kehren wir zu unserem Volleyball-Beispiel zurück.  Beachten Sie, dass keines der im Lambda zugewiesenen <code>Person</code> die an die <code>map</code> dem Geltungsbereich der <code>volleyballStars</code> Methode entgeht.  Mit anderen Worten, zum Zeitpunkt des Endes der <code>volleyballStars</code> Methode gibt es keinen Speicherbereich, der auf Objekte vom Typ <code>Person</code> verweisen würde.  Insbesondere wird der Datensatz des <code>getHeight</code> Werts nur für die <code>getHeight</code> verwendet. </p><br><p>  Irgendwann während der Erstellung der <code>volleyballStars</code> Methode kommen wir zu dem in der folgenden Abbildung gezeigten IR.  Der Block, der mit dem <code>Begin</code> Knoten -1621 beginnt, beginnt mit der Zuweisung des <code>Person</code> Objekts (im <code>Alloc</code> Knoten), das sowohl mit dem Wert des <code>Alloc</code> mit einem Inkrement von 1 als auch mit dem vorherigen Wert des <code>height</code> initialisiert wird.  Das <code>height</code> zuvor im <code>LoadField</code> -1539-Knoten gelesen.  Das Ergebnis der Zuordnung wird in AllocatedObject -2137 gekapselt und an den Methodenaufruf <code>accept</code> -1625 gesendet.  Der Compiler kann im Moment nichts mehr tun - aus seiner Sicht ist das Objekt der <code>volleyballStars</code> Methode entkommen.  ( <em>Anmerkung des Übersetzers: „Ein Objekt weglaufen lassen“ wird im Englischen als „Escape“ bezeichnet, daher lautet der Name der Optimierung „Escape-Analyse“.</em> ) </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a02/cca/495/a02cca495ad607770a0111040e0a724a.png"></p><br><p>  Danach beschließt der Compiler, den Aufruf <code>accept</code> inline zu setzen - dies scheint sinnvoll.  Als Ergebnis kommen wir zu folgendem IR: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/334/5b9/029/3345b90295b77a64ded506f3042a146a.png"></p><br><p>  Und hier startet der JIT-Compiler eine partielle Escape-Analyse: Er stellt fest, dass <code>AllocatedObject</code> nur zum Lesen des <code>height</code> wird (Rückruf, <code>height</code> nur unter Filterbedingungen verwendet, prüfen Sie, ob die Höhe größer als 198 ist).  Daher kann der Compiler den Wert des Felds <code>height</code> -2167 neu zuweisen, um direkt mit dem Knoten zu arbeiten, der zuvor in das Objekt <code>Person</code> (Knoten <code>Alloc</code> -2136). Dies ist unser <code>LoadField</code> -1539.  Darüber hinaus wird der <code>Alloc</code> Knoten nicht an die Eingabe eines anderen Knotens weitergeleitet, sodass Sie ihn einfach löschen können - dies ist toter Code! </p><br><p>  Diese Optimierung ist in der Tat der Hauptgrund, warum das <code>volleyballStars</code> Beispiel nach dem Wechsel zu GraalVM eine fünffache Beschleunigung erfahren hat.  Auch wenn nicht alle <code>Person</code> benötigt werden und sofort nach der Erstellung verworfen werden, müssen sie dennoch auf dem Heap zugewiesen werden, ihr Speicher muss jedoch noch initialisiert werden.  Mithilfe der partiellen Escape-Analyse können Sie Zuweisungen aufheben oder verschieben, indem Sie sie in die Codezweige verschieben, in denen Objekte wirklich weglaufen und die viel seltener vorkommen. </p><br><p>  In einem Artikel mit dem Titel <a href="http://www.ssw.uni-linz.ac.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf">Partial Escape Analysis und Scalar Replacement for Java</a> erhalten Sie ein tieferes Verständnis der partiellen Escape-Analyse. </p><br><h2>  <font color="#D93740">Zusammenfassung</font> </h2><br><p>  In diesem Artikel haben wir uns drei GraalVM-Optimierungen angesehen: Inlining, polymorphes Inlining und partielle Escape-Analyse.  Es gibt noch viele weitere Optimierungen: Heraufstufen und Aufteilen von Zyklen, Duplizieren von Pfaden, Nummerieren von globalen Werten, Faltung von Konstanten, Entfernen von totem Code, spekulative Ausführung und so weiter. </p><br><p>  Wenn Sie mehr über die Funktionsweise von GraalVM erfahren möchten, zögern Sie nicht, die <a href="http://www.graalvm.org/community/publications/">Publikationsseite</a> zu öffnen.  Wenn Sie sicherstellen möchten, dass GraalVM Ihren Code beschleunigt, können Sie <a href="https://www.graalvm.org/downloads/">die Binärdateien herunterladen</a> und selbst ausprobieren. </p><br><hr><br><h2>  <font color="#D93740">Vom Übersetzer: zusätzliche Materialien</font> </h2><br>  JPoint und Joker sprechen auf Konferenzen häufig über GraalVM.  So besuchten uns zuletzt im JPoint 2019 Thomas Würthinger (Research Director bei Oracle Labs, verantwortlich für GraalVM) und Oleg Shelaev, einer der beiden offiziellen Technologieevangelisten. <br><br>  Sie können diese und andere Videos auf unserem YouTube-Kanal ansehen: <br><br><ul><li>  Thomas Würthinger: <a href="https://www.youtube.com/watch%3Fv%3DR_SeDk16PLY">„Leistung maximieren mit GraalVM“</a> </li><li>  Oleg Shelaev: <a href="https://www.youtube.com/watch%3Fv%3DC5fATKdVxZ0">"Supercompilation, Teilevaluation, Futamura-Projektionen und wie GraalVM die Welt retten wird"</a> </li><li>  Roberto Cortez: <a href="https://www.youtube.com/watch%3Fv%3DoY8sfg7A1kg">„GraalVM und MicroProfile: Eine Lösung für mehrsprachige Microservices“</a> </li><li>  Ionut Balosin: <a href="https://www.youtube.com/watch%3Fv%3DRYLEIRHWsVo">„Ein Rennen zweier Compiler: GraalVM JIT gegen HotSpot JIT C2.</a>  <a href="https://www.youtube.com/watch%3Fv%3DRYLEIRHWsVo">Welches bietet eine bessere Laufzeitleistung? “</a> </li></ul><br><blockquote>  Wir erinnern Sie daran, dass der nächste JPoint vom 15. bis 16. Mai 2020 in Moskau stattfindet und Tickets bereits <a href="https://jpoint.ru/registration/%3Futm_source%3Dhabr%26utm_medium%3D485024%26utm_campaign%3Djpoint20">auf der offiziellen Website gekauft werden können</a> . </blockquote><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485024/">https://habr.com/ru/post/de485024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485012/index.html">Verwendung von Control Inversion in JavaScript und Reactjs zur Vereinfachung der Codebehandlung</a></li>
<li><a href="../de485014/index.html">Soll ich mich über Interviews beschweren?</a></li>
<li><a href="../de485016/index.html">Verwaltete Datenbanken bei Selectel: Willkommen bei Beta</a></li>
<li><a href="../de485018/index.html">Schreiben von Shadern mit Code in Unity LWRP</a></li>
<li><a href="../de485022/index.html">Playme Sigma: Funktioneller und erschwinglicher DVR</a></li>
<li><a href="../de485026/index.html">Georgiens Chancen für IT-Profis</a></li>
<li><a href="../de485028/index.html">CRM 2020</a></li>
<li><a href="../de485030/index.html">Top 8 IEO Gebühren und deren Aktivierung jetzt</a></li>
<li><a href="../de485032/index.html">Schnelleres Reagieren mit staatlichem Co-Hosting</a></li>
<li><a href="../de485034/index.html">Automatisieren der Erstellung eines Qt-Projekts unter Windows in Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>