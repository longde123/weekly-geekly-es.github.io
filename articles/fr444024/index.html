<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèº üë©‚Äçüíª üñåÔ∏è Comment impl√©menter un langage de programmation en JavaScript. Partie 3: interpr√®te CPS üó£Ô∏è üßöüèΩ üéæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour Je vous pr√©sente la troisi√®me partie de ma traduction du guide d'impl√©mentation de mon langage de programmation JavaScript - PL Tutorial . 
 D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment impl√©menter un langage de programmation en JavaScript. Partie 3: interpr√®te CPS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444024/"><p>  Bonjour  Je vous pr√©sente la troisi√®me partie de ma traduction du guide d'impl√©mentation de mon langage de programmation JavaScript - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PL Tutorial</a> . </p><br><h1 id="ot-perevodchika">  Du traducteur </h1><br><p>  Nous allons cr√©er notre propre langage de programmation - langage <strong>Œª</strong> (dans l'original - Œªanguage).  Dans le processus de cr√©ation, nous utiliserons de nombreuses techniques int√©ressantes, telles que la descente r√©cursive, le style de transfert de contr√¥le et les techniques d'optimisation de base.  Deux versions de l'interpr√©teur seront cr√©√©es - les interpr√®tes standard et CPS, le trans-compilateur en JavaScript. </p><br><p>  L'auteur de l'original est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mihai Bazon</a> , l'auteur de la c√©l√®bre biblioth√®que UglifyJS (un outil pour minimiser et formater le code JS). </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Table des mati√®res</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment impl√©menter un langage de programmation en JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: analyseur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment impl√©menter un langage de programmation en JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2: interpr√®te</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment impl√©menter un langage de programmation en JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: interpr√®te CPS</a> </li><li>  Comment impl√©menter un langage de programmation en JavaScript.  Partie 4: Trans Compilation dans JS </li></ol></div></div><br><p> PS Il y a un bug dans l'interpr√©teur et le compilateur: dans des expressions comme <code>a() &amp;&amp; b()</code> ou <code>a() || b()</code>  <code>a() || b()</code> deux parties sont toujours ex√©cut√©es.  Bien s√ªr, cela est faux car <code>a()</code> faux pour l'op√©rateur <code>&amp;&amp;</code> , ou pas faux pour le <code>||</code>  , alors la valeur de <code>b()</code> ne joue aucun r√¥le.  Ce n'est pas difficile √† r√©soudre. </p><br><h1 id="cps-interpretator">  Interpr√®te CPS </h1><br><p>  Notre langue Œª pr√©sente deux inconv√©nients: </p><br><ul><li>  La r√©cursivit√© est limit√©e √† la pile JS, nous n'avons donc pas de m√©thode normale pour faire des boucles. </li><li>  L'interpr√©teur est lent, donc la r√©cursivit√© est tr√®s lente. </li></ul><br><p>  Nous allons maintenant corriger la premi√®re faille sans pr√™ter attention au fait que l'interpr√®te deviendra encore plus lent.  Nous r√©√©crirons l'interpr√©teur dans le style "style de passage continu" (CPS). </p><br><h2 id="chto-takoe-peredacha-prodolzheniya">  Qu'est-ce qu'un "transfert de continuation" </h2><br><p>  Vous faites cela dans NodeJS tout le temps: </p><br><pre> <code class="javascript hljs">fs.readFile(<span class="hljs-string"><span class="hljs-string">"file.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"utf8"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   - "" //     'return', // 'readFile'  ,  . });</span></span></code> </pre> <br><p>  √Ä chaque √©tape, il y a un rappel qui sera appel√© lorsque vous devrez continuer.  Le style de transfert de continuation rend le transfert de contr√¥le ¬´explicite¬ª - vous n'utilisez pas <code>return</code> , <code>throw</code> , <code>break</code> ou <code>continue</code> .  Il n'y a pas de sauts implicites dans le code.  Vous ne pouvez m√™me pas utiliser <code>for</code> boucles <code>for</code> ou <code>while</code> avec des fonctions asynchrones.  Dans ce cas, pourquoi en avons-nous besoin dans le langage de programmation? </p><br><p>  √âcrire du code dans le style de transmission d'une suite est difficile et facile √† faire des erreurs, mais nous ne r√©√©crirons l'interpr√®te que dans ce style. </p><br><h2 id="funkciya-evaluate">  <code>evaluate</code> fonction </h2><br><p>  La fonction d' <code>evaluate</code> recevra trois arguments: expression (AST), contexte (Environnement) et la fonction qui sera appel√©e lorsque le r√©sultat est.  Voici le code, pour chaque fragment il y a une explication: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp, env, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (exp.type) {</code> </pre> <br><p>  Pour les constantes, nous retournerons simplement leur valeur.  Mais rappelez-vous, nous n'avons pas de <code>return</code> - au lieu de cela, nous appelons simplement le rappel et passons la valeur. </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"str"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: callback(exp.value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Le n≈ìud <code>var</code> est √©galement simple - r√©cup√©rez la variable √† partir du contexte et passez-la √† la fonction: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"var"</span></span>: callback(env.get(exp.value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Pour <code>assign</code> n≈ìuds, nous devons obtenir la valeur de l'expression gauche ( <code>right</code> ).  Pour ce faire, nous appelons <code>evaluate</code> , en passant une fonction qui obtiendra le r√©sultat (pour le c√¥t√© droit de l'expression).  Et puis nous appelons simplement le <code>callback</code> avec la valeur de la variable, d√©finissant la variable dans le contexte actuel: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"assign"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.left.type != <span class="hljs-string"><span class="hljs-string">"var"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot assign to "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(exp.left)); evaluate(exp.right, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">right</span></span></span><span class="hljs-function">)</span></span>{ callback(env.set(exp.left.value, right)); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Presque la m√™me chose pour les n≈ìuds de type <code>binary</code> , mais ici, nous devons d'abord obtenir la valeur du champ <code>left</code> , puis seulement la valeur du champ <code>right</code> .  Ensuite, nous appelons simplement le rappel, en passant le r√©sultat de l'op√©ration: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"binary"</span></span>: evaluate(exp.left, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">)</span></span>{ evaluate(exp.right, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">right</span></span></span><span class="hljs-function">)</span></span>{ callback(apply_op(exp.operator, left, right)); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Le n≈ìud <code>let</code> air plus compliqu√©, mais en fait c'est simple.  Nous avons un certain nombre de variables.  Leur champ <code>def</code> (valeur initiale) peut √™tre vide, auquel cas nous le d√©finirons sur <code>false</code> .  Mais s'il y a une valeur, alors nous devons appeler r√©cursivement pour l'obtenir. </p><br><p>  Si vous avez d√©j√† travaill√© avec NodeJS, vous l'avez d√©j√† fait plusieurs fois auparavant.  En raison des rappels, nous ne pouvons pas utiliser <code>for</code> , par cons√©quent, nous devons interpr√©ter ces expressions une par une (imaginez la fonction d' <code>evaluate</code> comme asynchrone).  La fonction de <code>loop</code> ci-dessous (imm√©diatement appel√©e) obtient le contexte et le num√©ro de la d√©finition √† traiter: </p><br><ul><li>  Si ce nombre est √©gal au nombre de variables ( <code>vars.length</code> ), cela signifie que nous avons d√©j√† d√©fini toutes les expressions afin de pouvoir ex√©cuter le corps de l'expression.  Veuillez noter que cette fois, nous n'appelons pas le <code>callback</code> , mais le transmettons pour <code>evaluate</code> , qui l'appellera ensuite. </li><li>  Si ce nombre est inf√©rieur, vous devez alors calculer la d√©finition actuelle et passer une fonction qui appellera <code>loop(scope, i + 1)</code> , avant de copier le contexte. <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"let"</span></span>: (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, i</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; exp.vars.length) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = exp.vars[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v.def) evaluate(v.def, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, value); loop(scope, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); loop(scope, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { evaluate(exp.body, env, callback); } })(env, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> </li></ul><br><p>  Le n≈ìud <code>lambda</code> sera trait√© dans une fonction distincte, comme pr√©c√©demment: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>: callback(make_lambda(env, exp)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Afin d'interpr√©ter <code>if</code> , nous interpr√©tons d'abord la condition.  Si elle n'est pas fausse, alors nous interpr√©tons l'expression <code>then</code> , dans un autre cas, interpr√©terons <code>else</code> s'il y en a une, ou retournons <code>false</code> sinon.  Comme pr√©c√©demment, pour <code>then</code> et <code>else</code> nous passons juste le <code>callback</code> comme ¬´action √† faire apr√®s ex√©cution¬ª de l'expression: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"if"</span></span>: evaluate(exp.cond, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cond</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) evaluate(exp.then, env, callback); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.else) evaluate(exp.else, env, callback); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> callback(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Le n≈ìud <code>prog</code> est interpr√©t√© de mani√®re similaire au n≈ìud <code>let</code> , mais avec la diff√©rence que nous n'avons pas besoin de copier le contexte ou de d√©finir des variables.  Et encore une fois, nous avons une fonction de <code>loop</code> qui prend un num√©ro d'expression.  Quand il est √©gal √† <code>prog.length</code> , alors nous avons termin√© toutes les expressions et nous retournons simplement le r√©sultat de la derni√®re expression (par le mot "return" je veux dire que nous appelons <code>callback</code> avec lui).  Veuillez noter que nous nous souvenons de la derni√®re valeur en la passant comme argument √† la fonction de <code>loop</code> (au d√©but c'est <code>false</code> pour le cas o√π le corps est vide): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"prog"</span></span>: (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">last, i</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; exp.prog.length) evaluate(exp.prog[i], env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">)</span></span>{ loop(val, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { callback(last); } })(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Pour un n≈ìud de type <code>call</code> nous devons interpr√©ter <code>func</code> et tous les arguments sont en ordre.  Et encore une fois, il existe une fonction de <code>loop</code> qui fonctionne sur le m√™me principe que <code>let</code> ou <code>prog</code> , √† la diff√©rence qu'il construit d√©sormais un tableau en cons√©quence: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"call"</span></span>: evaluate(exp.func, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">)</span></span>{ (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args, i</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; exp.args.length) evaluate(exp.args[i], env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ args[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = arg; loop(args, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { func.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); } })([ callback ], <span class="hljs-number"><span class="hljs-number">0</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Eh bien, la fin standard: si nous ne savons pas quoi faire, jetez une exception: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know how to evaluate "</span></span> + exp.type); } }</code> </pre> <br><p>  Vous pouvez remarquer que chaque <code>case</code> ci-dessus se termine par le mot-cl√© <code>return</code> .  Mais il n'y a pas de valeur de retour - le r√©sultat est toujours transmis √† la fonction de <code>callback</code> . </p><br><h3 id="novaya-funkciya-make_lambda">  Nouvelle fonction <code>make_lambda</code> </h3><br><p>  Dans cet interpr√©teur, toutes les fonctions recevront une ¬´continuation¬ª comme premier argument - la fonction que nous devons appeler pour passer le r√©sultat.  Apr√®s, ce sont les arguments habituels de la fonction.  Voici le nouveau code de la fonction <code>make_lambda</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.name) { env = env.extend(); env.def(exp.name, lambda); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = exp.vars; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; names.length; ++i) scope.def(names[i], i + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length ? <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); evaluate(exp.body, scope, callback); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lambda; }</code> </pre> <br><p>  Il n'est pas tr√®s diff√©rent.  Il ajoute de nouvelles variables √† un nouveau contexte.  Aussi, nous devons consid√©rer que le premier argument est le <code>callback</code> .  Enfin, la fonction d' <code>evaluate</code> est utilis√©e pour ex√©cuter le code de la fonction dans un nouveau contexte, mais, comme pr√©c√©demment, nous passons un <code>callback</code> . </p><br><p>  Au fait, c'est le seul endroit o√π j'ai utilis√© la boucle <code>for</code> .  En effet, les valeurs d'argument sont d√©j√† calcul√©es lors du traitement du n≈ìud d' <code>call</code> . </p><br><h2 id="nativnye-funkcii">  Fonctions natives </h2><br><p>  Dans cet interpr√©teur, les fonctions natives re√ßoivent un <code>callback</code> comme premier argument.  Nous devons nous en souvenir lorsque nous d√©finissons des fonctions natives.  Voici l'exemple de code pour le nouvel interpr√®te: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> code = <span class="hljs-string"><span class="hljs-string">"sum = lambda(x, y) x + y; print(sum(2, 3));"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ast = parse(TokenStream(InputStream(code))); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> globalEnv = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Environment(); <span class="hljs-comment"><span class="hljs-comment">// define the "print" primitive function globalEnv.def("print", function(callback, txt){ console.log(txt); callback(false); // call the continuation with some return value // if we don't call it, the program would stop // abruptly after a print! }); // run the evaluator evaluate(ast, globalEnv, function(result){ // the result of the entire program is now in "result" });</span></span></code> </pre> <br><h2 id="malenkiy-test">  Petit test </h2><br><p>  Essayons √† nouveau de calculer les nombres de Fibonacci: </p><br><pre> <code class="javascript hljs">fib = Œª(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> then n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); time( Œª() println(fib(<span class="hljs-number"><span class="hljs-number">10</span></span>)) );</code> </pre> <br><p>  Mais, si nous essayons de trouver le 27e nombre, nous obtenons un d√©bordement de pile.  En g√©n√©ral, la pile augmente maintenant beaucoup plus rapidement, il s'est donc av√©r√© que maintenant nous ne pouvons compter le nombre de Fibonacci que jusqu'au 12 (au moins dans mon navigateur).  Ce n'est pas tr√®s bon, vous devez donc le r√©parer d'une mani√®re ou d'une autre. </p><br><h1 id="zaschischaem-stek">  Nous prot√©geons la pile </h1><br><p>  Dans un interpr√©teur CPS, la pile se d√©veloppe beaucoup plus rapidement car l'interpr√©teur appelle toujours les fonctions de mani√®re r√©cursive, sans jamais retourner de r√©sultat.  Bien que nous ayons un <code>return</code> dans l'interpr√©teur, nous en avons besoin, mais dans le cas d'une r√©cursion tr√®s profonde, nous ne les atteignons jamais. </p><br><p>  Imaginons √† quoi ressemble notre pile pour un programme tr√®s simple.  Je vais montrer le pseudo code et je n'ai pas ajout√© d' <code>env</code> car il ne joue aucun r√¥le ici: </p><br><pre> <code class="python hljs">print(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">## : evaluate( print(1 + 2 * 3), K0 ) evaluate( print, K1 ) K1(print) #  'var',      evaluate( 1 + 2 * 3, K2 ) evaluate( 2 * 3, K3 ) evaluate( 2, K4 ) K4(2) # 2  ,      evaluate( 3, K5 ) #    3,      K5(3) K3(6) #  2*3 evaluate( 1, K6 ) #  ,  K6(1) K2(7) #  1+2*3 print(K0, 7) # ,     'print' K0(false) #  . 'print'  'false'.</span></span></code> </pre> <br><p>  Ce n'est qu'apr√®s le dernier appel qu'une longue s√©quence de <code>return</code> inutiles r√©duit la pile.  Si nous utilisons autant d'espace de pile pour un programme simple, il est difficile d'imaginer ce qui se passera pour <code>fib(13)</code> . </p><br><h2 id="zaschita-steka">  Protection contre la pile </h2><br><p>  Dans notre nouvel interpr√®te, la pile n'est tout simplement pas n√©cessaire.  Tout ce qui doit √™tre fait apr√®s qu'une expression se soit <code>callback</code> dans un <code>callback</code> , qui est pass√© en argument.  Nous avons donc ici une question: et si JavaScript permettait de "vider" la pile.  Ensuite, nous pouvons supprimer la pile et une r√©cursion infiniment profonde fonctionnera. </p><br><p>  Imaginons que nous ayons une fonction <code>GUARD</code> qui peut le faire.  Il obtient deux valeurs: la fonction √† appeler et les arguments qu'elle doit √™tre pass√©s.  Il v√©rifie: si la pile est trop profonde, il effacera la pile et appellera la fonction pass√©e.  Dans un autre cas, elle ne fait rien. </p><br><p>  En utilisant la nouvelle fonction, nous r√©√©crivons l'interpr√©teur comme indiqu√© ci-dessous.  Je ne commenterai pas sur chaque cas individuel, il y a le code qui a √©t√© d√©crit pr√©c√©demment, mais en utilisant la fonction <code>GUARD</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp, env, callback</span></span></span><span class="hljs-function">) </span></span>{ GUARD(evaluate, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (exp.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"str"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: callback(exp.value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"var"</span></span>: callback(env.get(exp.value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"assign"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.left.type != <span class="hljs-string"><span class="hljs-string">"var"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot assign to "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(exp.left)); evaluate(exp.right, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">right</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); callback(env.set(exp.left.value, right)); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"binary"</span></span>: evaluate(exp.left, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); evaluate(exp.right, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">right</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); callback(apply_op(exp.operator, left, right)); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"let"</span></span>: (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, i</span></span></span><span class="hljs-function">)</span></span>{ GUARD(loop, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; exp.vars.length) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = exp.vars[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v.def) evaluate(v.def, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, value); loop(scope, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); loop(scope, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { evaluate(exp.body, env, callback); } })(env, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>: callback(make_lambda(env, exp)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"if"</span></span>: evaluate(exp.cond, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cond</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) evaluate(exp.then, env, callback); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.else) evaluate(exp.else, env, callback); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> callback(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"prog"</span></span>: (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">last, i</span></span></span><span class="hljs-function">)</span></span>{ GUARD(loop, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; exp.prog.length) evaluate(exp.prog[i], env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); loop(val, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { callback(last); } })(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"call"</span></span>: evaluate(exp.func, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args, i</span></span></span><span class="hljs-function">)</span></span>{ GUARD(loop, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; exp.args.length) evaluate(exp.args[i], env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); args[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = arg; loop(args, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { func.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); } })([ callback ], <span class="hljs-number"><span class="hljs-number">0</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know how to evaluate "</span></span> + exp.type); } }</code> </pre> <br><p>  Pour les fonctions anonymes, nous devions ajouter un nom afin de pouvoir les passer dans la fonction <code>GUARD</code> .  J'ai utilis√© le nom <code>CC</code> ( <code>current continuation</code> ).  Vous pouvez utiliser <code>arguments.callee</code> , mais il s'agit d'une API obsol√®te. </p><br><p>  En outre, le m√™me changement dans <code>make_lambda</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.name) { env = env.extend(); env.def(exp.name, lambda); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ GUARD(lambda, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;--  var names = exp.vars; var scope = env.extend(); for (var i = 0; i &lt; names.length; ++i) scope.def(names[i], i + 1 &lt; arguments.length ? arguments[i + 1] : false); evaluate(exp.body, scope, callback); } return lambda; }</span></span></code> </pre> <br><p>  La mise en ≈ìuvre de <code>GUARD</code> tr√®s simple.  Comment sortir d'un appel profond?  Utilisation d'exceptions.  Pour ce faire, il y aura une variable globale qui indiquera combien de r√©cursions suppl√©mentaires nous pouvons faire.  S'il atteint z√©ro, nous lan√ßons l'objet <code>Continuation</code> , dans lequel il y aura une continuation - fonction et arguments: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> STACKLEN; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GUARD</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--STACKLEN &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Continuation(f, args); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Continuation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f = f; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.args = args; }</code> </pre> <br><p>  Et √† la fin, nous avons besoin d'une boucle qui attrapera les objets <code>Continuation</code> .  Nous devons appeler l'interpr√®te via cette boucle pour que tout fonctionne: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { STACKLEN = <span class="hljs-number"><span class="hljs-number">200</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(ex) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Continuation) f = ex.f, args = ex.args; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ex; } }</code> </pre> <br><p>  La fonction <code>Execute</code> accepte la fonction √† appeler et ses arguments.  Cela fonctionne en boucle, mais attention √† <code>return</code> si la fonction fonctionne sans d√©bordement de pile, on s'arr√™te tout de suite.  <code>STACKLEN</code> r√©initialis√© √† chaque d√©marrage d'une it√©ration de boucle.  Une valeur de <code>200</code> - correspond bien.  Lorsque nous interceptons l'objet <code>Continuation</code> , nous substituons une nouvelle fonction et de nouveaux arguments et continuons la boucle.  De plus, en raison d'une exception, la pile est effac√©e, afin que nous puissions continuer. </p><br><p>  Pour d√©marrer l'interpr√©teur, nous utilisons maintenant <code>Execute</code> : </p><br><pre> <code class="javascript hljs">Execute(evaluate, [ ast, globalEnv, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"*** Result:"</span></span>, result); }]);</code> </pre> <br><h2 id="test">  Test </h2><br><p>  La fonction <code>fib</code> fonctionnera d√©sormais: </p><br><pre> <code class="python hljs">fib = Œª(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> then n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); time( Œª() println(fib(<span class="hljs-number"><span class="hljs-number">20</span></span>)) ); <span class="hljs-comment"><span class="hljs-comment"># 6765, ~300ms</span></span></code> </pre> <br><p>  Dommage, mais si vous essayez de trouver <code>fib(27)</code> , cela prendra environ quatre fois plus de temps qu‚Äôun interpr√®te habituel.  Mais nous avons maintenant une r√©cursion infinie: </p><br><pre> <code class="javascript hljs">sum = Œª(n, ret) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">0</span></span> then ret <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sum(n - <span class="hljs-number"><span class="hljs-number">1</span></span>, ret + n); # compute <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> + ... + <span class="hljs-number"><span class="hljs-number">50000</span></span> time( Œª() println(sum(<span class="hljs-number"><span class="hljs-number">50000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) ); # <span class="hljs-number"><span class="hljs-number">1250025000</span></span>, ~<span class="hljs-number"><span class="hljs-number">700</span></span>ms</code> </pre> <br><p>  Bien s√ªr, le langage Œª est beaucoup plus lent que JavaScript.  Imaginez, chaque acc√®s √† une variable passe par un objet <code>Environment</code> .  Cela n'a aucun sens d'essayer d'optimiser l'interpr√©teur - nous n'obtiendrons pas un gain de performances significatif.  Pour am√©liorer les performances, il existe une solution: compiler le langage Œª en JS, et c'est ce que nous allons faire.  Dans un premier temps, voyons quelles choses int√©ressantes nous pouvons faire avec un interpr√©teur CPS. </p><br><h1 id="prodolzheniya">  Continuation </h1><br><p>  Maintenant que l'interpr√©teur fonctionne dans le style de transmission de continuation, et toutes les fonctions, √† la fois les fonctions de langage Œª et les fonctions natives JS, re√ßoivent la fonction de continuation comme premier argument pour renvoyer le r√©sultat (cet argument est requis pour les fonctions JavaScript, bien qu'il soit invisible pour les fonctions de langage Œª). </p><br><p>  Le <code>callback</code> variable signifie la poursuite de tout le programme.  <em>Tout ce que le programme fera ensuite.</em>  Nous appellerons cette variable ¬´continuation actuelle¬ª, ou <code>k</code> dans le code. </p><br><p>  De plus, si nous ne provoquons pas de suite, le programme s'arr√™tera.  Nous ne pouvons pas le faire √† partir du langage Œª car <code>make_lambda</code> invoque quand m√™me la continuation.  Mais nous pouvons le faire √† partir d'une fonction native.  J'ai cr√©√© une fonction pour montrer comment cela fonctionne: </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"halt"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">)</span></span>{});</code> </pre> <br><p>  C'est une fonction qui ne fait rien.  Elle re√ßoit la suite ( <code>k</code> ), mais ne l'appelle pas: </p><br><pre> <code class="python hljs">println(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); halt(); println(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>);</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">foo</code> </pre> <br><p>  Si vous supprimez l'appel <code>halt()</code> , la sortie sera: <code>foo / bar / ***Result: false</code> (car le dernier <code>println</code> retourne <code>false</code> ).  Mais avec <code>halt()</code> cela ne produit que <code>foo</code> .  * Maintenant, il n'y a m√™me plus de r√©sultat car <code>halt()</code> ne provoque pas de continuation et, par cons√©quent, le rappel que nous avons pass√© pour <code>evaluate</code> - celui qui affiche la cha√Æne <code>***Result</code> , n'est jamais appel√©.  La fonction qui a appel√© <code>evaluate</code> ne remarque pas que le programme s'est arr√™t√©.  Dans NodeJS, ce serait une balle dans le pied. </p><br><hr><br><p>  Imaginez que nous ayons besoin d'une fonction <code>sleepe</code> qui arr√™te un programme sans arr√™ter le navigateur (donc sans boucles stupides).  Nous pouvons facilement impl√©menter cela en utilisant une fonction native: </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"sleep"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k, milliseconds</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ Execute(k, [ <span class="hljs-literal"><span class="hljs-literal">false</span></span> ]); <span class="hljs-comment"><span class="hljs-comment">//   ,  'false' }, milliseconds); });</span></span></code> </pre> <br><p>  Un l√©ger inconv√©nient est que nous devons utiliser <code>Execute</code> , car <code>setTimeout</code> provoquera un rappel, qui lancera ensuite <code>Continuation</code> , et personne ne l'attrapera.  Voici comment l'utiliser: </p><br><pre> <code class="python hljs">let loop (n = <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> { println(n); sleep(<span class="hljs-number"><span class="hljs-number">250</span></span>); loop(n + <span class="hljs-number"><span class="hljs-number">1</span></span>); } }; println(<span class="hljs-string"><span class="hljs-string">"And we're done"</span></span>);</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 And we're done ***Result: false</code> </pre> <br><p>  Remarque, il y a un l√©ger d√©lai entre chaque ligne.  Vous pouvez essayer d'ex√©cuter ce code dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article d'origine</a> . </p><br><p>  C'est d√©j√† quelque chose que vous ne pouvez pas faire en JavaScript normal, sauf pour utiliser la transmission manuelle de la continuation (et aussi, vous ne pouvez pas utiliser <code>for</code> boucle <code>for</code> ): </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(n); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ loop(n + <span class="hljs-number"><span class="hljs-number">1</span></span>); }, <span class="hljs-number"><span class="hljs-number">250</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { println(<span class="hljs-string"><span class="hljs-string">"And we're done"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    } })(0);</span></span></code> </pre> <br><hr><br><p>  Imaginez comment vous pouvez utiliser l'API NodeJS dans un langage Œª: </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"readFile"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k, filename</span></span></span><span class="hljs-function">)</span></span>{ fs.readFile(filename, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// error handling is a bit more complex, ignoring for now Execute(k, [ data ]); // hope it's clear why we need the Execute }); }); globalEnv.def("writeFile", function(k, filename, data){ fs.writeFile(filename, data, function(err){ Execute(k, [ false ]); }); });</span></span></code> </pre> <br><p>  Utilisation: </p><br><pre> <code class="python hljs">copyFile = Œª(source, dest) { writeFile(dest, readFile(source)); }; copyFile(<span class="hljs-string"><span class="hljs-string">"foo.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"bar.txt"</span></span>);</code> </pre> <br><p>  Et tout cela fonctionne de mani√®re asynchrone.  Plus d'enfer de rappel. </p><br><hr><br><p>  Voici un exemple plus int√©ressant.  J'ai √©crit la fonction native suivante: </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"twice"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k, a, b</span></span></span><span class="hljs-function">)</span></span>{ k(a); k(b); });</code> </pre> <br><p>  Le programme prend deux arguments <code>a</code> et <code>b</code> et appelle la continuation deux fois, une fois pour chaque argument.  Essayons de l'appeler: </p><br><pre> <code class="python hljs">println(<span class="hljs-number"><span class="hljs-number">2</span></span> + twice(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); println(<span class="hljs-string"><span class="hljs-string">"Done"</span></span>);</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">5 Done ***Result: false 6 Done ***Result: false</code> </pre> <br><p>  La conclusion est √©trange si vous n'avez jamais travaill√© avec des continuations de passage auparavant, mais essayez de comprendre ce code vous-m√™me.  Un petit indice: le programme d√©marre une fois, mais renvoie le r√©sultat deux fois. </p><br><h2 id="obobschenie-callcc">  G√©n√©ralisation: <code>CallCC</code> </h2><br><p>  Nous avions l'habitude de jouer avec le feu lorsque nous √©crivions des fonctions natives.  Il n'y a aucun moyen en langage Œª d'interrompre l'ex√©cution de la suite en cours.  <code>CallCC</code> aidera √† r√©soudre ce probl√®me.  Le nom est l'abr√©viation de la fonction de Scheme - <code>call-with-current-continuation</code> (qui est g√©n√©ralement appel√©e call / cc dans Scheme). </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"CallCC"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k, f</span></span></span><span class="hljs-function">)</span></span>{ f(k, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">discarded, ret</span></span></span><span class="hljs-function">)</span></span>{ k(ret); }); });</code> </pre> <br><p>  Il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©ifie la</a> suite actuelle en une fonction qui peut √™tre appel√©e directement √† partir du langage Œª.  Cette fonction ignorera sa continuation <code>discarded</code> origine et appellera √† la place la continuation qui a √©t√© transmise √† la fonction <code>CallCC</code> . </p><br><p>  En utilisant cette fonction, nous pouvons impl√©menter (d√©j√† directement dans le langage, pas via des fonctions natives!) Un grand ensemble d'instructions de contr√¥le pour le flux d'ex√©cution auquel nous n'avions m√™me pas pens√© auparavant - √† partir d'exceptions et se terminant par <code>return</code> .  Commen√ßons par le dernier. </p><br><h3 id="realizaciya-return">  <code>return</code> impl√©mentation </h3><br><pre> <code class="python hljs">foo = Œª(<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>){ println(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-string"><span class="hljs-string">"DONE"</span></span>); println(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>); }; CallCC(foo);</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">foo ***Result: DONE</code> </pre> <br><p>  La fonction <code>foo</code> re√ßoit un argument qui fait la m√™me chose que le <code>return</code> de JavaScript (mais est appel√© comme une fonction r√©guli√®re).  Il saute la suite en cours (qui afficherait 'bar') et quitte la fonction, renvoyant la valeur donn√©e ("DONE").  Bien s√ªr, cela ne fonctionne que si vous appelez une fonction en utilisant <code>CallCC</code> pour passer la continuation en <code>return</code> .  Nous pouvons cr√©er un wrapper pour cela: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> = Œª(f) Œª() CallCC(f); foo = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(Œª(<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>){ println(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-string"><span class="hljs-string">"DONE"</span></span>); println(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>); }); foo();</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">foo ***Result: DONE</code> </pre> <br><p>  L'avantage de cette m√©thode est que nous n'avons plus besoin d'utiliser <code>CallCC</code> lorsque nous appelons <code>foo</code> .  Ce serait bien, bien s√ªr, si nous n'avions pas besoin d'accepter <code>return</code> comme argument ou d'utiliser la fonction <code>with-return</code> , mais dans le langage il n'y a aucun moyen d'ajouter du sucre syntaxique directement √† partir de lui, pour cela nous devons au moins modifier l'analyseur (+1 pour Lisp). </p><br><h3 id="perehody">  Transitions </h3><br><p>  Par exemple, nous devons √©crire un programme qui recherchera toutes les paires d'entiers positifs jusqu'√† 100 de sorte que si leur multiplication donne 84. Ce n'est pas une t√¢che difficile et vous pourriez imm√©diatement imaginer deux boucles imbriqu√©es pour le r√©soudre, mais ici, nous allons dans une direction diff√©rente.  Nous allons cr√©er deux fonctions: <code>guess</code> et <code>fail</code> .  La premi√®re choisira le num√©ro, et la seconde lui dira ¬´essayez un autre num√©ro¬ª.  Nous les utiliserons comme ceci: </p><br><pre> <code class="python hljs">a = guess(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">#  -  &gt;= 1 b = guess(a); #  -  &gt;= a if a * b == 84 { #    : print(a); print(" x "); println(b); }; fail(); #    `guess`    </span></span></code> </pre> <br><p>  : </p><br><pre> <code class="python hljs">fail = Œª() false; guess = Œª(current) { CallCC(Œª(k){ let (prevFail = fail) { fail = Œª(){ current = current + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current &gt; <span class="hljs-number"><span class="hljs-number">100</span></span> { fail = prevFail; fail(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { k(current); }; }; k(current); }; }); }; a = guess(<span class="hljs-number"><span class="hljs-number">1</span></span>); b = guess(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a * b == <span class="hljs-number"><span class="hljs-number">84</span></span> { print(a); print(<span class="hljs-string"><span class="hljs-string">" x "</span></span>); println(b); }; fail();</code> </pre> <br><p>     ,  ,      <code>a</code> ,    <code>84</code> ,   <code>b</code> ,  <code>84 / a</code> .           <code>guess</code> : <code>start</code>  <code>end</code> ‚Äî      .   ,  . </p><br><h3 id="try-i-catch-iz-common-lisp"> <code>try</code>  <code>catch</code>  Common Lisp </h3><br><p>     ‚Äî <code>catch</code>  <code>throw</code> .     : </p><br><pre> <code class="python hljs">f1 = Œª() { throw(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-string"><span class="hljs-string">"EXIT"</span></span>); print(<span class="hljs-string"><span class="hljs-string">"not reached"</span></span>); }; println(catch(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>, Œª() { f1(); print(<span class="hljs-string"><span class="hljs-string">"not reached"</span></span>); })); <span class="hljs-comment"><span class="hljs-comment">#  EXIT</span></span></code> </pre> <br><ul><li>  <code>catch(TAG, function)</code>  ,    ,  <code>TAG</code> ',   <code>function</code> . </li><li>  <code>throw(TAG, value)</code>  ,     ,  <code>TAG</code> '  ,     <code>value</code> . </li></ul><br><p>  : </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">##  , 'throw'   . ##       `error`, ##     JavaScript.    . throw = Œª(){ println("ERROR: No more catch handlers!"); halt(); }; catch = Œª(tag, func){ CallCC(Œª(k){ let (rethrow = throw, ret) { ##   ,     . throw = Œª(t, val) { throw = rethrow; #   ,   . if t == tag then k(val) else throw(t, val); }; ##      . ret = func(); ##       (  'throw') ##    .   . throw = rethrow; # XXX ##  . ret; }; }); };</span></span></code> </pre> <br><p>  Un exemple: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ... f1 = Œª() { throw("foo", "EXIT"); print("not reached"); }; println(catch("foo", Œª() { f1(); print("not reached"); }));</span></span></code> </pre> <br><h2 id="temnaya-storona-sily">    </h2><br><p>    <code>catch</code> ,     ,    ,    .   ,    , ,  <code>CallCC</code>     .    ,     .    "   " ‚Äî      ‚Äî  .    ,  ,     ,  <code>catch</code> / <code>throw</code>    ,  . </p><br><p>    .   ,    <code>catch</code> . ,   <code>throw</code>   , ,  <code>catch</code>   ,     .  Par exemple: </p><br><pre> <code class="python hljs">exit = false; <span class="hljs-comment"><span class="hljs-comment">#  . x = 0; # :   ,   'exit()'  CallCC( Œª(k) exit = k ); ## 'exit()'   ... if x == 0 then catch("foo", Œª(){ println("in catch"); x = 1; #  exit(); }); println("After catch"); throw("foo", "FOO");</span></span></code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">After catch After catch ERROR: No more catch handlers!</code> </pre> <br><p>    'After catch' ,   'ERROR: No more catch handlers!'. -  ,   'After catch'   ,   . ,  ''  ,  <code>catch</code> . ,    'XXX'   <code>catch</code>   ,         <code>throw</code> ,   <code>catch</code>   . </p><br><p> (       ,     .) </p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  CallCC</a> (, <em>   ,   CallCC</em> ).  ,    ‚Äî  <code>CallCC</code>           . </p><br><h1 id="yield"> Yield </h1><br><p> ,    ,   <code>yield</code> : </p><br><pre> <code class="python hljs">foo = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(Œª(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-string"><span class="hljs-string">"DONE"</span></span>; }); println(foo()); <span class="hljs-comment"><span class="hljs-comment"># 1 println(foo()); # 2 println(foo()); # 3 println(foo()); # DONE</span></span></code> </pre> <br><p>    <code>yield</code> ,       .  ,  <code>return</code> .      ,       ,    <code>yield</code> ,       . </p><br><p>  : </p><br><pre> <code class="python hljs">fib = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(Œª(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>){ let loop (a = <span class="hljs-number"><span class="hljs-number">1</span></span>, b = <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(b); loop(b, a + b); }; }); <span class="hljs-comment"><span class="hljs-comment">##   50   let loop (i = 0) { if i &lt; 50 { println(fib()); loop(i + 1); }; };</span></span></code> </pre> <br><p>  <code>fib</code>   .    .  <code>yield</code>      .     ,    ,         50  ,      50 . </p><br><p> ,      ,     , ,            . </p><br><h2 id="neudachnaya-popytka-realizacii">    </h2><br><p>          ,         . </p><br><p>   <code>yield</code> ,  ,       .   ,        ,      <code>return</code> . ,  ,    <code>yield</code> ,       <code>yield</code> ,         <em></em> .   ,   .      : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = Œª(func) { <span class="hljs-comment"><span class="hljs-comment">## with-yield     Œª() { CallCC(Œª(kret){ # kret     let (yield) { ##  yield yield = Œª(value) { # yield  ,    CallCC(Œª(kyld){ # kyld    yield... func = kyld; # ...     kret(value); #  . }); }; ## , ,  ,   yield. func(yield); }; }); }; };</span></span></code> </pre> <br><p>       <code>yield</code>  ,     . ,         ,     ,      "DONE". </p><br><p> ,     .   ,     - ,     ,    4   : </p><br><pre> <code class="python hljs">println(foo()); foo();</code> </pre> <br><p>    . </p><br><h3 id="problema-1-yield-nikogda-ne-izmenyaetsya">  ‚Ññ1: yield    </h3><br><p>  ,   ,  ,   ,     <code>yield</code> ( <code>kyld</code> ,    ,   )    : </p><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-string"><span class="hljs-string">"DONE"</span></span>;</code> </pre> <br><p>    <code>yield</code>   ?     <code>yield</code> ,       ,    <code>yield</code>    . ,    .  ,     <code>yield</code>        <code>return</code> ,      : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = Œª(func) { let (<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = Œª(value) { CallCC(Œª(kyld){ func = kyld; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(value); <span class="hljs-comment"><span class="hljs-comment"># 'return'  ,     }); #        . }; # Œª(val) { # CallCC(Œª(kret){ # return = kret; # &lt;-  func(val || yield); }); }; }; };</span></span></code> </pre> <br><p> ,  ,       <code>yield</code>  ,   <code>yield</code>       (  ).      <code>yield</code> . </p><br><p>   ,    ,    <code>println(foo())</code>   : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = Œª(func) { let (<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = Œª(value) { CallCC(Œª(kyld){ func = kyld; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(value); }); }; Œª(val) { CallCC(Œª(kret){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> = kret; func(val || <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); }); }; }; }; foo = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(Œª(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-string"><span class="hljs-string">"DONE"</span></span>; }); println(foo()); println(foo()); println(foo());</code> </pre> <br><p> ,    .        ,      <code>print(foo()); foo()</code> .   ,     <code>println(foo())</code> ?   ... </p><br><h3 id="problema-2-wtf">  ‚Ññ2: WTF? </h3><br><p>     .     :    ,          <code>foo()</code> .  ,     ? ‚Äî    . </p><br><pre> <code class="python hljs">println(foo()); <span class="hljs-comment"><span class="hljs-comment">## yield 1 &lt;-----------------  ---------------------------+ println(foo()); ## yield 2 | println(foo()); ## yield 3 | println(foo()); ##   "DONE",   foo()  --&gt;--+</span></span></code> </pre> <br><p>       <code>with-yield</code> : </p><br><pre> <code class="python hljs"> func(val || <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-comment"><span class="hljs-comment">#...</span></span></code> </pre> <br><p>     <code>yield</code> ,   ,       <code>#...</code> .   ,   ,     ( <code>"DONE"</code> ),     ,   <code>"DONE"</code>   ,     . <code>foo()</code>     ,    <code>"DONE"</code>   .      : </p><br><pre> <code class="python hljs">println(foo()); println(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>); println(foo()); println(foo()); foo();</code> </pre> <br><p>   : <code>1, bar, 2, 3, DONE, bar, DONE, bar, ...</code> . </p><br><p>      <code>func</code>  - ,    .   ,    <code>"no more continuations"</code> : </p><br><pre> <code class="python hljs"> val = func(val || <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); func = Œª() <span class="hljs-string"><span class="hljs-string">"NO MORE CONTINUATIONS"</span></span>; kret(val);</code> </pre> <br><p>     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = Œª(func) { let (<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = Œª(value) { CallCC(Œª(kyld){ func = kyld; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(value); }); }; Œª(val) { CallCC(Œª(kret){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> = kret; val = func(val || <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); func = Œª() <span class="hljs-string"><span class="hljs-string">"NO MORE CONTINUATIONS"</span></span>; kret(val); }); }; }; }; foo = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(Œª(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-string"><span class="hljs-string">"DONE"</span></span>; }); println(foo()); println(foo()); println(foo()); println(foo());</code> </pre> <br><p>      ,     : </p><br><pre> <code class="plaintext hljs">1 2 3 DONE NO MORE CONTINUATIONS NO MORE CONTINUATIONS NO MORE CONTINUATIONS ***Result: false</code> </pre> <br><p>    <code>1, 2, 3, DONE</code> ,      <code>"NO MORE CONTINUATIONS"</code>  .  ,       : </p><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"A. "</span></span>); println(foo()); print(<span class="hljs-string"><span class="hljs-string">"B. "</span></span>); println(foo()); print(<span class="hljs-string"><span class="hljs-string">"C. "</span></span>); println(foo()); print(<span class="hljs-string"><span class="hljs-string">"D. "</span></span>); println(foo()); <span class="hljs-comment"><span class="hljs-comment">##   : A. 1 B. 2 C. 3 D. DONE B. NO MORE CONTINUATIONS C. NO MORE CONTINUATIONS D. NO MORE CONTINUATIONS ***Result: false</span></span></code> </pre> <br><p>  ,     :       , , ,      ,  <code>"B."</code>   . </p><br><p>       ,         <code>yield</code> ,     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = Œª(func) { let (<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = Œª(value) { CallCC(Œª(kyld){ func = kyld; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(value); }); }; Œª(val) { CallCC(Œª(kret){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> = kret; val = func(val || <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); func = Œª() <span class="hljs-string"><span class="hljs-string">"NO MORE CONTINUATIONS"</span></span>; kret(val); }); }; }; }; fib = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(Œª(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>){ let loop (a = <span class="hljs-number"><span class="hljs-number">1</span></span>, b = <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(b); loop(b, a + b); }; }); <span class="hljs-comment"><span class="hljs-comment">##   50   let loop (i = 0) { if i &lt; 50 { println(fib()); loop(i + 1); }; };</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Conclusion</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 4807526976 7778742049 12586269025 20365011074 ***Result: false</code> </pre> </div></div><br><p> ,      (,       ),       " ". </p><br><h2 id="otdelennye-prodolzheniya-reset-i-shift">  : <code>reset</code>  <code>shift</code> </h2><br><p>    <code>yield</code>    : <code>reset</code>  <code>shift</code> .   " " ‚Äî ,     .  <code>reset</code>  ,   <code>shift</code>     ,   <code>CallCC</code> . </p><br><p>  , <code>reset</code>  <code>shift</code>    ‚Äî .     <code>reset</code> ,  <code>shift</code>      ,    <code>reset</code> . </p><br><p>  ,    <code>with-yield</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = Œª(func) { let (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) { <span class="hljs-comment"><span class="hljs-comment">## 'yield'  'shift'     ##  'reset'.  ,   ,    ##   'func' ‚Äî ,   `func()` ##    ,    . yield = Œª(val) { shift(Œª(k){ func = k; #    val; #    }); }; ##  `with-yield`      ##   'reset',    ,  ##   'yield' ( )    ##    Œª(val) { reset( Œª() func(val || yield) ); }; } };</span></span></code> </pre> <br><p>  ,      <code>reset</code> .  ,  ,       ,     <code>reset</code> .  ,    .     ,           . </p><br><p>     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = Œª(func) { let (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = Œª(val) { shift(Œª(k){ func = k; val; }); }; Œª(val) { reset( Œª() func(val || <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) ); }; } }; foo = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(Œª(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-string"><span class="hljs-string">"DONE"</span></span>; }); println(foo()); <span class="hljs-comment"><span class="hljs-comment">#  1 println(foo()); #  2 println(foo()); #  3 println(foo()); #  DONE</span></span></code> </pre> <br><h2 id="realizaciya-reset-i-shift">  <code>reset</code>  <code>shift</code> </h2><br><p>       ,      .    .     .     ,     ,        ,   .    <a href="">  Scheme</a> ( ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Oleg Kiselyov</a> ).   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>     . </p><br><h3 id="ispolzuya-nativnye-funkcii">    </h3><br><p>      ,      (    <code>CallCC</code> )         .   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pstack = []; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_goto</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ f(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KGOTO</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> h = pstack.pop(); h(r); }); } globalEnv.def(<span class="hljs-string"><span class="hljs-string">"reset"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">KRESET, th</span></span></span><span class="hljs-function">)</span></span>{ pstack.push(KRESET); _goto(th); }); globalEnv.def(<span class="hljs-string"><span class="hljs-string">"shift"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">KSHIFT, f</span></span></span><span class="hljs-function">)</span></span>{ _goto(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">KGOTO</span></span></span><span class="hljs-function">)</span></span>{ f(KGOTO, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SK</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k1, v</span></span></span><span class="hljs-function">)</span></span>{ pstack.push(k1); KSHIFT(v); }); }); });</code> </pre> <br><p>   ,   <code>reset</code> ,   <code>shift</code>  <code>_goto</code> ,  ‚Äî  .     .  <code>_goto</code>         ( <code>KGOTO</code> ).  ,       <code>f</code> (  <code>CallCC</code> )    -      <code>KGOTO</code> ,     .  ,  <code>f</code> ,   ,    <code>KGOTO</code> ,      ,     . </p><br><p>  <code>reset</code>      ( <code>KRESET</code> )     <code>_goto(th)</code> .      ,    , ,      <code>_goto</code> . ,     , <code>KGOTO</code>   <code>KRESET</code> . </p><br><p>   , <code>shift</code>     <code>KGOTO</code>     ,  <code>KGOTO</code>    <code>pstack</code> ,      <code>SK</code> ,     ,   <code>shift</code>   (   <code>shift</code> ‚Äî <code>KSHIFT</code> ).  <code>SK</code> ‚Äî   ‚Äî              ( <code>k1</code> )   .   ,     <code>shift2</code> ,    ,    <code>pstack.push(k1);</code>  : </p><br><pre> <code class="python hljs">println(reset(Œª(){ <span class="hljs-number"><span class="hljs-number">1</span></span> + shift( Œª(k) k(k(<span class="hljs-number"><span class="hljs-number">2</span></span>)) ); })); println(reset(Œª(){ <span class="hljs-number"><span class="hljs-number">1</span></span> + shift2( Œª(k) k(k(<span class="hljs-number"><span class="hljs-number">2</span></span>)) ); }));</code> </pre> <br><p>  Conclusion: </p><br><pre> <code class="plaintext hljs">4 3 ***Result: false</code> </pre> <br><p>  <code>shift</code>    ( <code>k</code> ),       <code>reset</code> .     ‚Äî  1   <code>shift</code> : </p><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + [?]</code> </pre> <br><p>    <code>k</code> ,   <code>?</code> .     ‚Äî <code>k(k(2))</code> .   2   ,   <code>k(2)</code>  3. ,  <code>k(3)</code>  3     ,     4. </p><br><p> <code>shift2</code>  :  k(2)    . </p><br><h3 id="ispolzuya-callcc">  <code>CallCC</code> </h3><br><p>   ,       ,     <code>CallCC</code> ,    .     ,     JS, ,      ,       .    ,    <code>CallCC</code> ,    . </p><br><p>      ‚Äî    <code>goto</code> ,       (    ): </p><br><pre> <code class="plaintext hljs">pstack = NIL; goto = false; reset = Œª(th) { CallCC(Œª(k){ pstack = cons(k, pstack); goto(th); }); }; shift = Œª(f) { CallCC(Œª(k){ goto(Œª(){ f(Œª(v){ CallCC(Œª(k1){ pstack = cons(k1, pstack); k(v); }); }); }); }); }; let (v = CallCC( Œª(k){ goto = k; k(false) } )) { if v then let (r = v(), h = car(pstack)) { pstack = cdr(pstack); h(r); } };</code> </pre> <br><p>          ‚Äî        ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444024/">https://habr.com/ru/post/fr444024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444014/index.html">Microsoft ouvre une √©cole de commerce pour apprendre les strat√©gies, la culture et la responsabilit√© de l'IA</a></li>
<li><a href="../fr444016/index.html">Obtenez plus avec Microsoft Game Stack</a></li>
<li><a href="../fr444018/index.html">Comment un changement de configuration PostgreSQL am√©liore 50 fois les performances des requ√™tes lentes</a></li>
<li><a href="../fr444020/index.html">Karting en URSS: comment le hobby des pilotes am√©ricains est devenu un hobby de bricolage massif en Union sovi√©tique</a></li>
<li><a href="../fr444022/index.html">Beego n'est plus parti</a></li>
<li><a href="../fr444026/index.html">MODX Digest # 1.1 (25 f√©vrier - 11 mars 2019)</a></li>
<li><a href="../fr444028/index.html">Pr√©sentation de Microsoft Game Stack</a></li>
<li><a href="../fr444030/index.html">Le d√©taillant en ligne chinois Gearbest a laiss√© ouverte une base de donn√©es contenant des millions de donn√©es personnelles sur les clients</a></li>
<li><a href="../fr444032/index.html">Pourquoi une imprimante 3D n'est pas une imprimante</a></li>
<li><a href="../fr444034/index.html">7 p√©ch√©s capitaux d'un manager</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>