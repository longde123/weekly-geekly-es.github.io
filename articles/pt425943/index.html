<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüç≥ ‚úîÔ∏è üèÄ Kotlin: cavando mais fundo. Construtores e Inicializadores üèÆ üë®üèº‚Äçüåæ ‚õ≤Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em maio de 2017, o Google anunciou que o Kotlin havia se tornado a linguagem oficial de desenvolvimento para o Android. Algu√©m ent√£o ouviu o nome dess...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin: cavando mais fundo. Construtores e Inicializadores</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/425943/"><img src="https://habrastorage.org/webt/fy/cu/i6/fycui6wsj3p54nc1y7v5ga_hfdq.jpeg"><br><br>  Em maio de 2017, o Google anunciou que o Kotlin havia se tornado a linguagem oficial de desenvolvimento para o Android.  Algu√©m ent√£o ouviu o nome desse idioma pela primeira vez, algu√©m o escreveu por um longo tempo, mas a partir desse momento ficou claro que todos os que est√£o pr√≥ximos do desenvolvimento do Android agora s√£o obrigados a conhec√™-lo.  Seguiram-se respostas entusiasmadas "Finalmente!" E terr√≠vel indigna√ß√£o "Por que precisamos de um novo idioma?"  O que Java n√£o agradou? ‚Äù  etc.  etc. <br><br>  Passou bastante tempo desde ent√£o e, embora o debate sobre se o Kotlin seja bom ou ruim ainda n√£o tenha diminu√≠do, mais e mais c√≥digos para Android est√£o escritos nele.  E at√© desenvolvedores bastante conservadores tamb√©m est√£o mudando para ele.  Al√©m disso, na rede, voc√™ pode encontrar informa√ß√µes de que a velocidade de desenvolvimento ap√≥s dominar essa linguagem aumenta em 30% em compara√ß√£o com Java. <br><br>  Hoje, Kotlin j√° conseguiu se recuperar de v√°rias doen√ßas da inf√¢ncia, cheio de muitas perguntas e respostas no Stack Overflow.  A olho nu, suas vantagens e fraquezas se tornaram vis√≠veis. <br><br>  E nessa onda, ocorreu-me a id√©ia de analisar em detalhes os elementos individuais de uma linguagem jovem, mas popular.  Preste aten√ß√£o a pontos complexos e compare-os com Java para maior clareza e melhor entendimento.  Para entender a quest√£o um pouco mais do que isso, voc√™ pode ler a documenta√ß√£o.  Se este artigo despertar interesse, provavelmente criar√° a base para toda uma s√©rie de artigos.  Enquanto isso, come√ßarei com coisas bastante b√°sicas, que, no entanto, escondem muitas armadilhas.  Vamos falar sobre construtores e inicializadores no Kotlin. <a name="habracut"></a><br><br>  Como em Java, no Kotlin, a cria√ß√£o de novos objetos - entidades de um determinado tipo - ocorre chamando o construtor de classe.  Voc√™ tamb√©m pode passar argumentos para o construtor, e pode haver v√°rios construtores.  Se voc√™ observar esse processo de fora, a √∫nica diferen√ßa do Java √© a falta da nova palavra-chave ao chamar o construtor.  Agora d√™ uma olhada mais profunda e veja o que acontece dentro da classe. <br><br>  Uma classe pode ter construtores prim√°rio e secund√°rio. <br>  Um construtor √© declarado usando a palavra-chave construtor.  Se o construtor principal n√£o tiver modificadores de acesso e anota√ß√µes, a palavra-chave poder√° ser omitida. <br>  Uma classe pode n√£o ter construtores declarados explicitamente.  Nesse caso, ap√≥s a declara√ß√£o da classe, n√£o h√° constru√ß√µes, prosseguimos imediatamente para o corpo da classe.  Se tra√ßarmos uma analogia com Java, isso equivale √† aus√™ncia de uma declara√ß√£o expl√≠cita de construtores, como resultado do qual o construtor padr√£o (sem par√¢metros) ser√° gerado automaticamente no est√°gio de compila√ß√£o.  Parece como o esperado: <br><br><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span></span></code> </pre> <br>  Isso √© equivalente √† seguinte entrada: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Mas se voc√™ escrever dessa maneira, ser√° educadamente solicitado a remover o construtor principal sem par√¢metros. <br><br>  O construtor prim√°rio √© aquele que sempre √© chamado quando um objeto √© criado, caso ele exista.  Enquanto levamos isso em considera√ß√£o, e o analisaremos com mais detalhes posteriormente, quando passarmos para os construtores secund√°rios.  Portanto, lembramos que, se n√£o h√° construtores, de fato h√° um (prim√°rio), mas n√£o o vemos. <br><br>  Se, por exemplo, queremos que o construtor prim√°rio sem par√¢metros n√£o tenha acesso p√∫blico, juntamente com a modifica√ß√£o <code>private</code> , precisaremos declar√°-lo explicitamente com a palavra-chave <code>constructor</code> . <br><br>  A principal caracter√≠stica do construtor prim√°rio √© que ele n√£o possui um corpo, ou seja,  n√£o pode conter c√≥digo execut√°vel.  Simplesmente leva os par√¢metros para si e os passa profundamente para a classe para uso futuro.  No n√≠vel da sintaxe, fica assim: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, param2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Os par√¢metros passados ‚Äã‚Äãdessa maneira podem ser usados ‚Äã‚Äãpara v√°rias inicializa√ß√µes, mas n√£o mais.  Em sua forma pura, n√£o podemos usar esses argumentos no c√≥digo de trabalho da classe.  No entanto, podemos inicializar os campos da classe aqui.  √â assim: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val param1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> param2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Aqui, <code>param1</code> e <code>param2</code> podem ser usados ‚Äã‚Äãno c√≥digo como campos da classe, que √© equivalente ao seguinte: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int, param3: Boolean)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ val param1 = p1 var param2 = p2 // some code }</span></span></span></span></code> </pre><br>  Bem, se voc√™ comparar com Java, seria assim (e, a prop√≥sito, neste exemplo, voc√™ pode avaliar quanto o Kotlin pode reduzir a quantidade de c√≥digo): <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String param1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer param2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyClassAJava(String p1, Integer p2, <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> param3) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param1 = p1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = p2; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String getParam1() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param1; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Integer getParam2() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param2; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void setParam2(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer param2) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = param2; } <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Vamos falar sobre designers adicionais.  Eles s√£o mais remanescentes dos construtores comuns em Java: eles aceitam par√¢metros e podem ter um bloco execut√°vel.  Ao declarar construtores adicionais, a palavra-chave construtor √© necess√°ria.  Como mencionado anteriormente, apesar da possibilidade de criar um objeto chamando um construtor adicional, o construtor principal (se houver) tamb√©m deve ser chamado com a ajuda da <code>this</code> .  No n√≠vel da sintaxe, isso est√° organizado da seguinte maneira: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1: String) { <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  I.e.  o construtor adicional √©, por assim dizer, o herdeiro do prim√°rio. <br>  Agora, se criarmos um objeto chamando um construtor adicional, acontecer√° o seguinte: <br><br>  chamar um construtor adicional; <br>  chame o construtor principal; <br>  inicializa√ß√£o de um campo da classe <code>p1</code> no construtor principal; <br>  execu√ß√£o de c√≥digo no corpo de um construtor adicional. <br><br>  Isso √© semelhante a uma constru√ß√£o desse tipo em Java: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String param1; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1)</span></span></span><span class="hljs-function"> </span></span>{ param1 = p1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, Boolean param3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1); <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Lembre-se de que em Java podemos chamar um construtor de outro usando a <code>this</code> apenas no in√≠cio do corpo do construtor.  Em Kotlin, essa quest√£o foi decidida radicalmente - eles fizeram essa liga√ß√£o parte da assinatura do construtor.  Apenas no caso, observo que √© proibido chamar qualquer construtor (prim√°rio ou adicional) diretamente do corpo do construtor adicional. <br><br>  Um construtor adicional sempre deve se referir ao principal (se houver), mas pode faz√™-lo indiretamente, referindo-se a outro construtor adicional.  O ponto principal √© que, no final da cadeia, ainda chegamos ao ponto principal.  O acionamento dos construtores obviamente ocorrer√° na ordem inversa dos projetistas se voltando um para o outro: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA(p1: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) <span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String, p2: Int, p3: Boolean) : this(p1) { // some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int, p3: Boolean, p4: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> :</span></span> this(p1, p2, p3) <span class="hljs-comment"><span class="hljs-comment">{ // some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Agora a sequ√™ncia √©: <br><br><ul><li>  chamando um construtor adicional com 4 par√¢metros; </li><li>  chamando um construtor adicional com 3 par√¢metros; </li><li>  chame o construtor prim√°rio; </li><li>  inicializa√ß√£o de um campo da classe p1 no construtor prim√°rio; </li><li>  execu√ß√£o de c√≥digo no corpo do construtor com 3 par√¢metros; </li><li>  execu√ß√£o de c√≥digo no corpo do construtor com 4 par√¢metros. </li></ul><br>  De qualquer forma, o compilador nunca nos esquecer√° de chegar ao construtor principal. <br><br>  Acontece que uma classe n√£o possui um construtor prim√°rio, enquanto pode ter um ou mais adicionais.  Portanto, construtores adicionais n√£o precisam se referir a algu√©m, mas tamb√©m podem se referir a outros construtores adicionais dessa classe.  Anteriormente, descobrimos que o construtor principal, n√£o especificado explicitamente, √© gerado automaticamente, mas isso se aplica a casos em que n√£o h√° construtores na classe.  Se houver pelo menos um construtor adicional, um construtor prim√°rio sem par√¢metros n√£o ser√° criado: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Podemos criar um objeto de classe chamando: <br><br><pre> <code class="hljs lisp">val myClassA = MyClassA()</code> </pre> <br>  Nesse caso: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Podemos criar um objeto apenas com esta chamada: <br><br><pre> <code class="hljs pgsql">val myClassA = MyClassA(‚Äú<span class="hljs-keyword"><span class="hljs-keyword">some</span></span> string‚Äù, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br>  N√£o h√° nada novo no Kotlin comparado ao Java. <br><br>  A prop√≥sito, como o construtor principal, o construtor adicional pode n√£o ter um corpo se sua tarefa √© apenas passar par√¢metros para outros construtores. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1, p2, p3, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(p1: String, p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>, p4: String) { <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Tamb√©m vale a pena prestar aten√ß√£o ao fato de que, diferentemente do construtor prim√°rio, a inicializa√ß√£o dos campos de classe na lista de argumentos do construtor adicional √© proibida. <br>  I.e.  esse registro ser√° inv√°lido: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p1: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Separadamente, √© importante notar que o construtor adicional, como o principal, pode estar sem par√¢metros: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">// some code } // some code }</span></span></code> </pre><br>  Falando em construtores, n√£o se pode deixar de mencionar um dos recursos convenientes de Kotlin - a capacidade de atribuir valores padr√£o para argumentos. <br><br>  Agora, suponha que tenhamos uma classe com v√°rios construtores que possuem um n√∫mero diferente de argumentos.  Vou dar um exemplo em Java: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String param1; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer param2; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> param3; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> param4; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (p1, <span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (p1, p2, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p1, p2, p3, <span class="hljs-number"><span class="hljs-number">20</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param1 = p1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param2 = p2; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param3 = p3; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.param4 = p4; } <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Como mostra a pr√°tica, esses projetos s√£o bastante comuns.  Vamos ver como o mesmo pode ser escrito no Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassA</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p3: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p4: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">20</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Agora, vamos dar um tapinha no Kotlin para saber quanto ele cortou o c√≥digo.  A prop√≥sito, al√©m de reduzir o n√∫mero de linhas, temos mais pedidos.  Lembre-se, voc√™ deve ter visto algo assim mais de uma vez: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String p1, Integer p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(p3, p1, p2, <span class="hljs-number"><span class="hljs-number">20</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClassAJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p1, String p2, Integer p3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br>  Quando voc√™ v√™ isso, deseja encontrar a pessoa que o escreveu, pegue-a por um bot√£o, traga-a para a tela e pergunte com uma voz triste: "Por qu√™?" <br>  Embora voc√™ possa repetir esse feito no Kotlin, mas n√£o √© necess√°rio. <br><br>  No entanto, h√° um detalhe que, no caso de uma nota√ß√£o abreviada no Kotlin, √© necess√°rio levar em considera√ß√£o: se queremos chamar o construtor com valores padr√£o do Java, devemos adicionar a anota√ß√£o <b><code>@JvmOverloads</code></b> : <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassA @JvmOverloads <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p2: Int = 5, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p3: Boolean = true, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p4: Int = 20)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ // some code }</span></span></span></span></code> </pre><br>  Caso contr√°rio, obteremos um erro. <br><br>  Agora vamos falar <b>sobre inicializadores</b> . <br><br>  Um inicializador √© um bloco de c√≥digo marcado com a palavra-chave <code>init</code> .  Nesse bloco, voc√™ pode executar alguma l√≥gica para inicializar os elementos da classe, incluindo o uso dos valores dos argumentos que vieram no construtor prim√°rio.  Tamb√©m podemos chamar fun√ß√µes deste bloco. <br><br>  Java tamb√©m possui blocos de inicializa√ß√£o, mas estes n√£o s√£o a mesma coisa.  Neles, n√£o podemos, como em Kotlin, passar um valor de fora (os argumentos do construtor prim√°rio).  O inicializador √© muito semelhante ao corpo do construtor prim√°rio, retirado em um bloco separado.  Mas √© √† primeira vista.  De fato, isso n√£o √© inteiramente verdade.  Vamos acertar. <br><br>  Um inicializador tamb√©m pode existir quando n√£o h√° construtor prim√°rio.  Nesse caso, seu c√≥digo, como todos os processos de inicializa√ß√£o, √© executado antes do c√≥digo do construtor adicional.  Pode haver mais de um inicializador.  Nesse caso, a ordem da chamada coincidir√° com a ordem da localiza√ß√£o no c√≥digo.  Observe tamb√©m que a inicializa√ß√£o do campo de classe pode ocorrer fora dos blocos <code>init</code> .  Nesse caso, a inicializa√ß√£o tamb√©m ocorre de acordo com a disposi√ß√£o dos elementos no c√≥digo, e isso deve ser levado em considera√ß√£o ao chamar m√©todos do bloco inicializador.  Se voc√™ o fizer de maneira descuidada, h√° uma chance de ocorrer um erro. <br><br>  Vou lhe dar alguns casos interessantes de trabalhar com inicializadores. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span> showTestParam() } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testParam: String = <span class="hljs-string"><span class="hljs-string">"after"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTestParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br>  Este c√≥digo √© bastante v√°lido, embora n√£o seja bastante √≥bvio.  Se voc√™ observar, poder√° ver que a atribui√ß√£o de um valor ao campo <code>testParam</code> no bloco inicializador ocorre antes que o par√¢metro seja declarado.  A prop√≥sito, isso s√≥ funciona se tivermos um construtor adicional na classe, mas n√£o tivermos um construtor prim√°rio (se aumentarmos a declara√ß√£o do campo <code>testParam</code> acima do bloco <code>init</code> , ele funcionar√° sem um construtor).  Se descompilarmos o c√≥digo de bytes dessa classe em Java, obteremos o seguinte: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String getTestParam() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void setTestParam(<span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> String var1) { Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = var1; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void showTestParam() { Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyClassB() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showTestParam(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam = <span class="hljs-string"><span class="hljs-string">"after"</span></span>; Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testParam); } }</code> </pre><br>  Aqui vemos que a primeira chamada ao campo durante a inicializa√ß√£o (no bloco <code>init</code> ou fora dele) √© equivalente √† sua inicializa√ß√£o usual em Java.  Todas as outras a√ß√µes associadas √† atribui√ß√£o de um valor durante o processo de inicializa√ß√£o, exceto a primeira (a primeira atribui√ß√£o de um valor √© combinada com a declara√ß√£o de campo), s√£o transferidas para o construtor. <br>  Se realizarmos experimentos com descompila√ß√£o, verifica-se que, se n√£o houver construtor, o construtor prim√°rio ser√° gerado e toda a m√°gica acontecer√° nele.  Se houver v√°rios construtores adicionais que n√£o se referem um ao outro e n√£o houver um prim√°rio, no c√≥digo Java desta classe todas as atribui√ß√µes subseq√ºentes ao campo <code>testParam</code> duplicadas em todos os construtores adicionais.  Se houver um construtor prim√°rio, somente no prim√°rio.  Fuf ... <br><br>  E o mais interessante para <code>testParam</code> : <code>testParam</code> mudar a assinatura <code>testParam</code> de <code>var</code> para <code>val</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"some string"</span></span> showTestParam() } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { testParam = <span class="hljs-string"><span class="hljs-string">"new string"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testParam: String = <span class="hljs-string"><span class="hljs-string">"after"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in constructor testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTestParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Log.i(<span class="hljs-string"><span class="hljs-string">"wow"</span></span>, <span class="hljs-string"><span class="hljs-string">"in showTestParam testParam = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$testParam</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre><br>  E em algum lugar do c√≥digo que chamamos: <br><br><pre> <code class="hljs cs">MyClassB myClassB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClassB();</code> </pre><br>  Tudo compilado sem erros, iniciado, e agora vemos a sa√≠da dos logs: <br><br>  em showTestParam testParam = alguma string <br>  no construtor testParam = depois <br><br>  Acontece que o campo declarado como <code>val</code> alterou o valor durante a execu√ß√£o do c√≥digo.  Porque  Eu acho que isso √© uma falha no compilador Kotlin e, no futuro, talvez isso n√£o seja compilado, mas hoje tudo est√° como est√°. <br><br>  Tirando conclus√µes dos casos acima, s√≥ √© aconselh√°vel n√£o produzir blocos de inicializa√ß√£o e n√£o espalh√°-los pela classe, evitar atribui√ß√µes repetidas de valores durante o processo de inicializa√ß√£o, chamar apenas fun√ß√µes puras dos blocos init.  Tudo isso √© feito para evitar poss√≠veis confus√µes. <br><br>  Ent√£o  <b>Inicializadores s√£o um determinado bloco de c√≥digo que deve ser executado ao criar um objeto, independentemente de qual construtor esse objeto √© criado.</b> <br><br>  Parece resolvido.  Considere a intera√ß√£o de construtores e inicializadores.  Dentro de uma classe, tudo √© bastante simples, mas voc√™ precisa se lembrar: <br><br><ul><li>  chamar um construtor adicional; </li><li>  chame o construtor prim√°rio; </li><li>  inicializa√ß√£o de campos de classe e blocos de inicializador na ordem de sua localiza√ß√£o no c√≥digo; </li><li>  execu√ß√£o de c√≥digo no corpo de um construtor adicional. </li></ul><br>  Casos com heran√ßa parecem mais interessantes. <br><br>  Vale a pena notar que, como Object √© a base para todas as classes em Java, qualquer um √© igual ao Kotlin.  No entanto, Any e Object n√£o s√£o a mesma coisa. <br><br>  Para come√ßar como a heran√ßa funciona.  A classe descendente, como a classe pai, pode ou n√£o ter um construtor prim√°rio, mas deve se referir a um construtor espec√≠fico da classe pai. <br><br>  Se a classe descendente tiver um construtor prim√°rio, esse construtor dever√° apontar para um construtor espec√≠fico da classe base.  Nesse caso, todos os construtores adicionais da classe sucessora devem se referir ao construtor principal de sua classe. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassC</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassA</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">) { constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p2</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">): this(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p1</span></span></span><span class="hljs-class">) { //some code } //some code }</span></span></code> </pre><br>  Se a classe descendente n√£o tiver um construtor prim√°rio, cada um dos construtores adicionais dever√° acessar o construtor da classe pai usando a palavra <code>super</code> chave <code>super</code> .  Nesse caso, diferentes construtores adicionais da classe sucessora podem acessar diferentes construtores da classe pai: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassA <span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String): super(p1) { //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int)</span></span></span><span class="hljs-function">:</span></span> super(p1, p2) <span class="hljs-comment"><span class="hljs-comment">{ //some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Al√©m disso, n√£o se esque√ßa da possibilidade de chamar indiretamente o construtor da classe pai atrav√©s de outros construtores da classe derivada: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassA<span class="hljs-comment"><span class="hljs-comment">{ constructor(p1: String): super(p1){ //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: Int)</span></span></span><span class="hljs-function">:</span></span> this (p1)<span class="hljs-comment"><span class="hljs-comment">{ //some code }</span></span> <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  Se a classe descendente n√£o tiver construtores, basta adicionar a chamada de construtor da classe pai ap√≥s o nome da classe descendente: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClassC</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyClassA</span></span></span></span>(‚Äúsome string‚Äù) { <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre><br>  No entanto, ainda existe uma op√ß√£o com heran√ßa, na qual uma refer√™ncia ao construtor da classe pai n√£o √© necess√°ria.  Esse registro √© v√°lido: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClassC : MyClassB <span class="hljs-comment"><span class="hljs-comment">{ constructor(){ //some code }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ }</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//some code }</span></span></span></span></code> </pre><br>  Mas somente se a classe pai tiver um construtor sem par√¢metros, que √© o construtor padr√£o (prim√°rio ou opcional - isso n√£o importa). <br><br>  Agora considere a ordem de chamada de inicializadores e construtores durante a heran√ßa: <br><br><ul><li>  chamar o construtor adicional do herdeiro; </li><li>  chamar o construtor principal do herdeiro; </li><li>  chamando o construtor adicional do pai; </li><li>  chame o construtor principal do pai; </li><li>  <code>init</code> blocos de <code>init</code> pai </li><li>  execu√ß√£o do c√≥digo do corpo do construtor adicional do pai; </li><li>  execu√ß√£o do bloco herdeiro <code>init</code> ; </li><li>  execu√ß√£o do c√≥digo do corpo do construtor adicional do herdeiro. </li></ul><br>  Vamos falar sobre compara√ß√£o com Java, na qual, de fato, n√£o existe um an√°logo do construtor principal do Kotlin.  Em Java, todos os construtores s√£o pares e podem ser chamados ou n√£o um do outro.  No Java e no Kotlin, existe um construtor padr√£o, √© um construtor sem par√¢metros, mas ele adquire um status especial somente ao herdar.  Aqui vale a pena prestar aten√ß√£o ao seguinte: ao herdar o Kotlin, devemos dizer explicitamente √† classe sucessora qual construtor da classe pai usar - o compilador n√£o nos deixar√° esquec√™-la.  Em Java, n√£o podemos indicar isso explicitamente.  Cuidado: nesse caso, o construtor padr√£o da classe pai ser√° chamado (se houver). <br><br>  Nesta fase, assumiremos que estudamos profundamente os designers e inicializadores e agora sabemos quase tudo sobre eles.  Descansaremos um pouco e cavaremos na outra dire√ß√£o! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425943/">https://habr.com/ru/post/pt425943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425931/index.html">‚ÄúQuero deixar a f√°brica na web‚Äù - 10 perguntas ao programador, 8¬™ edi√ß√£o</a></li>
<li><a href="../pt425933/index.html">Umidade no data center: por que √© importante</a></li>
<li><a href="../pt425935/index.html">Suspens√£o da unidade de sistema sob a mesa de p√©</a></li>
<li><a href="../pt425937/index.html">CoreBluetooth na pr√°tica</a></li>
<li><a href="../pt425939/index.html">DataIncrement - al√©m dos recursos do phpMyAdmin</a></li>
<li><a href="../pt425945/index.html">Dicas para uso profissional do RecyclerView. Parte 1</a></li>
<li><a href="../pt425947/index.html">Ratatouille corporativo</a></li>
<li><a href="../pt425951/index.html">Como blockchain e criptomoedas invadiram: 6 ataques bem-sucedidos "51%"</a></li>
<li><a href="../pt425953/index.html">Esta√ß√£o meteorol√≥gica no Arduino de A a Z. Parte 3</a></li>
<li><a href="../pt425955/index.html">8 bugs interessantes do iOS 12 beta e como os procuramos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>