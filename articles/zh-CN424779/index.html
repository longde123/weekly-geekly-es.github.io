<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🤝‍👨🏼 🤹 🐉 Python中的多页SPA 🍦 🤹🏿 🧘🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Python和React之间的桥梁 

 猫头鹰是可以集成到其他框架中的纳米框架。 
 来自sova.online的图片，运行3个http服务器： 
 http://sova.online/-只是猎鹰 
 http://sova.online:8000/-仅Django 
 http://sova....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python中的多页SPA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424779/">  <b>Python和React之间的桥梁</b> <br><br> 猫头鹰是可以集成到其他框架中的纳米框架。 <br> 来自sova.online的图片，运行3个http服务器： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://sova.online/-</a>只是猎鹰 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://sova.online:8000/-</a>仅Django <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://sova.online:8001/-</a>仅Python（登录：1，密码：1） <br> 有源代码和安装说明。 那里没有广告。 <br><br><img src="https://habrastorage.org/webt/gx/yn/h9/gxynh9nwwhuq9ik8ius_k7lvjgo.jpeg"><br><a name="habracut"></a><br> 用Python在React上渲染并创建站点的想法并不新鲜。 有一个很棒的框架<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://plot.ly/products/dash/</a> ，为什么还要做其他事情？ <br> 说明：Owl不是为网站开发而设计的。 这是一个用通过浏览器运行的应用程序（桌面应用程序）替换胖客户端的工具。 <br><br>  -什么是网络客户端？ <br>  -不 这不是Web客户端。 这是一个浏览器应用程序。 <br>  “我不明白。” <br>  -不幸的是，许多开发人员不了解。 <br><br> 总的来说，我积极参与了多个Internet应用程序。 <br><br>  <b>Ugra银行的在线客户（该银行已关闭）。</b> <br> 这是一个很好的应用程序，但它是一个Java applet，即 从浏览器启动胖客户端。 还有乌格拉河岸和过去的小程序。 <br><br>  <b>VTB-24银行在线客户（银行已关闭）。</b> <br> 我是一个人道主义者，但是在创造了这个奇迹之后，残酷的想法开始出现，例如：“强迫开发人员在其中注册1000张薪水”。 <br> 而且，作为一个网络客户端，他很漂亮。 动画在手机上打开。 哇！ 好酷！ <br> 我问一位朋友会计师：您如何与他合作？ <br> 她说：太好了！ 我以1s加载数据，以1s工作，然后将结果上传回去。 <br><br>  <b>Sberbank在线客户</b> <br> 满意的客户，您可以工作。 当要求我给他评分时，我给他5分中的3分，并给了他评论列表。 这是我每月10笔付款。 每天赚100张账单的人可能会上传信息。 <br><br> 填写付款。 <br><img src="https://habrastorage.org/webt/kx/0a/h2/kx0ah27hdkvgc6ob0-16ifdx5oq.jpeg"><br> 菜单占绿色的区域，占屏幕的20％。 它不只是干扰（位置：固定），还说开发人员不是专业人士。 如果我开始创建付款，则屏幕应该是。  3个按钮：“创建”，“另存为模板”，“取消”。 这些按钮是（出于以下某些原因）。 这不是多页SPA：如果单击菜单项，则表单中的数据将丢失。 <br> 这样做的人甚至都不知道这是什么打击：“通常，每个人都这样做，例如图书馆，人们在工作……”。 他是对的。 您需要向项目经理询问，对于经理来说，最主要的是概念模型中的数据库和层。 和形式-我们将聘请男孩，他们会画画。 他们可能为此感到骄傲。 <br><br>  <b>交易大厅（5件，44项联邦法律）</b> <br> 这些是真正的应用程序（不是Web客户端）。 但是我不喜欢现场控制器。 <br> 范例： <br><img src="https://habrastorage.org/webt/ap/wl/in/apwlinkughplv39l_m4qsopioza.jpeg"><br><br> 这是奇怪的对齐方式，字段的宽度明显不足，输入字段中没有自动高度。 <br><br> 另一个例子。  “发布日期”字段中没有dd.mm.yyyy模板，日历错误，日历图标令人恐惧： <br><img src="https://habrastorage.org/webt/zl/lk/6z/zllk6zxsfvaoxyq9qk7p9unosjw.jpeg"><br><br> 在rts-tender上列出：当前条目以彩色突出显示，箭头可以在列表中四处移动，但没有自动滚动（您可以远离屏幕边框），Enter或空格都不打开链接，选项卡未附加到当前记录。 尽管只能用鼠标打开链接，但我给控件加了一个加号。 这样的功能（记住并突出显示当前文档）对于我在mail.ru中是不够的 <br><br> 似乎有些小事。 但是专业应用在细节上与半专业有所不同。 最终用户不会告诉您您拥有什么数据库以及概念模型中的多少层。 它以屏幕形式工作，并具有3个要求：功能性，便捷性，快速性。 <br> 不幸的是，系统的选择是由IT专家和老板决定的，他们本身并不使用该系统，也将无法使用。 他们会欣赏速度，在理解功能的同时会欣赏它们的功能，并且他们不会对便利性一窍不通，最重要的是要美观。 <br>  Pavel Valeryevich Durov既没有发明社交网络也不是信使。 他方便，美观地完成了用户所需的操作。 人们对此表示赞赏，包括在经济上。 <br><br> 猫头鹰是用于构建专业界面的工具。 <br> 这意味着什么，例如EDMS。 <br><br> 有一个EDMS，它具有3个用户组： <br> 上级 <br> 文件准备专员 <br> 办公室文员。 <br><br> 老板，他们就像孩子。 它们必须简单美观。 理想情况下为1个按钮和1个字段。 并炫耀更多。 一个Web客户端，当然还有一个炫耀的移动客户端。 <br><br> 专家。 网络客户端，跨社交网络/邮件。 不要忘记有很多专家，他们需要接受培训。 环境对他们来说越熟悉，越好。 如果安全服务允许，移动客户端也将派上用场。 <br><br> 办公室文员。 这是猫头鹰派上用场的地方。 办公室文员是一群形成系统的用户。 其他所有人都会生病/休假/停止使用它-EDMS将起作用。 如果注册停止，一切都会结束。 <br> 文书工作是一条传送带，在这里一切都很重要，任何琐碎的事情：字体，半色调，自动填充，检查值，易于输入等。 <br>  EDS“案例”。 表演者的办公室是在网络客户端上建立的，办公室是一个胖客户端。 一切都很好，但是它将一直有效，直到政府禁止政府机构使用Windows。 我喜欢Win 7，但如果我是统治者，那么IT市场就会充满新订单，而MS仍然记忆犹新。 顺便说一句，在12月6日，安东·席拉扬诺夫（Anton Siluanov）签署了向家用软件过渡的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指令</a> 。 <br><br>  <b>网上在线</b> <br><br> 猫头鹰如何打开表格。 <br> 没有多页。 <br> 猫头鹰的中心元素是文档组件。 通过在起始页上按ctrl-U，您将看到创建Document类的对象所需的一切： <br>  -数据库的数据字段； <br>  -要显示的表单的网址； <br>  -dbAlias，unid-用于处理数据库； <br>  -还有其他东西。 <br><br> 在某种程度上，Document是Redux格式的类似物。 <br> 表单作为JSON字符串加载，然后前一个字典成为具有样式，className和元素数组（列表）的对象。 数组将以以下形式插入到id = root的元素中 <pre><code class="plaintext hljs">&lt;div style className&gt;……&lt;/div&gt;</code> </pre> <br> 数组元素是描述标签的对象。 <pre> <code class="plaintext hljs">&lt;div&gt;, &lt;a&gt;, &lt;img&gt;, &lt;button&gt;</code> </pre>  ，数组或组件。 <br> 装箱功能负责解析数组。 如果遇到包含数组的元素，它将递归调用自身。 <br> 地球的肚脐当然是一个div。 <br> 在最简单的情况下，这是一行：dict（div ='Hello'，className ='h2'） <br> 但是可能会有一个数组（array of arrays）： <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">style</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(**par)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">'style'</span></span>: {**par}} dict( <span class="hljs-comment"><span class="hljs-comment">#     sova.online style(position='relative'), readOnly = 1, div = [ dict( style(width=1000, margin='auto', paddingTop=20), div=[ { 'div': subFormTop.panel() }, { 'div': [subFormLeft.panel(), subFormRight.panel()], 'className': 'row' }, # { 'div': [subFormDown.panel()] }, ]), ] )</span></span></code> </pre> <br><br> 有3个面板（每个面板在一个单独的文件中：subFormTop.py等）。 <br>  subFormTop.panel（）返回一个数组以构建顶部面板。 <br>  subFormLeft.panel（）和subFormRight.panel（）组合成一个字符串（“ className”：“ row”），并描述左右面板。 <br>  subFormDown.panel（）已被注释掉（无用）。 <br><br> 这似乎很复杂。 但这是Python：一切都可以简化。 <br> 期刊“报告”中表格的示例。  labField函数（标签，DB_field_name）返回一个包含两个字典的数组（表行）：第一个字典是{'div'：label}，第二个字典是{'field'：[DB_field_name，'tx']}。 <br><pre> <code class="python hljs">div = [ docTitle(<span class="hljs-string"><span class="hljs-string">''</span></span>), dict ( wl=<span class="hljs-string"><span class="hljs-string">'40mm'</span></span>, className=<span class="hljs-string"><span class="hljs-string">'cellbg-green'</span></span>, div=_table( labField(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'nodafd'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'_STARTINGTIME'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'_ENDTIME'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'CREATOR'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'REPORTCAT'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'REPORTNAME'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'REPORTTITLE'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'dt1'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'dt2'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">'  2'</span></span>, <span class="hljs-string"><span class="hljs-string">'dt3'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">'  2'</span></span>, <span class="hljs-string"><span class="hljs-string">'dt4'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'LBYEARS'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'GRGROUP'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'QUERYMAIN'</span></span>), labField(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'NOTES'</span></span>), )), sent(), ]</code> </pre><br><br><img src="https://habrastorage.org/webt/7u/ah/tw/7uahtweb5axodfbphubw5v3-okw.jpeg"><br><br> 来自sova / api / forms / home / top.py的示例（从sova.online开始）： <br><br>  python字典 <br>  {'a'：'React v16'，'href'：'https：//reactjs.org'} <br> 产生清晰的React组件 <br><pre> <code class="plaintext hljs">&lt;a href={'https://reactjs.org'}&gt;React v16&lt;/a&gt;</code> </pre> <br><br>  Img比标准聪明-在道具中，您可以指定href和目标： <br><br>  Python： <br>  dict（img ='image？react.ico'，style = {'width'：16}，href ='https：//reactjs.org'） <br><br> 将对象数组转换为组件的解析器的一部分（boxing.js）： <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( td.img ) { <span class="hljs-comment"><span class="hljs-comment">// td –    let img = &lt;img src={td.img} _/&gt;; return td.href ? &lt;a href={td.href} key={i} target={td.target}&gt;{img}&lt;/a&gt; : img; }</span></span></code> </pre><br><br> 输入搜索引擎“反应组件库”。 结果是可以预见的-很多。 但是，所有这些丰富的都是针对网站的，而不是针对应用程序的： <br> 智能文本区域也许是唯一适合我的控件。 <br>  React-select-简化并重新放置下拉列表 <br> 数据选择器/日历-找不到合适的东西。 他以内置的G.Chrome为例，编写了自己的文章。 <br> 上传/下载-没有合适的东西，写了我自己的。 <br><br> 恕我直言：网站的前景可悲。 在不久的将来，绝大多数用户将停止使用浏览器（或已经停止使用）。 手机将与平板电脑一起成长，十个应用程序中的一小部分将完全满足需求。 <br> 我已经遇到两次程序员，他们不知道如何正确编写电子邮件地址。 他们为什么要记住自己不使用的东西。 世界在变化。 <br><br> 在Owl中，控制器并不是完美的，但它们是为操作员而非Web用户设计的。 <br> 例如，“转让商标”表格。 一种相当通用的形式，用于有老板的地方。 屏幕快照中以红色圈出了用于控制隐藏的字段。 如果在执行部分中有一些针对不同表演者的不同条款的说明，则其他决议会在填充时自动打开。 每组两个学期：第一学期至第一表演者，第二学期至共同执行者。 <br><img src="https://habrastorage.org/webt/yg/2q/f4/yg2qf4g9p3umqggkpduhnv4rgis.jpeg"><br><br> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>触摸表格 <br><br> 控制器是与数据库字段关联的React组件。 <br> 可以检查其操作的控制器的详细说明在Sova.online上。 <br> 注意rtf和json类型。  Rtf显示为文本，但是如果文本中存在{_ {object} _}构造，Owl将对此构造执行json.parse并将结果添加到表单中。  json类型的字段应存储标记元素数组的描述：[{ele1}，{ele2}，...]。  json.parse在渲染之前执行。 <br> 这些类型的字段允许您将标记存储在数据库或文件中。 对于报告和编写文档很有用。 <br><br> 所有类型的字段的控制器列表（controllers.js）： <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> controller = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (prop.type) { <span class="hljs-comment"><span class="hljs-comment">//  case 'chb': return &lt;Checkbox {...prop}/&gt;; case 'lbse': // listbox single enable (    ) case 'lbme': // listbox multivalue enable // lbse/lbme -     ,   case 'tx': return &lt;Text {...prop}/&gt;; // smart-textarea case 'lbsd': // listbox single disables (    ) case 'lbmd': return &lt;ListBox {...prop}/&gt;; case 'dt': return (prop.readOnly ? &lt;Text {...prop} xValue={Util.dtRus(prop.xValue)} /&gt; : &lt;Datepicker {...prop}/&gt;); case 'fd': return &lt;ForDisplayOnly {...prop}/&gt;; case 'table': case 'gr': return &lt;Table {...prop}/&gt;; case 'rtf': return &lt;RTF {...prop}/&gt;; case 'json': return &lt;JsonArea {...prop}/&gt;; case 'list': return &lt;List {...prop}/&gt;; case 'view': return &lt;View {...prop}/&gt;; default: console.warn('  ', prop.xName, prop.type); return &lt;Text {...prop}/&gt;; }; };</span></span></code> </pre><br><br> 应用程序需要一种用于操纵控制器的机制。 <br> 在猫头鹰中，所有文档控制器都存储在一个文档变量中 <br> 此注册 <br> 我不敢使用裁判，因为有传闻说编辑人员会取消它。 <br> 控制器可能具有以下接口： <br>  getValue（参数） <br>  setValue（值，参数） <br>  setFocus（） <br>  changeDropList（） <br><br> 为了访问所需的字段，有一些文档方法 <br>  getField（fieldName，param） <br>  setField（fieldName，value，param） <br>  changeDropList（fieldName，参数） <br>  setFocus（fieldName） <br> 对于FileShow类型的字段，有一个方法fileShow ['FILES1 _']。HasAtt（），其中FILES1_是文件区域的名称。 如果有附件，则返回true。 在此类区域的转移标记中2。 <br><br> 控制器可以生成一个recalc事件。 如果为该字段注册了处理程序，它将执行。 处理程序位于可加载的js文件中。 <br> 一个示例和稍微简化的描述： <br> 有一种形式“转让商标”（o.py）。 它包含已加载的o.js文件 <br> 在o.js中，处理程序已注册 <br><pre> <code class="javascript hljs">recalc: { <span class="hljs-attr"><span class="hljs-attr">PROJECTO</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">doc</span></span></span><span class="hljs-function"> =&gt;</span></span> doc.forceUpdate(), <span class="hljs-attr"><span class="hljs-attr">WHOPRJ2</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">doc</span></span></span><span class="hljs-function"> =&gt;</span></span> doc.forceUpdate(), <span class="hljs-attr"><span class="hljs-attr">WHOPRJ3</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">doc</span></span></span><span class="hljs-function"> =&gt;</span></span> doc.forceUpdate(), …   }</code> </pre> <br>  ，还指定了隐藏条件（project，op，prj1，prj2 ... prj5是divs描述中的“名称”属性）： <br><pre> <code class="javascript hljs">hide: { <span class="hljs-attr"><span class="hljs-attr">project</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">doc</span></span></span><span class="hljs-function"> =&gt;</span></span> !doc.getField(<span class="hljs-string"><span class="hljs-string">'projectO'</span></span>), <span class="hljs-comment"><span class="hljs-comment">// ,   PROJECTO  op: doc =&gt; doc.getField('projectO'), // ,   PROJECTO   prj1: doc =&gt; !doc.getField('projectO'), prj2: doc =&gt; !doc.getField('projectO'), prj3: doc =&gt; !doc.getField('projectO') || (!doc.getField('whoPrj2') &amp;&amp; !doc.getField('whoPrj3')), prj4: doc =&gt; !doc.getField('projectO') || (!doc.getField('whoPrj3') &amp;&amp; !doc.getField('whoPrj4')), prj5: doc =&gt; !doc.getField('projectO') || (!doc.getField('whoPrj4') &amp;&amp; !doc.getField('whoPrj5')), },</span></span></code> </pre> <br><br> 工作原理：PROJECTO字段是一个复选框，当值更改时，控制器将生成一个recalc事件，文档将调用recalc.PROJECTO（此）处理程序。 <br> 处理程序仅调用forceUpdate（）重绘文档。 <br> 重绘时，将检查props中的组件是否具有名称，该名称是否具有hide [props.name]函数以及是否返回true。 <br>  prj3：doc =&gt;！doc.getField（'projectO'）||  （！doc.getField（'whoPrj2'）&amp;&amp; !! doc.getField（'whoPrj3'）） <br> 如果“ projectO”复选框为OFF或在决议2和决议3的字段中未输入执行者（“ whoPrj2”和“ whoPrj3”字段均为空），则隐藏第三个决议（具有props.name ==='prj3'的区域）。 <br> 调用函数时，字段名称不区分大小写。 <br>  WHOPRJ2是一个组合框；当您选择一个值时，控制器还将生成一个recalc事件，这也将导致重画。 通过选择第二个分辨率的艺术家，您将因此打开第三个分辨率。 <br><br> 在加载的js文件中，您可以： <br>  -管理隐藏； <br>  -仅管理阅读； <br>  -应对现场变化； <br>  -执行按钮命令； <br>  -在保存之前对字段和表单进行验证； <br><br> 下载表格“ fo”的文件： <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.sovaActions = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.sovaActions || {}; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.sovaActions.fo = { <span class="hljs-comment"><span class="hljs-comment">// fo –      recalc: { //           PROJECTO: doc =&gt; doc.forceUpdate(), }, hide: { //   ,  true project: doc =&gt; !doc.getField('projectO'), }, readOnly: { //     ,  true who: doc =&gt; doc.getField('SENTFROMDB'), }, validate: { //         who: doc =&gt; doc.getField('who') ? '' : '   " "', form: doc =&gt; new Promise( (yes, no) =&gt; { let disableAutoOrder = false; for (let i = 1; i &lt;= 5; i++) { let val = doc.getField('RESPRJ' + i); disableAutoOrder |= /  /.test(val); } disableAutoOrder &amp;&amp; doc.setField('AUTOORDER', ''); yes(); }), }, cmd: { //    logoff: doc =&gt; { window.location.href = '/logoff' }, }, }</span></span></code> </pre> <br><br> 字段验证-如果一切正常，则返回空的函数，或者有关错误的消息。 猫头鹰会将焦点放在无效字段上。 <br> 表格验证-承诺。 在该示例中，没有检查（总是调用“是”），只是在发送到服务器之前完成了一些操作。 <br> 在redux形式中，验证是通过trow进行的-一种野性。 <br><br>  <i>对于那些不了解诺言的人，最简单的例子是：</i> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> confirmDlg = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ok, cancel</span></span></span><span class="hljs-function">) =&gt;</span></span> confirm(msg) ? ok(<span class="hljs-string"><span class="hljs-string">'  '</span></span>) : cancel(<span class="hljs-string"><span class="hljs-string">'  cancel'</span></span>)); confirmDlg(<span class="hljs-string"><span class="hljs-string">'  '</span></span>) .then( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s)) .catch( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s));</code> </pre> <br><br>  Document类具有几个可在按钮中使用的预定义命令： <br><br> 编辑：切换到表单编辑模式 <br> 保存：保存表格 <br> 关闭：关闭表格 <br>  saveClose：保存并关闭表单 <br><br>  prn：使用选择的打印模板打印表格 <br>  docOpen：打开文件 <br>  dbOpen：打开日志 <br>  xopen：打开网址 <br>  newDoc：使用所需的表单创建一个新文档 <br><br>  Redux形式的api更丰富-在Owl中只有必需的。 <br><br>  <b>多页。</b> <br><br>  Document类创建一个嵌入到元素中的对象（窗体）。 <pre> <code class="plaintext hljs">&lt;div id="root"&gt;&lt;/div&gt;</code> </pre>  。 <br> 我们将其称为“根文档”。 如果您将元素添加到根文档中 <br>  &lt;div style = {{position：'absolute'，zIndex：999}} /&gt;，您还可以在其中插入另一个Document对象。 <br> 如何处理可加载命令处理程序？ 很简单：每个表单都有自己的处理程序（自己的js），并且根文档应加载可能需要的处理程序。 <br> 起始页示例sova.online（home.py） <br> 为了演示多页性质，home.py表单使用“ rkckg”，“ outlet”，“ outlet.gru”，“ o”形式打开文档。 <br> 为了使所有表单正常工作，您需要在home.py中注册这些表单的脚本： <br><pre> <code class="python hljs">javaScriptUrl = [<span class="hljs-string"><span class="hljs-string">'jsv?api/forms/rkckg/rkckg.js'</span></span>, <span class="hljs-string"><span class="hljs-string">'jsv?api/forms/outlet_gru/outlet_gru.js'</span></span>, <span class="hljs-string"><span class="hljs-string">'jsv?api/forms/outlet/outlet.js'</span></span>, <span class="hljs-string"><span class="hljs-string">'jsv?api/forms/o/o.js'</span></span>, <span class="hljs-string"><span class="hljs-string">'jsv?api/forms/home/home.js'</span></span>]</code> </pre> <br><br> 由于调用处理程序的任何功能时，第一个参数会将链接传递到文档，因此将对所需文档执行操作。 <br><br>  OOP，没有奇迹。 <br><br> 反应-不是反应 <br> 我已经描述了报告表格。 它从报告管理器打开（箭头“ React”），并描述用于收集报告的参数。 <br><img src="https://habrastorage.org/webt/rp/tb/vj/rptbvjkspfqes5nxti7wfmitbtu.jpeg"><br> 报告本身（箭头“ not React”）以html附件的形式存储在下级文档中，形式为“ rreport”。 当React不存在时，我们就参与了报告的开发，“报告”表单很简单（html的20行和js的15行），为什么要改变8年的工作原理。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">打开报表管理器。</a> <br><br>  rreport表单包含4个按钮和一个iframe。 打开文档之前，猫头鹰用url行替换src =“”，以在iframe中下载html附件，其余的由浏览器完成。 <br>  EXCEL / WORD按钮相似：将要下载的url按钮以文件名“ report.html.xls”或“ report.html.doc”以及相应的mime类型插入正确的位置。 其余的工作由Excel / Word完成（“这些聪明的动物完全理解它们想要从它们那里得到的一切”）。 <br> 从do_get.py： <br><br><pre> <code class="python hljs">downloadUrl = <span class="hljs-string"><span class="hljs-string">'/download/'</span></span> + fn + <span class="hljs-string"><span class="hljs-string">'?'</span></span> + <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span>.join([d.db.alias, d.unid, idbl, fsName, fzip, ctype, flen]) excel = <span class="hljs-string"><span class="hljs-string">'/download/%s.xls?%s'</span></span> % (fn, <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span>.join([d.db.alias, d.unid, idbl, fsName, fzip, <span class="hljs-string"><span class="hljs-string">'application/x-excel'</span></span>, flen])) word = <span class="hljs-string"><span class="hljs-string">'/download/%s.doc?%s'</span></span> % (fn, <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span>.join([d.db.alias, d.unid, idbl, fsName, fzip, <span class="hljs-string"><span class="hljs-string">'application/msword'</span></span>, flen])) html = html.replace(<span class="hljs-string"><span class="hljs-string">'src=""'</span></span>, <span class="hljs-string"><span class="hljs-string">'src="%s"'</span></span> % downloadUrl).replace(<span class="hljs-string"><span class="hljs-string">'openExcel'</span></span>, excel).replace(<span class="hljs-string"><span class="hljs-string">'openWord'</span></span>, word)</code> </pre> <br><br> 在Excel / Word中打开html时，与浏览器有所不同，但差异很小。 这篇文章不是关于这个的。 <br><br>  <b>从头开始制作形状。</b> <br><br> 源数据： <br> 有3个功能 <br>  def snd（* msg，cat ='snd'）： <br>  def err（* msg，cat ='all'）： <br>  def dbg（* msg，cat ='snd'）： <br>  ，它们或多或少均匀地分布在整个代码中，并将错误消息和其他内容写入日志文件。 <br> 消息格式通过以下方式传递给logging.Formatter： <br>  '％（asctime）s％（levelname）s [％（name）s]％（message）s' <br> 该文件充满了消息 <br>  ... <br>  09/02/2018 17:50:07 DEBUG [http-server] addr（'127.0.0.1'，49964），“ GET / arm HTTP / 1.1” 200- <br>  09/02/2018 17:54:07信息[可用空间]附件保存在“。\ DB \文件”中免费68557 Mb <br>  2018年9月2日17:58:07错误[do_get.py] getScript：[Errno 2]没有这样的文件或目录：'sova / api / forms / o / oo.js' <br>  ... <br> 日期时间，然后是级别，然后在方括号中的级别中是类别，然后是消息。 <br><br> 挑战： <br> 制作页面以查看日志文件。 什么类型 <br><img src="https://habrastorage.org/webt/du/6e/ni/du6enivag9amyf4ss1lucuf1tm8.jpeg"><br><br> 我们将表单称为“ lm”，它将由api /forms/lm.py模块中的页面函数形成 <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dbAlias, mode, userName, multiPage)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dict( style(background=<span class="hljs-string"><span class="hljs-string">'url(/image?bg51.jpg)'</span></span>, backgroundSize=<span class="hljs-string"><span class="hljs-string">'100% 100%'</span></span>), div=[ dict( style(width=<span class="hljs-string"><span class="hljs-string">'200px'</span></span>, float=<span class="hljs-string"><span class="hljs-string">'left'</span></span>, background=<span class="hljs-string"><span class="hljs-string">'rgba(210,218,203, 0.5)'</span></span>, padding=<span class="hljs-string"><span class="hljs-string">'0 5px'</span></span>), div=[ _field(<span class="hljs-string"><span class="hljs-string">'type'</span></span>, <span class="hljs-string"><span class="hljs-string">'list'</span></span>, [<span class="hljs-string"><span class="hljs-string">' |all'</span></span>, <span class="hljs-string"><span class="hljs-string">'|err'</span></span>, <span class="hljs-string"><span class="hljs-string">'|info'</span></span>, <span class="hljs-string"><span class="hljs-string">'|debug'</span></span>], saveAlias=<span class="hljs-number"><span class="hljs-number">1</span></span>, **style(margin=<span class="hljs-string"><span class="hljs-string">'10px auto'</span></span>, width=<span class="hljs-number"><span class="hljs-number">170</span></span>, height=<span class="hljs-number"><span class="hljs-number">110</span></span>) ), _field(<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'list'</span></span>, <span class="hljs-string"><span class="hljs-string">'TYPE_ALIAS|||api.get?loadDropList&amp;logger|keys_{FIELD}'</span></span>, listItemClassName=<span class="hljs-string"><span class="hljs-string">'repName'</span></span>, listItemSelClassName=<span class="hljs-string"><span class="hljs-string">'repNameSel'</span></span>, **style(height=<span class="hljs-string"><span class="hljs-string">'calc(100vh - 133px)'</span></span>, overflow=<span class="hljs-string"><span class="hljs-string">'auto'</span></span>) ) ], ), _field(<span class="hljs-string"><span class="hljs-string">'msg'</span></span>, <span class="hljs-string"><span class="hljs-string">'fd'</span></span>, br=<span class="hljs-number"><span class="hljs-number">1</span></span>, **style(overflow=<span class="hljs-string"><span class="hljs-string">'auto'</span></span>, height=<span class="hljs-string"><span class="hljs-string">'100vh'</span></span>, font=<span class="hljs-string"><span class="hljs-string">'bold 12px Courier'</span></span>, background=<span class="hljs-string"><span class="hljs-string">'rgba(255,255,255, 0.8)'</span></span>) ), ] )</code> </pre> <br><br> 左侧有2个字段，均具有列表类型：type和cat（消息类型和类别）。 <br> 右边是一个类型为fd（forDisplayOnly）的msg字段。 <br> 消息类型写在字段描述中（['All log | all'，'Errors | err'，...）， <br>  xhr通过棘手的url调用将类别从全局词典中拉出： <br>  api.get？loadDropList＆logger | keys_err将以json格式返回全局词典中类别的数组（列表）。 很像（“ logger”，“ keys_err”）。 <br> 通过lm.py中的queryOpen函数打开文档时会生成消息 <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queryOpen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d, mode, ground)</span></span></span><span class="hljs-function">:</span></span> logParser() ls = well(<span class="hljs-string"><span class="hljs-string">'logger_all'</span></span>, <span class="hljs-string"><span class="hljs-string">'AL L'</span></span>) s = <span class="hljs-string"><span class="hljs-string">'\n'</span></span>.join(reversed(ls)) d.msg = s d.type_alias = <span class="hljs-string"><span class="hljs-string">'all'</span></span></code> </pre> <br>  logParser读取并分析日志文件。 它将结果分解成几个数组，并将它们保存在全局字典中。 没什么有趣的：2个简单的re和Iterator循环。 <br> 用于全局字典的函数： <br>  toWell（o，key1，[key2]）-将对象“ o”保存在全局字典中 <br> 好（key1，[key2]）-通过键（通过两个键）从全局词典中获取一个对象。 <br> 这对于第一张图就足够了。 为了能够显示所需类型和类别的消息，必须制作可加载的js。 <br> 在lm.py中添加该行 <br>  javaScriptUrl ='jsv？api /表格/lm/lm.js' <br> 并创建lm.js： <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.sovaActions = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.sovaActions || {}; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.sovaActions.lm = { <span class="hljs-comment"><span class="hljs-comment">//   "lm" init: doc =&gt; doc.changeDropList('CAT'), recalc: { TYPE: (doc, label, alias) =&gt; { doc.changeDropList('CAT'); getLogData(doc, alias + '|AL L'); }, CAT: (doc, label) =&gt; getLogData(doc, doc.getField('type_alias') + '|' + label), }, }; // *** *** *** let getLogData = (doc, keys) =&gt; { fetch('api.get?getLogData&amp;' + keys, {method: 'get', credentials: 'include'}) .then( response =&gt; response.text() ) .then( txt =&gt; doc.setField('msg', txt) ) .catch( err =&gt; doc.setField('msg', err.message) ); };</span></span></code> </pre> <br><br>  getLogData从服务器中提取所需类型和类别的消息： <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLogData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(par, un)</span></span></span><span class="hljs-function">:</span></span> lg, _, cat = par.partition(<span class="hljs-string"><span class="hljs-string">'|'</span></span>) msg = well(<span class="hljs-string"><span class="hljs-string">'logger_'</span></span> + lg, cat) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-string"><span class="hljs-string">'text/html; charset=UTF-8'</span></span>, <span class="hljs-string"><span class="hljs-string">'\n'</span></span>.join(reversed(msg))</code> </pre><br><br> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>享受表格。 <br> 最初，记录是根据标准记录模块完成的 <br> 使用logging.FileHandler，.addHandler和其他getLogger和setFormatter。 <br> 怎么教。 但与此同时，这是越野车。 您可以扔石头，但是当我扔日志并开始写文件时，代码变得更短，更易于理解，并且故障消失了。 <br><br> 包含具有Digest授权的自写多线程wsgi服务器。 这不适用于网站。 为什么根本需要他？ <br> 客户有40 jur。 人员，大多数情况下，1-2-3人会使用该系统。 禁止在Internet上存储数据。 全部获胜7。要求易于安装和配置。 <br> 解决方案：使用cx-Freeze和Inno Setup，我们进行安装，在最负责任的计算机上运行该安装程序，并从Windows服务开始为本地网络获取mini-http服务器。 没什么 您不能使用Python内置的内置wsgiref.simple_server或wsgi_Werkzeug，因为 它们是单线程的：当一个请求失败时，其他请求将等待。 <br> 报告内置Django WSGIServer / 0.2 CPython / 3.5.3的速度比自编写的Python快好几倍，这让我感到惊讶的可能性不大。 但这无关紧要-表单和目录缓存在客户端上，只有数据库数据通过本地网络非常快速地传输。 <br> 还有一个原因：桌面应用程序可以访问计算机资源（数字签名，文件，扫描仪...）。 为了从浏览器获得相同的访问权限，您必须在服务中编写插件或挂断小型http服务器，这些服务器可以从主服务器上嗅探并在本地执行必要的操作。 <br><br> 猫头鹰不使用框架工具来处理数据库。 在dbToolkit目录中，其结构类似于SQLite3中的MongoDB（或Lotus Notes）： <br> 图书类-数据库（使用MongoDB和Lotus Notes术语） <br>  Class DocumentCollection-书籍中的文档集合 <br>  Document类是一个文档（一个包含任意多个字段的对象）。 <br><br>  <b>安装方式：</b> <br> 从sova.online下载owl.zip <br><br> 归档文件包含owl目录，您可以从中运行来自django，falcon或没有框架的Owl。 <br><br> 下载，解压缩。 <br> 安装Python3（3.5+） <br><br>  1.猫头鹰-没有框架。 注意！ 登录名：1，密码：1 <br><br>  Linux： <br>  cd ./猫头鹰 <br>  python3 wsgi_sova.py <br><br> 或在单独的窗口中 <br> 屏幕-Udm python3 wsgi_server.py <br><br>  Windows： <br>  cd ./猫头鹰 <br>  wsgi_sova.py <br><br>  2. Django <br><br>  Linux： <br> 安装django： <br>  pip3安装Django <br>  cd ./猫头鹰 <br>  python3 manage.py运行服务器 <br><br> 或在单独的窗口中 <br> 屏幕-Udm python3 manage.py runserver 127.0.0.1:8000 <br><br>  Windows： <br> 安装django： <br>  pip安装Django <br>  cd ./猫头鹰 <br>  manage.py运行服务器 <br><br>  3.猎鹰 <br><br>  Linux： <br>  pip3安装猎鹰 <br>  cd ./猫头鹰 <br>  python3 wsgi_sova.py falcon应用：api 8001 log_falcon / falcon <br><br>  Windows： <br> 点安装猎鹰 <br>  cd ./猫头鹰 <br>  wsgi_sova.py falcon应用程序：api 8001 log_falcon / falcon <br><br>  ********************** <br><br>  -文章标题很奇怪，您了解什么是“ Multipage SPA”吗？ <br>  -正常的营销策略 <br>  -为什么没有Redux？ 每个人都使用Redux。 <br>  -我不喜欢“减速器”一词 <br>  -但是认真吗？  ombineReducers在任何层次的层次上……是如此的美丽 <br> 多页，宝贝。 命令处理程序应位于表单内部，而不像鹿角 <br>  -为什么还要写文章？ <br>  -公关 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424779/">https://habr.com/ru/post/zh-CN424779/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424765/index.html">Flutter应用程序中的状态管理</a></li>
<li><a href="../zh-CN424767/index.html">我们用哈伯做蛋糕。 再来一次</a></li>
<li><a href="../zh-CN424771/index.html">个人经验：从想法和空白表到网站的草稿版本</a></li>
<li><a href="../zh-CN424773/index.html">生物制药和数值模拟：安进的经验和实践</a></li>
<li><a href="../zh-CN424777/index.html">使用领事扩展有状态服务</a></li>
<li><a href="../zh-CN424781/index.html">使用Ignite在PyTorch上教学和测试神经网络</a></li>
<li><a href="../zh-CN424787/index.html">2018 RubyRussia会议发言人Aaron Patterson访谈</a></li>
<li><a href="../zh-CN424789/index.html">如何使用HAProxy Ingress，unicorn / puma和Web套接字部署Ruby on Rails应用程序</a></li>
<li><a href="../zh-CN424791/index.html">使用WI-FI扩展可编程继电器的网络功能</a></li>
<li><a href="../zh-CN424793/index.html">如何打印电动机</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>