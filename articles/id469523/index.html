<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🎓 🤱 🤮 Ketergantungan kinerja kode pada konteks deklarasi variabel dalam JavaScript 🤲🏼 🤦🏼 ⛹🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Awalnya, artikel ini disusun sebagai tolok ukur kecil untuk penggunaannya sendiri, dan secara umum tidak direncanakan untuk menjadi artikel, namun, da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ketergantungan kinerja kode pada konteks deklarasi variabel dalam JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469523/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/cx/hu/udcxhuvjpmyigj19lmdrz8ojyja.jpeg"></div><br>  Awalnya, artikel ini disusun sebagai tolok ukur kecil untuk penggunaannya sendiri, dan secara umum tidak direncanakan untuk menjadi artikel, namun, dalam proses melakukan pengukuran, beberapa fitur menarik muncul dalam implementasi arsitektur <i><b>JavaScript</b></i> yang sangat mempengaruhi kinerja kode akhir dalam beberapa kasus.  Saya sarankan, dan Anda, berkenalan dengan hasil yang diperoleh, secara kebetulan juga memeriksa beberapa topik terkait: <i><b>untuk</b></i> loop, lingkungan (konteks eksekusi), dan blok. <br><br><a name="habracut"></a>  Pada akhir artikel saya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Menggunakan deklarasi variabel let dan fitur penutupan JavaScript yang dihasilkan,”</a> saya dengan santai menyentuh topik membandingkan kinerja <i><b>let (LexicalDeclaration)</b></i> dan deklarasi variabel <i><b>var (VarDeclaredNames)</b></i> dalam loop.  Sebagai perbandingan, kami menggunakan runtime manual (tanpa bantuan <i><b>Array.prototype.sort ()</b></i> ) menyortir array, salah satu metode paling sederhana adalah menyortir berdasarkan pilihan, karena dengan panjang array 100.000 kami mendapat sedikit lebih dari 5 miliar.  iterasi dalam dua siklus (eksternal dan bersarang), dan, angka ini seharusnya memungkinkan penilaian yang memadai pada akhirnya. <br><br>  Untuk <i><b>var,</b></i> itu mengurutkan tampilan: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = arr.length; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 9.082 . //   Chrome: 10.783 .</span></span></code> </pre> <br>  Dan untuk <i><b>membiarkan</b></i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = arr.length; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.261 . //   Chrome: 5.391 .</span></span></code> </pre> <br>  Melihat angka-angka ini, tampaknya, dapat dengan tegas diperdebatkan bahwa <i><b>biarkan</b></i> iklan sepenuhnya melampaui <i><b>var</b></i> dalam kecepatan.  Tetapi, selain kesimpulan ini, pertanyaan tetap ada di udara: apa yang akan terjadi jika kita <i><b>membiarkan</b></i> deklarasi di luar <i><b>untuk</b></i> loop? <br><br>  Tetapi, sebelum melakukan ini, Anda perlu mempelajari lebih dalam pekerjaan <i><b>for for</b></i> loop, dipandu oleh spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><i>ECMAScript 2019 saat ini (ECMA-262)</i></a> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>Runtime Semantics: LabelledEvaluation With parameter labelSet. IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Expression;Expression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the first Expression is present, then a. Let exprRef be the result of evaluating the first Expression. b. Perform ? GetValue(exprRef). <span class="hljs-number"><span class="hljs-number">2</span></span>. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet). IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(varVariableDeclarationList;Expression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. Let varDcl be the result of evaluating VariableDeclarationList. <span class="hljs-number"><span class="hljs-number">2</span></span>. ReturnIfAbrupt(varDcl). <span class="hljs-number"><span class="hljs-number">3</span></span>. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet). IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(LexicalDeclarationExpression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. Let oldEnv be the running execution context's LexicalEnvironment. <span class="hljs-number"><span class="hljs-number">2</span></span>. Let loopEnv be NewDeclarativeEnvironment(oldEnv). <span class="hljs-number"><span class="hljs-number">3</span></span>. Let loopEnvRec be loopEnv's EnvironmentRecord. <span class="hljs-number"><span class="hljs-number">4</span></span>. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">5</span></span>. Let boundNames be the BoundNames of LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">6</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element dn of boundNames, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> isConst is true, then i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true). b. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, i. Perform ! loopEnvRec.CreateMutableBinding(dn, false). <span class="hljs-number"><span class="hljs-number">7</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to loopEnv. <span class="hljs-number"><span class="hljs-number">8</span></span>. Let forDcl be the result of evaluating LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">9</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> forDcl is an abrupt completion, then a. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to oldEnv. b. Return Completion(forDcl). <span class="hljs-number"><span class="hljs-number">10</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ». <span class="hljs-number"><span class="hljs-number">11</span></span>. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet). <span class="hljs-number"><span class="hljs-number">12</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to oldEnv. <span class="hljs-number"><span class="hljs-number">13</span></span>. Return Completion(bodyResult).</code> </pre>  <i>catatan: titik dua setelah IterationStatements, di sumbernya tidak dibingkai oleh apostrof - ditambahkan di sini sehingga tidak ada pemformatan otomatis yang cukup banyak merusak keterbacaan teks.</i> <br><br>  Di sini, seperti yang kita lihat, ada tiga opsi untuk memanggil dan pekerjaan lebih lanjut dari <i><b>for</b></i> loop: <br><ul><li>  dengan <i>untuk Pernyataan (Ekspresi; Ekspresi; Ekspresi)</i> <br>  <i><b>ForBodyEvaluation</b> (Ekspresi kedua, Ekspresi ketiga, Pernyataan, "", labelSet)</i> . </li><li>  dengan <i><b>untuk</b> (varVariableDeclarationList; Pernyataan; Ekspresi; Pernyataan)</i> <br>  <i><b>ForBodyEvaluation</b> (Ekspresi pertama, Ekspresi kedua, Pernyataan, "", labelSet).</i> </li><li>  pada <i>pernyataan (LexicalDeclarationExpression; Expression)</i> <br>  <i><b>ForBodyEvaluation</b> (Ekspresi pertama, Ekspresi kedua, Pernyataan, perIterationLets, labelSet)</i> </li></ul><br>  Pada varian terakhir, ketiga, tidak seperti dua yang pertama, parameter keempat tidak kosong - <i><b>perIterationLets</b></i> - ini sebenarnya deklarasi yang sama pada parameter pertama yang dilewatkan ke <i><b>for</b></i> loop.  Mereka ditentukan dalam paragraf 10: <br>  <i>- Jika <b>isConst</b> <b>salah</b> , biarkan <b>perIterationLets</b> menjadi boundNames;</i>  <i>jika tidak biarkan perIterationLets menjadi "".</i> <br>  Jika sebuah konstanta diteruskan ke <i><b>untuk</b></i> , tetapi bukan variabel, parameter <i><b>perIterationLets</b></i> menjadi kosong. <br><br>  Juga, dalam opsi ketiga, perlu memperhatikan paragraf 2: <br>  <i>- Biarkan loopEnv menjadi <b>NewDeclarativeEnvironment</b> (oldEnv).</i> <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">8</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>NewDeclarativeEnvironment ( E ) When the abstract operation NewDeclarativeEnvironment is called with a Lexical Environment as argument E the following steps are performed: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let env be a new Lexical Environment. <span class="hljs-number"><span class="hljs-number">2</span></span>. Let envRec be a new declarative Environment Record containing no bindings. <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> env's EnvironmentRecord to envRec. <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the outer lexical environment reference of env to E. <span class="hljs-number"><span class="hljs-number">5</span></span>. Return env.</code> </pre> <br>  Di sini, sebagai parameter <i><b>E</b></i> , lingkungan dari mana <i><b>for</b></i> loop dipanggil (global, fungsi apa saja, dll) diambil, dan, lingkungan baru dibuat untuk mengeksekusi <i><b>for</b></i> loop dengan merujuk ke lingkungan eksternal yang menciptakannya (poin 4).  Kami tertarik pada fakta ini karena fakta bahwa lingkungan adalah konteks eksekusi. <br><br>  Dan kita ingat bahwa deklarasi variabel <i><b>let</b></i> dan <i><b>const</b></i> secara kontekstual terikat pada blok di mana mereka dideklarasikan. <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">14</span></span>Runtime Semantics: BlockDeclarationInstantiation ( code, env ) Note When a Block or CaseBlock is evaluated a new declarative Environment Record is created and bindings <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each block scoped variable, constant, function, or class declared <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the block are instantiated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the Environment Record. BlockDeclarationInstantiation is performed as follows using arguments code and env. code is the Parse Node corresponding to the body of the block. env is the Lexical Environment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> which bindings are to be created. <span class="hljs-number"><span class="hljs-number">1</span></span>. Let envRec be env's EnvironmentRecord. <span class="hljs-number"><span class="hljs-number">2</span></span>. Assert: envRec is a declarative Environment Record. <span class="hljs-number"><span class="hljs-number">3</span></span>. Let declarations be the LexicallyScopedDeclarations of code. <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> declarations, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element dn of the BoundNames of d, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> IsConstantDeclaration of d is true, then <span class="hljs-number"><span class="hljs-number">1</span></span>. Perform ! envRec.CreateImmutableBinding(dn, true). ii. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>. Perform ! envRec.CreateMutableBinding(dn, false). b. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then i. Let fn be the sole element of the BoundNames of d. ii. Let fo be the result of performing InstantiateFunctionObject <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d with argument env. iii. Perform envRec.InitializeBinding(fn, fo).</code> </pre> <br>  Catatan: karena dalam dua varian pertama memanggil <i><b>for</b></i> loop tidak ada deklarasi seperti itu, tidak perlu membuat lingkungan baru untuk mereka. <br><br>  Kami melangkah lebih jauh dan mempertimbangkan apa itu <i><b>ForBodyEvaluation</b></i> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">8</span></span>Runtime Semantics: ForBodyEvaluation ( test, increment, stmt, perIterationBindings, labelSet ) The abstract operation ForBodyEvaluation with arguments test, increment, stmt, perIterationBindings, and labelSet is performed as follows: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let V be undefined. <span class="hljs-number"><span class="hljs-number">2</span></span>. Perform ? CreatePerIterationEnvironment(perIterationBindings). <span class="hljs-number"><span class="hljs-number">3</span></span>. Repeat, a. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> test is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> [empty], then i. Let testRef be the result of evaluating test. ii. Let testValue be ? GetValue(testRef). iii. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> ToBoolean(testValue) is false, return NormalCompletion(V). b. Let result be the result of evaluating stmt. c. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)). d. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> result.[[Value]] is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty, <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> V to result.[[Value]]. e. Perform ? CreatePerIterationEnvironment(perIterationBindings). f. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> increment is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> [empty], then i. Let incRef be the result of evaluating increment. ii. Perform ? GetValue(incRef).</code> </pre> <br>  Apa yang pertama-tama harus Anda perhatikan: <br><ul><li>  deskripsi parameter yang masuk: <br><ul><li>  <i><b>test</b></i> : ekspresi diperiksa kebenarannya sebelum iterasi berikutnya dari loop body (misalnya: <i><b>i &lt;len</b></i> ); </li><li>  <i><b>increment</b></i> : ekspresi dievaluasi pada awal setiap iterasi baru (kecuali untuk yang pertama) (misalnya: <i><b>i ++</b></i> ); </li><li>  <i><b>stmt</b></i> : loop body </li><li>  <i><b>perIterationBindings</b></i> : variabel dideklarasikan dengan <i><b>let</b></i> in pertama <i><b>untuk</b></i> parameter (misalnya: <i><b>let i = 0 || let i || let i, j</b></i> ); </li><li>  <i><b>labelSet</b></i> : label loop; </li></ul></li><li>  poin 2: di sini, jika parameter non-kosong <i><b>perIterationBindings dilewati</b></i> , lingkungan kedua dibuat untuk melakukan pass awal dari loop; </li><li>  paragraf 3.a: memeriksa kondisi yang diberikan untuk melanjutkan pelaksanaan siklus; </li><li>  klausa 3.b: eksekusi dari badan siklus; </li><li>  poin 3.e: menciptakan lingkungan baru. </li></ul><br>  Nah, dan, secara langsung, algoritma untuk menciptakan lingkungan internal <i><b>for for</b></i> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">9</span></span>Runtime Semantics: CreatePerIterationEnvironment ( perIterationBindings ) <span class="hljs-number"><span class="hljs-number">1</span></span>. The abstract operation CreatePerIterationEnvironment with argument perIterationBindings is performed as follows: <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> perIterationBindings has any elements, then a. Let lastIterationEnv be the running execution context's LexicalEnvironment. b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord. c. Let outer be lastIterationEnv's outer environment reference. d. Assert: outer is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> null. e. Let thisIterationEnv be NewDeclarativeEnvironment(outer). f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord. g. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element bn of perIterationBindings, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false). ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true). iii. Perform thisIterationEnvRec.InitializeBinding(bn, lastValue). h. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to thisIterationEnv. <span class="hljs-number"><span class="hljs-number">2</span></span>. Return undefined.</code> </pre> <br>  Seperti yang bisa kita lihat, paragraf pertama memeriksa keberadaan elemen apa pun dalam parameter yang diteruskan, dan paragraf 1 hanya dilakukan jika ada pengumuman.  Semua lingkungan baru dibuat dengan referensi ke konteks eksternal yang sama dan mengambil nilai terbaru dari iterasi sebelumnya (lingkungan kerja sebelumnya) sebagai binding baru variabel <i><b>let</b></i> . <br><br>  Sebagai contoh, perhatikan ungkapan serupa: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { arr.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  Dan di sini adalah bagaimana ia dapat didekomposisi tanpa menggunakan <i><b>untuk</b></i> (dengan sejumlah konvensionalitas): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = []; <span class="hljs-comment"><span class="hljs-comment">//    { let i = 0; //     for } //   ,   { let i = 0; //    i    if (i &lt; 3) arr.push(i); } //    { let i = 0; //    i    i++; if (i &lt; 3) arr.push(i); } //    { let i = 1; //    i    i++; if (i &lt; 3) arr.push(i); } //    { let i = 2; //    i    i++; if (i &lt; 3) arr.push(i); } console.log(arr); // Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  Bahkan, kami sampai pada kesimpulan bahwa untuk setiap konteks, dan di sini kami memiliki lima dari mereka, kami membuat binding baru untuk <i><b>membiarkan</b></i> variabel dideklarasikan sebagai parameter pertama dalam <i><b>untuk</b></i> (penting: ini tidak berlaku untuk <i><b>membiarkan</b></i> deklarasi langsung di tubuh loop). <br><br>  Begini caranya, misalnya, loop ini akan terlihat ketika menggunakan <i><b>var</b></i> ketika tidak ada binding tambahan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr2 = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  Dan kita bisa sampai pada kesimpulan yang tampaknya logis bahwa jika selama pelaksanaan loop kita tidak perlu membuat binding terpisah untuk setiap iterasi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih lanjut tentang situasi di mana ini, sebaliknya, mungkin masuk akal</a> ), kita harus membuat deklarasi variabel tambahan sebelum dengan <i><b>for for</b></i> , yang seharusnya menyelamatkan kita dari menciptakan dan menghapus sejumlah besar konteks dan, secara teori, meningkatkan kinerja. <br><br>  Mari kita coba melakukan ini, dengan menggunakan pengurutan yang sama dari 100.000 elemen sebagai contoh, dan demi kecantikan, kami juga membuat definisi dari semua variabel lain sebelumnya <i><b>untuk</b></i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 34.246 . //   Chrome: 10.803 .</span></span></code> </pre> <br>  Hasil yang tidak terduga ... Justru kebalikan dari apa yang diharapkan, tepatnya.  Drawdown <i><b>Firefox</b></i> dalam tes ini sangat mencolok. <br><br>  Ok  Ini tidak berhasil, mari kita kembalikan deklarasi variabel <i><b>i</b></i> dan <i><b>j</b></i> kembali ke parameter dari siklus yang sesuai: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 6.575 . //   Chrome: 6.749 .</span></span></code> </pre> <br>  Hm  Tampaknya, secara teknis, satu-satunya perbedaan antara contoh terakhir dan contoh di awal artikel adalah deklarasi variabel yang dibuat <i><b>min, mini</b></i> dan <i><b>len di</b></i> luar <i><b>for</b></i> loop, dan meskipun perbedaannya masih kontekstual, itu tidak terlalu menarik bagi kita sekarang, dan, di samping itu, kami menghilangkan kebutuhan untuk mendeklarasikan variabel-variabel ini 99.999 kali dalam tubuh siklus tingkat atas, yang lagi-lagi, secara teori, harus meningkatkan produktivitas daripada menguranginya lebih dari satu detik. <br><br>  Yaitu, ternyata entah bagaimana, bekerja dengan variabel yang dideklarasikan dalam parameter atau badan <i><b>for</b></i> loop terjadi jauh lebih cepat daripada di luarnya. <br><br>  Tapi, kami sepertinya tidak melihat instruksi "turbo" dalam spesifikasi for <i><b>for</b></i> loop yang dapat mengarahkan kami ke ide semacam itu.  Oleh karena itu, ini bukan spesifik pekerjaan loop <i><b>for</b></i> khusus, tetapi sesuatu yang lain ... Misalnya, fitur deklarasi <i><b>let</b></i> : apa fitur utama yang membedakan <i><b>let</b></i> dari <i><b>var</b></i> ?  Cekal konteks pelaksanaan!  Dan dalam dua contoh terakhir kami, kami menggunakan iklan di luar blok.  Tetapi, bagaimana jika alih-alih memindahkan deklarasi ini kembali ke <i><b>,</b></i> kami hanya memilih blok terpisah untuknya? <br><br><pre> <code class="javascript hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.262 . //   Chrome: 5.405 .</span></span></code> </pre> <br>  Voila!  Ternyata tangkapannya adalah <i><b>membiarkan</b></i> pengumuman dilakukan dalam konteks global, dan segera setelah kami mengalokasikan blok terpisah untuk mereka, semua masalah menghilang di sana. <br><br>  Dan di sini akan lebih baik untuk mengingat cara lain, sedikit terkutuk dikutuk untuk mendeklarasikan variabel - <i><b>var</b></i> . <br><br>  Dalam contoh di awal artikel, waktu menyortir menggunakan <i><b>var</b></i> menunjukkan hasil yang sangat menyedihkan, relatif dibandingkan dengan <i><b>membiarkan</b></i> .  Tetapi, jika Anda melihat lebih dekat pada contoh ini, Anda mungkin menemukan bahwa, karena <i><b>var</b></i> tidak memiliki ikatan blok variabel, konteks sebenarnya dari variabel adalah global.  Dan kami, pada contoh <i><b>let</b></i> , telah menemukan bagaimana ini dapat mempengaruhi kinerja (dan, yang khas, ketika menggunakan <i><b>let</b></i> , drawdown dalam kecepatan ternyata lebih kuat daripada dalam kasus dengan <i><b>var</b></i> , terutama di <i><b>Firefox</b></i> ).  Oleh karena itu, dalam keadilan, kami akan menjalankan contoh dengan <i><b>var</b></i> membuat konteks baru untuk variabel: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } test(); <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.255 . //   Chrome: 5.411 .</span></span></code> </pre> <br>  Dan, kami mendapat hasil yang hampir identik dengan apa yang digunakan saat menggunakan <i><b>let</b></i> . <br><br>  Akhirnya, mari kita periksa apakah perlambatan terjadi dengan membaca variabel global tanpa mengubah nilainya. <br><br>  <i><b>biarkan</b></i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.262 . //   Chrome: 5.391 .</span></span></code> </pre> <br>  <i><b>var</b></i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> len = arr.length; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j, min, mini; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } test(); <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.258 . //   Chrome: 5.439 .</span></span></code> </pre> <br>  Hasil menunjukkan bahwa membaca variabel global tidak mempengaruhi waktu eksekusi. <br><br><h3>  Untuk meringkas </h3><br><ol><li>  Mengubah variabel global jauh lebih lambat daripada mengubah variabel lokal.  Dengan mempertimbangkan hal ini, dimungkinkan untuk mengoptimalkan kode dalam situasi yang sesuai dengan membuat blok atau fungsi terpisah, termasuk untuk mendeklarasikan variabel, alih-alih mengeksekusi bagian dari kode dalam konteks global.  Ya, di hampir semua buku teks, Anda dapat menemukan rekomendasi untuk membuat ikatan global sesedikit mungkin, tetapi biasanya hanya menyumbat ruang nama global yang diindikasikan sebagai alasan, dan bukan sepatah kata pun tentang kemungkinan masalah kinerja. </li><li>  Terlepas dari kenyataan bahwa pelaksanaan loop dengan deklarasi <i><b>let</b></i> di parameter pertama <i><b>untuk</b></i> menciptakan sejumlah besar lingkungan, ini hampir tidak berpengaruh pada kinerja, tidak seperti situasi ketika kita mengambil deklarasi seperti itu di luar blok.  Namun demikian, orang tidak boleh mengecualikan kemungkinan keberadaan situasi eksotis ketika faktor ini akan mempengaruhi produktivitas secara lebih signifikan. </li><li>  Kinerja variabel <i><b>var</b></i> masih tidak kalah dengan variabel <i><b>biarkan</b></i> , namun, itu tidak melebihi mereka (sekali lagi, dalam kasus umum), yang membawa kita pada kesimpulan berikutnya bahwa tidak ada alasan untuk menggunakan deklarasi <i><b>var</b></i> kecuali untuk tujuan kompatibilitas.  Namun, jika perlu untuk memanipulasi variabel global dengan mengubah nilai-nilai mereka, varian dengan <i><b>var</b></i> dalam hal kinerja akan lebih disukai (setidaknya untuk saat ini, jika, khususnya, diasumsikan bahwa skrip juga dapat dijalankan pada mesin Gecko). </li></ol><br><h4>  Referensi </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">ECMAScript 2019 (ECMA-262)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan deklarasi biarkan variabel dan fitur dari penutupan yang dihasilkan dalam JavaScript</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469523/">https://habr.com/ru/post/id469523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469505/index.html">3 cara praktis untuk membawa bisnis ke pasar luar negeri: pendekatan dan teknik perusahaan nyata</a></li>
<li><a href="../id469507/index.html">Uap Ketiga kerentanan Klien Windows, tetapi tidak 0 hari</a></li>
<li><a href="../id469509/index.html">Skema sudut, atau bagaimana saya menulis template untuk cli sudut</a></li>
<li><a href="../id469515/index.html">Mempersiapkan aplikasi untuk Istio</a></li>
<li><a href="../id469521/index.html">Saya membeli sepeda motor untuk naik, bukan untuk jatuh</a></li>
<li><a href="../id469525/index.html">Sistem kontrol otomatis untuk excavator pertambangan</a></li>
<li><a href="../id469527/index.html">Apakah interkom itu mata-mata?</a></li>
<li><a href="../id469529/index.html">Render teks membenci Anda</a></li>
<li><a href="../id469531/index.html">“Membandingkan bahasa pemrograman dengan basis yang lebih baik-lebih buruk adalah pekerjaan yang benar-benar bodoh.”</a></li>
<li><a href="../id469533/index.html">Masalah dan ancaman identifikasi biometrik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>