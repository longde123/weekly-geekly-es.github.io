<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèº ‚ò¶Ô∏è ü¶ê Schnelle und effektive Arbeit in der Kommandozeile üÜí üßöüèæ ü•™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt viele Tipps und Trics f√ºr die Befehlszeile im Internet. Die meisten von ihnen beschreiben die Trivials wie "lerne die Hotkeys" oder " sudo !! ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnelle und effektive Arbeit in der Kommandozeile</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481940/"><p> Es gibt viele Tipps und Trics f√ºr die Befehlszeile im Internet.  Die meisten von ihnen beschreiben die Trivials wie "lerne die Hotkeys" oder " <code>sudo !!</code> f√ºhre vorherigen Befehl mit sudo aus".  Stattdessen werde ich Ihnen sagen, was Sie tun sollen, wenn Sie die Hotkeys bereits kennen und etwas √ºber <code>sudo !!</code> wissen <code>sudo !!</code>  . </p><a name="habracut"></a><br><h3 id="the-terminal-should-start-instantly">  Das Terminal sollte sofort starten </h3><br><p>  Wie viel Zeit verbringen Sie, um ein Terminal zu starten?  Und noch einer?  Ich habe lange Zeit die Tastenkombination Strg + Alt + T verwendet, um ein Terminal zu starten, und dachte, es ist schnell.  Als ich von Openbox auf i3 umgestiegen bin, habe ich begonnen, ein Terminal √ºber Win + Enter zu starten. Diese Bindung hat sich sofort bew√§hrt.  Wei√üt du was?  Jetzt denke ich nicht, dass Strg + Alt + T schnell genug ist. </p><br><p>  Nat√ºrlich ist das Ding keine Millisekunden-Beschleunigung, sondern dass man ein Terminal auf der Ebene der Reflexe √∂ffnet, ohne dass man das merkt. </p><br><p>  Wenn Sie h√§ufig ein Terminal verwenden, zum Starten jedoch eine Maus greifen, versuchen Sie, einen praktischen Hotkey zu konfigurieren.  Ich bin sicher, es wird dir gefallen. </p><br><h3 id="zsh-instead-of-bash">  Zsh statt bash </h3><br><p>  Ich wei√ü, dass dies ein Thema des Heiligen Krieges ist.  Sie sollten Zsh f√ºr mindestens drei Funktionen installieren: Erweiterte Autokomplettierung, Tippfehlerbehebung und Vervollst√§ndigung mehrerer Pfadnamen: Wenn ein einzelner Tab <code>/u/s/d</code> in <code>/usr/share/doc</code> konvertiert.  Arch Linux wurde bereits auf der Installations-CD auf Zsh migriert.  Ich hoffe, Zsh wird einmal eine Standard-Shell in Ubuntu.  Das wird ein historischer Moment sein. </p><br><p>  Es ist √ºberhaupt nicht schwierig, mit Zsh zu beginnen.  Installiere es einfach √ºber den Paketmanager und finde eine h√ºbsche Konfiguration.  Ich empfehle, die in Arch Linux verwendete Konfiguration zu verwenden: </p><br><pre> <code class="plaintext hljs">$ wget -O ~/.zshrc https://git.grml.org/f/grml-etc-core/etc/zsh/zshrc</code> </pre> <br><p>  Jetzt m√ºssen Sie nur noch Ihre Standard-Shell √§ndern und sich neu anmelden. </p><br><pre> <code class="plaintext hljs">$ chsh -s $(which zsh)</code> </pre> <br><p>  Das ist alles, arbeiten Sie einfach weiter, als w√§re nichts passiert. </p><br><h3 id="how-the-shell-prompt-should-look-like">  Wie die Shell-Eingabeaufforderung aussehen soll </h3><br><p>  Die Shell-Eingabeaufforderung ist ein kleiner Textabschnitt, der im Terminal am Anfang Ihrer Befehlszeile angezeigt wird.  Es sollte f√ºr Ihre Art von Arbeit konfiguriert werden.  Sie k√∂nnen es als Armaturenbrett eines Fahrzeugs wahrnehmen.  Bitte geben Sie dort einige n√ºtzliche Informationen ein, damit Sie besser navigieren k√∂nnen!  Machen Sie es praktisch, besonders wenn Sie es jeden Tag sehen! </p><br><p>  Die Shell-Eingabeaufforderung sollte farbig sein.  Nicht einverstanden?  Versuchen Sie zu z√§hlen, wie viele Befehle in diesem Terminal ausgef√ºhrt wurden: </p><br><p><img src="https://habrastorage.org/webt/yh/mu/s7/yhmus7x5-abqnlrho5u5djwau8o.png"></p><br><p>  Und jetzt mit Farbe: </p><br><p><img src="https://habrastorage.org/webt/re/1b/ln/re1blnqfemmydwf99758sbirqai.png"></p><br><p>  Die Shell-Eingabeaufforderung sollte ein aktuelles Arbeitsverzeichnis einer Shell anzeigen.  Wenn das aktuelle Arbeitsverzeichnis nicht angezeigt wird, m√ºssen Sie es im Hinterkopf behalten und regelm√§√üig mit dem Befehl <code>pwd</code> √ºberpr√ºfen.  Bitte tu das nicht.  Denken Sie an einige wirklich wichtige Dinge und verschwenden Sie keine Zeit mit dem Befehl <code>pwd</code> . </p><br><p>  Wenn Sie manchmal zum Root-Konto wechseln, ben√∂tigen Sie die Angabe "Aktueller Benutzer".  Der bestimmte Benutzername ist oft nicht wichtig, aber sein Status (normal oder root) ist.  Die L√∂sung ist die Verwendung von color: red shell prompt f√ºr root und green f√ºr den normalen Benutzer.  Und Sie werden die Root-Shell niemals so regelm√§√üig √ºbernehmen. </p><br><p>  Wenn Sie mit ssh eine Verbindung zu Servern herstellen, m√ºssen Sie Ihre lokalen und Remote-Shells unterscheiden.  Zu diesem Zweck sollte Ihre Shell-Eingabeaufforderung einen Hostnamen oder besser noch eine SSH-Verbindung enthalten. </p><br><p>  Die Shell-Eingabeaufforderung kann den Beendigungscode des letzten Befehls anzeigen.  Denken Sie daran, dass der Null-Beendigungscode bedeutet, dass ein Befehl erfolgreich beendet wurde, der nicht Null ist - Befehl wurde nicht erfolgreich beendet.  Sie k√∂nnen den Exit-Code des letzten Befehls √ºber <code>echo $?</code>  , aber all das zu tippen ist eine verdammt lange Sache.  Lassen Sie sich stattdessen von der Shell den erfolglosen Abschluss anzeigen. </p><br><p>  Wenn Sie mit Git-Repos arbeiten, ist es hilfreich, den Repository-Status in der Shell-Eingabeaufforderung anzuzeigen: aktueller Zweig und Status des Arbeitsverzeichnisses.  Sie sparen etwas Zeit bei den Befehlen <code>git status</code> und <code>git branch</code> und werden sich nicht auf einen falschen Zweig festlegen.  Ja, die Berechnung des Status kann in Fettdepots viel Zeit in Anspruch nehmen, aber f√ºr mich √ºberwiegen die Vor- und Nachteile. </p><br><p>  Einige Leute f√ºgen der Shell-Eingabeaufforderung eine Uhr oder sogar den Namen eines virtuellen Terminals (tty) oder einige willk√ºrliche Kringel hinzu.  Das ist alles √ºberfl√ºssig.  Es ist besser, viel Platz f√ºr Befehle zu lassen. </p><br><p>  So sieht meine Shell-Eingabeaufforderung unter verschiedenen Bedingungen aus: </p><br><p><img src="https://habrastorage.org/webt/ka/q3/gf/kaq3gfz9idb6pkxdglx44qyuxlq.png"></p><br><p>  Auf dem Screenshot sehen Sie, dass die Titelleiste des Terminals die gleiche Aufgabe √ºbernimmt.  Es ist auch ein Teil eines Dashboards und sollte auch konfiguriert werden. </p><br><p>  Also, wie all diese <code>.zshrc</code> sollten in <code>.zshrc</code> implementiert <code>.zshrc</code> ?  Die <code>PROMPT</code> Variable legt die linke Eingabeaufforderung und <code>RPROMPT</code> die rechte Eingabeaufforderung fest.  Die <code>EUID</code> Variable definiert den Status eines Benutzers (regul√§r oder root) und die Anwesenheit von <code>SSH_CLIENT</code> oder <code>SSH2_CLIENT</code> zeigt eine <code>SSH2_CLIENT</code> Verbindung an.  Also k√∂nnen wir eine Vorlage haben: </p><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH_CLIENT</span></span></span><span class="hljs-string">"</span></span> || -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SSH2_CLIENT</span></span></span><span class="hljs-string">"</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$EUID</span></span> == 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> PROMPT=... <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment"># not SSH if [[ $EUID == 0 ]]; then PROMPT=... else PROMPT=... fi fi</span></span></code> </pre> <br><p>  Ich zeige keinen Code, der zum Kopieren und Einf√ºgen bereit ist, da die genaue Implementierung eine Geschmackssache ist.  Wenn Sie sich nicht die M√ºhe machen m√∂chten und der Screenshot oben f√ºr Sie in Ordnung ist, dann nehmen Sie meine Cofig vom <a href="" rel="nofollow">Github</a> . </p><br><p>  Zusammenfassung: </p><br><ul><li>  Eine farbige Shell-Eingabeaufforderung ist ein Muss. </li><li>  Das erforderliche Minimum ist ein aktuelles Arbeitsverzeichnis. </li><li>  Die Wurzelschale sollte deutlich sichtbar sein. </li><li>  Der Name eines Benutzers interessiert eine Nutzlast nicht, wenn Sie nur ein Konto verwenden. </li><li>  Der Hostname ist n√ºtzlich, wenn Sie √ºber ssh eine Verbindung zu Servern herstellen. Wenn nicht, ist er nicht obligatorisch. </li><li>  Es ist n√ºtzlich, den fehlgeschlagenen Beendigungscode eines letzten Befehls zu sehen. </li><li>  Git-Repo-Status spart Zeit bei <code>git status</code> und <code>git branch</code> Befehlen und ist kinderleicht. </li></ul><br><h3 id="heavily-use-the-command-history">  Verwenden Sie den Befehlsverlauf intensiv </h3><br><p>  Die meisten Befehle in Ihrem Leben geben Sie mehr als einmal ein. Es w√§re also cool, sie aus dem Verlauf zu entfernen, anstatt sie erneut einzugeben.  Alle modernen Shells speichern einen Befehlsverlauf und bieten verschiedene M√∂glichkeiten zum Durchsuchen dieses Verlaufs. </p><br><p>  M√∂glicherweise k√∂nnen Sie den Verlauf bereits mithilfe der Tastenkombination Strg + R durchsuchen.  Leider hat es zwei Nachteile: </p><br><ol><li>  Die Befehlszeile sollte leer sein, um die Suche zu starten, dh falls "man einen Befehl eingegeben hat - erinnerst du dich an die Suche", musst du zuerst deine Eingabe l√∂schen, dann Strg + R dr√ºcken und deine Eingabe wiederholen.  Das dauert zu lange </li><li>  Die Vorw√§rtssuche funktioniert nicht standardm√§√üig, da Strg + S das Terminal anh√§lt. </li></ol><br><p>  Die schnellste und bequemste Art der Suche funktioniert folgenderma√üen: </p><br><ol><li>  Sie beginnen einen Befehl einzugeben, </li><li>  Sie erinnern sich an die Suche, </li><li>  Sie dr√ºcken einen Hotkey und die Shell bietet Ihnen Befehle aus dem Verlauf, die auf die gleiche Weise gestartet wurden. </li></ol><br><p>  Sie m√∂chten beispielsweise ein lokales Verzeichnis mit einem entfernten Verzeichnis mithilfe von Rsync synchronisieren und haben dies bereits zwei Stunden zuvor getan.  Sie geben <code>rsync</code> , dr√ºcken ein- oder zweimal einen Hotkey und der gew√ºnschte Befehl kann gestartet werden.  Sie m√ºssen den Suchmodus nicht zuerst aktivieren, die Shell-Eingabeaufforderung √§ndert sich nicht in <code>(reverse-i-search)':</code> und es springt nirgendwo hin.  Sie scrollen einfach durch den Verlauf, genauso wie Sie die Pfeile ‚Üë ‚Üì dr√ºcken, um durch zuvor eingegebene Befehle zu scrollen, jedoch mit zus√§tzlicher Filterung.  Das ist verdammt cool und spart viel Zeit. </p><br><p>  Diese Art der Suche funktioniert in Bash und Zsh nicht standardm√§√üig, daher m√ºssen Sie sie manuell aktivieren.  Ich habe PgUp f√ºr die Vorw√§rtssuche und PgDown f√ºr die R√ºckw√§rtssuche ausgew√§hlt.  Es ist weit, sie zu erreichen, aber ich habe es mir schon zur Gewohnheit gemacht.  Vielleicht wechsle ich sp√§ter zu etwas n√§herem wie Strg + P und Strg + N. </p><br><p>  F√ºr Bash m√ºssen Sie ein paar Zeichenfolgen zu <code>/etc/inputrc</code> von <code>~/.inputrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[5~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[6~"</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p>  Wenn Sie eine fremde vollst√§ndige <code>.zshrc</code> , ist es sehr wahrscheinlich, dass PgUp und PgDown den Job bereits erledigen.  Wenn nicht, dann f√ºge zu <code>~/.zshrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[5~"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-beginning-search-backward <span class="hljs-comment"><span class="hljs-comment"># pg up bindkey "^[[6~" history-beginning-search-forward # pg down</span></span></code> </pre> <br><p>  Bei Fisch- und Ipython-Muscheln ist eine solche Suche bereits an die Pfeile ‚Üë ‚Üì gebunden.  Ich denke, dass viele Benutzer nur wegen des Verhaltens der Pfeile zu Fish migriert sind.  Nat√ºrlich ist es m√∂glich, die Pfeile auf diese Weise sowohl in Bash als auch in Zsh zu binden, wenn Sie dies w√ºnschen.  Verwenden Sie dies in <code>/etc/inputrc</code> von <code>~/.inputrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">"\e[A"</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-backward <span class="hljs-string"><span class="hljs-string">"\e[B"</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>-search-forward</code> </pre> <br><p>  Und das f√ºr in <code>~/.zshrc</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -U up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">autoload</span></span> -U down-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N down-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[A"</span></span> up-line-or-beginning-search <span class="hljs-built_in"><span class="hljs-built_in">bindkey</span></span> <span class="hljs-string"><span class="hljs-string">"^[[B"</span></span> down-line-or-beginning-search</code> </pre> <br><p>  Es ist merkw√ºrdig, dass ich im Laufe der Zeit angefangen habe, Befehle zu schreiben, um sie sp√§ter aus der Geschichte herauszuholen.  Lassen Sie mich Ihnen einige Techniken zeigen. </p><br><p>  <strong>Verbinde die Befehle</strong> , die immer aufeinander folgen: </p><br><pre> <code class="plaintext hljs"># ip link set eth1 up &amp;&amp; dhclient eth1 # mkdir /tmp/t &amp;&amp; mount /dev/sdb1 /tmp/t</code> </pre> <br><p>  <strong>Mit absoluten Pfaden anstelle von relativen k√∂nnen</strong> Sie einen Befehl aus einem beliebigen Verzeichnis ausf√ºhren: <br>  <code>vim ~/.ssh/config</code> anstelle von <code>vim .ssh/config</code> , <code>systemd-nspawn /home/chroot/stretch</code> anstelle von <code>systemd-nspawn stretch</code> und so weiter. </p><br><p>  <strong>Die Verwendung von Platzhaltern</strong> macht Ihre Befehle universeller.  Ich benutze es normalerweise in Verbindung mit <code>chmod</code> und <code>chown</code> . </p><br><pre> <code class="plaintext hljs"># chown root:root /var/www/*.sq &amp;&amp; chmod 644 /var/www/*.sq</code> </pre> <br><h3 id="keyboard-shortcuts">  Tastaturk√ºrzel </h3><br><p>  Hier ist das erforderliche Minimum. </p><br><p>  Alt +.  - ersetzt das letzte Argument des vorherigen Befehls.  Es kann auch mit <code>!$</code> . <br>  Strg + A, Strg + E - springt an den Anfang bzw. das Ende der Zeile. <br>  Strg + U, Strg + Y - Ausschneiden und Einf√ºgen.  Dies ist praktisch, wenn Sie einen komplexen Befehl eingeben und feststellen, dass Sie zuerst einen anderen ausf√ºhren m√ºssen.  Hmm, wo soll die aktuelle Eingabe gespeichert werden?  Genau hier. <br>  Strg + W - t√∂tet ein Wort vor dem Cursor.  Durch Dr√ºcken und Halten wird die Linie gel√∂scht.  Standardm√§√üig wird die Eingabe in der Zwischenablage gespeichert (verwendet f√ºr Strg + Y). <br>  Strg + K - schneidet den Teil der Linie nach dem Cursor aus und f√ºgt ihn der Zwischenablage hinzu.  Strg + A Strg + K l√∂scht schnell die Zeile. <br>  PgUp, PgDown, Ctrl + R - Verlaufssuche. <br>  Strg + L l√∂scht das Terminal. </p><br><h3 id="keyboard-responsiveness">  Reaktionsf√§higkeit der Tastatur </h3><br><p>  Ich m√∂chte Ihnen ein kleines Setup zeigen, mit dem Sie schneller scrollen, navigieren und l√∂schen k√∂nnen.  Was machen wir, wenn wir etwas Gro√ües l√∂schen wollen?  Wir halten die R√ºcktaste gedr√ºckt und beobachten, wie Zeichen zur√ºckgewischt werden.  Was ist genau los?  Nachdem Sie die R√ºcktaste gedr√ºckt haben, wird ein Zeichen ausgeblendet, eine kurze Verz√∂gerung ausgef√ºhrt und dann die automatische Wiederholung ausgel√∂st: Mit der R√ºcktaste werden die Zeichen nacheinander gel√∂scht, so als w√ºrden Sie wiederholt darauf dr√ºcken. </p><br><p>  Ich empfehle Ihnen, die Verz√∂gerung und die Wiederholungsfrequenz an die Geschwindigkeit Ihrer Finger anzupassen.  Die Verz√∂gerung ist erforderlich, wenn Sie nur ein Zeichen l√∂schen m√∂chten. Sie haben dann die Zeit, eine Taste freizugeben.  Eine zu gro√üe Verz√∂gerung l√§sst Sie auf eine Wiederholung warten.  Nicht genug, um Sie zu √§rgern, aber genug, um die √úbertragung Ihrer Gedanken vom Kopf zum Computer zu verlangsamen.  Je h√∂her die H√§ufigkeit der automatischen Wiederholungen ist, desto schneller wird der Text gel√∂scht und desto schwieriger ist es, diesen Vorgang zu stoppen.  Ziel ist es, einen optimalen Wert zu finden. </p><br><p>  Der Zauberbefehl lautet also: </p><br><pre> <code class="plaintext hljs">$ xset r rate 190 20</code> </pre> <br><p>  190 - Verz√∂gerungsdauer in Millisekunden, <br>  20 - H√§ufigkeit von Wiederholungen pro Sekunde. </p><br><p>  Ich empfehle, von diesen Werten aus zu beginnen und die Verz√∂gerung St√ºck f√ºr St√ºck zu erh√∂hen, bis sie falsch positiv ist, und dann etwas zur√ºckzukehren.  Wenn die Verz√∂gerung zu gering ist, k√∂nnen Sie die Tastatur nicht verwenden.  Um dies zu beheben, sollte ein X-Server oder ein kompletter Computer neu gestartet werden.  Also sei bitte vorsichtig. </p><br><p>  Um Parameter zu speichern, m√ºssen Sie diesen Befehl irgendwo in X Autostart hinzuf√ºgen. </p><br><h3 id="process-exit-indication">  Prozessaustrittsanzeige </h3><br><p>  Ich muss oft einige lange laufende Prozesse starten: ein Fat Backup, Big Data Transfer, Packen / Extrahieren von Archiven, Paketerstellung und so weiter.  Normalerweise starte ich einen solchen Prozess, wechsle zu einer anderen Aufgabe und schaue gelegentlich, wenn mein langwieriger Prozess beendet ist.  Manchmal tauche ich zu tief in die Arbeit ein und vergesse es.  Die L√∂sung besteht darin, eine Benachrichtigung zum Beenden des Prozesses hinzuzuf√ºgen, die mich aus der Trance bringt. </p><br><p>  Es gibt viele Werkzeuge f√ºr diesen Zweck: benachrichtigen-senden, dzen2, Piepton, aplay, Wand.  Alle von ihnen sind irgendwie gut, aber funktionieren nicht mit ssh-Verbindung.  Deshalb benutze ich Terminal Beep: </p><br><pre> <code class="plaintext hljs">$ long-running-command; echo $'\a'</code> </pre> <br><p>  Die ASCII-Codierung hat ein 0x7-Zeichen mit dem Namen <a href="https://en.wikipedia.org/wiki/Bell_character" rel="nofollow">bell</a> .  Es wird verwendet, um den PC-Lautsprecher zu piepen.  PC-Lautsprecher sind keine moderne Sache, nicht jeder Computer hat sie und sie werden nicht in Kopfh√∂rern geh√∂rt.  Aus diesem Grund verwenden einige Terminals eine sogenannte visuelle Klingel.  Ich benutze urxvt und es f√ºhrt eine visuelle Glocke aus, indem es die Dringlichkeitsmarkierung anhebt.  Was ist das  Es wird verwendet, wenn ein Fenster Ihnen mitteilen m√∂chte, dass es dringend ist. </p><br><p>  Sie k√∂nnen jetzt √ºberpr√ºfen, wie Ihr Terminal auf Klingelzeichen reagiert: </p><br><pre> <code class="plaintext hljs">$ sleep 3; echo $'\a'</code> </pre> <br><p>  Sie haben drei Sekunden Zeit, um in ein anderes Fenster zu wechseln. Dies kann erforderlich sein. </p><br><p>  Leider kann nicht jedes Terminal eine visuelle Klingel anzeigen, indem es die Dringlichkeitsmarkierung anhebt.  Ich habe die beliebtesten √ºberpr√ºft. </p><br><div class="scrollable-table"><table><thead><tr><th>  Terminal-Emulator </th><th>  visuelle Glocke als Dringlichkeitsflagge </th></tr></thead><tbody><tr><td>  konsole </td><td>  kann in den Einstellungen aktiviert werden </td></tr><tr><td>  urxvt </td><td>  ja </td></tr><tr><td>  xfce4-terminal </td><td>  kann in den Einstellungen aktiviert werden </td></tr><tr><td>  xterm </td><td>  nein </td></tr><tr><td>  cooler retro Ausdruck </td><td>  nein </td></tr><tr><td>  lxterminal </td><td>  nein </td></tr><tr><td>  gnome-terminal </td><td>  nein </td></tr></tbody></table></div><br><p>  Es ist zu lang, um <code>echo $'\a'</code> einzugeben, daher habe ich einen <code>wake</code> Alias ‚Äã‚Äãerstellt. </p><br><h3 id="aliases">  Aliase </h3><br><p>  Standardm√§√üig funktionieren die Befehle <code>cp</code> , <code>scp</code> und <code>rm</code> nicht rekursiv und das ist schei√üe!  Es ist ein verdammt schlechtes Erbe!  Nun, es kann mit Aliasen behoben werden.  Aber schauen wir uns zuerst an, wann nicht-rekursives Verhalten n√ºtzlich sein kann. </p><br><pre> <code class="plaintext hljs">$ mkdir foodir $ cp * foodir</code> </pre> <br><p>  Es werden nur Dateien in <code>foodir</code> kopiert, keine Verzeichnisse.  Die gleiche Situation gilt f√ºr <code>rm</code> : </p><br><pre> <code class="plaintext hljs">$ rm *</code> </pre> <br><p>  l√∂scht nur Dateien und Symlinks, beh√§lt aber Verzeichnisse bei.  Aber wie oft ben√∂tigen Sie diese Funktion?  Ich denke gerne, dass <code>cp</code> und <code>rm</code> immer rekursiv arbeiten. </p><br><p>  Ok, aber was ist mit der Sicherheit?  Vielleicht sch√ºtzt nicht-rekursives Verhalten Ihre Dateien?  Es gibt einen Fall, in dem Sie einen Symlink zum Verzeichnis haben und diesen Symlink entfernen m√∂chten, aber das Verzeichnis behalten.  Wenn ein Schr√§gstrich (absichtlich oder gelegentlich) an den Verzeichnisnamen angeh√§ngt wird und der rekursive Modus √ºber <code>-r</code> , wird das Verzeichnis leer!  LEER! </p><br><pre> <code class="plaintext hljs">$ ln -s foodir dir_link $ rm -r dir_link/</code> </pre> <br><p>  Ohne <code>-r</code> arg wird es missbrauchen und nichts entfernen.  So erh√∂ht rekursives <code>rm</code> das Risiko, Daten ein wenig zu verlieren. </p><br><p>  Ich habe den rekursiven Modus f√ºr <code>cp</code> , <code>scp</code> und <code>rm</code> <code>mkdir</code> und <code>-p</code> f√ºr <code>mkdir</code> hinzugef√ºgt, um einfach verschachtelte Verzeichnisse zu erstellen. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> cp=<span class="hljs-string"><span class="hljs-string">'cp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> scp=<span class="hljs-string"><span class="hljs-string">'scp -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> rm=<span class="hljs-string"><span class="hljs-string">'rm -r'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> mkdir=<span class="hljs-string"><span class="hljs-string">'mkdir -p'</span></span></code> </pre> <br><p>  Seit zwei Jahren habe ich diese Aliase nie bereut und nie Daten verloren.  Es gibt auch einen Nachteil: Es ist m√∂glich, weniger Daten zu kopieren / zu entfernen, als ben√∂tigt wurden, und sie nicht zu sehen, wenn Sie ohne Aliase am System arbeiten.  Also sei bitte vorsichtig.  Ich wei√ü was ich tue und laufe immer mit Vorsicht. </p><br><p>  Am beliebtesten sind <code>ls</code> Aliase, die Sie wahrscheinlich bereits verwenden: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ls=<span class="hljs-string"><span class="hljs-string">'ls -F --color=auto'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> la=<span class="hljs-string"><span class="hljs-string">'ls -A'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> ll=<span class="hljs-string"><span class="hljs-string">'ls -lh'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> lla=<span class="hljs-string"><span class="hljs-string">'ll -A'</span></span></code> </pre> <br><p>  Auch ein farbiges Grep ist viel h√ºbscher als farblos: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> grep=<span class="hljs-string"><span class="hljs-string">'grep --colour=auto'</span></span></code> </pre> <br><p>  Aliase funktionieren nicht in Skripten, vergessen Sie diese Tatsache nicht!  Sie m√ºssen alle Argumente explizit angeben. </p><br><h3 id="touch-typing">  Tippen Sie auf </h3><br><p>  Es liegt auf der Hand, aber ich erinnere Sie daran: Tippen hilft, schneller zu tippen.  Am Anfang wird es schwierig, aber mit der Zeit werden Sie die Grenzen √ºberwinden. </p><br><p>  Die beste Zeit, um das Tippen zu lernen, ist Urlaub, wenn Sie niemand st√∂rt.  Bitte beeilen Sie sich nicht beim Lernen!  Ihr Ziel ist es, sich <em>zu merken,</em> wo sich jeder Charakter befindet, nicht so sehr mit Ihrem Verstand, sondern mit Ihren Fingern.  Es ist besser, langsam zu tippen, aber ohne Fehler, als mit Fehlern schnell.  Denken Sie daran, dass Meister nicht mit schnellen Fingern gute Ergebnisse erzielen, sondern keine Fehler machen. </p><br><p>  Vergiss nicht eine Pause zu machen.  Ihr Gehirn und Ihre Finger m√ºssen sich ausruhen.  Wenn Fehler auftreten, m√ºssen Sie eine Pause einlegen. </p><br><h3 id="that-is-all-for-today">  Das ist alles f√ºr heute </h3><br><p>  Ich hoffe, diese Tipps werden Ihnen wirklich helfen.  Viel Gl√ºck! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481940/">https://habr.com/ru/post/de481940/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481926/index.html">Lernen Sie die neue Veeam Backup for AWS-L√∂sung kennen</a></li>
<li><a href="../de481930/index.html">Entwicklungskultur: Wie Leistung und Effizienz bewertet werden</a></li>
<li><a href="../de481932/index.html">Bereitstellung und Datenbanken ohne Ausfallzeiten</a></li>
<li><a href="../de481934/index.html">Analyse: Warum der Kurs der Tesla-Aktie steigt</a></li>
<li><a href="../de481936/index.html">Vor- und Nachteile von A / B-Tests: Erfahrung gro√üer Unternehmen</a></li>
<li><a href="../de481942/index.html">Zur√ºck in die Zukunft: Welche modernen Spiele wurden 2010 vorgestellt?</a></li>
<li><a href="../de481944/index.html">Was bestimmt die Position der Site auf der Suchseite?</a></li>
<li><a href="../de481946/index.html">Kommunikationsmethoden in Microsoft-Teams: Channels VS Chats</a></li>
<li><a href="../de481948/index.html">Wie erstelle ich einen virtuellen Roboter?</a></li>
<li><a href="../de481950/index.html">Tutorial: Reaktiver Spring Boot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>