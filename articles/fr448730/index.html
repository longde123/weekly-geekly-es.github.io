<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ¤’ ğŸ‘¨ğŸ¼â€ğŸ¤ Overclocking du moniteur ğŸ˜… ğŸ™ğŸ½ ğŸ‘Œ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'overclocking du processeur ou de la mÃ©moire est comprÃ©hensible, mais pourquoi overclocker le rÃ©troÃ©clairage du moniteur? 



 Il s'agit de l'ancien ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Overclocking du moniteur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448730/"> L'overclocking du processeur ou de la mÃ©moire est comprÃ©hensible, mais pourquoi overclocker le rÃ©troÃ©clairage du moniteur? <br><br><img src="https://habrastorage.org/webt/j9/-x/td/j9-xtd1vnzydcain6_yk9lq6u7k.png"><br><br>  Il s'agit de l'ancien Samsung SyncMaster BX2340 de 23 pouces (sorti en janvier 2011) avec rÃ©tro-Ã©clairage LED.  Au fil du temps, il a commencÃ© Ã  remarquer que travailler pour lui Ã©tait fatigant et se concentrait de plus en plus difficile.  Et pas seulement travailler, il suffit de lire, par exemple.  Le moniteur lui-mÃªme est restÃ© le mÃªme, mais cela est devenu plus difficile pour moi.  Et pour les autres Ã©crans, cela a trÃ¨s bien fonctionnÃ©. <br><a name="habracut"></a><br>  Une fois <i>sur Internet,</i> j'ai lu sur les sentiments subjectifs des utilisateurs de tÃ©lÃ©phones avec Ã©crans OLED avec un taux de rafraÃ®chissement de 240 Hz.  Se plaint de fatigue et de maux de tÃªte.  Et il y avait des rÃ©fÃ©rences (sans preuves) d'Ã©tudes sur l'effet de la frÃ©quence de gradation du rÃ©tro-Ã©clairage sur le corps: bien que l'Å“il ne voit pas de scintillement Ã  240 Hz, le cerveau y rÃ©pond.  Une lueur constante ou avec une frÃ©quence supÃ©rieure Ã  3 kHz ne charge pas le cerveau de cette faÃ§on. <br><br>  Ensuite, sur YouTube, j'ai obtenu une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vidÃ©o</a> sur la refonte du rÃ©tro-Ã©clairage du moniteur pour le courant continu.  L'intervention dans le schÃ©ma a Ã©tÃ© cardinale.  Sous la vidÃ©o, il y avait des commentaires sur le changement de couleur Ã  faible courant sur les fils.  Et mon rÃ©tro-Ã©clairage fonctionne Ã  10-25%, car la piÃ¨ce est assez sombre.  <b>UPD</b> : Dans la vidÃ©o, l'auteur n'avait qu'une seule guirlande de LED et j'en avais 4. <br><br>  Il a Ã©tÃ© dÃ©cidÃ© de quitter le contrÃ´le de la luminositÃ© en utilisant <abbr title="Modulation de largeur d'impulsion, PWM">PWM</abbr> , mais d'augmenter la frÃ©quence.  Je n'ai mÃªme pas commencÃ© Ã  mesurer le scintillement par une mÃ©thode non invasive Ã  l'aide d'une photorÃ©sistance ou d'une photodiode, j'ai tout de suite dÃ©montÃ© le moniteur. <br><br><img src="https://habrastorage.org/webt/vh/xo/gv/vhxogvdagy1igeuolvfj8pnaqpq.jpeg"><br><br>  ContrÃ´leur de rÃ©troÃ©clairage - OZ9993CN.  Il n'y avait pas de fiche technique normale, seulement un pilote de rÃ©troÃ©clairage de groupe fabriquÃ© par O <sub>2</sub> Micro.  Il s'est avÃ©rÃ© que le pilote est Ã©galement impliquÃ© dans l'augmentation de la tension (selon les mesures de 14,4 V Ã  54,6 V) en utilisant un transistor Ã  effet de champ externe puissant et une inductance. <br><br>  L'un des circuits a une signification similaire Ã  celle du pilote; les numÃ©ros de broches ne correspondent pas: <br><br><img src="https://habrastorage.org/webt/cm/z0/15/cmz015ibazr_t1kscsgzsi1u8aw.png"><br><br>  Sur la carte, le chemin du signal PWM vers le pilote est signÃ© comme B-Dim (gradation du rÃ©tro-Ã©clairage?), Je n'ai pas eu Ã  chercher.  Ensuite, un clone de l'oscilloscope numÃ©rique USBee AX USB couplÃ© Ã  sigrok du cÃ´tÃ© PC est entrÃ© en jeu.  La mesure a montrÃ© que la frÃ©quence de rÃ©troÃ©clairage est de 180 Hz (ce ne sera pas suffisant!).  Niveau de signal Ã©levÃ© - 5 V. <br><br><img src="https://habrastorage.org/webt/sa/cw/eh/sacwehre4ijik_-yuuwyqscppfs.png"><br><br>  Maintenant, vous devez en quelque sorte augmenter la frÃ©quence PWM Ã  des valeurs kilohertz, une fois tous les 16. La premiÃ¨re chose qui m'est venue Ã  l'esprit est d'insÃ©rer un microcontrÃ´leur dans l'espace de piste PWM pour recevoir le signal et le jouer 16 fois plus vite.  Nous avons besoin de 2 temporisateurs, l'un mesurera la durÃ©e des niveaux bas et haut, l'autre donnera un signal PWM.  AprÃ¨s avoir ramassÃ© les coefficients du diviseur, nous pouvons nous passer du tout d'arithmÃ©tique, simplement en copiant.  Non, Arduino ne le fera pas.  Il n'y aura pas non plus d'assembleur, il y aura GCC.  Le petit MK avec au moins deux minuteries (en stock) Ã©tait ATtiny15.  Mais WinAVR ne veut pas travailler avec, donc j'ai dÃ» prendre une version plus ancienne - ATtiny45 (ATtiny25 / 85 fonctionnera Ã©galement). <br><br>  SchÃ©ma: <br><br><pre><code class="plaintext hljs">100n â”Œâ”€â”€â”€â”€â”€â”€â”€â”¤â”œâ”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ 1 8 â”œâ”€â”´â”€ VCC â”‚ â”‚ 2 7 â”œâ”€ PB2 (INT0) INPUT â”‚ â”‚ 3 6 â”œâ”€ PB1 (OC1A) OUTPUT GND â”€â”´â”€â”¤ 4 5 â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ATtiny45</code> </pre> <br>  Nous sÃ©lectionnons les facteurs des diviseurs de minuterie.  Prenez la frÃ©quence du processeur d'environ 8 MHz, Ã  partir du gÃ©nÃ©rateur RC intÃ©grÃ©. <br><br><ul><li>  Minuterie de mesure.  Combien de mesures pendant la pÃ©riode de gradation? <math></math><img src="https://habrastorage.org/getpro/habr/formulas/bce/3f9/e3f/bce3f9e3f9048249864fc5ec893c130b.svg" alt="8000000/180 $ \ environ 44444 $" data-tex="inline">  .  Pour que cela s'intÃ¨gre dans le registre Ã  huit bits du temporisateur avec une perte de prÃ©cision minimale, nous prenons le prÃ©-diviseur 256, la valeur maximale du compteur sera <math></math><img src="https://habrastorage.org/getpro/habr/formulas/f7e/d9a/a5e/f7ed9aa5e850f87710b2a3b71b187358.svg" alt="8 000 000 $ / 180/256 \ environ 173,6 $" data-tex="inline">  . </li><li>  Minuterie PWM  Nous allons augmenter la frÃ©quence 16 fois: <math></math><img src="https://habrastorage.org/getpro/habr/formulas/815/7e2/851/8157e28514214fc0aed19a97c6e851e7.svg" alt="180 $ \ cdot 16 = 2880 Hz $" data-tex="inline">  , alors le prÃ©-diviseur est autant de fois plus petit: <math></math><img src="https://habrastorage.org/getpro/habr/formulas/00c/f8a/413/00cf8a413a1aa29d9c9b7129efc855cb.svg" alt="256/16 $ = 16 $" data-tex="inline">  . </li></ul><br>  Le signal d'entrÃ©e est connectÃ© Ã  la jambe d'interruption externe.  Gestionnaire de celui-ci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* External Interrupt 0 */</span></span> ISR(INT0_vect, ISR_NAKED) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> timer = TCNT0; <span class="hljs-comment"><span class="hljs-comment">//     if (PINB &amp; 1&lt;&lt;PB2) { //  .   -    OCR1C = timer; //   TCNT0 = 0; //     } else { //   -  OCR1A = timer; //   } reti(); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce que ISR_NAKED?</b> <div class="spoiler_text">  "ISR_NAKED" signifie que la sauvegarde / restauration des registres et drapeaux du processeur est supprimÃ©e, ceci est fait pour accÃ©lÃ©rer.  Cela peut Ãªtre fait en s'assurant qu'ils ne sont pas affectÃ©s dans la boucle principale (nous avons juste une boucle <code>while(1) {}</code> sans fin <code>while(1) {}</code> ), et qu'il n'y aura pas d'appels de sous-programmes.  Eh bien, Ã  la fin, nous prescrivons le retour de la fonction avec l'armement de l' <code>reti()</code> interruption <code>reti()</code> . <br></div></div><br>  SoudÃ©, flashÃ© - et cela a fonctionnÃ©! <br><br><img src="https://habrastorage.org/webt/bb/at/e0/bbate0_liq4thqfjsibldj4yd-w.jpeg"><br><br>  Mais l'accÃ©lÃ©rateur a commencÃ© Ã  grincer.  Nous regardons ce qui se trouve sur la porte du contrÃ´leur de terrain qui contrÃ´le le courant Ã  travers l'inductance de puissance: <br><br><img src="https://habrastorage.org/webt/nj/ia/ph/njiaphmjgkj_23joxovlut5-afm.png"><br><br>  Tout est en ordre avec l'accÃ©lÃ©rateur, il continue de fonctionner Ã  une frÃ©quence de 320 kHz, mais si auparavant la frÃ©quence PWM Ã©tait de 180 Hz et est presque inaudible (seulement si vous apportez votre oreille), alors 2,9 kHz est trÃ¨s audible.  Et le confort n'a clairement pas augmentÃ©.  Mais que se passe-t-il si vous amenez la frÃ©quence au-delÃ  de la limite supÃ©rieure d'audibilitÃ©?  Par exemple <math></math><img src="https://habrastorage.org/getpro/habr/formulas/b6a/007/885/b6a007885f79173e0b6b01619f3e7ba8.svg" alt="180 Hz $ \ cdot 128 = 23040 Hz $" data-tex="inline">  ?  Nous modifions le multiplicateur du diviseur de temporisation PWM de 16 Ã  2 et le clignotons.  Il s'est avÃ©rÃ© que tout Ã©tait en ordre.  Presque. <br><br>  Les minuteries Ã  huit bits dans ce cas ne suffisent pas <s>, vous avez besoin de plus de minÃ©raux</s> .  Cela se manifeste sous la forme de fluctuations de luminositÃ© Ã  basse frÃ©quence, avec une augmentation et une disparition en douceur d'une frÃ©quence de plusieurs secondes.  Pour faire face Ã  ce flÃ©au, vous pouvez prendre le cristal plus gros, mais ce n'est pas notre chemin.  Nous allons augmenter la profondeur de bits de la minuterie de mesure par programmation et introduire un seuil (hystÃ©rÃ©sis) pour une dÃ©tection fiable de la commutation de luminositÃ© par l'utilisateur (0â€“100 avec une rÃ©solution de 1).  Nous augmentons la prÃ©cision du chronomÃ¨tre de mesure de 256 fois et le facteur multiplicateur devient Ã©gal Ã  1. <br><br>  Gestionnaire de dÃ©bordement de la minuterie de mesure avec l'option Â«quelque chose s'est mal passÃ© et la durÃ©e du niveau a traÃ®nÃ©Â»: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Timer/Counter0 Overflow */</span></span> ISR(TIM0_OVF_vect, ISR_NAKED) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIME_H_LIM (UCHAR_MAX-1) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (time_h &lt; TIME_H_LIM) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Normal way time_h += 1; } else { // High part overflowed if (PINB &amp; 1&lt;&lt;PB2) { OCR1A = TIME_H_LIM; // Always on } else { OCR1A = 0; // Always off } OCR1C = TIME_H_LIM; time_h = 0; time_cycle = 0; time_on = 0; } reti(); // Because ISR_NAKED }</span></span></span></span></code> </pre> <br>  L'interruption externe est dÃ©sormais un peu plus compliquÃ©e: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* External Interrupt 0 */</span></span> ISR(INT0_vect, ISR_NAKED) { <span class="hljs-comment"><span class="hljs-comment">// F_CPU / Timer1 prescaler / F_PWM_IN / grades / 4 #define THRESHOLD (F_CPU / 1 / F_PWM_IN / 100 / 4) uint16_t time; uint8_t time_l = TCNT0; if ((TIFR &amp; 1&lt;&lt;TOV0) &amp;&amp; (time_l &lt;= UCHAR_MAX/2)) { // Overflow occured right now time_l = UCHAR_MAX; // 0xff } time = (time_h &lt;&lt; 8) + time_l; if (PINB &amp; 1&lt;&lt;PB2) { // Risen if (abs(time - time_cycle) &gt; THRESHOLD) { time_cycle = time; OCR1C = time_h; } TCNT0 = 0; time_h = 0; if (TIFR &amp; 1&lt;&lt;TOV0) { TIFR = 1&lt;&lt;TOV0; // Clear Timer0 overflow flag } } else { // Falled if (abs(time - time_on) &gt; THRESHOLD) { time_on = time; OCR1A = time_h; } } reti(); // Because ISR_NAKED }</span></span></code> </pre> <br>  Il y a des variables globales que j'ai introduites dans les registres, nous avons l'overclocking aprÃ¨s tout.  SRAM est uniquement utilisÃ© pour stocker l'adresse de retour lors de la saisie des gestionnaires d'interruption.  La partie la plus Ã©levÃ©e du compteur de mesure d'intervalle se trouve dans la variable time_h, et les valeurs de la longueur de cycle PWM et du rapport cyclique mesurÃ©s sont dans time_cycle et time_on, respectivement.  SEUIL - seuil pour dÃ©tecter les changements de luminositÃ©. <br><br>  Maintenant, tout fonctionnait comme prÃ©vu. <br><br><div class="spoiler">  <b class="spoiler_title">Code complet</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PWM frequency multiplier x128 100n â”Œâ”€â”€â”€â”€â”€â”€â”€â”¤â”œâ”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ 1 8 â”œâ”€â”´â”€ VCC â”‚ â”‚ 2 7 â”œâ”€ PB2 (INT0) INPUT â”‚ â”‚ 3 6 â”œâ”€ PB1 (OC1A) OUTPUT GND â”€â”´â”€â”¤ 4 5 â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ATtiny45 fuses: lfuse=0xe2 hfuse=0xdf */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/interrupt.h&gt; #include &lt;avr/wdt.h&gt; #include &lt;stdlib.h&gt; #include &lt;limits.h&gt; #define F_CPU 8000000UL #define F_PWM_IN 180U register uint8_t time_h asm("r4"); // High part of time counter register uint16_t time_cycle asm("r12"); // Period register uint16_t time_on asm("r14"); // H level duration __attribute__((naked)) int main(void) { time_h = 0; time_cycle = 0; time_on = 0; ACSR |= 1&lt;&lt;ACD; // Comparator disable // Timer0 TCCR0A = 0; // CK/1 TCCR0B = 1&lt;&lt;CS00; // Timer1 DDRB |= 1&lt;&lt;PB1; // PWM output // CK/2, Clear the OC1A output line TCCR1 = 1&lt;&lt;CTC1|1&lt;&lt;PWM1A|2&lt;&lt;COM1A0|2&lt;&lt;CS10; TIMSK |= 1&lt;&lt;TOIE0; // Timer0 overflow // Ext int 0 MCUCR |= 1&lt;&lt;ISC00; // Any logical change on INT0 generates an interrupt request GIMSK |= 1&lt;&lt;INT0; // External Interrupt Request 0 Enable PORTB |= 1&lt;&lt;PB2; // Input wdt_enable(WDTO_120MS); // Watchdog on sei(); // Interrupts enable while (1) { // Do not use flags or registers wdt_reset(); // Watchdog reset } } /* External Interrupt 0 */ ISR(INT0_vect, ISR_NAKED) { // F_CPU / Timer1 prescaler / F_PWM_IN / grades / 4 #define THRESHOLD (F_CPU / 1 / F_PWM_IN / 100 / 4) uint16_t time; uint8_t time_l = TCNT0; if ((TIFR &amp; 1&lt;&lt;TOV0) &amp;&amp; (time_l &lt;= UCHAR_MAX/2)) { // Overflow occured right now time_l = UCHAR_MAX; // 0xff } time = (time_h &lt;&lt; 8) + time_l; if (PINB &amp; 1&lt;&lt;PB2) { // Risen if (abs(time - time_cycle) &gt; THRESHOLD) { time_cycle = time; OCR1C = time_h; } TCNT0 = 0; time_h = 0; if (TIFR &amp; 1&lt;&lt;TOV0) { TIFR = 1&lt;&lt;TOV0; // Clear Timer0 overflow flag } } else { // Falled if (abs(time - time_on) &gt; THRESHOLD) { time_on = time; OCR1A = time_h; } } reti(); // Because ISR_NAKED } /* Timer/Counter0 Overflow */ ISR(TIM0_OVF_vect, ISR_NAKED) { #define TIME_H_LIM (UCHAR_MAX-1) if (time_h &lt; TIME_H_LIM) { // Normal way time_h += 1; } else { // High part overflowed if (PINB &amp; 1&lt;&lt;PB2) { OCR1A = TIME_H_LIM; // Always on } else { OCR1A = 0; // Always off } OCR1C = TIME_H_LIM; time_h = 0; time_cycle = 0; time_on = 0; } reti(); // Because ISR_NAKED }</span></span></span></span></code> </pre><br></div></div><br>  Vous pouvez l'appeler autosuggestion, mais le rÃ©sultat est le suivant: la vie est devenue meilleure, la vie est devenue plus amusante!  MÃªme les projets de longue haleine ont Ã©voluÃ©. <br><br>  Si dans votre cas, la frÃ©quence du rÃ©troÃ©clairage n'affecte en rien votre bien-Ãªtre et votre productivitÃ© - considÃ©rez-vous chanceux.  Probablement.  Ainsi que les personnes qui assurent un confort absolu lorsque la teneur en CO <sub>2</sub> de la piÃ¨ce est supÃ©rieure Ã  0,2% (2000 <abbr title="MillioniÃ¨me ppm">ppm</abbr> ). <br><br><div class="spoiler">  <b class="spoiler_title">Mais qu'en est-il du lien vers github?</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La voici</a> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448730/">https://habr.com/ru/post/fr448730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448714/index.html">Slack - un thÃ¨me sombre non officiel pour la version de bureau de Windows, Linux, MacOS</a></li>
<li><a href="../fr448718/index.html">CrÃ©ation d'un treillis mÃ©tallique dans SPDS</a></li>
<li><a href="../fr448724/index.html">News de la semaine: le FSB n'est pas un dÃ©cret pour les opÃ©rateurs, l'IA bat les champions, Apple et Qualcomm se rÃ©concilient</a></li>
<li><a href="../fr448726/index.html">Affaire. De 0 Ã  81% de sÃ©mantique en TOP en 2 jours</a></li>
<li><a href="../fr448728/index.html">AprÃ¨s quelques dÃ©cennies, le cerveau sera connectÃ© Ã  Internet</a></li>
<li><a href="../fr448732/index.html">Hernie intervertÃ©brale? Travailler sur elle</a></li>
<li><a href="../fr448734/index.html">Des drones et des robots aident Ã  sauver la cathÃ©drale Notre-Dame de Paris</a></li>
<li><a href="../fr448738/index.html">Qui chasse les startups?</a></li>
<li><a href="../fr448740/index.html">Nous Ã©coutons de la musique SID (Commodore 64) via OPL3 sur des PC modernes</a></li>
<li><a href="../fr448742/index.html">Pandora's Box: nous analysons l'exploitation de la vulnÃ©rabilitÃ© WinRAR Ã  l'aide de l'exemple du job NeoQUEST-2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>