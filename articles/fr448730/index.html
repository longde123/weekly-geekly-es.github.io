<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏻 🤒 👨🏼‍🎤 Overclocking du moniteur 😅 🙍🏽 👌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'overclocking du processeur ou de la mémoire est compréhensible, mais pourquoi overclocker le rétroéclairage du moniteur? 



 Il s'agit de l'ancien ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Overclocking du moniteur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448730/"> L'overclocking du processeur ou de la mémoire est compréhensible, mais pourquoi overclocker le rétroéclairage du moniteur? <br><br><img src="https://habrastorage.org/webt/j9/-x/td/j9-xtd1vnzydcain6_yk9lq6u7k.png"><br><br>  Il s'agit de l'ancien Samsung SyncMaster BX2340 de 23 pouces (sorti en janvier 2011) avec rétro-éclairage LED.  Au fil du temps, il a commencé à remarquer que travailler pour lui était fatigant et se concentrait de plus en plus difficile.  Et pas seulement travailler, il suffit de lire, par exemple.  Le moniteur lui-même est resté le même, mais cela est devenu plus difficile pour moi.  Et pour les autres écrans, cela a très bien fonctionné. <br><a name="habracut"></a><br>  Une fois <i>sur Internet,</i> j'ai lu sur les sentiments subjectifs des utilisateurs de téléphones avec écrans OLED avec un taux de rafraîchissement de 240 Hz.  Se plaint de fatigue et de maux de tête.  Et il y avait des références (sans preuves) d'études sur l'effet de la fréquence de gradation du rétro-éclairage sur le corps: bien que l'œil ne voit pas de scintillement à 240 Hz, le cerveau y répond.  Une lueur constante ou avec une fréquence supérieure à 3 kHz ne charge pas le cerveau de cette façon. <br><br>  Ensuite, sur YouTube, j'ai obtenu une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vidéo</a> sur la refonte du rétro-éclairage du moniteur pour le courant continu.  L'intervention dans le schéma a été cardinale.  Sous la vidéo, il y avait des commentaires sur le changement de couleur à faible courant sur les fils.  Et mon rétro-éclairage fonctionne à 10-25%, car la pièce est assez sombre.  <b>UPD</b> : Dans la vidéo, l'auteur n'avait qu'une seule guirlande de LED et j'en avais 4. <br><br>  Il a été décidé de quitter le contrôle de la luminosité en utilisant <abbr title="Modulation de largeur d'impulsion, PWM">PWM</abbr> , mais d'augmenter la fréquence.  Je n'ai même pas commencé à mesurer le scintillement par une méthode non invasive à l'aide d'une photorésistance ou d'une photodiode, j'ai tout de suite démonté le moniteur. <br><br><img src="https://habrastorage.org/webt/vh/xo/gv/vhxogvdagy1igeuolvfj8pnaqpq.jpeg"><br><br>  Contrôleur de rétroéclairage - OZ9993CN.  Il n'y avait pas de fiche technique normale, seulement un pilote de rétroéclairage de groupe fabriqué par O <sub>2</sub> Micro.  Il s'est avéré que le pilote est également impliqué dans l'augmentation de la tension (selon les mesures de 14,4 V à 54,6 V) en utilisant un transistor à effet de champ externe puissant et une inductance. <br><br>  L'un des circuits a une signification similaire à celle du pilote; les numéros de broches ne correspondent pas: <br><br><img src="https://habrastorage.org/webt/cm/z0/15/cmz015ibazr_t1kscsgzsi1u8aw.png"><br><br>  Sur la carte, le chemin du signal PWM vers le pilote est signé comme B-Dim (gradation du rétro-éclairage?), Je n'ai pas eu à chercher.  Ensuite, un clone de l'oscilloscope numérique USBee AX USB couplé à sigrok du côté PC est entré en jeu.  La mesure a montré que la fréquence de rétroéclairage est de 180 Hz (ce ne sera pas suffisant!).  Niveau de signal élevé - 5 V. <br><br><img src="https://habrastorage.org/webt/sa/cw/eh/sacwehre4ijik_-yuuwyqscppfs.png"><br><br>  Maintenant, vous devez en quelque sorte augmenter la fréquence PWM à des valeurs kilohertz, une fois tous les 16. La première chose qui m'est venue à l'esprit est d'insérer un microcontrôleur dans l'espace de piste PWM pour recevoir le signal et le jouer 16 fois plus vite.  Nous avons besoin de 2 temporisateurs, l'un mesurera la durée des niveaux bas et haut, l'autre donnera un signal PWM.  Après avoir ramassé les coefficients du diviseur, nous pouvons nous passer du tout d'arithmétique, simplement en copiant.  Non, Arduino ne le fera pas.  Il n'y aura pas non plus d'assembleur, il y aura GCC.  Le petit MK avec au moins deux minuteries (en stock) était ATtiny15.  Mais WinAVR ne veut pas travailler avec, donc j'ai dû prendre une version plus ancienne - ATtiny45 (ATtiny25 / 85 fonctionnera également). <br><br>  Schéma: <br><br><pre><code class="plaintext hljs">100n ┌───────┤├───────┐ │ ┌────────────┐ │ │ │ 1 8 ├─┴─ VCC │ │ 2 7 ├─ PB2 (INT0) INPUT │ │ 3 6 ├─ PB1 (OC1A) OUTPUT GND ─┴─┤ 4 5 │ └────────────┘ ATtiny45</code> </pre> <br>  Nous sélectionnons les facteurs des diviseurs de minuterie.  Prenez la fréquence du processeur d'environ 8 MHz, à partir du générateur RC intégré. <br><br><ul><li>  Minuterie de mesure.  Combien de mesures pendant la période de gradation? <math></math><img src="https://habrastorage.org/getpro/habr/formulas/bce/3f9/e3f/bce3f9e3f9048249864fc5ec893c130b.svg" alt="8000000/180 $ \ environ 44444 $" data-tex="inline">  .  Pour que cela s'intègre dans le registre à huit bits du temporisateur avec une perte de précision minimale, nous prenons le pré-diviseur 256, la valeur maximale du compteur sera <math></math><img src="https://habrastorage.org/getpro/habr/formulas/f7e/d9a/a5e/f7ed9aa5e850f87710b2a3b71b187358.svg" alt="8 000 000 $ / 180/256 \ environ 173,6 $" data-tex="inline">  . </li><li>  Minuterie PWM  Nous allons augmenter la fréquence 16 fois: <math></math><img src="https://habrastorage.org/getpro/habr/formulas/815/7e2/851/8157e28514214fc0aed19a97c6e851e7.svg" alt="180 $ \ cdot 16 = 2880 Hz $" data-tex="inline">  , alors le pré-diviseur est autant de fois plus petit: <math></math><img src="https://habrastorage.org/getpro/habr/formulas/00c/f8a/413/00cf8a413a1aa29d9c9b7129efc855cb.svg" alt="256/16 $ = 16 $" data-tex="inline">  . </li></ul><br>  Le signal d'entrée est connecté à la jambe d'interruption externe.  Gestionnaire de celui-ci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* External Interrupt 0 */</span></span> ISR(INT0_vect, ISR_NAKED) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> timer = TCNT0; <span class="hljs-comment"><span class="hljs-comment">//     if (PINB &amp; 1&lt;&lt;PB2) { //  .   -    OCR1C = timer; //   TCNT0 = 0; //     } else { //   -  OCR1A = timer; //   } reti(); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce que ISR_NAKED?</b> <div class="spoiler_text">  "ISR_NAKED" signifie que la sauvegarde / restauration des registres et drapeaux du processeur est supprimée, ceci est fait pour accélérer.  Cela peut être fait en s'assurant qu'ils ne sont pas affectés dans la boucle principale (nous avons juste une boucle <code>while(1) {}</code> sans fin <code>while(1) {}</code> ), et qu'il n'y aura pas d'appels de sous-programmes.  Eh bien, à la fin, nous prescrivons le retour de la fonction avec l'armement de l' <code>reti()</code> interruption <code>reti()</code> . <br></div></div><br>  Soudé, flashé - et cela a fonctionné! <br><br><img src="https://habrastorage.org/webt/bb/at/e0/bbate0_liq4thqfjsibldj4yd-w.jpeg"><br><br>  Mais l'accélérateur a commencé à grincer.  Nous regardons ce qui se trouve sur la porte du contrôleur de terrain qui contrôle le courant à travers l'inductance de puissance: <br><br><img src="https://habrastorage.org/webt/nj/ia/ph/njiaphmjgkj_23joxovlut5-afm.png"><br><br>  Tout est en ordre avec l'accélérateur, il continue de fonctionner à une fréquence de 320 kHz, mais si auparavant la fréquence PWM était de 180 Hz et est presque inaudible (seulement si vous apportez votre oreille), alors 2,9 kHz est très audible.  Et le confort n'a clairement pas augmenté.  Mais que se passe-t-il si vous amenez la fréquence au-delà de la limite supérieure d'audibilité?  Par exemple <math></math><img src="https://habrastorage.org/getpro/habr/formulas/b6a/007/885/b6a007885f79173e0b6b01619f3e7ba8.svg" alt="180 Hz $ \ cdot 128 = 23040 Hz $" data-tex="inline">  ?  Nous modifions le multiplicateur du diviseur de temporisation PWM de 16 à 2 et le clignotons.  Il s'est avéré que tout était en ordre.  Presque. <br><br>  Les minuteries à huit bits dans ce cas ne suffisent pas <s>, vous avez besoin de plus de minéraux</s> .  Cela se manifeste sous la forme de fluctuations de luminosité à basse fréquence, avec une augmentation et une disparition en douceur d'une fréquence de plusieurs secondes.  Pour faire face à ce fléau, vous pouvez prendre le cristal plus gros, mais ce n'est pas notre chemin.  Nous allons augmenter la profondeur de bits de la minuterie de mesure par programmation et introduire un seuil (hystérésis) pour une détection fiable de la commutation de luminosité par l'utilisateur (0–100 avec une résolution de 1).  Nous augmentons la précision du chronomètre de mesure de 256 fois et le facteur multiplicateur devient égal à 1. <br><br>  Gestionnaire de débordement de la minuterie de mesure avec l'option «quelque chose s'est mal passé et la durée du niveau a traîné»: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Timer/Counter0 Overflow */</span></span> ISR(TIM0_OVF_vect, ISR_NAKED) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIME_H_LIM (UCHAR_MAX-1) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (time_h &lt; TIME_H_LIM) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Normal way time_h += 1; } else { // High part overflowed if (PINB &amp; 1&lt;&lt;PB2) { OCR1A = TIME_H_LIM; // Always on } else { OCR1A = 0; // Always off } OCR1C = TIME_H_LIM; time_h = 0; time_cycle = 0; time_on = 0; } reti(); // Because ISR_NAKED }</span></span></span></span></code> </pre> <br>  L'interruption externe est désormais un peu plus compliquée: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* External Interrupt 0 */</span></span> ISR(INT0_vect, ISR_NAKED) { <span class="hljs-comment"><span class="hljs-comment">// F_CPU / Timer1 prescaler / F_PWM_IN / grades / 4 #define THRESHOLD (F_CPU / 1 / F_PWM_IN / 100 / 4) uint16_t time; uint8_t time_l = TCNT0; if ((TIFR &amp; 1&lt;&lt;TOV0) &amp;&amp; (time_l &lt;= UCHAR_MAX/2)) { // Overflow occured right now time_l = UCHAR_MAX; // 0xff } time = (time_h &lt;&lt; 8) + time_l; if (PINB &amp; 1&lt;&lt;PB2) { // Risen if (abs(time - time_cycle) &gt; THRESHOLD) { time_cycle = time; OCR1C = time_h; } TCNT0 = 0; time_h = 0; if (TIFR &amp; 1&lt;&lt;TOV0) { TIFR = 1&lt;&lt;TOV0; // Clear Timer0 overflow flag } } else { // Falled if (abs(time - time_on) &gt; THRESHOLD) { time_on = time; OCR1A = time_h; } } reti(); // Because ISR_NAKED }</span></span></code> </pre> <br>  Il y a des variables globales que j'ai introduites dans les registres, nous avons l'overclocking après tout.  SRAM est uniquement utilisé pour stocker l'adresse de retour lors de la saisie des gestionnaires d'interruption.  La partie la plus élevée du compteur de mesure d'intervalle se trouve dans la variable time_h, et les valeurs de la longueur de cycle PWM et du rapport cyclique mesurés sont dans time_cycle et time_on, respectivement.  SEUIL - seuil pour détecter les changements de luminosité. <br><br>  Maintenant, tout fonctionnait comme prévu. <br><br><div class="spoiler">  <b class="spoiler_title">Code complet</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PWM frequency multiplier x128 100n ┌───────┤├───────┐ │ ┌────────────┐ │ │ │ 1 8 ├─┴─ VCC │ │ 2 7 ├─ PB2 (INT0) INPUT │ │ 3 6 ├─ PB1 (OC1A) OUTPUT GND ─┴─┤ 4 5 │ └────────────┘ ATtiny45 fuses: lfuse=0xe2 hfuse=0xdf */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/interrupt.h&gt; #include &lt;avr/wdt.h&gt; #include &lt;stdlib.h&gt; #include &lt;limits.h&gt; #define F_CPU 8000000UL #define F_PWM_IN 180U register uint8_t time_h asm("r4"); // High part of time counter register uint16_t time_cycle asm("r12"); // Period register uint16_t time_on asm("r14"); // H level duration __attribute__((naked)) int main(void) { time_h = 0; time_cycle = 0; time_on = 0; ACSR |= 1&lt;&lt;ACD; // Comparator disable // Timer0 TCCR0A = 0; // CK/1 TCCR0B = 1&lt;&lt;CS00; // Timer1 DDRB |= 1&lt;&lt;PB1; // PWM output // CK/2, Clear the OC1A output line TCCR1 = 1&lt;&lt;CTC1|1&lt;&lt;PWM1A|2&lt;&lt;COM1A0|2&lt;&lt;CS10; TIMSK |= 1&lt;&lt;TOIE0; // Timer0 overflow // Ext int 0 MCUCR |= 1&lt;&lt;ISC00; // Any logical change on INT0 generates an interrupt request GIMSK |= 1&lt;&lt;INT0; // External Interrupt Request 0 Enable PORTB |= 1&lt;&lt;PB2; // Input wdt_enable(WDTO_120MS); // Watchdog on sei(); // Interrupts enable while (1) { // Do not use flags or registers wdt_reset(); // Watchdog reset } } /* External Interrupt 0 */ ISR(INT0_vect, ISR_NAKED) { // F_CPU / Timer1 prescaler / F_PWM_IN / grades / 4 #define THRESHOLD (F_CPU / 1 / F_PWM_IN / 100 / 4) uint16_t time; uint8_t time_l = TCNT0; if ((TIFR &amp; 1&lt;&lt;TOV0) &amp;&amp; (time_l &lt;= UCHAR_MAX/2)) { // Overflow occured right now time_l = UCHAR_MAX; // 0xff } time = (time_h &lt;&lt; 8) + time_l; if (PINB &amp; 1&lt;&lt;PB2) { // Risen if (abs(time - time_cycle) &gt; THRESHOLD) { time_cycle = time; OCR1C = time_h; } TCNT0 = 0; time_h = 0; if (TIFR &amp; 1&lt;&lt;TOV0) { TIFR = 1&lt;&lt;TOV0; // Clear Timer0 overflow flag } } else { // Falled if (abs(time - time_on) &gt; THRESHOLD) { time_on = time; OCR1A = time_h; } } reti(); // Because ISR_NAKED } /* Timer/Counter0 Overflow */ ISR(TIM0_OVF_vect, ISR_NAKED) { #define TIME_H_LIM (UCHAR_MAX-1) if (time_h &lt; TIME_H_LIM) { // Normal way time_h += 1; } else { // High part overflowed if (PINB &amp; 1&lt;&lt;PB2) { OCR1A = TIME_H_LIM; // Always on } else { OCR1A = 0; // Always off } OCR1C = TIME_H_LIM; time_h = 0; time_cycle = 0; time_on = 0; } reti(); // Because ISR_NAKED }</span></span></span></span></code> </pre><br></div></div><br>  Vous pouvez l'appeler autosuggestion, mais le résultat est le suivant: la vie est devenue meilleure, la vie est devenue plus amusante!  Même les projets de longue haleine ont évolué. <br><br>  Si dans votre cas, la fréquence du rétroéclairage n'affecte en rien votre bien-être et votre productivité - considérez-vous chanceux.  Probablement.  Ainsi que les personnes qui assurent un confort absolu lorsque la teneur en CO <sub>2</sub> de la pièce est supérieure à 0,2% (2000 <abbr title="Millionième ppm">ppm</abbr> ). <br><br><div class="spoiler">  <b class="spoiler_title">Mais qu'en est-il du lien vers github?</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La voici</a> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448730/">https://habr.com/ru/post/fr448730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448714/index.html">Slack - un thème sombre non officiel pour la version de bureau de Windows, Linux, MacOS</a></li>
<li><a href="../fr448718/index.html">Création d'un treillis métallique dans SPDS</a></li>
<li><a href="../fr448724/index.html">News de la semaine: le FSB n'est pas un décret pour les opérateurs, l'IA bat les champions, Apple et Qualcomm se réconcilient</a></li>
<li><a href="../fr448726/index.html">Affaire. De 0 à 81% de sémantique en TOP en 2 jours</a></li>
<li><a href="../fr448728/index.html">Après quelques décennies, le cerveau sera connecté à Internet</a></li>
<li><a href="../fr448732/index.html">Hernie intervertébrale? Travailler sur elle</a></li>
<li><a href="../fr448734/index.html">Des drones et des robots aident à sauver la cathédrale Notre-Dame de Paris</a></li>
<li><a href="../fr448738/index.html">Qui chasse les startups?</a></li>
<li><a href="../fr448740/index.html">Nous écoutons de la musique SID (Commodore 64) via OPL3 sur des PC modernes</a></li>
<li><a href="../fr448742/index.html">Pandora's Box: nous analysons l'exploitation de la vulnérabilité WinRAR à l'aide de l'exemple du job NeoQUEST-2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>