<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤ğŸ¾ â‡ï¸ ğŸ£ FP vs OOP ğŸ—‘ï¸ ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘©ğŸ¼ ğŸ‘¨ğŸ½â€ğŸ”¬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Belum lama ini, beberapa posting muncul di hub yang kontras dengan pendekatan fungsional dan objek, yang menghasilkan komentar diskusi hangat tentang ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FP vs OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474518/"><p>  Belum lama ini, beberapa posting muncul di hub yang kontras dengan pendekatan fungsional dan objek, yang menghasilkan komentar diskusi hangat tentang apa itu sebenarnya - pemrograman berorientasi objek dan bagaimana hal itu berbeda dari fungsional.  Saya, walaupun dengan beberapa penundaan, ingin berbagi dengan yang lain apa yang Robert Martin, juga dikenal sebagai Paman Bob, tentang hal ini. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/cf/hd/udcfhd13y7i2zdqhnhtotltstyg.jpeg"></div><a name="habracut"></a><br><p>  Selama beberapa tahun terakhir, saya telah berulang kali dapat memprogram bersama orang-orang yang mempelajari Pemrograman Fungsional, yang bias tentang OOP.  Ini biasanya diungkapkan dalam bentuk pernyataan seperti: "Yah, ini terlalu mirip objek sesuatu." </p><br><p>  Saya pikir ini berasal dari keyakinan bahwa FP dan OOP saling eksklusif.  Banyak yang berpikir bahwa jika program itu fungsional, maka itu tidak berorientasi objek.  Saya percaya bahwa pembentukan pendapat semacam itu adalah konsekuensi logis dari studi tentang sesuatu yang baru. </p><br><p>  Ketika kita mengambil teknik baru, kita sering mulai menghindari teknik-teknik lama yang kita gunakan sebelumnya.  Ini wajar, karena kami percaya bahwa teknik baru itu "lebih baik" dan karena itu teknik lama mungkin "lebih buruk". </p><br><p>  Dalam posting ini, saya dibenarkan dalam pandangan bahwa sementara OOP dan FP adalah ortogonal, ini bukan konsep yang saling eksklusif.  Bahwa program fungsional yang baik dapat (dan harus) berorientasi objek.  Dan program berorientasi objek yang baik dapat (dan seharusnya) berfungsi.  Tetapi untuk melakukan ini, kita harus menentukan persyaratannya. </p><br><h2 id="chto-takoe-oop">  Apa itu OOP? </h2><br><p>  Saya akan mendekati masalah ini dari perspektif reduksionis.  Ada banyak definisi OOP yang benar yang mencakup banyak konsep, prinsip, teknik, pola, dan filosofi.  Saya bermaksud mengabaikannya dan fokus pada garam itu sendiri.  Di sini, reduksionisme diperlukan karena semua kekayaan peluang yang mengelilingi OOP ini bukanlah sesuatu yang spesifik untuk OOP;  itu hanya sebagian dari banyak peluang yang ditemukan dalam pengembangan perangkat lunak secara umum.  Di sini saya akan fokus pada bagian OOP, yang mendefinisikan dan tidak dapat dilepas. </p><br><p>  Lihatlah dua ungkapan: </p><br><p>  1: f (o);  2: dari (); </p><br><p>  Apa bedanya? </p><br><p>  Jelas tidak ada perbedaan semantik.  Seluruh perbedaan sepenuhnya ada dalam sintaksis.  Tapi yang satu terlihat prosedural, dan yang lain berorientasi objek.  Ini karena kita terbiasa dengan fakta bahwa ungkapan 2 secara implisit menyiratkan semantik perilaku khusus yang tidak dimiliki oleh ekspresi 1. Semantik perilaku khusus ini adalah polimorfisme. </p><br><p>  Ketika kita melihat ekspresi 1. kita melihat fungsi <strong>f</strong> , yang dipanggil ke mana objek <strong>o</strong> ditransfer.  Ini menyiratkan bahwa hanya ada satu fungsi bernama f, dan bukan fakta bahwa itu adalah anggota dari kohort standar fungsi di sekitar o. </p><br><p>  Di sisi lain, ketika kita melihat ekspresi 2. kita melihat sebuah objek dengan nama <strong>o di</strong> mana pesan dengan nama <strong>f</strong> dikirim.  Kami berharap bahwa mungkin ada jenis objek lain yang menerima pesan f, dan oleh karena itu kami tidak tahu perilaku spesifik apa yang diharapkan dari f setelah panggilan.  Perilaku tergantung pada tipe o.  yaitu, f adalah polimorfik. </p><br><p>  Fakta ini yang kita harapkan dari metode perilaku polimorfik adalah inti dari pemrograman berorientasi objek.  Ini adalah definisi reduksionis dan properti ini tidak dapat dihapus dari OOP.  OOP tanpa polimorfisme bukanlah OOP.  Semua properti OOP lainnya, seperti enkapsulasi data dan metode yang dilampirkan pada data ini dan bahkan pewarisan, lebih terkait dengan ekspresi 1. daripada ekspresi 2. </p><br><p>  Pemrogram yang menggunakan C dan Pascal (dan sampai batas tertentu bahkan Fortran dan Cobol) selalu menciptakan sistem fungsi dan struktur yang dienkapsulasi.  Untuk membuat struktur seperti itu, Anda bahkan tidak memerlukan bahasa pemrograman berorientasi objek.  Enkapsulasi dan bahkan pewarisan sederhana dalam bahasa-bahasa semacam itu jelas dan alami.  (Dalam C dan Pascal lebih alami daripada yang lain) </p><br><p>  Karena itu, yang benar-benar membedakan program OOP dari program non-OOP adalah polimorfisme. </p><br><p>  Anda mungkin ingin berdebat bahwa poliforisme dapat dilakukan hanya dengan menggunakan di dalam saklar f atau panjang jika rantai lain.  Ini benar, jadi saya perlu menetapkan batasan lain untuk OOP. </p><br><p>  Penggunaan polimorfisme seharusnya tidak menciptakan ketergantungan pemanggil pada yang dipanggil. </p><br><p>  Untuk menjelaskan ini, mari kita lihat kembali ekspresi.  Ekspresi 1: f (o) tampaknya bergantung pada fungsi f pada level kode sumber.  Kami menarik kesimpulan ini karena kami juga berasumsi bahwa f hanya satu dan karena itu penelepon harus tahu tentang callee. </p><br><p>  Namun, ketika kita melihat Ekspresi 2. dari () kita mengasumsikan sesuatu yang lain.  Kita tahu bahwa mungkin ada banyak realisasi dari f dan kita tidak tahu mana dari fungsi-fungsi ini yang akan dipanggil.  Oleh karena itu, kode sumber yang mengandung ekspresi 2 tidak tergantung pada fungsi yang dipanggil pada tingkat kode sumber. </p><br><p>  Lebih khusus lagi, ini berarti bahwa modul (file dengan kode sumber) yang berisi panggilan fungsi polimorfik tidak boleh merujuk ke modul (file dengan kode sumber) yang berisi implementasi fungsi-fungsi ini.  Tidak boleh ada <strong>menyertakan</strong> atau <strong>menggunakan</strong> atau <strong>mengharuskan</strong> atau kata kunci lain yang membuat beberapa file kode sumber bergantung pada orang lain. </p><br><p>  Jadi, definisi reduksionis kami tentang OOP adalah: </p><br><blockquote>  Teknik yang menggunakan polimorfisme dinamis untuk memanggil fungsi dan tidak membuat dependensi pemanggil pada panggilan di level kode sumber. </blockquote><br><h2 id="chto-takoe-fp">  Apa itu AF? </h2><br><p>  Dan lagi, saya akan menggunakan pendekatan reduksionis.  FP memiliki tradisi dan sejarah yang kaya, yang akarnya lebih dalam dari pemrograman itu sendiri.  Ada prinsip, teknik, teorema, filosofi, dan konsep yang menembus paradigma ini.  Saya akan mengabaikan semua ini dan langsung ke esensi, ke properti yang melekat yang memisahkan FP dari gaya lain.  Ini dia: </p><br><p>  f (a) == f (b) jika a == b. </p><br><p>  Dalam program fungsional, memanggil fungsi dengan argumen yang sama memberikan hasil yang sama tidak peduli berapa lama program telah berjalan.  Ini kadang-kadang disebut transparansi referensial. </p><br><p>  Oleh karena itu di atas bahwa f tidak boleh mengubah bagian-bagian dari negara global yang memengaruhi perilaku f.  Selain itu, jika kita mengatakan bahwa f mewakili semua fungsi dalam sistem - yaitu, semua fungsi dalam sistem harus transparan secara referensi - maka tidak ada fungsi dalam sistem yang dapat mengubah keadaan global.  Tidak ada fungsi yang dapat melakukan apa pun yang dapat menyebabkan fungsi lain dari sistem mengembalikan nilai yang berbeda dengan argumen yang sama. </p><br><p>  Ini memiliki konsekuensi yang lebih dalam - tidak ada nilai yang dapat diubah.  Artinya, tidak ada operator penugasan. </p><br><p>  Jika Anda dengan hati-hati mempertimbangkan pernyataan ini, Anda dapat sampai pada kesimpulan bahwa suatu program yang hanya terdiri dari fungsi-fungsi transparan yang transparan tidak dapat berbuat apa-apa - karena perilaku sistem yang berguna mengubah keadaan sesuatu;  bahkan jika itu hanya keadaan printer atau layar.  Namun, jika kita mengecualikan besi dari persyaratan untuk transparansi referensial dan semua elemen dunia di sekitar kita, ternyata kita dapat membuat sistem yang sangat berguna. </p><br><p>  Fokusnya, tentu saja, adalah rekursi.  Pertimbangkan fungsi yang mengambil struktur dengan status sebagai argumen.  Argumen ini terdiri dari semua informasi status yang harus berfungsi.  Ketika pekerjaan selesai, fungsi menciptakan struktur baru dengan keadaan yang isinya berbeda dari yang sebelumnya.  Dan dengan tindakan terakhir, fungsi menyebut dirinya dengan struktur baru sebagai argumen. </p><br><p>  Ini hanyalah salah satu trik sederhana yang dapat digunakan program fungsional untuk menyimpan perubahan status tanpa harus mengubah status [1]. </p><br><p>  Jadi, definisi reduksionis dari pemrograman fungsional: </p><br><blockquote>  Transparansi Referensial - Anda tidak dapat menetapkan kembali nilai. </blockquote><br><h2 id="fp-protiv-oop">  FP vs OOP </h2><br><p>  Pada titik ini, baik pendukung OOP dan pendukung FI sudah melihat saya melalui pemandangan optik.  Reduksionisme bukanlah cara terbaik untuk berteman.  Tapi terkadang itu bermanfaat.  Dalam hal ini, saya pikir berguna untuk menjelaskan holivar anti-OOP yang tidak memudar. </p><br><p>  Jelas bahwa dua definisi reduksionis yang saya pilih sepenuhnya ortogonal.  Polimorfisme dan Transparansi Referensial tidak ada hubungannya satu sama lain.  Mereka tidak berpotongan dengan cara apa pun. </p><br><p>  Tetapi ortogonalitas tidak menyiratkan saling pengecualian (tanya James Clerk Maxwell).  Sangat mungkin untuk membuat sistem yang menggunakan polimorfisme dinamis dan transparansi referensial.  Itu tidak hanya mungkin, itu benar dan baik! </p><br><p>  Mengapa kombinasi ini baik?  Untuk alasan yang persis sama bahwa kedua komponennya!  Sistem yang dibangun di atas polimorfisme dinamis adalah baik karena mereka memiliki konektivitas rendah.  Ketergantungan dapat dibalik dan ditempatkan pada sisi yang berbeda dari batas arsitektur.  Sistem ini dapat diuji menggunakan Moki dan Palsu dan jenis Uji Ganda lainnya.  Modul dapat dimodifikasi tanpa membuat perubahan ke modul lain.  Karena itu, sistem seperti itu lebih mudah untuk dimodifikasi dan diperbaiki. </p><br><p>  Sistem yang dibangun berdasarkan transparansi referensial juga bagus karena dapat diprediksi.  Keadaan tidak berubah membuat sistem seperti itu lebih mudah untuk dipahami, diubah, dan ditingkatkan.  Ini sangat mengurangi kemungkinan ras dan masalah multithreading lainnya. </p><br><p>  Ide utama di sini adalah ini: </p><br><blockquote>  Tidak ada FP dan OOP holivar </blockquote><p>  FP dan OOP bekerja sama dengan baik.  Keduanya baik dan layak digunakan dalam sistem modern.  Sistem, yang didasarkan pada kombinasi prinsip-prinsip OOP dan FP memaksimalkan fleksibilitas, rawatan, pengujian, kesederhanaan dan kekuatan.  Jika Anda menghapus satu untuk menambahkan yang lain, itu hanya akan memperburuk struktur sistem. </p><br><p>  [1] Karena kami menggunakan mesin dengan arsitektur Von Neumann, kami menganggap bahwa mereka memiliki sel memori yang kondisinya benar-benar berubah.  Dalam mekanisme rekursi yang saya jelaskan, optimasi rekursi ekor tidak akan memungkinkan pembuatan bingkai kaca baru dan bingkai kaca asli akan digunakan.  Tetapi pelanggaran transparansi referensial ini (biasanya) disembunyikan dari programmer dan tidak memengaruhi apa pun. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474518/">https://habr.com/ru/post/id474518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474502/index.html">Odnoklassniki parsing di Joker 2019</a></li>
<li><a href="../id474504/index.html">Backend Ortodoks</a></li>
<li><a href="../id474508/index.html">Pencapaian bioprinting 3D cangkok kulit</a></li>
<li><a href="../id474514/index.html">Bagaimana para pengusaha pertambangan Bitcoin Tiongkok bertahan</a></li>
<li><a href="../id474516/index.html">Aplikasi suara: pasar ke-milyar yang tidak diperhatikan Rusia</a></li>
<li><a href="../id474522/index.html">Cerita mutt</a></li>
<li><a href="../id474526/index.html">Webinar Hewlett Packard Enterprise pada bulan November-Januari</a></li>
<li><a href="../id474528/index.html">Buku "Komputasi kuantum untuk profesional TI sejati"</a></li>
<li><a href="../id474532/index.html">Laboratorium radio Nizhny Novgorod dan radio dengan detektor kristal</a></li>
<li><a href="../id474534/index.html">Buku Alan Turing dan Catatan Misterius - Detektif Sains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>