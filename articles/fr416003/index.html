<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶🏻 👨🏿 👷 Rendu de fichier HTML: un chapitre du livre ReactPHP for Beginners de Skyeng 👩‍👧‍👧 🙉 🧙🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le développeur du backend de l'application mobile Skyeng, Sergey Zhuk, continue d'écrire de bons livres. Cette fois, il a publié un manuel en russe po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendu de fichier HTML: un chapitre du livre ReactPHP for Beginners de Skyeng</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/416003/"><p><img src="https://habrastorage.org/webt/6v/oi/xx/6voixx5vd9au0asabvgmnckfj90.png"></p><br><p>  Le développeur du backend de l'application mobile Skyeng, Sergey Zhuk, continue d'écrire de bons livres.  Cette fois, il a publié un manuel en russe pour un public maîtrisant PHP.  J'ai demandé à Sergey de partager un chapitre utile et autosuffisant de son livre, et de donner aux lecteurs Habra un code de réduction.  Ci-dessous, les deux. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Tout d'abord, disons ce que nous avons arrêté dans les chapitres précédents.</b> <div class="spoiler_text"><p> Nous avons écrit notre simple serveur HTTP en PHP.  Nous avons le fichier <code>index.php</code> principal - le script qui démarre le serveur.  Voici le code de plus haut niveau: nous créons une boucle d'événements, configurons le comportement du serveur HTTP et démarrons la boucle: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Server</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; $loop = React\EventLoop\Factory::create(); $router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); $router-&gt;load(<span class="hljs-string"><span class="hljs-string">'routes.php'</span></span>); $server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Server( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($router)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $router($request); } ); $socket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> React\Socket\Server(<span class="hljs-number"><span class="hljs-number">8080</span></span>, $loop); $server-&gt;listen($socket); $loop-&gt;run();</code> </pre> <br><p>  Pour acheminer les demandes, le serveur utilise un routeur: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// src/Router.php use Psr\Http\Message\ServerRequestInterface; use React\Http\Response; class Router { private $routes = []; public function __invoke(ServerRequestInterface $request) { $path = $request-&gt;getUri()-&gt;getPath(); echo "Request for: $path\n"; $handler = $this-&gt;routes[$path] ?? $this-&gt;notFound($path); return $handler($request); } public function load($filename) { $routes = require $filename; foreach ($routes as $path =&gt; $handler) { $this-&gt;add($path, $handler); } } public function add($path, callable $handler) { $this-&gt;routes[$path] = $handler; } private function notFound($path) { return function () use ($path) { return new Response( 404, ['Content-Type' =&gt; 'text/html; charset=UTF-8'], "No request handler found for $path" ); }; } }</span></span></code> </pre> <br><p>  Les routes du fichier <code>routes.php</code> sont chargées dans le <code>routes.php</code> .  Maintenant, seuls deux itinéraires ont été annoncés ici: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Response</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'/'</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">'Main page'</span></span> ); }, <span class="hljs-string"><span class="hljs-string">'/upload'</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">'Upload page'</span></span> ); }, ];</code> </pre> <br><p>  Jusqu'à présent, tout est simple, et notre application asynchrone tient dans plusieurs fichiers. </p></div></div><br><p>  Nous passons à des choses plus «utiles».  Les réponses de quelques mots d'un texte simple que nous avons appris à tirer dans les chapitres précédents ne semblent pas très attrayantes.  Nous devons renvoyer quelque chose de réel, comme une page HTML. </p><br><p>  Alors, où mettons-nous ce HTML?  Bien sûr, vous pouvez coder en dur le contenu de la page Web directement dans le fichier routes: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php return [ '/' =&gt; function (ServerRequestInterface $request) { $html = &lt;&lt;&lt;HTML &lt;!DOCTYPE html&gt; &lt;html lang=”en”&gt; &lt;head&gt; &lt;meta charset=”UTF-8”&gt; &lt;title&gt;ReactPHP App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello, world &lt;/body&gt; &lt;/html&gt; HTML; return new Response( 200, ['Content-Type' =&gt; 'text/html'], $html ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Mais ne fais pas ça!  Vous ne pouvez pas mélanger la logique métier (routage) avec la présentation (page HTML).  Pourquoi?  Imaginez que vous devez changer quelque chose dans le code HTML, par exemple, la couleur du bouton.  Et quel fichier devra être changé?  Fichier avec routes <code>router.php</code> ?  Ça a l'air bizarre, non?  Modifiez le routage pour modifier la couleur du bouton ... </p><br><p>  Par conséquent, nous laisserons les routes seules et pour les pages HTML, nous créerons un répertoire séparé.  À la racine du projet, ajoutez un nouveau répertoire appelé pages.  Ensuite, à l'intérieur, nous créons le fichier <code>index.html</code> .  Ce sera notre page principale.  Voici son contenu: </p><br><pre> <code class="php hljs">&lt;!DOCTYPE html&gt; &lt;html lang=<span class="hljs-string"><span class="hljs-string">"en"</span></span>&gt; &lt;head&gt; &lt;meta charset=<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>&gt; &lt;title&gt;ReactPHP App&lt;/title&gt; &lt;link rel=<span class="hljs-string"><span class="hljs-string">"stylesheet"</span></span> href=<span class="hljs-string"><span class="hljs-string">"https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css"</span></span> &gt; &lt;/head&gt; &lt;body&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">row</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">action</span></span></span><span class="hljs-class">="/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">upload</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">method</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">POST</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">justify</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">content</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">center</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">group</span></span></span><span class="hljs-class">"&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">label</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">"&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Text</span></span></span><span class="hljs-class">&lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">label</span></span></span><span class="hljs-class">&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">textarea</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">control</span></span></span><span class="hljs-class">"&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class">&gt; &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">button</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">submit</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">="</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">btn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">btn</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">primary</span></span></span><span class="hljs-class">"&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Submit</span></span></span><span class="hljs-class">&lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">button</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">form</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">div</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">body</span></span></span><span class="hljs-class">&gt; &lt;/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">html</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br><p>  La page est assez simple, elle ne contient qu'un seul élément - le formulaire.  Le formulaire à l'intérieur a une zone de texte et un bouton pour soumettre.  J'ai également ajouté des styles Bootstrap pour rendre notre page plus belle. </p><br><h4 id="chtenie-faylov-kak-ne-nado-delat">  Lecture de fichiers.  Comment NE PAS faire </h4><br><p>  L'approche la plus simple consiste à lire le contenu du fichier à l'intérieur du gestionnaire de demande et à renvoyer ce contenu en tant que corps de réponse.  Quelque chose comme ça: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php return [ '/' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, // ... ];</span></span></code> </pre> <br><p>  Et en passant, cela fonctionnera.  Vous pouvez l'essayer vous-même: redémarrez le serveur et rechargez la page <code>http://127.0.0.1:8080/</code> dans votre navigateur. </p><br><p><img src="https://habrastorage.org/webt/zq/dc/91/zqdc91cvy7a971jkniyw8hpxgzi.png"></p><br><p>  Alors qu'est-ce qui ne va pas ici?  Et pourquoi ne pas faire ça?  En bref, car il y aura des problèmes si le système de fichiers commence à ralentir. </p><br><h4 id="blokiruyuschie-i-neblokiruyuschie-vyzovy">  Appels bloquants et non bloquants </h4><br><p>  Permettez-moi de vous montrer ce que j'entends par «bloquer» les appels et ce qui peut se produire lorsque l'un des gestionnaires de demandes contient du code de blocage.  Avant de renvoyer l'objet de réponse, ajoutez un appel à la fonction <code>sleep()</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php return [ '/' =&gt; function (ServerRequestInterface $request) { sleep(10); return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Cela fera geler le gestionnaire de requêtes pendant 10 secondes avant de pouvoir renvoyer une réponse avec le contenu de la page HTML.  Veuillez noter que nous n'avons pas touché le gestionnaire pour l'adresse <code>/upload</code> .  En appelant la fonction <code>sleep(10)</code> , j'émule l'exécution d'une sorte d'opération de blocage. </p><br><p>  Alors qu'avons-nous?  Lorsque le navigateur demande la page <code>/</code> , le gestionnaire attend 10 secondes, puis renvoie la page HTML.  Lorsque nous ouvrons l'adresse <code>/upload</code> , son gestionnaire doit immédiatement renvoyer une réponse avec la chaîne 'Upload page'. </p><br><p>  Voyons maintenant ce qui se passe dans la réalité.  Comme toujours, nous redémarrons le serveur.  Maintenant, veuillez ouvrir une autre fenêtre dans votre navigateur.  Dans la barre d'adresse, entrez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://127.0.0.1:8080/upload</a> , mais n'ouvrez pas cette page immédiatement.  Laissez cette adresse dans la barre d'adresse pour l'instant.  Ensuite, allez dans la première fenêtre du navigateur et ouvrez la page <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://127.0.0.1:8080/</a> .  Pendant le chargement de cette page (rappelez-vous que cela prendra 10 secondes), accédez rapidement à la deuxième fenêtre et appuyez sur «Entrée» pour charger l'adresse qui a été laissée dans la barre d'adresse ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://127.0.0.1:8080/upload</a> ) . </p><br><p>  Qu'avons-nous obtenu?  Oui, l'adresse /, comme prévu, prend 10 secondes à charger.  Mais, étonnamment, la deuxième page a pris le même temps à charger, bien que nous n'y ayons ajouté aucun appel <code>sleep()</code> .  Une idée de pourquoi c'est arrivé? </p><br><p>  ReactPHP s'exécute dans un seul thread.  Il peut sembler que dans une application asynchrone, les tâches soient exécutées en parallèle, mais en réalité ce n'est pas le cas.  L'illusion du parallélisme est créée par un cycle d'événements qui bascule constamment entre diverses tâches et les exécute.  Mais à un certain moment, une seule tâche est toujours effectuée.  Cela signifie que si l'une de ces tâches prend trop de temps, elle bloquera la boucle d'événements, qui ne pourra pas enregistrer de nouveaux événements et appeler des gestionnaires pour eux.  Et cela conduit finalement au «gel» de l'ensemble de l'application, elle perdra tout simplement l'asynchronie. </p><br><p>  OK, mais qu'est-ce que cela a à voir avec l'appel de <code>file_get_contents('pages/index.h')</code> ?  Le problème ici est que nous accédons directement au système de fichiers.  Par rapport à d'autres opérations, telles que l'utilisation de la mémoire ou de l'informatique, l'utilisation du système de fichiers peut être extrêmement lente.  Par exemple, si le fichier s'avère trop volumineux ou si le disque lui-même est lent, la lecture du fichier peut prendre un certain temps et, par conséquent, bloquer la boucle d'événements. </p><br><p>  Dans le modèle synchrone standard, la demande-réponse n'est pas un problème.  Si le client a demandé un fichier trop lourd, il attendra que ce fichier soit téléchargé.  Une telle demande lourde n'affecte pas les autres clients.  Mais dans notre cas, nous avons affaire à un modèle orienté événement asynchrone.  Nous avons lancé un serveur HTTP qui doit constamment traiter les demandes entrantes.  Si une demande prend trop de temps, cela affectera tous les autres clients du serveur. </p><br><p>  En règle générale, n'oubliez pas: </p><br><ul><li>  Vous ne pouvez jamais bloquer une boucle d'événements. </li></ul><br><p>  Alors, comment lisons-nous le fichier de manière asynchrone?  Et nous arrivons ici à la deuxième règle: </p><br><ul><li>  Lorsqu'une opération de blocage ne peut être évitée, elle doit être bifurquée dans le processus enfant et continuer l'exécution asynchrone dans le thread principal. </li></ul><br><p>  Donc, après avoir appris comment ne pas le faire, discutons de la bonne solution non bloquante. </p><br><h4 id="docherniy-process">  Processus enfant </h4><br><p>  Toutes les communications avec le système de fichiers dans une application asynchrone doivent être effectuées dans des processus enfants.  Pour gérer les processus enfants dans une application ReactPHP, nous devons installer un autre composant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Processus enfant»</a> .  Ce composant vous permet d'accéder aux fonctions du système d'exploitation pour exécuter n'importe quelle commande système à l'intérieur du processus enfant.  Pour installer ce composant, ouvrez un terminal à la racine du projet et exécutez la commande suivante: </p><br><p> <code>composer require react/child-process</code> </p> <br><h4 id="sovmestimost-s-windows">  <em>Compatibilité Windows</em> </h4><br><p>  <em>Dans le système d'exploitation Windows, les threads STDIN, STDOUT et STDERR se bloquent, ce qui signifie que le composant Processus enfant ne pourra pas fonctionner correctement.</em>  <em>Par conséquent, ce composant est principalement conçu pour fonctionner uniquement sur les systèmes nix.</em>  <em>Si vous essayez de créer un objet de la classe Process sur un système Windows, une exception sera levée.</em>  <em>Mais le composant peut fonctionner sous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Windows Subsystem for Linux (WSL)</a> .</em>  <em>Si vous avez l'intention d'utiliser ce composant sous Windows, vous devrez installer WSL.</em> </p><br><p>  Nous pouvons maintenant exécuter n'importe quelle commande shell à l'intérieur du processus enfant.  Ouvrez le fichier <code>routes.php</code> , puis changeons le gestionnaire pour <code>/</code> route.  Créez un objet de la classe <code>React\ChildProcess\Process</code> et en tant que commande, passez-lui <code>ls</code> pour obtenir le contenu du répertoire courant: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php use Psr\Http\Message\ServerRequestInterface; use React\ChildProcess\Process; use React\Http\Response; return [ '/' =&gt; function (ServerRequestInterface $request) { $childProcess = new Process('ls'); return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, // ... ];</span></span></code> </pre> <br><p>  Ensuite, nous devons démarrer le processus en appelant la méthode <code>start()</code> .  Le hic est que la méthode <code>start()</code> besoin d'un objet de boucle d'événement.  Mais dans le fichier <code>routes.php</code> , nous n'avons pas cet objet.  Comment passer la boucle d'événements de <code>index.php</code> aux routes directement au gestionnaire de requêtes?  La solution à ce problème est «l'injection de dépendance». </p><br><h4 id="inekciya-zavisimostey">  Injection de dépendance </h4><br><p>  Ainsi, l'un de nos itinéraires a besoin d'une boucle d'événements pour fonctionner.  Dans notre application, un seul composant connaît l'existence des routes - la classe <code>Router</code> .  Il s'avère qu'il est de sa responsabilité de fournir une boucle d'événement pour les itinéraires.  En d'autres termes, le routeur a besoin d'une boucle d'événements, ou cela dépend de la boucle d'événements.  Comment exprimer explicitement cette dépendance dans le code?  Comment rendre impossible de créer même un routeur sans lui passer une boucle d'événement?  Bien sûr, via le constructeur de la classe <code>Router</code> .  Ouvrez <code>Router.php</code> et ajoutez le constructeur à la classe <code>Router</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">EventLoop</span></span>\<span class="hljs-title"><span class="hljs-title">LoopInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Response</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Router</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $routes = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> LoopInterface */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $loop; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LoopInterface $loop)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;loop = $loop; } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  À l'intérieur du constructeur, enregistrez la boucle d'événements passée dans la propriété privée <code>$loop</code> .  Il s'agit d'une injection de dépendance lorsque nous fournissons à la classe les objets dont elle a besoin pour travailler à l'extérieur. </p><br><p>  Maintenant que nous avons ce nouveau constructeur, nous devons mettre à jour la création du routeur.  Ouvrez le fichier <code>index.php</code> et corrigez la ligne où nous créons l'objet de la classe <code>Router</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// index.php $loop = React\EventLoop\Factory::create(); $router = new Router($loop); $router-&gt;load('routes.php');</span></span></code> </pre> <br><p>  C'est fait.  Revenez à <code>routes.php</code> .  Comme vous l'avez probablement déjà deviné, ici nous pouvons utiliser la même idée avec l' <strong>injection de dépendances</strong> et ajouter une boucle d'événement comme deuxième paramètre à nos gestionnaires de requêtes.  Modifiez le premier rappel et ajoutez le deuxième argument: un objet qui implémente <code>LoopInterface</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php use Psr\Http\Message\ServerRequestInterface; use React\EventLoop\LoopInterface; use React\ChildProcess\Process; use React\Http\Response; return [ '/' =&gt; function (ServerRequestInterface $request, LoopInterface $loop) { $childProcess = new Process('ls'); $childProcess-&gt;start($loop); return new Response( 200, ['Content-Type' =&gt; 'text/html'], file_get_contents('pages/index.html') ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Ensuite, nous devons passer la boucle d'événements à la méthode <code>start()</code> du processus enfant.  Et où le gestionnaire obtient-il la boucle d'événements?  Et il est déjà stocké à l'intérieur du routeur dans la propriété privée <code>$loop</code> .  Nous avons juste besoin de le passer lorsque le gestionnaire est appelé. </p><br><p>  <code>__invoke()</code> la classe <code>Router</code> et <code>__invoke()</code> jour la méthode <code>__invoke()</code> , en ajoutant le deuxième argument à l'appel du gestionnaire de requêtes: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ $path = $request-&gt;getUri()-&gt;getPath(); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Request for: $path\n"</span></span>; $handler = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;routes[$path] ?? <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;notFound($path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $handler($request, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;loop); }</code> </pre> <br><p>  C'est tout!  C'est probablement une <strong>injection de dépendance</strong> suffisante.  Un assez grand voyage du cycle des événements s'est produit, non?  Du fichier <code>index.php</code> à la classe <code>Router</code> , puis de la classe <code>Router</code> au fichier <code>routes.php</code> à l'intérieur des rappels. </p><br><p>  Donc, pour confirmer que le processus enfant fera sa magie non bloquante, remplaçons la <code>ls</code> simple par le <code>ping 8.8.8.8</code> plus lourd <code>ping 8.8.8.8</code> .  Redémarrez le serveur et essayez à nouveau d'ouvrir deux pages dans deux fenêtres différentes.  D'abord, <code>http://127.0.0.1:8080/</code> , puis <code>/upload</code> .  Les deux pages s'ouvrent rapidement, sans délai, bien que la commande <code>ping</code> soit exécutée dans le premier gestionnaire en arrière-plan.  En passant, cela signifie que nous pouvons débourser toute opération coûteuse (par exemple, le traitement de gros fichiers), sans bloquer l'application principale. </p><br><h4 id="svyazyvaem-docherniy-process-i-otvet-s-pomoschyu-potokov">  Lier le processus enfant et la réponse à l'aide de threads </h4><br><p>  Revenons à notre application.  Nous avons donc créé un processus enfant, l'avons démarré, mais notre navigateur n'affiche en aucune façon les résultats d'une opération bifurquée.  Corrigeons-le. </p><br><p>  Comment pouvons-nous communiquer avec le processus enfant?  Dans notre cas, nous avons une <code>ls</code> cours d'exécution qui affiche le contenu du répertoire courant.  Comment pouvons-nous obtenir cette conclusion, puis l'envoyer au corps de la réponse?  La réponse courte est: les fils. </p><br><p>  Parlons un peu des processus.  Toute commande shell que vous exécutez possède trois flux de données: STDIN, STDOUT et STDERR.  Diffusez vers la sortie et l'entrée standard, plus le flux pour les erreurs.  Par exemple, lorsque nous exécutons la <code>ls</code> , le résultat de cette commande est envoyé directement à STDOUT (sur l'écran du terminal).  Donc, si nous devons obtenir la sortie d'un processus, l'accès au flux de sortie est requis.  Et c'est aussi simple que ça.  Lors de la création de l'objet de réponse, remplacez l'appel <code>file_get_contents()</code> par <code>$childProcess-&gt;stdout</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], $childProcess-&gt;stdout );</code> </pre> <br><p>  Tous les processus enfants ont trois propriétés liées aux flux <code>stdio</code> : <code>stdout</code> , <code>stdin</code> et <code>stderr</code> .  Dans notre cas, nous voulons afficher la sortie du processus sur une page Web.  Au lieu d'une chaîne dans le constructeur de la classe <code>Response</code> , nous passons un flux comme troisième argument.  La classe <code>Response</code> est suffisamment intelligente pour se rendre compte qu'elle a reçu le flux et le traiter en conséquence. </p><br><p>  Donc, comme d'habitude, nous redémarrons le serveur et voyons ce que nous avons fait.  Ouvrons la page <code>http://127.0.0.1:8080/</code> dans le navigateur: vous devriez voir une liste des fichiers du dossier racine du projet. </p><br><p><img src="https://habrastorage.org/webt/mm/ui/za/mmuizadmcw-fzg1cekm0d1jpz3e.png"></p><br><p>  La dernière étape consiste à remplacer la <code>ls</code> par quelque chose de plus utile.  Nous avons commencé ce chapitre en rendant le fichier <code>pages/index.html</code> à l'aide de la fonction <code>file_get_contents()</code> .  Maintenant, nous pouvons lire ce fichier de manière absolument asynchrone, sans craindre qu'il bloque notre application.  Remplacez la <code>ls</code> par <code>cat pages/index.html</code> . </p><br><p>  Si vous n'êtes pas familier avec la <code>cat</code> , elle est utilisée pour concaténer et sortir des fichiers.  Le plus souvent, cette commande est utilisée pour lire un fichier et afficher son contenu sur la sortie standard.  La commande <code>cat pages/index.html</code> lit le fichier <code>cat pages/index.html</code> et imprime son contenu dans STDOUT.  Et nous envoyons déjà <code>stdout</code> comme organe de réponse.  Voici la version finale du fichier <code>routes.php</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// routes.php use Psr\Http\Message\ServerRequestInterface; use React\EventLoop\LoopInterface; use React\ChildProcess\Process; use React\Http\Response; return [ '/' =&gt; function (ServerRequestInterface $request, LoopInterface $loop) { $childProcess = new Process('cat pages/index.html'); $childProcess-&gt;start($loop); return new Response( 200, ['Content-Type' =&gt; 'text/html'], $childProcess-&gt;stdout ); }, '/upload' =&gt; function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Upload page' ); }, ];</span></span></code> </pre> <br><p>  Par conséquent, tout ce code n'était nécessaire que pour remplacer un appel à la fonction <code>file_get_contents()</code> .  Injection de dépendances, passage d'un objet de boucle d'événements, ajout de processus enfants et utilisation de threads.  Tout cela est juste pour remplacer un appel de fonction.  Cela en valait-il la peine?  Réponse: oui, ça valait le coup.  Lorsque quelque chose peut bloquer la boucle d'événements et que le système de fichiers peut certainement, assurez-vous qu'il finira par se bloquer, et au moment le plus inopportun. </p><br><p>  La création d'un processus enfant à chaque fois que nous devons accéder au système de fichiers peut sembler une surcharge supplémentaire qui affectera la vitesse et les performances de notre application.  Malheureusement, en PHP, il n'y a pas d'autre moyen de travailler de manière asynchrone avec le système de fichiers.  Toutes les bibliothèques PHP asynchrones utilisent des processus enfants (ou des extensions qui les font abstraction). </p><br><p>  Les lecteurs Habra peuvent acheter l'intégralité du livre à prix réduit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur ce lien</a> . </p><br><p>  Et nous vous rappelons que nous sommes toujours à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recherche de développeurs sympas</a> !  Venez, nous nous amusons! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416003/">https://habr.com/ru/post/fr416003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415993/index.html">Remot, farine impitoyable</a></li>
<li><a href="../fr415995/index.html">Développement de CROC de l'intérieur: personnes, canards et beaucoup de travail</a></li>
<li><a href="../fr415997/index.html">Logiciel d'apprentissage automatique Python</a></li>
<li><a href="../fr415999/index.html">Qu'est-ce que la bourse Apple et pourquoi est-ce plus qu'un simple ticket WWDC</a></li>
<li><a href="../fr416001/index.html">Messages d'un site en VK - simple et efficace - PHP + CUrl</a></li>
<li><a href="../fr416005/index.html">16 React Tools pour les développeurs d'interfaces</a></li>
<li><a href="../fr416007/index.html">À peu près compliqué. Le début de la création d'une "maison intelligente" sans fil. Basé sur la technologie Linux, les logiciels Z-Wave et MajorDoMo</a></li>
<li><a href="../fr416009/index.html">Essayez les excréments de lapin, c'est vigoureux, ça va attraper - extraits en pharmacologie</a></li>
<li><a href="../fr416011/index.html">Modèle BIF: code frontal propre et travail pratique avec les données du serveur</a></li>
<li><a href="../fr416013/index.html">Comment commencer à investir et économiser de l'argent: les experts de Dow Jones ont nommé les cinq principales erreurs des traders débutants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>