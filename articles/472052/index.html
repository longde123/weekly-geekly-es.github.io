<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïØÔ∏è üë©üèΩ‚Äçüîß üëÇüèª Dise√±o orientado a datos (o por qu√©, usando OOP, probablemente te dispares en el pie) üë¥üèΩ üë©üèΩ‚Äç‚úàÔ∏è üë®üèª‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagina esta imagen: se acerca el final del ciclo de desarrollo, tu juego apenas se arrastra, pero en el generador de perfiles no puedes encontrar √°re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dise√±o orientado a datos (o por qu√©, usando OOP, probablemente te dispares en el pie)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472052/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f8/5ea/960/4f85ea960a2c233300fd62f394a5b213.png" alt="imagen"></div><br>  Imagina esta imagen: se acerca el final del ciclo de desarrollo, tu juego apenas se arrastra, pero en el generador de perfiles no puedes encontrar √°reas problem√°ticas obvias.  ¬øQui√©n tiene la culpa?  Patrones de memoria de acceso aleatorio y errores persistentes de cach√©.  Intentando mejorar el rendimiento, intenta paralelizar partes del c√≥digo, pero vale la pena los esfuerzos heroicos, y al final, debido a toda la sincronizaci√≥n que tuvo que agregarse, la aceleraci√≥n apenas se nota.  Adem√°s, el c√≥digo es tan complicado que corregir errores causa a√∫n m√°s problemas, y la idea de agregar nuevas caracter√≠sticas se descarta de inmediato.  ¬øTe suena familiar? <br><br>  Tal desarrollo de eventos describe con precisi√≥n casi todos los juegos en los que particip√© durante los √∫ltimos diez a√±os.  Las razones no est√°n en los lenguajes de programaci√≥n o las herramientas de desarrollo, o incluso la falta de disciplina.  En mi experiencia, en gran medida, se debe culpar a la programaci√≥n orientada a objetos (OOP) y su cultura circundante.  ¬°OOP puede no ayudar, pero interferir con sus proyectos! <br><a name="habracut"></a><br><h2>  Se trata de datos </h2><br>  OOP ha penetrado tanto en la cultura existente del desarrollo de videojuegos que cuando piensas en un juego, es dif√≠cil imaginar algo m√°s que objetos.  Durante muchos a√±os, hemos estado creando clases para autom√≥viles, jugadores y m√°quinas estatales.  Cuales son las alternativas?  Programaci√≥n procesal?  Lenguajes funcionales?  Lenguajes de programaci√≥n ex√≥ticos? <br><br>  El dise√±o orientado a datos es otra forma de dise√±ar software dise√±ado para resolver todos estos problemas.  El elemento principal de la programaci√≥n de procedimientos son las llamadas a procedimientos, y OOP trata principalmente con objetos.  Tenga en cuenta que en ambos casos el c√≥digo se coloca en el centro: en un caso, se trata de procedimientos (o funciones) ordinarios, en el otro, c√≥digo agrupado asociado con un determinado estado interno.  El dise√±o orientado a datos cambia el foco de atenci√≥n de los objetos a los datos en s√≠: el tipo de datos, su ubicaci√≥n en la memoria, los m√©todos para leerlos y procesarlos en el juego. <br><br>  La programaci√≥n por definici√≥n es una forma de convertir datos: el acto de crear una secuencia de instrucciones de m√°quina que describen el proceso de procesamiento de datos de entrada y creaci√≥n de datos de salida.  Un juego no es m√°s que un programa interactivo, as√≠ que ¬øno ser√≠a m√°s l√≥gico concentrarse principalmente en los datos y no en el c√≥digo que los procesa? <br><br>  Para no confundirlo, explicar√© de inmediato: el dise√±o orientado a datos no significa que el programa est√© basado en datos.  Un juego basado en datos suele ser un juego cuya funcionalidad est√° en gran medida fuera del c√≥digo;  Permite que los datos determinen el comportamiento del juego.  Este concepto es independiente del dise√±o orientado a datos y puede usarse en cualquier m√©todo de programaci√≥n. <br><br><h2>  Datos perfectos </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/100/4e9/bb7/1004e9bb72c374929c1b914a344c43b9.png" alt="Secuencia de llamadas con un enfoque orientado a objetos" width="229" height="247"></div><br>  <i>Figura 1a.</i>  <i>Secuencia de llamada con un enfoque orientado a objetos</i> <br><br>  Si miramos el programa en t√©rminos de datos, ¬øc√≥mo ser√°n los datos ideales?  Depende de los datos en s√≠ y de c√≥mo usarlos.  En general, los datos ideales est√°n en un formato que puede usarse con un m√≠nimo esfuerzo.  En el mejor de los casos, el formato coincidir√° completamente con el resultado de salida esperado, es decir, el procesamiento consiste solo en copiar los datos.  Muy a menudo, un esquema de datos ideal se ve como grandes bloques de datos homog√©neos adyacentes que pueden procesarse secuencialmente.  Sea como fuere, el objetivo es minimizar el n√∫mero de transformaciones;  si es posible, "hornee" los datos en este formato ideal de antemano, en la etapa de creaci√≥n de recursos del juego. <br><br>  Dado que el dise√±o orientado a datos pone los datos primero, podemos crear la arquitectura de un programa completo en torno a un formato de datos ideal.  No siempre lograremos que sea completamente perfecto (as√≠ como el c√≥digo rara vez se parece a OOP de un libro de texto), pero este es nuestro objetivo principal, que siempre recordamos.  Cuando lo logramos, la mayor√≠a de los problemas mencionados al principio del art√≠culo simplemente se disuelven (m√°s en esta pr√≥xima secci√≥n). <br><br>  Cuando pensamos en objetos, recordamos inmediatamente los √°rboles: √°rboles de herencia, √°rboles de anidaci√≥n o √°rboles de mensajes, y nuestros datos se ordenan naturalmente de esta manera.  Por lo tanto, cuando realizamos una operaci√≥n en un objeto, esto generalmente lleva al hecho de que el objeto, a su vez, accede a otros objetos en el √°rbol.  Al iterar sobre varios objetos, realizar la misma operaci√≥n generar√° operaciones posteriores, completamente diferentes para cada objeto (ver Figura 1a). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f8/5ea/960/4f85ea960a2c233300fd62f394a5b213.png" alt="Secuencia de llamadas con un enfoque orientado a datos" width="233" height="297"></div><br>  <i>Figura 1b.</i>  <i>Secuencia de llamadas en una t√©cnica orientada a datos</i> <br><br>  Para obtener el mejor esquema de almacenamiento de datos, puede ser √∫til dividir cada objeto en diferentes componentes y agrupar componentes del mismo tipo en la memoria, independientemente del objeto del que los tomamos.  Tal orden conduce a la creaci√≥n de grandes bloques de datos homog√©neos, lo que nos permite procesar los datos secuencialmente (ver Figura 1b).  La raz√≥n principal del poder del concepto de dise√±o orientado a datos es que funciona muy bien con grandes grupos de objetos.  OOP, por definici√≥n, funciona con un solo objeto.  Recuerda el √∫ltimo juego en el que trabajaste: ¬øcon qu√© frecuencia en el c√≥digo hab√≠a lugares donde ten√≠as que trabajar con un solo elemento?  Un enemigo?  Un veh√≠culo?  Una forma de encontrar nodo?  Una bala?  Una pieza?  Nunca!  Donde hay uno, hay varios m√°s.  OOP ignora esto y trabaja con cada objeto individualmente.  Por lo tanto, podemos simplificar el trabajo para nosotros y para el equipo organizando los datos de manera que sea necesario procesar muchos elementos del mismo tipo. <br><br>  ¬øTe parece extra√±o este enfoque?  ¬øPero sabes que?  Lo m√°s probable es que ya lo est√© utilizando en algunas partes del c√≥digo: a saber, en el sistema de part√≠culas.  El dise√±o orientado a datos convierte toda la base de c√≥digo en un gran sistema de part√≠culas.  Es posible que este m√©todo parezca m√°s familiar para los desarrolladores de juegos; deber√≠a llamarse programaci√≥n basada en part√≠culas. <br><br><h2>  Beneficios del dise√±o orientado a datos </h2><br>  Si en primer lugar pensamos en los datos y creamos la arquitectura del programa sobre la base de esto, esto nos dar√° muchas ventajas. <br><br><h3>  Paralelismo </h3><br>  Hoy en d√≠a es imposible deshacerse del hecho de que necesitamos trabajar con m√∫ltiples n√∫cleos.  Aquellos que intentaron paralelizar el c√≥digo OOP pueden confirmar cu√°n compleja, propensa a errores y quiz√°s no particularmente eficiente es la tarea.  A menudo, debe agregar muchas primitivas de sincronizaci√≥n para evitar el acceso simult√°neo a los datos de varios subprocesos, y generalmente muchos subprocesos est√°n inactivos durante mucho tiempo, esperando que otros subprocesos terminen de funcionar.  Como resultado, las ganancias de productividad son bastante mediocres. <br><br>  Si aplicamos un dise√±o orientado a datos, la paralelizaci√≥n se vuelve mucho m√°s simple: tenemos datos de entrada, una peque√±a funci√≥n que los procesa y genera datos.  Algo similar se puede dividir f√°cilmente en varias secuencias con una sincronizaci√≥n m√≠nima entre ellas.  Incluso puede dar un paso m√°s y ejecutar este c√≥digo en procesadores con memoria local (por ejemplo, en SPU de procesadores Cell) sin cambiar ninguna operaci√≥n. <br><br><h3>  Uso de cach√© </h3><br>  Adem√°s de usar m√∫ltiples n√∫cleos, una de las formas clave de lograr un alto rendimiento en equipos modernos con tuber√≠as de instrucci√≥n profundas y sistemas de memoria lenta con varios niveles de cach√© es la implementaci√≥n de acceso a datos que es conveniente para el almacenamiento en cach√©.  El dise√±o orientado a datos permite un uso muy eficiente del cach√© de comandos, porque el mismo c√≥digo se ejecuta constantemente en √©l.  Adem√°s, si organizamos los datos en grandes bloques adyacentes, podemos procesar los datos secuencialmente, logrando un uso casi perfecto del cach√© de datos y un excelente rendimiento. <br><br><h2>  Opci√≥n de optimizaci√≥n </h2><br>  Cuando pensamos en objetos o funciones, generalmente nos enfocamos en optimizar a nivel de una funci√≥n o incluso un algoritmo: tratamos de cambiar el orden de las llamadas a funciones, cambiar el m√©todo de clasificaci√≥n o incluso reescribir parte del c√≥digo C en lenguaje ensamblador. <br><br>  Tales optimizaciones son ciertamente √∫tiles, pero si piensa primero en los datos, podemos dar un paso atr√°s y crear optimizaciones m√°s ambiciosas e importantes.  No olvides que el juego solo trata con la conversi√≥n de ciertos datos (recursos, entrada del usuario, estado) en algunos otros datos (comandos gr√°ficos, nuevos estados del juego).  Con este flujo de datos en mente, podemos tomar decisiones m√°s informadas de alto nivel en funci√≥n de c√≥mo se convierten y aplican los datos.  Tales optimizaciones en las t√©cnicas OOP m√°s tradicionales pueden ser extremadamente complejas y llevar mucho tiempo. <br><br><h3>  Modularidad </h3><br>  Todas las ventajas anteriores del dise√±o orientado a datos estaban relacionadas con el rendimiento: uso de cach√©, optimizaci√≥n y paralelizaci√≥n.  No hay duda de que para nosotros los programadores de juegos, el rendimiento es extremadamente importante.  A menudo hay un conflicto entre las t√©cnicas que aumentan la productividad y las t√©cnicas que promueven la legibilidad del c√≥digo y la facilidad de desarrollo.  Por ejemplo, si reescribimos parte del c√≥digo en lenguaje ensamblador, mejoraremos el rendimiento, pero esto generalmente conduce a una disminuci√≥n de la legibilidad y complica el soporte para el c√≥digo. <br><br>  Afortunadamente, el dise√±o orientado a datos beneficia tanto la productividad como la facilidad de desarrollo.  Si escribe c√≥digo espec√≠ficamente para la conversi√≥n de datos, obtiene funciones peque√±as con un n√∫mero muy peque√±o de dependencias con otras partes del c√≥digo.  La base del c√≥digo sigue siendo muy "plana", con muchas funciones "hoja" que no tienen grandes dependencias.  Este nivel de modularidad y la ausencia de dependencias simplifica enormemente la comprensi√≥n, el reemplazo y la actualizaci√≥n del c√≥digo. <br><br><h3>  Prueba </h3><br>  El √∫ltimo beneficio importante del dise√±o orientado a datos es su facilidad de prueba.  Muchas personas saben que escribir pruebas unitarias para probar la interacci√≥n de objetos es una tarea no trivial.  Necesita crear dise√±os y elementos de prueba indirectamente.  Honestamente, esto es bastante doloroso.  Por otro lado, trabajar directamente con datos, escribir pruebas unitarias es absolutamente f√°cil: creamos algunos datos entrantes, llamamos a la funci√≥n que los convierte y verificamos si la salida coincide con los datos esperados.  Y eso es todo.  De hecho, esta es una gran ventaja que simplifica enormemente las pruebas de c√≥digo, ya sea desarrollo basado en pruebas o escritura de pruebas unitarias despu√©s del c√≥digo. <br><br><h2>  Desventajas del dise√±o orientado a datos </h2><br>  El dise√±o orientado a datos no es una "bala de plata" que resuelve todos los problemas en el desarrollo del juego.  Realmente ayuda a escribir c√≥digo de alto rendimiento y a crear programas que sean m√°s legibles y m√°s f√°ciles de mantener, pero en s√≠ mismo tiene algunas desventajas. <br><br>  El principal problema con el dise√±o orientado a datos: difiere de lo que la mayor√≠a de los programadores han aprendido y acostumbrado.  Requiere cambiar nuestro modelo mental del programa noventa grados y cambiar el punto de vista sobre √©l.  Para que este enfoque se convierta en una segunda naturaleza, se requiere pr√°ctica. <br><br>  Adem√°s, debido a la diferencia en los enfoques, puede causar dificultades para interactuar con el c√≥digo existente escrito en un estilo de procedimiento o POO.  Es dif√≠cil escribir una funci√≥n por separado, pero tan pronto como pueda aplicar el dise√±o orientado a datos a un subsistema completo, puede obtener muchas ventajas. <br><br><h2>  Uso de dise√±o orientado a datos </h2><br>  Suficiente teor√≠a y rese√±as.  ¬øC√≥mo comenzar a implementar el m√©todo de dise√±o orientado a datos?  Para comenzar, seleccione un √°rea espec√≠fica de su c√≥digo: navegaci√≥n, animaciones, colisiones u otra cosa.  M√°s tarde, cuando la parte principal del motor del juego se centre en los datos, podr√° ajustar el flujo de datos a lo largo de toda la ruta, desde el principio del cuadro hasta el final. <br><br>  A continuaci√≥n, es necesario identificar claramente los datos de entrada requeridos por el sistema y el tipo de datos que debe generar.  Es posible que est√© pensando en la terminolog√≠a de OOP por ahora, solo para identificar los datos.  Por ejemplo, para un sistema de animaci√≥n, parte de los datos de entrada ser√°n esqueletos, poses b√°sicas, datos de animaci√≥n y el estado actual.  El resultado no es un "c√≥digo de animaci√≥n animada", sino datos generados por las animaciones que se reproducen actualmente.  En este caso, la salida ser√° un nuevo conjunto de poses y un estado actualizado. <br><br>  Es importante retroceder y clasificar los datos entrantes en funci√≥n de c√≥mo se usan.  ¬øSon de solo lectura, lectura-escritura o solo escritura?  Dicha clasificaci√≥n ayudar√° a tomar decisiones sobre d√≥nde almacenar datos y cu√°ndo procesarlos debido a dependencias en otras partes del programa. <br><br>  En esta etapa, debe dejar de pensar en los datos necesarios para una operaci√≥n y comenzar a pensar en aplicarlos a docenas o cientos de elementos.  Ya no tenemos un esqueleto, una pose b√°sica y un estado actual: tenemos un bloque de cada uno de estos tipos con muchas instancias en cada uno de los bloques. <br><br>  Considere cuidadosamente c√≥mo se utilizar√°n los datos en el proceso de transformaci√≥n de entrada a salida.  Puede darse cuenta de que para transmitir datos necesita escanear un campo espec√≠fico en la estructura, y luego debe usar los resultados para realizar otra pasada.  En este caso, puede ser m√°s l√≥gico dividir este campo de origen en un bloque de memoria separado, que puede procesarse por separado, lo que har√° un mejor uso de la memoria cach√© y preparar√° el c√≥digo para una posible paralelizaci√≥n.  O bien, es posible que deba vectorizar parte del c√≥digo si necesita recibir datos de diferentes lugares para colocarlos en un registro vectorial.  En este caso, los datos se almacenar√°n adyacentes para que las operaciones vectoriales se puedan aplicar directamente, sin conversiones innecesarias. <br><br>  Ahora debe tener una muy buena comprensi√≥n de sus datos.  Escribir c√≥digo para convertirlos ser√° mucho m√°s f√°cil.  Ser√° como crear c√≥digo rellenando espacios.  Se sorprender√° gratamente de que el c√≥digo result√≥ ser mucho m√°s simple y compacto de lo que pensaba originalmente, en comparaci√≥n con el mismo c√≥digo OOP. <br><br>  La mayor√≠a de las publicaciones en mi blog te prepararon para este tipo de dise√±o.  Ahora debemos tener cuidado con la forma en que se organizan los datos, hornear los datos en el formato de entrada para que puedan usarse de manera eficiente y usar enlaces sin punteros entre los bloques de datos para que puedan moverse f√°cilmente. <br><br><h2>  ¬øHay espacio para usar OOP? </h2><br>  ¬øSignifica esto que OOP es in√∫til y nunca debe usarse al crear programas?  No puedo decir eso.  Pensar en el contexto de los objetos no es da√±ino si estamos hablando de una sola instancia de cada objeto (por ejemplo, un dispositivo gr√°fico, administrador de registros, etc.), aunque en este caso el c√≥digo puede implementarse en funci√≥n de funciones de estilo C m√°s simples y est√°ticas. datos a nivel de archivo.  E incluso en esta situaci√≥n, sigue siendo importante que los objetos se dise√±en con √©nfasis en la transformaci√≥n de datos. <br><br>  Otra situaci√≥n en la que todav√≠a uso OOP son los sistemas GUI.  Quiz√°s esto se deba a que aqu√≠ estamos trabajando con un sistema que ya est√° dise√±ado de manera orientada a objetos, o quiz√°s porque el rendimiento y la complejidad no son factores cr√≠ticos para el c√≥digo GUI.  Sea como fuere, prefiero las API GUI que hacen poco uso de la herencia y maximizan la anidaci√≥n (buenos ejemplos aqu√≠ son Cocoa y CocoaTouch).  Es probable que para los juegos puedas escribir sistemas GUI atractivos con una orientaci√≥n de datos, pero hasta ahora no los he visto. <br><br>  Al final, nada te impide crear una imagen mental basada en objetos de todos modos, si prefieres pensar en el juego de esta manera.  Es solo que la esencia del enemigo no ocupar√° un lugar f√≠sico en la memoria, sino que se dividir√° en subcomponentes m√°s peque√±os, cada uno de los cuales forma parte de una gran tabla de datos de componentes similares. <br><br>  El dise√±o orientado a datos est√° un poco alejado de los m√©todos de programaci√≥n tradicionales, pero si siempre piensa en los datos y las formas necesarias de transformarlos, le brindar√° grandes ventajas en t√©rminos de productividad y facilidad de desarrollo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472052/">https://habr.com/ru/post/472052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472036/index.html">F√≥rmula para calcular n√∫meros primos y optimizar divisores de fuerza bruta</a></li>
<li><a href="../472040/index.html">Equilibrando √°rboles rojo-negros: tres casos</a></li>
<li><a href="../472042/index.html">Multi-arrendamiento completo en Zimbra OSE con Zextras Admin</a></li>
<li><a href="../472044/index.html">Descripci√≥n general de ISPmanager: alojamiento y paneles de control del sitio</a></li>
<li><a href="../472046/index.html">Conferencias: el comienzo del camino</a></li>
<li><a href="../472054/index.html">Organizadores y asistentes de ense√±anza sobre los programas en l√≠nea del CS Center.</a></li>
<li><a href="../472060/index.html">La polic√≠a alemana irrumpi√≥ en el b√∫nker militar, que albergaba el centro de datos recientemente declarado.</a></li>
<li><a href="../472062/index.html">Monitoreo + prueba de estr√©s = pron√≥stico y sin fallas</a></li>
<li><a href="../472064/index.html">Ansible + auto git pull en el cl√∫ster de m√°quinas virtuales en la nube</a></li>
<li><a href="../472068/index.html">Uso de SSD NVME como unidad de sistema en computadoras con BIOS antiguo y sistema operativo Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>