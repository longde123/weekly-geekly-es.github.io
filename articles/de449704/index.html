<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔳 🎚️ 🧓 MVCC-5. In-Page-Reinigung und HEISS 🤜🏼 💗 🙆🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich möchte Sie daran erinnern, dass wir Probleme im Zusammenhang mit der Isolation untersucht , einen Exkurs über das Organisieren von Daten auf niedr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-5. In-Page-Reinigung und HEISS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/449704/">  Ich möchte Sie daran erinnern, dass wir Probleme im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation untersucht</a> , einen Exkurs über das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Organisieren von Daten auf niedriger Ebene durchgeführt</a> und dann ausführlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">über Zeilenversionen</a> und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erhalten</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Snapshots</a> aus Versionen gesprochen haben. <br><br>  Heute werden wir uns mit zwei ziemlich eng verwandten Themen befassen: <em>Bereinigung</em> <em>innerhalb der</em> <em>Seite</em> und <em>HOT-Updates</em> .  Beide Mechanismen können als Optimierungen klassifiziert werden.  Sie sind wichtig, werden jedoch in der Benutzerdokumentation fast nicht behandelt. <br><br><h1>  In-Page-Reinigung mit regelmäßigen Updates </h1><br>  Beim Zugriff auf eine Seite - sowohl während des Aktualisierens als auch beim Lesen - kann eine schnelle Bereinigung innerhalb der Seite erfolgen, wenn PostgreSQL versteht, dass auf der Seite nicht genügend Speicherplatz vorhanden ist.  Dies tritt in zwei Fällen auf. <br><br><ol><li>  Bei einem zuvor auf dieser Seite durchgeführten Update (UPDATE) wurde nicht genügend Speicherplatz gefunden, um eine neue Version der Zeile auf derselben Seite zu platzieren.  Diese Situation wird im Seitentitel gespeichert und beim nächsten Löschen der Seite. </li><li>  Die Seite ist mehr gefüllt als auf fillfactor.  In diesem Fall erfolgt die Reinigung sofort, ohne das nächste Mal zu verzögern. </li></ol><a name="habracut"></a><br>  Fillfactor ist ein Speicherparameter, der für die Tabelle (und für den Index) definiert werden kann.  PostgreSQL fügt nur dann eine neue Zeile (INSERT) auf der Seite ein, wenn diese Seite weniger als voll oder voll ist.  Der verbleibende Speicherplatz ist für neue Versionen von Zeichenfolgen reserviert, die aus Aktualisierungen (UPDATE) resultieren.  Der Standardwert für Tabellen ist 100, dh der Speicherplatz ist nicht reserviert (und der Wert für Indizes ist 90). <br><br>  Die Intra-Page-Bereinigung entfernt Versionen von Zeilen, die in keinem Bild sichtbar sind (außerhalb des "Ereignishorizonts" der Datenbank, über den wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzte Mal gesprochen haben</a> ), funktioniert jedoch ausschließlich innerhalb derselben Tabellenseite.  Zeiger auf bereinigte Versionen von Zeichenfolgen werden nicht freigegeben, da auf sie aus Indizes verwiesen werden kann und der Index eine andere Seite ist.  Die Bereinigung von Seiten geht nie über eine Tabellenseite hinaus, ist jedoch sehr schnell. <br><br>  Aus den gleichen Gründen wird die Freiraumkarte nicht aktualisiert.  Es spart auch Platz für Updates, nicht für Einfügungen.  Die Sichtbarkeitskarte wird ebenfalls nicht aktualisiert. <br><br>  Die Tatsache, dass eine Seite beim Lesen gelöscht werden kann, bedeutet, dass eine Leseanforderung (SELECT) dazu führen kann, dass sich Seiten ändern.  Dies ist ein weiterer solcher Fall zusätzlich zu der zuvor verzögerten Änderung von Hinweisbits. <br><br>  Lassen Sie uns anhand eines Beispiels sehen, wie dies funktioniert.  Erstellen Sie eine Tabelle und Indizes für beide Spalten. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> hot(id <span class="hljs-type"><span class="hljs-type">integer</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">2000</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">75</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> hot_id <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> hot(id); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> hot_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> hot(s);</code> </pre> <br>  Wenn nur lateinische Buchstaben in Spalte s gespeichert sind, belegt jede Version der Zeile 2004 Bytes plus 24 Bytes des Headers.  Wir setzen den Speicherparameter für den Füllfaktor auf 75% - es ist genügend Platz für drei Zeilen vorhanden. <br><br>  Der Einfachheit halber erstellen wir eine bereits bekannte Funktion neu und ergänzen die Ausgabe durch zwei Felder: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, hhu <span class="hljs-type"><span class="hljs-type">text</span></span>, hot <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask2 &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">16384</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'t'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> hhu, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask2 &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">32768</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'t'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> hot, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Und lassen Sie uns eine Funktion erstellen, um in die Indexseite zu schauen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> index_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(itemoffset <span class="hljs-type"><span class="hljs-type">smallint</span></span>, ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> itemoffset, ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> bt_page_items(relname,pageno); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Wir werden überprüfen, wie die Bereinigung innerhalb einer Seite funktioniert.  Fügen Sie dazu eine Zeile ein und ändern Sie sie mehrmals: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'D'</span></span>;</code> </pre><br>  Es gibt vier Versionen der Zeile auf der Seite: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 3979 (c) | 3980 (c) | | | (0,2) (0,2) | normal | 3980 (c) | 3981 (c) | | | (0,3) (0,3) | normal | 3981 (c) | 3982 | | | (0,4) (0,4) | normal | 3982 | 0 (a) | | | (0,4) (4 rows)</code> </pre><br>  Wie erwartet haben wir gerade die Füllfaktorschwelle überschritten.  Dies wird durch die Differenz zwischen der Seitengröße und den oberen Werten angezeigt: Sie überschreitet den Schwellenwert von 75% der Seitengröße, der 6144 Byte beträgt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | pagesize -------+-------+---------- 40 | 64 | 8192 (1 row)</code> </pre><br>  Wenn Sie das nächste Mal auf die Seite zugreifen, sollte eine Bereinigung innerhalb der Seite erfolgen.  Überprüfen Sie dies heraus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'E'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | dead | | | | | (0,2) | dead | | | | | (0,3) | dead | | | | | (0,4) | normal | 3982 (c) | 3983 | | | (0,5) (0,5) | normal | 3983 | 0 (a) | | | (0,5) (5 rows)</code> </pre><br>  Alle irrelevanten Versionen der Zeilen (0,1), (0,2) und (0,3) werden gelöscht.  Danach wird dem frei gewordenen Raum eine neue Version der Zeile (0.5) hinzugefügt. <br><br>  Die nach dem Bereinigen verbleibenden Zeilenversionen werden physisch an die Seite der Adressen der höheren Seite verschoben, sodass der gesamte freie Speicherplatz durch ein fortlaufendes Fragment dargestellt wird.  Die Werte der Zeiger ändern sich entsprechend.  Dank dessen gibt es keine Probleme mit der Fragmentierung des freien Speicherplatzes auf der Seite. <br><br>  Zeiger auf gelöschte Versionen von Zeichenfolgen können nicht freigegeben werden, da auf sie von einer Indexseite verwiesen wird.  Schauen wir uns die erste Seite des hot_s-Index an (weil die Null mit Metainformationen beschäftigt ist): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'hot_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) 4 | (0,4) 5 | (0,5) (5 rows)</code> </pre><br>  Wir werden das gleiche Bild in einem anderen Index sehen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'hot_id'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,5) 2 | (0,4) 3 | (0,3) 4 | (0,2) 5 | (0,1) (5 rows)</code> </pre><br>  Sie können feststellen, dass die Zeiger auf die Tabellenzeilen hier "rückwärts" gehen, aber das spielt keine Rolle, da in allen Versionen der Zeilen der gleiche Wert id = 1 ist. Im vorherigen Index sind die Zeiger jedoch nach s-Werten geordnet, und dies im Wesentlichen. <br><br>  Mit dem Indexzugriff kann PostgreSQL (0,1), (0,2) oder (0,3) als Zeilenversionskennung erhalten.  Dann wird er versuchen, die entsprechende Zeile von der Tabellenseite abzurufen, aber dank des toten Status des Zeigers wird er feststellen, dass eine solche Version nicht mehr existiert, und sie ignorieren.  (Wenn PostgreSQL zum ersten Mal feststellt, dass eine Version einer Tabellenzeile fehlt, ändert PostgreSQL auch den Status des Zeigers auf der Indexseite, sodass nicht erneut auf die Tabellenseite zugegriffen wird.) <br><br>  Es ist wichtig, dass die Bereinigung innerhalb einer Seite nur innerhalb einer Tabellenseite funktioniert und keine Indexseiten gelöscht werden. <br><br><h1>  HEISSE Updates </h1><br>  Warum ist es schlecht, Links zu allen Versionen einer Zeichenfolge im Index zu behalten? <br><br>  Erstens müssen Sie bei jeder Zeilenänderung alle für die Tabelle erstellten Indizes aktualisieren: Da eine neue Version angezeigt wurde, müssen Sie Links dazu haben.  Und das müssen Sie auf jeden Fall tun, auch wenn sich Felder ändern, die nicht im Index enthalten sind.  Offensichtlich ist dies nicht sehr effektiv. <br><br>  Zweitens sammeln die Indizes Links zu historischen Versionen der Zeichenfolge, die dann zusammen mit den Versionen selbst gelöscht werden müssen (wir werden dies etwas später betrachten). <br><br>  Darüber hinaus gibt es ein Merkmal der Implementierung des B-Baums in PostgreSQL.  Wenn auf der Indexseite nicht genügend Platz zum Einfügen einer neuen Zeile vorhanden ist, wird die Seite in zwei Teile geteilt und alle Daten werden zwischen ihnen neu verteilt.  Dies wird als geteilte Seite bezeichnet.  Beim Löschen von Zeilen bleiben jedoch zwei Indexseiten nicht mehr zu einer zusammen.  Aus diesem Grund wird die Größe des Index möglicherweise nicht verringert, selbst wenn ein wesentlicher Teil der Daten gelöscht wird. <br><br>  Je mehr Indizes auf dem Tisch erstellt werden, desto größer sind natürlich die Schwierigkeiten, mit denen Sie konfrontiert sind. <br><br>  Wenn sich jedoch der Wert einer Spalte ändert, die zu keinem Index gehört, macht es keinen Sinn, einen zusätzlichen Datensatz im B-Baum zu erstellen, der denselben Schlüsselwert enthält.  So funktioniert die Optimierung, das so genannte HOT-Update - das Heap-Only-Tupel-Update. <br><br>  Mit diesem Update gibt es nur einen Eintrag auf der Indexseite, der auf die allererste Version der Zeile auf der Tabellenseite verweist.  Und bereits auf dieser tabellarischen Seite ist eine Versionskette organisiert: <br><br><ul><li>  Zeichenfolgen, die geändert und in die Kette aufgenommen werden, sind mit dem Bit Heap Hot Updated gekennzeichnet. </li><li>  Zeilen, auf die im Index nicht verwiesen wird, sind mit dem Bit "Nur Heap-Tupel" gekennzeichnet (dh "nur die tabellarische Version der Zeile"). </li><li>  Die regelmäßige Verknüpfung von Zeichenfolgenversionen über das Feld ctid wird unterstützt. </li></ul><br>  Wenn PostgreSQL beim Scannen des Index die Tabellenseite aufruft und die als Heap Hot Updated gekennzeichnete Version erkennt, muss es nicht angehalten werden und geht weiter entlang der gesamten Update-Kette.  Natürlich wird für alle auf diese Weise erhaltenen Versionen von Zeichenfolgen die Sichtbarkeit überprüft, bevor sie an den Client zurückgegeben werden. <br><br>  Um die Funktionsweise eines HOT-Updates zu überprüfen, löschen Sie einen Index und löschen Sie die Tabelle. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> hot_s; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> hot;</code> </pre><br>  Wiederholen Sie das Einfügen und aktualisieren Sie die Zeile. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Folgendes sehen wir auf der Tabellenseite: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | normal | 3986 (c) | 3987 | t | | (0,2) (0,2) | normal | 3987 | 0 (a) | | t | (0,2) (2 rows)</code> </pre><br>  Auf der Seite gibt es eine Reihe von Änderungen: <br><br><ul><li>  Das Heap Hot Updated-Flag zeigt an, dass Sie entlang der ctid-Kette gehen müssen. </li><li>  Das Flag Nur Heap-Tupel zeigt an, dass keine Indexverknüpfungen zu dieser Version der Zeile vorhanden sind. </li></ul><br>  Mit weiteren Änderungen wächst die Kette (innerhalb der Seite): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'D'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 3986 (c) | 3987 (c) | t | | (0,2) (0,2) | normal | 3987 (c) | 3988 (c) | t | t | (0,3) (0,3) | normal | 3988 (c) | 3989 | t | t | (0,4) (0,4) | normal | 3989 | 0 (a) | | t | (0,4) (4 rows)</code> </pre><br>  Darüber hinaus gibt es im Index einen einzigen Verweis auf den „Kopf“ der Kette: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'hot_id'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) (1 row)</code> </pre><br>  Wir betonen, dass HOT-Updates funktionieren, wenn die aktualisierten Felder in keinem Index enthalten sind.  Andernfalls würde in einem Index ein Link direkt zur neuen Version der Zeichenfolge vorhanden sein, was der Idee dieser Optimierung widerspricht. <br><br>  Die Optimierung funktioniert nur innerhalb der Grenzen einer Seite. Daher erfordert ein zusätzlicher Bypass der Kette keinen Zugriff auf andere Seiten und beeinträchtigt die Leistung nicht. <br><br><h1>  In-Page-Reinigung mit HOT-Updates </h1><br>  Ein besonderer, aber wichtiger Fall der Intra-Page-Reinigung ist die Reinigung während der HOT-Updates. <br><br>  Wie beim letzten Mal haben wir den Füllfaktor-Schwellenwert bereits überschritten, sodass das nächste Update zu einer Bereinigung der Seite führen sollte.  Aber diesmal auf der Seite ist eine Kette von Updates.  Der "Kopf" dieser HOT-Kette sollte immer an Ort und Stelle bleiben, da der Index darauf verweist und der Rest der Zeiger freigegeben werden kann: Es ist bekannt, dass sie nicht von außen referenziert werden. <br><br>  Um den "Kopf" nicht zu berühren, wird eine doppelte Adressierung verwendet: Der Zeiger, auf den sich der Index bezieht - in diesem Fall (0,1) - erhält den Status "Umleiten" und leitet zur gewünschten Version der Zeichenfolge um. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'E'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+---------------+----------+-------+-----+-----+-------- (0,1) | redirect to 4 | | | | | (0,2) | normal | 3990 | 0 (a) | | t | (0,2) (0,3) | unused | | | | | (0,4) | normal | 3989 (c) | 3990 | t | t | (0,2) (4 rows)</code> </pre><br>  Bitte beachten Sie Folgendes: <br><br><ul><li>  Versionen (0,1), (0,2) und (0,3) wurden gelöscht, </li><li>  Der Kopfzeiger (0,1) blieb erhalten, erhielt jedoch den Umleitungsstatus. </li><li>  Eine neue Version der Zeile wird an Ort und Stelle geschrieben (0.2), da diese Version garantiert keine Links von Indizes enthält und der Zeiger freigegeben (nicht verwendet) wurde. </li></ul><br>  Führen Sie das Update noch einige Male durch: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'F'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'G'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+---------------+----------+----------+-----+-----+-------- (0,1) | redirect to 4 | | | | | (0,2) | normal | 3990 (c) | 3991 (c) | t | t | (0,3) (0,3) | normal | 3991 (c) | 3992 | t | t | (0,5) (0,4) | normal | 3989 (c) | 3990 (c) | t | t | (0,2) (0,5) | normal | 3992 | 0 (a) | | t | (0,5) (5 rows)</code> </pre><br>  Das folgende Update führt erneut zu einer Bereinigung innerhalb der Seite: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'H'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+---------------+----------+-------+-----+-----+-------- (0,1) | redirect to 5 | | | | | (0,2) | normal | 3993 | 0 (a) | | t | (0,2) (0,3) | unused | | | | | (0,4) | unused | | | | | (0,5) | normal | 3992 (c) | 3993 | t | t | (0,2) (5 rows)</code> </pre><br>  Wieder werden einige Versionen gelöscht und der Zeiger auf den "Kopf" wird entsprechend verschoben. <br><br>  Schlussfolgerung: Bei häufigen Aktualisierungen von Spalten außerhalb der Indizes kann es sinnvoll sein, den Parameter fillfactor zu reduzieren, um auf der Seite Platz für Aktualisierungen zu reservieren.  Natürlich müssen wir berücksichtigen, dass je niedriger der Füllfaktor ist, desto mehr nicht zugewiesener Speicherplatz auf der Seite verbleibt und dementsprechend die physische Größe der Tabelle zunimmt. <br><br><h1>  HEISSER Kettenbruch </h1><br>  Wenn auf der Seite nicht genügend freier Speicherplatz vorhanden ist, um eine neue Version einer Zeile zu veröffentlichen, wird die Kette unterbrochen.  Die Version der Zeile, die auf einer anderen Seite veröffentlicht wird, muss einen separaten Link zum Index erstellen. <br><br>  Um diese Situation zu erreichen, starten wir eine parallele Transaktion und erstellen darin einen Datenschnappschuss. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> hot;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 1 | (1 row)</code> </pre><br>  Ein Schnappschuss löscht nicht die Version der Zeilen auf der Seite.  Jetzt führen wir das Update in der ersten Sitzung durch: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'I'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'J'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'K'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+---------------+----------+----------+-----+-----+-------- (0,1) | redirect to 2 | | | | | (0,2) | normal | 3993 (c) | 3994 (c) | t | t | (0,3) (0,3) | normal | 3994 (c) | 3995 (c) | t | t | (0,4) (0,4) | normal | 3995 (c) | 3996 | t | t | (0,5) (0,5) | normal | 3996 | 0 (a) | | t | (0,5) (5 rows)</code> </pre><br>  Wenn die Seite das nächste Mal aktualisiert wird, ist nicht genügend Speicherplatz auf der Seite vorhanden, aber die Bereinigung der Seite kann nichts freigeben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'L'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--    </span></span></code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+---------------+----------+----------+-----+-----+-------- (0,1) | redirect to 2 | | | | | (0,2) | normal | 3993 (c) | 3994 (c) | t | t | (0,3) (0,3) | normal | 3994 (c) | 3995 (c) | t | t | (0,4) (0,4) | normal | 3995 (c) | 3996 (c) | t | t | (0,5) (0,5) | normal | 3996 (c) | 3997 | | t | (1,1) (5 rows)</code> </pre><br>  In Version (0.5) sehen wir einen Link zu (1.1), der zu Seite 1 führt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+------+-------+-----+-----+-------- (1,1) | normal | 3997 | 0 (a) | | | (1,1) (1 row)</code> </pre><br>  Jetzt gibt es zwei Zeilen im Index, von denen jede auf den Anfang ihrer HOT-Kette zeigt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'hot_id'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (1,1) 2 | (0,1) (2 rows)</code> </pre><br><blockquote>  Leider fehlen in der Dokumentation praktisch Informationen zur Bereinigung von Seiten und zu HOT-Updates, und die Wahrheit muss im Quellcode gesucht werden.  Ich empfehle mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">README.HOT zu beginnen</a> . <br></blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449704/">https://habr.com/ru/post/de449704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449688/index.html">Testen der sendBeacon-Einstellungen zum Senden von Daten</a></li>
<li><a href="../de449690/index.html">Im geheimen Labor von Ledger</a></li>
<li><a href="../de449696/index.html">Nehmen Sie am Wettbewerb zum Übertakten von RAM - HyperX Memory OC Competition 2019 teil</a></li>
<li><a href="../de449700/index.html">Warum der Verkehr plötzlich zum Stau wird</a></li>
<li><a href="../de449702/index.html">Auf der Bühne wieder Gewinner der internationalen Wettbewerbe SSH und sudo. Unter der Anleitung von Honoured Conductor Active Directory</a></li>
<li><a href="../de449706/index.html">Arbeiten Sie mit der KOMPAS-3D-API → Lektion 15 → Zusammengesetzte Linien basierend auf Absatz</a></li>
<li><a href="../de449708/index.html">Citymobil - ein Handbuch zur Verbesserung der Verfügbarkeit bei Unternehmenswachstum für Startups. Teil 3</a></li>
<li><a href="../de449712/index.html">Wöchentliche Nachrichten: HDD-Nachfrage sinkt, staatliches Internetgesetz genehmigt, 5G-Geräteproduktion in Russland</a></li>
<li><a href="../de449714/index.html">Null ist nicht immer Null</a></li>
<li><a href="../de449716/index.html">Acronis eröffnet Entwicklern zum ersten Mal den Zugriff auf die API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>