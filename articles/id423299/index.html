<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💡 🔇 ⬅️ Koordinator Aplikasi di aplikasi iOS 👩‍🎓 🎢 ‼️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap tahun, platform iOS mengalami banyak perubahan, di samping itu, perpustakaan pihak ketiga secara teratur bekerja dengan jaringan, menyimpan dat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Koordinator Aplikasi di aplikasi iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/423299/">  Setiap tahun, platform iOS mengalami banyak perubahan, di samping itu, perpustakaan pihak ketiga secara teratur bekerja dengan jaringan, menyimpan data, membuat UI melalui JavaScript, dan banyak lagi.  Berbeda dengan semua tren ini, <strong>Pavel Gurov</strong> berbicara tentang solusi arsitektur, yang akan relevan terlepas dari teknologi apa yang Anda gunakan sekarang atau akan digunakan dalam beberapa tahun. <br><br>  ApplicationCoordinator dapat digunakan untuk membangun navigasi antar layar, dan pada saat yang sama menyelesaikan sejumlah masalah.  Di bawah demo kucing dan instruksi untuk implementasi tercepat dari pendekatan ini. <br><br><img src="https://habrastorage.org/webt/xx/ok/ti/xxoktiysvlvnzl1zbhvivxccrry.jpeg"><br><br>  <strong>Tentang pembicara:</strong> Pavel Gurov sedang mengembangkan aplikasi iOS di Avito. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Pt9TGFzLVzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h2>  Navigasi <br></h2><br><br><img src="https://habrastorage.org/webt/9d/dp/od/9ddpodzty4uclncm046g1ms9nvy.jpeg"><br><br>  Menavigasi antar layar adalah tugas yang 100% Anda hadapi, apa pun yang Anda lakukan - jejaring sosial, panggilan taksi, atau bank online.  Inilah aplikasi yang dimulai dengan bahkan pada tahap prototipe, ketika Anda bahkan tidak tahu sepenuhnya seperti apa layarnya, seperti apa bentuk animasi mereka, apakah data akan di-cache.  Layar mungkin berupa gambar kosong atau statis, tetapi <strong>tugas navigasi muncul di aplikasi segera setelah ada lebih dari satu layar ini</strong> .  Yaitu, segera. <br><br><img src="https://habrastorage.org/webt/um/r-/qo/umr-qogrmhhn58yvlaseyxqyrre.jpeg"><br><br>  Metode paling umum untuk membangun arsitektur aplikasi iOS: MVc, MVVm, dan MVp, menjelaskan cara membuat modul layar tunggal.  Ia juga mengatakan bahwa modul-modul tersebut dapat saling mengenal, berkomunikasi satu sama lain, dll.  Tetapi sangat sedikit perhatian diberikan pada masalah bagaimana transisi antara modul-modul ini dibuat, siapa yang memutuskan transisi ini, dan bagaimana data ditransmisikan. <br><br><h2>  UlStoryboard + segues <br></h2><br>  iOS out of the box menyediakan beberapa cara untuk menunjukkan skenario layar berikut: <br><br><ol><li>  <strong>UlStoryboard + segues yang terkenal</strong> , ketika kami menetapkan semua transisi antar layar dalam satu file-meta, dan kemudian memanggilnya.  Semuanya sangat nyaman dan hebat. </li><li>  Kontainer - seperti UINavigationController.  UITabBarController, UIPageController atau, mungkin, wadah yang ditulis sendiri yang dapat digunakan baik secara programatis dan bersama dengan StoryBoards. </li><li>  Metode sekarang (_: animasi: selesai :).  Ini hanya metode kelas UIController. </li></ol><br>  Tidak ada masalah dengan alat ini sendiri.  Masalahnya persis bagaimana mereka biasa digunakan.  UINavigationController, performSegue, prepForSegue, metode presentViewController adalah semua metode properti dari kelas UIViewController.  Apple menyarankan untuk menggunakan alat-alat ini di dalam UIViewController itu sendiri. <br><br><img src="https://habrastorage.org/webt/gy/_n/vb/gy_nvb7uettqb7xdoillr3ud3m4.jpeg"><br><br>  Buktinya adalah sebagai berikut. <br><br><img src="https://habrastorage.org/webt/hv/cq/6p/hvcq6prwv2si1cyrpqkiwchlwds.jpeg"><br><br>  Ini adalah komentar yang muncul di proyek Anda jika Anda membuat subkelas baru dari UIViewController menggunakan templat standar.  Ini ditulis secara langsung - jika Anda menggunakan segues dan Anda perlu mentransfer data ke layar berikutnya sesuai dengan skenario, Anda harus: mendapatkan ViewController ini dari segue;  tahu apa jenisnya;  masukkan ke tipe ini dan berikan data Anda di sana. <br><br>  Pendekatan ini untuk masalah dalam membangun navigasi. <br><br>  <strong>1. Konektivitas layar yang kaku</strong> <br><br>  Ini berarti bahwa layar 1 tahu tentang keberadaan layar 2. Tidak hanya dia tahu tentang keberadaannya, itu juga berpotensi membuatnya, atau mengambilnya dari segue, mengetahui jenisnya, dan mentransfer beberapa data ke sana. <br><br>  Jika kita perlu, dalam beberapa keadaan, untuk menampilkan layar 3 daripada layar 2, maka kita harus tahu tentang layar baru 3 dengan cara yang sama untuk dijahit ke pengontrol layar 1. Semuanya menjadi lebih sulit jika pengontrol 2 dan 3 dapat dipanggil dari beberapa tempat lagi, tidak hanya dari layar 1. Ternyata pengetahuan layar 2 dan 3 harus dijahit di setiap tempat ini. <br><br>  Untuk melakukan ini adalah setengah dari masalah, masalah utama akan dimulai ketika perlu untuk melakukan perubahan pada transisi ini, atau untuk mendukung semua ini. <br><br><img src="https://habrastorage.org/webt/nx/34/yw/nx34ywvotea8yovx9xuuaxp2lro.jpeg"><br><br>  <strong>2. Susun ulang pengontrol skrip</strong> <br><br>  Ini juga tidak begitu sederhana karena koneksi.  Untuk menukar dua ViewControllers, tidak akan cukup untuk masuk ke UlStoryboard dan menukar 2 gambar.  Anda harus membuka kode untuk masing-masing layar ini, mentransfernya ke pengaturan yang berikutnya, dan mengubah tempatnya, yang sangat tidak nyaman. <br><br><img src="https://habrastorage.org/webt/lz/_g/n6/lz_gn6x_emphixjobmg-cezayqa.jpeg"><br><br>  <strong>3. Transfer data sesuai dengan skenario</strong> <br><br>  Misalnya, ketika memilih sesuatu di layar 3, kita perlu memperbarui Tampilan di layar 1. Karena pada awalnya kita tidak memiliki apa-apa selain ViewController, kita harus entah bagaimana menghubungkan dua ViewControllers - tidak masalah bagaimana - melalui delegasi atau entah bagaimana belum.  Akan lebih sulit lagi jika, menurut aksi pada layar 3, perlu memperbarui bukan satu layar, tetapi beberapa sekaligus, misalnya, yang pertama dan kedua. <br><br><img src="https://habrastorage.org/webt/wy/gz/gr/wygzgrppqbr4dc6tszklinog714.jpeg"><br><br>  Dalam hal ini, delegasi tidak dapat diabaikan, karena delegasi adalah hubungan satu-ke-satu.  Seseorang akan berkata, mari kita gunakan pemberitahuan, seseorang - melalui status bersama.  Semua ini membuat sulit untuk men-debug dan melacak aliran data dalam aplikasi kita. <br><br>  Seperti yang mereka katakan, lebih baik melihat sekali daripada mendengar 100 kali.  Mari kita lihat contoh spesifik dari aplikasi Avito Services Pro ini.  Aplikasi ini untuk para profesional di sektor layanan, di mana nyaman untuk melacak pesanan Anda, berkomunikasi dengan pelanggan, mencari pesanan baru. <br><br>  Skenario - memilih kota dalam mengedit profil pengguna. <br><br><img src="https://habrastorage.org/webt/0j/cd/zn/0jcdznc3-8b7fy9lliaairh1s_u.jpeg"><br><br>  Ini adalah layar pengeditan profil, seperti yang ada di banyak aplikasi.  Kami tertarik untuk memilih kota. <br><br>  Apa yang sedang terjadi di sini? <br><br><ul><li>  Pengguna mengklik sel dengan kota, dan layar pertama memutuskan bahwa sudah waktunya untuk menambahkan layar berikut ke tumpukan navigasi.  Ini adalah layar dengan daftar kota-kota federal (Moskow dan St. Petersburg) dan daftar wilayah. </li><li>  Jika pengguna memilih kota federal pada layar kedua, maka layar kedua memahami bahwa skrip telah selesai, meneruskan kota yang dipilih ke yang pertama dan tumpukan Navigasi kembali ke layar pertama.  Script dianggap lengkap. </li><li>  Jika pengguna memilih area di layar kedua, maka layar kedua memutuskan bahwa layar ketiga perlu disiapkan, di mana kita melihat daftar kota di daerah ini.  Jika pengguna memilih kota, maka kota ini dikirim ke layar pertama, menggulung tumpukan Navigasi dan skrip dianggap lengkap. </li></ul><br>  Dalam diagram ini, masalah konektivitas yang saya sebutkan sebelumnya ditampilkan sebagai panah di antara ViewController.  Kami akan menyingkirkan masalah ini sekarang. <br><br>  <strong>Bagaimana kita melakukan ini?</strong> <br><br><ol><li>  Kami <strong>melarang diri di dalam UIViewController untuk mengakses kontainer</strong> , yaitu ke self.navigationController, self.tabBarController, atau beberapa kontainer kustom lain yang Anda buat sebagai ekstensi properti.  Sekarang kita tidak bisa mengambil wadah kita dari kode layar dan memintanya untuk melakukan sesuatu. <br><br><img src="https://habrastorage.org/webt/av/ci/0x/avci0xx4juu-sitqkcidwmo5woi.jpeg"><br></li><li>  <strong>Kami melarang diri kami di dalam UIViewController untuk memanggil metode performSegue</strong> dan menulis kode dalam metode prepForSegue, yang akan mengambil layar yang mengikuti skrip dan mengkonfigurasinya.  Artinya, kami tidak lagi bekerja dengan segue (dengan transisi antar layar) di dalam UIViewController. <br><br><img src="https://habrastorage.org/webt/xp/lh/kq/xplhkqdhp61csbpdmvaulmonqra.jpeg"><br></li><li>  Kami juga <strong>melarang penyebutan pengontrol lain di dalam pengontrol khusus kami</strong> : tidak ada inisialisasi, transfer data, dan hanya itu. <br><br><img src="https://habrastorage.org/webt/cr/0_/j9/cr0_j999w13tkk8szf2wh1xbjsm.jpeg"><br></li></ol><br><br><h2>  Koordinator <br></h2><br>  Karena kita menghapus semua tanggung jawab ini dari UIViewController, kita memerlukan entitas baru yang akan menjalankannya.  Buat kelas objek baru, dan menyebutnya koordinator. <br><br><img src="https://habrastorage.org/webt/ta/ub/t6/taubt6cqzz4_lviz88jbgih3jf4.jpeg"><br><br>  Koordinator hanyalah objek biasa yang kita lewati pada awal NavigationController dan memanggil metode Mulai.  Sekarang jangan berpikir tentang bagaimana ini diterapkan, lihat saja bagaimana skenario memilih kota akan berubah dalam kasus ini. <br><br>  Sekarang ini tidak dimulai dengan fakta bahwa kami sedang mempersiapkan transisi ke layar NavigationController tertentu, tetapi kami memanggil metode Start di koordinator, meneruskannya sebelum itu di penginisialisasi NavigationController.  Koordinator memahami bahwa sudah waktunya bagi NavigationController untuk meluncurkan layar pertama, yang ia lakukan. <br><br>  Selanjutnya, ketika pengguna memilih sel dengan kota, acara ini diteruskan ke koordinator.  Artinya, layar itu sendiri tidak tahu apa-apa - setelah itu, seperti yang mereka katakan, setidaknya banjir.  Dia mengirim pesan ini ke koordinator, dan kemudian koordinator bereaksi dengan (karena dia memiliki NavigationController), yang mengirimkan langkah selanjutnya - ini adalah pilihan daerah. <br><br>  Selanjutnya, pengguna mengklik "Wilayah" - gambar yang sama persis - layar itu sendiri tidak menyelesaikan apa pun, hanya memberi tahu koordinator bahwa layar berikutnya terbuka. <br><br>  Ketika pengguna memilih kota tertentu pada layar ketiga, kota ini juga ditransfer ke layar pertama melalui koordinator.  Yaitu, sebuah pesan dikirimkan kepada koordinator bahwa suatu kota telah dipilih.  Koordinator mengirim pesan ini ke layar pertama dan melempar tumpukan Navigasi ke layar pertama. <br><br>  Perhatikan bahwa <strong>pengontrol tidak lagi berkomunikasi satu sama lain</strong> , memutuskan siapa yang akan menjadi berikutnya, dan tidak mengirimkan data satu sama lain.  Apalagi mereka tidak tahu apa-apa tentang lingkungannya. <br><br><img src="https://habrastorage.org/webt/uz/sy/uo/uzsyuorkw837chi1zn8s39hdkw0.jpeg"><br><br>  Jika kita mempertimbangkan aplikasi dalam kerangka arsitektur tiga lapis, maka ViewController idealnya pas sepenuhnya ke dalam lapisan Presentasi dan membawa sesedikit mungkin logika aplikasi. <br><br>  Dalam hal ini, kami menggunakan koordinator untuk mengeluarkan logika transisi ke lapisan di atas dan menghapus pengetahuan ini dari ViewController. <br><br><h2>  Demo <br></h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek</a> presentasi dan demo tersedia di Github, di bawah ini adalah demonstrasi selama pembicaraan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Pt9TGFzLVzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ini adalah skenario yang sama: mengedit profil dan memilih kota di dalamnya. <br><br>  Layar pertama adalah layar edit pengguna.  Ini menunjukkan informasi tentang pengguna saat ini: nama dan kota yang dipilih.  Ada tombol "Pilih kota."  Ketika kita mengkliknya, kita menuju ke layar dengan daftar kota.  Jika kita memilih kota di sana, maka layar pertama mendapatkan kota ini. <br><br>  Mari kita lihat sekarang bagaimana ini bekerja dalam kode.  Mari kita mulai dengan modelnya. <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> city: <span class="hljs-type"><span class="hljs-type">City?</span></span> }</code> </pre> <br>  <strong>Modelnya</strong> sederhana: <br><br><ol><li>  Struktur kota yang memiliki nama bidang, string; </li><li>  Seorang pengguna yang juga memiliki nama dan kota properti. </li></ol><br>  Selanjutnya adalah <strong>StoryBoard</strong> .  Dimulai dengan NavigationController.  Pada prinsipnya, ini adalah layar yang sama dengan yang ada di simulator: layar pengeditan pengguna dengan label dan tombol dan layar dengan daftar kota, yang menunjukkan tablet dengan kota. <br><br><h4>  Layar Edit Pengguna <br></h4><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserEditViewController: UIViewController, UpdateableWithUser { // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> - var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>? { didSet { updateView() } } // MARK: - Output - var onSelectCity: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? @IBOutlet private weak var userLabel: UILabel? @IBAction private func selectCityTap(_ sender: UIButton) { onSelectCity?() } override func viewWillAppear(_ animated: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) { super.viewWillAppear(animated) updateView() } private func updateView() { userLabel?.text = "User: \(user?.name ?? ""), \n" + "City: \(user?.city?.name ?? "")" } }</code> </pre><br>  Di sini ada Pengguna properti - ini adalah pengguna yang dikirim ke luar - pengguna yang akan kami edit.  Setel pengguna di sini menyebabkan blok didSet dipanggil, yang mengarah ke panggilan ke metode updateView () lokal.  Semua yang dilakukan metode ini hanyalah menaruh informasi tentang pengguna pada label, yaitu menunjukkan nama dan nama kota tempat tinggal pengguna ini. <br><br>  Hal yang sama terjadi pada metode viewWillAppear (). <br><br>  Tempat paling menarik adalah pawang untuk mengklik tombol pilih kota selectCityTap ().  <strong>Di sini, pengontrol itu sendiri tidak menyelesaikan apa pun</strong> : ia tidak membuat pengontrol apa pun, ia tidak memanggil segue apa pun.  Yang dia lakukan hanyalah panggilan balik - ini adalah properti kedua dari ViewController kami.  Callback onSelectCity tidak memiliki parameter.  Ketika pengguna mengklik tombol, ini menyebabkan panggilan balik ini dipanggil. <br><br><h4>  Layar pemilihan kota <br></h4><br><pre> <code class="hljs powershell">import UIKit final <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CitiesViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewController</span></span></span></span> { // MARK: - Output - var onCitySelected: ((City) -&gt; Void)? // MARK: - Private variables - private let cities: [<span class="hljs-type"><span class="hljs-type">City</span></span>] = [<span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Moscow"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Ulyanovsk"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"New York"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Tokyo"</span></span>)] // MARK: - Table - override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cities.count } override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-string"><span class="hljs-string">"cell"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: indexPath) cell.textLabel?.text = cities[<span class="hljs-type"><span class="hljs-type">indexPath.row</span></span>].name <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell } override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { onCitySelected?(cities[<span class="hljs-type"><span class="hljs-type">indexPath.row</span></span>]) } }</code> </pre><br>  Layar ini adalah UITableViewController.  Daftar kota di sini sudah diperbaiki, tetapi mungkin datang dari tempat lain.  Selanjutnya (// MARK: - Tabel -) adalah kode tabel yang cukup sepele yang menampilkan daftar kota dalam sel. <br><br>  Tempat paling menarik di sini adalah handler didSelectRowAt IndexPath, metode terkenal untuk semua orang.  Di sini layar itu sendiri lagi tidak menyelesaikan apa pun.  Apa yang terjadi setelah kota dipilih?  Itu hanya memanggil panggilan balik dengan parameter tunggal "kota". <br><br>  Ini mengakhiri kode untuk layar sendiri.  Seperti yang kita lihat, mereka tidak tahu apa-apa tentang lingkungan mereka. <br><br><h4>  Koordinator <br></h4><br>  Mari beralih ke tautan di antara layar-layar ini. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit protocol UpdateableWithUser: <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } } final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserEditCoordinator { // MARK: - Properties private var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span> { didSet { updateInterfaces() } } private weak var navigationController: UINavigationController? // MARK: - Init init(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, navigationController: UINavigationController) { self.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> self.navigationController = navigationController } func <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() { showUserEditScreen() } // MARK: - Private implementation private func showUserEditScreen() { let controller = UIStoryboard.makeUserEditController() controller.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> controller.onSelectCity = { [weak self] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self?.showCitiesScreen() } navigationController?.pushViewController(controller, animated: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } private func showCitiesScreen() { let controller = UIStoryboard.makeCitiesController() controller.onCitySelected = { [weak self] city <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self?.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.city = city _ = self?.navigationController?.popViewController(animated: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } navigationController?.pushViewController(controller, animated: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } private func updateInterfaces() { navigationController?.viewControllers.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { (<span class="hljs-meta"><span class="hljs-meta">$0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? UpdateableWithUser)?.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> } } }</code> </pre><br>  Koordinator memiliki dua properti: <br><br><ol><li>  Pengguna - pengguna yang akan kami edit; </li><li>  NavigationController yang akan dilewati saat startup. </li></ol><br>  Ada init sederhana () yang mengisi properti ini. <br><br>  Berikutnya adalah metode start (), yang menyebabkan metode <strong>ShowUserEditScreen () dipanggil</strong> .  Mari kita bahas lebih detail.  Metode ini mengeluarkan pengontrol dari UIStoryboard, meneruskannya ke pengguna lokal kami.  Kemudian dia melakukan panggilan balik "SelectCity" dan mendorong pengontrol ini ke tumpukan Navigasi. <br><br>  Setelah pengguna mengklik tombol, panggilan balik onSelectCity dipicu, dan ini akan <strong>memanggil</strong> metode <strong>ShowCitiesScreen ()</strong> pribadi berikut. <br><br>  Bahkan, ia melakukan hal yang hampir sama - ia mengangkat pengontrol yang sedikit berbeda dari UIStoryboard, menempatkan panggilan balik onCitySelected di atasnya dan mendorongnya ke tumpukan Navigasi - itu saja yang terjadi.  Ketika pengguna memilih kota tertentu, panggilan balik ini dipicu, koordinator memperbarui bidang "kota" dari pengguna lokal kami dan melempar tumpukan Navigasi ke layar pertama. <br><br>  Karena Pengguna adalah struktur, memperbarui bidang "kota" di dalamnya mengarah pada fakta bahwa blok didSet dipanggil, masing-masing, metode pribadi <strong>updateInterfaces ()</strong> dipanggil.  Metode ini melewati seluruh tumpukan Navigasi dan mencoba untuk menyebarkan setiap ViewController sebagai protokol UpdateableWithUser.  Ini adalah protokol paling sederhana, yang hanya memiliki satu properti - pengguna.  Jika ini berhasil, maka ia melemparnya ke pengguna yang diperbarui.  Dengan demikian, ternyata pengguna yang kami pilih di layar kedua secara otomatis melompat ke layar pertama. <br><br>  Semuanya jelas dengan koordinator, dan satu-satunya yang tersisa untuk ditampilkan di sini adalah titik masuk ke aplikasi kita.  Di sinilah semuanya dimulai.  Dalam hal ini, ini adalah metode didFinishLaunchingWithOptions di AppDelegate kami. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit @UIApplicationMain <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AppDelegate: UIResponder, UIApplicationDelegate { var <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>: UIWindow? var coordinator: UserEditCoordinator! func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>]?) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { guard let navigationController = <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>?.rootViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? UINavigationController <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } let <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Pavel Gurov", city: City(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Moscow")) coordinator = UserEditCoordinator(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, navigationController: navigationController) coordinator.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } }</code> </pre><br>  Di sini navigationController diambil dari UIStoryboard, seorang Pengguna dibuat, yang akan kami edit, dengan nama dan kota tertentu.  Selanjutnya kita buat koordinator kita dengan User dan navigationController.  Ini memanggil metode start ().  Koordinator dipindahkan ke properti lokal - itu pada dasarnya semua.  Skema ini cukup sederhana. <br><br><h4>  Input dan output <br></h4><br>  Ada beberapa poin yang ingin saya bahas lebih detail.  Anda mungkin memperhatikan bahwa properti di userEditViewController ditandai dengan komentar sebagai Input, dan panggilan balik dari pengontrol ini ditandai sebagai Output. <br><br><img src="https://habrastorage.org/webt/xs/_v/kr/xs_vkrwlnwgvdyneeeijb2xsrm0.jpeg"><br><br>  <strong>Input</strong> adalah semua data yang dapat berubah dari waktu ke waktu, serta beberapa metode ViewController yang dapat dipanggil dari luar.  Misalnya, di UserEditViewController ini adalah properti Pengguna - Pengguna itu sendiri atau parameter City-nya dapat berubah. <br><br>  <strong>Keluar</strong> adalah peristiwa apa pun yang ingin dikontrol pengontrol ke dunia luar.  Di UserEditViewController, ini adalah klik pada tombol onSelectCity, dan pada layar pemilihan kota, ini adalah klik pada sel dengan kota tertentu.  Gagasan utama di sini adalah, saya ulangi, bahwa pengontrol tidak tahu apa-apa dan tidak melakukan apa-apa tentang peristiwa ini.  Dia mendelegasikan untuk memutuskan apa yang harus dilakukan, kepada orang lain. <br><br>  Di Objective-C, saya tidak terlalu suka menulis save callbacks karena sintaksisnya yang buruk.  Tetapi di Swift, ini jauh lebih sederhana.  Menggunakan panggilan balik dalam hal ini merupakan alternatif dari pola delegasi terkenal di iOS.  Hanya di sini, alih-alih menetapkan metode dalam protokol dan mengatakan bahwa koordinator sesuai dengan protokol ini, dan kemudian menulis metode ini di suatu tempat secara terpisah, kita dapat segera membuat entitas di satu tempat dengan mudah, melakukan panggilan balik ke sana dan melakukan semuanya. <br><br>  Benar, dengan pendekatan ini, tidak seperti delegasi, ada hubungan yang erat antara esensi koordinator dan layar, karena koordinator tahu bahwa ada esensi spesifik layar. <br><br>  Anda dapat menyingkirkan ini dengan cara yang sama seperti dalam delegasi, menggunakan protokol. <br><br><img src="https://habrastorage.org/webt/a-/nm/aa/a-nmaaf8uwdvujtzcvhjmfz0k2c.jpeg"><br><br>  Untuk menghindari konektivitas, kita dapat <strong>menutup</strong> <strong>Input dan</strong> <strong>Output dari controller kita dengan sebuah protokol</strong> . <br><br>  Di atas adalah protokol CitiesOutput, yang memiliki tepat satu persyaratan - panggilan balik onCitySelected.  Di sebelah kiri adalah analog dari skema ini di Swift.  Pengontrol kami mematuhi protokol ini, menentukan panggilan balik yang diperlukan.  Kami melakukan ini sehingga koordinator tidak tahu tentang keberadaan kelas CitiesViewController.  Tetapi pada beberapa titik dia perlu mengkonfigurasi output dari controller ini.  Untuk menghidupkan semuanya, kami menambahkan pabrik ke koordinator. <br><br><img src="https://habrastorage.org/webt/vx/hl/0v/vxhl0vp5g0pybl5_6pbasirpfby.jpeg"><br><br>  Pabrik memiliki metode cityOutput ().  Ternyata koordinator kami tidak membuat pengontrol dan tidak mendapatkannya dari suatu tempat.  Sebuah pabrik melemparkannya ke arahnya, yang mengembalikan objek yang ditutup oleh protokol dalam metode, dan dia tidak tahu apa-apa tentang kelas apa objek ini. <br><br>  Sekarang yang paling penting - mengapa melakukan semua ini?  <strong>Mengapa kita perlu membangun level tambahan lain ketika tidak ada masalah?</strong> <br><br>  Orang dapat membayangkan situasi ini: seorang manajer akan datang kepada kami dan meminta Anda untuk melakukan pengujian A / B atas fakta bahwa alih-alih daftar kota, kami akan memiliki pilihan kota di peta.  Jika dalam aplikasi kami pilihan kota tidak di satu tempat, tetapi di koordinator yang berbeda, dalam skenario yang berbeda, kami harus menjahit bendera di setiap tempat, melemparkannya ke luar, pada bendera ini menaikkan salah satu atau yang lain ViewController.  Ini sangat tidak nyaman. <br><br>  Kami ingin menghapus pengetahuan ini dari koordinator.  Karena itu, seseorang dapat melakukan ini di satu tempat.  Di pabrik itu sendiri, kita akan membuat parameter di mana pabrik mengembalikan salah satu atau pengontrol lain yang ditutup oleh protokol.  Keduanya akan memiliki panggilan balik onCitySelected, dan koordinator pada prinsipnya tidak akan peduli dengan layar mana yang dapat digunakan - peta atau daftar. <br><br><h2>  Komposisi VS Warisan <br></h2><br>  Poin berikutnya yang ingin saya bahas adalah komposisi melawan warisan. <br><br><img src="https://habrastorage.org/webt/l5/9m/qg/l59mqgla1anz9rqv3sla16adtiw.jpeg"><br><br><ol><li>  Metode pertama yang dapat dilakukan koordinator kami adalah <strong>membuat komposisi</strong> ketika NavigationController diteruskan dari luar dan disimpan secara lokal sebagai properti.  Ini seperti komposisi - kami menambahkan NavigationController sebagai properti. </li><li>  Di sisi lain, ada pendapat bahwa semuanya ada di Kit UI, dan kita tidak perlu menemukan kembali roda.  Anda cukup mengambil dan <strong>mewarisi UI</strong> <strong>NavigationController</strong> . </li></ol><br>  Setiap opsi memiliki pro dan kontra, tetapi secara pribadi menurut saya <strong>komposisi dalam kasus ini lebih cocok</strong> daripada warisan.  Warisan umumnya merupakan skema yang kurang fleksibel.  Jika kita perlu, misalnya, untuk mengubah Navigasi ke, katakanlah, UIPageController, maka dalam kasus pertama kita dapat dengan mudah menutupnya dengan protokol umum, seperti "Tampilkan layar berikutnya" dan dengan mudah mengganti wadah yang kita butuhkan. <br><br>  Dari sudut pandang saya, argumen paling penting adalah bahwa Anda menyembunyikan dari pengguna akhir dalam komposisi semua metode yang tidak perlu.  Ternyata dia kurang mungkin tersandung.  Anda <strong>hanya</strong> menyisakan <strong>API yang diperlukan</strong> , misalnya, metode Mulai - dan itu saja.  Dia tidak memiliki cara untuk memanggil PushViewController, metode PopViewController, yaitu, entah bagaimana mengganggu kegiatan koordinator.  Semua metode dari kelas induk disembunyikan. <br><br><h2>  Papan cerita <br></h2><br>  Saya percaya bahwa mereka pantas mendapat perhatian khusus bersama dengan segues.  Secara pribadi, <strong>saya mendukung</strong> <strong>segues</strong> , karena memungkinkan Anda dengan cepat membiasakan diri dengan skrip.  Ketika seorang pengembang baru tiba, ia tidak perlu memanjat kode, Storyboards membantu dengan ini.  Bahkan jika Anda membuat antarmuka dengan kode, Anda dapat meninggalkan ViewController kosong, dan membuat antarmuka dengan kode, tetapi meninggalkan setidaknya transisi dan seluruh poin.  Seluruh esensi Storyboards ada dalam transisi sendiri, dan bukan dalam tata letak UI. <br><br>  Untungnya, <strong>pendekatan koordinator tidak membatasi pilihan alat</strong> .  Kita dapat dengan aman menggunakan koordinator bersama dengan segues.  Tetapi kita harus ingat bahwa sekarang kita tidak dapat bekerja dengan segues di dalam UIViewController. <br><br><img src="https://habrastorage.org/webt/hp/sl/qp/hpslqpf2-het-coms7wczezguo8.jpeg"><br><br>  Oleh karena itu, kita harus mengganti metode onPrepareForSegue di kelas kita.  Alih-alih melakukan sesuatu di dalam controller, kami akan mendelegasikan tugas-tugas ini lagi ke koordinator, melalui callback.  Metode onPrepareForSegue disebut, Anda tidak melakukan apa pun sendiri - Anda tidak tahu jenis segmen apa itu, apa tujuan pengontrolnya - itu tidak masalah bagi Anda.  Anda cukup melemparkan semuanya ke dalam callback, dan koordinator akan mengetahuinya.  Dia memiliki pengetahuan ini, Anda tidak membutuhkan pengetahuan ini. <br><br>  Untuk membuat semuanya lebih sederhana, Anda bisa melakukan ini di kelas Base tertentu agar tidak menimpanya di setiap kontroler yang diambil secara terpisah.  Dalam hal ini, koordinator akan lebih nyaman bekerja dengan segmen Anda. <br><br>  Hal lain yang menurut saya nyaman dengan Storyboard adalah mematuhi aturan bahwa <strong>satu</strong> <strong>Storyboard sama dengan satu koordinator</strong> .  Kemudian Anda bisa sangat menyederhanakan semuanya, membuat satu kelas secara umum - StoryboardCoordinator, dan menghasilkan parameter RootType di dalamnya, membuat pengontrol Navigasi awal di Storyboard dan membungkus seluruh skrip di dalamnya. <br><br><img src="https://habrastorage.org/webt/sm/v2/wz/smv2wzspn7ykrajsui8npmfvcls.jpeg"><br><br>  Seperti yang Anda lihat, di sini koordinator memiliki 2 properti: navigationController;  RootViewController dari RootType kami bersifat umum.  Selama inisialisasi, kami meneruskannya bukan dengan navigationController tertentu, tetapi Storyboard, dari mana Navigasi root kami dan pengontrol pertama didapat.  Dengan cara ini kita bahkan tidak perlu memanggil metode Mulai.  Artinya, Anda membuat koordinator, ia segera memiliki Navigasi, dan segera memiliki Root.  Anda dapat menunjukkan Navigasi secara modal, atau mengambil Root dan mendorong ke navigasi yang ada dan terus bekerja. <br><br>  UserEditCoordinator kami dalam hal ini hanya akan menjadi typealias, menggantikan jenis RootViewController di parameter generik. <br><br><h2>  Transfer data skrip kembali <br></h2><br>  Mari kita bicara tentang memecahkan masalah terakhir, yang saya uraikan di awal.  Ini adalah transfer data kembali ke skrip. <br><br><img src="https://habrastorage.org/webt/i6/i9/el/i6i9el9jdxqnjqp2pe80epk27iy.jpeg"><br><br>  Pertimbangkan skenario yang sama untuk memilih kota, tetapi sekarang akan dimungkinkan untuk memilih bukan satu kota, tetapi beberapa.  Untuk menunjukkan kepada pengguna bahwa ia telah memilih beberapa kota di wilayah yang sama, kami akan menunjukkan di layar dengan daftar wilayah sejumlah kecil di sebelah nama wilayah, yang menunjukkan jumlah kota yang dipilih di wilayah ini. <br><br>  Ternyata aksi pada satu kontroler (pada yang ketiga) harus mengarah pada perubahan penampilan beberapa lainnya sekaligus.  Artinya, di pertama kita harus menunjukkan di sel dengan kota, dan di kedua kita harus memperbarui semua angka di wilayah yang dipilih. <br><br>  Koordinator menyederhanakan tugas ini dengan mentransfer data kembali ke skrip - ini sekarang tugas yang sederhana seperti mentransfer data ke depan sesuai dengan skrip. <br><br>  Apa yang sedang terjadi di sini?  Pengguna memilih kota.  Pesan ini dikirim ke koordinator.  Koordinator, seperti yang telah saya tunjukkan dalam demo, melewati seluruh tumpukan navigasi dan mengirimkan data yang diperbarui ke semua pihak yang berkepentingan.  Dengan demikian, ViewController dapat memperbarui Lihat mereka dengan data ini. <br><br><h2>  Refactoring Kode yang Ada <br></h2><br>  Bagaimana cara memperbaiki kode yang ada jika Anda ingin menanamkan pendekatan ini dalam aplikasi yang sudah ada yang memiliki MVc, MVVm atau MVp? <br><br><img src="https://habrastorage.org/webt/dd/_h/ss/dd_hssepys-qb1ybs9tg6qhnlqo.jpeg"><br><br>  Anda memiliki banyak ViewController.  Hal pertama yang harus dilakukan adalah membaginya ke dalam skenario di mana mereka berpartisipasi.  Dalam contoh kami, ada 3 skenario: otorisasi, pengeditan profil, rekaman. <br><br><img src="https://habrastorage.org/webt/nb/gy/yq/nbgyyqm1qsj1jb_nasqr5wdtdnk.jpeg"><br><br>  Kami sekarang membungkus setiap skenario di dalam koordinator kami.  Kita seharusnya dapat, pada kenyataannya, memulai skrip-skrip ini dari mana saja dalam aplikasi kita.  Ini harus fleksibel - <strong>koordinator harus sepenuhnya mandiri</strong> . <br><br>  Pendekatan pengembangan ini memberikan kenyamanan tambahan.  Terdiri dari fakta bahwa jika Anda saat ini bekerja dengan skenario tertentu, Anda tidak perlu mengkliknya setiap kali Anda memulainya.  Anda dapat memulainya dengan cepat di awal, mengedit sesuatu di dalamnya, dan kemudian menghapus awal sementara ini. <br><br>  Setelah kami memutuskan koordinator kami, kami perlu menentukan skenario mana yang bisa mengarah ke permulaan yang lain, dan membuat pohon dari skenario ini. <br><br><img src="https://habrastorage.org/webt/ya/y0/dn/yay0dneeqirzezm667lwklnkux0.jpeg"><br><br>  Dalam kasus kami, struktur pohonnya sederhana: LoginCoordinator dapat memulai koordinator pengeditan profil.  Di sini, hampir semuanya jatuh pada tempatnya, tetapi detail yang sangat penting tetap ada - skema kami tidak memiliki titik masuk. <br><br><img src="https://habrastorage.org/webt/38/-0/no/38-0nolfpsqej62yytkzqp-ux6s.jpeg"><br><br>  Titik masuk ini akan menjadi koordinator khusus - <strong>ApplicationCoordinator</strong> .  Itu dibuat dan dimulai oleh <strong>AppDelegate</strong> , dan kemudian sudah mengendalikan logika di tingkat aplikasi, yaitu, koordinator mana yang mulai sekarang. <br><br>  Kami hanya melihat sirkuit yang sangat mirip, hanya saja ViewController bukan koordinator, dan kami membuatnya sehingga ViewController tidak tahu apa-apa tentang satu sama lain dan tidak saling mengirimkan data.  Pada prinsipnya, hal yang sama dapat dilakukan dengan koordinator.  Kita dapat menetapkan Input (metode Mulai) dan Output tertentu (panggilan balik onFinish) di dalamnya.  <strong>Koordinator menjadi mandiri, dapat digunakan kembali, dan mudah diuji</strong> .  Koordinator tidak lagi saling mengenal dan berkomunikasi, misalnya, hanya dengan ApplicationCoordinator. <br><br>  Anda perlu berhati-hati, karena jika aplikasi Anda memiliki cukup skrip ini, maka ApplicationCoordinator dapat berubah menjadi objek dewa besar, ia akan tahu tentang semua skrip yang ada - ini juga tidak terlalu keren.  Di sini kita harus sudah melihat - mungkin membagi koordinator menjadi sub-koordinator, yaitu, memikirkan arsitektur sedemikian rupa sehingga objek-objek ini tidak tumbuh ke ukuran luar biasa.  <strong>Meskipun ukuran tidak selalu menjadi alasan untuk refactoring</strong> . <br><br><h3>  Mulai dari mana <br></h3><br>  Saya menyarankan mulai dari bawah ke atas - pertama mengimplementasikan skrip individual. <br><br><img src="https://habrastorage.org/webt/rw/tw/al/rwtwalrny6uxjzbpfhcjzxybzse.jpeg"><br><br>  Sebagai solusinya, mereka dapat dimulai di dalam UIViewController.  Artinya, selama Anda tidak memiliki Root atau koordinator lain, Anda dapat membuat satu koordinator dan, sebagai solusi sementara, mulai dari UIViewController, simpan secara lokal di properti (seperti Koordinator selanjutnya adalah di atas).  Ketika suatu peristiwa terjadi, Anda, seperti yang saya tunjukkan dalam demo, membuat properti lokal, meletakkan koordinator di sana dan memanggil metode Mulai di atasnya.  Semuanya sangat sederhana. <br><br>  Kemudian, ketika semua koordinator telah melakukannya, awal dari satu di dalam yang lain terlihat persis sama.  Apakah Anda memiliki properti lokal atau beberapa jenis dependensi seperti koordinator, Anda meletakkan semua ini di sana sehingga tidak lari, dan memanggil metode Mulai. <br><br><h2>  Ringkasan <br></h2><br><ul><li>  <strong>Layar dan skrip independen</strong> yang tidak tahu apa-apa tentang satu sama lain tidak saling berkomunikasi.  Kami berusaha mencapai ini. <br></li><li>  <strong>Mudah untuk mengubah urutan</strong> layar dalam aplikasi tanpa mengubah kode layar.  Jika semuanya dilakukan sebagaimana mestinya, satu-satunya hal yang harus berubah dalam aplikasi ketika skrip berubah bukan kode layar, tetapi kode koordinator. <br></li><li>  <strong>Transfer data yang disederhanakan antara layar</strong> dan tugas-tugas lain yang menyiratkan koneksi antara layar. <br></li><li>      —    ,       <strong>  </strong>     . <br></li></ul><br><blockquote> AppsConf 2018  8  9  —  !   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  )  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> .      — iOS  Android,      ,       ,     ,      . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423299/">https://habr.com/ru/post/id423299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423285/index.html">Rekayasa Sosial: Musuh yang Sulit Dihadapi di Dunia Keamanan Siber</a></li>
<li><a href="../id423291/index.html">Rusia membuat rekor: 110 film bajakan per orang</a></li>
<li><a href="../id423293/index.html">Bagaimana tidak menembak diri sendiri di kaki dengan mesin negara</a></li>
<li><a href="../id423295/index.html">Konferensi Pengembangan Seluler Paling Berguna</a></li>
<li><a href="../id423297/index.html">Dari Pengembang Android ke DevOps</a></li>
<li><a href="../id423303/index.html">AI, tentu saja praktis. Transformasi Musik Berbasis Emosi</a></li>
<li><a href="../id423305/index.html">Merusak kinerja</a></li>
<li><a href="../id423307/index.html">GitHub Tarik Permintaan dalam Kode Visual Studio</a></li>
<li><a href="../id423309/index.html">Transaksi DBMS</a></li>
<li><a href="../id423311/index.html">Naviaddress Kemitraan dan ACTUM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>