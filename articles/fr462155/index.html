<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏻 🔢 🛩️ Travaillez avec Worker «comme vous le souhaitez», pas «autant que possible» 🚔 🎦 👩🏽‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article utilisera la méthode eval DIRTY, unsafe, "béquille", effrayant, etc. Les faibles de cœur ne lisent pas! 


 Je dois dire tout de suite que...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Travaillez avec Worker «comme vous le souhaitez», pas «autant que possible»</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/462155/"><p> Cet article utilisera la méthode <code>eval</code> DIRTY, unsafe, "béquille", effrayant, etc.  Les faibles de cœur ne lisent pas! </p><br><p>  Je dois dire tout de suite que certains problèmes d'utilisabilité n'ont pas pu être résolus: dans le code qui sera transmis au travailleur, vous ne pouvez pas utiliser la fermeture. <br><img src="https://habrastorage.org/webt/t1/dt/x4/t1dtx4olv1-uzfyxmrltaxi9zyq.jpeg" alt="Travaillez avec Worker &quot;comme vous le souhaitez&quot;, mais pas &quot;autant que possible&quot;"></p><a name="habracut"></a><br><p>  Nous aimons tous les nouvelles technologies, et nous l'aimons quand il est commode d'utiliser ces technologies.  Mais dans le cas des travailleurs, ce n'est pas entièrement vrai.  Le travailleur travaille avec un fichier ou un lien de fichier, mais cela n'est pas pratique.  Je voudrais pouvoir mettre n'importe quelle tâche dans le travailleur, et pas seulement du code spécialement conçu. </p><br><p>  De quoi a-t-on besoin pour rendre le travail avec le travailleur plus pratique?  À mon avis, ce qui suit: </p><br><ul><li>  Possibilité d'exécuter du code arbitraire dans le travailleur à tout moment </li><li>  Capacité à transmettre des données complexes au travailleur (instances de classe, fonctions) </li><li>  Capacité d'obtenir Promise avec une réponse du travailleur. </li></ul><br><p>  Tout d'abord, nous avons besoin d'un protocole de communication entre le travailleur et la fenêtre principale.  En général, un protocole est simplement la structure et les types de données avec lesquels la fenêtre du navigateur et le travailleur communiqueront.  Il n'y a rien de compliqué.  Vous pouvez utiliser quelque chose comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ça</a> ou écrire votre propre version.  Dans chaque message, nous aurons un identifiant et des données spécifiques à un type de message particulier.  Pour commencer, nous aurons deux types de messages pour le travailleur: </p><br><ul><li>  ajout de bibliothèques / fichiers au travailleur </li><li>  lancement des travaux </li></ul><br><h2 id="fayl-vnutri-worker">  Fichier à l'intérieur du travailleur </h2><br><p>  Avant de commencer à créer un travailleur, vous devez décrire un fichier qui fonctionnera dans travailleur et prendra en charge le protocole décrit par nous.  J'adore la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">POO</a> , ce sera donc une classe appelée WorkerBody.  Cette classe doit s'abonner à l'événement depuis la fenêtre parent. </p><br><pre> <code class="javascript hljs">self.onmessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onMessage(message.data); };</code> </pre> <br><p>  Nous pouvons maintenant écouter les événements de la fenêtre parent.  Nous avons deux types d'événements: ceux auxquels la réponse est implicite, et tous les autres.  Nous traitons les événements. <br>  L'ajout de bibliothèques et de fichiers au travailleur se fait à l'aide de l'API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">importScripts</a> . </p><br><p>  Et le pire: nous utiliserons <em>eval</em> pour exécuter une fonction arbitraire. </p><br><pre> <code class="javascript hljs">... onMessage(message) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (message.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MESSAGE_TYPE.ADD_LIBS: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addLibs(message.libs); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MESSAGE_TYPE.WORK: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doWork(message); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } doWork(message) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processor = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(message.job); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> params = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parser.parse(message.params); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = processor(params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result &amp;&amp; result.then &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> result.then === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { result.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: data }); }, (error) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { error = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(error); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: error }); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: result }); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(e) }); } } send(data) { data.body = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._serializer.serialize(data.body); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { self.postMessage(data); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toSet = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: data.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(e) }; self.postMessage(toSet); } }</code> </pre><br><p>  La méthode <code>onMessage</code> responsable de la réception du message et de la sélection du gestionnaire, <code>doWork</code> - démarre la fonction passée, et <code>send</code> envoie la réponse à la fenêtre parente. </p><br><h2 id="parser-i-serializator">  Analyseur et sérialiseur </h2><br><p>  Maintenant que nous avons le contenu de travailleur, nous devons apprendre à sérialiser et analyser toutes les données afin de les transmettre à travailleur.  Commençons par le sérialiseur.  Nous voulons pouvoir transmettre toutes les données au travailleur, y compris les instances de classe, les classes et les fonctions.  Mais avec les fonctionnalités natives de Worker, nous ne pouvons transmettre que des données de type JSON.  Pour contourner cette interdiction, nous avons besoin d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">eval</a> .  Tout ce qui ne peut pas accepter JSON, nous encapsulerons dans les constructions de chaînes correspondantes et exécuterons de l'autre côté.  Pour préserver l'immuabilité, les données obtenues sont clonées à la volée, et celles qui ne peuvent pas être sérialisées de la manière habituelle sont remplacées par des objets de service, et à leur tour, ils sont remplacés par l'analyseur de l'autre côté.  À première vue, il peut sembler que cette tâche n'est pas difficile, mais il existe de nombreux pièges.  La pire limitation de cette approche est l'incapacité à utiliser la fermeture, qui porte un style d'écriture de code légèrement différent.  Commençons par le plus simple, avec la fonction.  Vous devez d'abord apprendre à distinguer une fonction d'un constructeur de classe. </p><br><p>  Essayons de distinguer: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> isFunction(Factory){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Factory.prototype) { <span class="hljs-comment"><span class="hljs-comment">// Arrow function has no prototype return true; } const prototypePropsLength = Object.getOwnPropertyNames(Factory.prototype) .filter(item =&gt; item !== 'constructor') .length; return prototypePropsLength === 0 &amp;&amp; Serializer.getClassParents(Factory).length === 1; } static getClassParents(Factory) { const result = [Factory]; let tmp = Factory; let item = Object.getPrototypeOf(tmp); while (item.prototype) { result.push(item); tmp = item; item = Object.getPrototypeOf(tmp); } return result.reverse(); }</span></span></code> </pre><br><p>  Tout d'abord, nous verrons si la fonction a un prototype.  Si ce n'est pas le cas, c'est certainement une fonction.  Ensuite, nous regardons le nombre de propriétés dans le prototype, et si dans le prototype seuls le constructeur et la fonction ne sont pas les héritiers d'une autre classe, nous considérons que c'est une fonction. </p><br><p>  Après avoir trouvé une fonction, nous la remplaçons simplement par un objet de service avec les champs <code>__type = "serialized-function"</code> et <code>template</code> , qui est égal au template de cette fonction ( <code>func.toString()</code> ). </p><br><p>  Pour l'instant, ignorez la classe et analysez l'instance de classe.  Plus loin dans les données, nous devons distinguer les objets ordinaires des instances de classe. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> isInstance(some) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> = some.<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>; if (!<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !Serializer.isNative(<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>); } static isNative(data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-regexp"><span class="hljs-regexp">/function .*?\(\) \{ \[native code\] \}/</span></span>.test(data.toString()); }</code> </pre><br><p>  Nous considérons un objet comme ordinaire s'il n'a pas de constructeur ou si son constructeur est une fonction native.  Après avoir identifié l'instance de classe, nous la remplaçons par un objet de service avec des champs: </p><br><ul><li>  <code>__type</code> - 'instance sérialisée' </li><li>  <code>data</code> - données qui étaient dans l'instance </li><li>  <code>index</code> - l'index de classe de cette instance dans la liste des services de classe. </li></ul><br><p>  Pour transférer des données, nous devons créer un champ supplémentaire: nous y stockons une liste de toutes les classes uniques que nous passons.  La partie la plus difficile est que lorsqu'une classe est détectée, prenez non seulement son modèle, mais aussi le modèle de toutes les classes parentes et enregistrez-les en tant que classes distinctes - de sorte que chaque "parent" ne soit transmis qu'une seule fois - et enregistrez la vérification sur instanceof.  La définition d'une classe est simple: il s'agit d'une fonction qui n'a pas réussi notre test Serializer.isFunction.  Lors de l'ajout d'une classe, nous vérifions la présence d'une telle classe dans la liste des données sérialisées et n'ajoutons que des données uniques.  Le code qui collecte la classe dans un modèle est assez volumineux et se trouve <a href="">ici</a> . </p><br><p>  Dans l'analyseur, nous parcourons d'abord toutes les classes qui nous sont passées et les compilons si elles n'ont pas été passées auparavant.  Ensuite, nous parcourons récursivement chaque champ de données et remplaçons les objets de service par des données compilées.  La chose la plus intéressante est dans l'instance de classe.  Nous avons une classe et il y a des données qui étaient dans son instance, mais nous ne pouvons pas simplement les instancier, car l'appel au constructeur peut avoir des paramètres que nous n'avons pas.  Une méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Object.create</a> presque oubliée vient à notre aide, qui renvoie un objet avec un prototype donné.  Nous évitons donc d'appeler le constructeur et d'obtenir une instance de la classe, puis de simplement réécrire les propriétés dans l'instance. </p><br><h2 id="sozdanie-worker">  Travailleur de création </h2><br><p>  Pour que le travailleur fonctionne correctement, nous devons avoir un analyseur et un sérialiseur à l'intérieur et à l'extérieur du travailleur.Nous prenons donc le sérialiseur et transformons le sérialiseur, l'analyseur et le corps du travailleur en modèle.  Nous créons un blob à partir du modèle et créons un lien de téléchargement via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">URL.createObjectURL</a> (cette méthode peut ne pas fonctionner avec certaines "Content-Security-Policy").  Cette méthode convient également pour exécuter du code arbitraire à partir d'une chaîne. </p><br><pre> <code class="javascript hljs">_createWorker(customWorker) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = <span class="hljs-string"><span class="hljs-string">`var MyWorker = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._createTemplate(customWorker)}</span></span></span><span class="hljs-string">;`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> blob = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob([template], { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'application/javascript'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(URL.createObjectURL(blob)); } _createTemplate(WorkerBody) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Name = Serializer.getFnName(WorkerBody); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Name) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Unnamed Worker Body class! Please add name to Worker Body class!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'(function () {'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(Serializer, <span class="hljs-string"><span class="hljs-string">'Serializer'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(Parser, <span class="hljs-string"><span class="hljs-string">'Parser'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(WorkerBody, <span class="hljs-string"><span class="hljs-string">'WorkerBody'</span></span>), <span class="hljs-string"><span class="hljs-string">`return new WorkerBody(Serializer, Parser)})();`</span></span> ].join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); }</code> </pre><br><h2 id="rezultat">  Résultat </h2><br><p>  Ainsi, nous avons obtenu une bibliothèque facile à utiliser qui peut exécuter du code arbitraire dans worker.  Il prend en charge les classes de TypeScript.  Par exemple: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = workerWrapper.create(); wrapper.process(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// This code in worker. Cannot use closure! // do some hard work return 100; // or return Promise.resolve(100) }, params).then((result) =&gt; { // result = 100; }); wrapper.terminate() // terminate for kill worker process</span></span></code> </pre> <br><h2 id="dalneyshie-plany">  Plans supplémentaires </h2><br><p>  Cette bibliothèque, malheureusement, est loin d'être idéale.  Il est nécessaire d'ajouter un support pour les setters et les getters sur les classes, les objets, les prototypes, les propriétés statiques.  Nous aimerions également ajouter la mise en cache, faire exécuter un script alternatif sans <code>eval</code> via URL.createObjectURL et ajouter un fichier avec le contenu de travailleur à l'assembly (si la création n'est pas disponible à la volée).  Venez au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référentiel</a> ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462155/">https://habr.com/ru/post/fr462155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462145/index.html">Pourquoi faut-il plusieurs jours pour se désinscrire?</a></li>
<li><a href="../fr462147/index.html">Utilisation de la navigation lors de la refactorisation d'un héritage de projet dans React Native</a></li>
<li><a href="../fr462149/index.html">Mode de restriction d'accès pour les accessoires sur les appareils iOS et comment le contourner</a></li>
<li><a href="../fr462151/index.html">5 principales distributions Kubernetes</a></li>
<li><a href="../fr462153/index.html">Shaders de carte interactive Unity</a></li>
<li><a href="../fr462159/index.html">Construire un système de reconnaissance faciale basé sur Golang et OpenCV</a></li>
<li><a href="../fr462161/index.html">Expérience d'installation d'Apache Airflow sur Windows 10</a></li>
<li><a href="../fr462163/index.html">Des technologies qui seront populaires en 2020</a></li>
<li><a href="../fr462165/index.html">Comment 25 personnes ont été amenées à travailler pour une société de jeux inexistante</a></li>
<li><a href="../fr462167/index.html">Contournez la limite de recherche de LinkedIn en jouant avec l'API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>