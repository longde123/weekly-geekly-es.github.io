<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíï ‚è¨ üçï Artigos da confer√™ncia de primavera C ++ R√∫ssia 2018 ü§ôüèΩ üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üï∏Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De 19 a 21 de abril, a confer√™ncia C ++ R√∫ssia 2018 foi realizada em S√£o Petersburgo. De ano para ano, a organiza√ß√£o e a conduta se tornam um n√≠vel su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Artigos da confer√™ncia de primavera C ++ R√∫ssia 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418645/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/if/m8/km/ifm8kmasjfgchispcdfdx3-2ax0.png"></div><br>  De 19 a 21 de abril, a confer√™ncia C ++ R√∫ssia 2018 foi realizada em S√£o Petersburgo. De ano para ano, a organiza√ß√£o e a conduta se tornam um n√≠vel superior, o que √© uma boa not√≠cia.  Agrade√ßo ao organizador permanente da C ++ Russia Sergey Platonov por sua contribui√ß√£o para o desenvolvimento desta √°rea. <br><a name="habracut"></a><br>  No dia 19 de abril, foram planejadas aulas de mestrado, das quais, infelizmente, n√£o pudemos comparecer, e nos dias 20 e 21, foi realizado o principal programa da confer√™ncia, do qual participamos com grande interesse.  Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Sermp</a> fez um √≥timo trabalho e atraiu v√°rios oradores estrangeiros not√°veis ‚Äã‚Äãcomo oradores.  O primeiro dia da confer√™ncia foi aberto por Jon Kalb, organizador do CppCon e autor do C ++ Today: The Beast is Back.  O segundo dia come√ßou com uma apresenta√ß√£o de Daveed Vandevoorde, membro do comit√™ de padroniza√ß√£o, um dos autores do C ++ Templates: The Complete Guide.  Andrei Alexandrescu estava no centro das aten√ß√µes, que, depois de seu relat√≥rio sobre exce√ß√µes, em certo momento reuniu uma multid√£o de pessoas que queriam obter um aut√≥grafo e tirar uma foto conjunta.  Pela primeira vez, uma palestra de Herb Sutter foi transmitida no Skype sobre o operador de nave espacial para C ++ 20. <br><br>  Embora a confer√™ncia tenha ocorrido h√° mais de tr√™s meses, o v√≠deo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lista de reprodu√ß√£o completa</a> ) foi postado agora, ent√£o √© hora de atualizar suas mem√≥rias e mergulhar nos incr√≠veis recursos do C ++. <br><br><h3>  Jon Kalb.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C ++ hoje: a fera est√° de volta</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/qj/4d/qxqj4duts1eygoh4trgst-2i8bw.png"></div><br>  Essa palestra aborda por que os engenheiros que procuram desempenho escolhem C ++.  Jon apresenta uma perspectiva hist√≥rica do C ++, concentrando-se no que est√° acontecendo na comunidade C ++ no momento e para onde est√° indo a linguagem e sua base de usu√°rios.  Com um interesse renovado no desempenho para data centers e dispositivos m√≥veis, e com o sucesso das bibliotecas de software de c√≥digo aberto, o C ++ est√° de volta e est√° quente.  Essa palestra explica por que o C ++ √© a linguagem preferencial dos engenheiros de software para desempenho.  Voc√™ receber√° um esbo√ßo hist√≥rico aproximado que coloca o C ++ em perspectiva e cobre sua popularidade altos e baixos. <br><br><h3>  Arno Sch√∂dl.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">De Iteradores a Intervalos</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g2/wi/1c/g2wi1czg7ulvtypu_8xqlz1irdo.png"></div><br>  Pares de iteradores s√£o onipresentes em toda a biblioteca C ++.  √â geralmente aceito que a combina√ß√£o desse par em uma √∫nica entidade, geralmente denominada Range, fornece c√≥digo mais conciso e leg√≠vel.  A defini√ß√£o da sem√¢ntica precisa desse conceito de alcance √© surpreendentemente complicada.  As considera√ß√µes te√≥ricas conflitam com as pr√°ticas.  Alguns objetivos de design s√£o completamente incompat√≠veis. <br><br><h3>  Jonathan Boccara.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">105 algoritmos STL em menos de uma hora</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jv/lf/ga/jvlfga-cdxxb3furo797y5ezpfy.png"></div><br>  Todos sabemos que devemos conhecer os algoritmos STL.  Inclu√≠-los em nossos projetos nos permite tornar nosso c√≥digo mais expressivo e mais robusto.  E √†s vezes, de uma maneira espetacular. <br><br>  Mas voc√™ conhece seus algoritmos STL? <br><br>  Nesta palestra, o autor apresenta 105 algoritmos que o STL possui atualmente, incluindo os adicionados em C ++ 11 e C ++ 17.  Por√©m, mais do que apenas uma lista, o objetivo desta palestra √© apresentar os diferentes grupos de algoritmos, os padr√µes que eles formam no STL e como os algoritmos se relacionam. <br><br>  Esse tipo de quadro geral √© a melhor maneira de lembrar de todos eles e constitui uma caixa de ferramentas repleta de maneiras de tornar nosso c√≥digo mais expressivo e robusto. <br><br><h3>  Viktor Kirilov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Compila√ß√£o interativa de C ++ (REPL): a maneira enxuta</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zz/bd/4w/zzbd4w9yrkytmf3aqgamwc6iafw.png"></div><br>  Sempre quis modificar algum valor ou executar alguma instru√ß√£o enquanto seu programa C ++ est√° sendo executado apenas para testar algo - n√£o √© trivial ou poss√≠vel com um depurador?  As linguagens de script possuem um REPL (read-eval-print-loop).  A coisa mais pr√≥xima que o C ++ tem √© o apego (desenvolvido por pesquisadores do CERN), mas √© constru√≠do sobre o LLVM e √© muito complicado de configurar.  O RCRL (Read-Compile-Run-Loop) √© um projeto de demonstra√ß√£o que mostra uma abordagem inovadora para fazer a compila√ß√£o de C ++ em tempo de execu√ß√£o de uma maneira independente de plataforma e compilador, que pode ser facilmente incorporada.  Nesta apresenta√ß√£o, √© mostrado como us√°-lo, como funciona e como pode ser modificado e integrado a qualquer aplicativo e fluxo de trabalho. <br><br><h3>  Victor Ciura.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">String_view suficiente para nos enforcarmos</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/gz/sl/bmgzslbc51pb7tc4f-jeaoywee4.png"></div><br>  N√£o seria bom se tiv√©ssemos um tipo C ++ padr√£o para representar strings?  Oh, espere ... n√≥s fazemos: std :: string.  N√£o seria bom se pud√©ssemos usar esse tipo padr√£o em todo o nosso aplicativo / projeto?  Bem ... n√£o podemos!  A menos que esteja escrevendo um aplicativo ou servi√ßo de console.  Mas, se estivermos escrevendo um aplicativo com GUI ou interagindo com APIs de SO modernas, √© prov√°vel que precisemos lidar com pelo menos um outro tipo de string C ++ n√£o padr√£o.  Dependendo da plataforma e do projeto, pode ser CString do MFC ou ATL, Platform :: String do WinRT, QString do Qt, wxString do wxWidgets, etc.  Ah, n√£o vamos esquecer nosso velho amigo const char *, melhor ainda const wchar_t * para a fam√≠lia C de APIs ... <br><br>  Ent√£o, acabamos com dois tipos de string em nossa base de c√≥digo.  OK, isso √© gerenci√°vel: mantemos std :: string para todo o c√≥digo independente de plataforma e convertemos para o outro XString ao interagir com APIs do sistema ou c√≥digo da GUI.  Faremos algumas c√≥pias desnecess√°rias ao atravessar esta ponte e terminaremos com algumas fun√ß√µes engra√ßadas manipulando dois tipos de strings;  mas isso √© cola, enfim ... certo? <br><br>  √â um bom plano ... at√© que nosso projeto cres√ßa e acumulemos muitos utilit√°rios e algoritmos de string.  Restringimos esses itens algor√≠tmicos a std :: string?  N√≥s recorremos ao denominador comum const char * e perdemos a seguran√ßa de tipo / mem√≥ria do nosso tipo C ++?  O C ++ 17 std :: string_view √© a resposta para todos os nossos problemas de string? <br><br>  O autor tenta explorar as op√ß√µes, em conjunto, com um estudo de caso em um aplicativo Windows de 15 anos: Advanced Installer (www.advancedinstaller.com) - um projeto C ++ desenvolvido ativamente, modernizado para C ++ 17, gra√ßas ao clang-tidy e "Clang Power Tools" ( <a href="">www.clangpowertools.com)</a> ... <br><br><h3>  Andrei Alexandrescu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Espere o esperado</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k4/76/5i/k4765i7g8pxr-u0qfvk433pbfnk.png"></div><br>  Escrever c√≥digo resiliente a erros sempre foi um problema em todos os idiomas.  As exce√ß√µes s√£o os meios politicamente corretos para sinalizar erros no C ++, mas muitos aplicativos ainda recorrem a c√≥digos de erro por motivos relacionados √† facilidade de entendimento, facilidade de manipula√ß√£o de erros localmente e efici√™ncia do c√≥digo gerado. <br><br>  Esta palestra mostra como uma variedade de artefatos te√≥ricos e pr√°ticos podem ser combinados para abordar c√≥digos de erro e exce√ß√µes em um pacote simples e saud√°vel.  O tipo gen√©rico Expected pode ser usado para modos local (estilo de c√≥digo de erro) e centralizado (estilo de exce√ß√£o), utilizando os pontos fortes de cada um. <br><br><h3>  Borislav Stanimirov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DynaMix: Uma nova vis√£o do polimorfismo</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2r/ji/ej/2rjiej_ldue2ztihyhwrgy7lhaa.png"></div><br>  Software com l√≥gica de neg√≥cios muito complexa, como jogos, sistemas CAD e sistemas corporativos, geralmente precisa compor e modificar objetos em tempo de execu√ß√£o - por exemplo, para adicionar ou substituir um m√©todo em um objeto existente.  O C ++ padr√£o possui tipos r√≠gidos que s√£o definidos em tempo de compila√ß√£o e dificultam isso.  Por outro lado, linguagens com tipos din√¢micos como lua, Python e JavaScript tornam isso muito f√°cil.  Portanto, para manter o c√≥digo leg√≠vel e de manuten√ß√£o e para cumprir requisitos complexos de l√≥gica de neg√≥cios, muitos projetos usam essas linguagens ao lado do C ++.  Algumas desvantagens dessa abordagem incluem a complexidade adicionada em uma camada de liga√ß√£o de idioma, a perda de desempenho do uso de uma linguagem interpretada e a inevit√°vel duplica√ß√£o de c√≥digo para muitas funcionalidades de utilidades pequenas. <br><br>  O DynaMix √© uma biblioteca que tenta remover, ou pelo menos reduzir bastante, a necessidade de uma linguagem de script separada, permitindo que os usu√°rios componham e modifiquem objetos polim√≥rficos em tempo de execu√ß√£o em C ++.  Essa palestra elabora esse problema e apresenta a biblioteca e seus principais recursos a usu√°rios ou pessoas em potencial que podem se beneficiar da abordagem com um exemplo anotado e uma pequena demonstra√ß√£o. <br><br><h3>  Mikhail Matrosov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C ++ vers√°til aplicado</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ao/ox/ha/aooxhajausoz9zfpywpbrsz8wsa.png"></div><br>  No C ++, voc√™ pode resolver uma √∫nica tarefa de v√°rias maneiras.  O autor escolhe uma tarefa real da produ√ß√£o e investiga como ela pode ser resolvida com v√°rias ferramentas fornecidas pelo C ++: cont√™ineres STL, boost.range, intervalos C ++ 20, corotinas.  Ele tamb√©m compara as restri√ß√µes da API e o desempenho de diferentes solu√ß√µes, e como elas podem ser facilmente convertidas de uma para outra, se o c√≥digo estiver bem estruturado.  Durante o processo, o autor tamb√©m explora aplicativos de alguns recursos √∫teis do C ++ 17, como constexpr if, instru√ß√µes de sele√ß√£o com inicializador, std :: not_fn, etc.  √â dada aten√ß√£o especial aos algoritmos de t√≥picos padr√£o. <br><br><h3>  Alexander Granin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Abordagem funcional da mem√≥ria transacional de software</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d-/ty/uh/d-tyuhxlhdvvelofkinuwnmpyl4.png"></div><br>  A programa√ß√£o paralela √© um t√≥pico muito multifacetado e profundo.  Ao longo das d√©cadas de pesquisa, um grande n√∫mero de abordagens, pr√°ticas e ferramentas foi desenvolvido, mas dificilmente podemos assumir que a linguagem C ++ acompanhou essas tend√™ncias.  Come√ßando com o padr√£o C ++ 11, conceitos como std :: thread, std :: atomic, std :: future, std :: mutex foram introduzidos e, no futuro, espera-se a adi√ß√£o de corotinas, um modelo de c√°lculos ass√≠ncronos.  Bem, essas s√£o coisas interessantes para estudar, mas o relat√≥rio se concentrar√° em uma id√©ia completamente diferente. <br><br>  A Mem√≥ria Transacional de Software (STM) - o conceito de um modelo de dados mut√°vel transacionalmente - existe h√° muito tempo e possui v√°rias implementa√ß√µes para todos os idiomas.  Usando o STM, voc√™ expressa seu modelo de dados e inicia a mudan√ßa em v√°rios segmentos, competitivamente, sem ter que se preocupar com a sincroniza√ß√£o de segmentos, o estado v√°lido dos dados ou bloqueios.  STM far√° tudo por voc√™.  Isso parece muito bom, mas nem todas as bibliotecas STM s√£o igualmente √∫teis.  Os STMs imperativos tradicionais s√£o muito complexos, propensos a erros multithread n√£o triviais e dif√≠ceis de usar.  Por outro lado, no mundo da programa√ß√£o funcional, o conceito de STM combinat√≥rio j√° existe h√° muito tempo, transa√ß√µes nas quais s√£o tijolos compost√°veis, a partir das quais voc√™ constr√≥i transa√ß√µes de um n√≠vel superior.  A abordagem combinat√≥ria do STM permite expressar um modelo de dados competitivo de maneira mais flex√≠vel, clara e confi√°vel.  A programa√ß√£o paralela tamb√©m pode ser agrad√°vel! <br><br>  No relat√≥rio, o autor falar√° sobre os recursos do STM combinat√≥rio, como us√°-lo e como ele pode ser implementado no C ++ 17. <br><br><h3>  Vadim Vinnik.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Processamento de cole√ß√£o.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ess√™ncia √∫nica, m√∫ltiplas manifesta√ß√µes</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xh/4-/09/xh4-09mvu7jukasuqttn0-ipifu.png"></div><br>  Ao longo de toda a hist√≥ria da programa√ß√£o, o processamento seq√ºencial de v√°rios tipos de cole√ß√µes tem sido e ainda √© uma das tarefas pr√°ticas mais comuns.  A representa√ß√£o interna das cole√ß√µes, bem como o algoritmo usado para buscar elementos subseq√ºentes, podem variar em uma variedade muito ampla: matriz, lista vinculada, √°rvore, tabela de hash, arquivo e outros.  No entanto, por tr√°s da variedade de idiomas, fun√ß√µes de biblioteca padr√£o, solu√ß√µes ad-hoc, pode-se revelar a ess√™ncia que permanece invari√°vel para toda essa classe de tarefas.  Esta palestra tem como objetivo mostrar uma transi√ß√£o passo a passo de algoritmos baseados na descri√ß√£o expl√≠cita de a√ß√µes sobre elementos individuais para ferramentas de processamento declarativas de alto n√≠vel que tratam uma cole√ß√£o como uma entidade e revelam adequadamente a l√≥gica do dom√≠nio. <br><br><h3>  Dmitry Banshchikov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bibliotecas compartilhadas sem depend√™ncias externas</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/75/rt/xn/75rtxnsxinft9v9g2bs2rtyc2sy.png"></div><br>  O autor contar√° sobre sua experi√™ncia no desenvolvimento de um mecanismo antiv√≠rus em C ++ na forma de uma biblioteca compartilhada.  Um recurso exclusivo √© a aus√™ncia de depend√™ncias externas (tempo de execu√ß√£o C ++ ou C).  Todo esse grupo √© criado com base no uso de uma cadeia de ferramentas personalizada no GCC para um destino especial, que o libc newlib vai usar para o mesmo destino, al√©m do qual o libstdc ++ √© criado.  Assim, a biblioteca compartilhada √© montada por meio de uma cadeia de ferramentas customizada com libgcc_s, libc, libcstdc ++ customizada (altera√ß√µes apenas na montagem).  Toda intera√ß√£o com o tempo de execu√ß√£o √© por meio da biblioteca compartilhada ABI.  Portanto, a biblioteca mant√©m a capacidade de usar C ++ moderno completo sem restri√ß√µes (RTTI, exce√ß√µes, iostream, etc.), que vai para libstdc ++ libc (newlib) |  l ibgcc-ABI.  Uma abordagem semelhante foi testada nas cadeias de ferramentas GCC / newlib / libstdc ++ para Linux e clang / newlib / libc ++ para MacOS.  O relat√≥rio pode ser de interesse para quem deseja usar C ++ em bibliotecas compartilhadas, mas n√£o pode pag√°-lo devido a depend√™ncias externas. <br><br><h3>  Ilya Shishkov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como ensinar a linguagem C ++: a experi√™ncia de criar cursos no Coursera</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sj/zk/e6/sjzke6dn32bnehol5pyaeg9bmpe.png"></div><br>  No √∫ltimo ano e meio, o autor liderou a cria√ß√£o da especializa√ß√£o Coursera em C ++ moderno.  A especializa√ß√£o consistir√° em cinco cursos, dois dos quais j√° est√£o em execu√ß√£o e outro est√° quase pronto. <br><br>  O relat√≥rio dir√°: <br><br><ul><li>  que problemas podem ser encontrados no trabalho em cursos (por exemplo, ap√≥s 3 meses de trabalho, os desenvolvedores jogaram fora todo o material e come√ßaram de novo) </li><li>  como o curr√≠culo √© formado e por que exatamente (por exemplo, por que a palavra "ponteiro" n√£o soou nos dois primeiros cursos nem uma vez) </li></ul><br>  Al√©m disso, durante o trabalho de especializa√ß√£o, foi desenvolvido um conjunto de princ√≠pios aplic√°veis ‚Äã‚Äãao trabalho cotidiano: <br><br><ul><li>  no processo de integra√ß√£o de um novo funcion√°rio ao projeto </li><li>  durante a revis√£o de c√≥digo </li><li>  ao contratar </li></ul><br>  Portanto, o autor n√£o apenas quer dizer como se especializa, mas tamb√©m tenta transferir a experi√™ncia adquirida para as tarefas di√°rias. <br><br><h3>  Ivan Ponomarev.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Relat√≥rios de falha no NDK do Android</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/yx/zc/h9yxzc_vcjlymv-gzh28xsaock4.png"></div><br>  N√£o √© segredo que o desenvolvimento em C / C ++ tem requisitos muito mais altos para a qualidade do c√≥digo do que o desenvolvimento em Java.  A probabilidade de cometer um erro fatal √© muito maior.  Ao mesmo tempo, coletar informa√ß√µes sobre esses erros √© uma tarefa n√£o trivial, mesmo para programadores experientes. <br><br>  Na primeira parte do relat√≥rio, analisaremos brevemente os desenvolvimentos existentes: como o depurador interno do Android funciona, que solu√ß√µes j√° existem.  A segunda parte √© dedicada √† hist√≥ria de como funciona "por baixo do cap√¥": como obter o estado do processador no momento do erro, como relaxar a pilha de chamadas, como descobrir os n√∫meros de linha no c√≥digo-fonte.  Uma vis√£o geral das bibliotecas de promo√ß√£o de pilha, como libcorkscrew, libunwind, libunwindstack, ser√° fornecida. <br><br>  O relat√≥rio ser√° de interesse dos desenvolvedores do Android, cujos aplicativos usam NDK, e de todos os outros para ampliar seus horizontes. <br><br><h3>  Fedor Short.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A mem√≥ria √© a abstra√ß√£o perfeita</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/yh/ns/tcyhnsqf9zd7owu6oylohlcgkqe.png"></div><br>  int * ptr = novo int; <br>  * ptr = 42; <br>  delete ptr; <br><br>  O que realmente acontece quando essas tr√™s linhas de c√≥digo s√£o executadas?  Examinaremos o alocador de mem√≥ria, o sistema operacional e o hardware moderno para dar uma resposta exaustiva a esta pergunta. <br><br><h3>  Alexey Salmin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dicas e truques de gerenciamento de mem√≥ria</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yi/re/ju/yirejuytypvwzo-ldwc-jmd4ylg.png"></div><br>  Em 2017, a quest√£o de escolher um alocador em C ++ n√£o perde relev√¢ncia.  Eles adicionaram uma nova maneira ao padr√£o de escolher um alocador local para cont√™ineres (std :: pmr), tcmalloc global e jemalloc continuam a evoluir, bem como as interfaces do kernel nas quais eles dependem.  Este relat√≥rio √© dedicado ao "andar inferior" deste design: os recursos do mmap e do madvise no kernel Linux e o impacto desses recursos no desempenho dos alocadores. <br><br><h3>  Herb Sutter.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Novo no C ++ 20: O operador de nave espacial</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/ex/dw/jhexdwnxovbsvpbtftm3jmrofr0.png"></div><br>  A nova nave espacial foi adotada recentemente como um recurso de linguagem para C ++ 20.  Nesta palestra, o designer e autor da proposta da nave espacial fornece uma vis√£o geral do recurso, discute sua motiva√ß√£o e design e apresenta exemplos de como us√°-lo.  Ele enfatiza particularmente como o recurso torna o c√≥digo C ++ mais limpo para escrever e ler, mais r√°pido, evitando trabalhos redundantes e mais robusto, evitando v√°rias armadilhas importantes, por√©m sutis, no c√≥digo mais fr√°gil que anteriormente t√≠nhamos que escrever manualmente sem esse recurso. <br><br><h3>  Anastasia Kazakova.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Depurando c√≥digo C ++ sem executar e compilar</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/at/na/ve/atnaverrgqdy-zv-xexxy6oan_g.png"></div><br>  Quando voc√™ olha para modelos, reflex√£o, gera√ß√£o de c√≥digo no est√°gio de compila√ß√£o, metaclasses, voc√™ sente que o C ++ se prop√¥s a tarefa de "ocultar" o c√≥digo final do desenvolvedor o m√°ximo poss√≠vel.  Um uso n√£o trivial do pr√©-processador (e v√°rias ramifica√ß√µes) pode tornar a sequ√™ncia do programa muito √≥bvia.  Obviamente, essas abordagens salvam os desenvolvedores de copiar e colar sem fim e repetir partes semelhantes da base de c√≥digo, mas requerem suporte mais avan√ßado nas ferramentas de desenvolvimento. <br><br>  √â poss√≠vel depurar o c√≥digo sem reinici√°-lo continuamente, sem um depurador e mesmo sem uma compila√ß√£o simples de toda a base de c√≥digo?  √â poss√≠vel encontrar erros no c√≥digo que n√£o podem ser montados ou executados na m√°quina local?  Existe!  Os Ambientes de Desenvolvimento Integrado (IDEs) t√™m amplo conhecimento e entendimento do c√≥digo personalizado e s√£o eles que podem fornecer as ferramentas apropriadas. <br><br>  Este relat√≥rio mostrar√° como se pode ‚Äúdepurar‚Äù as substitui√ß√µes de macro aninhadas pelo typedef, entender os tipos de vari√°veis ‚Äã‚Äã(que no C ++ moderno s√£o frequentemente ‚Äúocultas‚Äù), depurar diferentes ramos do pr√©-processador ou sobrecarga do operador e muito mais com a ajuda de um software verdadeiramente inteligente. IDE  Alguns dos recursos j√° est√£o dispon√≠veis no CLion e ReSharper C ++, e alguns s√£o apenas id√©ias interessantes para o futuro, que seriam interessantes para discutir com o p√∫blico. <br><br><h3>  Eugene Lukyanets.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Construir no Docker usando Conan</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kt/es/9y/ktes9yg6zny3qia9p2qd6mksxqm.png"></div><br>  A montagem de um projeto C ++ pode ser movida dentro do cont√™iner do docker, enquanto em vez de instalar as bibliotecas e depend√™ncias necess√°rias no sistema host, eles podem ser instalados diretamente na imagem do docker (por exemplo, Cuda) ou instalados usando o gerenciador C ++ da biblioteca Conan (por exemplo, Impulso).  Isso resulta em um ambiente controlado (e sempre o mesmo) isolado para a montagem, no qual voc√™ pode conectar o cache do Conan, para que projetos diferentes usando as mesmas bibliotecas usem as mesmas montagens.  Al√©m disso, a constru√ß√£o n√£o depende mais da distribui√ß√£o Linux em que o projeto est√° sendo constru√≠do, o principal √© que voc√™ pode executar o Docker nessa distribui√ß√£o. <br><br><h3>  Denis Panin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Metaprograma√ß√£o pr√°tica: escrevendo uma tabela de hash heterog√™nea</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/il/zf/8d/ilzf8daway7fam09ukocar1bdpw.png"></div><br>  No decorrer do relat√≥rio, escreveremos uma pequena biblioteca de trabalho com std :: tuple.  Usando esta biblioteca, compilamos o tempo de compila√ß√£o em uma tabela de hash heterog√™nea.  Al√©m disso - em sua base, escreveremos uma pequena estrutura RPC, usando o fato de n√£o termos apagamento de tipo. <br><br>  Haver√° muitos c√°lculos constexpr, modelos e novos recursos no C ++ 17 (especificamente, se constexpr). <br><br><h3>  Dmitry Sokolov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gera√ß√£o de c√≥digo como reflexo para os pobres</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m6/cy/ey/m6cyeyyxuncuuz_jzzlzzcwj8q8.png"></div><br>  Muitas vezes, √© necess√°ria reflex√£o para generalizar algoritmos de serializa√ß√£o.  Implementa√ß√£o de v√°rios protocolos, trabalho com bancos de dados.  Para resolver esses problemas, escrevemos um compilador homebrew IDL para gerar estruturas C ++ e uma biblioteca para interagir com o resultado.  Protobuf com pedais e se valeu a pena. <br><br><h3>  Daveed Vandevoorde.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Metaprograma√ß√£o Reflexiva em C ++</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5c/ho/ie/5choiecmddpmcbekwyekclxdmlq.png"></div><br>  H√° algum tempo, o comit√™ de padroniza√ß√£o do C ++ criou um subgrupo "SG-7" para explorar como adicionar recursos de reflex√£o √† linguagem.  Mais recentemente, esse grupo adicionou "metaprograma√ß√£o" ao seu prato e tomou algumas decis√µes significativas em rela√ß√£o ao formato da solu√ß√£o final.  Nesta palestra, o autor examina o passado que nos trouxe aqui e examina um poss√≠vel caminho para o suporte de primeira classe de C ++ √† "metaprograma√ß√£o reflexiva". <br><br><h3>  Dietmar K√ºhl.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste Baseado em Conceito</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/st/sa/3s/stsa3scg4ux8lm4x7avft5qzabg.png"></div><br>  Com os conceitos sendo adicionados √† pr√≥xima revis√£o do C ++, espera-se que novos conceitos sejam definidos.  Cada conceito define um conjunto de opera√ß√µes usadas pelo c√≥digo gen√©rico.  Um desses usos pode ser um teste gen√©rico, verificando se todas as partes de um conceito est√£o definidas e verificando intera√ß√µes gen√©ricas entre as opera√ß√µes de um conceito.  O ideal √© que esse teste funcione com classes apenas modelando parcialmente um conceito para orientar a implementa√ß√£o de classes. <br><br>  Esta apresenta√ß√£o n√£o usa as extens√µes de conceito reais, mas mostra como testes gen√©ricos podem ser criados usando os recursos do C ++ 17.  Para os testes gen√©ricos, o idioma de detec√ß√£o e o constexpr s√£o usados ‚Äã‚Äãpara determinar a disponibilidade das opera√ß√µes necess√°rias e lidar com a abund√¢ncia de opera√ß√µes.  Os testes gen√©ricos devem ser capazes de cobrir o b√°sico de classes que modelam um conceito.  Obviamente, o comportamento espec√≠fico das classes ainda exigir√° testes correspondentes. <br><br><h3>  Simon Brand  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Paralelismo moderno em C ++ da CPU √† GPU</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/qz/st/qqqzstnuzvnt3ev15p-9hngj3iy.png"></div><br>  A programa√ß√£o paralela pode ser usada para tirar proveito das arquiteturas multic√™ntricas e heterog√™neas e pode aumentar significativamente o desempenho do software.  O C ++ moderno foi um longo caminho para tornar a programa√ß√£o paralela mais f√°cil e mais acess√≠vel;  fornecendo abstra√ß√µes de alto e baixo n√≠vel.  O C ++ 17 leva isso adiante, fornecendo algoritmos paralelos de alto n√≠vel, e muito mais √© esperado no C ++ 20.  Esta palestra fornece uma vis√£o geral dos atuais utilit√°rios de paralelismo dispon√≠veis e analisa o futuro de como GPUs e sistemas heterog√™neos podem ser suportados por meio de novos recursos de biblioteca padr√£o e outros padr√µes como SYCL. <br><br><h3>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C ++ eficaz (Maers n√£o tem nada a ver com isso :)</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rb/lp/mu/rblpmu6fzwwn7hnt3cim-pipjf0.png"></div><br>  A linguagem C ++ e a infraestrutura em torno dela continuam evoluindo, o que torna essa linguagem uma das ferramentas mais eficazes no momento.  Gostaria de destacar tr√™s fatores que tornam a linguagem C ++ agora t√£o atraente. <br><br><ul><li>  Primeiro: inova√ß√µes no padr√£o da linguagem, permitindo escrever c√≥digo eficiente. </li><li>  Segundo: a maturidade das ferramentas de desenvolvimento e um aumento na velocidade de montagem dos projetos. </li><li>  Terceiro: ferramentas de suporte avan√ßadas que permitem controlar a qualidade do c√≥digo e outros aspectos do ciclo de vida do projeto. </li></ul><br>  Este relat√≥rio √© uma ode √† linguagem de programa√ß√£o C ++! <br><br><h3>  Ivan Puzyrevsky.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Assincronia na programa√ß√£o</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/vx/iw/3gvxiw02427rxts0p3nza4kburu.png"></div><br>  No campo do desenvolvimento de aplicativos multithread ou distribu√≠dos altamente carregados, √© poss√≠vel ouvir cada vez mais conversas sobre c√≥digo ass√≠ncrono, incluindo especula√ß√µes sobre a necessidade (falta de necessidade) de levar em considera√ß√£o a assincronia no c√≥digo, sobre a compreensibilidade (incompreensibilidade) do c√≥digo ass√≠ncrono e sua efici√™ncia (inefici√™ncia).  Neste relat√≥rio, tentaremos aprofundar a √°rea de assunto: analisaremos o que √© assincronia;  quando surge;  como isso afeta o c√≥digo que escrevemos e a linguagem de programa√ß√£o que usamos.  Vamos tentar descobrir o que os futuros e promessas t√™m a ver com isso, vamos falar um pouco sobre corotinas e atores.  Iremos afetar o JavaScript e os sistemas operacionais.  O objetivo do relat√≥rio √© tornar mais expl√≠citos os compromissos que surgem com uma ou outra abordagem para o desenvolvimento de software distribu√≠do ou multithread. <br><br><h3>  Pavel Bulatov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mudando para o WebAssembly: o jogo vale a pena?</a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/s6/ga/vts6gamnunde4u6qzk6p_4zqc6c.png"></div><br>  O relat√≥rio discutir√° o estado atual do WebAssembly em rela√ß√£o a produtos reais.  Falaremos sobre nossa experi√™ncia de portar o aplicativo, sobre quais problemas surgiram e como os resolvemos. <br><br>  Os t√≥picos abordados incluem: <br><br><ul><li>  Suporte para o padr√£o em diferentes plataformas e navegadores. </li><li>  Desempenho e tamanho da constru√ß√£o versus asm.js. </li><li>  Intera√ß√µes com o navegador. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Construir falhas do usu√°rio. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recursos da VM. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry Kozhevnikov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMake armadilhas e onde eles moram</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zt/_l/qr/zt_lqrmu-qimm8_m2z7g_zd2xsg.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O sistema de cria√ß√£o do CMake est√° gradualmente se tornando o padr√£o de fato para a programa√ß√£o C ++ entre plataformas. </font><font style="vertical-align: inherit;">No entanto, muitas vezes √© criticado de maneira justa, incluindo a linguagem de script inconveniente, a documenta√ß√£o desatualizada e o fato de que as mesmas tarefas podem ser executadas de maneiras diferentes, e pode ser bastante dif√≠cil entender qual √© a mais correta em uma situa√ß√£o espec√≠fica . </font><font style="vertical-align: inherit;">O autor dir√°:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anti-padr√µes populares freq√ºentes e por que eles s√£o ruins, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em que n√≠veis de abstra√ß√£o o CMake funciona e quando "vazam", </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o que √© o "Modern CMake" e quais s√£o suas vantagens, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como localizar e depurar problemas nos scripts do CMake (incluindo alguns bastante ex√≥ticos). </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Shambir. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando C ++ procedural √© bom</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/ib/vy/kxibvyhzvf5taodgpswkywptk9y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A arquitetura limpa do projeto, abstra√ß√µes simples em cada camada √© o sonho de qualquer equipe. </font><font style="vertical-align: inherit;">Para realizar esse sonho, muitas t√©cnicas orientadas a objetos foram inventadas. </font><font style="vertical-align: inherit;">Levados pelo OOP, os desenvolvedores esquecem de monitorar a limpeza do c√≥digo na jun√ß√£o de C e C ++. </font><font style="vertical-align: inherit;">√â aqui que o estilo processual ajudar√° a restaurar a ordem, criar abstra√ß√µes convenientes e seguras que se encaixam facilmente no c√≥digo orientado a objeto do projeto. </font><font style="vertical-align: inherit;">Vamos descobrir:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por que voc√™ precisa isolar a API C (como winapi, POSIX, SQLite, OpenGL, OpenSSL) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por que OOP funciona mal neste neg√≥cio </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como escrever uma camada de abstra√ß√£o em cima da API de estilo C </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como lidar com retornos de chamada, tratamento de erros e gerenciamento de recursos para tornar compreens√≠vel o c√≥digo tradicionalmente complexo e confuso, mesmo para jovens </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evgeny Zuev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API sem√¢ntica para programas C ++</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-e/wb/d4/-ewbd4monfzqy8msagott8iaxzu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seus interesses profissionais s√£o a sem√¢ntica de linguagens de programa√ß√£o, o design e a implementa√ß√£o de compiladores do YaP e outras ferramentas orientadas a linguagem. </font><font style="vertical-align: inherit;">Entre as realiza√ß√µes mais significativas est√£o a participa√ß√£o em projetos como a cria√ß√£o de um compilador do padr√£o completo da linguagem C ++ (Interstron, Moscou, 2000), a implementa√ß√£o do compilador da linguagem Zonnon para .NET (ETH Zurich, 2005) e a implementa√ß√£o do prot√≥tipo Swift para a plataforma Tizen ( Samsung Research Institute, Moscou, 2015).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ivan ƒåukiƒá. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2020: Uma odiss√©ia no vazio</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/_4/qw/lz_4qwm76c6mz0aadcqwqcd8av8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O C ++ sempre teve uma poderosa sub-linguagem de metaprograma√ß√£o que permitiu que os desenvolvedores de bibliotecas realizassem proezas m√°gicas como introspec√ß√£o est√°tica para obter execu√ß√£o polim√≥rfica sem heran√ßa. </font><font style="vertical-align: inherit;">O problema era que a sintaxe era estranha e desnecessariamente detalhada, o que tornava a aprendizagem de metaprograma√ß√£o uma tarefa assustadora. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com as recentes melhorias no padr√£o e com os recursos planejados para o C ++ 20, a metaprograma√ß√£o ficou muito mais f√°cil, e os metaprogramas ficaram mais f√°ceis de entender e raciocinar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta palestra, o autor apresenta algumas t√©cnicas modernas de metaprograma√ß√£o, com foco principal na meta-fun√ß√£o m√°gica void_t.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evgeny Okhotnikov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atores de C ++: Valeu a pena?</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9t/tn/tw/9ttntwqtinuogjfwkd0jjbqn8ko.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O autor do relat√≥rio √© respons√°vel pelo desenvolvimento da estrutura SObjectizer de c√≥digo-fonte aberto h√° 16 anos. </font><font style="vertical-align: inherit;">Essa √© uma das poucas estruturas de ator de plataforma cruzada em desenvolvimento e em desenvolvimento para C ++. </font><font style="vertical-align: inherit;">O desenvolvimento do SObjectizer come√ßou no ano de 2002, quando o C ++ estava entre as linguagens de programa√ß√£o mais populares e comuns. </font><font style="vertical-align: inherit;">Nos √∫ltimos tempos, o C ++ mudou muito e a atitude em rela√ß√£o ao C ++ mudou ainda mais. </font><font style="vertical-align: inherit;">O relat√≥rio discutir√° como essas mudan√ßas afetaram o desenvolvimento de uma ferramenta com um hist√≥rico de 16 anos e qu√£o simples e conveniente foi criar essa ferramenta para a linguagem C ++. </font><font style="vertical-align: inherit;">E se era necess√°rio criar essa ferramenta para C ++ em geral.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rainer Grimm. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√°ticas recomendadas para simultaneidade em C ++ moderno</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yk/12/j2/yk12j2luup7tzp2at0vt9epwr6m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com a padroniza√ß√£o do C ++ 11, obtivemos no C ++ uma biblioteca multithreading e um modelo de mem√≥ria. </font><font style="vertical-align: inherit;">A biblioteca possui os blocos de constru√ß√£o b√°sicos, como at√¥micas, encadeamentos, tarefas, bloqueios e vari√°veis ‚Äã‚Äãde condi√ß√£o. </font><font style="vertical-align: inherit;">O modelo de mem√≥ria fornece garantias para o uso seguro de thread desses componentes b√°sicos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sete anos depois, temos muitas pr√°ticas recomendadas para aplicar o multithreading e o modelo de mem√≥ria de maneira segura. </font><font style="vertical-align: inherit;">A palestra do autor √© precisamente sobre essas pr√°ticas recomendadas para regras gerais de concorr√™ncia, regras especiais para a biblioteca multithreading e regras especiais para o modelo de mem√≥ria. </font><font style="vertical-align: inherit;">O foco dessas pr√°ticas recomendadas est√° muito al√©m do C ++.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexey Malov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experi√™ncia no uso de C ++ moderno no desenvolvimento de aplicativos de desktop</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uu/te/59/uute59evuanipkaccp6qabg1ari.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A palestra ser√° sobre as ferramentas da linguagem C ++ e as bibliotecas Boost e STL, bem como sobre abordagens arquiteturais para a cria√ß√£o de aplicativos GUI que usamos para desenvolver uma ferramenta para a cria√ß√£o de videoaulas. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pratique usando o padr√£o Model-View-Presenter </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerenciamento de ciclo de vida de documentos </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Armazenamento de arquivos de ponteiros inteligentes </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Vasiliev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An√°lise est√°tica: procurando bugs ... e vulnerabilidades?</font></font></a> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z7/it/1h/z7it1hjlb46zf_4xp1pvsqlyqbq.png"></div><br>  Not√≠cias sobre a pr√≥xima vulnerabilidade encontrada regularmente s√£o exibidas aqui e ali.  As perdas colaterais de $, como regra, s√£o enormes.  Portanto, em vez de corrigir vulnerabilidades, elas n√£o devem aparecer. <br><br>  Uma maneira de lidar com erros no c√≥digo √© usar a an√°lise est√°tica.  Mas qu√£o adequado √© procurar vulnerabilidades?  E existe realmente uma grande diferen√ßa entre bugs simples e vulnerabilidades de c√≥digo? <br><br>  Discutiremos essas quest√µes durante o relat√≥rio e, ao mesmo tempo, falaremos sobre como usar a an√°lise est√°tica para tirar o m√°ximo proveito dela. <br><br>  <b>PS</b> <br><br>  Por conta pr√≥pria, quero chamar sua aten√ß√£o para a mini-intriga em torno de <i>std :: string</i> relacionada aos relat√≥rios da minha colega Andrei Karpov.  Ent√£o, em ordem: <br><br><ol><li>  Um fragmento do relat√≥rio de Andrei (C ++ R√∫ssia 2016) "Contos particulares de desenvolvedores de analisadores de c√≥digo" de 30:05 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> . </li><li>  Trolling f√°cil de pessoas como n√≥s por Anton Polukhin (C ++ R√∫ssia 2017) no relat√≥rio ‚ÄúComo n√£o fazer: constru√ß√£o de bicicletas em C ++ para profissionais‚Äù a partir das 2:00 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> . </li><li>  A hist√≥ria de Andrey na confer√™ncia C ++ Russia 2018 de que n√£o somos dinossauros e estamos aprendendo uma coisa nova: "C ++ eficaz" a partir das 12:21 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> . </li></ol><br>  Isso √© tudo!  Aproveite seus relat√≥rios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418645/">https://habr.com/ru/post/pt418645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418635/index.html">Criando uma m√°quina de arcade emulador. Parte 1</a></li>
<li><a href="../pt418637/index.html">Kubernetes para as massas: Slurm come√ßa em 3 de agosto</a></li>
<li><a href="../pt418639/index.html">Akka Streams para meros mortais</a></li>
<li><a href="../pt418641/index.html">Um erro que impede um designer de crescer</a></li>
<li><a href="../pt418643/index.html">Sit vs stand: como trabalhar melhor?</a></li>
<li><a href="../pt418647/index.html">TESS lan√ßa pesquisa de exoplanetas</a></li>
<li><a href="../pt418649/index.html">A gera√ß√£o cont√≠nua de vers√µes alternativas do TLS resolver√° o problema de ossifica√ß√£o do protocolo antigo</a></li>
<li><a href="../pt418651/index.html">Eventos digitais em Moscou, de 30 de julho a 5 de agosto</a></li>
<li><a href="../pt418653/index.html">O WebAssembly est√° retornando miniaplicativos Java e Flash?</a></li>
<li><a href="../pt418655/index.html">Realidade mista do Windows: um guia do desenvolvedor (parte 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>