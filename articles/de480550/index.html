<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÅ üë®üèª‚Äç‚öïÔ∏è üôåüèø Hallo Welt von Bytecode f√ºr JVM üê¢ ü§µüèΩ üé¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir kompilieren ein einfaches Programm, das "Hello World" anzeigt und dessen Struktur durchl√§uft 


 Ich denke nicht, dass der Artikel ausreichend inf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hallo Welt von Bytecode f√ºr JVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480550/"><p>  Wir kompilieren ein einfaches Programm, das "Hello World" anzeigt und dessen Struktur durchl√§uft </p><br><p>  Ich denke nicht, dass der Artikel ausreichend informativ ist f√ºr diejenigen, die nicht oberfl√§chlich wissen, wie der Bytecode aussieht und wie die JVM damit arbeitet (zum Beispiel die einfachsten Anweisungen (Kenntnisse √ºber ihre Existenz)). </p><br><p> In der Tat ist es nicht so schwierig.  Es reicht aus, das <code>javap</code> Tool aus dem JDK zu verwenden und den disassemblierten Code zu ber√ºcksichtigen. </p><br><p>  Und wir werden anfangen, die Struktur des Bytecodes f√ºr die JVM zu analysieren </p><a name="habracut"></a><br><p>  Ein sehr n√ºtzliches Buch daf√ºr war die offizielle JVM-Spezifikation - The Java Virtual Machine Specification bei <a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">oracle</a> </p><br><p>  Erstellen Sie zun√§chst ein einfaches Programm: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String ... args)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>); } }</code> </pre><br><p>  Kompilieren Sie es mit dem <code>javac Main.java</code> Team und nehmen Sie die Demontage vor </p><br><pre> <code class="plaintext hljs"> javap -c -v Main</code> </pre> <br><p>  <em>Hauptklasse</em> </p><br><pre> <code class="plaintext hljs">Classfile /C:/Users/Arthur/playground/java/jvm/Main.class Last modified 26.10.2019; size 413 bytes MD5 checksum 6449121a3bb611fee394e4f322401ee1 Compiled from "Main.java" public class Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Main #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 Main.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 Hello World #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 Main #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V { public Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String...); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC, ACC_VARARGS Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello World 5: invokevirtual #4// Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 4: 0 line 5: 8 } SourceFile: "Main.java"</code> </pre><br><p>  Dies ist nur eine Bytecode-Darstellung, die f√ºr eine Person leichter zu sehen ist als der urspr√ºngliche Bytecode, die jedoch anders aussieht: </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d 0a00 0600 0f09 0010 0011 0800 120a 0013 0014 0700 1507 0016 0100 063c 696e 6974 3e01 0003 2829 5601 0004 436f 6465 0100 0f4c 696e 654e 756d 6265 7254 6162 6c65 0100 046d 6169 6e01 0016 285b 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 2956 0100 0a53 6f75 7263 6546 696c 6501 0009 4d61 696e 2e6a 6176 610c 0007 0008 0700 170c 0018 0019 0100 0b48 656c 6c6f 2057 6f72 6c64 0700 1a0c 001b 001c 0100 044d 6169 6e01 0010 6a61 7661 2f6c 616e 672f 4f62 6a65 6374 0100 106a 6176 612f 6c61 6e67 2f53 7973 7465 6d01 0003 6f75 7401 0015 4c6a 6176 612f 696f 2f50 7269 6e74 5374 7265 616d 3b01 0013 6a61 7661 2f69 6f2f 5072 696e 7453 7472 6561 6d01 0007 7072 696e 746c 6e01 0015 284c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b29 5600 2100 0500 0600 0000 0000 0200 0100 0700 0800 0100 0900 0000 1d00 0100 0100 0000 052a b700 01b1 0000 0001 000a 0000 0006 0001 0000 0001 0089 000b 000c 0001 0009 0000 0025 0002 0001 0000 0009 b200 0212 03b6 0004 b100 0000 0100 0a00 0000 0a00 0200 0000 0400 0800 0500 0100 0d00 0000 0200 0e</code> </pre> <br><p>  (Sie k√∂nnen Ihre <code>.class</code> Datei √ºber Sublime Text √∂ffnen, der File-&gt; Save with Encoding -&gt; Hexademical anzeigt.) </p><br><p>  Wir werden mit diesem Code arbeiten. </p><br><p>  Aber zuerst m√ºssen wir es formatieren, um nicht zu verwechseln, wo es ist, und der Bytecode hat tats√§chlich eine sehr starre Struktur: </p><br><pre> <code class="plaintext hljs"> ClassFile { u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; }</code> </pre> <br><p>  Sie finden es in der JVM-Spezifikation in <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Kapitel 4.1 Die ClassFile-Struktur</a> </p><br><p>  Hier ist alles einfach - die Dimension in Bytes ist links und die Beschreibung rechts angegeben. </p><br><p>  Wir analysieren den Bytecode in hexadezimaler Schreibweise, wobei jede Ziffer 4 Bits ben√∂tigt, also f√ºr zwei Bytes - 4 Ziffern und f√ºr vier Bytes - 8 Ziffern. </p><br><p>  <strong>Magie</strong> </p><br><p>  Magie ist ein Wert, der das Format unserer Klasse kennzeichnet.  Es ist gleich <code>0xCAFEBABE</code> , das eine eigene <a href="https://en.wikipedia.org/wiki/Java_class_file">Sch√∂pfungsgeschichte hat</a> . </p><br><p>  <strong>minor_version, major_version</strong> </p><br><p>  Dies sind Versionen Ihrer <code>class</code> .  Wenn wir <code>major_version</code> M und <code>minor_version</code> m <code>minor_version</code> , erhalten wir die Version unserer <code>class</code> als <code>Mm</code> </p><br><p>  Jetzt werde ich sofort Beispiele aus unserem Programm "Hello World" geben, um zu sehen, wie sie verwendet werden: </p><br><pre> <code class="plaintext hljs"> cafe babe -- magic 0000 -- minor_version 0034 -- major_version</code> </pre> <br><p>  Wir k√∂nnen es im disassemblierten Code sehen, aber bereits im Dezimalzahlensystem: </p><br><pre> <code class="plaintext hljs"> ... public class Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ...</code> </pre> <br><p>  <strong>constant_pool_count</strong> </p><br><p>  Hier wird die Anzahl der Variablen im Konstantenpool angegeben.  Zur gleichen Zeit, wenn Sie sich entscheiden, Code in reinem Bytecode zu schreiben, m√ºssen Sie auf jeden Fall seinen Wert √ºberwachen, denn wenn Sie den falschen Wert angeben, wird das gesamte Programm zur H√∂lle (√ºberpr√ºft!). </p><br><p>  Vergessen Sie auch nicht, dass Sie dort die Anzahl_Variablen_ in den <code>___ + 1</code> schreiben sollten </p><br><p>  Insgesamt bekommen wir: </p><br><pre> <code class="plaintext hljs"> cafe babe -- magic 0000 0034 -- version 001d -- constant_pool_count</code> </pre> <br><p>  <strong>constant_pool []</strong> </p><br><p>  Jeder Variablentyp im Konstantenpool hat eine eigene Struktur: </p><br><pre> <code class="plaintext hljs"> cp_info { u1 tag; u1 info[]; }</code> </pre> <br><p>  Hier muss alles nacheinander erledigt werden.  Zuerst lesen wir <code>tag</code> , um den Typ der Variablen herauszufinden, und anhand des Typs dieser Variablen untersuchen wir, welche Struktur ihr nachfolgender Wert <code>info[]</code> </p><br><p>  Eine Tabelle mit Tags finden Sie in der Spezifikation <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Tabelle 4.3 Konstantenpool-Tags</a> . </p><br><p>  Eigentlich ist hier das Tablet: </p><br><div class="scrollable-table"><table><thead><tr><th>  Konstanter Typ </th><th>  Wert </th></tr></thead><tbody><tr><td> <code>CONSTANT_Class</code> </td> <td>  7 </td></tr><tr><td> <code>CONSTANT_Fieldref</code> </td> <td>  9 </td></tr><tr><td> <code>CONSTANT_Methodref</code> </td> <td>  10 </td></tr><tr><td> <code>CONSTANT_InterfaceMethodref</code> </td> <td>  11 </td></tr><tr><td> <code>CONSTANT_String</code> </td> <td>  8 </td></tr><tr><td> <code>CONSTANT_Integer</code> </td> <td>  3 </td></tr><tr><td> <code>CONSTANT_Float</code> </td> <td>  4 </td></tr><tr><td> <code>CONSTANT_Long</code> </td> <td>  5 </td></tr><tr><td> <code>CONSTANT_Double</code> </td> <td>  6 </td></tr><tr><td> <code>CONSTANT_NameAndType</code> </td> <td>  12 </td></tr><tr><td> <code>CONSTANT_Utf8</code> </td> <td>  1 </td></tr><tr><td> <code>CONSTANT_MethodHandle</code> </td> <td>  15 </td></tr><tr><td> <code>CONSTANT_MethodType</code> </td> <td>  16 </td></tr><tr><td> <code>CONSTANT_InvokeDynamic</code> </td> <td>  18 </td></tr></tbody></table></div><br><p>  Wie bereits erw√§hnt, hat jeder Konstantentyp eine eigene Struktur. </p><br><p>  Hier ist zum Beispiel die <code>CONSTANT_Class</code> Struktur: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Class_info { u1 tag; u2 name_index; }</code> </pre> <br><p>  Feld- und Methodenstruktur: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Fieldref_info { u1 tag; u2 class_index; u2 name_and_type_index; } CONSTANT_Methodref_info { u1 tag; u2 class_index; u2 name_and_type_index; }</code> </pre> <br><p>  Hierbei ist zu beachten, dass unterschiedliche Strukturen unterschiedliche L√§ngen haben k√∂nnen. </p><br><p>  Betrachten Sie einen Teil unseres Codes: </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d -- constant_pool_count 0a00 0600 0f09 0010 0011 0800 12 ...</code> </pre> <br><p>  Wir sehen uns also die Struktur der Konstanten an und stellen fest, dass das erste Byte f√ºr den Konstantentyp reserviert ist.  Hier sehen wir <code>0a</code> (10) - und daher ist es <code>CONSTANT_Methodref</code> </p><br><p>  Wir betrachten seine Struktur: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Methodref_info { u1 tag; u2 class_index; u2 name_and_type_index; }</code> </pre> <br><p>  Nach einem Byte f√ºr das Tag ben√∂tigen wir 4 weitere Bytes f√ºr <code>class_index</code> und <code>name_and_type_index</code> </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d -- constant_pool_count 0a 0006 000f -- CONSTANT_Methodref 0900 1000 1108 0012 ...</code> </pre> <br><p>  Nun, wir haben einen der Werte des konstanten Pools gefunden.  Mach weiter.  Wir schauen, <code>09</code> - bedeutet den Typ <code>CONSTANT_Fieldref</code> </p><br><p>  Wir bekommen: </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d -- constant_pool_count 0a 0006 000f -- CONSTANT_Methodref 09 0010 0011 -- CONSTANT_Fieldref 08 0012 ...</code> </pre> <br><p>  Sie k√∂nnten denken, dass die meisten Typen dieselbe Form haben, aber dies ist nicht der Fall. <br>  Beispielsweise sieht eine Struktur des folgenden Typs wie <code>CONSTANT_String</code> : </p><br><pre> <code class="plaintext hljs"> CONSTANT_String_info { u1 tag; u2 string_index; }</code> </pre> <br><p>  Alle diese Strukturen finden Sie in <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Kapitel 4.4 Der Konstantenpool.</a> </p><br><p>  Nun wollen wir sehen, was Typen in <code>info</code> selbst bedeuten. </p><br><p>  Methoden, die unter das Muster <code>*_index</code> , enthalten normalerweise die Adresse aus der Konstantenpooltabelle.  Zum Beispiel <code>class_index</code> f√ºr einen Wert vom Typ <code>CONSTANT_Class_info</code> und <code>string_index</code> f√ºr einen <code>string_index</code> <code>CONSTANT_Utf8_info</code> </p><br><p>  Wir k√∂nnen dies im disassemblierten Code sehen: </p><br><pre> <code class="plaintext hljs"> #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18</code> </pre> <br><pre> <code class="plaintext hljs"> 0a 0006 000f -- CONSTANT_Methodref 09 0010 0011 -- CONSTANT_Fieldref 08 0012 -- CONSTANT_String</code> </pre> <br><p>  Sie k√∂nnen auch die Darstellung von Zahlen und Zeichenfolgen hervorheben. </p><br><p>  Sie k√∂nnen die Darstellung von Zahlen ab Kapitel <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">4.4.4</a> nachlesen, aber wir werden vorerst nur die Zeilen analysieren, da die Zahlen noch nicht im Hello World-Programm enthalten sind </p><br><p>  Eigentlich sieht die Zeile so aus: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Utf8_info { u1 tag; u2 length; u1 bytes[length]; }</code> </pre> <br><p>  Zum Beispiel unsere Hallo Welt: </p><br><pre> <code class="plaintext hljs"> 01 -- tag 000b -- length 48 65 6c 6c 6f 20 57 6f 72 6c 64 -- bytes[length] // H ello W orld</code> </pre> <br><p>  Wenn wir den gesamten Pool von Bytecode-Konstanten analysieren, erhalten wir: </p><br><div class="spoiler">  <b class="spoiler_title">Der ganze Konstantenpool</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> -- [Constant Pool] -- methodref 0a 0006 000f -- fieldref 09 0010 0011 -- string 08 0012 -- methodref 0a 0013 0014 -- Class 07 0015 -- Class 07 0016 -- Utf8 01 0006 3c 69 6e 69 74 3e -- Utf8 01 0003 28 29 56 -- Utf8 01 0004 43 6f 64 65 -- Utf8 01 000f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 -- Utf8 01 0004 6d 61 69 6e -- Utf8 01 0016 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 -- Utf8 01 000a 53 6f 75 72 63 65 46 69 6c 65 -- Utf8 01 0009 4d 61 69 6e 2e 6a 61 76 61 -- NameAndType 0c 0007 0008 -- Class 07 0017 -- NameAndType 0c 0018 0019 -- Utf8 01 000b 48 65 6c 6c 6f 20 57 6f 72 6c 64 -- Class 07 001a -- NameAndType 0c 001b 001c -- Utf8 01 0004 4d 61 69 6e -- Utf8 01 0010 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 -- Utf8 01 0010 6a 61 76 61 2f 6c 61 6e 67 2f 53 79 73 74 65 6d -- Utf8 01 0003 6f 75 74 -- Utf8 01 0015 4c 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 3b -- Utf8 01 0013 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d -- Utf8 01 0007 70 72 69 6e 74 6c 6e -- Utf8 01 0015 28 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 -- [Constant Pool END]</code> </pre> </div></div><br><p>  Wir k√∂nnen es auch mit disassembliertem Code vergleichen: </p><br><pre> <code class="plaintext hljs"> Constant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Main #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 Main.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 Hello World #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 Main #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V</code> </pre> <br><p>  Dabei wird gepr√ºft, ob alles passt, denn tats√§chlich verarbeitet <code>javap</code> diesen Bytecode einfach und zeigt ihn uns formatiert an. </p><br><p>  Der konstante Pool wird f√ºr Anweisungen ben√∂tigt.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs"> public Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 //    1    4: return</code> </pre> <br><p>  Weitere Informationen zu allen Typen im Konstantenpool finden Sie in <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Kapitel 4.4 Der Konstantenpool.</a> </p><br><p>  Weiter in der <em>ClassFile-</em> Struktur </p><br><p>  <strong>access_flags</strong> </p><br><p>  Dies ist eine Bitmaske f√ºr Modifizierereigenschaften. </p><br><div class="scrollable-table"><table><thead><tr><th>  Fahnenname </th><th>  Wert </th><th>  Interpretation </th></tr></thead><tbody><tr><td> <code>ACC_PUBLIC</code> </td> <td>  0x0001 </td><td>  <code>public</code> erkl√§rt;  kann von au√üerhalb des Pakets zugegriffen werden. </td></tr><tr><td> <code>ACC_FINAL</code> </td> <td>  0x0010 </td><td>  F√ºr <code>final</code> erkl√§rt;  Keine Unterklassen erlaubt. </td></tr><tr><td> <code>ACC_SUPER</code> </td> <td>  0x0020 </td><td>  Behandeln Sie Methoden der Oberklasse besonders, wenn sie von der Anweisung <em>invokespecial</em> aufgerufen werden. </td></tr><tr><td> <code>ACC_INTERFACE</code> </td> <td>  0x0200 </td><td>  Ist eine Schnittstelle, keine Klasse. </td></tr><tr><td> <code>ACC_ABSTRACT</code> </td> <td>  0x0400 </td><td>  Deklarierte <code>abstract</code> ;  darf nicht instanziiert werden. </td></tr><tr><td> <code>ACC_SYNTHETIC</code> </td> <td>  0x1000 </td><td>  Synthetisch deklariert;  nicht im Quellcode vorhanden. </td></tr><tr><td> <code>ACC_ANNOTATION</code> </td> <td>  0x2000 </td><td>  Als Anmerkungstyp deklariert. </td></tr><tr><td> <code>ACC_ENUM</code> </td> <td>  0x4000 </td><td>  Als <code>enum</code> deklariert. </td></tr></tbody></table></div><br><p>  <strong>this_class</strong> </p><br><p>  Muss eine Adresse f√ºr <code>this</code> Klasse enthalten.  In unserem Fall befindet es sich unter der Adresse 5: </p><br><pre> <code class="plaintext hljs"> Constant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Main #6 = Class #22 // java/lang/Object ...</code> </pre> <br><p>  Es ist zu beachten, dass die Struktur dieser Variablen <code>CONSTANT_Class_info</code> entsprechen muss </p><br><p>  <strong>super_class</strong> </p><br><p>  Adresse des Vorfahren der Klasse.  In unserem Fall befindet sich der Wert an der Adresse <code>#6</code> .  Nun, die <code>CONSTANT_Class_info</code> ist ebenfalls erforderlich </p><br><p>  Die Namen dieser Klassen sind in der Struktur der Konstante <code>CONSTANT_Utf8_info</code> definiert.  Wenn wir uns die Zellen <code>#21</code> und <code>#22</code> ansehen, werden wir sehen: </p><br><pre> <code class="plaintext hljs"> ... #21 = Utf8 Main #22 = Utf8 java/lang/Object ...</code> </pre> <br><p>  Das hei√üt, in diesen Zellen wird <code>name_index</code> aus der Struktur angegeben: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Class_info { u1 tag; u2 name_index; }</code> </pre> <br><p>  <strong>interfaces_count, fields_count</strong> </p><br><p>  Sie befinden sich nicht in unserem Programm, daher sind ihre Werte gleich 0000, und es gibt einfach keine nachfolgenden Werte f√ºr <code>fields[]</code> , <code>interfaces[]</code> . </p><br><p>  Lesen Sie mehr <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">4.1 Die ClassFile-Struktur</a> </p><br><p>  <strong>methods_count</strong> </p><br><p>  Anzahl der Methoden.  Obwohl wir im Code eine Methode in der Klasse sehen, gibt es tats√§chlich zwei davon.  Neben der <code>main</code> gibt es auch einen Standardkonstruktor.  Daher ist ihre Zahl in unserem Fall zwei. </p><br><p>  <strong>methoden []</strong> </p><br><p>  Jedes Element muss der in <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Kapitel 4.6 Methoden</a> beschriebenen <code>method_info</code> Struktur entsprechen </p><br><pre> <code class="plaintext hljs"> method_info { u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count]; }</code> </pre> <br><p>  In unserem Bytecode (formatiert, mit Kommentaren) sieht es so aus: </p><br><pre> <code class="plaintext hljs"> -- [methods] -- public Main(); 0001 --access_flags 0007 -- name_index 0008 -- descriptor_index 0001 -- attributes_count -- attribute_info 0009 -- attribute_name_index (Code) 0000 001d - attribute_length 0001 -- max_stack 0001 -- max_locals 0000 0005 -- code_length 2a b7 00 01 b1 -- code[] 0000 -- exception_table_length 0001 -- attributes_count; 000a -- attribute_name_index 0000 0006 -- attribute_length 00 01 00 00 00 01 -- public static void main(java.lang.String...); 0089 --access_flags 000b -- name_index 000c -- descriptor_index 0001 -- attributes_count -- attribute_info 0009 -- attribute_name_index (Code) 0000 0025 -- attribute_length 0002 -- max_stack 0001 -- max_locals 0000 0009 -- code_length b2 00 02 12 03 b6 00 04 b1 -- code[] 0000 -- exception_table_length 0001 -- attributes_count 000a -- attribute_name_index 0000 000a -- attribute_length 00 02 00 00 00 04 00 08 00 05 -- [methods END]</code> </pre> <br><p>  Lassen Sie uns die Struktur der Methoden genauer analysieren: </p><br><p>  <strong>access_flags</strong> </p><br><p>  Modifikatormaske.  <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Tabelle 4.5 Methodenzugriffs- und Eigenschaftsflags</a> </p><br><div class="scrollable-table"><table><thead><tr><th>  Fahnenname </th><th>  Wert </th><th>  Interpretation </th></tr></thead><tbody><tr><td> <code>ACC_PUBLIC</code> </td> <td>  0x0001 </td><td>  <code>public</code> erkl√§rt;  kann von au√üerhalb des Pakets zugegriffen werden. </td></tr><tr><td> <code>ACC_PRIVATE</code> </td> <td>  0x0002 </td><td>  F√ºr <code>private</code> erkl√§rt;  Zugriff nur innerhalb der definierenden Klasse. </td></tr><tr><td> <code>ACC_PROTECTED</code> </td> <td>  0x0004 </td><td>  F√ºr <code>protected</code> erkl√§rt;  kann innerhalb von Unterklassen zugegriffen werden. </td></tr><tr><td> <code>ACC_STATIC</code> </td> <td>  0x0008 </td><td>  <code>static</code> deklariert. </td></tr><tr><td> <code>ACC_FINAL</code> </td> <td>  0x0010 </td><td>  F√ºr <code>final</code> erkl√§rt;  darf nicht √ºberschrieben werden ( <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html">¬ß5.4.5</a> ). </td></tr><tr><td> <code>ACC_SYNCHRONIZED</code> </td> <td>  0x0020 </td><td>  Deklariert <code>synchronized</code> ;  Der Aufruf wird von einer Monitorverwendung umschlossen. </td></tr><tr><td> <code>ACC_BRIDGE</code> </td> <td>  0x0040 </td><td>  Eine vom Compiler generierte Bridge-Methode. </td></tr><tr><td> <code>ACC_VARARGS</code> </td> <td>  0x0080 </td><td>  Deklariert mit variabler Anzahl von Argumenten. </td></tr><tr><td> <code>ACC_NATIVE</code> </td> <td>  0x0100 </td><td>  Als <code>native</code> deklariert;  in einer anderen Sprache als Java implementiert. </td></tr><tr><td> <code>ACC_ABSTRACT</code> </td> <td>  0x0400 </td><td>  Deklarierte <code>abstract</code> ;  Eine Implementierung ist nicht vorgesehen. </td></tr><tr><td> <code>ACC_STRICT</code> </td> <td>  0x0800 </td><td>  <code>strictfp</code> ;  Der Gleitkommamodus ist FP-streng. </td></tr><tr><td> <code>ACC_SYNTHETIC</code> </td> <td>  0x1000 </td><td>  Synthetisch deklariert;  nicht im Quellcode vorhanden. </td></tr></tbody></table></div><br><p>  Wie wir aus dem Bytecode ersehen k√∂nnen, in der <code>public Main();</code> -Methode <code>public Main();</code>  (Konstruktor) ist die Maske <code>0001</code> , was <code>ACC_PUBLIC</code> bedeutet. </p><br><p>  Versuchen wir nun, die Hauptmethode selbst zusammenzusetzen.  Folgendes hat er: </p><br><ul><li>  public - ACC_PUBLIC - 0x0001 </li><li>  static - ACC_STATIC - 0x0008 </li><li>  String ... args - ACC_VARARGS - 0x0080 </li></ul><br><p>  Wir sammeln die Maske: 0x0001 + 0x0008 + 0x0080 = <code>0x0089</code> .  Also haben wir <code>access_flag</code> </p><br><blockquote>  √úbrigens ist ACC_VARARGS hier optional, in dem Sinne, dass wenn wir <br>  Wenn Sie String [] args anstelle von String ... args verwenden, wird dieses Flag nicht verwendet </blockquote><p>  <strong>name_index</strong> </p><br><p>  Methodenname Adresse ( <code>CONSTANT_Utf8_info</code> ) im Konstantenpool.  Hierbei ist zu beachten, dass der Konstruktorname nicht Main, sondern <code>&lt;init&gt;</code> in Zelle 7 lautet. </p><br><p>  Weitere <code>&lt;clinit&gt;</code> <code>&lt;init&gt;</code> und <code>&lt;clinit&gt;</code> in <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html">Kapitel 2.9 Spezielle Methoden</a> </p><br><p>  <strong>descriptor_index</strong> </p><br><p>  Grob gesagt ist dies eine Adresse, die auf ein Methodenhandle verweist.  Dieser Deskriptor enth√§lt den Typ des R√ºckgabewerts und den Typ seiner Signatur. </p><br><p>  Die JVM verwendet auch interpretierte Abk√ºrzungen: </p><br><div class="scrollable-table"><table><thead><tr><th>  <em>BaseType-</em> Zeichen </th><th>  Typ </th><th>  Interpretation </th></tr></thead><tbody><tr><td> <code>B</code> </td> <td> <code>byte</code> </td> <td>  signiertes Byte </td></tr><tr><td> <code>C</code> </td> <td> <code>char</code> </td> <td>  Unicode-Zeichencodepunkt in der mehrsprachigen Basisebene, codiert mit UTF-16 </td></tr><tr><td> <code>D</code> </td> <td> <code>double</code> </td> <td>  Gleitkommawert mit doppelter Genauigkeit </td></tr><tr><td> <code>F</code> </td> <td> <code>float</code> </td> <td>  Gleitkommawert mit einfacher Genauigkeit </td></tr><tr><td> <code>I</code> </td> <td> <code>int</code> </td> <td>  Ganzzahl </td></tr><tr><td> <code>J</code> </td> <td> <code>long</code> </td> <td>  lange ganze Zahl </td></tr><tr><td>  <code>L</code> <em>ClassName</em> <code>;</code> </td><td> <code>reference</code> </td> <td>  eine Instanz der Klasse <em>ClassName</em> </td></tr><tr><td> <code>S</code> </td> <td> <code>short</code> </td> <td>  kurz unterschrieben </td></tr><tr><td> <code>Z</code> </td> <td> <code>boolean</code> </td> <td>  <code>true</code> oder <code>false</code> </td></tr><tr><td> <code>[</code> </td> <td> <code>reference</code> </td> <td>  eine Array-Dimension </td></tr></tbody></table></div><br><p>  Im Allgemeinen sieht es so aus: </p><br><pre> <code class="plaintext hljs"> ( ParameterDescriptor* ) ReturnDescriptor</code> </pre> <br><p>  Zum Beispiel die folgende Methode: </p><br><pre> <code class="plaintext hljs"> Object method(int i, double d, Thread t) {..}</code> </pre> <br><p>  Kann dargestellt werden als </p><br><pre> <code class="plaintext hljs"> (IDLjava/lang/Thread;)Ljava/lang/Object</code> </pre> <br><p>  Eigentlich ist <code>I</code> <code>int</code> , <code>D</code> ist <code>double</code> und <code>Ljava/lang/Thread;</code>  class <code>Thread</code> aus der Standardbibliothek <code>java.lang</code> . </p><br><p>  Als n√§chstes gibt es Attribute, die ebenfalls eine eigene Struktur haben. </p><br><p>  Aber zuerst, wie immer, z√§hlt dessen <code>attributes_count</code> </p><br><p>  Dann die Attribute selbst mit der in <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Kapitel 4.7</a> beschriebenen Struktur </p><br><pre> <code class="plaintext hljs"> attribute_info { u2 attribute_name_index; u4 attribute_length; u1 info[attribute_length]; }</code> </pre> <br><p>  <strong>attribute_name_index</strong> </p><br><p>  Gibt einen Attributnamen an.  In unserem Fall haben beide Methoden einen <code>Code</code> .  Attribute ist ein eigenst√§ndiges gro√ües Thema, in dem Sie sogar Ihre eigenen Attribute nach Spezifikation erstellen k√∂nnen.  Vorerst sollten wir jedoch wissen, dass <code>attribute_name_index</code> nur auf die Adresse im Konstantenpool mit der <code>CONSTANT_Utf8_info</code> Struktur verweist </p><br><p>  <strong>attribute_length</strong> </p><br><p>  Enth√§lt die L√§nge des Attributs ohne <code>attribute_name_index</code> und <code>attribute_length</code> </p><br><p>  <strong>info</strong> </p><br><p>  Als N√§chstes verwenden wir die <code>Code</code> , da wir im Wert von <code>attribute_name_index</code> auf den Wert im Pool der <code>Code</code> verwiesen haben. </p><br><p>  Lesen Sie mehr: <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Kapitel 4.7.3 Das Code-Attribut</a> </p><br><p>  Hier ist seine Struktur: </p><br><pre> <code class="plaintext hljs"> Code_attribute { u2 attribute_name_index; u4 attribute_length; u2 max_stack; u2 max_locals; u4 code_length; u1 code[code_length]; u2 exception_table_length; { u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; } exception_table[exception_table_length]; u2 attributes_count; attribute_info attributes[attributes_count]; }</code> </pre> <br><p>  <strong>max_stack</strong> </p><br><p>  Es scheint mir, dass der Name dieses Attributs aufgrund des Pr√§fixes max irref√ºhrend sein kann.  Tats√§chlich ist dies die minimale Stapelgr√∂√üe, die zum Abschlie√üen des Vorgangs erforderlich ist.  Nun, dieser Name √ºbernimmt die Logik, um die maximale Stapelgr√∂√üe anzugeben, die w√§hrend des Vorgangs erreicht wird. </p><br><p>  Einfach ausgedr√ºckt, die JVM weist dem Operandenstapel Speicherplatz zu.  Dort k√∂nnen Sie einen Wert angeben, der gr√∂√üer als erforderlich ist. Wenn Sie jedoch einen Wert in diesem Attribut definieren, der kleiner als erforderlich ist, wird ein Fehler verursacht. </p><br><p>  Zum Thema des Stacks k√∂nnen Sie " <a href="https%253A%252F%252Fwww.tune-it.ru%252Fweb%252Fbleizard%252Fblog%253Fp_p_id%253Dcom_liferay_blogs_web_portlet_BlogsPortlet%2526p_p_lifecycle%253D0%2526p_p_state%253Dnormal%2526p_p_mode%253Dview%2526_com_liferay_blogs_web_portlet_BlogsPortlet_cur%253D2%2526_com_liferay_blogs_web_portlet_BlogsPortlet_delta%253D10%2526p_r_p_resetCur%253Dfalse">Auf dem Stack und Heap im Kontext der Java-Welt</a> " oder " <a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a> " lesen. </p><br><p>  <strong>max_locals</strong> </p><br><p>  Maximale Gr√∂√üe lokaler Variablen </p><br><p>  Sie k√∂nnen sich mit lokalen Variablen entweder in <a href="https://jrebel.com/rebellabs/rebel-labs-report-mastering-java-bytecode-at-the-core-of-the-jvm/">Mastering Java Bytecode im Kern der JVM</a> oder in denselben <a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM-</a> <a href="https://jrebel.com/rebellabs/rebel-labs-report-mastering-java-bytecode-at-the-core-of-the-jvm/">Interna</a> vertraut machen </p><br><p>  <strong>Codel√§nge</strong> </p><br><p>  Die Gr√∂√üe des Codes, der innerhalb der Methode ausgef√ºhrt wird </p><br><p>  <strong>code []</strong> </p><br><p>  Jeder Code verweist auf eine Anweisung.  Die Tabelle zur Korrelation von <code>optcode</code> und Befehlen mit Mnemonics finden Sie auf Wikipedia - <a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">Java-Bytecode-Anweisungslisten</a> oder in der Spezifikation selbst am Ende des Buches </p><br><p>  Nehmen Sie zum Beispiel unseren Konstruktor: </p><br><pre> <code class="plaintext hljs"> -- public Main(); 0001 --access_flags 0007 -- name_index 0008 -- descriptor_index 0001 -- attributes_count -- attribute_info 0009 -- attribute_name_index (Code) 0000 001d - attribute_length 00 01 -- max_stack 00 01 -- max_locals 00 00 00 05 -- code_length 2a b7 00 01 b1 -- code[] 0000 -- exception_table_length 0001 -- attributes_count; 00 0a -- attribute_name_index 0000 0006 -- attribute_length 00 01 00 00 00 01</code> </pre> <br><p>  Hier finden wir unseren Code: </p><br><pre> <code class="plaintext hljs"> 2a b7 00 01 b1</code> </pre> <br><p>  Wir suchen nach Befehlen in der Tabelle und vergleichen: </p><br><pre> <code class="plaintext hljs"> 2a - aload_0 b7 0001 - invokespecial #1 b1 - return</code> </pre> <br><p>  Beschreibungen dieser Befehle finden Sie auch hier: <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Kapitel 4.10.1.9.</a>  <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Anweisungen zur Typpr√ºfung</a> </p><br><p>  <strong>Ausnahmetabellenl√§nge</strong> </p><br><p>  Gibt die Anzahl der Elemente in der Ausnahmetabelle an.  Wir haben keine Exception-Hooks, daher werden wir sie nicht analysieren.  Sie k√∂nnen aber auch das <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Kapitel 4.7.3 Das Code-Attribut</a> lesen </p><br><p>  <strong>Ausnahmetabelle []</strong> </p><br><p>  Es hat folgende Struktur: </p><br><pre> <code class="plaintext hljs"> { u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; }</code> </pre> <br><p>  Zur Vereinfachung m√ºssen Sie den Anfang, das Ende ( <code>start_pc</code> , <code>end_pc</code> ) des Codes, den <code>handler_pc</code> verarbeiten soll, und den Ausnahmetyp <code>catch_type</code> </p><br><p>  <strong>attributes_count</strong> </p><br><p>  Anzahl der Attribute im <code>Code</code> </p><br><p>  <strong>Attribute []</strong> </p><br><p>  Attribute werden h√§ufig von Analysatoren oder Debuggern verwendet. </p><br><hr><br><h3 id="sredstva-dlya-raboty-s-bayt-kodom">  Bytecode-Werkzeuge </h3><br><p>  Dies ist nicht das Thema, das sich auf diesen Artikel bezieht, aber es h√§ngt immer noch indirekt damit zusammen. </p><br><p>  Es gibt viele Tools f√ºr die Arbeit mit Bytecode.  Hier m√∂chte ich die <a href="https://commons.apache.org/proper/commons-bcel/">Byte Code Engineering Library</a> (BCEL) von Apache Commons √ºberpr√ºfen. </p><br><p>  Zun√§chst k√∂nnen wir damit einige Bytecode-Attribute erhalten: </p><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">// read file from resources/complied/ClassA.class InputStream inputStream = ClassParserExample.class.getResourceAsStream("/compiled/ClassA.class"); if (inputStream == null) throw new FileNotFoundException(); ClassParser parser = new ClassParser(inputStream, "ClassA.class"); JavaClass clazz = parser.parse(); final String HEX_BYTECODE = getHex(clazz.getBytes()); System.out.println("Hex bytecode: "); System.out.println(HEX_BYTECODE); System.out.println(); final String MINOR_VER = getHex(clazz.getMinor()); final String MAJOR_VER = getHex(clazz.getMajor()); final String CONSTANT_POOL = getHex(clazz.getConstantPool().getConstantPool()); final String ACCESS_FLAGS = getHex(clazz.getAccessFlags()); final String THIS_CLASS = getHex(clazz.getClassName().getBytes()); final String SUPER_CLASS = getHex(clazz.getSuperClass().getBytes()); final String INTERFACES = getHex(clazz.getInterfaces()); final String FIELDS = getHex(clazz.getFields()); final String METHODS = getHex(clazz.getMethods()); final String ATTRIBUTES = getHex(clazz.getAttributes());</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndige Codeliste</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">import org.apache.bcel.classfile.*; import org.apache.commons.codec.binary.Hex; import java.io.*; public class ClassParserExample { public static void main(String... args) throws IOException, ClassNotFoundException { // read file from resources/complied/ClassA.class InputStream inputStream = ClassParserExample.class.getResourceAsStream("/compiled/ClassA.class"); if (inputStream == null) throw new FileNotFoundException(); ClassParser parser = new ClassParser(inputStream, "ClassA.class"); JavaClass clazz = parser.parse(); final String HEX_BYTECODE = getHex(clazz.getBytes()); System.out.println("Hex bytecode: "); System.out.println(HEX_BYTECODE); System.out.println(); final String MINOR_VER = getHex(clazz.getMinor()); final String MAJOR_VER = getHex(clazz.getMajor()); final String CONSTANT_POOL = getHex(clazz.getConstantPool().getConstantPool()); final String ACCESS_FLAGS = getHex(clazz.getAccessFlags()); final String THIS_CLASS = getHex(clazz.getClassName().getBytes()); final String SUPER_CLASS = getHex(clazz.getSuperClass().getBytes()); final String INTERFACES = getHex(clazz.getInterfaces()); final String FIELDS = getHex(clazz.getFields()); final String METHODS = getHex(clazz.getMethods()); final String ATTRIBUTES = getHex(clazz.getAttributes()); System.out.println( "minor: " + MINOR_VER ); // 0 System.out.println( "major: " + MAJOR_VER ); // 34 System.out.println( "constant pool: " + CONSTANT_POOL); // not correctly System.out.println( "access flags: " + ACCESS_FLAGS ); // 21 System.out.println( "this class: " + THIS_CLASS ); System.out.println( "super class: " + SUPER_CLASS ); // Object System.out.println( "interfaces: " + INTERFACES ); // &lt;empty&gt; System.out.println( "fields: " + FIELDS ); // &lt;empty&gt; System.out.println( "methods: " + METHODS ); // one method: psvm hello world System.out.println( "attributes: " + ATTRIBUTES ); // 536f7572636546696c65 - I think it's instructions for Java tools } private static String getHex(byte[] bytes){ return Hex.encodeHexString(bytes); } private static String getHex(int intNum){ return Integer.toHexString(intNum); } private static String getHex(Constant[] constants){ if (constants == null) return null; StringBuilder sb = new StringBuilder(); for (Constant c : constants){ if (c == null) continue; sb.append(getHex(c.getTag())).append(" "); } return sb.toString(); } private static String getHex(JavaClass[] clazzes){ if (clazzes == null) return null; StringBuilder sb = new StringBuilder(); for (JavaClass c : clazzes){ sb.append(getHex(c.getClassName().getBytes())).append(" "); } return sb.toString(); } private static String getHex(Field[] fields){ if (fields == null) return null; StringBuilder sb = new StringBuilder(); for (Field c : fields){ sb.append(getHex(c.getName().getBytes())).append(" "); } return sb.toString(); } private static String getHex(Method[] methods){ if (methods == null) return null; StringBuilder sb = new StringBuilder(); for (Method c : methods){ sb.append(getHex(c.getName().getBytes())).append(" "); } return sb.toString(); } private static String getHex(Attribute[] attributes){ if (attributes == null) return null; StringBuilder sb = new StringBuilder(); for (Attribute c : attributes){ sb.append(getHex(c.getName().getBytes())).append(" "); } return sb.toString(); } } /* Class A: public class ClassA { public static void main(String[] args) { System.out.println("Hello world"); } } */ /* Class A bytecode: cafe babe 0000 0034 0022 0a00 0600 1409 0015 0016 0800 170a 0018 0019 0700 1a07 001b 0100 063c 696e 6974 3e01 0003 2829 5601 0004 436f 6465 0100 0f4c 696e 654e 756d 6265 7254 6162 6c65 0100 124c 6f63 616c 5661 7269 6162 6c65 5461 626c 6501 0004 7468 6973 0100 1d4c 636f 6d2f 6170 706c 6f69 6478 7878 2f70 6172 7365 2f43 6c61 7373 413b 0100 046d 6169 6e01 0016 285b 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 2956 0100 0461 7267 7301 0013 5b4c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b01 000a 536f 7572 6365 4669 6c65 0100 0b43 6c61 7373 412e 6a61 7661 0c00 0700 0807 001c 0c00 1d00 1e01 000b 4865 6c6c 6f20 776f 726c 6407 001f 0c00 2000 2101 001b 636f 6d2f 6170 706c 6f69 6478 7878 2f70 6172 7365 2f43 6c61 7373 4101 0010 6a61 7661 2f6c 616e 672f 4f62 6a65 6374 0100 106a 6176 612f 6c61 6e67 2f53 7973 7465 6d01 0003 6f75 7401 0015 4c6a 6176 612f 696f 2f50 7269 6e74 5374 7265 616d 3b01 0013 6a61 7661 2f69 6f2f 5072 696e 7453 7472 6561 6d01 0007 7072 696e 746c 6e01 0015 284c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b29 5600 2100 0500 0600 0000 0000 0200 0100 0700 0800 0100 0900 0000 2f00 0100 0100 0000 052a b700 01b1 0000 0002 000a 0000 0006 0001 0000 0006 000b 0000 000c 0001 0000 0005 000c 000d 0000 0009 000e 000f 0001 0009 0000 0037 0002 0001 0000 0009 b200 0212 03b6 0004 b100 0000 0200 0a00 0000 0a00 0200 0000 0800 0800 0900 0b00 0000 0c00 0100 0000 0900 1000 1100 0000 0100 1200 0000 0200 13 */ /* Assembled code: Classfile /C:/java/BCEL/src/main/resources/compiled/ClassA.class Last modified 08.12.2019; size 563 bytes MD5 checksum bcd0198f6764a1dc2f3967fef701452e Compiled from "ClassA.java" public class com.apploidxxx.parse.ClassA minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #6.#20 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #21.#22 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #23 // Hello world #4 = Methodref #24.#25 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #26 // com/apploidxxx/parse/ClassA #6 = Class #27 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/apploidxxx/parse/ClassA; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 SourceFile #19 = Utf8 ClassA.java #20 = NameAndType #7:#8 // "&lt;init&gt;":()V #21 = Class #28 // java/lang/System #22 = NameAndType #29:#30 // out:Ljava/io/PrintStream; #23 = Utf8 Hello world #24 = Class #31 // java/io/PrintStream #25 = NameAndType #32:#33 // println:(Ljava/lang/String;)V #26 = Utf8 com/apploidxxx/parse/ClassA #27 = Utf8 java/lang/Object #28 = Utf8 java/lang/System #29 = Utf8 out #30 = Utf8 Ljava/io/PrintStream; #31 = Utf8 java/io/PrintStream #32 = Utf8 println #33 = Utf8 (Ljava/lang/String;)V { public com.apploidxxx.parse.ClassA(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 6: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/apploidxxx/parse/ClassA; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello world 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 8: 0 line 9: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String; } SourceFile: "ClassA.java */</code> </pre> </div></div><br><p>     ,    (,  Jasmin) -. </p><br><p>      <a href="https://github.com/AppLoidx/JVM-research"> </a>   <a href="https://github.com/apache/commons-bcel/tree/master/src/examples"> </a> </p><br><p> ,     <strong>Jasmin</strong> .   ,   ,     ,         JVM  -. </p><br><p>         : </p><br><div class="spoiler"> <b class="spoiler_title">Hello World</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.bytecode 52.0 .source Main.j .class public Main .super java/lang/Object .method public static main([Ljava/lang/String;)V .limit stack 2 .limit locals 2 getstatic java/lang/System/out Ljava/io/PrintStream; ldc "Hello world!" invokevirtual java/io/PrintStream.println(Ljava/lang/String;)V return .end method</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="plaintext hljs">; ClassCreating.j .bytecode 52.0 .source ClassCreating.java .class public ClassCreating .super java/lang/Object .method public &lt;init&gt;()V .limit stack 1 .limit locals 1 .line 1 0: aload_0 1: invokespecial java/lang/Object/&lt;init&gt;()V 4: return .end method .method public static main([Ljava/lang/String;)V ; Flag ACC_VARARGS set, see JVM spec .limit stack 2 .limit locals 3 .line 3 0: new java/lang/String 3: dup 4: invokespecial java/lang/String/&lt;init&gt;()V 7: astore_1 .line 4 8: new ClassCreating 11: dup 12: invokespecial ClassCreating/&lt;init&gt;()V 15: astore_2 .line 5 16: aload_2 17: invokevirtual ClassCreating/sayHello()V .line 6 20: return .end method .method public sayHello()V .limit stack 2 .limit locals 1 .line 9 0: getstatic java/lang/System/out Ljava/io/PrintStream; 3: ldc "Hello, User!" 5: invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V .line 10 8: return .end method</code> </pre> </div></div><br><hr><br><p>       Hello World </p><br><p>  -       : <a href="https://gist.github.com/AppLoidx/7173d7277dd73025ae06377a7cc75ed0">gist.github</a> </p><br><p>          . </p><br><p>  <strong>Benutzte Literatur</strong> </p><br><ul><li> The Java Virtual Machine Specification ‚Äî <a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">docs.oracle</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480550/">https://habr.com/ru/post/de480550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480534/index.html">16 Entwicklungstipps f√ºr Android in Kotlin. Teil 2</a></li>
<li><a href="../de480538/index.html">Was ist besser f√ºr Spiele: Intel Optane oder SSD?</a></li>
<li><a href="../de480540/index.html">Umbraco 8.4 Release: CMS ist noch komfortabler</a></li>
<li><a href="../de480542/index.html">Sicherheitsbewusstsein f√ºr Erwachsene: So schlie√üen Sie eine Phishing-Sicherheitsanf√§lligkeit</a></li>
<li><a href="../de480544/index.html">5 versteckte Geheimnisse in Java</a></li>
<li><a href="../de480552/index.html">Firefox k√§mpft f√ºr die Zukunft des Webs</a></li>
<li><a href="../de480554/index.html">Die Zukunft des Cloud Computing von Sun, die es nie gab</a></li>
<li><a href="../de480556/index.html">NGINX: Verifikation der russischen IT-Community</a></li>
<li><a href="../de480558/index.html">Wie die Gewinnschwelle des Bergbaus es Ihnen erm√∂glicht, den Dreh- und Angelpunkt von Bitcoin zu bestimmen</a></li>
<li><a href="../de480560/index.html">ICD-Robotik Teil der Funktionen in der Betriebsabteilung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>