<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚙️ 🙌 ♉️ Bagaimana waktu linear berubah menjadi Windows dalam O (n²) 🏴‍☠️ 🧞 💆🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya baru-baru ini mengalami penundaan multi-menit di workstation saya. Setelah penyelidikan, ternyata penyebab masalahnya adalah kunci, yang bisa ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana waktu linear berubah menjadi Windows dalam O (n²)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479498/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/2e8/f34/41c2e8f34752be4805fac21fec9b9ae0.png" alt="gambar"></div><br>  Saya baru-baru ini mengalami penundaan multi-menit di workstation saya.  Setelah penyelidikan, ternyata penyebab masalahnya adalah kunci, yang bisa bertahan selama lima menit, di mana sumber kunci pada dasarnya berputar dalam siklus sembilan instruksi. <br><br>  Sangat penting bagi saya untuk memilih judul yang baik untuk posting saya, tetapi saya segera ingat bahwa nama yang tepat "48 core diblokir oleh sembilan instruksi" <a href="https://randomascii.wordpress.com/2019/10/20/63-cores-blocked-by-seven-instructions/" rel="nofollow">sudah diambil</a> [ <a href="https://habr.com/ru/post/472552/">terjemahan</a> di Habré] oleh sebuah pos yang ditulis kurang dari sebulan yang lalu.  Jumlah prosesor yang diblokir berbeda, dan siklusnya sedikit lebih lama, tetapi pada kenyataannya, semua ini membuat Anda mengalami deja vu.  Karena itu, ketika saya menjelaskan masalah baru yang ditemukan, saya ingin merenungkan <em>mengapa ini terjadi setiap saat</em> . <br><br><h2>  Mengapa ini terjadi? </h2><br>  Secara kasar, masalah seperti itu muncul sebagai hasil dari pengamatan yang saya sebut <em>Hukum Pertama Dawson tentang Komputasi:</em> <a href="https://twitter.com/BruceDawson0xB/status/1120381406700429312" rel="nofollow">O (n <sup>2</sup> ) adalah magnet bagi algoritma yang tidak skala dengan baik</a> : mereka cukup cepat untuk masuk ke produksi, tetapi cukup lambat untuk merusak semuanya, ketika mereka sampai di sana. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/017/fb8/bea017fb89b90af6566d8ad77298efb9.png"></div><br>  <i>O (n <sup>2</sup> ) dalam aksi - data diambil dari kasus saya</i> <br><a name="habracut"></a><br>  Apa yang sedang terjadi  Pengembang menulis kode dan menggunakan algoritma O (n <sup>2</sup> ).  Mungkin dia tidak menyadari hal ini, atau algoritme menjadi O (n <sup>2</sup> ) <a href="https://randomascii.wordpress.com/2019/04/21/on2-in-createprocess/" rel="nofollow">karena bug</a> , atau pengembang tahu bahwa dia adalah O (n <sup>2</sup> ), tetapi dia berpikir bahwa itu tidak akan pernah penting.  Dalam kondisi laboratorium, kecepatan kode dapat diterima, dan itu dapat diterima untuk sebagian besar pengguna di dunia nyata, tetapi kemudian seseorang membuat <a href="https://randomascii.wordpress.com/2018/10/15/making-windows-slower-part-2-process-creation/" rel="nofollow">7.000 proses</a> dengan App Verifier dihidupkan atau membuat <a href="https://randomascii.wordpress.com/2019/04/21/on2-in-createprocess/" rel="nofollow">file biner dengan 180.000 elemen CFG</a> , atau mengumpulkan DLL besar sehingga <a href="https://connect.microsoft.com/VisualStudio/feedback/details/1064219/ltcg-linking-of-chromes-pdf-dll-spends-60-of-time-in-c2-dll-ssrfree" rel="nofollow">terus</a> - <a href="https://connect.microsoft.com/VisualStudio/feedback/details/1064219/ltcg-linking-of-chromes-pdf-dll-spends-60-of-time-in-c2-dll-ssrfree" rel="nofollow">menerus daftar</a> tautan <a href="https://connect.microsoft.com/VisualStudio/feedback/details/1064219/ltcg-linking-of-chromes-pdf-dll-spends-60-of-time-in-c2-dll-ssrfree" rel="nofollow">tunggal dipindai</a> , yang mengambil seluruh prosesor.  Ketika bekerja pada waktu peluncuran mesin Valve Source 2, saya menemukan <em>banyak</em> algoritma O (n <sup>2</sup> ), yang masing-masing menambahkan sekitar 30 detik pada waktu peluncuran mesin, yaitu masalah ini terjadi pada pengembang yang sangat berbeda. <br><br>  <em>O (n <sup>2</sup> ) adalah magnet untuk algoritma yang tidak skala dengan baik: mereka cukup cepat untuk masuk ke produksi, tetapi cukup lambat untuk merusak semuanya ketika mereka sampai di sana.</em> <br><br>  Tepat <br><br>  Misalnya, <a href="https://randomascii.wordpress.com/2018/10/15/making-windows-slower-part-2-process-creation/" rel="nofollow">pembuatan nama file log Verifier Aplikasi dilakukan dalam waktu linier</a> untuk setiap proses yang berjalan, dan ini normal sampai Anda menyadari bahwa ini mengarah ke O (n <sup>2</sup> ) jika banyak proses sedang berjalan.  Kadang-kadang bahkan tidak jelas bahwa ada loop bersarang, atau yang <em>secara resmi</em> bukan O (n <sup>2</sup> ), atau tidak jelas bahwa loop dapat berjalan begitu lama sehingga secara signifikan dapat mempengaruhi kecepatan ... <br><br>  Jadi pertimbangkan fitur ini, pikirkan ketika menulis kode, pantau bagaimana skala kinerja di bawah beban berat, dan periksa bagian kode yang mencurigakan saat membuat profil beban berat seperti itu.  Atau serahkan pada saya sehingga saya bisa mencari mereka dan menulis artikel di blog saya. <br><br><h2>  Mari kita kembali ke keluhan kita yang biasa </h2><br>  Seperti biasa, saya menjalankan bisnis saya dengan komputer saya yang sudah usang tetapi masih kuat dengan 48 prosesor logis dan RAM 96 GB.  Saya memperkenalkan <em>ninja chrome</em> untuk membangun Chromium, tapi ... tidak ada yang terjadi.  Saya melihat dan menunggu dua puluh detik, tetapi pertemuan itu tidak pernah dimulai.  Jadi saya, tentu saja, beralih ke <a href="https://randomascii.wordpress.com/2015/09/01/xperf-basics-recording-a-trace-the-ultimate-easy-way/" rel="nofollow"><em>UIforETW</em></a> untuk merekam jejak <a href="https://randomascii.wordpress.com/2015/09/24/etw-central/" rel="nofollow"><em>ETW</em></a> .  Lebih tepatnya, saya mencoba melakukannya.  Mencoba memulai pelacakan rekaman, <em>UIforETW membeku</em> .  Untuk pertama kalinya dalam latihan saya, bug menggunakan langkah-langkah perlindungan untuk mencegah saya menjelajahinya! <br><br>  Setelah satu atau dua menit, perakitan Chromium dimulai, dan <em>UIforETW</em> memulai pelacakan, tetapi sudah mulai terlambat dan saya tidak memiliki sedikit pun informasi tentang apa yang terjadi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/485/76e/b86/48576eb86c46f3254d1b891d180cc25e.png"></div><br>  <i>Opsi UIforETW dengan Pelacakan Penyangga Sirkular terpilih</i> <br><br>  Ketika hal yang sama terjadi beberapa hari kemudian, <em>UIforETW</em> kembali tidak dapat melakukan apapun.  Kali ini, saya meninggalkan jejak untuk bekerja di buffer memori melingkar, untuk bersiap-siap karena fakta bahwa hang akan terjadi untuk ketiga kalinya.  Namun, ini sangat mengurangi kecepatan alat bangun saya, jadi setelah beberapa jam saya menyerah. <br><br>  Kemudian situasi ini terulang <em>lagi</em> .  Kali ini saya menjalankan alat <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-recorder" rel="nofollow"><em>pencatat</em></a> jejak ETW yang dibuat oleh Microsoft - <a href="https://docs.microsoft.com/en-us/windows-hardware/test/wpt/windows-performance-recorder" rel="nofollow"><em>wprui</em></a> , dan saya dapat mulai merekam.  Sekitar 40 detik kemudian, perakitan mulai bekerja dan saya mendapat jejak! <br><br><h2>  Bisakah saya memulai penyelidikan sekarang? </h2><br>  Sebelumnya, saya perhatikan di "Task Manager" bahwa <em>WinMgmt.exe dijalankan</em> selama <em>pembekuan</em> ini.  Melihat data Penggunaan CPU (Precise) di WPA, saya yakin bahwa setelah lebih dari empat puluh detik, selama <em>WinMgmt.exe</em> adalah satu-satunya proses yang bekerja, mesin saya menjadi hidup setelah <em>WinMgmt.exe dimatikan</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02a/cd4/35d/02acd435d1b3dec571ae9ebb5b56b67a.png"></div><br>  <i>Kami menunggu kebangkitan proses setelah WinMgmt.exe selesai</i> <br><br>  Semua ini agak mencurigakan, tetapi pembaca bijak saya tahu bahwa "setelah" tidak berarti "karena", dan akan membutuhkan bukti. <br><br>  Seperti yang <a href="https://randomascii.wordpress.com/2019/10/20/63-cores-blocked-by-seven-instructions/" rel="nofollow">terakhir kali</a> , saya memperkirakan saat membuka kunci pada grafik, menyortir sakelar konteks oleh <em>Switch-In Time</em> dan mencari sakelar pertama dengan nilai <em>Time Sejak Terakhir yang</em> lama (menunjukkan lamanya waktu selama thread tidak dieksekusi).  Setelah melewatkan selusin utas yang hanya downtime pendek, saya menemukan yang pertama dari banyak yang menunggu 41,57 detik.  Thread yang tertidur tidak membangunkan <em>WinMgmt.exe</em> , tetapi saya segera mengetahui bahwa itu terbangun dengan thread yang membangunkan <em>WinMgmt.exe</em> sepersekian milidetik sebelumnya. <br><br><blockquote>  Untuk penjelasan tentang grafik Penggunaan CPU (Precise) dan konsep ready-thread / new-thread, lihat <a href="https://randomascii.wordpress.com/2012/05/05/xperf-wait-analysisfinding-idle-time/" rel="nofollow">tutorial</a> <a href="https://randomascii.wordpress.com/2012/05/11/the-lost-xperf-documentationcpu-scheduling/" rel="nofollow">ini</a> atau <a href="https://randomascii.wordpress.com/2012/05/11/the-lost-xperf-documentationcpu-scheduling/" rel="nofollow">dokumentasi ini</a> . </blockquote><br>  Di tangkapan layar dengan data pemindahan konten, baris 17 berisi stream <em>72.748 (WinMgmt.exe)</em> , yang mengaktifkan streaming <em>74.156 (svchost.exe).</em>  Selanjutnya, pada baris 19, utas <em>74.156 (svchost.exe)</em> mengaktifkan utas <em>58.704 (svchost.exe)</em> , yang sedang menunggu 41,57 detik.  Ini adalah utas pertama yang bangun setelah tidur panjang dan dari sini terus rantai aktivasi arus.  Utas yang baru saja diaktifkan dapat dilihat di kolom <em>Id Utas Baru</em> , lalu turun beberapa baris dan melihatnya di kolom <em>Readying Thread Id</em> , mengaktifkan utas lainnya.  Nama dan ID proses membantu Anda memahami konteksnya.  Jalur 17 dikaitkan dengan jalur 18 dan 19, jalur 19 dikaitkan dengan 20, yang dikaitkan dengan jalur 23, yang dikaitkan dengan jalur 27, dan seterusnya;  setiap utas diaktifkan oleh utas sebelumnya di rantai: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/2e8/f34/41c2e8f34752be4805fac21fec9b9ae0.png"></div><br>  <i>Monster itu terbangun - utas panjang yang menganggur hidup kembali</i> <br><br>  41.57 adalah waktu yang lama untuk memblokir utas, tetapi dalam kenyataannya ratusan utas diblokir, dan mereka diblokir <em>lebih</em> lama.  Satu-satunya alasan nilai <em>Time Sejak Terakhir</em> adalah sekitar 41,5 detik adalah karena lamanya jejak sebelum hang diselesaikan. <br><br>  Tampaknya hasilnya konsisten dengan teori bahwa masalahnya ada di <em>WinMgmt.exe</em> , tetapi mereka tidak membuktikannya.  Keyakinan saya meningkat ketika saya melihat <em>svchost.exe (3024)</em> di <em>Trace-&gt; System Configuration-&gt; Services</em> dan menemukan bahwa itu adalah layanan <em>Winmgmt</em> , tetapi saya masih membutuhkan lebih banyak kepastian. <br><br>  Setelah mencari-cari lebih banyak (berkeliaran maju dan mundur dalam waktu), saya memutuskan bahwa interaksi terlalu rumit untuk menganalisis mereka secara rinci, terutama tanpa <a href="https://randomascii.wordpress.com/2015/10/26/thread-naming-in-windows-time-for-something-better/" rel="nofollow">nama aliran</a> yang bisa memberi petunjuk kepada kami apa yang dilakukan 25 thread berbeda di <em>svchost.exe (3024)</em> . <br><br><h2>  Bukti! </h2><br>  Kemudian saya memutuskan untuk mendekati <em>WinMgmt.exe bukti</em> bersalah secara berbeda.  Mungkin itu layak dimulai dengan ini, tetapi itu akan terlalu sederhana.  Saya mengambil baris perintah <em>WinMgmt.exe</em> dari tabel <em>Processes</em> di WPA dan memulainya secara manual.  Perintah memiliki bentuk: <br><br><blockquote>  winmgmt.exe / verifikasi repositori </blockquote><br>  dan butuh sekitar lima menit untuk menyelesaikannya.  Sementara itu berhasil (dan saya punya banyak waktu), saya menemukan bahwa saya tidak dapat memulai jejak ETW dari <em>UIforETW</em> .  Bukti seperti itu lebih baik daripada analisis rumit yang bisa saya lakukan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/c6f/d64/1a0c6fd64820226eddd120b5e9ab2ab7.png"></div><br>  <i>Konfigurasi untuk menampilkan hanya utas yang lama tidak aktif</i> <br><br>  Lalu aku berlari repro lagi dengan jejak sudah berjalan;  Setelah menganalisis jejak, saya menemukan lebih dari <em>seratus</em> proses yang utasnya diblokir selama lebih dari <em>lima menit!</em> <br><br><h2>  Dan lagi ke titik ... </h2><br>  Karena kebiasaan, saya melihat kembali data Penggunaan CPU (Sampel) untuk melihat apa <em>yang</em> membuang waktu <em>WinMgmt.exe</em> .  Saya segera mengetahui bahwa 96,5% sampel berada di <em>repdrvfs.dll! CPageCache :: Read ()</em> , meminta empat tumpukan berbeda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/7d9/5f1/5447d95f1b431681cdd83ad42df7e731.png"></div><br>  <i>Empat jalur yang mengarahkan saya ke CPageCache :: Read</i> <br><br>  Pohon tumpukan penuh untuk fungsi ini ditampilkan di sini, terutama untuk orang-orang dari Microsoft yang ingin meneliti masalah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e6/6b3/519/0e66b35191db016e98ded6eb08445569.png"></div><br>  <i>Tumpukan penuh yang mengarah ke CPageCache :: Baca dalam tiga cara</i> <br><br>  Saya menambahkan kolom alamat dan menemukan bahwa 95,3% dari sampel berada dalam satu siklus dari sembilan instruksi (sampel selalu jatuh hanya tujuh dari sembilan instruksi (jika Anda ingin tahu mengapa, lihat di <a href="https://travisdowns.github.io/blog/2019/08/20/interrupts.html" rel="nofollow">sini</a> ), tetapi debugger menunjukkan ukuran penuh siklus) : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/8e6/04a/ecf8e604adbd110fdfaf77bb87dd378a.png"></div><br>  <i>Sampel berdasarkan alamat - tujuh alamat yang sangat "panas"</i> <br><br>  Kemudian saya mulai <em>winmgmt.exe / verifikasi repositori</em> secara manual, dan pada saat yang <em>sama</em> saya <a href="https://randomascii.wordpress.com/2016/11/27/cpu-performance-counters-on-windows/" rel="nofollow">mengumpulkan data penghitung CPU tentang instruksi cabang yang sedang dieksekusi</a> .  Dari ini, saya kira-kira bisa mengetahui berapa kali loop berjalan.  Ini mungkin tidak perlu, tetapi saya ingin memastikan bahwa loop dijalankan berkali-kali, dan tidak dieksekusi lambat (untuk beberapa alasan).  Saya pikir itu sangat keren sehingga saya bisa melakukannya secara sederhana, cukup buat <a href="" rel="nofollow">perubahan kecil</a> pada file batch.  Saya menemukan bahwa <em>WinMgmt.exe</em> dijalankan kira-kira satu instruksi percabangan per siklus, yaitu siklus (yang, seperti yang saya sudah tahu, menghabiskan sebagian besar waktu CPU) sangat cepat, dan perlambatan disebabkan oleh kenyataan bahwa ia menjalankan ratusan juta kali. <br><br><h2>  Keterlambatan Xperf </h2><br>  Hanya demi ketelitian, saya memutuskan untuk melihat mengapa <em>UIforETW</em> tidak dapat mulai melacak selama insiden ini.  <em>Ternyata UIforETW</em> menjalankan <em>xperf</em> , tetapi <em>xperf</em> idle selama 41,5 detik (sebenarnya lebih lama) di tumpukan panggilan ini: <br><br><blockquote>  xperf.exe! wmain <br>  xperf.exe! CStopTrace :: Execute <br>  perfctrl.dll! LoggingSession :: EnumLoggers <br>  perfctrl.dll! LoggingSession :: LoggingSession <br>  perfctrl.dll! LoggingSession :: CreateProviderList <br>  perfctrl.dll! GetProviderInfoCache <br>  perfctrl.dll! CProviderInfoCache :: CProviderInfoCache <br>  tdh.dll! TdhfEnumerateProviders <br>  tdh.dll! TdhpWbemConnect <br>  wbemprox.dll! CLocator :: ConnectServer <br>  wbemprox.dll! CDCOMTrans :: DoActualConnection </blockquote><br>  Singkatnya, <em>xperf</em> dipanggil oleh <em>Wbem</em> , dan karenanya diblokir oleh masalah ini.  <em>xperf</em> mencoba menghentikan jejak sebelum memulainya, karena saya menambahkan perilaku ini untuk membuat <a href="https://github.com/google/UIforETW/commit/092fa4d3c30137eca658a86d58fc8230ced56c7c" rel="nofollow">awal jejak lebih toleran terhadap kesalahan</a> .  Saya menduga bahwa hang masih akan terjadi, tetapi saya tidak tahu pasti. <br><br><h2>  Kami membuat grafik kompleksitas komputasi </h2><br>  Saya perhatikan bahwa <em>WinMgmt.exe</em> memindai <em>direktori</em> <em>c: \ windows \ System32 \ wbem \ Repository</em> , yang berukuran 1,9 GB di komputer saya, jadi saya bertanya di tempat kerja dan di Twitter untuk mengetahui berapa banyak direktori ini yang diperlukan untuk mendapatkan poin data.  Saya juga meminta orang-orang untuk memperbaiki runtime <em>winmgmt.exe / verifikasi repositori</em> dan mulai menjadwalkan.  Meskipun pengujian ini dilakukan pada mesin yang sama sekali berbeda dengan kecepatan CPU yang berbeda, grafik ternyata cukup jelas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/dd8/23d/539dd823d7fb9b33df39dc61f9e183dd.png"></div><br>  <i>Hubungan antara akar kuadrat waktu dan ukuran repositori</i> <br><br>  Grafik rasio sqrt (waktu) ini dengan ukuran repositori sangat ideal untuk data yang diterima dari enam mesin yang berbeda, dan bagaimanapun, itu nyata.  Jelas, fungsi <em>VerifyRepository</em> memiliki kinerja O (n <sup>2</sup> ).  Jika n adalah ukuran direktori Repositori dalam <a href="https://randomascii.wordpress.com/2016/02/13/base-ten-for-almost-everything/" rel="nofollow">GB</a> , maka <em>VerifyRepository</em> membutuhkan waktu sekitar 1,6 * n <sup>2</sup> menit.  Ini adalah perkiraan kasar yang baik untuk semua nilai - dari sepersekian detik hingga sepuluh menit. <br><br><h2>  Relevansi </h2><br>  Entah saya beruntung, atau saya hanya jeli, karena selama beberapa minggu tidak ada yang pernah mengalami masalah ini lagi - saya pikir hal-hal aneh terjadi pada mobil saya.  Tapi tiba-tiba saya mulai mendengar keluhan serupa yang mencurigakan dari rekan kerja.  Salah satu dari mereka memiliki repositori 2,6 GB, yang membutuhkan waktu sepuluh menit untuk memverifikasi.  Masalahnya memengaruhi beberapa pengembang <a href="https://en.wikipedia.org/wiki/Continuous_integration" rel="nofollow">CI</a> kami, dan pada tingkat yang berbeda, orang lain berbeda.  Rekan-rekan saya biasanya tahu bahwa jika terjadi masalah dengan kinerja mesin Windows, saya harus mengatakan ini kepada saya, namun, mungkin ada banyak karyawan Google lain yang bekerja di bawah Windows yang dicegah oleh bug ini, tetapi mereka tidak menyadarinya. <br><br>  Untungnya, saya sudah mulai bekerja dengan departemen TI kami.  Saya menemukan skrip yang meluncurkan <em>WinMgmt</em> dan menemukan bahwa itu berjalan setiap jam.  Ini berarti bahwa mesin saya <em>menjalankan WinMgmt.exe / memverifikasi repositori</em> 10% dari waktu, dan beberapa rekan saya memiliki lebih dari 16% dari waktu.  Ada kemungkinan yang cukup tinggi untuk mendapatkan penundaan sepuluh menit sebelum perakitan. <br><br>  Pada saat laporan mulai tiba, perbaikan sudah dalam perjalanan ke produksi.  Script adalah opsional, dan tentu saja tidak sepadan dengan masalah yang ditimbulkannya, jadi perbaikannya adalah mematikan panggilannya. <br><br><h2>  Ringkasan </h2><br>  <em>winmgmt.exe / verifikasi repositori</em> berisi siklus sembilan instruksi, jumlah iterasi eksekusi yang sebanding dengan kuadrat ukuran <em>repositori wbem</em> .  Karena itu, pelaksanaan perintah dapat memakan waktu hingga sepuluh menit, meskipun dalam kenyataannya harus dijalankan hanya dalam beberapa detik.  Ini buruk dalam dirinya sendiri. <br><br>  Tetapi lebih buruk lagi, tim melakukan kunci WMI ( <a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page" rel="nofollow">Windows Management Instrumentation</a> ) selama operasinya, sehingga setiap proses yang melakukan operasi WMI akan membeku. <br><br><h2>  Teka-teki menakjubkan </h2><br>  Script yang <em>menjalankan winmgmt.exe / verifikasi repositori</em> setiap jam melakukan ini selama bertahun-tahun, tetapi perilaku bermasalah mulai muncul hanya satu hingga dua bulan lalu.  Agaknya, ini berarti bahwa repositori wbem baru-baru ini menjadi jauh lebih besar.  Penundaan pada 0,5 GB mudah diabaikan, tetapi dari 1,0 GB dan di atas mereka sudah bisa tegang.  Seperti yang <a href="https://twitter.com/itoleck/status/1192647636085592069" rel="nofollow">disarankan di Twitter,</a> saya menjalankan <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/strings" rel="nofollow">strings.exe</a> untuk file objects.data.  Banyak string yang paling umum mengandung polmkr dalam namanya, tetapi saya tidak tahu apa artinya itu. <br><br>  Saya <a href="https://twitter.com/BruceDawson0xB/status/1189979046135750657" rel="nofollow">menerbitkan laporan bug di Twitter</a> , dan pada awalnya menyebabkan <a href="https://twitter.com/djammmer/status/1192634563421495297" rel="nofollow">beberapa gerakan dari tim WMI</a> , tetapi kemudian saya berhenti menerima jawaban, jadi saya tidak tahu apa situasinya sekarang. <br><br>  Saya ingin melihat perbaikan untuk masalah kinerja, dan saya ingin departemen TI kami dapat menemukan dan memperbaiki masalah yang membuat repositori wbem kami begitu besar.  Tetapi untuk saat ini, departemen TI telah berjanji untuk tidak menjalankan perintah repositori / verifikasi setiap jam lebih, yang seharusnya membantu kita menghindari gejala terburuk. <br><br><h2>  Referensi </h2><br><ul><li>  Daftar umum tutorial, investigasi, dan dokumentasi ETW tersedia di sini: <a href="https://tinyurl.com/etwcentral" rel="nofollow">https://tinyurl.com/etwcentral</a> </li><li>  Tutorial Penggunaan CPU (Sampel) (untuk mengetahui berapa waktu CPU dihabiskan) ada di <a href="https://randomascii.wordpress.com/2013/04/23/xperf-for-excess-cpu-consumption-wpa-edition/" rel="nofollow">sini</a> , dan dokumentasinya ada di <a href="https://randomascii.wordpress.com/2012/05/08/the-lost-xperf-documentationcpu-sampling/" rel="nofollow">sini.</a> </li><li>  Tutorial Penggunaan CPU (Tepat) (untuk menemukan alasan mengapa utas tidak dapat berjalan) ada di <a href="https://randomascii.wordpress.com/2012/05/05/xperf-wait-analysisfinding-idle-time/" rel="nofollow">sini</a> , dan dokumentasinya ada di <a href="https://randomascii.wordpress.com/2012/05/11/the-lost-xperf-documentationcpu-scheduling/" rel="nofollow">sini.</a> </li><li>  Tautan ke masing-masing artikel diberikan di badan pos, Anda juga dapat menemukannya di kategori <a href="https://randomascii.wordpress.com/category/investigative-reporting/" rel="nofollow">Pelaporan Investigasi</a> saya </li><li>  Cerita lain tentang algoritma O (n <sup>2</sup> ) dapat dibaca di <a href="https://accidentallyquadratic.tumblr.com/" rel="nofollow">Accidentally Quadratic</a> </li></ul><br>  Diskusi tentang artikel tentang Reddit ada di <a href="https://www.reddit.com/r/programming/comments/e87dpb/on2_again_now_in_wmi/" rel="nofollow">sini</a> , diskusi tentang berita hacker ada di <a href="https://news.ycombinator.com/item%3Fid%3D21743424" rel="nofollow">sini</a> , utas di Twitter ada di <a href="https://twitter.com/BruceDawson0xB/status/1203905010716643328" rel="nofollow">sini,</a> dan mungkin <a href="https://twitter.com/BruceDawson0xB/status/1203922370957721600" rel="nofollow">di sini</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479498/">https://habr.com/ru/post/id479498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479482/index.html">SARIF SDK dan kesalahannya</a></li>
<li><a href="../id479486/index.html">Pemrograman heterogen dan oneAPI Toolkit. Kuliah pakar improvisasi Intel menjawab pertanyaan Anda</a></li>
<li><a href="../id479488/index.html">Dari laptop - server rumah dengan daya redundan ke router Mikrotik</a></li>
<li><a href="../id479492/index.html">Komputasi tanpa server berdasarkan OpenWhisk, bagian 3</a></li>
<li><a href="../id479496/index.html">Parsing Tugas WTF dalam JavaScript</a></li>
<li><a href="../id479502/index.html">Bagaimana cara bertahan hidup di zaman es paling parah dalam sejarah Bumi?</a></li>
<li><a href="../id479504/index.html">Membangun RDP Thin Client berbasis Raspberry Pi</a></li>
<li><a href="../id479508/index.html">Antipatterns PostgreSQL: GABUNGAN dan OR berbahaya</a></li>
<li><a href="../id479510/index.html">Ulasan PocketBook X - pembaca 10,3 inci yang besar dengan layar E Ink Carta Mobius dan casing logam</a></li>
<li><a href="../id479512/index.html">MVCC dalam PostgreSQL-4. Jepretan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>