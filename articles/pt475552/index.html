<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüåæ ü§∂üèø üõ¨ Algoritmos de aprendizado de m√°quina de teste de blitz: alimente seu conjunto de dados na biblioteca scikit-learn üë©üèΩ‚Äçüé§ üñïüèª üõãÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos os dias a web global √© reabastecida com artigos sobre os algoritmos de aprendizado de m√°quina mais populares e usados ‚Äã‚Äãpara solucionar v√°rios p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritmos de aprendizado de m√°quina de teste de blitz: alimente seu conjunto de dados na biblioteca scikit-learn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475552/"><img src="https://habrastorage.org/getpro/habr/post_images/7d1/0a1/6c9/7d10a16c9f50f8289a4b30eb53ffc661.jpg" alt="imagem"><br><br>  Todos os dias a web global √© reabastecida com artigos sobre os algoritmos de aprendizado de m√°quina mais populares e usados ‚Äã‚Äãpara solucionar v√°rios problemas.  Al√©m disso, a base desses artigos, ligeiramente alterada na forma de um lugar ou de outro, passa de um pesquisador de dados para outro.  Al√©m disso, todos esses trabalhos s√£o unidos por um postulado geralmente aceito e incontest√°vel: a aplica√ß√£o de um ou outro algoritmo de aprendizado de m√°quina depende do tamanho e da natureza dos dados dispon√≠veis e da tarefa em quest√£o. <br><br>  Al√©m disso, pesquisadores de dados especialmente insistidos, compartilhando sua experi√™ncia, enfatizam: <i>‚ÄúA escolha de um m√©todo de avalia√ß√£o deve depender parcialmente dos seus dados e do que, na sua opini√£o, o modelo deve ser bom‚Äù (‚ÄúCi√™ncia de Dados: informa√ß√µes privilegiadas para iniciantes. Incluindo a linguagem R, de Cathy O'Neill, Rachel Shutt)</i> . <br><a name="habracut"></a><br>  Em outras palavras, um estat√≠stico / pesquisador de dados deve ter n√£o apenas experi√™ncia na √°rea de assunto, mas tamb√©m uma ampla gama de conhecimentos variados: <i>‚ÄúUm pesquisador de dados √© aquele que possui conhecimento nas seguintes √°reas: matem√°tica, estat√≠stica, engenharia da computa√ß√£o, aprendizado de m√°quina, visualiza√ß√£o, meios de troca de dados ... ‚Äù</i> (do mesmo livro).  Somente o carregamento completo do conhecimento das √°reas acima na cabe√ßa pode ser abordado no aprendizado de m√°quina e encontrar solu√ß√µes para os problemas indicados. <br><br>  Quanto a mim, esse come√ßo √© bastante adequado para um livro comum de meio quilo e meio de ci√™ncia de dados, ou para um artigo de hist√≥ria de horror cient√≠fico com f√≥rmulas, s√≠mbolos e rabiscos de dois andares "in√∫teis" subsequentes que t√™m um impacto grave e deprimente para iniciantes no campo de aprendizado de m√°quina e apenas por acaso interessados ‚Äã‚Äãnessa dire√ß√£o, leitores inexperientes, n√£o sobrecarregados com o "conhecimento necess√°rio".  Al√©m disso, o n√∫mero 10 da rodada dos mesmos artigos sobre os 10 algoritmos de aprendizado de m√°quina mais populares ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">por exemplo</a> ) apenas refor√ßa o efeito imposto. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">No habr, eles tamb√©m se distinguiram</a> : <i>‚ÄúA resposta √† pergunta:‚Äú Que tipo de algoritmo de aprendizado de m√°quina devo usar? ‚ÄùSempre soa assim:‚Äú Dependendo das circunst√¢ncias ‚Äù.</i>  <i>A escolha do algoritmo depende do volume, qualidade e natureza dos dados.</i>  <i>Depende de como voc√™ gerencia o resultado.</i>  <i>Depende de como as instru√ß√µes para o computador que o implementa foram criadas a partir do algoritmo e tamb√©m de quanto tempo voc√™ tem.</i>  <i>Mesmo os analistas de dados mais experientes n√£o v√£o dizer qual algoritmo √© melhor at√© que eles o testem. ‚Äù</i> <br><br>  Sem d√∫vida, todo esse conhecimento, bem como perseveran√ßa e interesse, s√£o necess√°rios e √∫teis para alcan√ßar bons resultados, n√£o apenas no caminho para a compreens√£o do aprendizado de m√°quina, mas tamb√©m em muitas outras √°reas.  Al√©m disso, facilitar√£o o entendimento de que os algoritmos de aprendizado de m√°quina (a seguir denominados algoritmos) est√£o longe de uma d√∫zia;  mas isso √© apenas mais tarde, com estudo independente. <br><br>  Meu objetivo √© apresentar ao leitor os algoritmos mais utilizados de um ponto de vista pr√°tico e acess√≠vel.  (O fato de eu n√£o ser um programador e, al√©m disso, n√£o um matem√°tico (santo-santo-santo!) Deve sublinhar o interesse na narrativa. O ensino de engenharia e a experi√™ncia no "assunto crescem" de 10 anos (apenas algum tipo de n√∫mero m√°gico ) - como se costuma dizer, e todas as minhas coisas, todas as minhas malas com as quais fui direto para o aprendizado de m√°quina.Gra√ßas √† experi√™ncia adquirida na ind√∫stria do petr√≥leo, foram encontradas id√©ias para o uso de redes neurais artificiais e algoritmos de aprendizado de m√°quina (leia - eram necess√°rias conjuntos de dados.) Tudo o que restava era lidar com  Scarlet - aprenda a distorcer os dados para envi√°-los corretamente √† entrada do "programa" e qual, de fato, o algoritmo a ser escolhido. E ent√£o em um c√≠rculo vicioso. Percebo que meu caminho era espinhoso e divertido - "balas assobiavam no alto" (de m / f "As aventuras de Funtik"), - mas ainda assim eu consegui fazer anota√ß√µes e, se o interesse for indicado, no futuro publicarei outras mensagens.) <br><br>  Ent√£o, proponho abordar a "usinagem", por outro lado: por que n√£o alimentar seu conjunto de dados existente (nos exemplos voc√™ carregar√° conjuntos de dados que podem ser facilmente treinados) para v√°rios algoritmos de uma s√≥ vez e, de acordo com os resultados, decida qual deles deve prestar mais aten√ß√£o estudo cuidadoso subsequente e sele√ß√£o de par√¢metros ideais que melhoram o resultado.  Al√©m disso, o principal valor do m√©todo discutido acima √© que seus resultados responder√£o √† pergunta sobre o valor de seu conjunto de dados: <i>"comece resolvendo o problema e verifique se voc√™ tem algo para otimizar"</i> (tamb√©m de alguns ent√£o as estat√≠sticas insistentes diziam "respeito" a ele, um bom conselho!). <br><br>  Como √© feito? <br><br>  Sabe-se que a maior parte dos problemas resolvidos com a ajuda de algoritmos est√° relacionada aos problemas de classifica√ß√£o (classifica√ß√£o) e an√°lise de regress√£o (an√°lise preditiva).  Por <i>classifica√ß√£o</i> entende-se uma diferencia√ß√£o constante de unidades de observa√ß√£o (inst√¢ncias) de um conjunto de dados para uma determinada categoria (classe) com base nos resultados do treinamento.  <i>A an√°lise de regress√£o</i> √© um conjunto de m√©todos e processos estat√≠sticos para avaliar a rela√ß√£o entre vari√°veis ‚Äã‚Äã[ <i>Statistics: Textbook / Ed.</i>  <i>prof.</i>  <i>M.R.</i>  <i>Efimova.</i>  <i>- M.: INFRA-M, 2002</i> ].  O objetivo da an√°lise de regress√£o √© avaliar o valor de uma vari√°vel de sa√≠da cont√≠nua a partir dos valores das vari√°veis ‚Äã‚Äãde entrada [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ]. <br><br>  Deixamos de lado o fato de que a an√°lise de regress√£o tem √† sua disposi√ß√£o dois m√©todos diferentes - modelagem preditiva e previs√£o.  Observamos apenas que, se houver uma s√©rie temporal (dados de s√©ries temporais), usando um modelo de regress√£o baseado em uma tend√™ncia expl√≠cita, sujeita √† estacionariedade (const√¢ncia), a previs√£o poder√° ser realizada.  Se as condi√ß√µes para a forma√ß√£o de n√≠veis das s√©ries temporais mudarem, ou seja, o processo n√£o estacion√°rio n√£o for observado, ent√£o cabe √† modelagem preditiva.  Particularmente visando o dom√≠nio completo da ML, proponho a leitura deste artigo em ingl√™s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> .  Se surgir uma discuss√£o sobre isso, terei prazer em participar. <br><br>  Como as s√©ries temporais n√£o ser√£o usadas nos exemplos deste artigo, o termo <i>previs√£o</i> se refere √† <i>an√°lise preditiva</i> . <br><br>  Para resolver os problemas de classifica√ß√£o e previs√£o, √© adequado todo um conjunto de algoritmos, alguns dos quais consideraremos mais adiante.  Por conveni√™ncia, o texto subseq√ºente ser√° dividido em duas partes: na primeira, consideramos os algoritmos de classifica√ß√£o mais comuns, na segunda, dedicamos aos algoritmos de an√°lise de regress√£o.  Para cada parte, ser√° apresentado um conjunto de dados de "brinquedo" carregado da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca</a> scikit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">-learn</a> (v0.21.3): <i>conjunto de dados de d√≠gitos (classifica√ß√£o)</i> e <i>conjunto de dados de pre√ßos da casa de Boston (regress√£o)</i> , bem como links para cada algoritmo da biblioteca scikit-learn para auto-exame e, possivelmente, estudo. <br><br>  Todos os exemplos de c√≥digo s√£o executados no console do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IDE Spyder</a> 3.3.3 no Python 3.7.3. <br><br><h3>  Problema de classifica√ß√£o </h3><br>  Primeiro, importamos os m√≥dulos e fun√ß√µes necess√°rios que usaremos para resolver o problema de classifica√ß√£o de dados: <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      from sklearn.datasets import load_digits from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.discriminant_analysis import LinearDiscriminantAnalysis from sklearn.neighbors import KNeighborsClassifier from sklearn.tree import DecisionTreeClassifier from sklearn.naive_bayes import GaussianNB from sklearn.svm import LinearSVC from sklearn.svm import SVC from sklearn.neural_network import MLPClassifier from sklearn.ensemble import BaggingClassifier from sklearn.ensemble import RandomForestClassifier from sklearn.ensemble import ExtraTreesClassifier from sklearn.ensemble import AdaBoostClassifier from sklearn.ensemble import GradientBoostingClassifier from sklearn.model_selection import KFold from sklearn.model_selection import cross_val_score from sklearn.pipeline import Pipeline from sklearn.preprocessing import StandardScaler from sklearn.preprocessing import MinMaxScaler from sklearn.preprocessing import Normalizer from matplotlib import pyplot</span></span></code> </pre> <br>  Fa√ßa o download do conjunto de dados 'd√≠gitos' diretamente do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√≥dulo 'sklearn.datasets'</a> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    dataset = load_digits()</span></span></code> </pre> <br>  O IDE Spyder fornece uma ferramenta conveniente "Variable Manager", que √© √∫til em todos os momentos do aprendizado de m√°quina (pelo menos para mim), como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outros "truques"</a> : <br><br>  Execute o c√≥digo.  No console "gerenciador de vari√°veis", clique na vari√°vel do <i>conjunto de dados</i> .  O seguinte dicion√°rio √© exibido: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9f/362/64a/f9f36264a8a368644793b6f4ed7ad045.png" alt="imagem"><br><br>  A descri√ß√£o do conjunto de dados √© a seguinte: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/887/659/b2b/887659b2bc79bfd532c30d6ddee8aa5e.png" alt="imagem"><br><br>  Neste exemplo, n√£o precisamos da chave 'images'; portanto, atribu√≠mos a vari√°vel 'data' a <i>X</i> , que √© um array NumPy multidimensional com um conjunto de atributos, 1797 linhas em 64 colunas e a vari√°vel <i>Y</i> a 'target', um array multidimensional NumPy com um marcador para cada string. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    # dataset = load_digits() X = dataset.data Y = dataset.target</span></span></code> </pre> <br>  Em seguida, dividimos o conjunto de dados nas partes de treinamento e teste, configuramos os par√¢metros para avaliar os algoritmos (a valida√ß√£o cruzada √© usada [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dois</a> ]), definindo a 'precis√£o' da m√©trica no par√¢metro 'scoring' [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ].  Precis√£o √© a propor√ß√£o de objetos classificados corretamente em rela√ß√£o ao n√∫mero total de objetos.  Quanto mais pr√≥ximo o resultado de 1, melhor [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ].  Al√©m disso, em um dos livros, verificou-se que os resultados de 0,95 (ou 95%) e superiores s√£o considerados excelentes. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#         test_size = 0.2 seed = 7 X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_size, random_state=seed) #     num_folds = 10 n_estimators = 100 scoring = 'accuracy'</span></span></code> </pre> <br>  <i>Permita que as</i> vari√°veis <i>X_train</i> e <i>Y_train sejam usadas</i> para fins de treinamento, <i>X_test</i> e <i>Y_test</i> para o desenvolvimento de valores de previs√£o.  Nesse caso, a vari√°vel <i>Y_test</i> n√£o <i>est√°</i> envolvida no c√°lculo da previs√£o: usando o m√©todo de pontua√ß√£o, que √© o mesmo para cada um dos algoritmos apresentados abaixo, calcularemos as respostas corretas usando a m√©trica de precis√£o.  Isso nos permitir√° julgar como o algoritmo lida com a tarefa.  Eu n√£o discuto, por nossa parte, √© t√£o humanamente vil n√£o pedir ao carro as respostas corretas, mas de que outra forma verificar seu desempenho? <br><br>  Abaixo est√° uma lista de algoritmos com os quais alimentamos o conjunto de dados.  Com base nos resultados dos c√°lculos, concluiremos qual algoritmo (qual dos algoritmos) mostra a maior efici√™ncia.  Esse m√©todo pode muito bem ser chamado de <b>"teste de blitz de algoritmos de aprendizado de m√°quina"</b> (doravante - teste de blitz). <br><br>  Por conveni√™ncia, as informa√ß√µes ser√£o abreviadas ao lado de cada algoritmo.  Deve-se notar que as configura√ß√µes de cada algoritmo s√£o aceitas por padr√£o (padr√£o), com exce√ß√£o de alguns pontos, a fim de fornecer condi√ß√µes iguais. <br><br><h4>  Algoritmos lineares: </h4><br>  - Regress√£o log√≠stica * / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regress√£o log√≠stica</a> ('LR') <br>  <i>* A palavra "regress√£o" pode ser confusa.</i>  <i>Mas n√£o esque√ßa que "Regress√£o Log√≠stica" √© um algoritmo de classifica√ß√£o</i> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">An√°lise Discriminante Linear</a> ('LDA') <br><br><h4>  Algoritmos n√£o lineares: </h4><br>  - M√©todo dos k vizinhos mais pr√≥ximos (classifica√ß√£o) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">K-Neighbors Classifier</a> ('KNN') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificador da √Årvore de Decis√£o</a> ('CART') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificador Naive Bayes</a> ('NB') <br>  - M√©todo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classifica√ß√£o de vetores de suporte linear</a> (classifica√ß√£o) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classifica√ß√£o de vetores de suporte linear</a> ('LSVC') <br>  - M√©todo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vetor de suporte</a> (classifica√ß√£o) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classifica√ß√£o do vetor de suporte C</a> ('SVC') <br><br><h4>  Algoritmo de rede neural artificial: </h4><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Perceptron multicamada</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Perceptrons multicamada</a> ('MLP') <br><br><h4>  Algoritmos do conjunto: </h4><br>  - Ensacamento (classifica√ß√£o) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificador de ensacados</a> ('BG') (Ensacamento = agrega√ß√£o de Bootstrap) <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classifica√ß√£o florestal aleat√≥ria</a> ('RF') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificador de √Årvores Extra</a> ('ET') <br>  - AdaBoost (classifica√ß√£o) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificador AdaBoost</a> ('AB') (AdaBoost = impulso adapt√°vel) <br>  - Refor√ßo de gradiente (classifica√ß√£o) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificador de refor√ßo de gradiente</a> ('GB') <br><br>  Assim, a lista de 'modelos' cont√©m os seguintes modelos: <br><br><pre> <code class="python hljs">models = [] models.append((<span class="hljs-string"><span class="hljs-string">'LR'</span></span>, LogisticRegression())) models.append((<span class="hljs-string"><span class="hljs-string">'LDA'</span></span>, LinearDiscriminantAnalysis())) models.append((<span class="hljs-string"><span class="hljs-string">'KNN'</span></span>, KNeighborsClassifier())) models.append((<span class="hljs-string"><span class="hljs-string">'CART'</span></span>, DecisionTreeClassifier())) models.append((<span class="hljs-string"><span class="hljs-string">'NB'</span></span>, GaussianNB())) models.append((<span class="hljs-string"><span class="hljs-string">'LSVC'</span></span>, LinearSVC())) models.append((<span class="hljs-string"><span class="hljs-string">'SVC'</span></span>, SVC())) models.append((<span class="hljs-string"><span class="hljs-string">'MLP'</span></span>, MLPClassifier())) models.append((<span class="hljs-string"><span class="hljs-string">'BG'</span></span>, BaggingClassifier(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'RF'</span></span>, RandomForestClassifier(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'ET'</span></span>, ExtraTreesClassifier(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'AB'</span></span>, AdaBoostClassifier(n_estimators=n_estimators, algorithm=<span class="hljs-string"><span class="hljs-string">'SAMME'</span></span>))) models.append((<span class="hljs-string"><span class="hljs-string">'GB'</span></span>, GradientBoostingClassifier(n_estimators=n_estimators)))</code> </pre> <br>  Como j√° mencionado, a efic√°cia de cada algoritmo √© avaliada usando valida√ß√£o cruzada.  Como resultado, uma mensagem √© exibida (msg - abrevia√ß√£o de mensagem) contendo as seguintes informa√ß√µes: nome do modelo na forma de uma abrevia√ß√£o, pontua√ß√£o m√©dia de 10 vezes a valida√ß√£o cruzada nos dados de treinamento (m√©trica 'precis√£o'), o desvio padr√£o √© mostrado entre par√™nteses , bem como o valor da m√©trica "precis√£o" nos dados de teste. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      scores = [] names = [] results = [] predictions = [] msg_row = [] for name, model in models: kfold = KFold(n_splits=num_folds, random_state=seed) cv_results = cross_val_score(model, X_train, Y_train, cv=kfold, scoring=scoring) names.append(name) results.append(cv_results) m_fit = model.fit(X_train, Y_train) m_predict = model.predict(X_test) predictions.append(m_predict) m_score = model.score(X_test, Y_test) scores.append(m_score) msg = "%s: train = %.3f (%.3f) / test = %.3f" % (name, cv_results.mean(), cv_results.std(), m_score) msg_row.append(msg) print(msg)</span></span></code> </pre> <br>  Depois de executar o c√≥digo, obtemos os seguintes resultados: <br><br><pre> <code class="python hljs">LR: train = <span class="hljs-number"><span class="hljs-number">0.957</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> CART: train = <span class="hljs-number"><span class="hljs-number">0.843</span></span> (<span class="hljs-number"><span class="hljs-number">0.033</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.830</span></span> NB: train = <span class="hljs-number"><span class="hljs-number">0.819</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.806</span></span> LSVC: train = <span class="hljs-number"><span class="hljs-number">0.942</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.928</span></span> SVC: train = <span class="hljs-number"><span class="hljs-number">0.343</span></span> (<span class="hljs-number"><span class="hljs-number">0.079</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.342</span></span> MLP: train = <span class="hljs-number"><span class="hljs-number">0.972</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.961</span></span> BG: train = <span class="hljs-number"><span class="hljs-number">0.952</span></span> (<span class="hljs-number"><span class="hljs-number">0.021</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> RF: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.965</span></span> ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gr√°fico de amplitude</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚Äúcaixa com bigode‚Äù</a> ) (diagrama ou plotagem de caixas e bigodes, plotagem de caixas): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e3e/301/4c9/e3e3014c9931e3af6b7ea01eda90a0d0.png" alt="imagem"><br><br>  Como resultado de um teste de blitz em dados brutos, pode-se observar que os mais efetivos nos dados de teste foram os algoritmos 'KNN' (k-vizinhos mais pr√≥ximos), 'ET' (extra-√°rvores), 'GB' (gradiente 'boosting'), 'RF' (floresta aleat√≥ria) e 'MLP' (perceptron multicamada): <br><br><pre> <code class="python hljs">KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> RF: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.965</span></span> MLP: train = <span class="hljs-number"><span class="hljs-number">0.972</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.961</span></span> LR: train = <span class="hljs-number"><span class="hljs-number">0.957</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> BG: train = <span class="hljs-number"><span class="hljs-number">0.952</span></span> (<span class="hljs-number"><span class="hljs-number">0.021</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> LSVC: train = <span class="hljs-number"><span class="hljs-number">0.942</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.928</span></span> CART: train = <span class="hljs-number"><span class="hljs-number">0.843</span></span> (<span class="hljs-number"><span class="hljs-number">0.033</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.830</span></span> AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> NB: train = <span class="hljs-number"><span class="hljs-number">0.819</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.806</span></span> SVC: train = <span class="hljs-number"><span class="hljs-number">0.343</span></span> (<span class="hljs-number"><span class="hljs-number">0.079</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.342</span></span></code> </pre> <br>  No entanto, muitos algoritmos s√£o muito exigentes quanto aos dados em que s√£o veiculados.  Portanto, uma das etapas necess√°rias √© a chamada prepara√ß√£o preliminar de dados (pr√©-processamento de dados [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ]) <br><br>  No entanto, acontece que o algoritmo mostra os melhores resultados sem processamento preliminar.  Da√≠ a seguinte recomenda√ß√£o: inclua no teste de blitz v√°rias transforma√ß√µes do conjunto de dados original e, ap√≥s realizar os c√°lculos, compare os resultados para capturar a ess√™ncia do problema como um todo. <br><br>  Os m√©todos mais usados ‚Äã‚Äãpara a prepara√ß√£o preliminar de dados s√£o: <br><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padroniza√ß√£o;</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escala</a> (o intervalo padr√£o √© [0, 1]); <br><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">normaliza√ß√£o</a> <br><br>  Essas opera√ß√µes com avalia√ß√£o subsequente podem ser automatizadas e colocadas no transportador usando a ferramenta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pipeline</a> . <br><br>  Um trecho de c√≥digo com padroniza√ß√£o dos dados de origem √© o seguinte: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -      #    ( StandardScaler) pipelines = [] pipelines.append(('SS_LR', Pipeline([('Scaler', StandardScaler()), ('LR', LogisticRegression())]))) pipelines.append(('SS_LDA', Pipeline([('Scaler', StandardScaler()), ('LDA', LinearDiscriminantAnalysis())]))) pipelines.append(('SS_KNN', Pipeline([('Scaler', StandardScaler()), ('KNN', KNeighborsClassifier())]))) pipelines.append(('SS_CART', Pipeline([('Scaler', StandardScaler()), ('CART', DecisionTreeClassifier())]))) pipelines.append(('SS_NB', Pipeline([('Scaler', StandardScaler()), ('NB', GaussianNB())]))) pipelines.append(('SS_LSVC', Pipeline([('Scaler', StandardScaler()), ('LSVC', LinearSVC())]))) pipelines.append(('SS_SVC', Pipeline([('Scaler', StandardScaler()), ('SVC', SVC())]))) pipelines.append(('SS_MLP', Pipeline([('Scaler', StandardScaler()), ('MLP', MLPClassifier())]))) pipelines.append(('SS_BG', Pipeline([('Scaler', StandardScaler()), ('BG', BaggingClassifier(n_estimators=n_estimators))]))) pipelines.append(('SS_RF', Pipeline([('Scaler', StandardScaler()), ('RF', RandomForestClassifier(n_estimators=n_estimators))]))) pipelines.append(('SS_ET', Pipeline([('Scaler', StandardScaler()), ('ET', ExtraTreesClassifier(n_estimators=n_estimators))]))) pipelines.append(('SS_AB', Pipeline([('Scaler', StandardScaler()), ('AB', AdaBoostClassifier(n_estimators=n_estimators, algorithm='SAMME'))]))) pipelines.append(('SS_GB', Pipeline([('Scaler', StandardScaler()), ('GB', GradientBoostingClassifier(n_estimators=n_estimators))]))) #      scores_SS = [] names_SS = [] results_SS = [] predictions_SS = [] msg_SS = [] for name, model in pipelines: kfold = KFold(n_splits=num_folds, random_state=seed) cv_results = cross_val_score(model, X_train, Y_train, cv=kfold) names_SS.append(name) results_SS.append(cv_results) m_fit = model.fit(X_train, Y_train) m_predict = model.predict(X_test) predictions_SS.append(m_predict) m_score = model.score(X_test, Y_test) scores_SS.append(m_score) msg = "%s: train = %.3f (%.3f) / test = %.3f" % (name, cv_results.mean(), cv_results.std(), m_score) msg_SS.append(msg) print(msg) #    (StandardScaler) fig = pyplot.figure() fig.suptitle('     . ') ax = fig.add_subplot(111) red_square = dict(markerfacecolor='r', marker='s') pyplot.boxplot(results_SS, flierprops=red_square) ax.set_xticklabels(names_SS, rotation=45) pyplot.show()</span></span></code> </pre> <br>  Observe a adi√ß√£o de '_SS' (abrevia√ß√£o de StandardScaler) para listar nomes.  Isso √© feito para n√£o acumular os resultados e exibi-los convenientemente usando o "gerenciador de vari√°veis" ap√≥s a execu√ß√£o das convers√µes. <br><br>  A execu√ß√£o de um trecho de c√≥digo produz os seguintes resultados: <br><br><pre> <code class="python hljs">SS_LR: train = <span class="hljs-number"><span class="hljs-number">0.958</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.949</span></span> SS_LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> SS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.023</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_CART: train = <span class="hljs-number"><span class="hljs-number">0.853</span></span> (<span class="hljs-number"><span class="hljs-number">0.036</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.835</span></span> SS_NB: train = <span class="hljs-number"><span class="hljs-number">0.756</span></span> (<span class="hljs-number"><span class="hljs-number">0.046</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.751</span></span> SS_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.945</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> SS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.990</span></span> SS_MLP: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.973</span></span> SS_BG: train = <span class="hljs-number"><span class="hljs-number">0.947</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> SS_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> SS_AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> SS_GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span></code> </pre> <br>  Caixa de bigode (StandardScaler): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f7/a0d/bf7/8f7a0dbf718cfdd7b061ffd43a7bed8e.png" alt="imagem"><br><br>  De acordo com os resultados do c√°lculo em dados padronizados, os seguintes algoritmos se tornaram l√≠deres: <br><br><pre> <code class="python hljs">SS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.990</span></span> SS_ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> SS_MLP: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.973</span></span> SS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.023</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> SS_LR: train = <span class="hljs-number"><span class="hljs-number">0.958</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.949</span></span> SS_BG: train = <span class="hljs-number"><span class="hljs-number">0.947</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> SS_LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> SS_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.945</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> SS_CART: train = <span class="hljs-number"><span class="hljs-number">0.853</span></span> (<span class="hljs-number"><span class="hljs-number">0.036</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.835</span></span> SS_AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> SS_NB: train = <span class="hljs-number"><span class="hljs-number">0.756</span></span> (<span class="hljs-number"><span class="hljs-number">0.046</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.751</span></span></code> </pre> <br>  Como se costuma dizer, dos trapos √†s riquezas: o m√©todo do vetor de suporte ('SVC'), alimentado por dados padronizados, fez o resto, mostrando um excelente resultado.  Durante a verifica√ß√£o ‚Äúmanual‚Äù, comparando os valores das vari√°veis <i>Y_test</i> e <i>predictions_SS [6]</i> , o algoritmo n√£o mastigou apenas alguns valores. <br><br>  A seguir, o mesmo c√≥digo √© executado para as fun√ß√µes MinMaxScaler (dimensionamento) e Normalizador (normaliza√ß√£o).  N√£o darei o c√≥digo completo no artigo.  Voc√™ pode baix√°-lo do meu reposit√≥rio no GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> . <br><br>  Lembre-se de esperar um pouco e rir de si mesmo 'apenas para fins educacionais'!  :) <br><br>  Como resultado, ap√≥s analisar todo o c√≥digo, obtemos os seguintes resultados: <br><br><pre> <code class="python hljs">LR: train = <span class="hljs-number"><span class="hljs-number">0.957</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> CART: train = <span class="hljs-number"><span class="hljs-number">0.843</span></span> (<span class="hljs-number"><span class="hljs-number">0.033</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.830</span></span> NB: train = <span class="hljs-number"><span class="hljs-number">0.819</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.806</span></span> LSVC: train = <span class="hljs-number"><span class="hljs-number">0.942</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.928</span></span> SVC: train = <span class="hljs-number"><span class="hljs-number">0.343</span></span> (<span class="hljs-number"><span class="hljs-number">0.079</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.342</span></span> MLP: train = <span class="hljs-number"><span class="hljs-number">0.972</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.961</span></span> BG: train = <span class="hljs-number"><span class="hljs-number">0.952</span></span> (<span class="hljs-number"><span class="hljs-number">0.021</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> RF: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.965</span></span> ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> SS_LR: train = <span class="hljs-number"><span class="hljs-number">0.958</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.949</span></span> SS_LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> SS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.023</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_CART: train = <span class="hljs-number"><span class="hljs-number">0.853</span></span> (<span class="hljs-number"><span class="hljs-number">0.036</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.835</span></span> SS_NB: train = <span class="hljs-number"><span class="hljs-number">0.756</span></span> (<span class="hljs-number"><span class="hljs-number">0.046</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.751</span></span> SS_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.945</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> SS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.990</span></span> SS_MLP: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.973</span></span> SS_BG: train = <span class="hljs-number"><span class="hljs-number">0.947</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> SS_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> SS_AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> SS_GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> MMS_LR: train = <span class="hljs-number"><span class="hljs-number">0.961</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.953</span></span> MMS_LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> MMS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> MMS_CART: train = <span class="hljs-number"><span class="hljs-number">0.850</span></span> (<span class="hljs-number"><span class="hljs-number">0.027</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.840</span></span> MMS_NB: train = <span class="hljs-number"><span class="hljs-number">0.796</span></span> (<span class="hljs-number"><span class="hljs-number">0.045</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.786</span></span> MMS_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.958</span></span> MMS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.963</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.956</span></span> MMS_MLP: train = <span class="hljs-number"><span class="hljs-number">0.972</span></span> (<span class="hljs-number"><span class="hljs-number">0.011</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.963</span></span> MMS_BG: train = <span class="hljs-number"><span class="hljs-number">0.948</span></span> (<span class="hljs-number"><span class="hljs-number">0.024</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> MMS_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> MMS_ET: train = <span class="hljs-number"><span class="hljs-number">0.983</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> MMS_AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> MMS_GB: train = <span class="hljs-number"><span class="hljs-number">0.963</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> N_LR: train = <span class="hljs-number"><span class="hljs-number">0.938</span></span> (<span class="hljs-number"><span class="hljs-number">0.020</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.919</span></span> N_LDA: train = <span class="hljs-number"><span class="hljs-number">0.952</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.949</span></span> N_KNN: train = <span class="hljs-number"><span class="hljs-number">0.981</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.985</span></span> N_CART: train = <span class="hljs-number"><span class="hljs-number">0.834</span></span> (<span class="hljs-number"><span class="hljs-number">0.028</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.825</span></span> N_NB: train = <span class="hljs-number"><span class="hljs-number">0.825</span></span> (<span class="hljs-number"><span class="hljs-number">0.043</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.805</span></span> N_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.960</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.953</span></span> N_SVC: train = <span class="hljs-number"><span class="hljs-number">0.551</span></span> (<span class="hljs-number"><span class="hljs-number">0.053</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.586</span></span> N_MLP: train = <span class="hljs-number"><span class="hljs-number">0.963</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> N_BG: train = <span class="hljs-number"><span class="hljs-number">0.949</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.938</span></span> N_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> N_ET: train = <span class="hljs-number"><span class="hljs-number">0.982</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.980</span></span> N_AB: train = <span class="hljs-number"><span class="hljs-number">0.825</span></span> (<span class="hljs-number"><span class="hljs-number">0.040</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.820</span></span> N_GB: train = <span class="hljs-number"><span class="hljs-number">0.953</span></span> (<span class="hljs-number"><span class="hljs-number">0.022</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.956</span></span></code> </pre> <br>  Resultados dos "5 principais": <br><br><pre> <code class="python hljs">SS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.990</span></span> N_KNN: train = <span class="hljs-number"><span class="hljs-number">0.981</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.985</span></span> KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> MMS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> MMS_ET: train = <span class="hljs-number"><span class="hljs-number">0.983</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span></code> </pre> <br>  Assim, de acordo com os resultados de um teste de blitz dos algoritmos de aprendizado de m√°quina para resolver o problema de classifica√ß√£o do conjunto de dados 'd√≠gitos', os algoritmos de aprendizado de m√°quina mais adequados s√£o: o m√©todo k-vizinhos mais pr√≥ximos ('KNN'), o m√©todo do vetor de suporte ('SVC') e extra-√°rvores (¬´ET¬ª).  Esses algoritmos devem prestar mais aten√ß√£o ao desenvolvimento de resultados que visem aumentar a efici√™ncia dos c√°lculos.  Tudo, como se costuma dizer, √© solucion√°vel. <br><br>  E nesta nota levantada, prossiga sem problemas para a 2¬™ parte. <br><br><h3>  Problema de previs√£o </h3><br>  Passamos o polegar: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      from sklearn.datasets import load_boston from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.linear_model import Ridge from sklearn.linear_model import Lasso from sklearn.linear_model import ElasticNet from sklearn.linear_model import LarsCV from sklearn.linear_model import BayesianRidge from sklearn.neighbors import KNeighborsRegressor from sklearn.tree import DecisionTreeRegressor from sklearn.svm import LinearSVR from sklearn.svm import SVR from sklearn.ensemble import AdaBoostRegressor from sklearn.ensemble import BaggingRegressor from sklearn.ensemble import ExtraTreesRegressor from sklearn.ensemble import GradientBoostingRegressor from sklearn.ensemble import RandomForestRegressor from sklearn.model_selection import KFold from sklearn.model_selection import cross_val_score from sklearn.pipeline import Pipeline from sklearn.preprocessing import StandardScaler from sklearn.preprocessing import Normalizer from matplotlib import pyplot #    dataset = load_boston()</span></span></code> </pre> <br>  Execute o c√≥digo e lide com o dicion√°rio.  Descri√ß√£o e chaves s√£o as seguintes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e2/80f/4e2/1e280f4e239b31bae42274ab21c42d29.png" alt="imagem"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/24a/448/05a/24a44805af40951d544ef8cc6637c52a.png" alt="imagem"><br><br>  Atribu√≠mos a chave 'data' √† vari√°vel <i>X</i> , que √© um array NumPy multidimensional com um conjunto de atributos, dimensione 506 linhas por 13 colunas e a vari√°vel <i>Y</i> - 'target', um array NumPy multidimensional com um marcador para cada linha. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    #dataset = load_boston() X = dataset.data Y = dataset.target</span></span></code> </pre> <br>  Dividimos o conjunto de dados em partes de treinamento e teste, configuramos os par√¢metros para avaliar os algoritmos.  No par√¢metro 'scoring', definimos uma das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√©tricas 'r2'</a> tradicional para an√°lise de regress√£o: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    dataset = load_boston() X = dataset.data Y = dataset.target #         test_size = 0.2 seed = 7 X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_size, random_state=seed) #     num_folds = 10 n_iter = 1000 n_estimators = 100 scoring = 'r2'</span></span></code> </pre> <br>  R2 - coeficiente de determina√ß√£o - √© a propor√ß√£o da vari√¢ncia da vari√°vel dependente, explicada pelo modelo em quest√£o ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ). <br><br>  <i>‚ÄúO coeficiente de determina√ß√£o para um modelo com uma constante leva valores de 0 a 1. Quanto mais pr√≥ximo o coeficiente de 1, maior a depend√™ncia.</i>  <i>Ao avaliar modelos de regress√£o, isso √© interpretado como correspondendo o modelo aos dados.</i>  <i>Para modelos aceit√°veis, assume-se que o coeficiente de determina√ß√£o deve ser de pelo menos 50% (neste caso, o coeficiente de correla√ß√£o m√∫ltipla excede o m√≥dulo de 70%).</i>  <i>Modelos com um coeficiente de determina√ß√£o acima de 80% podem ser considerados bastante bons (o coeficiente de correla√ß√£o excede 90%).</i>  <i>A igualdade do coeficiente de determina√ß√£o com a unidade significa que a vari√°vel explicada √© exatamente descrita pelo modelo em considera√ß√£o ‚Äù</i> (ibid.). <br><br>  Para resolver o problema de previs√£o, usamos os seguintes algoritmos: <br><br><h4>  Algoritmos lineares: </h4><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regress√£o linear</a> ('LR') <br>  - Regress√£o de Ridge (regress√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ridge</a> ) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regress√£o de Ridge</a> ('R') <br>  - Regress√£o do la√ßo (do ingl√™s LASSO - Operador de Sele√ß√£o e Retra√ß√£o Menos Absolutos) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regress√£o do la√ßo</a> ('L') <br>  - M√©todo de regress√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">regress√£o l√≠quida el√°stica</a> ('ELN') <br>  - M√©todo da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">regress√£o com √¢ngulo m√≠nimo</a> (LARS) ('LARS') <br>  - Regress√£o da crista bayesiana / regress√£o da crista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bayesiana</a> ('BR') <br><br><h4>  Algoritmos n√£o lineares: </h4><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√©todo k-regressor de vizinhos mais pr√≥ximos</a> ('KNR') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regressor da √°rvore de decis√£o</a> ('DTR') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">M√°quina de vetores de suporte linear</a> (regress√£o) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">M√°quina de vetores de suporte linear - regress√£o</a> / ('LSVR') <br>  - M√©todo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vetor de suporte</a> (regress√£o) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">regress√£o do vetor de suporte Epsilon</a> ('SVR') <br><br><h4>  Algoritmos do conjunto: </h4><br>  - AdaBoost (regress√£o) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AdaBoost Regressor</a> ('ABR') (AdaBoost = refor√ßo adaptativo) <br>  - Ensacamento (regress√£o) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regressor de ensacamento</a> ('BR') (Ensacamento = agrega√ß√£o de Bootstrap) <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regressor de √°rvores extras</a> ('ETR') <br>  - Refor√ßo de gradiente (regress√£o) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regressor de refor√ßo de gradiente</a> ('GBR') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classifica√ß√£o aleat√≥ria de floresta</a> (regress√£o) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classificador aleat√≥rio de floresta</a> ('RFR') <br><br>  Assim, a lista de 'modelos' cont√©m os seguintes modelos: <br><br><pre> <code class="python hljs">models = [] models.append((<span class="hljs-string"><span class="hljs-string">'LR'</span></span>, LinearRegression())) models.append((<span class="hljs-string"><span class="hljs-string">'R'</span></span>, Ridge())) models.append((<span class="hljs-string"><span class="hljs-string">'L'</span></span>, Lasso())) models.append((<span class="hljs-string"><span class="hljs-string">'ELN'</span></span>, ElasticNet())) models.append((<span class="hljs-string"><span class="hljs-string">'LARS'</span></span>, Lars())) models.append((<span class="hljs-string"><span class="hljs-string">'BR'</span></span>, BayesianRidge(n_iter=n_iter))) models.append((<span class="hljs-string"><span class="hljs-string">'KNR'</span></span>, KNeighborsRegressor())) models.append((<span class="hljs-string"><span class="hljs-string">'DTR'</span></span>, DecisionTreeRegressor())) models.append((<span class="hljs-string"><span class="hljs-string">'LSVR'</span></span>, LinearSVR())) models.append((<span class="hljs-string"><span class="hljs-string">'SVR'</span></span>, SVR())) models.append((<span class="hljs-string"><span class="hljs-string">'ABR'</span></span>, AdaBoostRegressor(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'BR'</span></span>, BaggingRegressor(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'ETR'</span></span>, ExtraTreesRegressor(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'GBR'</span></span>, GradientBoostingRegressor(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'RFR'</span></span>, RandomForestRegressor(n_estimators=n_estimators)))</code> </pre> <br>  Como na classifica√ß√£o, a avalia√ß√£o da efic√°cia de cada algoritmo √© feita usando a valida√ß√£o cruzada.  A mensagem exibida cont√©m as seguintes informa√ß√µes: o nome do modelo na forma de uma abrevia√ß√£o, a pontua√ß√£o m√©dia de uma valida√ß√£o cruzada de 10 vezes nos dados de treinamento (m√©trica 'r2'), o desvio padr√£o e o coeficiente de determina√ß√£o r2 nos dados de teste s√£o mostrados entre colchetes. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      scores = [] names = [] results = [] predictions = [] msg_row = [] for name, model in models: kfold = KFold(n_splits=num_folds, random_state=seed) cv_results = cross_val_score(model, X_train, Y_train, cv=kfold, scoring=scoring) names.append(name) results.append(cv_results) m_fit = model.fit(X_train, Y_train) m_predict = model.predict(X_test) predictions.append(m_predict) m_score = model.score(X_test, Y_test) scores.append(m_score) msg = "%s: train = %.3f (%.3f) / test = %.3f" % (name, cv_results.mean(), cv_results.std(), m_score) msg_row.append(msg) print(msg) #   (¬´  ¬ª) fig = pyplot.figure() fig.suptitle('   ') ax = fig.add_subplot(111) red_square = dict(markerfacecolor='r', marker='s') pyplot.boxplot(results, flierprops=red_square) ax.set_xticklabels(names, rotation=45) pyplot.show()</span></span></code> </pre> <br>  Depois de executar o c√≥digo, obtemos os seguintes resultados: <br><br><pre> <code class="python hljs">LR: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> R: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.067</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.570</span></span> L: train = <span class="hljs-number"><span class="hljs-number">0.689</span></span> (<span class="hljs-number"><span class="hljs-number">0.070</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.641</span></span> ELN: train = <span class="hljs-number"><span class="hljs-number">0.677</span></span> (<span class="hljs-number"><span class="hljs-number">0.074</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.662</span></span> LARS: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> BR: train = <span class="hljs-number"><span class="hljs-number">0.739</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.571</span></span> KNR: train = <span class="hljs-number"><span class="hljs-number">0.434</span></span> (<span class="hljs-number"><span class="hljs-number">0.288</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.538</span></span> DTR: train = <span class="hljs-number"><span class="hljs-number">0.671</span></span> (<span class="hljs-number"><span class="hljs-number">0.145</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.637</span></span> LSVR: train = <span class="hljs-number"><span class="hljs-number">0.550</span></span> (<span class="hljs-number"><span class="hljs-number">0.144</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.459</span></span> SVR: train = <span class="hljs-number"><span class="hljs-number">-0.012</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">-0.003</span></span> ABR: train = <span class="hljs-number"><span class="hljs-number">0.810</span></span> (<span class="hljs-number"><span class="hljs-number">0.078</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.763</span></span> BR: train = <span class="hljs-number"><span class="hljs-number">0.854</span></span> (<span class="hljs-number"><span class="hljs-number">0.064</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.805</span></span> ETR: train = <span class="hljs-number"><span class="hljs-number">0.889</span></span> (<span class="hljs-number"><span class="hljs-number">0.047</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.836</span></span> GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.042</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.863</span></span> RFR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.819</span></span></code> </pre> <br>  Gr√°fico de amplitude: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a7/140/96c/2a714096c35498ccddc267298f502a6a.png" alt="imagem"><br><br>  Os l√≠deres √≥bvios s√£o os m√©todos de conjunto 'GBR' (gradiente 'refor√ßo'), 'ETR' (extra-√°rvores), 'RFR' (floresta aleat√≥ria) e 'BR' ('ensacamento'): <br><br><pre> <code class="python hljs">GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.042</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.863</span></span> ETR: train = <span class="hljs-number"><span class="hljs-number">0.889</span></span> (<span class="hljs-number"><span class="hljs-number">0.047</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.836</span></span> RFR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.819</span></span> BR: train = <span class="hljs-number"><span class="hljs-number">0.854</span></span> (<span class="hljs-number"><span class="hljs-number">0.064</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.805</span></span> ABR: train = <span class="hljs-number"><span class="hljs-number">0.810</span></span> (<span class="hljs-number"><span class="hljs-number">0.078</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.763</span></span> ELN: train = <span class="hljs-number"><span class="hljs-number">0.677</span></span> (<span class="hljs-number"><span class="hljs-number">0.074</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.662</span></span> L: train = <span class="hljs-number"><span class="hljs-number">0.689</span></span> (<span class="hljs-number"><span class="hljs-number">0.070</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.641</span></span> DTR: train = <span class="hljs-number"><span class="hljs-number">0.671</span></span> (<span class="hljs-number"><span class="hljs-number">0.145</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.637</span></span> LR: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> LARS: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> BR: train = <span class="hljs-number"><span class="hljs-number">0.739</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.571</span></span> R: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.067</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.570</span></span> KNR: train = <span class="hljs-number"><span class="hljs-number">0.434</span></span> (<span class="hljs-number"><span class="hljs-number">0.288</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.538</span></span> LSVR: train = <span class="hljs-number"><span class="hljs-number">0.550</span></span> (<span class="hljs-number"><span class="hljs-number">0.144</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.459</span></span> SVR: train = <span class="hljs-number"><span class="hljs-number">-0.012</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">-0.003</span></span></code> </pre> <br>  Um "adabust", "loshara", fica para tr√°s. <br><br>  Talvez os tr√™s l√≠deres estejam combatendo a padroniza√ß√£o e a normaliza√ß√£o.  Vamos descobrir executando o restante do c√≥digo. <br><br>  Os resultados s√£o os seguintes: <br><br><pre> <code class="python hljs">SS_LR: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> SS_R: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.578</span></span> SS_L: train = <span class="hljs-number"><span class="hljs-number">0.678</span></span> (<span class="hljs-number"><span class="hljs-number">0.054</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.510</span></span> SS_ELN: train = <span class="hljs-number"><span class="hljs-number">0.665</span></span> (<span class="hljs-number"><span class="hljs-number">0.060</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.513</span></span> SS_LARS: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> SS_BR: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.066</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.576</span></span> SS_KNR: train = <span class="hljs-number"><span class="hljs-number">0.763</span></span> (<span class="hljs-number"><span class="hljs-number">0.098</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.739</span></span> SS_DTR: train = <span class="hljs-number"><span class="hljs-number">0.610</span></span> (<span class="hljs-number"><span class="hljs-number">0.242</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.629</span></span> SS_LSVR: train = <span class="hljs-number"><span class="hljs-number">0.727</span></span> (<span class="hljs-number"><span class="hljs-number">0.091</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.482</span></span> SS_SVR: train = <span class="hljs-number"><span class="hljs-number">0.653</span></span> (<span class="hljs-number"><span class="hljs-number">0.126</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.610</span></span> SS_ABR: train = <span class="hljs-number"><span class="hljs-number">0.811</span></span> (<span class="hljs-number"><span class="hljs-number">0.076</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.819</span></span> SS_BR: train = <span class="hljs-number"><span class="hljs-number">0.853</span></span> (<span class="hljs-number"><span class="hljs-number">0.074</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.813</span></span> SS_ETR: train = <span class="hljs-number"><span class="hljs-number">0.887</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.846</span></span> SS_GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.038</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.860</span></span> SS_RFR: train = <span class="hljs-number"><span class="hljs-number">0.851</span></span> (<span class="hljs-number"><span class="hljs-number">0.071</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.818</span></span> N_LR: train = <span class="hljs-number"><span class="hljs-number">0.751</span></span> (<span class="hljs-number"><span class="hljs-number">0.099</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.576</span></span> N_R: train = <span class="hljs-number"><span class="hljs-number">0.287</span></span> (<span class="hljs-number"><span class="hljs-number">0.126</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.271</span></span> N_L: train = <span class="hljs-number"><span class="hljs-number">-0.030</span></span> (<span class="hljs-number"><span class="hljs-number">0.032</span></span>) / test = <span class="hljs-number"><span class="hljs-number">-0.000</span></span> N_ELN: train = <span class="hljs-number"><span class="hljs-number">-0.007</span></span> (<span class="hljs-number"><span class="hljs-number">0.030</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.023</span></span> N_LARS: train = <span class="hljs-number"><span class="hljs-number">0.751</span></span> (<span class="hljs-number"><span class="hljs-number">0.099</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.576</span></span> N_BR: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.100</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.589</span></span> N_KNR: train = <span class="hljs-number"><span class="hljs-number">0.485</span></span> (<span class="hljs-number"><span class="hljs-number">0.192</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.504</span></span> N_DTR: train = <span class="hljs-number"><span class="hljs-number">0.729</span></span> (<span class="hljs-number"><span class="hljs-number">0.080</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.765</span></span> N_LSVR: train = <span class="hljs-number"><span class="hljs-number">0.182</span></span> (<span class="hljs-number"><span class="hljs-number">0.108</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.136</span></span> N_SVR: train = <span class="hljs-number"><span class="hljs-number">0.086</span></span> (<span class="hljs-number"><span class="hljs-number">0.076</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.084</span></span> N_ABR: train = <span class="hljs-number"><span class="hljs-number">0.795</span></span> (<span class="hljs-number"><span class="hljs-number">0.053</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.752</span></span> N_BR: train = <span class="hljs-number"><span class="hljs-number">0.854</span></span> (<span class="hljs-number"><span class="hljs-number">0.054</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.827</span></span> N_ETR: train = <span class="hljs-number"><span class="hljs-number">0.877</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.850</span></span> N_GBR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.063</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.872</span></span> N_RFR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.051</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.801</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ pode ver, os m√©todos de conjunto ainda est√£o √† frente de todos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'Top 5' cont√©m os seguintes resultados:</font></font><br><br><pre> <code class="python hljs">N_GBR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.063</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.872</span></span> GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.042</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.863</span></span> SS_GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.038</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.860</span></span> N_ETR: train = <span class="hljs-number"><span class="hljs-number">0.877</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.850</span></span> SS_ETR: train = <span class="hljs-number"><span class="hljs-number">0.887</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.846</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos exibir um gr√°fico comparando os resultados: o </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b1/9a0/cc6/8b19a0cc6379c2337c9082eedd415585.jpg" alt="imagem"><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teste Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© o padr√£o. Os cinco resultados selecionados mostrados no diagrama s√£o indicados por uma linha tracejada. Pode-se observar que todos os picos foram reproduzidos com repeti√ß√£o exata ou em um grau ou outro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trecho curto da compara√ß√£o manual dos valores de refer√™ncia e dos valores de previs√£o do algoritmo inclu√≠do no Top 5: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/711/0a7/2de/7110a72de1daa81209ecaee33542dfef.png" alt="imagem"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, de acordo com os resultados de um teste de blitz de algoritmos de aprendizado de m√°quina para resolver o problema de prever o conjunto de dados 'pre√ßo da casa de boston', os algoritmos mais adequados s√£o o ‚Äúimpulso‚Äù de gradiente ('GBR ') e √°rvores extras (' ETR '). Esses algoritmos devem receber mais aten√ß√£o para desenvolver ainda mais os resultados e aumentar a efic√°cia das previs√µes.</font></font><br><br><h3>  Posf√°cio </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma verifica√ß√£o r√°pida dos algoritmos de aprendizado de m√°quina permite, em uma primeira aproxima√ß√£o, identificar os algoritmos mais eficazes para resolver problemas de classifica√ß√£o e an√°lise de regress√£o (previs√£o). Ficamos convencidos disso processando o conjunto de dados 'd√≠gitos', classificando de forma brilhante as inst√¢ncias em 10 classes, bem como o conjunto de dados 'pre√ßo da casa de boston', classificando de maneira "surpreendente" a localiza√ß√£o de depend√™ncias e a previs√£o "flutuante" da vari√°vel dependente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ est√° convidado a experimentar esse m√©todo em seus pr√≥prios conjuntos de dados ou naqueles que voc√™ pode cavar em v√°rios reposit√≥rios, incluindo o GitHub. Por exemplo: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenha um conjunto de dados adequado para o alvo - e defina um monte de algoritmos nele na equipe do teste de blitz. E a√≠ fica claro de quem √©: quem est√° no campo n√£o √© um guerreiro.</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E em conclus√£o. Serei grato por seus coment√°rios, perguntas e sugest√µes, pois a base deste artigo √© a informa√ß√£o que compartilho com novos colegas em cada novo projeto no campo de aprendizado de m√°quina. Cada um deles tem sua pr√≥pria especializa√ß√£o, sobre aprendizado de m√°quina e redes neurais artificiais, muitos deles apenas "ouvidos em algum lugar", por isso √© importante para mim falar sobre complexos, multifacetados e, finalmente, inexpugn√°veis ‚Äã‚Äã(trata-se de RNA e aprendizado de m√°quina em geral) :), em uma linguagem simples e compreens√≠vel; mostre que n√£o s√£o os deuses que queimam panelas; e que, se houver interesse, mais de uma d√∫zia de algoritmos podem ser "aproveitados".</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS No final do artigo, comecei a me prever, ent√£o, para as pr√≥ximas perguntas sobre onde obtive as dicas na primeira figura que forne√ßo: tudo no mesmo site scikit-learn.org ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'Escolhendo o estimador certo'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">E a personifica√ß√£o da intelig√™ncia artificial na forma de um Samodelkin corado √© assim das ondas de mem√≥ria da minha inf√¢ncia feliz.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt475552/">https://habr.com/ru/post/pt475552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt475542/index.html">Como o marketing por email mudou desde 2013: 4 principais tend√™ncias e estat√≠sticas atuais</a></li>
<li><a href="../pt475544/index.html">Cat√°logos de produtos, servi√ßos e muito mais</a></li>
<li><a href="../pt475546/index.html">S√≠ndromes viciantes de TI</a></li>
<li><a href="../pt475548/index.html">Matchmaking chato, sem desequil√≠brio e filas: um guia pr√°tico</a></li>
<li><a href="../pt475550/index.html">Sistemas ac√∫sticos para salas abertas</a></li>
<li><a href="../pt475554/index.html">T√©cnicas de design de interface do usu√°rio que economizam tempo</a></li>
<li><a href="../pt475556/index.html">Mudan√ßa para Munique. O caminho dos escaladores da Amazon para o emprego dos sonhos da Amazon</a></li>
<li><a href="../pt475558/index.html">Dicion√°rio de TI ou o qu√™? Onde Para onde? Parte 1</a></li>
<li><a href="../pt475560/index.html">KotlinConf 2019 Live: Assista ao vivo de 5 a 6 de dezembro</a></li>
<li><a href="../pt475562/index.html">MVC no Unity com objetos program√°veis. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>