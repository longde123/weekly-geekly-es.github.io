<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🌾 🤶🏿 🛬 Algoritmos de aprendizado de máquina de teste de blitz: alimente seu conjunto de dados na biblioteca scikit-learn 👩🏽‍🎤 🖕🏻 🛋️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos os dias a web global é reabastecida com artigos sobre os algoritmos de aprendizado de máquina mais populares e usados ​​para solucionar vários p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritmos de aprendizado de máquina de teste de blitz: alimente seu conjunto de dados na biblioteca scikit-learn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475552/"><img src="https://habrastorage.org/getpro/habr/post_images/7d1/0a1/6c9/7d10a16c9f50f8289a4b30eb53ffc661.jpg" alt="imagem"><br><br>  Todos os dias a web global é reabastecida com artigos sobre os algoritmos de aprendizado de máquina mais populares e usados ​​para solucionar vários problemas.  Além disso, a base desses artigos, ligeiramente alterada na forma de um lugar ou de outro, passa de um pesquisador de dados para outro.  Além disso, todos esses trabalhos são unidos por um postulado geralmente aceito e incontestável: a aplicação de um ou outro algoritmo de aprendizado de máquina depende do tamanho e da natureza dos dados disponíveis e da tarefa em questão. <br><br>  Além disso, pesquisadores de dados especialmente insistidos, compartilhando sua experiência, enfatizam: <i>“A escolha de um método de avaliação deve depender parcialmente dos seus dados e do que, na sua opinião, o modelo deve ser bom” (“Ciência de Dados: informações privilegiadas para iniciantes. Incluindo a linguagem R, de Cathy O'Neill, Rachel Shutt)</i> . <br><a name="habracut"></a><br>  Em outras palavras, um estatístico / pesquisador de dados deve ter não apenas experiência na área de assunto, mas também uma ampla gama de conhecimentos variados: <i>“Um pesquisador de dados é aquele que possui conhecimento nas seguintes áreas: matemática, estatística, engenharia da computação, aprendizado de máquina, visualização, meios de troca de dados ... ”</i> (do mesmo livro).  Somente o carregamento completo do conhecimento das áreas acima na cabeça pode ser abordado no aprendizado de máquina e encontrar soluções para os problemas indicados. <br><br>  Quanto a mim, esse começo é bastante adequado para um livro comum de meio quilo e meio de ciência de dados, ou para um artigo de história de horror científico com fórmulas, símbolos e rabiscos de dois andares "inúteis" subsequentes que têm um impacto grave e deprimente para iniciantes no campo de aprendizado de máquina e apenas por acaso interessados ​​nessa direção, leitores inexperientes, não sobrecarregados com o "conhecimento necessário".  Além disso, o número 10 da rodada dos mesmos artigos sobre os 10 algoritmos de aprendizado de máquina mais populares ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">por exemplo</a> ) apenas reforça o efeito imposto. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">No habr, eles também se distinguiram</a> : <i>“A resposta à pergunta:“ Que tipo de algoritmo de aprendizado de máquina devo usar? ”Sempre soa assim:“ Dependendo das circunstâncias ”.</i>  <i>A escolha do algoritmo depende do volume, qualidade e natureza dos dados.</i>  <i>Depende de como você gerencia o resultado.</i>  <i>Depende de como as instruções para o computador que o implementa foram criadas a partir do algoritmo e também de quanto tempo você tem.</i>  <i>Mesmo os analistas de dados mais experientes não vão dizer qual algoritmo é melhor até que eles o testem. ”</i> <br><br>  Sem dúvida, todo esse conhecimento, bem como perseverança e interesse, são necessários e úteis para alcançar bons resultados, não apenas no caminho para a compreensão do aprendizado de máquina, mas também em muitas outras áreas.  Além disso, facilitarão o entendimento de que os algoritmos de aprendizado de máquina (a seguir denominados algoritmos) estão longe de uma dúzia;  mas isso é apenas mais tarde, com estudo independente. <br><br>  Meu objetivo é apresentar ao leitor os algoritmos mais utilizados de um ponto de vista prático e acessível.  (O fato de eu não ser um programador e, além disso, não um matemático (santo-santo-santo!) Deve sublinhar o interesse na narrativa. O ensino de engenharia e a experiência no "assunto crescem" de 10 anos (apenas algum tipo de número mágico ) - como se costuma dizer, e todas as minhas coisas, todas as minhas malas com as quais fui direto para o aprendizado de máquina.Graças à experiência adquirida na indústria do petróleo, foram encontradas idéias para o uso de redes neurais artificiais e algoritmos de aprendizado de máquina (leia - eram necessárias conjuntos de dados.) Tudo o que restava era lidar com  Scarlet - aprenda a distorcer os dados para enviá-los corretamente à entrada do "programa" e qual, de fato, o algoritmo a ser escolhido. E então em um círculo vicioso. Percebo que meu caminho era espinhoso e divertido - "balas assobiavam no alto" (de m / f "As aventuras de Funtik"), - mas ainda assim eu consegui fazer anotações e, se o interesse for indicado, no futuro publicarei outras mensagens.) <br><br>  Então, proponho abordar a "usinagem", por outro lado: por que não alimentar seu conjunto de dados existente (nos exemplos você carregará conjuntos de dados que podem ser facilmente treinados) para vários algoritmos de uma só vez e, de acordo com os resultados, decida qual deles deve prestar mais atenção estudo cuidadoso subsequente e seleção de parâmetros ideais que melhoram o resultado.  Além disso, o principal valor do método discutido acima é que seus resultados responderão à pergunta sobre o valor de seu conjunto de dados: <i>"comece resolvendo o problema e verifique se você tem algo para otimizar"</i> (também de alguns então as estatísticas insistentes diziam "respeito" a ele, um bom conselho!). <br><br>  Como é feito? <br><br>  Sabe-se que a maior parte dos problemas resolvidos com a ajuda de algoritmos está relacionada aos problemas de classificação (classificação) e análise de regressão (análise preditiva).  Por <i>classificação</i> entende-se uma diferenciação constante de unidades de observação (instâncias) de um conjunto de dados para uma determinada categoria (classe) com base nos resultados do treinamento.  <i>A análise de regressão</i> é um conjunto de métodos e processos estatísticos para avaliar a relação entre variáveis ​​[ <i>Statistics: Textbook / Ed.</i>  <i>prof.</i>  <i>M.R.</i>  <i>Efimova.</i>  <i>- M.: INFRA-M, 2002</i> ].  O objetivo da análise de regressão é avaliar o valor de uma variável de saída contínua a partir dos valores das variáveis ​​de entrada [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ]. <br><br>  Deixamos de lado o fato de que a análise de regressão tem à sua disposição dois métodos diferentes - modelagem preditiva e previsão.  Observamos apenas que, se houver uma série temporal (dados de séries temporais), usando um modelo de regressão baseado em uma tendência explícita, sujeita à estacionariedade (constância), a previsão poderá ser realizada.  Se as condições para a formação de níveis das séries temporais mudarem, ou seja, o processo não estacionário não for observado, então cabe à modelagem preditiva.  Particularmente visando o domínio completo da ML, proponho a leitura deste artigo em inglês: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> .  Se surgir uma discussão sobre isso, terei prazer em participar. <br><br>  Como as séries temporais não serão usadas nos exemplos deste artigo, o termo <i>previsão</i> se refere à <i>análise preditiva</i> . <br><br>  Para resolver os problemas de classificação e previsão, é adequado todo um conjunto de algoritmos, alguns dos quais consideraremos mais adiante.  Por conveniência, o texto subseqüente será dividido em duas partes: na primeira, consideramos os algoritmos de classificação mais comuns, na segunda, dedicamos aos algoritmos de análise de regressão.  Para cada parte, será apresentado um conjunto de dados de "brinquedo" carregado da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca</a> scikit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">-learn</a> (v0.21.3): <i>conjunto de dados de dígitos (classificação)</i> e <i>conjunto de dados de preços da casa de Boston (regressão)</i> , bem como links para cada algoritmo da biblioteca scikit-learn para auto-exame e, possivelmente, estudo. <br><br>  Todos os exemplos de código são executados no console do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IDE Spyder</a> 3.3.3 no Python 3.7.3. <br><br><h3>  Problema de classificação </h3><br>  Primeiro, importamos os módulos e funções necessários que usaremos para resolver o problema de classificação de dados: <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      from sklearn.datasets import load_digits from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.discriminant_analysis import LinearDiscriminantAnalysis from sklearn.neighbors import KNeighborsClassifier from sklearn.tree import DecisionTreeClassifier from sklearn.naive_bayes import GaussianNB from sklearn.svm import LinearSVC from sklearn.svm import SVC from sklearn.neural_network import MLPClassifier from sklearn.ensemble import BaggingClassifier from sklearn.ensemble import RandomForestClassifier from sklearn.ensemble import ExtraTreesClassifier from sklearn.ensemble import AdaBoostClassifier from sklearn.ensemble import GradientBoostingClassifier from sklearn.model_selection import KFold from sklearn.model_selection import cross_val_score from sklearn.pipeline import Pipeline from sklearn.preprocessing import StandardScaler from sklearn.preprocessing import MinMaxScaler from sklearn.preprocessing import Normalizer from matplotlib import pyplot</span></span></code> </pre> <br>  Faça o download do conjunto de dados 'dígitos' diretamente do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">módulo 'sklearn.datasets'</a> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    dataset = load_digits()</span></span></code> </pre> <br>  O IDE Spyder fornece uma ferramenta conveniente "Variable Manager", que é útil em todos os momentos do aprendizado de máquina (pelo menos para mim), como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outros "truques"</a> : <br><br>  Execute o código.  No console "gerenciador de variáveis", clique na variável do <i>conjunto de dados</i> .  O seguinte dicionário é exibido: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9f/362/64a/f9f36264a8a368644793b6f4ed7ad045.png" alt="imagem"><br><br>  A descrição do conjunto de dados é a seguinte: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/887/659/b2b/887659b2bc79bfd532c30d6ddee8aa5e.png" alt="imagem"><br><br>  Neste exemplo, não precisamos da chave 'images'; portanto, atribuímos a variável 'data' a <i>X</i> , que é um array NumPy multidimensional com um conjunto de atributos, 1797 linhas em 64 colunas e a variável <i>Y</i> a 'target', um array multidimensional NumPy com um marcador para cada string. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    # dataset = load_digits() X = dataset.data Y = dataset.target</span></span></code> </pre> <br>  Em seguida, dividimos o conjunto de dados nas partes de treinamento e teste, configuramos os parâmetros para avaliar os algoritmos (a validação cruzada é usada [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dois</a> ]), definindo a 'precisão' da métrica no parâmetro 'scoring' [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ].  Precisão é a proporção de objetos classificados corretamente em relação ao número total de objetos.  Quanto mais próximo o resultado de 1, melhor [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ].  Além disso, em um dos livros, verificou-se que os resultados de 0,95 (ou 95%) e superiores são considerados excelentes. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#         test_size = 0.2 seed = 7 X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_size, random_state=seed) #     num_folds = 10 n_estimators = 100 scoring = 'accuracy'</span></span></code> </pre> <br>  <i>Permita que as</i> variáveis <i>X_train</i> e <i>Y_train sejam usadas</i> para fins de treinamento, <i>X_test</i> e <i>Y_test</i> para o desenvolvimento de valores de previsão.  Nesse caso, a variável <i>Y_test</i> não <i>está</i> envolvida no cálculo da previsão: usando o método de pontuação, que é o mesmo para cada um dos algoritmos apresentados abaixo, calcularemos as respostas corretas usando a métrica de precisão.  Isso nos permitirá julgar como o algoritmo lida com a tarefa.  Eu não discuto, por nossa parte, é tão humanamente vil não pedir ao carro as respostas corretas, mas de que outra forma verificar seu desempenho? <br><br>  Abaixo está uma lista de algoritmos com os quais alimentamos o conjunto de dados.  Com base nos resultados dos cálculos, concluiremos qual algoritmo (qual dos algoritmos) mostra a maior eficiência.  Esse método pode muito bem ser chamado de <b>"teste de blitz de algoritmos de aprendizado de máquina"</b> (doravante - teste de blitz). <br><br>  Por conveniência, as informações serão abreviadas ao lado de cada algoritmo.  Deve-se notar que as configurações de cada algoritmo são aceitas por padrão (padrão), com exceção de alguns pontos, a fim de fornecer condições iguais. <br><br><h4>  Algoritmos lineares: </h4><br>  - Regressão logística * / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regressão logística</a> ('LR') <br>  <i>* A palavra "regressão" pode ser confusa.</i>  <i>Mas não esqueça que "Regressão Logística" é um algoritmo de classificação</i> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Análise Discriminante Linear</a> ('LDA') <br><br><h4>  Algoritmos não lineares: </h4><br>  - Método dos k vizinhos mais próximos (classificação) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">K-Neighbors Classifier</a> ('KNN') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificador da Árvore de Decisão</a> ('CART') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificador Naive Bayes</a> ('NB') <br>  - Método de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classificação de vetores de suporte linear</a> (classificação) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificação de vetores de suporte linear</a> ('LSVC') <br>  - Método do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vetor de suporte</a> (classificação) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificação do vetor de suporte C</a> ('SVC') <br><br><h4>  Algoritmo de rede neural artificial: </h4><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Perceptron multicamada</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Perceptrons multicamada</a> ('MLP') <br><br><h4>  Algoritmos do conjunto: </h4><br>  - Ensacamento (classificação) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificador de ensacados</a> ('BG') (Ensacamento = agregação de Bootstrap) <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificação florestal aleatória</a> ('RF') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificador de Árvores Extra</a> ('ET') <br>  - AdaBoost (classificação) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificador AdaBoost</a> ('AB') (AdaBoost = impulso adaptável) <br>  - Reforço de gradiente (classificação) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificador de reforço de gradiente</a> ('GB') <br><br>  Assim, a lista de 'modelos' contém os seguintes modelos: <br><br><pre> <code class="python hljs">models = [] models.append((<span class="hljs-string"><span class="hljs-string">'LR'</span></span>, LogisticRegression())) models.append((<span class="hljs-string"><span class="hljs-string">'LDA'</span></span>, LinearDiscriminantAnalysis())) models.append((<span class="hljs-string"><span class="hljs-string">'KNN'</span></span>, KNeighborsClassifier())) models.append((<span class="hljs-string"><span class="hljs-string">'CART'</span></span>, DecisionTreeClassifier())) models.append((<span class="hljs-string"><span class="hljs-string">'NB'</span></span>, GaussianNB())) models.append((<span class="hljs-string"><span class="hljs-string">'LSVC'</span></span>, LinearSVC())) models.append((<span class="hljs-string"><span class="hljs-string">'SVC'</span></span>, SVC())) models.append((<span class="hljs-string"><span class="hljs-string">'MLP'</span></span>, MLPClassifier())) models.append((<span class="hljs-string"><span class="hljs-string">'BG'</span></span>, BaggingClassifier(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'RF'</span></span>, RandomForestClassifier(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'ET'</span></span>, ExtraTreesClassifier(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'AB'</span></span>, AdaBoostClassifier(n_estimators=n_estimators, algorithm=<span class="hljs-string"><span class="hljs-string">'SAMME'</span></span>))) models.append((<span class="hljs-string"><span class="hljs-string">'GB'</span></span>, GradientBoostingClassifier(n_estimators=n_estimators)))</code> </pre> <br>  Como já mencionado, a eficácia de cada algoritmo é avaliada usando validação cruzada.  Como resultado, uma mensagem é exibida (msg - abreviação de mensagem) contendo as seguintes informações: nome do modelo na forma de uma abreviação, pontuação média de 10 vezes a validação cruzada nos dados de treinamento (métrica 'precisão'), o desvio padrão é mostrado entre parênteses , bem como o valor da métrica "precisão" nos dados de teste. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      scores = [] names = [] results = [] predictions = [] msg_row = [] for name, model in models: kfold = KFold(n_splits=num_folds, random_state=seed) cv_results = cross_val_score(model, X_train, Y_train, cv=kfold, scoring=scoring) names.append(name) results.append(cv_results) m_fit = model.fit(X_train, Y_train) m_predict = model.predict(X_test) predictions.append(m_predict) m_score = model.score(X_test, Y_test) scores.append(m_score) msg = "%s: train = %.3f (%.3f) / test = %.3f" % (name, cv_results.mean(), cv_results.std(), m_score) msg_row.append(msg) print(msg)</span></span></code> </pre> <br>  Depois de executar o código, obtemos os seguintes resultados: <br><br><pre> <code class="python hljs">LR: train = <span class="hljs-number"><span class="hljs-number">0.957</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> CART: train = <span class="hljs-number"><span class="hljs-number">0.843</span></span> (<span class="hljs-number"><span class="hljs-number">0.033</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.830</span></span> NB: train = <span class="hljs-number"><span class="hljs-number">0.819</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.806</span></span> LSVC: train = <span class="hljs-number"><span class="hljs-number">0.942</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.928</span></span> SVC: train = <span class="hljs-number"><span class="hljs-number">0.343</span></span> (<span class="hljs-number"><span class="hljs-number">0.079</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.342</span></span> MLP: train = <span class="hljs-number"><span class="hljs-number">0.972</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.961</span></span> BG: train = <span class="hljs-number"><span class="hljs-number">0.952</span></span> (<span class="hljs-number"><span class="hljs-number">0.021</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> RF: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.965</span></span> ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gráfico de amplitude</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“caixa com bigode”</a> ) (diagrama ou plotagem de caixas e bigodes, plotagem de caixas): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e3e/301/4c9/e3e3014c9931e3af6b7ea01eda90a0d0.png" alt="imagem"><br><br>  Como resultado de um teste de blitz em dados brutos, pode-se observar que os mais efetivos nos dados de teste foram os algoritmos 'KNN' (k-vizinhos mais próximos), 'ET' (extra-árvores), 'GB' (gradiente 'boosting'), 'RF' (floresta aleatória) e 'MLP' (perceptron multicamada): <br><br><pre> <code class="python hljs">KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> RF: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.965</span></span> MLP: train = <span class="hljs-number"><span class="hljs-number">0.972</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.961</span></span> LR: train = <span class="hljs-number"><span class="hljs-number">0.957</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> BG: train = <span class="hljs-number"><span class="hljs-number">0.952</span></span> (<span class="hljs-number"><span class="hljs-number">0.021</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> LSVC: train = <span class="hljs-number"><span class="hljs-number">0.942</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.928</span></span> CART: train = <span class="hljs-number"><span class="hljs-number">0.843</span></span> (<span class="hljs-number"><span class="hljs-number">0.033</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.830</span></span> AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> NB: train = <span class="hljs-number"><span class="hljs-number">0.819</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.806</span></span> SVC: train = <span class="hljs-number"><span class="hljs-number">0.343</span></span> (<span class="hljs-number"><span class="hljs-number">0.079</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.342</span></span></code> </pre> <br>  No entanto, muitos algoritmos são muito exigentes quanto aos dados em que são veiculados.  Portanto, uma das etapas necessárias é a chamada preparação preliminar de dados (pré-processamento de dados [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ]) <br><br>  No entanto, acontece que o algoritmo mostra os melhores resultados sem processamento preliminar.  Daí a seguinte recomendação: inclua no teste de blitz várias transformações do conjunto de dados original e, após realizar os cálculos, compare os resultados para capturar a essência do problema como um todo. <br><br>  Os métodos mais usados ​​para a preparação preliminar de dados são: <br><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padronização;</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escala</a> (o intervalo padrão é [0, 1]); <br><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">normalização</a> <br><br>  Essas operações com avaliação subsequente podem ser automatizadas e colocadas no transportador usando a ferramenta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pipeline</a> . <br><br>  Um trecho de código com padronização dos dados de origem é o seguinte: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -      #    ( StandardScaler) pipelines = [] pipelines.append(('SS_LR', Pipeline([('Scaler', StandardScaler()), ('LR', LogisticRegression())]))) pipelines.append(('SS_LDA', Pipeline([('Scaler', StandardScaler()), ('LDA', LinearDiscriminantAnalysis())]))) pipelines.append(('SS_KNN', Pipeline([('Scaler', StandardScaler()), ('KNN', KNeighborsClassifier())]))) pipelines.append(('SS_CART', Pipeline([('Scaler', StandardScaler()), ('CART', DecisionTreeClassifier())]))) pipelines.append(('SS_NB', Pipeline([('Scaler', StandardScaler()), ('NB', GaussianNB())]))) pipelines.append(('SS_LSVC', Pipeline([('Scaler', StandardScaler()), ('LSVC', LinearSVC())]))) pipelines.append(('SS_SVC', Pipeline([('Scaler', StandardScaler()), ('SVC', SVC())]))) pipelines.append(('SS_MLP', Pipeline([('Scaler', StandardScaler()), ('MLP', MLPClassifier())]))) pipelines.append(('SS_BG', Pipeline([('Scaler', StandardScaler()), ('BG', BaggingClassifier(n_estimators=n_estimators))]))) pipelines.append(('SS_RF', Pipeline([('Scaler', StandardScaler()), ('RF', RandomForestClassifier(n_estimators=n_estimators))]))) pipelines.append(('SS_ET', Pipeline([('Scaler', StandardScaler()), ('ET', ExtraTreesClassifier(n_estimators=n_estimators))]))) pipelines.append(('SS_AB', Pipeline([('Scaler', StandardScaler()), ('AB', AdaBoostClassifier(n_estimators=n_estimators, algorithm='SAMME'))]))) pipelines.append(('SS_GB', Pipeline([('Scaler', StandardScaler()), ('GB', GradientBoostingClassifier(n_estimators=n_estimators))]))) #      scores_SS = [] names_SS = [] results_SS = [] predictions_SS = [] msg_SS = [] for name, model in pipelines: kfold = KFold(n_splits=num_folds, random_state=seed) cv_results = cross_val_score(model, X_train, Y_train, cv=kfold) names_SS.append(name) results_SS.append(cv_results) m_fit = model.fit(X_train, Y_train) m_predict = model.predict(X_test) predictions_SS.append(m_predict) m_score = model.score(X_test, Y_test) scores_SS.append(m_score) msg = "%s: train = %.3f (%.3f) / test = %.3f" % (name, cv_results.mean(), cv_results.std(), m_score) msg_SS.append(msg) print(msg) #    (StandardScaler) fig = pyplot.figure() fig.suptitle('     . ') ax = fig.add_subplot(111) red_square = dict(markerfacecolor='r', marker='s') pyplot.boxplot(results_SS, flierprops=red_square) ax.set_xticklabels(names_SS, rotation=45) pyplot.show()</span></span></code> </pre> <br>  Observe a adição de '_SS' (abreviação de StandardScaler) para listar nomes.  Isso é feito para não acumular os resultados e exibi-los convenientemente usando o "gerenciador de variáveis" após a execução das conversões. <br><br>  A execução de um trecho de código produz os seguintes resultados: <br><br><pre> <code class="python hljs">SS_LR: train = <span class="hljs-number"><span class="hljs-number">0.958</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.949</span></span> SS_LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> SS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.023</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_CART: train = <span class="hljs-number"><span class="hljs-number">0.853</span></span> (<span class="hljs-number"><span class="hljs-number">0.036</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.835</span></span> SS_NB: train = <span class="hljs-number"><span class="hljs-number">0.756</span></span> (<span class="hljs-number"><span class="hljs-number">0.046</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.751</span></span> SS_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.945</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> SS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.990</span></span> SS_MLP: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.973</span></span> SS_BG: train = <span class="hljs-number"><span class="hljs-number">0.947</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> SS_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> SS_AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> SS_GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span></code> </pre> <br>  Caixa de bigode (StandardScaler): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f7/a0d/bf7/8f7a0dbf718cfdd7b061ffd43a7bed8e.png" alt="imagem"><br><br>  De acordo com os resultados do cálculo em dados padronizados, os seguintes algoritmos se tornaram líderes: <br><br><pre> <code class="python hljs">SS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.990</span></span> SS_ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> SS_MLP: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.973</span></span> SS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.023</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> SS_LR: train = <span class="hljs-number"><span class="hljs-number">0.958</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.949</span></span> SS_BG: train = <span class="hljs-number"><span class="hljs-number">0.947</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> SS_LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> SS_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.945</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> SS_CART: train = <span class="hljs-number"><span class="hljs-number">0.853</span></span> (<span class="hljs-number"><span class="hljs-number">0.036</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.835</span></span> SS_AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> SS_NB: train = <span class="hljs-number"><span class="hljs-number">0.756</span></span> (<span class="hljs-number"><span class="hljs-number">0.046</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.751</span></span></code> </pre> <br>  Como se costuma dizer, dos trapos às riquezas: o método do vetor de suporte ('SVC'), alimentado por dados padronizados, fez o resto, mostrando um excelente resultado.  Durante a verificação “manual”, comparando os valores das variáveis <i>Y_test</i> e <i>predictions_SS [6]</i> , o algoritmo não mastigou apenas alguns valores. <br><br>  A seguir, o mesmo código é executado para as funções MinMaxScaler (dimensionamento) e Normalizador (normalização).  Não darei o código completo no artigo.  Você pode baixá-lo do meu repositório no GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> . <br><br>  Lembre-se de esperar um pouco e rir de si mesmo 'apenas para fins educacionais'!  :) <br><br>  Como resultado, após analisar todo o código, obtemos os seguintes resultados: <br><br><pre> <code class="python hljs">LR: train = <span class="hljs-number"><span class="hljs-number">0.957</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> CART: train = <span class="hljs-number"><span class="hljs-number">0.843</span></span> (<span class="hljs-number"><span class="hljs-number">0.033</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.830</span></span> NB: train = <span class="hljs-number"><span class="hljs-number">0.819</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.806</span></span> LSVC: train = <span class="hljs-number"><span class="hljs-number">0.942</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.928</span></span> SVC: train = <span class="hljs-number"><span class="hljs-number">0.343</span></span> (<span class="hljs-number"><span class="hljs-number">0.079</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.342</span></span> MLP: train = <span class="hljs-number"><span class="hljs-number">0.972</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.961</span></span> BG: train = <span class="hljs-number"><span class="hljs-number">0.952</span></span> (<span class="hljs-number"><span class="hljs-number">0.021</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> RF: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.965</span></span> ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> SS_LR: train = <span class="hljs-number"><span class="hljs-number">0.958</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.949</span></span> SS_LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> SS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.023</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_CART: train = <span class="hljs-number"><span class="hljs-number">0.853</span></span> (<span class="hljs-number"><span class="hljs-number">0.036</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.835</span></span> SS_NB: train = <span class="hljs-number"><span class="hljs-number">0.756</span></span> (<span class="hljs-number"><span class="hljs-number">0.046</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.751</span></span> SS_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.945</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> SS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.990</span></span> SS_MLP: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.973</span></span> SS_BG: train = <span class="hljs-number"><span class="hljs-number">0.947</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> SS_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> SS_AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> SS_GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> MMS_LR: train = <span class="hljs-number"><span class="hljs-number">0.961</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.953</span></span> MMS_LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> MMS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> MMS_CART: train = <span class="hljs-number"><span class="hljs-number">0.850</span></span> (<span class="hljs-number"><span class="hljs-number">0.027</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.840</span></span> MMS_NB: train = <span class="hljs-number"><span class="hljs-number">0.796</span></span> (<span class="hljs-number"><span class="hljs-number">0.045</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.786</span></span> MMS_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.958</span></span> MMS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.963</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.956</span></span> MMS_MLP: train = <span class="hljs-number"><span class="hljs-number">0.972</span></span> (<span class="hljs-number"><span class="hljs-number">0.011</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.963</span></span> MMS_BG: train = <span class="hljs-number"><span class="hljs-number">0.948</span></span> (<span class="hljs-number"><span class="hljs-number">0.024</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> MMS_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> MMS_ET: train = <span class="hljs-number"><span class="hljs-number">0.983</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> MMS_AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> MMS_GB: train = <span class="hljs-number"><span class="hljs-number">0.963</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> N_LR: train = <span class="hljs-number"><span class="hljs-number">0.938</span></span> (<span class="hljs-number"><span class="hljs-number">0.020</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.919</span></span> N_LDA: train = <span class="hljs-number"><span class="hljs-number">0.952</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.949</span></span> N_KNN: train = <span class="hljs-number"><span class="hljs-number">0.981</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.985</span></span> N_CART: train = <span class="hljs-number"><span class="hljs-number">0.834</span></span> (<span class="hljs-number"><span class="hljs-number">0.028</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.825</span></span> N_NB: train = <span class="hljs-number"><span class="hljs-number">0.825</span></span> (<span class="hljs-number"><span class="hljs-number">0.043</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.805</span></span> N_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.960</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.953</span></span> N_SVC: train = <span class="hljs-number"><span class="hljs-number">0.551</span></span> (<span class="hljs-number"><span class="hljs-number">0.053</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.586</span></span> N_MLP: train = <span class="hljs-number"><span class="hljs-number">0.963</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> N_BG: train = <span class="hljs-number"><span class="hljs-number">0.949</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.938</span></span> N_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> N_ET: train = <span class="hljs-number"><span class="hljs-number">0.982</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.980</span></span> N_AB: train = <span class="hljs-number"><span class="hljs-number">0.825</span></span> (<span class="hljs-number"><span class="hljs-number">0.040</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.820</span></span> N_GB: train = <span class="hljs-number"><span class="hljs-number">0.953</span></span> (<span class="hljs-number"><span class="hljs-number">0.022</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.956</span></span></code> </pre> <br>  Resultados dos "5 principais": <br><br><pre> <code class="python hljs">SS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.990</span></span> N_KNN: train = <span class="hljs-number"><span class="hljs-number">0.981</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.985</span></span> KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> MMS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> MMS_ET: train = <span class="hljs-number"><span class="hljs-number">0.983</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span></code> </pre> <br>  Assim, de acordo com os resultados de um teste de blitz dos algoritmos de aprendizado de máquina para resolver o problema de classificação do conjunto de dados 'dígitos', os algoritmos de aprendizado de máquina mais adequados são: o método k-vizinhos mais próximos ('KNN'), o método do vetor de suporte ('SVC') e extra-árvores («ET»).  Esses algoritmos devem prestar mais atenção ao desenvolvimento de resultados que visem aumentar a eficiência dos cálculos.  Tudo, como se costuma dizer, é solucionável. <br><br>  E nesta nota levantada, prossiga sem problemas para a 2ª parte. <br><br><h3>  Problema de previsão </h3><br>  Passamos o polegar: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      from sklearn.datasets import load_boston from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.linear_model import Ridge from sklearn.linear_model import Lasso from sklearn.linear_model import ElasticNet from sklearn.linear_model import LarsCV from sklearn.linear_model import BayesianRidge from sklearn.neighbors import KNeighborsRegressor from sklearn.tree import DecisionTreeRegressor from sklearn.svm import LinearSVR from sklearn.svm import SVR from sklearn.ensemble import AdaBoostRegressor from sklearn.ensemble import BaggingRegressor from sklearn.ensemble import ExtraTreesRegressor from sklearn.ensemble import GradientBoostingRegressor from sklearn.ensemble import RandomForestRegressor from sklearn.model_selection import KFold from sklearn.model_selection import cross_val_score from sklearn.pipeline import Pipeline from sklearn.preprocessing import StandardScaler from sklearn.preprocessing import Normalizer from matplotlib import pyplot #    dataset = load_boston()</span></span></code> </pre> <br>  Execute o código e lide com o dicionário.  Descrição e chaves são as seguintes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e2/80f/4e2/1e280f4e239b31bae42274ab21c42d29.png" alt="imagem"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/24a/448/05a/24a44805af40951d544ef8cc6637c52a.png" alt="imagem"><br><br>  Atribuímos a chave 'data' à variável <i>X</i> , que é um array NumPy multidimensional com um conjunto de atributos, dimensione 506 linhas por 13 colunas e a variável <i>Y</i> - 'target', um array NumPy multidimensional com um marcador para cada linha. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    #dataset = load_boston() X = dataset.data Y = dataset.target</span></span></code> </pre> <br>  Dividimos o conjunto de dados em partes de treinamento e teste, configuramos os parâmetros para avaliar os algoritmos.  No parâmetro 'scoring', definimos uma das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">métricas 'r2'</a> tradicional para análise de regressão: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    dataset = load_boston() X = dataset.data Y = dataset.target #         test_size = 0.2 seed = 7 X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_size, random_state=seed) #     num_folds = 10 n_iter = 1000 n_estimators = 100 scoring = 'r2'</span></span></code> </pre> <br>  R2 - coeficiente de determinação - é a proporção da variância da variável dependente, explicada pelo modelo em questão ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ). <br><br>  <i>“O coeficiente de determinação para um modelo com uma constante leva valores de 0 a 1. Quanto mais próximo o coeficiente de 1, maior a dependência.</i>  <i>Ao avaliar modelos de regressão, isso é interpretado como correspondendo o modelo aos dados.</i>  <i>Para modelos aceitáveis, assume-se que o coeficiente de determinação deve ser de pelo menos 50% (neste caso, o coeficiente de correlação múltipla excede o módulo de 70%).</i>  <i>Modelos com um coeficiente de determinação acima de 80% podem ser considerados bastante bons (o coeficiente de correlação excede 90%).</i>  <i>A igualdade do coeficiente de determinação com a unidade significa que a variável explicada é exatamente descrita pelo modelo em consideração ”</i> (ibid.). <br><br>  Para resolver o problema de previsão, usamos os seguintes algoritmos: <br><br><h4>  Algoritmos lineares: </h4><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regressão linear</a> ('LR') <br>  - Regressão de Ridge (regressão de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ridge</a> ) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regressão de Ridge</a> ('R') <br>  - Regressão do laço (do inglês LASSO - Operador de Seleção e Retração Menos Absolutos) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regressão do laço</a> ('L') <br>  - Método de regressão de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">regressão líquida elástica</a> ('ELN') <br>  - Método da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">regressão com ângulo mínimo</a> (LARS) ('LARS') <br>  - Regressão da crista bayesiana / regressão da crista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bayesiana</a> ('BR') <br><br><h4>  Algoritmos não lineares: </h4><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">método k-regressor de vizinhos mais próximos</a> ('KNR') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regressor da árvore de decisão</a> ('DTR') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Máquina de vetores de suporte linear</a> (regressão) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Máquina de vetores de suporte linear - regressão</a> / ('LSVR') <br>  - Método do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vetor de suporte</a> (regressão) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">regressão do vetor de suporte Epsilon</a> ('SVR') <br><br><h4>  Algoritmos do conjunto: </h4><br>  - AdaBoost (regressão) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AdaBoost Regressor</a> ('ABR') (AdaBoost = reforço adaptativo) <br>  - Ensacamento (regressão) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regressor de ensacamento</a> ('BR') (Ensacamento = agregação de Bootstrap) <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regressor de árvores extras</a> ('ETR') <br>  - Reforço de gradiente (regressão) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Regressor de reforço de gradiente</a> ('GBR') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Classificação aleatória de floresta</a> (regressão) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classificador aleatório de floresta</a> ('RFR') <br><br>  Assim, a lista de 'modelos' contém os seguintes modelos: <br><br><pre> <code class="python hljs">models = [] models.append((<span class="hljs-string"><span class="hljs-string">'LR'</span></span>, LinearRegression())) models.append((<span class="hljs-string"><span class="hljs-string">'R'</span></span>, Ridge())) models.append((<span class="hljs-string"><span class="hljs-string">'L'</span></span>, Lasso())) models.append((<span class="hljs-string"><span class="hljs-string">'ELN'</span></span>, ElasticNet())) models.append((<span class="hljs-string"><span class="hljs-string">'LARS'</span></span>, Lars())) models.append((<span class="hljs-string"><span class="hljs-string">'BR'</span></span>, BayesianRidge(n_iter=n_iter))) models.append((<span class="hljs-string"><span class="hljs-string">'KNR'</span></span>, KNeighborsRegressor())) models.append((<span class="hljs-string"><span class="hljs-string">'DTR'</span></span>, DecisionTreeRegressor())) models.append((<span class="hljs-string"><span class="hljs-string">'LSVR'</span></span>, LinearSVR())) models.append((<span class="hljs-string"><span class="hljs-string">'SVR'</span></span>, SVR())) models.append((<span class="hljs-string"><span class="hljs-string">'ABR'</span></span>, AdaBoostRegressor(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'BR'</span></span>, BaggingRegressor(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'ETR'</span></span>, ExtraTreesRegressor(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'GBR'</span></span>, GradientBoostingRegressor(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'RFR'</span></span>, RandomForestRegressor(n_estimators=n_estimators)))</code> </pre> <br>  Como na classificação, a avaliação da eficácia de cada algoritmo é feita usando a validação cruzada.  A mensagem exibida contém as seguintes informações: o nome do modelo na forma de uma abreviação, a pontuação média de uma validação cruzada de 10 vezes nos dados de treinamento (métrica 'r2'), o desvio padrão e o coeficiente de determinação r2 nos dados de teste são mostrados entre colchetes. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      scores = [] names = [] results = [] predictions = [] msg_row = [] for name, model in models: kfold = KFold(n_splits=num_folds, random_state=seed) cv_results = cross_val_score(model, X_train, Y_train, cv=kfold, scoring=scoring) names.append(name) results.append(cv_results) m_fit = model.fit(X_train, Y_train) m_predict = model.predict(X_test) predictions.append(m_predict) m_score = model.score(X_test, Y_test) scores.append(m_score) msg = "%s: train = %.3f (%.3f) / test = %.3f" % (name, cv_results.mean(), cv_results.std(), m_score) msg_row.append(msg) print(msg) #   («  ») fig = pyplot.figure() fig.suptitle('   ') ax = fig.add_subplot(111) red_square = dict(markerfacecolor='r', marker='s') pyplot.boxplot(results, flierprops=red_square) ax.set_xticklabels(names, rotation=45) pyplot.show()</span></span></code> </pre> <br>  Depois de executar o código, obtemos os seguintes resultados: <br><br><pre> <code class="python hljs">LR: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> R: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.067</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.570</span></span> L: train = <span class="hljs-number"><span class="hljs-number">0.689</span></span> (<span class="hljs-number"><span class="hljs-number">0.070</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.641</span></span> ELN: train = <span class="hljs-number"><span class="hljs-number">0.677</span></span> (<span class="hljs-number"><span class="hljs-number">0.074</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.662</span></span> LARS: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> BR: train = <span class="hljs-number"><span class="hljs-number">0.739</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.571</span></span> KNR: train = <span class="hljs-number"><span class="hljs-number">0.434</span></span> (<span class="hljs-number"><span class="hljs-number">0.288</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.538</span></span> DTR: train = <span class="hljs-number"><span class="hljs-number">0.671</span></span> (<span class="hljs-number"><span class="hljs-number">0.145</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.637</span></span> LSVR: train = <span class="hljs-number"><span class="hljs-number">0.550</span></span> (<span class="hljs-number"><span class="hljs-number">0.144</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.459</span></span> SVR: train = <span class="hljs-number"><span class="hljs-number">-0.012</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">-0.003</span></span> ABR: train = <span class="hljs-number"><span class="hljs-number">0.810</span></span> (<span class="hljs-number"><span class="hljs-number">0.078</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.763</span></span> BR: train = <span class="hljs-number"><span class="hljs-number">0.854</span></span> (<span class="hljs-number"><span class="hljs-number">0.064</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.805</span></span> ETR: train = <span class="hljs-number"><span class="hljs-number">0.889</span></span> (<span class="hljs-number"><span class="hljs-number">0.047</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.836</span></span> GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.042</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.863</span></span> RFR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.819</span></span></code> </pre> <br>  Gráfico de amplitude: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a7/140/96c/2a714096c35498ccddc267298f502a6a.png" alt="imagem"><br><br>  Os líderes óbvios são os métodos de conjunto 'GBR' (gradiente 'reforço'), 'ETR' (extra-árvores), 'RFR' (floresta aleatória) e 'BR' ('ensacamento'): <br><br><pre> <code class="python hljs">GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.042</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.863</span></span> ETR: train = <span class="hljs-number"><span class="hljs-number">0.889</span></span> (<span class="hljs-number"><span class="hljs-number">0.047</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.836</span></span> RFR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.819</span></span> BR: train = <span class="hljs-number"><span class="hljs-number">0.854</span></span> (<span class="hljs-number"><span class="hljs-number">0.064</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.805</span></span> ABR: train = <span class="hljs-number"><span class="hljs-number">0.810</span></span> (<span class="hljs-number"><span class="hljs-number">0.078</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.763</span></span> ELN: train = <span class="hljs-number"><span class="hljs-number">0.677</span></span> (<span class="hljs-number"><span class="hljs-number">0.074</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.662</span></span> L: train = <span class="hljs-number"><span class="hljs-number">0.689</span></span> (<span class="hljs-number"><span class="hljs-number">0.070</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.641</span></span> DTR: train = <span class="hljs-number"><span class="hljs-number">0.671</span></span> (<span class="hljs-number"><span class="hljs-number">0.145</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.637</span></span> LR: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> LARS: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> BR: train = <span class="hljs-number"><span class="hljs-number">0.739</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.571</span></span> R: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.067</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.570</span></span> KNR: train = <span class="hljs-number"><span class="hljs-number">0.434</span></span> (<span class="hljs-number"><span class="hljs-number">0.288</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.538</span></span> LSVR: train = <span class="hljs-number"><span class="hljs-number">0.550</span></span> (<span class="hljs-number"><span class="hljs-number">0.144</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.459</span></span> SVR: train = <span class="hljs-number"><span class="hljs-number">-0.012</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">-0.003</span></span></code> </pre> <br>  Um "adabust", "loshara", fica para trás. <br><br>  Talvez os três líderes estejam combatendo a padronização e a normalização.  Vamos descobrir executando o restante do código. <br><br>  Os resultados são os seguintes: <br><br><pre> <code class="python hljs">SS_LR: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> SS_R: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.578</span></span> SS_L: train = <span class="hljs-number"><span class="hljs-number">0.678</span></span> (<span class="hljs-number"><span class="hljs-number">0.054</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.510</span></span> SS_ELN: train = <span class="hljs-number"><span class="hljs-number">0.665</span></span> (<span class="hljs-number"><span class="hljs-number">0.060</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.513</span></span> SS_LARS: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> SS_BR: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.066</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.576</span></span> SS_KNR: train = <span class="hljs-number"><span class="hljs-number">0.763</span></span> (<span class="hljs-number"><span class="hljs-number">0.098</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.739</span></span> SS_DTR: train = <span class="hljs-number"><span class="hljs-number">0.610</span></span> (<span class="hljs-number"><span class="hljs-number">0.242</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.629</span></span> SS_LSVR: train = <span class="hljs-number"><span class="hljs-number">0.727</span></span> (<span class="hljs-number"><span class="hljs-number">0.091</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.482</span></span> SS_SVR: train = <span class="hljs-number"><span class="hljs-number">0.653</span></span> (<span class="hljs-number"><span class="hljs-number">0.126</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.610</span></span> SS_ABR: train = <span class="hljs-number"><span class="hljs-number">0.811</span></span> (<span class="hljs-number"><span class="hljs-number">0.076</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.819</span></span> SS_BR: train = <span class="hljs-number"><span class="hljs-number">0.853</span></span> (<span class="hljs-number"><span class="hljs-number">0.074</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.813</span></span> SS_ETR: train = <span class="hljs-number"><span class="hljs-number">0.887</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.846</span></span> SS_GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.038</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.860</span></span> SS_RFR: train = <span class="hljs-number"><span class="hljs-number">0.851</span></span> (<span class="hljs-number"><span class="hljs-number">0.071</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.818</span></span> N_LR: train = <span class="hljs-number"><span class="hljs-number">0.751</span></span> (<span class="hljs-number"><span class="hljs-number">0.099</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.576</span></span> N_R: train = <span class="hljs-number"><span class="hljs-number">0.287</span></span> (<span class="hljs-number"><span class="hljs-number">0.126</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.271</span></span> N_L: train = <span class="hljs-number"><span class="hljs-number">-0.030</span></span> (<span class="hljs-number"><span class="hljs-number">0.032</span></span>) / test = <span class="hljs-number"><span class="hljs-number">-0.000</span></span> N_ELN: train = <span class="hljs-number"><span class="hljs-number">-0.007</span></span> (<span class="hljs-number"><span class="hljs-number">0.030</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.023</span></span> N_LARS: train = <span class="hljs-number"><span class="hljs-number">0.751</span></span> (<span class="hljs-number"><span class="hljs-number">0.099</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.576</span></span> N_BR: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.100</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.589</span></span> N_KNR: train = <span class="hljs-number"><span class="hljs-number">0.485</span></span> (<span class="hljs-number"><span class="hljs-number">0.192</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.504</span></span> N_DTR: train = <span class="hljs-number"><span class="hljs-number">0.729</span></span> (<span class="hljs-number"><span class="hljs-number">0.080</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.765</span></span> N_LSVR: train = <span class="hljs-number"><span class="hljs-number">0.182</span></span> (<span class="hljs-number"><span class="hljs-number">0.108</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.136</span></span> N_SVR: train = <span class="hljs-number"><span class="hljs-number">0.086</span></span> (<span class="hljs-number"><span class="hljs-number">0.076</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.084</span></span> N_ABR: train = <span class="hljs-number"><span class="hljs-number">0.795</span></span> (<span class="hljs-number"><span class="hljs-number">0.053</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.752</span></span> N_BR: train = <span class="hljs-number"><span class="hljs-number">0.854</span></span> (<span class="hljs-number"><span class="hljs-number">0.054</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.827</span></span> N_ETR: train = <span class="hljs-number"><span class="hljs-number">0.877</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.850</span></span> N_GBR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.063</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.872</span></span> N_RFR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.051</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.801</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como você pode ver, os métodos de conjunto ainda estão à frente de todos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'Top 5' contém os seguintes resultados:</font></font><br><br><pre> <code class="python hljs">N_GBR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.063</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.872</span></span> GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.042</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.863</span></span> SS_GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.038</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.860</span></span> N_ETR: train = <span class="hljs-number"><span class="hljs-number">0.877</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.850</span></span> SS_ETR: train = <span class="hljs-number"><span class="hljs-number">0.887</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.846</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos exibir um gráfico comparando os resultados: o </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b1/9a0/cc6/8b19a0cc6379c2337c9082eedd415585.jpg" alt="imagem"><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teste Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é o padrão. Os cinco resultados selecionados mostrados no diagrama são indicados por uma linha tracejada. Pode-se observar que todos os picos foram reproduzidos com repetição exata ou em um grau ou outro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trecho curto da comparação manual dos valores de referência e dos valores de previsão do algoritmo incluído no Top 5: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/711/0a7/2de/7110a72de1daa81209ecaee33542dfef.png" alt="imagem"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, de acordo com os resultados de um teste de blitz de algoritmos de aprendizado de máquina para resolver o problema de prever o conjunto de dados 'preço da casa de boston', os algoritmos mais adequados são o “impulso” de gradiente ('GBR ') e árvores extras (' ETR '). Esses algoritmos devem receber mais atenção para desenvolver ainda mais os resultados e aumentar a eficácia das previsões.</font></font><br><br><h3>  Posfácio </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma verificação rápida dos algoritmos de aprendizado de máquina permite, em uma primeira aproximação, identificar os algoritmos mais eficazes para resolver problemas de classificação e análise de regressão (previsão). Ficamos convencidos disso processando o conjunto de dados 'dígitos', classificando de forma brilhante as instâncias em 10 classes, bem como o conjunto de dados 'preço da casa de boston', classificando de maneira "surpreendente" a localização de dependências e a previsão "flutuante" da variável dependente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você está convidado a experimentar esse método em seus próprios conjuntos de dados ou naqueles que você pode cavar em vários repositórios, incluindo o GitHub. Por exemplo: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenha um conjunto de dados adequado para o alvo - e defina um monte de algoritmos nele na equipe do teste de blitz. E aí fica claro de quem é: quem está no campo não é um guerreiro.</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E em conclusão. Serei grato por seus comentários, perguntas e sugestões, pois a base deste artigo é a informação que compartilho com novos colegas em cada novo projeto no campo de aprendizado de máquina. Cada um deles tem sua própria especialização, sobre aprendizado de máquina e redes neurais artificiais, muitos deles apenas "ouvidos em algum lugar", por isso é importante para mim falar sobre complexos, multifacetados e, finalmente, inexpugnáveis ​​(trata-se de RNA e aprendizado de máquina em geral) :), em uma linguagem simples e compreensível; mostre que não são os deuses que queimam panelas; e que, se houver interesse, mais de uma dúzia de algoritmos podem ser "aproveitados".</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS No final do artigo, comecei a me prever, então, para as próximas perguntas sobre onde obtive as dicas na primeira figura que forneço: tudo no mesmo site scikit-learn.org ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'Escolhendo o estimador certo'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">E a personificação da inteligência artificial na forma de um Samodelkin corado é assim das ondas de memória da minha infância feliz.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt475552/">https://habr.com/ru/post/pt475552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt475542/index.html">Como o marketing por email mudou desde 2013: 4 principais tendências e estatísticas atuais</a></li>
<li><a href="../pt475544/index.html">Catálogos de produtos, serviços e muito mais</a></li>
<li><a href="../pt475546/index.html">Síndromes viciantes de TI</a></li>
<li><a href="../pt475548/index.html">Matchmaking chato, sem desequilíbrio e filas: um guia prático</a></li>
<li><a href="../pt475550/index.html">Sistemas acústicos para salas abertas</a></li>
<li><a href="../pt475554/index.html">Técnicas de design de interface do usuário que economizam tempo</a></li>
<li><a href="../pt475556/index.html">Mudança para Munique. O caminho dos escaladores da Amazon para o emprego dos sonhos da Amazon</a></li>
<li><a href="../pt475558/index.html">Dicionário de TI ou o quê? Onde Para onde? Parte 1</a></li>
<li><a href="../pt475560/index.html">KotlinConf 2019 Live: Assista ao vivo de 5 a 6 de dezembro</a></li>
<li><a href="../pt475562/index.html">MVC no Unity com objetos programáveis. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>