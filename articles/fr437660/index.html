<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔳 👩🏼‍🤝‍👨🏾 🗽 Mise à jour du profil à vie dans Visual Studio 2019 Preview 2 🚶🏻 🥩 🔩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le profil de durée de vie des directives C ++ Core , qui fait partie des directives C ++ Core , vise à détecter les problèmes de durée de vie, comme l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mise à jour du profil à vie dans Visual Studio 2019 Preview 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/437660/"><p>  Le profil de durée de vie des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">directives C ++ Core</a> , qui fait partie des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">directives C ++ Core</a> , vise à détecter les problèmes de durée de vie, comme les pointeurs et les références pendantes, dans le code C ++.  Il utilise les informations de type déjà présentes dans la source ainsi que quelques contrats simples entre les fonctions pour détecter les défauts au moment de la compilation avec une annotation minimale. </p><br><br><img src="https://habrastorage.org/webt/m6/sd/zl/m6sdzl8oiweahnxld6esvr3s03u.png"><a name="habracut"></a><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Original dans le blog</a> <br><br><p>  Ce sont les contrats de base que le profil attend du code: </p><br><ol><li>  N'utilisez pas de pointeur potentiellement suspendu. </li><li>  Ne passez pas un pointeur potentiellement suspendu à une autre fonction. </li><li>  Ne renvoyez aucun pointeur potentiellement suspendu à partir d'une fonction. </li></ol><br><p>  Pour plus d'informations sur l'historique et les objectifs du profil, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le blog de Herb Sutter sur la version 1.0</a> . </p><br><h2>  Nouveautés de Visual Studio 2019 Preview 2 </h2><br><p>  Dans l'aperçu 2, nous avons fourni une version d'aperçu du vérificateur de profil à vie qui implémente la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version publiée du profil à vie</a> .  Ce vérificateur fait partie des vérificateurs de base <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++</a> dans Visual Studio. </p><br><ul><li>  Prise en charge des itérateurs, des vues de chaîne et des étendues. </li><li>  Meilleure détection des types de propriétaire et de pointeur personnalisés, ce qui permet aux types personnalisés qui se comportent comme des conteneurs, des pointeurs propriétaires ou des pointeurs non propriétaires de participer à l'analyse. </li><li>  Les règles par défaut sensibles au type pour les conditions de pré et de post d'appel de fonction aident à réduire les faux positifs et à améliorer la précision. </li><li>  Meilleur support pour les types d'agrégats. </li><li>  Amélioration générale de l'exactitude et des performances. </li><li>  Une analyse nullptr simple. </li></ul><br><h2>  Activation des règles du vérificateur de profil à vie </h2><br><p>  Les règles du vérificateur ne sont pas activées par défaut.  Si vous souhaitez essayer les nouvelles règles, vous devrez mettre à jour le jeu de règles d'analyse de code sélectionné pour votre projet.  Vous pouvez soit sélectionner les «Règles de durée de vie de C ++ Core Check» - qui n'activent que les règles de profil de durée de vie - ou vous pouvez modifier votre ensemble de règles existant pour activer les avertissements 26486 à 26489. </p><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/602/81e/cdc/60281ecdcf10232b8e9f58c5f0623d31.png" alt="Capture d'écran de la page de propriétés d'analyse de code qui montre l'ensemble de règles C ++ Core Check Lifetime Rules sélectionné." width="1253" height="898"></a> <p>  Capture d'écran de la page de propriétés d'analyse de code qui montre l'ensemble de règles C ++ Core Check Lifetime Rules sélectionné. </p><br><p>  Des avertissements apparaissent dans la liste des erreurs lorsque l'analyse de code est exécutée (Analyser&gt; Exécuter l'analyse de code), ou si vous avez activé l'analyse de code en arrière-plan, des erreurs de durée de vie s'affichent dans l'éditeur avec des gribouillis verts. </p><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/593/6da/b6c/5936dab6c4be57347101009d35125739.png" alt="Capture d'écran montrant un avertissement du vérificateur de profil à vie avec un gribouillis vert dans le code source." width="982" height="134"></a> <p>  Capture d'écran montrant un avertissement du vérificateur de profil à vie avec un gribouillis vert dans le code source. </p><br><h2>  Des exemples </h2><br><h3>  Pointeur pendant </h3><br><p> L'exemple le plus simple - en utilisant un pointeur suspendu - est le meilleur endroit pour commencer.  Ici, <code>px</code> pointe vers <code>x</code> , puis <code>x</code> laisse la portée, laissant <code>px</code> pendant.  Lorsque <code>px</code> est utilisé, un avertissement est émis. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simple_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* px; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; px = &amp;x; } *px = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// error, dangling pointer to 'x' }</span></span></code> </pre> <br><h3>  Pointeur de sortie pendant </h3><br><p>  Le retour de pointeurs pendants n'est pas non plus autorisé.  Dans ce cas, le paramètre <code>ppx</code> est présumé être un paramètre de sortie.  Dans ce cas, il est défini pour pointer sur <code>x</code> qui sort du champ d'application à la fin de la fonction.  Cela laisse <code>*ppx</code> pendant. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out_parameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">** ppx)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// *ppx points to 'x' which is invalid { *ppx = &amp;x; }</span></span></span></span></code> </pre> <br><h3>  Vue des chaînes pendantes </h3><br><p>  Les deux derniers exemples étaient évidents, mais des instances temporaires peuvent introduire des bogues subtils.  Pouvez-vous trouver le bogue dans le code suivant? </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_string_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view sv = get_string(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = sv.at(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>  Dans ce cas, la vue de chaîne <code>sv</code> est construite avec l'instance de chaîne temporaire renvoyée par <code>get_string()</code> .  La chaîne temporaire est ensuite détruite, ce qui laisse la vue de chaîne référençant un objet non valide. </p><br><h3>  Itérateur suspendu </h3><br><p>  Un autre problème de durée de vie difficile à détecter se produit lors de l'utilisation d'un itérateur invalidé dans un conteneur.  Dans le cas ci-dessous, l'appel à <code>push_back</code> peut amener le vecteur à réallouer son stockage sous-jacent, ce qui invalide l'itérateur. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = v.begin(); *it = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ok, iterator is valid v.push_back(4); *it = 0; // error, using an invalid iterator }</span></span></code> </pre> <br><p>  Une chose à noter à propos de cet exemple est qu'il n'y a pas de gestion spéciale pour 'std :: vector :: push_back'.  Ce comportement sort des règles de profil par défaut.  Une règle classe les conteneurs en tant que «propriétaire».  Ensuite, lorsqu'une méthode non const est appelée sur le propriétaire, sa mémoire possédée est supposée invalidée et les itérateurs qui pointent vers la mémoire possédée sont également considérés comme invalides. </p><br><h3>  Propriétaire modifié </h3><br><p>  Le profil est normatif dans son orientation.  Il s'attend à ce que ce code utilise idiomatiquement le système de types lors de la définition des paramètres de fonction.  Dans cet exemple suivant, <code>std::unique_ptr</code> , un type 'Owner', est passé à une autre fonction par référence non const.  Selon les règles du profil, les propriétaires transmis par référence non constante sont supposés être modifiés par l'appelé. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_unique_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; upRef)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assumes_modification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> unique = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Line A auto ptr = unique.get(); *ptr = 10; // ok, ptr is valid use_unique_ptr(unique); *ptr = 10; // error, dangling pointer to the memory held by 'unique' at Line A }</span></span></code> </pre> <br><p>  Dans cet exemple, nous obtenons un pointeur brut, <code>ptr</code> , vers la mémoire appartenant à <code>unique</code> .  Ensuite, <code>unique</code> est passé à la fonction <code>use_unique_ptr</code> par référence non const.  Puisqu'il s'agit d'une utilisation non-constante d' <code>unique</code> où la fonction pourrait faire n'importe quoi, l'analyse suppose que l' <code>unique</code> 'est invalidé d'une manière ou d'une autre (par exemple, unique_ptr :: reset), ce qui ferait <code>ptr</code> . </p><br><h3>  Plus d'exemples </h3><br><p>  Il existe de nombreux autres cas que l'analyse peut détecter.  Essayez-le dans Visual Studio sur votre propre code et voyez ce que vous trouvez.  Consultez également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le blog de Herb</a> pour plus d'exemples et, si vous êtes curieux, lisez le document Profil de la vie. </p><br><h2>  Problèmes connus </h2><br><p>  L'implémentation actuelle ne prend pas totalement en charge l'analyse telle que décrite dans l'article sur le profil de durée de vie.  Voici les grandes catégories qui ne sont pas implémentées dans cette version. </p><br><ul><li>  <b>Annotations</b> - L'article présente des annotations (c'est-à-dire <code>[[gsl::lifetime-const]]</code> ) qui ne sont pas prises en charge.  Cela signifie pratiquement que si les règles d'analyse par défaut ne fonctionnent pas pour votre code, vous ne pouvez pas faire grand-chose d'autre que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">supprimer les</a> faux positifs. </li><li>  <b>Exceptions</b> - Les chemins de gestion des exceptions, y compris le contenu des blocs <code>catch</code> , ne sont pas actuellement analysés. </li><li>  <b>Règles par défaut pour les</b> <b>types STL</b> - Au lieu d'une annotation à vie, le document recommande que pour les rares fonctions membres du conteneur STL où nous voulons remplacer les valeurs par défaut, nous les traitions comme si elles étaient annotées.  Par exemple, une surcharge de <code>std::vector::at</code> n'est pas <code>const</code> car elle peut renvoyer une référence non const - cependant nous savons que l'appeler est <code>lifetime-const</code> car il n'invalide pas la mémoire du vecteur.  Nous n'avons pas terminé le travail pour faire cette annotation implicite de tous les types de conteneurs STL. </li><li>  <b>Captures Lambda</b> - Si une variable de pile est capturée par référence dans un lambda, nous ne détectons pas actuellement si le lambda quitte la portée de la variable capturée. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> captures_x = [&amp;x] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> captures_x; <span class="hljs-comment"><span class="hljs-comment">// returns a dangling reference to 'x' }</span></span></code> </pre> </li></ul><br><h2>  Conclure </h2><br><p>  Essayez le vérificateur de profil à vie dans Visual Studio 2019 Preview 2. Nous espérons qu'il vous aidera à identifier les problèmes de durée de vie dans vos projets.  Si vous trouvez des faux positifs ou des faux négatifs, veuillez les signaler afin que nous puissions hiérarchiser les scénarios qui sont importants pour vous.  Si vous avez des suggestions ou des problèmes avec cette vérification - ou toute fonctionnalité de Visual Studio - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">signalez un problème</a> ou publiez sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communauté des développeurs</a> et faites-le nous savoir.  Nous sommes également sur Twitter à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@VisualC</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437660/">https://habr.com/ru/post/fr437660/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437650/index.html">Une sélection des meilleurs cadeaux pour le geek et la personne enthousiaste le 23 février</a></li>
<li><a href="../fr437652/index.html">Annonce de TypeScript 3.3 RC</a></li>
<li><a href="../fr437654/index.html">Imprimantes 3D photopolymères peu coûteuses et abordables</a></li>
<li><a href="../fr437656/index.html">Éléphant dans une boutique de porcelaine: imprimantes 3D avec un immense champ d'impression</a></li>
<li><a href="../fr437658/index.html">Guide: Thymeleaf + Spring. 3e partie</a></li>
<li><a href="../fr437664/index.html">Récupération du composé</a></li>
<li><a href="../fr437666/index.html">Annonce de l'aperçu de F # 4.6</a></li>
<li><a href="../fr437670/index.html">Mises à jour du backend MSVC dans Visual Studio 2019 Preview 2: nouvelles optimisations, améliorations OpenMP et Build Throughput</a></li>
<li><a href="../fr437672/index.html">cyberd: Calculer les connaissances du web3</a></li>
<li><a href="../fr437674/index.html">Méthodes de reconnaissance d'objets 3D pour les véhicules sans pilote. Rapport Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>