<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏻 👨🏼‍🏭 🔪 Centrifugo v2 - l'avenir du serveur de messagerie en temps réel et de la bibliothèque pour Go 🍔 👃🏿 👩🏾‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Certains lecteurs ont peut-être déjà entendu parler de Centrifugo . Cet article se concentrera sur le développement de la deuxième version du serveur ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Centrifugo v2 - l'avenir du serveur de messagerie en temps réel et de la bibliothèque pour Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/416915/"><p>  Certains lecteurs ont peut-être déjà entendu parler de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Centrifugo</a> .  Cet article se concentrera sur le développement de la deuxième version du serveur et de la nouvelle bibliothèque en temps réel pour le langage Go qui le sous-tend. </p><br><p>  Je m'appelle Alexander Emelin.  L'été dernier, j'ai rejoint l'équipe Avito, où j'aide maintenant à développer le backend messenger Avito.  Le nouveau travail, directement lié à la livraison rapide des messages aux utilisateurs, et les nouveaux collègues m'ont inspiré pour continuer à travailler sur le projet open source Centrifugo. </p><br><p><img src="https://habrastorage.org/webt/cl/mo/yt/clmoytonrzc4exvj6eeky8j-zw4.jpeg"></p><a name="habracut"></a><br><p>  En un mot - c'est un serveur qui se charge de maintenir des connexions constantes des utilisateurs de votre application.  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">polyfill</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Websocket</a> ou SockJS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est</a> utilisé comme transport; il peut, s'il n'est pas possible d'établir une connexion Websocket, fonctionner via Eventsource, le streaming XHR, l'interrogation longue et d'autres transports basés sur HTTP.  Les clients s'abonnent aux canaux sur lesquels le backend via l'API Centrifuge publie de nouveaux messages au fur et à mesure qu'ils apparaissent - après quoi les messages sont remis aux utilisateurs abonnés au canal.  En d'autres termes, c'est un serveur PUB / SUB. </p><br><p><img src="https://habrastorage.org/webt/-c/ws/k-/-cwsk-n9eulxk4cd7v9berdltzy.png"></p><br><p> Actuellement, le serveur est utilisé dans un nombre assez important de projets.  Parmi eux, par exemple, certains projets Mail.Ru (intranet, plates-formes de formation Technopark / Technosphere, Centre de certification, etc.), avec Centrifugo, un beau tableau de bord fonctionne à la réception du bureau de Badoo à Moscou, et 350 000 utilisateurs sont connectés simultanément au service spot.im à la centrifugeuse. </p><br><p>  Quelques liens vers des articles précédents sur le serveur et son application pour ceux qui ont entendu parler pour la première fois du projet: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Plongez dans Centrifugo</a> , </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Centrifugo - 3,5 millions de tr / min</a> , </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ainsi qu'un article en anglais racontant l'histoire du projet et la motivation de son apparition</a> . </li></ul><br><p>  J'ai commencé à travailler sur la deuxième version en décembre de l'année dernière et continue à ce jour.  Voyons ce qui se passe.  J'écris cet article non seulement pour vulgariser le projet, mais aussi pour obtenir un retour un peu plus constructif avant la sortie de Centrifugo v2 - maintenant il y a de la place pour la manœuvre et des changements incompatibles. </p><br><h1 id="real-time-biblioteka-dlya-go">  Bibliothèque en temps réel pour Go </h1><br><p>  Dans la communauté Go, la question se pose de temps en temps - existe-t-il des alternatives à socket.io sur Go?  Parfois, j'ai remarqué que les développeurs en réponse à cela sont invités à se tourner vers Centrifugo.  Cependant, Centrifugo est un serveur auto-hébergé, pas une bibliothèque - la comparaison n'est pas juste.  On m'a également demandé à plusieurs reprises si le code Centrifugo pouvait être réutilisé pour écrire des applications en temps réel dans Go.  Et la réponse était: théoriquement possible, mais je ne pouvais pas garantir la rétrocompatibilité de l'API des packages internes à mes risques et périls.  Il est clair qu'il n'y a aucune raison pour que quelqu'un le prenne, et la fourche est également une option.  De plus, je ne dirais pas que l'API pour les packages internes a été généralement préparée pour une telle utilisation. </p><br><p>  Par conséquent, l'une des tâches ambitieuses que je voulais résoudre dans le processus de travail sur la deuxième version du serveur était d'essayer de séparer le cœur du serveur dans une bibliothèque distincte sur Go.  Je crois que cela a du sens, compte tenu du nombre de fonctionnalités de la centrifugeuse pour être adapté à la production.  De nombreuses fonctionnalités prêtes à l'emploi permettent de créer des applications évolutives en temps réel, éliminant ainsi la nécessité pour les développeurs d'écrire leurs propres solutions.  J'ai écrit sur ces fonctionnalités plus tôt et j'en décrirai également certaines ci-dessous. </p><br><p>  J'essaierai de justifier un plus de l'existence d'une telle bibliothèque.  La plupart des utilisateurs de Centrifugo sont des développeurs qui écrivent des backends dans des langages / frameworks avec un support de concurrence faible (par exemple Django / Flask / Laravel / ...): travaillent avec beaucoup de connexions persistantes si possible, de manière non évidente ou inefficace.  En conséquence, tous les utilisateurs ne peuvent pas aider au développement d'un serveur écrit en Go (ringard en raison d'un manque de connaissance de la langue).  Par conséquent, même une très petite communauté de développeurs Go autour de la bibliothèque pourra aider à développer le serveur Centrifugo en l'utilisant. </p><br><p>  Le résultat est une bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Centrifuge</a> .  C'est toujours WIP, mais absolument toutes les fonctionnalités indiquées dans la description sur Github sont implémentées et fonctionnent.  Étant donné que la bibliothèque fournit une API assez riche, avant de garantir la compatibilité descendante, je voudrais entendre plusieurs exemples réussis d'utilisation dans de vrais projets sur Go.  Il n'y en a pas encore.  En plus d'échec :).  Il n'y en a pas. </p><br><p>  Je comprends qu'en nommant la bibliothèque de la même manière que le serveur, je gérerai à jamais la confusion.  Mais je pense que c'est le bon choix, car les clients (tels que centrifuge-js, centrifuge-go) fonctionnent à la fois avec la bibliothèque Centrifuge et le serveur Centrifugo.  De plus, le nom est déjà bien ancré dans l'esprit des utilisateurs, et je ne veux pas perdre ces associations.  Et pourtant, pour un peu plus de clarté, je vais encore clarifier: </p><br><ul><li>  Centrifuge - une bibliothèque pour la langue Go, </li><li>  Centrifugo est une solution clé en main, un service distinct, qui dans la version 2 sera construit sur la bibliothèque Centrifuge. </li></ul><br><p>  En raison de sa conception, Centrifugo (un service autonome qui ne sait rien de votre backend) suppose que le flux de messages via le transport en temps réel ira du serveur au client.  Que voulez-vous dire?  Si, par exemple, l'utilisateur écrit un message dans le chat, ce message doit d'abord être envoyé au backend de l'application (par exemple, AJAX dans le navigateur), validé côté backend, enregistré dans la base de données si nécessaire, puis envoyé à l'API Centrifuge.  La bibliothèque supprime cette restriction, vous permettant d'organiser l'échange bidirectionnel de messages asynchrones entre le serveur et le client, ainsi que les appels RPC. </p><br><p><img src="https://habrastorage.org/webt/jf/_d/er/jf_dervpzmkl2fuprcse34ayoke.png"></p><br><p>  Regardons un exemple simple: nous implémentons un petit serveur sur Go en utilisant la bibliothèque Centrifuge.  Le serveur recevra les messages des clients du navigateur via Websocket, le client disposera d'un champ de texte dans lequel vous pourrez conduire un message, appuyez sur Entrée - et le message sera envoyé à tous les utilisateurs abonnés à la chaîne.  Autrement dit, la version la plus simplifiée du chat.  Il m'a semblé qu'il serait plus commode de placer cela sous la forme d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">résumé</a> . </p><br><p>  Vous pouvez exécuter comme d'habitude: </p><br><pre><code class="go hljs">git clone https:<span class="hljs-comment"><span class="hljs-comment">//gist.github.com/2f1a38ae2dcb21e2c5937328253c29bf.git cd 2f1a38ae2dcb21e2c5937328253c29bf go get -u github.com/centrifugal/centrifuge go run main.go</span></span></code> </pre> <br><p>  Et puis allez sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 8000</a> , ouvrez plusieurs onglets de navigateur. </p><br><p>  Comme vous pouvez le voir, le point d'entrée de la logique métier de l'application se produit lors du blocage des fonctions de rappel <code>On().Connect()</code> : </p><br><pre> <code class="go hljs">node.On().Connect(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, client *centrifuge.Client, e centrifuge.ConnectEvent)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">centrifuge</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConnectReply</span></span></span></span> { client.On().Disconnect(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e centrifuge.DisconnectEvent)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">centrifuge</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisconnectReply</span></span></span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"client disconnected"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centrifuge.DisconnectReply{} }) log.Printf(<span class="hljs-string"><span class="hljs-string">"client connected via %s"</span></span>, client.Transport().Name()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centrifuge.ConnectReply{} })</code> </pre> <br><p>  L'approche basée sur le rappel m'a semblé la plus pratique pour interagir avec la bibliothèque.  De plus, une approche similaire, mais faiblement typée, est utilisée dans la mise en œuvre du <a href="">serveur socket-io sur Go</a> .  Si tout à coup vous avez des idées sur la façon dont l'API pourrait être réalisée de manière plus idiomatique - je serai heureux de l'entendre. </p><br><p>  Il s'agit d'un exemple très simple qui ne montre pas toutes les fonctionnalités de la bibliothèque.  Quelqu'un peut noter qu'à de telles fins, il est plus facile de prendre une bibliothèque pour travailler avec Websocket.  Par exemple, Gorilla Websocket.  Il en est ainsi.  Cependant, même dans ce cas, vous devrez copier un morceau de code de serveur décent à partir de l'exemple dans le référentiel Gorilla Websocket.  Et si: </p><br><ul><li>  vous devez faire évoluer l'application sur plusieurs machines, </li><li>  ou vous n'avez pas besoin d'un canal commun, mais de plusieurs - et les utilisateurs peuvent s'abonner et se désabonner dynamiquement d'eux lorsque vous naviguez dans votre application, </li><li>  ou vous devez travailler lorsque la connexion Websocket n'a pas pu être établie (il n'y a pas de support dans le navigateur du client, il y a une extension de navigateur, une sorte de proxy sur le chemin entre le client et le serveur coupe la connexion), </li><li>  ou vous devez restaurer les messages manqués par le client pendant de courtes pauses dans la connexion Internet sans charger la base de données principale, </li><li>  ou vous avez besoin de contrôler l'autorisation utilisateur dans le canal, </li><li>  ou vous devez déconnecter la connexion permanente des utilisateurs qui sont désactivés dans l'application, </li><li>  ou vous avez besoin d'informations sur qui est actuellement sur la chaîne ou sur les événements auxquels une personne s'est abonnée / désabonnée de la chaîne, </li><li>  ou avez-vous besoin de mesures et de surveillance? </li></ul><br><p>  La bibliothèque Centrifuge peut vous y aider - en fait, elle a hérité de toutes les fonctionnalités de base qui étaient auparavant disponibles dans Centrifugo.  Plus d'exemples montrant les points énoncés ci-dessus peuvent être trouvés sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Github</a> . </p><br><p>  Le fort héritage de Centrifugo peut être un inconvénient, car la bibliothèque a adopté toutes les mécaniques de serveur, qui sont assez originales et, peut-être, peuvent sembler peu évidentes ou surchargées de fonctionnalités inutiles pour quelqu'un.  J'ai essayé d'organiser le code de telle manière que les fonctionnalités inutilisées n'affectent pas les performances globales. </p><br><p>  Il existe des optimisations dans la bibliothèque qui permettent une utilisation plus efficace des ressources.  Il s'agit de combiner plusieurs messages dans une trame Websocket pour économiser sur les appels système Write ou, par exemple, utiliser Gogoprotobuf pour sérialiser les messages Protobuf et autres.  En parlant de Protobuf. </p><br><h1 id="binarnyy-protobuf-protokol">  Protocole Protobuf binaire </h1><br><p>  Je voulais vraiment que Centrifugo travaille avec des données binaires ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">et pas seulement moi</a> ), donc dans la nouvelle version, je voulais ajouter un protocole binaire en plus de celui existant basé sur JSON.  Maintenant, le protocole entier est décrit comme un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">schéma Protobuf</a> .  Cela nous a permis de le rendre plus structuré, de repenser certaines décisions non évidentes dans le protocole de la première version. </p><br><p>  Je pense que vous n'avez pas besoin de dire longtemps quels sont les avantages de Protobuf par rapport à JSON - compacité, vitesse de sérialisation, schéma strict.  Il y a un inconvénient sous la forme d'illisibilité, mais maintenant les utilisateurs ont la possibilité de décider ce qui est le plus important pour eux dans une situation particulière. </p><br><p>  En général, le trafic généré par le protocole Centrifugo lors de l'utilisation de Protobuf au lieu de JSON devrait diminuer d'environ 2 fois (à l'exclusion des données d'application).  La consommation de CPU dans mes tests de charge synthétique a diminué de la même manière ~ 2 fois par rapport à JSON.  Ces chiffres parlent en fait peu de ce que, dans la pratique, tout dépendra du profil de charge d'une application particulière. </p><br><p>  Pour des raisons d'intérêt, j'ai lancé sur une machine avec Debian 9.4 et 32 ​​processeurs Intel® Xeon® Platinum 8168 @ 2.70GHz vCPU, ce qui nous a permis de comparer la bande passante de l'interaction client-serveur en cas d'utilisation du protocole JSON et du protocole Protobuf.  Il y avait 1000 abonnés à 1 chaîne.  Sur cette chaîne, les messages ont été publiés en 4 flux et remis à tous les abonnés.  La taille de chaque message était de 128 octets. </p><br><p>  Résultats pour JSON: </p><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -s ws:<span class="hljs-comment"><span class="hljs-comment">//localhost:8000/connection/websocket -n 1000 -ns 1000 -np 4 channel Starting benchmark [msgs=1000, msgsize=128, pubs=4, subs=1000] Centrifuge Pub/Sub stats: 265,900 msgs/sec ~ 32.46 MB/sec Pub stats: 278 msgs/sec ~ 34.85 KB/sec [1] 73 msgs/sec ~ 9.22 KB/sec (250 msgs) [2] 71 msgs/sec ~ 9.00 KB/sec (250 msgs) [3] 71 msgs/sec ~ 8.90 KB/sec (250 msgs) [4] 69 msgs/sec ~ 8.71 KB/sec (250 msgs) min 69 | avg 71 | max 73 | stddev 1 msgs Sub stats: 265,635 msgs/sec ~ 32.43 MB/sec [1] 273 msgs/sec ~ 34.16 KB/sec (1000 msgs) ... [1000] 277 msgs/sec ~ 34.67 KB/sec (1000 msgs) min 265 | avg 275 | max 278 | stddev 2 msgs</span></span></code> </pre> <br><p>  Résultats pour le cas Protobuf: </p><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -s ws:<span class="hljs-comment"><span class="hljs-comment">//localhost:8000/connection/websocket?format=protobuf -n 100000 -ns 1000 -np 4 channel Starting benchmark [msgs=100000, msgsize=128, pubs=4, subs=1000] Centrifuge Pub/Sub stats: 681,212 msgs/sec ~ 83.16 MB/sec Pub stats: 685 msgs/sec ~ 85.69 KB/sec [1] 172 msgs/sec ~ 21.57 KB/sec (25000 msgs) [2] 171 msgs/sec ~ 21.47 KB/sec (25000 msgs) [3] 171 msgs/sec ~ 21.42 KB/sec (25000 msgs) [4] 171 msgs/sec ~ 21.42 KB/sec (25000 msgs) min 171 | avg 171 | max 172 | stddev 0 msgs Sub stats: 680,531 msgs/sec ~ 83.07 MB/sec [1] 681 msgs/sec ~ 85.14 KB/sec (100000 msgs) ... [1000] 681 msgs/sec ~ 85.13 KB/sec (100000 msgs) min 680 | avg 680 | max 685 | stddev 1 msgs</span></span></code> </pre><br><p>  Vous pouvez remarquer que le débit d'une telle installation est plus de 2 fois supérieur dans le cas de Protobuf.  Le script client peut être trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> - c'est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">script de référence Nats adapté aux réalités de Centrifuge</a> . </p><br><p>  Il convient également de noter que les performances de la sérialisation JSON sur le serveur peuvent être "améliorées" en utilisant la même approche que dans gogoprotobuf - pool de tampons et génération de code - actuellement JSON est sérialisé par un package de la bibliothèque standard Go construite sur Reflect.  Par exemple, dans Centrifugo, la première version de JSON est sérialisée manuellement à l'aide d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque</a> qui fournit <a href="">un pool de mémoire tampon</a> .  Quelque chose de similaire peut être fait à l'avenir dans le cadre de la deuxième version. </p><br><p>  Il convient de souligner que protobuf peut également être utilisé lors de la communication avec le serveur à partir d'un navigateur.  Le client javascript utilise pour cela la bibliothèque protobuf.js.  Étant donné que la bibliothèque protobufjs est assez lourde et que le nombre d'utilisateurs au format binaire sera petit, en utilisant webpack et son algorithme de tremblement d'arbre, nous générons deux versions du client - l'une avec prise en charge du protocole JSON uniquement, et l'autre avec prise en charge JSON et protobuf.  Pour les autres environnements où la taille des ressources ne joue pas un rôle aussi critique, les clients ne peuvent pas s'inquiéter de cette séparation. </p><br><h1 id="json-web-token-jwt">  Jeton Web JSON (JWT) </h1><br><p>  L'un des problèmes liés à l'utilisation d'un serveur autonome tel que Centrifugo est qu'il ne sait rien de vos utilisateurs et de leur méthode d'authentification, ni du type de mécanisme de session utilisé par votre backend.  Et vous devez en quelque sorte authentifier la connexion. </p><br><p>  Pour ce faire, dans la première version Centrifuge, lors de la connexion, la signature SHA-256 HMAC a été utilisée, basée sur une clé secrète connue uniquement du backend et de la Centrifuge.  Ainsi, l'ID utilisateur transmis par le client lui appartient réellement. </p><br><p>  Peut-être que le transfert correct des paramètres de connexion et la génération d'un jeton ont été l'une des principales difficultés à intégrer Centrifugo dans le projet. </p><br><p>  Lorsque la centrifugeuse est apparue, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la norme JWT</a> n'était pas encore si populaire.  Maintenant, quelques années plus tard, des bibliothèques pour la génération JWT sont disponibles pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les langues les plus populaires</a> .  L'idée principale de JWT est exactement ce dont la centrifugeuse a besoin: la confirmation de l'authenticité des données transmises.  Dans la deuxième version de HMAC, une signature générée manuellement a fait place à l'utilisation de JWT.  Cela a permis de supprimer le besoin de prise en charge des fonctions d'assistance pour la génération correcte de jetons dans des bibliothèques pour différentes langues. </p><br><p>  Par exemple, en Python, un jeton de connexion à Centrifugo peut être généré comme suit: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time token = jwt.encode({<span class="hljs-string"><span class="hljs-string">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"42"</span></span>, <span class="hljs-string"><span class="hljs-string">"exp"</span></span>: int(time.time()) + <span class="hljs-number"><span class="hljs-number">10</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>}, <span class="hljs-string"><span class="hljs-string">"secret"</span></span>).decode() print(token)</code> </pre> <br><p>  Il est important de noter que si vous utilisez la bibliothèque Centrifuge, vous pouvez authentifier l'utilisateur en utilisant la méthode Go native - à l'intérieur du middleware.  Des exemples sont dans le référentiel. </p><br><h1 id="grpc">  GRPC </h1><br><p>  Pendant le développement, j'ai essayé le streaming bidirectionnel GRPC comme moyen de transport pour la communication entre le client et le serveur (en plus des solutions de secours Websocket et HTTP SockJS).  Que puis-je dire?  Il a travaillé.  Cependant, je n'ai pas trouvé un seul scénario où le streaming GRPC bidirectionnel serait mieux que Websocket.  J'ai regardé principalement les métriques du serveur: trafic généré via l'interface réseau, consommation CPU par le serveur avec un grand nombre de connexions entrantes, consommation mémoire par connexion. </p><br><p>  GRPC a perdu Websocket à tous égards: </p><br><ul><li>  GRPC génère 20% de trafic supplémentaire dans des scénarios similaires, </li><li>  GRPC consomme 2 à 3 fois plus de CPU (selon la configuration des connexions - tous sont abonnés à des canaux différents ou tous sont abonnés à un canal), </li><li>  GRPC consomme 4 fois plus de RAM par connexion.  Par exemple, sur des connexions 10 000, le serveur Websocket a consommé 500 Mo de mémoire et GRPC - 2 Go. </li></ul><br><p>  Les résultats étaient assez ... attendus.  En général, dans GRPC, en tant que transport client, je ne voyais pas beaucoup de sens - et j'ai supprimé le code avec une conscience claire jusqu'à ce que, peut-être, des temps meilleurs. </p><br><p>  Cependant, GRPC est bon pour ce pour quoi il a été principalement créé - pour générer du code qui vous permet de faire des appels RPC entre les services en utilisant un schéma prédéterminé.  Par conséquent, en plus de l'API HTTP, la centrifugeuse aura désormais également la prise en charge de l'API basée sur GRPC, par exemple pour la publication de nouveaux messages sur le canal et d'autres méthodes d'API de serveur disponibles. </p><br><h1 id="slozhnosti-s-klientami">  Difficultés avec les clients </h1><br><p>  Les modifications apportées dans la deuxième version, j'ai supprimé le support obligatoire des bibliothèques pour l'API serveur - il est devenu plus facile à intégrer côté serveur, cependant, le protocole client du projet a été modifié et dispose d'un nombre suffisant de fonctionnalités.  Cela rend la mise en œuvre des clients assez difficile.  Pour la deuxième version, nous avons maintenant un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">client pour Javascript</a> qui fonctionne dans les navigateurs, devrait fonctionner avec NodeJS et React-Native.  Il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">client sur Go</a> et construit sur sa base et sur la base <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des liants de projet gomobile</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour iOS et Android</a> . </p><br><p>  Pour un bonheur complet, il n'y a pas assez de bibliothèques natives pour iOS et Android.  Pour la première version de Centrifugo, ils ont été achetés par des gars de la communauté open-source.  Je veux croire que quelque chose comme ça va arriver maintenant. </p><br><p>  J'ai récemment tenté ma chance en envoyant une demande de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">subvention MOSS de Mozilla</a> , dans l'intention d'investir dans le développement client, mais a été refusée.  La raison en est la communauté insuffisamment active sur Github.  Malheureusement, cela est vrai, mais comme vous pouvez le voir, je prends des mesures pour améliorer la situation. </p><br><p><img src="https://habrastorage.org/webt/y4/3q/kc/y43qkcl_yp7fjdgalrqvuzw5hl0.jpeg"></p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Je n'ai pas annoncé toutes les fonctionnalités qui apparaîtront dans Centrifugo v2 - un peu plus d'informations sont dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problème sur Github</a> .  La version du serveur n'a pas encore eu lieu, mais elle arrivera bientôt.  Il reste des moments inachevés, notamment la nécessité de compléter la documentation.  Le prototype de la documentation peut être consulté <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Si vous êtes un utilisateur de Centrifugo, c'est le bon moment pour influencer la deuxième version du serveur.  Un moment où ce n'est pas si effrayant de casser quelque chose, de mieux faire plus tard.  Pour les intéressés: le développement est concentré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la branche c2</a> . </p><br><p>  Il est difficile pour moi de juger de la demande de la bibliothèque Centrifuge qui sous-tend Centrifugo v2.  Pour le moment, je suis heureux d'avoir pu le ramener à son état actuel.  L'indicateur le plus important pour moi maintenant est la réponse à la question "est-ce que j'utiliserais moi-même cette bibliothèque dans mon projet personnel?"  Ma réponse est oui.  Au travail?  Oui  Par conséquent, je crois que d'autres développeurs l'apprécieront. </p><br><p>  PS Je voudrais remercier les gars qui ont aidé avec le travail et les conseils - Dmitry Korolkov, Artemy Ryabinkov, Oleg Kuzmin.  Ce serait serré sans toi. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416915/">https://habr.com/ru/post/fr416915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416905/index.html">Présentation de Boston Dynamics SpotMini</a></li>
<li><a href="../fr416907/index.html">Théorie du bonheur. Zèbre de loi et file d'attente extraterrestre</a></li>
<li><a href="../fr416909/index.html">Historique des sessions actives de PostgreSQL - nouvelle extension pgsentinel</a></li>
<li><a href="../fr416911/index.html">Les chatbots étaient censés être la prochaine percée: qu'est-ce qui a mal tourné?</a></li>
<li><a href="../fr416913/index.html">Qu'est-ce que l'administrateur doit oublier lors du passage au cloud - et ce qu'il faut apprendre</a></li>
<li><a href="../fr416917/index.html">Septième tristesse</a></li>
<li><a href="../fr416919/index.html">Burger King et enregistrement d'écran secret de votre téléphone</a></li>
<li><a href="../fr416921/index.html">Comment des centaines de milliers d'antennes se réunissent dans un seul télescope</a></li>
<li><a href="../fr416925/index.html">Ce que nous savons sur Ant Design</a></li>
<li><a href="../fr416927/index.html">Startups de chaussures - et pourquoi la Silicon Valley les aime tant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>