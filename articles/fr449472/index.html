<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏾 📔 👰🏾 Cataclysm Dark Days Ahead, analyse statique et bagels 🧝🏽 🔜 👩🏼‍🤝‍👨🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Très probablement, d'après le titre de l'article, vous avez déjà deviné que l'accent est mis sur les erreurs dans le code source. Mais ce n'est pas la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cataclysm Dark Days Ahead, analyse statique et bagels</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/449472/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73b/65b/d13/73b65bd13915628ce2e414e1881f9ac3.png" alt="Image 10"></div><br>  Très probablement, d'après le titre de l'article, vous avez déjà deviné que l'accent est mis sur les erreurs dans le code source.  Mais ce n'est pas la seule chose qui sera discutée dans cet article.  Si en plus du C ++ et des erreurs dans le code de quelqu'un d'autre, vous êtes attiré par des jeux inhabituels et vous souhaitez savoir ce que sont ces "bagels" et ce qu'ils mangent avec eux, bienvenue au chat! <br><a name="habracut"></a><br>  Dans ma recherche de jeux inhabituels, je suis tombé sur un jeu Cataclysm Dark Days Ahead, qui diffère des autres graphiques inhabituels: il est mis en œuvre en utilisant des caractères ASCII multicolores sur fond noir. <br><br>  Ce qui frappe dans ce jeu et son acabit, c'est combien tout est implémenté en eux.  Plus précisément, dans Cataclysm, par exemple, même pour créer un personnage, je veux rechercher des guides, car il existe des dizaines de paramètres, de fonctionnalités et de tracés initiaux différents, sans parler des variations d'événements dans le jeu lui-même. <br><br>  Il s'agit d'un jeu open source, également écrit en C ++.  Il était donc impossible de passer à côté et de ne pas exécuter ce projet via l'analyseur statique PVS-Studio, dans le développement duquel je suis maintenant activement impliqué.  Le projet lui-même m'a surpris par la haute qualité du code, cependant, il contient encore quelques défauts et j'en discuterai plusieurs dans cet article. <br><br>  À ce jour, de nombreux jeux ont été testés avec PVS-Studio.  Par exemple, vous pouvez lire notre autre article, « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse statique dans l'industrie du jeu vidéo: les 10 principales erreurs logicielles</a> ». <br><br><h2>  La logique </h2><br>  <b>Exemple 1:</b> <br><br>  L'exemple suivant est une erreur de copie typique. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques à gauche et à droite de '||'  opérateur: rng (2, 7) &lt;abs (z) ||  rng (2, 7) &lt;abs (z) overmap.cpp 1503 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> overmap::generate_sub( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z ) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( rng( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( z ) || rng( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( z ) ) { .... } .... }</code> </pre> <br>  Ici, la même condition est vérifiée deux fois.  Très probablement, l'expression a été copiée et a oublié de changer quelque chose.  J'ai du mal à dire si cette erreur est importante, mais la vérification ne fonctionne pas comme prévu. <br><br>  Un avertissement similaire: <ul><li>  V501 Il existe des sous-expressions identiques «one_in (100000 / to_turns &lt;int&gt; (dur))» à gauche et à droite de l'opérateur «&amp;&amp;».  player_hardcoded_effects.cpp 547 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8c/16d/103/e8c16d1033a55f07c7754b604aae4807.png" alt="Image 9"></div><br>  <b>Exemple 2:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V728</a> Un contrôle excessif peut être simplifié.  Le '(A &amp;&amp; B) ||  (! A &amp;&amp;! B) 'est équivalente à l'expression' bool (A) == bool (B) '.  inventaire_ui.cpp 199 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inventory_selector_preset::sort_compare( .... ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> left_fav = g-&gt;u.inv.assigned.count( lhs.location-&gt;invlet ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> right_fav = g-&gt;u.inv.assigned.count( rhs.location-&gt;invlet ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( left_fav &amp;&amp; right_fav ) || ( !left_fav &amp;&amp; !right_fav ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .... } .... }</code> </pre> <br>  Il n'y a pas d'erreur dans la condition, mais c'est inutilement compliqué.  Il vaudrait la peine de prendre pitié de ceux qui doivent démonter cette condition, et il est plus facile d'écrire <i>if (left_fav == right_fav)</i> . <br><br>  Un avertissement similaire: <br><br><ul><li>  V728 Un contrôle excessif peut être simplifié.  Le '(A &amp;&amp;! B) ||  (! A &amp;&amp; B) 'est équivalente à l'expression' bool (A)! = Bool (B) '.  iuse_actor.cpp 2653 </li></ul><br><h2>  Retraite I </h2><br>  Il s'est avéré être une découverte pour moi que les jeux qui sont aujourd'hui appelés «bagels» ne sont que des adeptes assez légers de l'ancien genre des jeux roguelike.  Tout a commencé avec le jeu culte Rogue de 1980, qui est devenu un modèle et a inspiré de nombreux étudiants et programmeurs à créer leurs propres jeux.  Je pense que beaucoup a également été apporté par la communauté des jeux de rôle du conseil d'administration de DnD et ses variantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/d85/de3/4dcd85de3509609962cab730653f7ed1.png" alt="Image 8"></div><br><h2>  Microoptimisation </h2><br>  <b>Exemple 3:</b> <br><br>  Le prochain groupe d'avertissements de l'analyseur n'indique pas une erreur, mais la possibilité d'une microoptimisation du code du programme. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V801</a> Diminution des performances.  Il est préférable de redéfinir le deuxième argument de fonction comme référence.  Pensez à remplacer "const ... type" par "const ... &amp; type".  map.cpp 4644 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Stack&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;item&gt; use_amount_stack( Stack <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itype_id type ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;item&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.begin(); a != <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.end() &amp;&amp; quantity &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a-&gt;use_amount( type, ret ) ) { a = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.erase( a ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++a; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Ici, <i>itdpe_id</i> masque <i>std :: string</i> .  Étant donné que l'argument est toujours passé constant, ce qui ne permettra pas de le modifier, il serait plus rapide de simplement passer une référence de variable à la fonction et de ne pas gaspiller de ressources lors de la copie.  Et bien que, très probablement, la ligne y soit très petite, mais une copie constante sans raison apparente n'est pas nécessaire.  De plus, cette fonction est appelée à partir de différents endroits, dont beaucoup, à leur tour, obtiennent également le <i>type</i> de l'extérieur et le copient. <br><br>  Avertissements similaires: <br><br><ul><li>  V801 Diminution des performances.  Il est préférable de redéfinir le troisième argument de fonction comme référence.  Pensez à remplacer 'const ... evt_filter' par 'const ... &amp; evt_filter'.  input.cpp 691 </li><li>  V801 Diminution des performances.  Il est préférable de redéfinir le cinquième argument de fonction comme référence.  Pensez à remplacer «const ... color» par «const ... &amp; color».  output.h 207 </li><li>  Au total, l'analyseur a généré 32 avertissements de ce type. </li></ul><br>  <b>Exemple 4:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V813</a> Performances <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réduites</a> .  L'argument 'str' devrait probablement être rendu comme une référence constante.  catacharset.cpp 256 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base64_encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( str.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; str[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'#'</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> input_length = str.length(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encoded_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( output_length, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'\0'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; input_length; ) { .... } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mod_table[input_length % <span class="hljs-number"><span class="hljs-number">3</span></span>]; i++ ) { encoded_data[output_length - <span class="hljs-number"><span class="hljs-number">1</span></span> - i] = <span class="hljs-string"><span class="hljs-string">'='</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"#"</span></span> + encoded_data; }</code> </pre> <br>  Dans ce cas, l'argument, bien que non constant, ne change pas dans le corps de la fonction.  Par conséquent, pour l'optimisation, il serait bien de le passer par un lien constant et de ne pas forcer le compilateur à créer des copies locales. <br><br>  Cet avertissement n'était pas non plus unique, il y avait 26 cas au total. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/557/9b3/4ff5579b36733a7bd46f4c3df6f30d90.png" alt="Image 7"></div><br>  Avertissements similaires: <br><br><ul><li>  V813 Performances réduites.  L'argument 'message' devrait probablement être restitué comme une référence constante.  json.cpp 1452 </li><li>  V813 Performances réduites.  L'argument 's' devrait probablement être rendu comme une référence constante.  catacharset.cpp 218 </li><li>  Et ainsi de suite ... </li></ul><br><h2>  Retraite II </h2><br>  Certains des jeux roguelike classiques sont toujours en cours de développement.  Si vous accédez aux référentiels GitHub Cataclysm DDA ou NetHack, vous pouvez voir que des modifications sont activement apportées chaque jour.  NetHack est généralement le plus ancien jeu en cours de développement: il est sorti en juillet 1987 et la dernière version date de 2018. <br><br>  Cependant, l'un des jeux les plus célèbres de ce genre est Dwarf Fortress, développé depuis 2002 et sorti pour la première fois en 2006.  «Perdre, c'est amusant» est la devise du jeu, qui reflète fidèlement son essence, car il est impossible de la gagner.  Ce jeu en 2007 a remporté le titre de meilleur jeu roguelike de l'année à la suite du vote, qui a lieu chaque année sur le site Web ASCII GAMES. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e39/7fb/efa/e397fbefa4204777cc74d97e2b8e52e9.png" alt="Image 6"></div><br>  Par ailleurs, ceux qui sont intéressés par ce jeu peuvent être intéressés par les nouvelles suivantes.  Dwarf Fortress sortira sur Steam avec des graphismes 32 bits améliorés.  Avec une image mise à jour sur laquelle travaillent deux modérateurs de jeux expérimentés, la version premium de Dwarf Fortress recevra des pistes musicales supplémentaires et un support pour Steam Workshop.  Mais si quoi que ce soit, les propriétaires de la version payante de Dwarf Fortress pourront changer les graphiques mis à jour au format précédent en ASCII.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Plus de détails</a> . <br><br><h2>  Remplacement de l'opérateur d'affectation </h2><br>  <b>Exemples 5, 6:</b> <br><br>  Il y avait également une paire intéressante d'avertissements similaires. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V690</a> La classe 'JsonObject' implémente un constructeur de copie, mais il manque l'opérateur '='.  Il est dangereux d'utiliser une telle classe.  json.h 647 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... JsonIn *jsin; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JsonObject( JsonIn &amp;jsin ); JsonObject( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JsonObject &amp;jsobj ); JsonObject() : positions(), start( <span class="hljs-number"><span class="hljs-number">0</span></span> ), end( <span class="hljs-number"><span class="hljs-number">0</span></span> ), jsin( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {} ~JsonObject() { finish(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// moves the stream to the end of the object .... void JsonObject::finish() { .... } .... }</span></span></code> </pre> <br>  Cette classe a un constructeur et un destructeur de copie, cependant, elle ne surcharge pas l'opérateur d'affectation.  Le problème ici est qu'un opérateur d'affectation généré automatiquement ne peut affecter qu'un pointeur à <i>JsonIn</i> .  Par conséquent, les deux objets de la classe <i>JsonObject</i> pointent vers le même <i>JsonIn</i> .  On ne sait pas si une telle situation pourrait se produire quelque part maintenant, mais, dans tous les cas, c'est un rake sur lequel quelqu'un va marcher tôt ou tard. <br><br>  Un problème similaire est présent dans la classe suivante. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V690</a> La classe 'JsonArray' implémente un constructeur de copie, mais il manque l'opérateur '='.  Il est dangereux d'utiliser une telle classe.  json.h 820 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonArray</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... JsonIn *jsin; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JsonArray( JsonIn &amp;jsin ); JsonArray( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JsonArray &amp;jsarr ); JsonArray() : positions(), ...., jsin( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {}; ~JsonArray() { finish(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// move the stream position to the end of the array void JsonArray::finish() { .... } }</span></span></code> </pre> <br>  Vous pouvez en savoir plus sur le danger d'un manque de surcharge d'un opérateur d'affectation pour une classe complexe dans l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Law of The Big Two</a> " (ou dans la traduction de cet article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++: The Big Two Law</a> "). <br><br>  <b>Exemples 7, 8:</b> <br><br>  Un autre exemple lié à l'opérateur d'affectation surchargé, mais cette fois, nous parlons de sa mise en œuvre spécifique. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V794</a> L'opérateur d'affectation doit être protégé contre le cas de 'this == &amp; other'.  mattack_common.h 49 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRefTestAccess</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* m_start; size_type m_size; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* m_data = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = ( StringRef <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;other ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> -&gt; StringRef&amp; { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] m_data; m_data = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; m_start = other.m_start; m_size = other.m_size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Le problème est que cette implémentation n'est pas protégée contre l'affectation de l'objet à lui-même, ce qui est une pratique dangereuse.  En d'autres termes, si une référence à <i>* this</i> est transmise à cet opérateur, une fuite de mémoire peut se produire. <br><br>  Un exemple similaire de surcharge d'opérateur d'affectation erronée avec un effet secondaire intéressant: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V794</a> L'opérateur d'affectation doit être protégé contre le cas de 'this == &amp; rhs'.  player_activity.cpp 38 <br><br><pre> <code class="cpp hljs">player_activity &amp;player_activity::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> player_activity &amp;rhs ) { type = rhs.type; .... targets.clear(); targets.reserve( rhs.targets.size() ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform( rhs.targets.begin(), rhs.targets.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter( targets ), []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> item_location &amp; e ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.clone(); } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Dans ce cas, tout comme il n'y a pas de contrôle sur l'affectation de l'objet à lui-même.  Mais en plus, le vecteur se remplit.  Si vous essayez de vous assigner l'objet par une telle surcharge, alors dans le champ <i>cibles</i> , nous obtenons un vecteur doublé, dont certains éléments sont corrompus.  Cependant, il y a <i>clair</i> avant la <i>transformation</i> qui effacera le vecteur de l'objet et les données seront perdues. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92a/db9/a3a/92adb9a3ab8b30a4f8c02de2bc353a7a.png" alt="Image 16"></div><br><h2>  Retraite III </h2><br>  En 2008, les bagels ont même acquis une définition formelle, qui a reçu le nom épique «Interprétation de Berlin».  Selon cette définition, les principales caractéristiques de ces jeux sont: <br><br><ul><li>  Un monde généré aléatoirement qui augmente la valeur de relecture; </li><li>  Permadeath: si votre personnage meurt, il meurt pour toujours et tous les objets sont perdus; </li><li>  Pas à pas: les changements ne se produisent qu’en même temps que l’action du joueur, jusqu’à ce que l’action soit exécutée - le temps s’arrête; </li><li>  Survie: les ressources sont extrêmement limitées. </li></ul><br>  Eh bien et surtout: les bagels visent principalement à explorer et découvrir le monde, à chercher de nouvelles façons d'utiliser des objets et de parcourir des donjons. <br><br>  La situation habituelle dans Cataclysm DDA: gelé et affamé à mort, vous êtes tourmenté par la soif, et vous avez en effet six tentacules au lieu de jambes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fe/f8e/b69/8fef8eb69a48050011726fe47ec1da35.png" alt="Image 15"></div><br><h2>  Détails importants </h2><br>  <b>Exemple 9:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V1028 Débordement</a> possible.  Envisagez de transposer des opérandes de l'opérateur 'start + large' en type 'size_t', pas le résultat.  worldfactory.cpp 638 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> worldfactory::draw_mod_list( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;start, .... ) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> larger = ....; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iNum = ....; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( .... ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( iNum &gt;= <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;( start ) &amp;&amp; iNum &lt; <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;( start + larger ) ) { .... } .... } .... }</code> </pre> <br>  Il semble que le programmeur ait voulu éviter les débordements.  Mais apporter le résultat de l'addition dans ce cas est inutile, car un débordement se produira lorsque les nombres seront ajoutés et une expansion de type sera effectuée sur le résultat sans signification.  Afin d'éviter cette situation, vous devez <i>convertir</i> un seul des arguments en un type plus grand: <i>(static_cast &lt;size_t&gt; (start) + large)</i> . <br><br>  <b>Exemple 10:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V530</a> La valeur de retour de la fonction 'taille' doit être utilisée.  worldfactory.cpp 1340 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> worldfactory::world_need_lua_build( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> world_name ) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LUA .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Prevent unused var error when LUA and RELEASE enabled. world_name.size(); return false; }</span></span></span></span></code> </pre> <br>  Pour de tels cas, il y a une petite astuce.  Si la variable n'est pas utilisée, au lieu d'essayer d'appeler n'importe quelle méthode, vous pouvez simplement écrire <i>(void) world_name</i> pour supprimer l'avertissement du compilateur. <br><br>  <b>Exemple 11:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V812</a> Performances <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réduites</a> .  Utilisation inefficace de la fonction «comptage».  Il peut éventuellement être remplacé par l'appel à la fonction 'find'.  player.cpp 9600 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> player::read( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inventory_position, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> continuous ) { .... player_activity activity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !continuous || !<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::all_of( learners.begin(), learners.end(), [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;npc *, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; elem ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::count( activity.values.begin(), activity.values.end(), elem.first-&gt;getID() ) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } ) { .... } .... }</code> </pre> <br>  A en juger par le fait que le résultat du <i>comptage est</i> comparé à zéro, l'idée est de comprendre s'il y a au moins un élément requis parmi l' <i>activité</i> .  Mais <i>count est</i> obligé de parcourir tout le conteneur, car il compte toutes les occurrences de l'élément.  Dans cette situation, il sera plus rapide d'utiliser <i>find</i> , qui s'arrête une fois la première correspondance trouvée. <br><br>  <b>Exemple 12:</b> <br><br>  L'erreur suivante est facilement détectée si vous connaissez une subtilité. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V739</a> EOF ne doit pas être comparé à une valeur de type 'char'.  Le «ch» doit être de type «int».  json.cpp 762 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> JsonIn::skip_separator() { <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == <span class="hljs-string"><span class="hljs-string">','</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ate_separator ) { .... } .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == EOF) { .... }</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/976/f53/d2f/976f53d2fe83c567077c7eacb481d852.png" alt="Image 3"></div><br>  C'est l'une de ces erreurs qui peut être difficile à remarquer si vous ne savez pas que <i>EOF est</i> défini comme -1.  Par conséquent, si vous essayez de le comparer avec une variable de type <i>signé char</i> , la condition est presque toujours <i>fausse</i> .  La seule exception est si le code de caractère est 0xFF (255).  Lors de la comparaison, un tel symbole se transformera en -1 et la condition sera vraie. <br><br>  <b>Exemple 13:</b> <br><br>  La prochaine petite erreur pourrait un jour devenir critique.  Pas étonnant qu'il figure sur la liste CWE en tant que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CWE-834</a> .  Et il y en avait d'ailleurs cinq. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La</a> boucle infinie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V663</a> est possible.  La condition «cin.eof ()» est insuffisante pour rompre la boucle.  Pensez à ajouter l'appel de fonction 'cin.fail ()' à l'expression conditionnelle.  action.cpp 46 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_keymap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;keymap_txt, .... )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt.eof() ) { .... } }</code> </pre> <br>  Comme indiqué dans l'avertissement, la vérification pour atteindre la fin du fichier pendant la lecture ne suffit pas, vous devez également vérifier l'erreur de lecture <i>cin.fail ()</i> .  Modifiez le code pour une lecture plus sécurisée: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt.eof() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(keymap_txt.fail()) { keymap_txt.clear(); keymap_txt.ignore(numeric_limits&lt;streamsize&gt;::max(),<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  <i>keymap_txt.clear () est</i> nécessaire pour supprimer l'état d'erreur (indicateur) du flux en cas d'erreur de lecture du fichier, sinon le texte ne peut pas être lu plus avant.  <i>keymap_txt.ignore</i> avec les <i>paramètres</i> <i>numeric_limits &lt;streamsize&gt; :: max ()</i> et un caractère de contrôle de saut de ligne vous permet de sauter le reste de la ligne. <br><br>  Il existe un moyen beaucoup plus simple d'arrêter la lecture: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt ) { .... }</code> </pre> <br>  Lorsqu'il est utilisé dans un contexte de logique, il se convertit en une valeur équivalente à <i>true</i> jusqu'à ce que <i>EOF</i> soit atteint. <br><br><h2>  Retraite IV </h2><br>  Maintenant, les jeux les plus populaires sont ceux qui combinent les signes des jeux roguelike et d'autres genres: les jeux de plateforme, les stratégies, etc. Ces jeux sont maintenant appelés roguelike-like ou roguelite.  Ces jeux incluent des titres célèbres tels que Don't Starve, The Binding of Isaac, FTL: Faster Than Light, Darkest Dungeon et même Diablo. <br><br>  Bien que la différence entre roguelike et roguelite soit parfois si petite qu'il n'est pas clair à quel genre le jeu appartient.  Quelqu'un croit que Dwarf Fortress n'est plus un roguelike, mais pour quelqu'un, Diablo est un bagel classique. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/330/a83/895/330a838954a71a90e8bd65764a9169a8.png" alt="Image 1"></div><br><h2>  Conclusion </h2><br>  Bien que le projet dans son ensemble soit un exemple de code de haute qualité et qu'il n'ait pas été possible de trouver de nombreuses erreurs graves, cela ne signifie pas que l'utilisation de l'analyse statique est redondante pour lui.  Le point n'est pas dans les contrôles ponctuels que nous faisons afin de vulgariser la méthodologie de l'analyse de code statique, mais dans l'utilisation régulière de l'analyseur.  De nombreuses erreurs peuvent alors être identifiées à un stade précoce et, par conséquent, réduire le coût de leur correction.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemple de</a> calculs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18d/90c/4b5/18d90c4b57268f6f55e2721a68fc017c.png" alt="Image 2"></div><br>  Un travail actif est en cours sur le jeu considéré et il existe une communauté active de moddeurs.  De plus, il est porté sur de nombreuses plateformes, dont iOS et Android.  Donc, si vous êtes intéressé par ce jeu, je vous recommande d'essayer! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449472/">https://habr.com/ru/post/fr449472/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449460/index.html">Museum DataArt. Le manipulateur souris d'informations graphiques</a></li>
<li><a href="../fr449462/index.html">Utilisation des mécanismes de jetons cryptographiques PKCS # 11 dans les langages de script</a></li>
<li><a href="../fr449464/index.html">Widget vk.com sans demande définit un compteur de mail.ru sur le site</a></li>
<li><a href="../fr449466/index.html">Pauses dans les jeux HTML5</a></li>
<li><a href="../fr449468/index.html">Comment le "piratage éthique" du fabricant de logiciels de jeu s'est transformé en cauchemar complet</a></li>
<li><a href="../fr449476/index.html">Un nouveau type de stockage SSD réduira la consommation d'énergie dans le centre de données - comment cela fonctionne</a></li>
<li><a href="../fr449478/index.html">Ajouter UICollectionViews à un UITableViewCell personnalisé qui se fait via Xib</a></li>
<li><a href="../fr449480/index.html">Choisissez le suivi de bogue approprié</a></li>
<li><a href="../fr449484/index.html">Nous créons un capteur de contrôle de la qualité de l'air sur InfluxDB, Grafana, Docker et Raspberry Pi</a></li>
<li><a href="../fr449486/index.html">Exode massif des jeux par navigateur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>