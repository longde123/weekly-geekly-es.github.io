<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöï ü§® üôÖüèæ Kami memperkirakan throughput saluran MIMO (termasuk algoritma penuangan air) üõÄüèø üéóÔ∏è üë®üèø‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kata Pengantar 


 Pada musim panas 2016, dari acara yang terkenal, hamba Anda yang rendah hati, di antara sekelompok siswa lain, dapat menghadiri kul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami memperkirakan throughput saluran MIMO (termasuk algoritma penuangan air)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448570/"><p><img src="https://habrastorage.org/getpro/habr/post_images/0d0/672/437/0d067243758eedce24dc51cb947b5581.jpg"></p><br><h1 id="predislovie">  Kata Pengantar </h1><br><p>  Pada musim panas 2016, dari acara yang terkenal, hamba Anda yang rendah hati, di antara sekelompok siswa lain, dapat menghadiri kuliah oleh Profesor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Martin Haardt</a> tentang topik <strong>MIMO</strong> , yang diselenggarakan olehnya dalam kerangka program master internasional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">"Komunikasi dan Pemrosesan Sinyal"</a> .  Tetapi, sayangnya, satu setengah minggu dari dua, saya sakit keras - dan karena itu sejumlah topik baru saja keluar dari ruang lingkup pemahaman saya ... Namun, setelah beberapa waktu, menganalisis dasar-dasar MIMO menjadi hobi saya - tidak meninggalkan kasus yang belum selesai. </p><br><p>  Sedikit demi sedikit, semua ini telah berkembang menjadi serangkaian <em>seminar abstrak</em> kecil, yang, mungkin, salah untuk tidak dibagikan.  Dan hari ini, untuk menghormati <strong>Hari Komunikasi</strong> , saya ingin membahas dengan Anda topik bandwidth saluran MIMO - topik sederhana, tetapi masih menimbulkan kesulitan bagi siswa (dan bukan hanya siswa). </p><br><p>  Tampaknya bagi orang-orang yang tidak terlibat bahwa peningkatan jumlah antena penerima dan pemancar dalam kerangka teknologi tersebut meningkatkan bandwidth sistem dengan jumlah yang sama: misalnya, jika Anda menempatkan <strong>2</strong> antena di sisi penerima dan <strong>2</strong> antena di sisi pengirim (MIMO 2x2), maka throughput pasti akan meningkat <strong>2</strong> kali.  Tetapi apakah ini benar dalam teori?  Mari kita coba mencari tahu! </p><a name="habracut"></a><br><blockquote>  Versi yang lebih formal dalam bahasa Inggris dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">di tautan</a> dan di <a href="" rel="nofollow">repositori GitHub</a> saya. <br>  Pada artikel ini, kami tidak akan mempertimbangkan masalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">korelasi antena</a> dan masalah implementasi lainnya.  Kami membatasi diri pada teori suling - sebagai permulaan. </blockquote><br><h1 id="model-prinyatogo-signala">  Model Sinyal yang Diterima </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/308/f3d/94b/308f3d94b67d28b58f43b6c934fdefd7.png"></p><br><p>  Sebelum kita mulai berbicara tentang bandwidth, pertama-tama kita akan membahas deskripsi matematis dari sinyal yang diterima.  Bagian ini harus diambil dengan hati-hati, karena banyak yang akan datang dari formula ini.  Jadi sinyal yang diterima dapat direpresentasikan sebagai: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/4ec/2f2/a114ec2f2cdbad23ee05bedbe4ca698f.svg" alt="\ mathbf {y} = \ sqrt {\ frac {P} {M_T}} \ mathbf {H} \ mathbf {s} + \ mathbf {n} \ qquad (1)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/d01/0b8/a41/d010b8a414d72f3ae43997a3a0c383db.svg" alt="P">  - daya pemancar, <img src="https://habrastorage.org/getpro/habr/post_images/790/f98/5f1/790f985f11719c2994f91faf218ad311.svg" alt="M_T">  - Jumlah antena pemancar, <img src="https://habrastorage.org/getpro/habr/post_images/704/f4d/c83/704f4dc83e43715dbca37e74095e21fd.svg" alt="\ mathbf {s}">  - Karakter yang dikirimkan <img src="https://habrastorage.org/getpro/habr/post_images/0c8/028/7f3/0c80287f3b7d3378c2e2c69a374282d7.svg" alt="\ mathbf {n}">  - Aditif noise, dan <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  - Matriks koefisien transmisi saluran (pada kenyataannya, proses fading). </p><br><p>  Sinyal yang ditransmisikan juga dapat dicat sedikit lebih detail: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/0f5/eb0/3990f5eb08f290f19a1288c2c5772792.svg" alt="s_i = \ gamma_i d_i \ quad i = 1,2, .. M_T \ qquad (2)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/1bb/7b2/fbc/1bb7b2fbccba41b76c9d4173d75920a6.svg" alt="di">  - salah satu sinyal informasi ( <img src="https://habrastorage.org/getpro/habr/post_images/3da/909/c1e/3da909c1e9bfc42a2d72c4cb9eaf46cd.svg" alt="E \ {\ mathbf {d} \ mathbf {d} ^ H \} = M_T">  ), dan <img src="https://habrastorage.org/getpro/habr/post_images/c81/04b/c49/c8104bc49b2fd2a61cc8b9299bc02b3d.svg" alt="\ gamma_i">  - amplifikasi dari jalur propagasi tertentu dari gelombang EM (path gain). </p><br><p>  <u>Mari kita nyatakan apa penguatan jalur:</u> <br>  Penguatan jalur propagasi (atau berat antena) berarti distribusi daya keluaran sebanding dengan "kekuatan" jalur tertentu.  Dengan kata lain, kami ingin mengalokasikan lebih banyak daya untuk saluran yang baik (jalur propagasi) dan lebih sedikit energi untuk saluran yang buruk. </p><br><p>  Bobot antena dibatasi oleh jumlah antena pemancar: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/3c5/de0/cbb3c5de0a1de4ab81447d7e251f85a4.svg" alt="\ jumlah ^ r_ {i = 1} \ gamma_i = M_T \ qquad (3)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/cd2/a49/a17/cd2a49a1779b4e360712e1013ed124a7.svg" alt="r">  Apakah <strong>pangkat</strong> matriks saluran. </p><br><p>  Berbicara tentang yang terakhir. </p><br><p>  Dimensi matriks <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  membuat <img src="https://habrastorage.org/getpro/habr/post_images/043/a05/2ed/043a052edaf7736764222d480a9bdf44.svg" alt="M_R \ kali M_T">  dimana <img src="https://habrastorage.org/getpro/habr/post_images/e8c/d2b/287/e8cd2b287c02798716d1728e3080ebeb.svg" alt="M_R">  - Jumlah antena penerima. <br>  Untuk beberapa pengukuran waktu, saluran akan terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6fb/9e2/0c2/6fb9e20c2a79856e2d952dd1897813ec.png"></p><br><blockquote>  <strong>Untuk referensi:</strong> <br>  Mungkin untuk perhitungan dan model yang lebih rumit, Anda ingin menggunakan salah satu alat paling populer untuk itu - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">MatLab</a> .  Dalam hal ini, perlu dipertimbangkan bahwa struktur data yang sedikit berbeda digunakan di sana: baris adalah pengukuran waktu (foto), jumlah kolom sesuai dengan jumlah antena pemancar <img src="https://habrastorage.org/getpro/habr/post_images/790/f98/5f1/790f985f11719c2994f91faf218ad311.svg" alt="M_T">  , dimensi lateral sesuai dengan <img src="https://habrastorage.org/getpro/habr/post_images/e8c/d2b/287/e8cd2b287c02798716d1728e3080ebeb.svg" alt="M_R">  . </blockquote><p>  Formula (1) dapat dengan mudah diadaptasi untuk kasus-kasus khusus MIMO. </p><br><p>  <strong>MISO</strong> ( <strong>M</strong> ultiple Input <strong>S</strong> ingle Output - beberapa antena pemancar dan satu penerima): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/faa/99b/800/faa99b80083c385e9efcec4c39e135b9.svg" alt="y = \ sqrt {\ frac {P} {M_T}} \ mathbf {h} \ mathbf {s} + n \ qquad (4)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/e0b/43a/394/e0b43a394e4da4c710d883c2040a101f.svg" alt="\ mathbf {h}">  Apakah vektor <img src="https://habrastorage.org/getpro/habr/post_images/198/8ce/bbb/1988cebbb6865548743db331b96b8691.svg" alt="1 \ kali M_T">  . </p><br><p>  <strong>SIMO</strong> (P engaman Tunggal Tunggal <strong>O</strong> utput - beberapa antena penerima dan satu antena pemancar): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/4ce/713/1d44ce713b6479b18db31b6eea465139.svg" alt="y = \ sqrt {P} \ mathbf {h} s + \ mathbf {n} \ qquad (5)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/e0b/43a/394/e0b43a394e4da4c710d883c2040a101f.svg" alt="\ mathbf {h}">  Apakah vektor <img src="https://habrastorage.org/getpro/habr/post_images/255/44a/e75/25544ae75110da1c6751c23ef7057e7d.svg" alt="M_R \ kali 1"></p><br><p>  <strong>SISO</strong> ( <strong>S</strong> ingle Single <strong>S</strong> ingle <strong>O</strong> utput - satu antena di sisi penerima dan pemancar): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dff/17e/6a9/dff17e6a9569811683f776e4e9b87b9a.svg" alt="y = \ sqrt {P} hs + n \ qquad (6)"></div><br><p>  Tampaknya sederhana. </p><br><p>  Semua pertimbangan lebih lanjut dapat dibagi menjadi <strong>dua</strong> kasus besar: informasi status saluran (informasi status saluran CSI) tidak <em>diketahui oleh</em> pemancar ( <strong>CU</strong> - Saluran Tidak Dikenal) dan informasi status saluran <em>diketahui oleh</em> pemancar ( <strong>CK</strong> - Saluran Diketahui). </p><br><p>  Di atas, kami memeriksa kasing ketika saluran tidak <strong>dikenal</strong> oleh pemancar (kasing <strong>terbuka</strong> , transmisi tanpa umpan balik).  Dengan kata lain, karena kurangnya informasi yang diperlukan, kami tidak dapat memilih arah yang efektif, dan oleh karena itu kami mengikuti jalur yang paling sederhana: kami mentransmisikan kekuatan yang sama melalui semua antena (jalur, jalur propagasi).  Oleh karena itu, gain setiap gain jalur adalah <strong>1</strong> : </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/f6d/75b/39ef6d75b2d7666174e1f1570c433b07.svg" alt="\ gamma_i = 1, \ quad i = 1,2, .. M_T \ qquad (7)"></div><br><p>  Namun, kami ulangi: kami ingin mengalokasikan <strong>lebih banyak</strong> daya untuk saluran yang <strong>baik</strong> (jalur propagasi) dan <strong>lebih sedikit</strong> energi untuk saluran yang <strong>buruk</strong> . </p><br><p>  Muncul pertanyaan: <u>bagaimana cara mendistribusikan daya secara efektif?</u> </p><br><p>  Jika saluran <strong>diketahui</strong> ( <strong>kasing tertutup</strong> - dengan umpan balik), kami dapat menggunakan skenario transmisi tingkat lanjut dengan beberapa algoritma pemrosesan sinyal tambahan.  Misalnya, dengan pendekatan linier seperti <em>pre-coding</em> dan <strong>post-processing</strong> . </p><br><p>  Kita akan mengerti apa arti dua istilah terakhir. </p><br><p>  Jika kami memiliki <strong>CSI</strong> di sisi pengiriman, mis.  matriks <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  , kita secara matematis dapat memproses matriks ini.  Misalnya, menerapkan algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">SVD</a> (Singular Value Decomposition). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6bb/95a/fd3/6bb95afd35a66bb0b6421818b985d561.png"></p><br><p>  Perhatikan bahwa matriks <img src="https://habrastorage.org/getpro/habr/post_images/1da/072/a41/1da072a419fecc8ecc89c0fa5f6fcd6d.svg" alt="\ mathbf {\ Sigma}">  Merupakan matriks diagonal, dan unsur-unsur diagonalnya (nilai singular) pada intinya adalah koefisien transmisi jalur propagasi unik.  Dengan kata lain, jika kita mencapai penggandaan sinyal kita dengan matriks nilai singular <img src="https://habrastorage.org/getpro/habr/post_images/1da/072/a41/1da072a419fecc8ecc89c0fa5f6fcd6d.svg" alt="\ mathbf {\ Sigma}">  daripada saluran penuh <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  , maka saluran <strong>MIMO</strong> akan terurai menjadi array saluran <strong>SISO</strong> paralel. </p><br><p>  Jadi matriks precoding linear (filter) seharusnya <img src="https://habrastorage.org/getpro/habr/post_images/0dc/438/f04/0dc438f04dcae00f8f6be6e90cc305d7.svg" alt="\ mathbf {F} = \ mathbf {V} _s">  , dan matriks linear post-processing (demodulator) <img src="https://habrastorage.org/getpro/habr/post_images/7d4/715/f1a/7d4715f1a45bb371053c241af4f13904.svg" alt="\ mathbf {D} = \ mathbf {U} ^ H_s">  ( <em>H</em> adalah singkatan dari konjugasi Hermitian). </p><br><blockquote>  Jelas, untuk kasus dengan saluran yang tidak dikenal <img src="https://habrastorage.org/getpro/habr/post_images/262/9d2/195/2629d21955e2a9cd73b9be24a5a947eb.svg" alt="\ mathbf {F}">  dan <img src="https://habrastorage.org/getpro/habr/post_images/21b/7c1/06d/21b7c106daa35c36f96c5ae499233ec0.svg" alt="\ mathbf {D}">  matriks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">identitas yang</a> sama. </blockquote><p>  Sekarang, mengetahui semua hal di atas, mari kita mendefinisikan kembali model sinyal yang diterima: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38b/56d/23d/38b56d23d403a6a8910ad66923db4118.svg" alt="\ mathbf {Dy} = \ mathbf {D} \ kiri (\ sqrt {\ frac {P} {M_t}} \ mathbf {H} \ mathbf {F} \ mathbf {s} + \ mathbf {n} \ kanan) = \ mathbf {U} ^ H_s \ mathbf {y} = \ sqrt {\ frac {P} {M_t}} \ mathbf {U} ^ H_s \ mathbf {H} \ mathbf {V} _s \ mathbf {s} + \ mathbf {U} ^ H_s \ mathbf {n} = \ sqrt {\ frac {P} {M_t}} \ mathbf {\ Sigma} _s \ mathbf {s} + \ mathbf {\ hat {n}} = \ mathbf {\ hat {y}} \ qquad (8)"></div><br><p>  Perhatikan bahwa: </p><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/feb/dae/d36/febdaed369cb465bf821b996e5e5cb61.svg" alt="\ mathbf {\ hat {n}}">  memiliki sifat statistik yang sama dengan <img src="https://habrastorage.org/getpro/habr/post_images/0c8/028/7f3/0c80287f3b7d3378c2e2c69a374282d7.svg" alt="\ mathbf {n}">  ; </li><li>  Nilai eigen <img src="https://habrastorage.org/getpro/habr/post_images/bff/f9f/d6d/bfff9fd6d698c1d0e8011e5f9a9c6585.svg" alt="\ mathbf {HH} ^ H">  adalah kuadrat dari nilai singular dari matriks saluran <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  ( <img src="https://habrastorage.org/getpro/habr/post_images/5d9/204/19e/5d920419e86666fa5a5de6669e965466.svg" alt="\ sigma_i = \ sqrt {\ lambda_i}">  ) </li></ul><br><p>  Secara skematis, ini dapat direpresentasikan sebagai: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/e66/ce5/f41/e66ce5f41bd4d57670aad51ad5409adc.png" alt="sch" width="500" height="600"><br><p>  <em>Fig.</em>  <em>1. Skema pre-coding dan post-processing [1, hal.67].</em> </p><br><img src="https://habrastorage.org/getpro/habr/post_images/072/138/b29/072138b29e56f44939c260426c564153.png" alt="sejajar" width="500" height="600"><br><p>  <em>Fig.</em>  <em>2. Skema penguraian modal</em> <em><img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}"></em>  <em>ketika saluran diketahui oleh pemancar dan penerima [1, hal.67].</em> </p><br><p>  Dasar-dasar dipisahkan - kita dapat melanjutkan langsung ke <strong>bandwidth</strong> ! </p><br><h1 id="propusknaya-sposobnost-capacity">  Kapasitas </h1><br><p>  Saya pikir semua orang yang mempelajari <strong>teori informasi</strong> ingat bahwa istilah bandwidth datang kepada kita dari disiplin khusus ini.  Biasanya (di usia mahasiswa saya), pertimbangan difokuskan pada kasus klasik saluran AWGN, tetapi rumusnya dapat relatif mudah diperoleh untuk kasus saluran MIMO dengan fading. </p><br><blockquote>  Agar tidak mengetik ulang perhitungan dari buku sekali lagi, saya mencoba mengatur semuanya lebih atau kurang penuh warna dan dengan tangan - untuk memberikan formula kehidupan, sehingga untuk berbicara.  Saya harap format ini tidak terlalu membosankan. </blockquote><p>  Jadi, sekali lagi, kami menulis model sinyal: </p><br><img src="https://habrastorage.org/webt/rh/x_/gc/rhx_gc1lr_rmqj6eaeewoewhvce.png"><br><p>  Sekarang mari kita lanjutkan untuk menentukan throughput melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">informasi timbal balik</a> . </p><br><img src="https://habrastorage.org/webt/40/rb/cf/40rbcfuupxwyyx0ztm58nhubpqc.png"><br><p>  Kami menulis matriks autocovariance dari sinyal yang diterima dan komponennya: </p><br><img src="https://habrastorage.org/webt/hd/ke/nz/hdkenzy3rhhgoysafzwopgnij7u.png"><br><p>  Dan kami menggunakannya dalam menentukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">entropi diferensial</a> : </p><br><img src="https://habrastorage.org/webt/ev/cj/mm/evcjmmt0qlyjudk_7xqn2ldimec.png"><br><p>  Pengganti (4) dan (5) dalam (2): </p><br><img src="https://habrastorage.org/webt/ww/ud/gd/wwudgdbvqd6orus-tfnp3azhly0.png"><br><p>  Dan sekarang kita mengganti (6) dalam (1): </p><br><img src="https://habrastorage.org/webt/2i/3c/p4/2i3cp4tj0nf_4s-rnistbmcw0rm.png"><br><p>  Kami terus beralasan.  Ambil kasus pertama: salurannya tidak diketahui (Kanal tidak dikenal).  Ini berarti bagi kami bahwa tidak mungkin untuk memilih arah transmisi yang optimal, dan oleh karena itu sinyal yang ditransmisikan akan independen dan akan memiliki kekuatan yang sama (bertenaga equi).  Berdasarkan kondisi maksimum ( <img src="https://habrastorage.org/getpro/habr/post_images/b55/710/37c/b5571037cdb68260d690fba1e74c122b.svg" alt="Tr \ {\ mathbf {R} _ {ss} \} = M_T">  ), kita dapat mengambil matriks autocovariance dari karakter yang ditransmisikan sama dengan matriks identitas.  Maka kita memiliki: </p><br><img src="https://habrastorage.org/webt/nn/bd/_p/nnbd_pjhgqezwomw944_71x0vw4.png"><br><p>  Kami menggunakan properti faktor penentu berikut: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbb/866/f57/fbb866f57bd5076cb0d56869fe5ecde0.svg" alt="det \ left (\ mathbf {I} _m + \ mathbf {AB} \ kanan) = det \ left (\ mathbf {I} _n + \ mathbf {BA} \ kanan)"></div><br><p>  Ini adalah kasus kami, dan kami dapat menukar matriks sehingga <img src="https://habrastorage.org/getpro/habr/post_images/698/669/b9e/698669b9ea8fc3b7983608348382cc36.svg" alt="\ mathbf {Q} \ mathbf {Q} ^ H = \ mathbf {I}">  (dari properti EVD).  Akan tetap: </p><br><img src="https://habrastorage.org/webt/pk/no/dq/pknodqpt0rpcbvfp0z9eisl7imq.png"><br><p>  Melewati dari matriks ke jumlah, kita memiliki: </p><br><img src="https://habrastorage.org/webt/u_/gm/k9/u_gmk95fp05y8obm7odpf-wo2lq.png" width="600"><br><p>  Formula ini sekali lagi menggambarkan pendekatan untuk mempertimbangkan MIMO sebagai saluran SISO paralel. <br>  Untuk kasus dengan saluran yang dikenal ( <strong>C</strong> hannel <strong>K</strong> nown), bobot antena akan ditambahkan ke rumus: </p><br><img src="https://habrastorage.org/webt/vr/ht/bl/vrhtblex4vq8soaxqoa1tokmmre.png"><br><p>  Kami juga menulis rumus untuk kasus khusus: </p><br><img src="https://habrastorage.org/webt/y-/f5/7y/y-f57yb-4yc4-yeegeblpmr6-hy.png"><br><blockquote>  <strong>Catatan</strong> : <br>  Untuk kasus <strong>SIMO</strong> dan <strong>MISO,</strong> tidaklah sia-sia bahwa kuadrat dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">norma Frobenius</a> muncul dalam catatan. <img src="https://habrastorage.org/getpro/habr/post_images/c16/a79/bd1/c16a79bd16d4f7febf57f4dc4cefd303.svg" alt="|| \ mathbf {h} || _F ^ 2">  - dari sudut pandang matematika, mereka setara dengan nilai eigen <img src="https://habrastorage.org/getpro/habr/post_images/f99/9f8/c65/f999f8c65e413f78334f6f3db0a438a6.svg" alt="\ mathbf {h} \ mathbf {h} ^ H">  .  Karena itu, jika Anda perlu menghitung sesuatu dengan cepat - ini caranya. </blockquote><p>  Yah, saya harap tulisan tangan dan bahasa Inggris saya tidak terlalu mengganggu persepsi informasi, tetapi tetap saja, mari kita bicara tentang <strong>poin utama</strong> : </p><br><ul><li>  Ya, bandwidth saluran <strong>MIMO</strong> dapat dianggap sebagai <strong>jumlah</strong> bandwidth saluran <strong>SISO</strong> . </li><li>  Namun, jumlah ini dibatasi oleh <strong>peringkat</strong> saluran! </li></ul><br><h2 id="algoritm-water-pouring">  Algoritma Penuangan Air </h2><br><p>  Seperti yang dapat dilihat dari rumus bandwidth yang dikenal di sisi transmisi saluran (CK - Saluran Diketahui), distribusi energi melalui antena dapat dioptimalkan.  Untuk melakukan ini, kami menggunakan algoritma Penuangan Air ( <em>pengisian dengan air</em> ) [1, hlm. 68-69]: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> linalg <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> LA <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waterpouring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mt, SNR_dB, H_chan)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) r = LA.matrix_rank(H_chan) H_sq = np.dot(H_chan,np.matrix(H_chan, dtype=complex).H) lambdas = LA.eigvals(H_sq) lambdas = np.sort(lambdas)[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] p = <span class="hljs-number"><span class="hljs-number">1</span></span>; gammas = np.zeros((r,<span class="hljs-number"><span class="hljs-number">1</span></span>)) flag = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> flag == <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: lambdas_r_p_1 = lambdas[<span class="hljs-number"><span class="hljs-number">0</span></span>:(r-p+<span class="hljs-number"><span class="hljs-number">1</span></span>)] inv_lambdas_sum = np.sum(<span class="hljs-number"><span class="hljs-number">1</span></span>/lambdas_r_p_1) mu = ( Mt / (r - p + <span class="hljs-number"><span class="hljs-number">1</span></span>) ) * ( <span class="hljs-number"><span class="hljs-number">1</span></span> + (<span class="hljs-number"><span class="hljs-number">1</span></span>/SNR) * inv_lambdas_sum) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(lambdas_r_p_1): gammas[idx] = mu - (Mt/(SNR*item)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gammas[rp] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">#due to Python starts from 0 gammas[rp] = 0 #due to Python starts from 0 p = p + 1 else: flag = False res = [] for gamma in gammas: res.append(float(gamma)) return np.array(res)</span></span></code> </pre> <br><p>  Pengujian: </p><br><pre> <code class="python hljs">Mt = <span class="hljs-number"><span class="hljs-number">3</span></span> SNR_db = <span class="hljs-number"><span class="hljs-number">10</span></span> H_chan = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]], dtype = float) gammas = waterpouring(Mt, SNR_db, H_chan) print(<span class="hljs-string"><span class="hljs-string">'Rank of the matrix: '</span></span>+str(LA.matrix_rank(H_chan))) print(<span class="hljs-string"><span class="hljs-string">'Gammas:\n'</span></span>+str(gammas)) &gt;&gt;&gt; Rank of the matrix: <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; Gammas: &gt;&gt;&gt; [<span class="hljs-number"><span class="hljs-number">1.545</span></span> <span class="hljs-number"><span class="hljs-number">1.455</span></span>]</code> </pre> <br><p>  Yah, itu terlihat masuk akal: <br>  1) jumlah antena pemancar yang terlibat sama dengan <strong>pangkat</strong> saluran; <br>  2) jumlah <strong>bobot</strong> antena sama dengan jumlah antena pemancar. </p><br><h2 id="dva-predelnyh-sluchaya">  Dua kasus pembatas </h2><br><p>  Dan sekarang mari kita sedikit terganggu dan menyelesaikan masalah untuk pemahaman. </p><br><p>  Mari kita cari, misalnya, untuk apa koefisiennya <img src="https://habrastorage.org/getpro/habr/post_images/c81/04b/c49/c8104bc49b2fd2a61cc8b9299bc02b3d.svg" alt="\ gamma_i">  dengan SNR cenderung <img src="https://habrastorage.org/getpro/habr/post_images/279/496/46c/27949646c03ab2b1b12c79632ddc20bf.svg" alt="+ \ infty">  dan <img src="https://habrastorage.org/getpro/habr/post_images/60b/863/8b2/60b8638b28b303b1718d37bee487ac72.svg" alt="- \ infty">  (pada skala logaritmik, tentu saja, karena tidak ada kekuatan negatif). </p><br><p>  Kami mengingat rumus korespondensi antara desibel dan waktu: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/109/e43/006/109e430066ec30bab3ea15fc12b24b5a.svg" alt="SNR_ {dB} = 10log_ {10} \ kiri (\ frac {S} {N} \ kanan)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/5bf/27c/73c/5bf27c73c71f303844ee4973cab18377.svg" alt="S">  - kekuatan sinyal yang ditransmisikan (untuk tugas kita, itu setara dengan energi simbol <img src="https://habrastorage.org/getpro/habr/post_images/072/074/880/072074880bc38a00e1970f944ed4cf99.svg" alt="E_s">  ), dan <img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N">  - Kekuatan noise (dalam masalah kami sama dengan kepadatan spektral noise) <img src="https://habrastorage.org/getpro/habr/post_images/69a/ad3/04d/69aad304d9c25b25096b8e1cc83127e0.svg" alt="N_0">  ) </p><br><p>  Jadi pada skala linier akan: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60d/387/38e/60d38738e895ea76af6cc9fcfb1dd0b6.svg" alt="\ frac {E_s} {N_0} \ equiv \ frac {S} {N} = 10 ^ {SNR_ {dB} / 10}"></div><br><p>  Kami melihat rumus dasar dari algoritma: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/6ee/46c/62a6ee46c3a82d81a5b1bddd0f625ea8.svg" alt="\ mu = \ frac {M_T} {(r-p + 1)} \ kiri [1 + \ frac {N_0} {E_s} \ sum_ {i = 1} ^ {r-p + 1} \ frac {1} {\ lambda_i} \ kanan]"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/d76/c4d/c2b/d76c4dc2b17f00a09c864bf2d24ab365.svg" alt="hal">  Apakah iterator dimulai dengan 1, <img src="https://habrastorage.org/getpro/habr/post_images/cd2/a49/a17/cd2a49a1779b4e360712e1013ed124a7.svg" alt="r">  Apakah pangkat matriks saluran, <img src="https://habrastorage.org/getpro/habr/post_images/4a1/9e2/b6a/4a19e2b6a9b67e2a8e0682126d49684a.svg" alt="\ lambda_i">  - nilai eigen ke-i dari "kuadrat" dari matriks saluran.  Gammas dihitung berdasarkan rumus berikut: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f5/2eb/aff/4f52ebaffbebeba87ac646dadd57d2cd.svg" alt="\ gamma_i = \ kiri (\ mu - \ frac {M_TN_0} {E_s \ lambda_i} \ kanan) \ quad i = 1,2, ..., r-p + 1"></div><br><p>  Kami mulai beralasan: </p><br><p>  Jika <img src="https://habrastorage.org/getpro/habr/post_images/734/618/09c/73461809c5cedcf8d9c19312c41a4d7a.svg" alt="SNR_ {dB} \ hingga + \ infty">  lalu <img src="https://habrastorage.org/getpro/habr/post_images/4ae/0cd/4f4/4ae0cd4f42acfe2e7b83ea1781a19667.svg" alt="\ frac {E_s} {N_0} \ hingga + \ infty">  .  Oleh karena itu <img src="https://habrastorage.org/getpro/habr/post_images/c58/ff3/050/c58ff30508740ab8078825a703e9e651.svg" alt="\ frac {N_0} {E_s} \ hingga 0">  .  Untuk iterasi pertama, ia tetap: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05a/3a2/84f/05a3a284fd68bd18f8bbcb5608edf314.svg" alt="\ mu = \ frac {M_T} {r}"></div><br><p>  Pengganti untuk gamma: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/e82/af3/47ee82af3923910da61acce90e57ccc3.svg" alt="\ gamma_i = \ mu = \ frac {M_T} {r} \ quad i = 1,2, ..., r"></div><br><p>  Kami merangkum: </p><br><p>  Dengan energi transmisi yang sangat besar atau kebisingan yang sangat kecil, tidak ada yang perlu diciptakan, katakanlah begitu - kami mendistribusikan daya secara merata di antara antena pemancar (dengan mempertimbangkan peringkat matriks saluran). </p><br><p>  Kami beralasan lebih lanjut: </p><br><p>  Dan apa yang cenderung terjadi pada SNR <img src="https://habrastorage.org/getpro/habr/post_images/60b/863/8b2/60b8638b28b303b1718d37bee487ac72.svg" alt="- \ infty">  ?  Di sini kita bahkan tidak akan masuk ke matematika, kita akan beralasan secara logis: kasus ini sesuai dengan suara yang sangat besar atau nol daya pancar.  Jadi, ini dan itu, sistem kami, anggap, tidak berfungsi.  Karenanya, pertanyaan dengan gammas menghilang secara otomatis ... </p><br><p>  Ini kadang-kadang pertanyaan yang muncul dalam ujian dengan seorang profesor. </p><br><h1 id="schitaem-propusknuyu-sposobnost-nakonec-to">  Menghitung throughput (akhirnya!) </h1><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">siso_capacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(H_chan, SNR_dB)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) c = np.log2(<span class="hljs-number"><span class="hljs-number">1</span></span> + SNR*(np.abs(H_chan)**<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openloop_capacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(H_chan, SNR_dB)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) Mt = np.shape(H_chan)[<span class="hljs-number"><span class="hljs-number">1</span></span>] H_sq = np.dot(H_chan,np.matrix(H_chan, dtype=complex).H) lambdas = LA.eigvals(H_sq) lambdas = np.sort(lambdas)[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] c = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> eig <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lambdas: c = c + np.log2(<span class="hljs-number"><span class="hljs-number">1</span></span> + SNR*eig/Mt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.real(c) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closedloop_capacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(H_chan, SNR_dB)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) Mt = np.shape(H_chan)[<span class="hljs-number"><span class="hljs-number">1</span></span>] H_sq = np.dot(H_chan,np.matrix(H_chan, dtype=complex).H) lambdas = LA.eigvals(H_sq) lambdas = np.real(np.sort(lambdas))[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] c = <span class="hljs-number"><span class="hljs-number">0</span></span> gammas = waterpouring(Mt, SNR_dB, H_chan) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(lambdas): c = c + np.log2(<span class="hljs-number"><span class="hljs-number">1</span></span> + SNR*item*gammas[idx]/Mt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.real(c) Mr = <span class="hljs-number"><span class="hljs-number">4</span></span> Mt = <span class="hljs-number"><span class="hljs-number">4</span></span> H_chan = (np.random.randn(Mr,Mt) \ + <span class="hljs-number"><span class="hljs-number">1j</span></span>*np.random.randn(Mr, Mt))/np.sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">#Rayleigh flat fading c = openloop_capacity(H_chan, 10) print(c) c = closedloop_capacity(H_chan, 10) print(c) c = siso_capacity(H_chan[0,0], 10) print(c) &gt;&gt;&gt; 11.978909197556913 &gt;&gt;&gt; 12.342571770086721 &gt;&gt;&gt; 3.9058582578551193</span></span></code> </pre> <br><p>  Tampaknya bekerja.  Kami lolos ke penilaian yang lebih substantif. </p><br><h2 id="ergodic-capacity">  Kapasitas ergonomis </h2><br><p>  Seperti dapat dilihat dari contoh di atas, kami bekerja dengan proses acak.  Dan, terus terang, itu adalah kesalahan untuk menarik kesimpulan tentang proses acak dalam satu implementasi.  Bahkan jika saluran <em>konstan</em> dalam arti statistik, beberapa rata-rata lebih dari satu set yang cukup besar diperlukan. </p><br><p>  Di sini konsep <strong>kapasitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">ergodik</a></strong> bermanfaat bagi kita: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/664/e69/cc3664e69c54efa0d98127e7f65bf6ea.svg" alt="\ hat {C} = E \ kiri \ {C \ kanan \} \ qquad (9)"></div><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/a73/317/bad/a73317bad2bf7d6419c448e2051efdc9.svg" alt="E \ {* \}">  menunjukkan tikar.  harapan (nilai yang diharapkan). </p><br><p>  Kami adalah pemodelan. </p><br><pre> <code class="python hljs">Mr = <span class="hljs-number"><span class="hljs-number">4</span></span> Mt = <span class="hljs-number"><span class="hljs-number">4</span></span> counter = <span class="hljs-number"><span class="hljs-number">1000</span></span> SNR_dBs = [i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>)] C_MIMO_CU = np.empty((len(SNR_dBs), counter)) C_MIMO_CK = np.empty((len(SNR_dBs), counter)) C_SISO = np.empty((len(SNR_dBs), counter)) C_SIMO = np.empty((len(SNR_dBs), counter)) C_MISO_CU = np.empty((len(SNR_dBs), counter)) C_MISO_CK = np.empty((len(SNR_dBs), counter)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(counter): H_MIMO = (np.random.randn(Mr,Mt) + <span class="hljs-number"><span class="hljs-number">1j</span></span>*np.random.randn(Mr, Mt))/np.sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) H_SISO = H_MIMO[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] H_SIMO = H_MIMO[:,<span class="hljs-number"><span class="hljs-number">0</span></span>].reshape(Mr,<span class="hljs-number"><span class="hljs-number">1</span></span>) H_MISO = H_MIMO[<span class="hljs-number"><span class="hljs-number">0</span></span>,:].reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>,Mt) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, SNR_dB <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(SNR_dBs): C_MIMO_CU[idx, c] = openloop_capacity(H_MIMO, SNR_dB) C_MIMO_CK[idx, c] = closedloop_capacity(H_MIMO, SNR_dB) C_SISO[idx, c] = siso_capacity(H_SISO, SNR_dB) C_SIMO[idx, c] = openloop_capacity(H_SIMO, SNR_dB) C_MISO_CU[idx, c] = openloop_capacity(H_MISO, SNR_dB) C_MISO_CK[idx, c] = closedloop_capacity(H_MISO, SNR_dB) C_MIMO_CU_erg = np.mean(C_MIMO_CU, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_MIMO_CK_erg = np.mean(C_MIMO_CK, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_SISO_erg = np.mean(C_SISO, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_SIMO_erg = np.mean(C_SIMO, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_MISO_CU_erg = np.mean(C_MISO_CU, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_MISO_CK_erg = np.mean(C_MISO_CK, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">600</span></span>) plt.plot(SNR_dBs, C_MIMO_CU_erg,<span class="hljs-string"><span class="hljs-string">'g-o'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=4$, $M_T=4$ (CU)'</span></span>) plt.plot(SNR_dBs, C_MIMO_CK_erg,<span class="hljs-string"><span class="hljs-string">'g-v'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=4$, $M_T=4$ (CK)'</span></span>) plt.plot(SNR_dBs, C_MISO_CU_erg, <span class="hljs-string"><span class="hljs-string">'m-o'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=1$, $M_T=4$ (CU)'</span></span>) plt.plot(SNR_dBs, C_MISO_CK_erg, <span class="hljs-string"><span class="hljs-string">'m-v'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=1$, $M_T=4$ (CK)'</span></span>) plt.plot(SNR_dBs, C_SISO_erg, <span class="hljs-string"><span class="hljs-string">'k-'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=1$, $M_T=1$'</span></span>) plt.plot(SNR_dBs, C_SIMO_erg, <span class="hljs-string"><span class="hljs-string">'c-'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=4$, $M_T=1$'</span></span>) plt.title(<span class="hljs-string"><span class="hljs-string">"Ergodic Capacity"</span></span>) plt.xlabel(<span class="hljs-string"><span class="hljs-string">'SNR (dB)'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Capacity (bps/Hz)'</span></span>) plt.legend() plt.minorticks_on() plt.grid(which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>) plt.grid(which=<span class="hljs-string"><span class="hljs-string">'minor'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">':'</span></span>) plt.show()</code> </pre> <br><p><img src="https://habrastorage.org/webt/5z/il/br/5zilbr1ijigrduhc3pqpzn7qsuc.png"><br>  <em>Fig. 3.</em>  <em>Kurva bandwidth untuk berbagai skema transmisi.</em>  <em>Bandingkan dengan [1, hlm.</em>  <em>74].</em> </p><br><p>  Jadi kita lihat itu </p><br><ul><li>  kasus <strong>MIMO</strong> diharapkan lebih unggul dari yang lain, dan dengan meningkatnya <strong>SNR,</strong> kebutuhan akan pengetahuan tentang matriks saluran berkurang (lihat contoh dengan infinitas). </li><li>  <strong>SIMO lebih</strong> unggul daripada <strong>MISO</strong> jika pemancar tidak <em>tahu</em> salurannya (daya di MISO dibagi di semua antena, tetapi tidak secara optimal) dan bertepatan dengan <strong>MISO</strong> dalam kasus saluran yang <em>dikenal</em> . </li><li>  <strong>SISO</strong> diperkirakan akan menyerang. </li></ul><br><p>  Dan Yang Mulia memerintah atas <strong>pangkat matriks saluran</strong> , yang tidak memungkinkan kita untuk secara jelas membandingkan peningkatan jumlah antena dengan peningkatan kecepatan transmisi. </p><br><p>  Hal-hal seperti itu. </p><br><h2 id="literatura">  Sastra </h2><br><p>  (meskipun hanya ada satu buku, tetapi buku ini sangat bagus!) </p><br><ol><li>  Paulraj, Arogyaswami, Rohit Nabar, dan Dhananjay Gore. <br>  Pengantar komunikasi nirkabel ruang-waktu.  Cambridge University Press, 2003. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448570/">https://habr.com/ru/post/id448570/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448558/index.html">Apakah mungkin untuk membuat gambar yang realistis tanpa angka floating point?</a></li>
<li><a href="../id448560/index.html">Rencana transformasi AI: bagaimana mengelola perusahaan di era AI?</a></li>
<li><a href="../id448562/index.html">Google Membantu Polisi Menemukan Perangkat Dekat Tempat Tindak Pidana Menggunakan Data Lokasi</a></li>
<li><a href="../id448564/index.html">Yang pertama dalam kelompok - yang pertama jatuh: penilaian risiko kepemimpinan pada kelompok hewan yang diatur sendiri</a></li>
<li><a href="../id448568/index.html">Cara menerapkan ISO 27001: petunjuk penggunaan</a></li>
<li><a href="../id448572/index.html">Komunikasi manusia menjadi barang mewah</a></li>
<li><a href="../id448574/index.html">Satu tugas dari rutin SEO: solusi 3 langkah</a></li>
<li><a href="../id448576/index.html">Transistor Story Bagian 2: Dari Crucible of War</a></li>
<li><a href="../id448582/index.html">Membuat tip kalkulator di Kotlin: bagaimana cara kerjanya?</a></li>
<li><a href="../id448584/index.html">7 kesalahan umum saat menggunakan preposisi dalam bahasa Inggris dan cara menghindarinya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>