<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüíª ‚ÜñÔ∏è üë®‚Äçüë©‚Äçüëß Tercera prueba Qt 5 con PVS-Studio ü§µüèº üå≠ üôåüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De vez en cuando, nuestro equipo revisa los proyectos sobre los cuales ya hemos escrito art√≠culos. Otro de estos proyectos revisados ‚Äã‚Äãfue Qt. La √∫lti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tercera prueba Qt 5 con PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/426485/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd9/87d/907/dd987d90784865f850555bc198a97b81.png" alt="PVS-Studio y Qt"></div><br>  De vez en cuando, nuestro equipo revisa los proyectos sobre los cuales ya hemos escrito art√≠culos.  Otro de estos proyectos revisados ‚Äã‚Äãfue Qt.  La √∫ltima vez que lo probamos con PVS-Studio en 2014.  Desde 2014, el proyecto comenz√≥ a verificarse regularmente con la ayuda de Coverity.  Esto es interesante  Veamos si ahora podemos encontrar errores interesantes usando PVS-Studio. <br><a name="habracut"></a><br><h2>  Qt </h2><br>  Art√≠culos anteriores: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo reducir la probabilidad de errores en la etapa de redacci√≥n del c√≥digo</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> julio de 2011. </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Qt 5 framework check</a> ", abril de 2014. </li></ul><br>  Esta vez <a href="">se probaron</a> <a href="">Qt Base</a> (Core, Gui, Widgets, Network, ...) y <a href="">Qt5 super module</a> .  Acerca de Qt Creator, planeamos escribir un art√≠culo separado m√°s adelante.  Para la verificaci√≥n, utilizamos el analizador est√°tico PVS-Studio, una versi√≥n de prueba que puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descargar</a> del sitio. <br><br>  En mi opini√≥n subjetiva, el c√≥digo Qt ha mejorado.  Durante los a√±os transcurridos desde la √∫ltima prueba, han aparecido muchos diagn√≥sticos nuevos en el analizador PVS-Studio.  A pesar de esto, durante el estudio de revisi√≥n de las advertencias, no encontr√© tantos errores para un proyecto de este tama√±o.  Repito una vez m√°s que esta es mi impresi√≥n individual.  No hice ninguna investigaci√≥n especial sobre la densidad de errores ni entonces ni ahora. <br><br>  Lo m√°s probable es que las comprobaciones peri√≥dicas utilizando el analizador est√°tico Coverity probablemente hayan afectado la calidad del c√≥digo.  En 2014, con la ayuda de Coverity, el proyecto Qt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">qt-project</a> ) comenz√≥ a comprobarse, y en 2016, el Qt Creator ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">qt-creator</a> ).  Mi opini√≥n: si est√° desarrollando un proyecto abierto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Coverity Scan</a> puede ser una buena soluci√≥n gratuita que mejorar√° significativamente la calidad y la confiabilidad de sus proyectos. <br><br>  Sin embargo, como el lector puede adivinar, si no hubiera notado nada interesante en el informe de PVS-Studio, entonces no habr√≠a habido ning√∫n art√≠culo :).  Y como hay un art√≠culo, es decir, defectos.  Miremos a ellos.  En total, escrib√≠ 96 errores. <br><br><h2>  Copiar y pegar errores tipogr√°ficos </h2><br>  Comencemos con los cl√°sicos del g√©nero, cuando la causa del error es la falta de atenci√≥n.  Estos errores son subestimados por los programadores.  Para aquellos que a√∫n no han le√≠do, les recomiendo que miren estos dos art√≠culos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Efecto de la √∫ltima l√≠nea</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El mal vive en funciones de comparaci√≥n</a> </li></ul><br>  Estos errores son interlenguaje.  Por ejemplo, el segundo art√≠culo ofrece muchos ejemplos de errores en las funciones de comparaci√≥n escritas en C, C ++ y C #.  Ahora, al implementar el soporte de lenguaje Java en PVS-Studio, encontramos los mismos patrones de error.  Aqu√≠, por ejemplo, hay un error que encontramos recientemente en la biblioteca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hibernate</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other instanceof Id) { Id that = (Id) other; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Si observa de cerca, resulta que el campo de compraSecuencia se compara con √©l mismo.  La opci√≥n correcta: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> that.purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber;</code> </pre> <br>  En general, todo es como siempre, y el analizador PVS-Studio tendr√° que "rastrillar los establos de Augean" en proyectos Java.  Por cierto, invitamos a todos a participar en la prueba de la versi√≥n Beta de PVS-Studio para Java, que aparecer√° en un futuro pr√≥ximo.  Para hacer esto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escr√≠banos</a> (seleccione "Quiero el analizador para Java"). <br><br>  Ahora volvamos a los errores en el proyecto Qt. <br><br>  <b>Defecto N1</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">windowDpiAwareness</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hwnd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QWindowsContext::user32dll.getWindowDpiAwarenessContext &amp;&amp; QWindowsContext::user32dll.getWindowDpiAwarenessContext ? QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext( QWindowsContext::user32dll.getWindowDpiAwarenessContext(hwnd)) : <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  Advertencia de PVS-Studio: V501 CWE-571 Hay subexpresiones id√©nticas 'QWindowsContext :: user32dll.getWindowDpiAwarenessContext' a la izquierda y a la derecha del operador '&amp;&amp;'.  qwindowscontext.cpp 150 <br><br>  Aqu√≠ no se requiere ninguna explicaci√≥n especial adem√°s del mensaje del analizador.  Me parece que la expresi√≥n deber√≠a haber sido as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext &amp;&amp; QWindowsContext::user32dll.getWindowDpiAwarenessContext ? QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext( QWindowsContext::user32dll.getWindowDpiAwarenessContext(hwnd)) : <span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre> <br>  <b>Defecto N2, N3</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QReadWriteLockPrivate::release() { Q_ASSERT(!recursive); Q_ASSERT(!waitingReaders &amp;&amp; !waitingReaders &amp;&amp; !readerCount &amp;&amp; !writerCount); freelist-&gt;release(id); }</code> </pre> <br>  Advertencia de PVS-Studio: V501 CWE-571 Hay subexpresiones id√©nticas a la izquierda y a la derecha del operador '&amp;&amp;' :! WaitingReaders &amp;&amp;! WaitingReaders qreadwritelock.cpp 632 <br><br>  El error est√° dentro de la <i>condici√≥n de</i> macro <i>Q_ASSERT</i> , por lo que no es significativo.  Pero a√∫n as√≠, esto es un error.  La variable <i>waitingReaders</i> se verifica dos <i>veces</i> .  Y aparentemente se olvidaron de verificar alguna otra variable. <br><br>  Se encuentra un error id√©ntico en la l√≠nea 625 del archivo qreadwritelock.cpp.  ¬°Viva Copy-Paste!  :) <br><br>  <b>Defecto N4</b> <br><br><pre> <code class="cpp hljs">QString QGraphicsSceneBspTree::debug(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == Node::Horizontal) { tmp += debug(firstChildIndex(index)); tmp += debug(firstChildIndex(index) + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tmp += debug(firstChildIndex(index)); tmp += debug(firstChildIndex(index) + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Advertencia de PVS-Studio: V523 CWE-691 La declaraci√≥n 'then' es equivalente a la declaraci√≥n 'else'.  qgraphicsscene_bsp.cpp 179 <br><br>  Lo m√°s probable es que se haya copiado el bloque de texto, pero se olvidaron de corregirlo. <br><br>  <b>Defecto N5</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> FillRule { OddEvenFill, WindingFill }; QDataStream &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;&gt;(QDataStream &amp;s, QPainterPath &amp;p) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fillRule; s &gt;&gt; fillRule; Q_ASSERT(fillRule == Qt::OddEvenFill || Qt::WindingFill); .... }</code> </pre> <br>  Advertencia de PVS-Studio: V768 CWE-571 La constante de enumeraci√≥n 'WindingFill' se usa como una variable de tipo booleano.  qpainterpath.cpp 2479 <br><br>  De acuerdo, esta es una hermosa blooper!  <i>Q_ASSERT</i> no verifica nada, ya que la condici√≥n siempre es verdadera.  La condici√≥n es verdadera porque la constante nombrada <i>Qt :: WindingFill</i> es 1. <br><br>  <b>Defecto N6</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QVariant::canConvert(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetTypeId) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == QMetaType::SChar || currentType == QMetaType::Char) currentType = QMetaType::UInt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetTypeId == QMetaType::SChar || currentType == QMetaType::Char) targetTypeId = QMetaType::UInt; .... }</code> </pre> <br>  Antes de leer la advertencia, intente detectar un error tipogr√°fico usted mismo.  Al agregar una imagen, te ayudar√© a no leer el mensaje del analizador de inmediato :). <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86f/f1d/7c5/86ff1d7c55cdc0fb71cbce45f2f84f05.png" alt="Hora de pensar"></div><br><br>  Advertencia de PVS-Studio: V560 CWE-570 Una parte de la expresi√≥n condicional siempre es falsa: currentType == QMetaType :: Char.  qvariant.cpp 3529 <br><br>  La condici√≥n "currentType == QMetaType :: Char" se verifica en el primer <i>if</i> .  Si se cumple la condici√≥n, a la variable <i>currentType se le</i> asigna el valor <i>QMetaType :: UInt</i> .  Por lo tanto, la variable <i>currentType</i> ya no puede ser igual a <i>QMetaType :: Char</i> .  Por lo tanto, el analizador informa que en el segundo <i>if, la</i> subexpresi√≥n "currentType == QMetaType :: Char" siempre es falsa. <br><br>  De hecho, el segundo <i>si</i> deber√≠a ser as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetTypeId == QMetaType::SChar || targetTypeId == QMetaType::Char) targetTypeId = QMetaType::UInt;</code> </pre> <br><br>  <b>Nota de diagn√≥stico de V560</b> <br><br>  El informe encontr√≥ muchas advertencias V560.  Sin embargo, ya no los mir√© tan pronto como encontr√© un caso interesante para el art√≠culo, que se consider√≥ anteriormente como un defecto N6. <br><br>  La gran mayor√≠a de los mensajes V560 no se pueden llamar falsos, pero no sirven de nada.  En otras palabras, describirlos en un art√≠culo no es interesante.  Para aclarar lo que quiero decir exactamente, considere uno de esos casos. <br><br><pre> <code class="cpp hljs">QString QTextHtmlExporter::findUrlForImage(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QTextDocument *doc, ....) { QString url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!doc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (QTextDocument *parent = qobject_cast&lt;QTextDocument *&gt;(doc-&gt;parent())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findUrlForImage(parent, cacheKey, isPixmap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc &amp;&amp; doc-&gt;docHandle()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Advertencia PVS-Stuidio: V560 CWE-571 Una parte de la expresi√≥n condicional siempre es cierta: doc.  qtextdocument.cpp 2992 <br><br>  El analizador tiene toda la raz√≥n de que el puntero <i>doc</i> no siempre es <i>nullptr</i> cuando se vuelve a comprobar.  Pero esto no es un error, solo el programador estaba a salvo.  Puede simplificar el c√≥digo escribiendo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc-&gt;docHandle()) {</code> </pre> <br>  <b>Defecto N7</b> <br><br>  Y el √∫ltimo caso, que se puede clasificar como un error tipogr√°fico.  El error ocurre debido a la confusi√≥n en los nombres de las constantes, que difieren solo en el caso de la primera letra. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QWindowsCursor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QPlatformCursor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CursorState { CursorShowing, CursorHidden, CursorSuppressed }; .... } QWindowsCursor::CursorState QWindowsCursor::cursorState() { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { cursorShowing = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, cursorSuppressed = <span class="hljs-number"><span class="hljs-number">0x2</span></span> }; CURSORINFO cursorInfo; cursorInfo.cbSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(CURSORINFO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetCursorInfo(&amp;cursorInfo)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cursorInfo.flags &amp; CursorShowing) .... }</code> </pre> <br>  Advertencia de PVS-Studio: V616 CWE-480 La constante con nombre 'CursorShowing' con el valor de 0 se utiliza en la operaci√≥n bit a bit.  qwindowscursor.cpp 669 <br><br>  Con m√°s detalle, ya analic√© este error en una peque√±a nota separada: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una vez m√°s, el analizador PVS-Studio result√≥ ser m√°s atento</a> que una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">persona</a> ". <br><br><h2>  Fallas de seguridad </h2><br>  De hecho, todos los errores que se analizan en este art√≠culo pueden denominarse defectos de seguridad.  Todos ellos se clasifican seg√∫n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la enumeraci√≥n de debilidad com√∫n</a> (ver ID de CWE en los mensajes del analizador).  Si los errores se clasifican como CWE, son potencialmente un riesgo de seguridad.  Esto se explica con m√°s detalle en la p√°gina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio SAST</a> . <br><br>  Sin embargo, me gustar√≠a se√±alar una serie de errores en un grupo separado.  Echemos un vistazo a ellos. <br><br>  <b>Defecto N8, N9</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QLocalServerPrivate::addListener() { .... SetSecurityDescriptorOwner(pSD.data(), pTokenUser-&gt;User.Sid, FALSE); SetSecurityDescriptorGroup(pSD.data(), pTokenGroup-&gt;PrimaryGroup, FALSE); .... }</code> </pre> <br>  Advertencias de PVS-Studio: <br><br><ul><li>  V530 CWE-252 Se requiere el valor de retorno de la funci√≥n 'SetSecurityDescriptorOwner'.  qlocalserver_win.cpp 167 </li><li>  V530 CWE-252 Para poder utilizar el valor de retorno de la funci√≥n 'SetSecurityDescriptorGroup'.  qlocalserver_win.cpp 168 </li></ul><br>  Hay varias funciones relacionadas con el control de acceso.  Las funciones <i>SetSecurityDescriptorOwner</i> y <i>SetSecurityDescriptorGroup se</i> encuentran entre ellas. <br><br>  Con tales funciones, debe trabajar con mucho cuidado.  Por ejemplo, debe verificar el estado que devuelven.  ¬øQu√© sucede si falla la llamada a estas funciones?  No es necesario adivinar, es necesario escribir c√≥digo para manejar este caso. <br><br>  No es necesario aprovechar la falta de verificaci√≥n y convertir dichos errores en vulnerabilidades.  Sin embargo, este no es en ning√∫n caso un lugar de riesgo, y debe escribir un c√≥digo m√°s seguro. <br><br>  <b>Defecto N10</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QLocalServerPrivate::addListener() { .... InitializeAcl(acl, aclSize, ACL_REVISION_DS); .... }</code> </pre> <br>  Advertencia de PVS-Studio: V530 CWE-252 Para poder utilizar el valor de retorno de la funci√≥n 'InitializeAcl'.  qlocalserver_win.cpp 144 <br><br>  La situaci√≥n es similar a la discutida anteriormente. <br><br>  <b>Defecto N11, N12</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: V597 CWE-14 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'chunkBuffer'.  La funci√≥n RtlSecureZeroMemory () debe usarse para borrar los datos privados.  sha1.cpp 189 <br><br>  El compilador eliminar√° la <i>llamada a la</i> funci√≥n <i>memset</i> .  Ya muchas veces en art√≠culos analic√© esta situaci√≥n.  No tengo ganas de repetirme.  Me refiero al art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Limpieza segura de datos privados</a> ". <br><br>  Y otro error est√° en el mismo archivo sha1.cpp, en la l√≠nea 247. <br><br><h2>  Punteros nulos </h2><br>  Es hora de hablar sobre punteros.  Hubo muchos errores en este tema. <br><br>  <b>Defecto N13</b> <br><br><pre> <code class="cpp hljs">QByteArray &amp;QByteArray::append(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) len = qstrlen(str); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str &amp;&amp; len) { .... }</code> </pre> <br>  Advertencia de PVS-Studio: V595 CWE-476 El puntero 'str' se utiliz√≥ antes de verificarlo con nullptr.  L√≠neas de verificaci√≥n: 2118, 2119. qbytearray.cpp 2118 <br><br>  La situaci√≥n cl√°sica es cuando se usa un puntero al principio y luego se verifica la igualdad <i>nula</i> .  Este es un patr√≥n de error muy com√∫n, y lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vemos</a> regularmente en casi todos los proyectos. <br><br>  <b>Defecto N14, N15</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> QMetaObjectPrivate *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">priv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QMetaObjectPrivate*&gt;(data); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QMetaEnum::isFlag() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = priv(mobj-&gt;d.data)-&gt;revision &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mobj &amp;&amp; mobj-&gt;d.data[handle + offset] &amp; EnumIsFlag; }</code> </pre> <br>  Advertencia de PVS-Studio: V595 CWE-476 El puntero 'mobj' se utiliz√≥ antes de que se verificara contra nullptr.  L√≠neas de verificaci√≥n: 2671, 2672. qmetaobject.cpp 2671 <br><br>  Por si acaso, traigo el cuerpo de la funci√≥n <i>priv</i> .  Por alguna raz√≥n, a veces los lectores comienzan a pensar en situaciones en las que el c√≥digo funcionar√°.  No entiendo de d√≥nde viene esta desconfianza y el deseo de ver una caracter√≠stica enga√±osa por error :).  Por ejemplo, alguien puede sugerir en los comentarios que <i>priv</i> es una macro de la forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> priv(A) foo(sizeof(A))</span></span></code> </pre> <br>  Entonces todo funcionar√°. <br><br>  Para evitar tales discusiones, trato de citar fragmentos de c√≥digo donde se proporciona toda la informaci√≥n que confirma la existencia de un error. <br><br>  Entonces, el puntero <i>modj se</i> desreferencia y luego se verifica. <br><br>  M√°s adelante en la escena llega el "poderoso y terrible" Copy-Paste.  Debido a que se detecta exactamente el mismo error en la funci√≥n <i>isScoped</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QMetaEnum::isScoped() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = priv(mobj-&gt;d.data)-&gt;revision &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mobj &amp;&amp; mobj-&gt;d.data[handle + offset] &amp; EnumIsScoped; }</code> </pre> <br>  Advertencia de PVS-Studio: V595 CWE-476 El puntero 'mobj' se utiliz√≥ antes de que se verificara contra nullptr.  L√≠neas de verificaci√≥n: 2683, 2684. qmetaobject.cpp 2683 <br><br>  <b>Defecto N16-N21</b> <br><br>  Considere otro ejemplo y, creo, suficiente. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QTextCursor::insertFragment(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QTextDocumentFragment &amp;fragment) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!d || !d-&gt;priv || fragment.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; d-&gt;priv-&gt;beginEditBlock(); d-&gt;remove(); fragment.d-&gt;insert(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); d-&gt;priv-&gt;endEditBlock(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fragment.d &amp;&amp; fragment.d-&gt;doc) d-&gt;priv-&gt;mergeCachedResources(fragment.d-&gt;doc-&gt;docHandle()); }</code> </pre> <br>  Advertencia de PVS-Studio: V595 CWE-476 El puntero 'fragment.d' se utiliz√≥ antes de verificarlo con nullptr.  L√≠neas de verificaci√≥n: 2238, 2241. qtextcursor.cpp 2238 <br><br>  De todos modos  Preste atenci√≥n a la secuencia de trabajo con el puntero almacenado en el <i>fragmento</i> variable.d. <br><br>  Otros errores de este tipo: <br><br><ul><li>  V595 CWE-476 El puntero 'ventana' se utiliz√≥ antes de que se verificara contra nullptr.  L√≠neas de verificaci√≥n: 1846, 1848. qapplication.cpp 1846 </li><li>  V595 CWE-476 El puntero 'ventana' se utiliz√≥ antes de que se verificara contra nullptr.  L√≠neas de verificaci√≥n: 1858, 1860. qapplication.cpp 1858 </li><li>  V595 CWE-476 El puntero de 'respuesta' se utiliz√≥ antes de verificarlo con nullptr.  Verifique las l√≠neas: 492, 502. qhttpnetworkconnectionchannel.cpp 492 </li><li>  V595 CWE-476 El puntero 'newHandle' se utiliz√≥ antes de que se verificara contra nullptr.  L√≠neas de verificaci√≥n: 877, 883. qsplitter.cpp 877 </li><li>  V595 CWE-476 El puntero 'widget' se utiliz√≥ antes de que se verificara contra nullptr.  L√≠neas de verificaci√≥n: 2320, 2322. qwindowsvistastyle.cpp 2320 </li><li>  De hecho, hay m√°s errores.  R√°pidamente me cans√© de aprender las advertencias V595, y para el art√≠culo ya escrib√≠ suficientes fragmentos de c√≥digo. </li></ul><br>  <b>Defecto N22-N33</b> <br><br>  Hay un c√≥digo en el que se comprueba un puntero que devuelve el <i>nuevo</i> operador.  Esto es especialmente divertido en medio del hecho de que hay muchos lugares donde no se verifica el resultado de la funci√≥n <i>malloc</i> (consulte el siguiente grupo de errores). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QTranslatorPrivate::do_load(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;realname, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;directory) { .... d-&gt;unmapPointer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[d-&gt;unmapLength]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d-&gt;unmapPointer) { file.seek(<span class="hljs-number"><span class="hljs-number">0</span></span>); qint64 readResult = file.read(d-&gt;unmapPointer, d-&gt;unmapLength); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readResult == qint64(unmapLength)) ok = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  Advertencia de PVS-Studio: V668 CWE-571 No tiene sentido probar el puntero 'd-&gt; unmap Pointer' contra nulo, ya que la memoria se asign√≥ utilizando el operador 'nuevo'.  La excepci√≥n se generar√° en caso de error de asignaci√≥n de memoria.  qtranslator.cpp 596 <br><br>  Comprobar el puntero no tiene sentido, porque en caso de un error de asignaci√≥n de memoria, se <i>lanzar√°</i> una excepci√≥n <i>std :: bad_alloc</i> .  Si desea que el <i>nuevo</i> operador devuelva <i>nullptr</i> cuando no hay suficiente memoria, debe escribir: <br><br><pre> <code class="cpp hljs">d-&gt;unmapPointer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nothrow) <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[d-&gt;unmapLength];</code> </pre> <br>  El analizador conoce este uso del <i>nuevo</i> operador y no dar√≠a una advertencia en este caso. <br><br>  Otros errores: les dar√© el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivo qt-V668.txt</a> . <br><br>  <b>Defecto N34-N70</b> <br><br>  Como se prometi√≥, ahora es el turno de los errores cuando no verifican el resultado de llamar a las funciones <i>malloc</i> , <i>calloc</i> , <i>strdup</i> , etc.  Estos errores son m√°s graves de lo que parece a primera vista.  M√°s detalles: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øPor qu√© es importante verificar qu√© devolvi√≥ la funci√≥n malloc</a> ?" <br><br><pre> <code class="cpp hljs">SourceFiles::SourceFiles() { nodes = (SourceFileNode**)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SourceFileNode*)*(num_nodes=<span class="hljs-number"><span class="hljs-number">3037</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; num_nodes; n++) nodes[n] = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre> <br>  Advertencia de PVS-Studio: V522 CWE-690 Puede haber una desreferenciaci√≥n de un potencial 'nodo' de puntero nulo.  L√≠neas de verificaci√≥n: 138, 136. makefiledeps.cpp 138 <br><br>  El puntero se usa sin verificaci√≥n previa. <br><br>  Todos estos errores son del mismo tipo, por lo que no me detendr√© en ellos con m√°s detalle.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dar√©</a> el resto de la lista de advertencia: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">qt-V522-V575.txt</a> . <br><br><h2>  Errores l√≥gicos en las condiciones. </h2><br>  <b>Defecto N71</b> <br><br><pre> <code class="cpp hljs">QString QEdidParser::parseEdidString(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quint8 *data) { <span class="hljs-function"><span class="hljs-function">QByteArray </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">reinterpret_cast</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *&gt;(data), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">13</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Erase carriage return and line feed buffer = buffer.replace('\r', '\0').replace('\n', '\0'); // Replace non-printable characters with dash for (int i = 0; i &lt; buffer.count(); ++i) { if (buffer[i] &lt; '\040' &amp;&amp; buffer[i] &gt; '\176') buffer[i] = '-'; } return QString::fromLatin1(buffer.trimmed()); }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: V547 CWE-570 Expresi√≥n 'buffer [i] &lt;' \ 040 '&amp;&amp; buffer [i]&gt;' \ 176 '' siempre es falso.  qedidparser.cpp 169 <br><br>  La funci√≥n debe realizar la siguiente acci√≥n "Reemplazar caracteres no imprimibles con gui√≥n".  Sin embargo, ella no.  Echemos un vistazo m√°s de cerca a esta condici√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i] &lt; <span class="hljs-string"><span class="hljs-string">'\040'</span></span> &amp;&amp; buffer[i] &gt; <span class="hljs-string"><span class="hljs-string">'\176'</span></span>)</code> </pre> <br>  No tiene sentido  Un car√°cter no puede ser menor que '\ 040' y mayor que '\ 176' al mismo tiempo.  En esta condici√≥n, debe usar el operador '||'.  El c√≥digo correcto es: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i] &lt; <span class="hljs-string"><span class="hljs-string">'\040'</span></span> || buffer[i] &gt; <span class="hljs-string"><span class="hljs-string">'\176'</span></span>)</code> </pre> <br>  <b>Defecto N72</b> <br><br>  Un error similar, debido a que los usuarios de Windows no tienen suerte. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(Q_OS_WIN) static QString driveSpec(const QString &amp;path) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (path.size() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 2) return QString(); char c = path.at(0).toLatin1(); if (c &lt; 'a' &amp;&amp; c &gt; 'z' &amp;&amp; c &lt; 'A' &amp;&amp; c &gt; 'Z') return QString(); if (path.at(1).toLatin1() != ':') return QString(); return path.mid(0, 2); } #endif</span></span></span></span></code> </pre> <br>  El analizador genera dos advertencias a la vez: <br><br><ul><li>  V590 CWE-571 Considere inspeccionar la expresi√≥n 'c &lt;' a '&amp;&amp; c&gt;' z '&amp;&amp; c &lt;' A '&amp;&amp; c&gt;' Z ''.  La expresi√≥n es excesiva o contiene un error de imprenta.  qdir.cpp 77 </li><li>  V560 CWE-570 Una parte de la expresi√≥n condicional siempre es falsa: c&gt; 'z'.  qdir.cpp 77 </li></ul><br>  Un error l√≥gico est√° en la condici√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &gt; <span class="hljs-string"><span class="hljs-string">'z'</span></span> &amp;&amp; c &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span> &amp;&amp; c &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>)</code> </pre> <br>  Seg√∫n tengo entendido, el programador quer√≠a encontrar un personaje que no sea una letra del alfabeto latino.  En este caso, la condici√≥n deber√≠a ser as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((c &lt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> || c &gt; <span class="hljs-string"><span class="hljs-string">'z'</span></span>) &amp;&amp; (c &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span> || c &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>))</code> </pre> <br>  <b>Defecto N73</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SelectionMode { NoSelection, SingleSelection, MultiSelection, ExtendedSelection, ContiguousSelection }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QAccessibleTableCell::unselectCell() { QAbstractItemView::SelectionMode selectionMode = view-&gt;selectionMode(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_index.isValid() || (selectionMode &amp; QAbstractItemView::NoSelection)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  Advertencia de PVS-Studio: V616 CWE-480 La constante denominada 'QAbstractItemView :: NoSelection' con el valor de 0 se utiliza en la operaci√≥n bit a bit.  itemviews.cpp 976 <br><br>  La constante nombrada <i>QAbstractItemView :: NoSelection</i> es cero.  Por lo tanto, la subexpresi√≥n <i>(selectionMode &amp; QAbstractItemView :: NoSelection)</i> no tiene sentido.  Siempre ser√° 0. <br><br>  Creo que deber√≠a escribirse aqu√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_index.isValid() || (selectionMode == QAbstractItemView::NoSelection))</code> </pre> <br>  <b>Defecto N74</b> <br><br>  El siguiente c√≥digo es dif√≠cil de entender para m√≠.  Est√° equivocado, pero no s√© qu√© deber√≠a ser.  Comentar una funci√≥n tampoco me ayuda. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Re-engineered from the inline function _com_error::ErrorMessage(). // We cannot use it directly since it uses swprintf_s(), which is not // present in the MSVCRT.DLL found on Windows XP (QTBUG-35617). static inline QString errorMessageFromComError(const _com_error &amp;comError) { TCHAR *message = nullptr; FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, DWORD(comError.Error()), MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT), message, 0, NULL); if (message) { const QString result = QString::fromWCharArray(message).trimmed(); LocalFree(static_cast&lt;HLOCAL&gt;(message)); return result; } if (const WORD wCode = comError.WCode()) return QString::asprintf("IDispatch error #%u", uint(wCode)); return QString::asprintf("Unknown error 0x0%x", uint(comError.Error())); }</span></span></code> </pre> <br>  Advertencia de PVS-Studio: V547 CWE-570 La expresi√≥n 'mensaje' siempre es falsa.  qwindowscontext.cpp 802 <br><br>  El programador probablemente asume que la funci√≥n <i>FormatMessage</i> cambiar√° el valor del puntero del <i>mensaje</i> .  Pero esto no es as√≠.  La <i>funci√≥n FormatMessage</i> no puede cambiar el valor de un puntero, ya que se pasa a la funci√≥n por valor.  Aqu√≠ hay un prototipo de esta funci√≥n: <br><br><pre> <code class="cpp hljs">DWORD __<span class="hljs-function"><span class="hljs-function">stdcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormatMessageW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments )</span></span></span></span>;</code> </pre> <br><br><h2>  Posibles fugas de memoria </h2><br>  <b>Defecto N75-N92</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SourceDependChildren</span></span></span><span class="hljs-class"> {</span></span> SourceFile **children; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num_nodes, used_nodes; SourceDependChildren() : children(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), num_nodes(<span class="hljs-number"><span class="hljs-number">0</span></span>), used_nodes(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } ~SourceDependChildren() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children) <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(children); children = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SourceFile *s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num_nodes &lt;= used_nodes) { num_nodes += <span class="hljs-number"><span class="hljs-number">200</span></span>; children = (SourceFile**)<span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(children, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SourceFile*)*(num_nodes)); } children[used_nodes++] = s; } };</code> </pre> <br>  Advertencia de PVS-Studio: V701 CWE-401 realloc () posible fuga: cuando realloc () falla al asignar memoria, se pierde el puntero original 'hijos'.  Considere asignar realloc () a un puntero temporal.  makefiledeps.cpp 103 <br><br>  La expansi√≥n de la memoria intermedia se implementa de manera peligrosa.  Si la funci√≥n <i>realloc</i> no puede asignar memoria, devolver√° <i>NULL</i> .  Este <i>NULL</i> se colocar√° inmediatamente en la variable secundaria y no habr√° posibilidad de liberar de alguna manera el b√∫fer asignado anteriormente.  Se producir√° una p√©rdida de memoria. <br><br>  Errores similares: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">qt-701.txt</a> . <br><br><h2>  Miscel√°neo </h2><br>  <b>Defecto N93</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GradientBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlendType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlendType</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QT_FASTCALL</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">qt_fetch_linear_gradient_template</span></span></span><span class="hljs-class">(....) {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t+inc*length &lt; qreal(INT_MAX &gt;&gt; (FIXPT_BITS + <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp;&amp; t+inc*length &gt; qreal(INT_MIN &gt;&gt; (FIXPT_BITS + <span class="hljs-number"><span class="hljs-number">1</span></span>))) { .... }</code> </pre> <br>  Advertencia de PVS-Studio: V610 CWE-758 Comportamiento no especificado.  Verifique el operador de turno '&gt;&gt;'.  El operando izquierdo '(- 2147483647 - 1)' es negativo.  qdrawhelper.cpp 4015 <br><br>  El valor negativo de <i>INT_MIN</i> no se puede desplazar.  Este es un comportamiento no especificado, y no puede confiar en el resultado de dicha operaci√≥n.  Los bits m√°s significativos pueden ser iguales a 0 o 1. <br><br>  <b>Defecto N94</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QObjectPrivate::addConnection(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signal, Connection *c) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &gt;= connectionLists-&gt;count()) connectionLists-&gt;resize(signal + <span class="hljs-number"><span class="hljs-number">1</span></span>); ConnectionList &amp;connectionList = (*connectionLists)[signal]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... }</code> </pre> <br>  Advertencia de PVS-Studio: V781 CWE-129 El valor de la variable 'se√±al' se verifica despu√©s de su uso.  Quiz√°s haya un error en la l√≥gica del programa.  Verifique las l√≠neas: 397, 413. qobject.cpp 397 <br><br>  Una comprobaci√≥n <i>(se√±al &lt;0)</i> indica que el valor del argumento de la <i>se√±al</i> puede ser negativo.  Sin embargo, este argumento se utiliz√≥ anteriormente para indexar la matriz.  Resulta que la verificaci√≥n se realiza demasiado tarde.  El programa ya estar√° interrumpido. <br><br>  <b>Defecto N95</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QXmlStreamWriterPrivate::finishStartElement(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> contents) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inEmptyElement) { write(<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>); QXmlStreamWriterPrivate::Tag &amp;tag = tagStack_pop(); lastNamespaceDeclaration = tag.namespaceDeclarationsSize; lastWasStartElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { write(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>); } inStartElement = inEmptyElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; lastNamespaceDeclaration = namespaceDeclarations.size(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hadSomethingWritten; }</code> </pre> <br>  Advertencia de PVS-Studio: V519 CWE-563 La variable 'lastNamespaceDeclaration' recibe valores asignados dos veces sucesivamente.  Quiz√°s esto sea un error.  Verifique las l√≠neas: 3188, 3194. qxmlstream.cpp 3194 <br><br>  Destacar√© la esencia del error: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inEmptyElement) { lastNamespaceDeclaration = tag.namespaceDeclarationsSize; } lastNamespaceDeclaration = namespaceDeclarations.size();</code> </pre> <br>  <b>Defecto N96</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QRollEffect::scroll() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentHeight != totalHeight) { currentHeight = totalHeight * (elapsed/duration) + (<span class="hljs-number"><span class="hljs-number">2</span></span> * totalHeight * (elapsed%duration) + duration) / (<span class="hljs-number"><span class="hljs-number">2</span></span> * duration); <span class="hljs-comment"><span class="hljs-comment">// equiv. to int((totalHeight*elapsed) / duration + 0.5) done = (currentHeight &gt;= totalHeight); } done = (currentHeight &gt;= totalHeight) &amp;&amp; (currentWidth &gt;= totalWidth); .... }</span></span></code> </pre> <br>  V519 CWE-563 A la variable 'hecho' se le asignan valores dos veces sucesivas.  Quiz√°s esto sea un error.  Verifique las l√≠neas: 509, 511. qeffects.cpp 511 <br><br>  Todo es igual que en el caso anterior.  Tenga en cuenta la variable <i>hecha</i> . <br><br><h2>  Conclusi√≥n </h2><br>  Incluso mirando el informe superficialmente, escrib√≠ casi 100 errores.  Estoy satisfecho con los resultados de PVS-Studio. <br><br>  Por supuesto, tales comprobaciones de c√≥digos raros no tienen nada que ver con mejorar la calidad y la confiabilidad del c√≥digo.  Solo demuestran las capacidades del analizador de c√≥digo.  Las herramientas de an√°lisis est√°tico deben aplicarse regularmente.  En este caso, reducen el costo de corregir errores y protegen las aplicaciones de muchas vulnerabilidades potenciales. <br><br>  Gracias por su atencion  Para mantenerse al tanto de nuestras nuevas publicaciones, lo invito a suscribirse a uno de nuestros canales: <ol><li>  VK.com: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pvsstudio_rus</a> </li><li>  RSS "Vieja escuela": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">viva64-blog-ru</a> </li><li>  Twitter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@pvsstudio_rus</a> </li><li>  Instagram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@pvsstudio_rus</a> </li><li>  Telegrama: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@pvsstudio_rus</a> </li></ol><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Si desea compartir este art√≠culo con una audiencia de habla inglesa, utilice el enlace a la traducci√≥n: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una tercera comprobaci√≥n de Qt 5 con PVS-Studio</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426485/">https://habr.com/ru/post/es426485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426475/index.html">Miya - asistente desde el tel√©fono inteligente</a></li>
<li><a href="../es426477/index.html">Toda la verdad sobre RTOS. Art√≠culo # 15. Particiones de memoria: servicios y estructuras de datos</a></li>
<li><a href="../es426479/index.html">Banco de pruebas casero para placas base</a></li>
<li><a href="../es426481/index.html">Mapas de hex√°gono en Unity: Path Finder, escuadrones de jugadores, animaciones</a></li>
<li><a href="../es426483/index.html">Uno que supera a Tesla. Para m√°s rentable</a></li>
<li><a href="../es426487/index.html">Prueba de automatizaci√≥n desde cero. Parte 1</a></li>
<li><a href="../es426489/index.html">Sobre la relaci√≥n de n√∫meros primos e irracionales</a></li>
<li><a href="../es426491/index.html">Semana de la seguridad 39: a la muerte de Google+</a></li>
<li><a href="../es426493/index.html">Descuentos constantes de los anfitriones para VPS y VPS. Hoy Buscar visitantes</a></li>
<li><a href="../es426495/index.html">Dise√±ador en solitario. C√≥mo construir una carrera cuando trabajas solo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>