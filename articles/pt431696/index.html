<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‡ğŸ¾ ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¾ ğŸ‘ˆğŸ½ Kodein. O bÃ¡sico ğŸ‘¨ğŸ¾â€âš–ï¸ ğŸ•” ğŸˆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="NÃ£o encontrei guias compreensÃ­veis para quem Kodein pela primeira vez e a documentaÃ§Ã£o nÃ£o Ã© transparente e consistente em todos os lugares. Por isso,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kodein. O bÃ¡sico</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431696/"> NÃ£o encontrei guias compreensÃ­veis para quem <code>Kodein</code> pela primeira vez e a documentaÃ§Ã£o nÃ£o Ã© transparente e consistente em todos os lugares. Por isso, quero compartilhar os principais recursos da biblioteca com vocÃª.  Alguns recursos da biblioteca serÃ£o lanÃ§ados, mas essa Ã© basicamente a parte avanÃ§ada.  Aqui vocÃª encontrarÃ¡ tudo para iniciar normalmente e comeÃ§ar a implementar dependÃªncias com o <code>Kodein</code> enquanto lÃª o artigo.  O artigo Ã© baseado no <code>Kodein 5.3.0</code> , pois o <code>Kodein 6.0.0</code> requer a <code>Support Library 28</code> ou o <code>AndroidX</code> e de maneira alguma todos irÃ£o mudar para eles, pois muitas bibliotecas de terceiros ainda nÃ£o oferecem versÃµes compatÃ­veis. <br><img src="https://habrastorage.org/webt/uj/ve/am/ujveamkhrxko4wle8mcfugfzjvc.png"><br><a name="habracut"></a><br>  <code>Kodein</code> Ã© uma biblioteca para implementar injeÃ§Ã£o de dependÃªncia (DI).  Se vocÃª nÃ£o conhece esse conceito, leia o inÃ­cio do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo sobre Dagger2</a> , onde o autor explica brevemente os aspectos teÃ³ricos da DI. <br><br>  Neste artigo, consideraremos tudo no exemplo do Android, mas, de acordo com os desenvolvedores, o Kodein se comporta da mesma maneira em todas as plataformas suportadas pelo Kotlin (JVM, Android, JS, Nativo). <br><br><h3>  InstalaÃ§Ã£o </h3><br>  Devido ao fato de Java ter <code>type erasure</code> , surge um problema - o compilador apaga o tipo genÃ©rico.  No nÃ­vel do bytecode, <code>List&lt;String&gt;</code> e <code>List&lt;Date&gt;</code> sÃ£o apenas <code>List</code> .  Ainda existe uma maneira de obter informaÃ§Ãµes sobre tipos genÃ©ricos, mas custarÃ¡ muito e funcionarÃ¡ apenas na JVM e Android.  Nesse sentido, os desenvolvedores do <code>Kodein</code> sugerem o uso de uma das duas dependÃªncias: uma recebe informaÃ§Ãµes sobre tipos generalizados ( <code>kodein-generic</code> ) enquanto trabalha e o outro nÃ£o ( <code>kodein-erased</code> ).  Por exemplo, ao usar <code>kodein-erased</code> <code>List&lt;String&gt;</code> <code>kodein-erased</code> por <code>kodein-erased</code> <code>List&lt;String&gt;</code> e a <code>List&lt;Date</code> &gt; serÃ£o salvas como <code>List&lt;*&gt;</code> e, ao usar o <code>kodein-generic</code> tudo serÃ¡ salvo junto com o tipo especificado, ou seja, como <code>List&lt;String&gt;</code> e <code>List&lt;Date&gt;</code> respectivamente. <br><br>  Como escolher? <br><br>  Escreva <b>nÃ£o</b> na JVM - use <code>kodein-erased</code> , caso contrÃ¡rio, Ã© impossÃ­vel. <br>  Escreva na JVM e o problema de desempenho Ã© muito importante para vocÃª - vocÃª pode usar o <code>kodein-erased</code> , mas tenha cuidado, pois essa experiÃªncia pode ser inesperada no mau sentido dessas palavras.  Se vocÃª estiver criando um aplicativo regular sem nenhum requisito especial de desempenho, use <code>kodein-generic</code> . <br><br>  Por fim, se vocÃª pensar no impacto da DI no desempenho, na maioria das vezes a maioria das dependÃªncias Ã© criada uma vez ou as dependÃªncias sÃ£o criadas para reutilizaÃ§Ã£o repetida, Ã© improvÃ¡vel que, com essas aÃ§Ãµes, vocÃª possa afetar significativamente o desempenho do seu aplicativo. <br><br>  EntÃ£o, instale: <br><br>  Primeiro - no build.gradle entre os repositÃ³rios deve estar o jcenter (), se nÃ£o estiver lÃ¡ - adicione. <br><br><pre> <code class="plaintext hljs">buildscript { repositories { jcenter() } }</code> </pre><br>  Em seguida, no bloco de dependÃªncias, adicione uma das dependÃªncias bÃ¡sicas mencionadas acima: <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-generic-jvm:$version"</code> </pre><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-erased-jvm:$version"</code> </pre><br>  Como estamos falando do Android, haverÃ¡ mais dependÃªncias.  VocÃª pode, Ã© claro, ficar sem ele, o Kodein funcionarÃ¡ normalmente, mas por que recusar recursos adicionais Ãºteis para o Android (falarei sobre eles no final do artigo)?  A escolha Ã© sua, mas proponho que acrescente. <br><br>  TambÃ©m hÃ¡ opÃ§Ãµes aqui. <br><br>  Primeiro, vocÃª nÃ£o estÃ¡ usando a <code>SupportLibrary</code> <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-core:$version"</code> </pre><br>  O segundo - use <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-support:$version"</code> </pre><br>  Terceiro - vocÃª estÃ¡ usando o AndroidX <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-x:$version"</code> </pre><br><h3>  ComeÃ§amos a criar dependÃªncias </h3><br>  Usando o <code>Dagger2</code> , estou acostumado a criar e inicializar dependÃªncias na inicializaÃ§Ã£o do aplicativo, na classe Application. <br><br>  Com o Kodein, isso Ã© feito assim: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApp</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> } }</code> </pre><br>  As declaraÃ§Ãµes de dependÃªncia sempre comeÃ§am com <br><br><pre> <code class="kotlin hljs">bind&lt;TYPE&gt;() with</code> </pre><br><h4>  Tags </h4><br>  A marcaÃ§Ã£o de dependÃªncia de Kodein Ã© um recurso semelhante em funcionalidade ao <code>Qualifier</code> do <code>Dagger2</code> .  No <code>Dagger2</code> vocÃª precisa separar o <code>Qualifier</code> ou usar <code>@Named("someTag")</code> , que de fato tambÃ©m Ã© <code>Qualifier</code> .  A linha inferior Ã© simples - dessa maneira, vocÃª distingue duas dependÃªncias do mesmo tipo.  Por exemplo, vocÃª precisa obter o <code>ontext</code> aplicativo ou uma <code>Activity</code> especÃ­fica, dependendo da situaÃ§Ã£o; portanto, Ã© necessÃ¡rio especificar tags para isso ao declarar dependÃªncias.  <code>Kodein</code> permite que <code>Kodein</code> declare uma dependÃªncia sem uma tag, ela serÃ¡ a base e, se vocÃª nÃ£o especificar a tag ao receber a dependÃªncia, nÃ³s a obteremos, as outras precisarÃ£o ser marcadas e, quando a dependÃªncia for recebida, a tag precisarÃ¡ ser especificada. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Context&gt;() with ... bind&lt;Context&gt;(tag = <span class="hljs-string"><span class="hljs-string">"main_activity"</span></span>) with ... bind&lt;Context&gt;(tag = <span class="hljs-string"><span class="hljs-string">"sale_activity"</span></span>) with ... }</code> </pre><br>  O parÃ¢metro <code>tag</code> Ã© do tipo <code>Any</code> , para que vocÃª possa usar mais do que apenas strings.  Mas lembre-se de que as classes usadas como tags devem implementar os mÃ©todos <code>equals</code> e <code>hashCode</code> .  Ã‰ sempre necessÃ¡rio passar uma tag para uma funÃ§Ã£o como argumento nomeado, independentemente de vocÃª criar ou receber uma dependÃªncia. <br><br><h3>  Tipos de injeÃ§Ã£o de dependÃªncia </h3><br>  Existem vÃ¡rias maneiras de fornecer dependÃªncias no <code>Kodein</code> , <code>Kodein</code> pelo essencial - criando singletones.  O singleton viverÃ¡ dentro da estrutura da instÃ¢ncia criada do <code>Kodein</code> . <br><br><h4>  Apresentando singleton </h4><br>  Vamos comeÃ§ar com um exemplo: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with singleton { RoomDb() } }</code> </pre><br>  Assim, fornecemos (forneÃ§amos) <code>IMyDatabase</code> , atrÃ¡s do qual uma instÃ¢ncia do <code>RoomDb</code> ficarÃ¡ oculta.  Uma instÃ¢ncia do <code>RoomDb</code> serÃ¡ criada na primeira solicitaÃ§Ã£o da dependÃªncia e nÃ£o serÃ¡ <code>Kodein</code> atÃ© que uma nova instÃ¢ncia do <code>Kodein</code> seja <code>Kodein</code> .  Um singleton Ã© criado sincronizado, mas, se desejado, pode ser feito nÃ£o sincronizado.  Isso aumentarÃ¡ a produtividade, mas vocÃª deve entender os riscos a seguir. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with singleton(sync = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { RoomDb() } }</code> </pre><br>  Se vocÃª precisar criar uma instÃ¢ncia de dependÃªncia nÃ£o na primeira chamada, mas imediatamente apÃ³s a criaÃ§Ã£o da instÃ¢ncia <code>Kodein</code> , use outra funÃ§Ã£o: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with eagerSingleton { RoomDb() } }</code> </pre><br><h4>  Criando constantemente uma nova instÃ¢ncia da dependÃªncia </h4><br>  Ã‰ possÃ­vel criar nÃ£o singletones, mas constantemente ao acessar uma dependÃªncia para obter uma nova instÃ¢ncia dela.  Para isso, a funÃ§Ã£o do <code>provider</code> Ã© usada: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMainPresenter&gt;() with provider { QuantityPresenter() } }</code> </pre><br>  Nesse caso, toda vez que solicitarmos uma dependÃªncia do <code>IMainPresenter</code> , uma nova instÃ¢ncia do <code>QuantityPresenter</code> serÃ¡ criada. <br><br><h4>  Crie constantemente uma nova instÃ¢ncia da dependÃªncia e passe os parÃ¢metros para o construtor da dependÃªncia </h4><br>  VocÃª pode obter uma nova instÃ¢ncia toda vez que adicionar uma dependÃªncia, como no exemplo anterior, mas especifique os parÃ¢metros para criar a dependÃªncia.  Os parÃ¢metros podem ter no mÃ¡ximo <b>5</b> .  Para esse comportamento, use o mÃ©todo de <code>factory</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IColorPicker&gt;() with factory { r: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, g: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; RgbColorPicker(r, g, b, a) } }</code> </pre><br><h4>  Sempre que criamos uma instÃ¢ncia em cache, dependendo dos parÃ¢metros </h4><br>  Lendo o parÃ¡grafo anterior, vocÃª pode pensar que seria bom receber nÃ£o uma nova instÃ¢ncia a cada vez, de acordo com os parÃ¢metros passados, mas receber a mesma instÃ¢ncia da dependÃªncia do mesmo parÃ¢metro. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IRandomIntGenerator&gt;() with multiton { from: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, to: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; IntRandom(from, to) } }</code> </pre><br>  No exemplo acima, quando <code>IntRandom(5, 10)</code> a dependÃªncia com os parÃ¢metros <code>5</code> e <code>10</code> criaremos uma nova instÃ¢ncia do <code>IntRandom(5, 10)</code> . Quando chamarmos a dependÃªncia novamente com os mesmos parÃ¢metros, obteremos a instÃ¢ncia criada anteriormente.  Assim, Ã© obtido um <code>map</code> de singleton com inicializaÃ§Ã£o lenta.  Os argumentos, como no caso da <code>factory</code> mÃ¡ximo <b>5</b> . <br><br>  Como nas singletones, vocÃª pode desativar a sincronizaÃ§Ã£o aqui. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IRandomIntGenerator&gt;() with multiton(sync = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { from: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, to: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; IntRandom(from, to) } }</code> </pre><br><h4>  Usando links suaves e fracos no Kodein </h4><br>  Ao fornecer dependÃªncias usando <code>singleton</code> ou <code>multiton</code> vocÃª pode especificar o tipo de referÃªncia para a instÃ¢ncia armazenada.  No caso usual, que consideramos acima - este serÃ¡ o elo <code>strong</code> usual.  Mas Ã© possÃ­vel usar links <code>soft</code> e <code>weak</code> .  Se vocÃª Ã© novo nesses conceitos, dÃª uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">olhada aqui</a> . <br><br>  Assim, seus singletones podem ser recriados como parte do ciclo de vida do aplicativo ou podem nÃ£o ser. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyMap&gt;() with singleton(ref = softReference) { WorldMap() } bind&lt;IClient&gt;() with singleton(ref = weakReference) { id -&gt; clientFromDB(id) } }</code> </pre><br><h4>  Singleton separado para cada fluxo </h4><br>  Ã‰ o mesmo singleton, mas para cada thread que solicita uma dependÃªncia, um singleton serÃ¡ criado.  Para fazer isso, use o parÃ¢metro familiar <code>ref</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Cache&gt;() with singleton(ref = threadLocal) { LRUCache(<span class="hljs-number"><span class="hljs-number">16</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) } }</code> </pre><br><h4>  Constantes como dependÃªncias incorporÃ¡veis </h4><br>  VocÃª pode fornecer constantes como dependÃªncias.  A documentaÃ§Ã£o chama a atenÃ§Ã£o para o fato de que com o <code>Kodein</code> vocÃª deve <code>Kodein</code> constantes de tipos simples sem heranÃ§a ou interfaces, por exemplo, primitivas ou classes de dados. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { constant(tag = <span class="hljs-string"><span class="hljs-string">"maxThread"</span></span>) with <span class="hljs-number"><span class="hljs-number">8</span></span> constant(tag = <span class="hljs-string"><span class="hljs-string">"serverURL"</span></span>) with <span class="hljs-string"><span class="hljs-string">"https://my.server.url"</span></span></code> </pre><br><h4>  Crie dependÃªncias sem alterar o tipo </h4><br>  Por exemplo, vocÃª deseja fornecer a dependÃªncia como um singleton, mas nÃ£o a oculta atrÃ¡s da interface.  VocÃª simplesmente nÃ£o pode especificar o tipo ao chamar <code>bind</code> e usar <code>from</code> vez de <code>with</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind() from singleton { Gson() }</code> </pre><br>  A dependÃªncia no exemplo acima terÃ¡ o tipo de retorno da funÃ§Ã£o, ou seja, serÃ¡ <code>Gson</code> uma dependÃªncia do tipo <code>Gson</code> . <br><br><h4>  Criar dependÃªncias de subclasse de uma superclasse ou interface </h4><br>  <code>Kodein</code> permite fornecer dependÃªncia de maneiras diferentes para os descendentes de uma classe especÃ­fica ou classes que implementam uma Ãºnica interface. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Animal&gt;().subTypes() with { animalType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (animalType.jvmType) { Dog::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eagerSingleton</span></span></span><span class="hljs-class"> </span></span>{ Dog() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; provider { WildAnimal(animalType) } } }</code> </pre><br>  A classe <code>Animal</code> pode ser uma superclasse ou uma interface. Usando <code>.subtypes</code> , obtemos um <code>animalType</code> tipo <code>TypeToken&lt;*&gt;</code> , do qual jÃ¡ podemos obter uma classe Java e, dependendo dela, fornecer uma dependÃªncia de diferentes maneiras.  Esse recurso pode ser Ãºtil se vocÃª usar o <code>TypeToken</code> ou seus derivados como um parÃ¢metro construtor para vÃ¡rios casos.  AlÃ©m disso, vocÃª pode evitar cÃ³digo desnecessÃ¡rio com a mesma criaÃ§Ã£o de dependÃªncia para diferentes tipos. <br><br><h4>  Crie dependÃªncias que precisam de outras dependÃªncias como parÃ¢metros </h4><br>  Na maioria das vezes, nÃ£o criamos apenas uma classe sem parÃ¢metros como uma dependÃªncia, mas criamos uma classe para a qual precisamos passar parÃ¢metros ao construtor. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductGateway</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api: IProductApi, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dispatchers: IDispatchersContainer) : IProductGateway</code> </pre><br>  Para criar uma classe com dependÃªncias que foram criadas anteriormente no <code>Kodein</code> basta passar uma chamada de funÃ§Ã£o instance () como parÃ¢metros.  Nesse caso, a ordem da criaÃ§Ã£o nÃ£o Ã© importante. <br><br><pre> <code class="kotlin hljs">bind&lt;IDispatchersContainer&gt;() with singleton { DispatchersContainer() } bind&lt;IProductGateway&gt;() with singleton { ProductGateway(instance(), instance()) } bind&lt;IProductApi&gt;() with singleton { ProductApi() }</code> </pre><br>  Em vez de <code>instance()</code> pode haver chamadas para o <code>provider()</code> ou <code>factory()</code> ; examinaremos mais de perto esses mÃ©todos na seÃ§Ã£o sobre obtenÃ§Ã£o e implementaÃ§Ã£o de dependÃªncias. <br><br><h4>  Crie uma dependÃªncia chamando o mÃ©todo de dependÃªncia criado anteriormente </h4><br>  NÃ£o parece muito bom, mas vocÃª pode chamar a <code>instance&lt;TYPE&gt;</code> para obter uma classe que jÃ¡ fornecemos em algum lugar e chamar o mÃ©todo dessa classe para obter uma nova dependÃªncia. <br><br><pre> <code class="kotlin hljs">bind&lt;DataSource&gt;() with singleton { MySQLDataSource() } bind&lt;Connection&gt;() with provider { instance&lt;DataSource&gt;().openConnection() }</code> </pre><br><h3>  MÃ³dulos </h3><br>  Usando o <code>Dagger2</code> , estou acostumado a <code>Dagger2</code> dependÃªncias de <code>Dagger2</code> .  No <code>Kodein</code> , Ã  primeira vista, tudo nÃ£o parece muito bom.  VocÃª precisa criar muitas dependÃªncias diretamente na classe <code>Application</code> , e eu pessoalmente nÃ£o gosto disso.  Mas existe uma soluÃ§Ã£o, o <code>Kodein</code> tambÃ©m permite criar mÃ³dulos e conectÃ¡-los nos locais onde for necessÃ¡rio. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } bind&lt;HttpClient&gt;() with singleton { provideHttpClient() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) bind&lt;ISchedulersContainer&gt;() with singleton { SchedulersContainer() } <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  Mas tenha cuidado, os mÃ³dulos sÃ£o apenas contÃªineres declarando mÃ©todos para obter dependÃªncias; eles mesmos nÃ£o criam classes.  Portanto, se vocÃª declarar o recebimento da dependÃªncia como um singleton no mÃ³dulo e importar esse mÃ³dulo para duas instÃ¢ncias diferentes do <code>Kodein</code> , receberÃ¡ dois singlets diferentes, um por instÃ¢ncia do <code>Kodein</code> . <br><br>  AlÃ©m disso, o nome de cada mÃ³dulo deve ser exclusivo.  No entanto, se vocÃª precisar importar um mÃ³dulo de outro projeto, Ã© difÃ­cil garantir a exclusividade do nome; para isso, Ã© possÃ­vel renomear o mÃ³dulo ou adicionar um prefixo ao nome. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(apiModule.copy(name = <span class="hljs-string"><span class="hljs-string">"firstAPI"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondApiModule.copy(prefix = <span class="hljs-string"><span class="hljs-string">"secondAPI-"</span></span>))</code> </pre><br>  Estou acostumado a trabalhar quando os mÃ³dulos dependem um do outro e formam algum tipo de hierarquia.  <code>Kodein</code> pode importar cada mÃ³dulo para o <code>Kodein</code> uma vez; portanto, se vocÃª tentar importar dois mÃ³dulos com os mesmos mÃ³dulos dependentes em um <code>Kodein</code> , o aplicativo <code>Kodein</code> .  A soluÃ§Ã£o Ã© simples - vocÃª precisa usar a <code>importOnce(someModule)</code> para importar, que verificarÃ¡ se o mÃ³dulo com o mesmo nome foi importado anteriormente e depois importarÃ¡, se necessÃ¡rio. <br><br>  Por exemplo, nesses casos, o aplicativo falharÃ¡: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { importOnce(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br>  Mas se a chamada <code>importOnce</code> estiver em uma segunda tentativa de conexÃ£o, tudo funcionarÃ¡.  Tome cuidado. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { importOnce(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br><h4>  HeranÃ§a </h4><br>  Se vocÃª usar o mesmo mÃ³dulo duas vezes, dependÃªncias diferentes serÃ£o criadas, mas e a heranÃ§a e o comportamento de implementaÃ§Ã£o semelhantes aos <code>Subcomponents</code> no <code>Dagger2</code> ?  Tudo Ã© simples, vocÃª sÃ³ precisa herdar da instÃ¢ncia <code>Kodein</code> e terÃ¡ acesso a todas as dependÃªncias dos pais no herdeiro. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;ISchedulersContainer&gt;() with singleton { SchedulersContainer() } <span class="hljs-comment"><span class="hljs-comment">//   } val subKodein = Kodein { extend(kodein) //   }</span></span></code> </pre><br><h4>  RedefiniÃ§Ã£o </h4><br>  Por padrÃ£o, vocÃª nÃ£o pode substituir a dependÃªncia, caso contrÃ¡rio, os usuÃ¡rios ficariam loucos procurando motivos para o aplicativo funcionar incorretamente.  Mas Ã© possÃ­vel fazer isso usando um parÃ¢metro adicional da funÃ§Ã£o de <code>bind</code> .  Essa funcionalidade serÃ¡ Ãºtil, por exemplo, para organizar testes. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Api&gt;() with singleton { ApiImpl() } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> bind&lt;Api&gt;(overrides = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) with singleton { OtherApiImpl() } }</code> </pre><br>  Por padrÃ£o, os mÃ³dulos e suas dependÃªncias nÃ£o podem substituir dependÃªncias jÃ¡ declaradas no objeto <code>Kodein</code> , mas ao importar um mÃ³dulo, vocÃª pode indicar que as dependÃªncias existentes podem substituir suas dependÃªncias e, dentro deste mÃ³dulo, vocÃª jÃ¡ pode especificar dependÃªncias que outras pessoas podem substituir. <br><br>  NÃ£o parece muito claro, vamos usar exemplos.  Nesses casos, o aplicativo falharÃ¡: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) }</code> </pre><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule, allowOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br>  E nisso, a dependÃªncia do mÃ³dulo substitui a dependÃªncia declarada no objeto <code>Kodein</code> . <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;(overrides = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule, allowOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br>  Mas se vocÃª realmente quiser e entender o que estÃ¡ fazendo, poderÃ¡ criar um mÃ³dulo que, se houver dependÃªncias idÃªnticas ao objeto <code>Kodein</code> redefinirÃ¡ e o aplicativo nÃ£o falharÃ¡.  Usamos o parÃ¢metro <code>allowSilentOverride</code> para o mÃ³dulo. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testModule = Kodein.Module(name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, allowSilentOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { bind&lt;EmailClient&gt;() with singleton { MockEmailClient() } }</code> </pre><br>  A documentaÃ§Ã£o discute situaÃ§Ãµes mais complexas com heranÃ§a e redefiniÃ§Ã£o de dependÃªncias, bem como com dependÃªncias de cÃ³pia em herdeiros, mas essas situaÃ§Ãµes nÃ£o serÃ£o consideradas aqui. <br><br><h3>  Recuperando e Injetando DependÃªncias </h3><br>  Finalmente, descobrimos como declarar dependÃªncias de vÃ¡rias maneiras; Ã© hora de descobrir como obtÃª-las em suas classes. <br><br>  <code>Kodein</code> desenvolvedores do <code>Kodein</code> compartilham duas maneiras de obter dependÃªncias - <code>injection</code> e <code>retieval</code> .  Em resumo, <code>injection</code> Ã© quando a classe recebe todas as dependÃªncias quando Ã© criada, ou seja, no construtor, e <code>retrieval</code> Ã© quando a prÃ³pria classe Ã© responsÃ¡vel por obter suas dependÃªncias. <br><br>  Ao usar a <code>injection</code> sua classe nÃ£o sabe nada sobre o <code>Kodein</code> e o cÃ³digo da classe Ã© mais limpo, mas se vocÃª usar a <code>retrieval</code> , terÃ¡ a oportunidade de gerenciar dependÃªncias com mais flexibilidade.  No caso de <code>retrieval</code> todas as dependÃªncias sÃ£o obtidas preguiÃ§osamente, somente no momento do primeiro apelo Ã  dependÃªncia. <br><br><h4>  MÃ©todos <code>Kodein</code> para usar dependÃªncias </h4><br>  Uma instÃ¢ncia da classe <code>Kodein</code> possui trÃªs mÃ©todos que retornam uma dependÃªncia, uma fÃ¡brica de dependÃªncia ou um provedor de dependÃªncia - <code>instance()</code> , <code>factory()</code> e <code>provider()</code> respectivamente.  Portanto, se vocÃª fornecer uma dependÃªncia usando uma <code>factory</code> ou <code>provider</code> , poderÃ¡ receber nÃ£o apenas o resultado da execuÃ§Ã£o da funÃ§Ã£o, mas tambÃ©m a prÃ³pria funÃ§Ã£o.  Lembre-se de que vocÃª pode usar tags em todas as variaÃ§Ãµes. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance(arg = <span class="hljs-string"><span class="hljs-string">"23.87"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numberFactory: (value: String) -&gt; BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> factory() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random: Random <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomProvider: () -&gt; Random <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> provider()</code> </pre><br><h4>  InjeÃ§Ã£o de dependÃªncia atravÃ©s do construtor </h4><br>  Como vocÃª jÃ¡ entendeu, serÃ¡ sobre <code>injection</code> .  Para implementar, vocÃª deve primeiro levar todas as dependÃªncias da classe para o construtor e, em seguida, criar uma instÃ¢ncia da classe chamando <code>kodein.newInstance</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductApi</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: HttpClient, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson) : IProductApi <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } bind&lt;HttpClient&gt;() with singleton { provideHttpClient() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.newInstance { ProductApi(instance(), instance()) } }</code> </pre><br><h4>  InjeÃ§Ã£o de dependÃªncia em propriedades anulÃ¡veis </h4><br>  Pode ser que vocÃª nÃ£o saiba se uma dependÃªncia foi declarada.  Se a dependÃªncia nÃ£o for declarada na instÃ¢ncia <code>Kodein</code> , o cÃ³digo do exemplo acima resultarÃ¡ em uma <code>Kodein.NotFoundException</code> .  Se vocÃª deseja obter <code>null</code> como resultado, se nÃ£o houver dependÃªncia, existem trÃªs funÃ§Ãµes auxiliares para isso: <code>instanceOrNull()</code> , <code>factoryOrNull()</code> e <code>providerOrNull()</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductApi</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: HttpClient?, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson) : IProductApi <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.newInstance { ProductApi(instanceOrNull(), instance()) } }</code> </pre><br><h4>  Obtenha dependÃªncias dentro da classe. </h4><br>  Como jÃ¡ mencionado, no caso em que usamos <code>retrieval</code> , a inicializaÃ§Ã£o de todas as dependÃªncias Ã© lenta por padrÃ£o.  Isso permite que vocÃª obtenha dependÃªncias somente quando elas sÃ£o necessÃ¡rias e obtenha dependÃªncias nas classes que o sistema cria. <br><br>  <code>Activity</code> , <code>Fragment</code> e outras classes com seu prÃ³prio ciclo de vida, Ã© tudo sobre eles. <br><br>  Para implementar dependÃªncias no <code>Activity</code> precisamos apenas de um link para uma instÃ¢ncia do Kodein, apÃ³s o qual podemos usar mÃ©todos conhecidos.  De fato, vocÃª jÃ¡ viu exemplos de <code>retrieval</code> acima, basta declarar uma propriedade e delegÃ¡-la a uma das funÃ§Ãµes: <code>instance()</code> , <code>factory()</code> ou <code>provider()</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"23.87"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numberFactory: (value: String) -&gt; BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.factory() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random: Random? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instanceOrNull() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomProvider: (() -&gt; Random)? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.providerOrNull()</code> </pre><br><h4>  Passando parÃ¢metros para fÃ¡bricas </h4><br>  VocÃª jÃ¡ viu que, para passar um parÃ¢metro para a fÃ¡brica, basta usar o parÃ¢metro <code>arg</code> da funÃ§Ã£o de <code>instance</code> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas e se houver vÃ¡rios parÃ¢metros (eu disse anteriormente que pode haver atÃ© </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parÃ¢metros em uma fÃ¡brica </font><font style="vertical-align: inherit;">)? </font><font style="vertical-align: inherit;">VocÃª sÃ³ precisa passar uma </font></font><code>arg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classe </font><font style="vertical-align: inherit;">para o parÃ¢metro </font></font><code>M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que sobrecarregou os construtores e pode levar de 2 a 5 argumentos.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IColorPicker&gt;() with factory { r: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, g: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; RgbColorPicker(r, g, b, a) } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> picker: IColorPicker <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = M(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">211</span></span>, <span class="hljs-number"><span class="hljs-number">175</span></span>, <span class="hljs-number"><span class="hljs-number">215</span></span>))</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ForÃ§ar inicializaÃ§Ã£o de dependÃªncia </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como eles disseram - por padrÃ£o, a inicializaÃ§Ã£o Ã© lenta, mas vocÃª pode criar um gatilho, vinculÃ¡-lo a uma propriedade, vÃ¡rias propriedades ou uma instÃ¢ncia inteira </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, depois de puxar esse gatilho e as dependÃªncias serÃ£o inicializadas.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(trigger = myTrigger).instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> myTrigger.trigger() <span class="hljs-comment"><span class="hljs-comment">//     Gson</span></span></code> </pre><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinWithTrigger = kodein.on(trigger = myTrigger) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodeinWithTrigger.instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> myTrigger.trigger() <span class="hljs-comment"><span class="hljs-comment">//        kodeinWithTrigger</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CriaÃ§Ã£o de instÃ¢ncia preguiÃ§osa do Kodein </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes disso, constantemente criamos explicitamente uma instÃ¢ncia </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas Ã© possÃ­vel adiar a inicializaÃ§Ã£o dessa propriedade usando uma classe </font></font><code>LazyKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que assume uma funÃ§Ã£o no construtor que deve retornar um objeto </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa abordagem pode ser Ãºtil se, por exemplo, nÃ£o se souber se as dependÃªncias de uma determinada instÃ¢ncia do Kodein sÃ£o necessÃ¡rias.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = LazyKodein { Kodein { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"13.4"</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> number.toPlainString() <span class="hljs-comment"><span class="hljs-comment">//     kodein   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma chamada para Kodein.lazy levarÃ¡ a um resultado semelhante. </font></font><br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein.lazy { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"13.4"</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> number.toPlainString() <span class="hljs-comment"><span class="hljs-comment">//     kodein   </span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> InicializaÃ§Ã£o atrasada de Kodein </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para inicializaÃ§Ã£o atrasada, </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existe um objeto </font></font><code>LateInitKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">VocÃª pode criar esse objeto, delegar a criaÃ§Ã£o de propriedades a ele e depois de inicializar o prÃ³prio objeto, defina a propriedade para ele </font></font><code>baseKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, apÃ³s o qual vocÃª jÃ¡ poderÃ¡ acessar as dependÃªncias.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = LateInitKodein() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> kodein.baseKodein = <span class="hljs-comment"><span class="hljs-comment">/*     Kodein */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> gson.fromJson(someStr)</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obter todas as instÃ¢ncias do tipo especificado </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VocÃª pode solicitar ao Kodein uma instÃ¢ncia do tipo especificado e todos os seus descendentes no formulÃ¡rio </font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tudo estÃ¡ apenas dentro da tag especificada. </font><font style="vertical-align: inherit;">Para fazer isso, existem mÃ©todos </font></font><code>allInstances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>allProviders</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>allFactories</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.allInstances()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se vocÃª imprimir no log, verÃ¡ lÃ¡ [32767, 136.88, 4562, 12.46]. </font><font style="vertical-align: inherit;">A dependÃªncia com a tag nÃ£o estÃ¡ na lista.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simplifique a aquisiÃ§Ã£o de dependÃªncias usando a interface KodeinAware </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa interface obriga a substituir a propriedade type </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em troca, fornece acesso a todas as funÃ§Ãµes disponÃ­veis para a instÃ¢ncia </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> allInstances() }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como vocÃª pode ver, agora vocÃª pode simplesmente escrever em </font></font><code>by allInstances()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez de </font></font><code>by kodein.allInstances()</code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, jÃ¡ falamos sobre o gatilho para receber dependÃªncias. </font><font style="vertical-align: inherit;">Na interface, </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vocÃª pode substituir um gatilho e obter todas as dependÃªncias declaradas quando esse gatilho Ã© chamado.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> allInstances() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate() kodeinTrigger.trigger() } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o acesso Ã s dependÃªncias e Ã  instÃ¢ncia </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ã© lento, vocÃª pode delegar a inicializaÃ§Ã£o da instÃ¢ncia para a </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funÃ§Ã£o interna no Kotlin </font></font><code>lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Essa abordagem pode ser Ãºtil nas classes, dependendo do seu contexto, por exemplo, em </font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { (application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyApplication).kodein } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myFloat: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelas mesmas razÃµes, vocÃª pode usar um modificador </font></font><code>lateinit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myFloat: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) kodein = (application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyApplication).kodein }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acesso a dependÃªncias sem delegar propriedades </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se, por algum motivo, vocÃª nÃ£o quiser usar a delegaÃ§Ã£o de propriedades, poderÃ¡ usar o acesso direto atravÃ©s </font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(de direto). </font><font style="vertical-align: inherit;">A principal diferenÃ§a Ã© que a inicializaÃ§Ã£o lenta serÃ¡ ido, a dependÃªncia serÃ¡ obtido imediatamente no momento da chamada </font></font><code>instance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e funÃ§Ãµes similares. </font><font style="vertical-align: inherit;">VocÃª </font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode </font><font style="vertical-align: inherit;">obtÃª- </font><font style="vertical-align: inherit;">lo em uma instÃ¢ncia existente do Kodein ou compilar do zero.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with singleton { BigDecimal.TEN } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> directKodein: DKodein = kodein.direct <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> directKodein2: DKodein = Kodein.direct { bind&lt;BigDecimal&gt;() with singleton { BigDecimal.ONE } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someNumber:BigDecimal = directKodein.instance() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someNumber2:BigDecimal = directKodein2.instance()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Kodein pode ser usado na estrutura </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, </font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na estrutura </font></font><code>DKodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vocÃª pode experimentar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obter dependÃªncias em qualquer contexto </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obter </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vÃ¡rias dependÃªncias do mesmo tipo </font><font style="vertical-align: inherit;">de um objeto, </font><font style="vertical-align: inherit;">jÃ¡ examinamos a opÃ§Ã£o de usar tags e fÃ¡bricas com argumentos, mas hÃ¡ mais uma coisa: usar um contexto (e esse nÃ£o Ã© o contexto que estÃ¡ no Android). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DiferenÃ§as de dependÃªncia com tag:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma tag nÃ£o pode ser usada dentro de uma funÃ§Ã£o na qual criamos uma dependÃªncia </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ao usar o contexto, temos acesso Ã  instÃ¢ncia de contexto na funÃ§Ã£o de criaÃ§Ã£o de dependÃªncia </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FreqÃ¼entemente, em vez do contexto, vocÃª pode usar uma fÃ¡brica com um argumento, e os desenvolvedores </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendam fazer isso se nÃ£o tiver certeza do que usar. Mas o contexto pode ser Ãºtil, por exemplo, quando vocÃª nÃ£o pode converter dois argumentos para o mesmo tipo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, vocÃª tem </font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Presenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e deseja, usando um objeto </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, fornecer vÃ¡rias dependÃªncias de tipos diferentes de maneiras diferentes, dependendo da classe em que sÃ£o recebidas. Para liderar </font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Presenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para um tipo - vocÃª precisa de uma interface opcional, ea fÃ¡brica terÃ¡ que verificar o tipo do argumento resultante. O esquema nÃ£o Ã© muito conveniente. Portanto, examinamos como usar o contexto:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with contexted&lt;CategoriesActivity&gt;().provider { context.getActivityBigDecimal() } bind&lt;BigDecimal&gt;() with contexted&lt;CategoriesPresenter&gt;().factory { initialValue:BigDecimal -&gt; context.getPresenterBigDecimal(initialValue) } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), AppKodeinAware { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActivityBigDecimal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = BigDecimal(<span class="hljs-string"><span class="hljs-string">"16.34"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> activityBigDecimal: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).instance() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesPresenter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppKodeinAware { fun getPresenterBigDecimal</span></span></span></span>(initialValue: BigDecimal) = initialValue * BigDecimal.TEN <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> presenterBigDecimal: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).instance(arg = BigDecimal(<span class="hljs-string"><span class="hljs-string">"31.74"</span></span>)) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um exemplo, Ã© claro, serÃ¡ puxado sobre as orelhas e, na prÃ¡tica real, Ã© improvÃ¡vel que vocÃª encontre exatamente essa situaÃ§Ã£o, mas este exemplo mostra como o contexto funciona. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para declarar uma dependÃªncia, vocÃª nÃ£o especifica </font></font><code>with provider()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas </font></font><code>with contexted&lt;OurContextClass&gt;().provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, onde </font></font><code>OurContextClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ã© o tipo de classe, cuja instÃ¢ncia atuarÃ¡ como um contexto. </font></font><code>contexted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sÃ³ pode ser fornecedor ou fÃ¡brica. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O acesso a esse contexto em uma funÃ§Ã£o que retorna a relaÃ§Ã£o, atravÃ©s do nome de uma variÃ¡vel </font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obter uma dependÃªncia anexada a um contexto, primeiro Ã© necessÃ¡rio especificar o contexto para o objeto </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por meio da funÃ§Ã£o </font></font><code>on()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e solicitar a dependÃªncia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da mesma forma, o contexto Ã© usado no caso de </font></font><code>injection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = someContext).newInstance { ProductApi(instance(), instance()) } }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ExtensÃµes Android </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No comeÃ§o do artigo, prometi considerar opÃ§Ãµes de expansÃ£o para </font></font><code>Android</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nada impede vocÃª de usÃ¡- </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lo como discutimos acima, mas vocÃª pode tornar tudo uma ordem de magnitude mais conveniente.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein embutido para Android </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma coisa muito Ãºtil Ã© um mÃ³dulo preparado para Android. </font><font style="vertical-align: inherit;">Para conectÃ¡-lo, Ã© necessÃ¡rio que a classe </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implemente </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e inicialize a propriedade </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lentamente (para acessar a instÃ¢ncia </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Em troca, vocÃª obtÃ©m um grande nÃºmero de dependÃªncias declaradas que pode obter da classe </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, incluindo tudo o que precisa </font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como conectar - veja um exemplo.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein.lazy { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(androidModule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MyApplication</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//  } val inflater: LayoutInflater by instance() }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como vocÃª pode ver - vocÃª pode obter, por exemplo </font></font><code>LayoutInflater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para uma lista completa das dependÃªncias declaradas no mÃ³dulo - </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veja aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se vocÃª deseja obter essas dependÃªncias fora das classes do Android que conhecem seu contexto, especifique o contexto explicitamente.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inflater: LayoutInflater <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = getActivity()).instance()</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obtenha rapidamente o Kodein principal atravÃ©s do closestKodein () </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ã‰ simples, no Android, alguns objetos dependem de outros. </font><font style="vertical-align: inherit;">No nÃ­vel superior, hÃ¡ Aplicativo, abaixo do qual Atividade, e depois Fragmento. </font><font style="vertical-align: inherit;">VocÃª pode implementar a atividade </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bem como chamada de inicializaÃ§Ã£o </font></font><code>closestKodein()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, assim, receber uma cÃ³pia </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ds: DataSource <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() }</code> </pre><br> <code>closestKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VocÃª tambÃ©m pode obtÃª-lo fora das classes do Android, mas precisa de um contexto do Android no qual possa chamar a funÃ§Ã£o. </font><font style="vertical-align: inherit;">Se vocÃª o usar </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, especifique tambÃ©m o contexto (substitua a propriedade correspondente e passe o contexto do Android para a funÃ§Ã£o </font></font><code>kcontext()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span></span>(androidContext: Context) : KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> androidContext.closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinContext = kcontext(androidContext) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inflater: LayoutInflater <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criar um Kodein separado na Atividade </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pode ser necessÃ¡rio herdar do Kodein pai na Atividade e expandi-lo. </font><font style="vertical-align: inherit;">A soluÃ§Ã£o Ã© bastante simples.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parentKodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Kodein.lazy { extend(parentKodein) <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> } }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein que estÃ¡ passando por uma alteraÃ§Ã£o na configuraÃ§Ã£o </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sim vocÃª pode. </font><font style="vertical-align: inherit;">Existe uma funÃ§Ã£o para isso </font></font><code>retainedKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ao usÃ¡-lo, o objeto </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nÃ£o serÃ¡ recriado apÃ³s uma alteraÃ§Ã£o na configuraÃ§Ã£o.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parentKodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> retainedKodein { extend(parentKodein) } }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O que nÃ£o Ã© dito no artigo? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu nÃ£o pretendia ser completo, e eu mesmo nÃ£o entendo algumas coisas o suficiente para tentar indicÃ¡-las. </font><font style="vertical-align: inherit;">Aqui estÃ¡ uma lista do que vocÃª pode aprender por conta prÃ³pria, conhecendo os princÃ­pios bÃ¡sicos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escopos </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LigaÃ§Ã£o de InstÃ¢ncia </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LigaÃ§Ã£o mÃºltipla </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Retornos de chamada jÃ¡ </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fonte externa </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Armadilhas da versÃ£o apagada </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein configurÃ¡vel </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compatibilidade com JSR-330 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bem e links para a documentaÃ§Ã£o: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Core 5.3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 5.3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PÃ¡gina inicial</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obrigado pela leitura, espero que o artigo seja Ãºtil para vocÃª! </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431696/">https://habr.com/ru/post/pt431696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431686/index.html">Exceto IoT: Miranet botnet lanÃ§ou ataque a mÃ¡quinas Linux</a></li>
<li><a href="../pt431688/index.html">Como o Clang compila uma funÃ§Ã£o</a></li>
<li><a href="../pt431690/index.html">SoluÃ§Ã£o de crackme da Kaspersky Lab</a></li>
<li><a href="../pt431692/index.html">AvanÃ§os na imunoterapia no tratamento da esclerose mÃºltipla</a></li>
<li><a href="../pt431694/index.html">Classificar "Torre de HanÃ³i"</a></li>
<li><a href="../pt431698/index.html">AnÃ¡lise de perguntas no estande hh.ru em # HolyJS18</a></li>
<li><a href="../pt431700/index.html">Um multÃ­metro domÃ©stico que eu nunca encontrei no mercado</a></li>
<li><a href="../pt431702/index.html">HI-FI soviÃ©tico e seus criadores: fones de ouvido para um registro ou uma histÃ³ria esquecida Electronics TDK-3 â€œQuadâ€</a></li>
<li><a href="../pt431704/index.html">Leitura de fim de semana: como nÃ£o estragar sua audiÃ§Ã£o e fugir do barulho da cidade - 17 artigos e guias prÃ¡ticos</a></li>
<li><a href="../pt431706/index.html">Teoria da felicidade. Acidentes nÃ£o sÃ£o acidentais?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>