<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏾 👨🏿‍🤝‍👨🏾 👈🏽 Kodein. O básico 👨🏾‍⚖️ 🕔 🍈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Não encontrei guias compreensíveis para quem Kodein pela primeira vez e a documentação não é transparente e consistente em todos os lugares. Por isso,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kodein. O básico</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431696/"> Não encontrei guias compreensíveis para quem <code>Kodein</code> pela primeira vez e a documentação não é transparente e consistente em todos os lugares. Por isso, quero compartilhar os principais recursos da biblioteca com você.  Alguns recursos da biblioteca serão lançados, mas essa é basicamente a parte avançada.  Aqui você encontrará tudo para iniciar normalmente e começar a implementar dependências com o <code>Kodein</code> enquanto lê o artigo.  O artigo é baseado no <code>Kodein 5.3.0</code> , pois o <code>Kodein 6.0.0</code> requer a <code>Support Library 28</code> ou o <code>AndroidX</code> e de maneira alguma todos irão mudar para eles, pois muitas bibliotecas de terceiros ainda não oferecem versões compatíveis. <br><img src="https://habrastorage.org/webt/uj/ve/am/ujveamkhrxko4wle8mcfugfzjvc.png"><br><a name="habracut"></a><br>  <code>Kodein</code> é uma biblioteca para implementar injeção de dependência (DI).  Se você não conhece esse conceito, leia o início do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo sobre Dagger2</a> , onde o autor explica brevemente os aspectos teóricos da DI. <br><br>  Neste artigo, consideraremos tudo no exemplo do Android, mas, de acordo com os desenvolvedores, o Kodein se comporta da mesma maneira em todas as plataformas suportadas pelo Kotlin (JVM, Android, JS, Nativo). <br><br><h3>  Instalação </h3><br>  Devido ao fato de Java ter <code>type erasure</code> , surge um problema - o compilador apaga o tipo genérico.  No nível do bytecode, <code>List&lt;String&gt;</code> e <code>List&lt;Date&gt;</code> são apenas <code>List</code> .  Ainda existe uma maneira de obter informações sobre tipos genéricos, mas custará muito e funcionará apenas na JVM e Android.  Nesse sentido, os desenvolvedores do <code>Kodein</code> sugerem o uso de uma das duas dependências: uma recebe informações sobre tipos generalizados ( <code>kodein-generic</code> ) enquanto trabalha e o outro não ( <code>kodein-erased</code> ).  Por exemplo, ao usar <code>kodein-erased</code> <code>List&lt;String&gt;</code> <code>kodein-erased</code> por <code>kodein-erased</code> <code>List&lt;String&gt;</code> e a <code>List&lt;Date</code> &gt; serão salvas como <code>List&lt;*&gt;</code> e, ao usar o <code>kodein-generic</code> tudo será salvo junto com o tipo especificado, ou seja, como <code>List&lt;String&gt;</code> e <code>List&lt;Date&gt;</code> respectivamente. <br><br>  Como escolher? <br><br>  Escreva <b>não</b> na JVM - use <code>kodein-erased</code> , caso contrário, é impossível. <br>  Escreva na JVM e o problema de desempenho é muito importante para você - você pode usar o <code>kodein-erased</code> , mas tenha cuidado, pois essa experiência pode ser inesperada no mau sentido dessas palavras.  Se você estiver criando um aplicativo regular sem nenhum requisito especial de desempenho, use <code>kodein-generic</code> . <br><br>  Por fim, se você pensar no impacto da DI no desempenho, na maioria das vezes a maioria das dependências é criada uma vez ou as dependências são criadas para reutilização repetida, é improvável que, com essas ações, você possa afetar significativamente o desempenho do seu aplicativo. <br><br>  Então, instale: <br><br>  Primeiro - no build.gradle entre os repositórios deve estar o jcenter (), se não estiver lá - adicione. <br><br><pre> <code class="plaintext hljs">buildscript { repositories { jcenter() } }</code> </pre><br>  Em seguida, no bloco de dependências, adicione uma das dependências básicas mencionadas acima: <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-generic-jvm:$version"</code> </pre><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-erased-jvm:$version"</code> </pre><br>  Como estamos falando do Android, haverá mais dependências.  Você pode, é claro, ficar sem ele, o Kodein funcionará normalmente, mas por que recusar recursos adicionais úteis para o Android (falarei sobre eles no final do artigo)?  A escolha é sua, mas proponho que acrescente. <br><br>  Também há opções aqui. <br><br>  Primeiro, você não está usando a <code>SupportLibrary</code> <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-core:$version"</code> </pre><br>  O segundo - use <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-support:$version"</code> </pre><br>  Terceiro - você está usando o AndroidX <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-x:$version"</code> </pre><br><h3>  Começamos a criar dependências </h3><br>  Usando o <code>Dagger2</code> , estou acostumado a criar e inicializar dependências na inicialização do aplicativo, na classe Application. <br><br>  Com o Kodein, isso é feito assim: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApp</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> } }</code> </pre><br>  As declarações de dependência sempre começam com <br><br><pre> <code class="kotlin hljs">bind&lt;TYPE&gt;() with</code> </pre><br><h4>  Tags </h4><br>  A marcação de dependência de Kodein é um recurso semelhante em funcionalidade ao <code>Qualifier</code> do <code>Dagger2</code> .  No <code>Dagger2</code> você precisa separar o <code>Qualifier</code> ou usar <code>@Named("someTag")</code> , que de fato também é <code>Qualifier</code> .  A linha inferior é simples - dessa maneira, você distingue duas dependências do mesmo tipo.  Por exemplo, você precisa obter o <code>ontext</code> aplicativo ou uma <code>Activity</code> específica, dependendo da situação; portanto, é necessário especificar tags para isso ao declarar dependências.  <code>Kodein</code> permite que <code>Kodein</code> declare uma dependência sem uma tag, ela será a base e, se você não especificar a tag ao receber a dependência, nós a obteremos, as outras precisarão ser marcadas e, quando a dependência for recebida, a tag precisará ser especificada. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Context&gt;() with ... bind&lt;Context&gt;(tag = <span class="hljs-string"><span class="hljs-string">"main_activity"</span></span>) with ... bind&lt;Context&gt;(tag = <span class="hljs-string"><span class="hljs-string">"sale_activity"</span></span>) with ... }</code> </pre><br>  O parâmetro <code>tag</code> é do tipo <code>Any</code> , para que você possa usar mais do que apenas strings.  Mas lembre-se de que as classes usadas como tags devem implementar os métodos <code>equals</code> e <code>hashCode</code> .  É sempre necessário passar uma tag para uma função como argumento nomeado, independentemente de você criar ou receber uma dependência. <br><br><h3>  Tipos de injeção de dependência </h3><br>  Existem várias maneiras de fornecer dependências no <code>Kodein</code> , <code>Kodein</code> pelo essencial - criando singletones.  O singleton viverá dentro da estrutura da instância criada do <code>Kodein</code> . <br><br><h4>  Apresentando singleton </h4><br>  Vamos começar com um exemplo: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with singleton { RoomDb() } }</code> </pre><br>  Assim, fornecemos (forneçamos) <code>IMyDatabase</code> , atrás do qual uma instância do <code>RoomDb</code> ficará oculta.  Uma instância do <code>RoomDb</code> será criada na primeira solicitação da dependência e não será <code>Kodein</code> até que uma nova instância do <code>Kodein</code> seja <code>Kodein</code> .  Um singleton é criado sincronizado, mas, se desejado, pode ser feito não sincronizado.  Isso aumentará a produtividade, mas você deve entender os riscos a seguir. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with singleton(sync = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { RoomDb() } }</code> </pre><br>  Se você precisar criar uma instância de dependência não na primeira chamada, mas imediatamente após a criação da instância <code>Kodein</code> , use outra função: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with eagerSingleton { RoomDb() } }</code> </pre><br><h4>  Criando constantemente uma nova instância da dependência </h4><br>  É possível criar não singletones, mas constantemente ao acessar uma dependência para obter uma nova instância dela.  Para isso, a função do <code>provider</code> é usada: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMainPresenter&gt;() with provider { QuantityPresenter() } }</code> </pre><br>  Nesse caso, toda vez que solicitarmos uma dependência do <code>IMainPresenter</code> , uma nova instância do <code>QuantityPresenter</code> será criada. <br><br><h4>  Crie constantemente uma nova instância da dependência e passe os parâmetros para o construtor da dependência </h4><br>  Você pode obter uma nova instância toda vez que adicionar uma dependência, como no exemplo anterior, mas especifique os parâmetros para criar a dependência.  Os parâmetros podem ter no máximo <b>5</b> .  Para esse comportamento, use o método de <code>factory</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IColorPicker&gt;() with factory { r: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, g: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; RgbColorPicker(r, g, b, a) } }</code> </pre><br><h4>  Sempre que criamos uma instância em cache, dependendo dos parâmetros </h4><br>  Lendo o parágrafo anterior, você pode pensar que seria bom receber não uma nova instância a cada vez, de acordo com os parâmetros passados, mas receber a mesma instância da dependência do mesmo parâmetro. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IRandomIntGenerator&gt;() with multiton { from: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, to: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; IntRandom(from, to) } }</code> </pre><br>  No exemplo acima, quando <code>IntRandom(5, 10)</code> a dependência com os parâmetros <code>5</code> e <code>10</code> criaremos uma nova instância do <code>IntRandom(5, 10)</code> . Quando chamarmos a dependência novamente com os mesmos parâmetros, obteremos a instância criada anteriormente.  Assim, é obtido um <code>map</code> de singleton com inicialização lenta.  Os argumentos, como no caso da <code>factory</code> máximo <b>5</b> . <br><br>  Como nas singletones, você pode desativar a sincronização aqui. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IRandomIntGenerator&gt;() with multiton(sync = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { from: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, to: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; IntRandom(from, to) } }</code> </pre><br><h4>  Usando links suaves e fracos no Kodein </h4><br>  Ao fornecer dependências usando <code>singleton</code> ou <code>multiton</code> você pode especificar o tipo de referência para a instância armazenada.  No caso usual, que consideramos acima - este será o elo <code>strong</code> usual.  Mas é possível usar links <code>soft</code> e <code>weak</code> .  Se você é novo nesses conceitos, dê uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">olhada aqui</a> . <br><br>  Assim, seus singletones podem ser recriados como parte do ciclo de vida do aplicativo ou podem não ser. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyMap&gt;() with singleton(ref = softReference) { WorldMap() } bind&lt;IClient&gt;() with singleton(ref = weakReference) { id -&gt; clientFromDB(id) } }</code> </pre><br><h4>  Singleton separado para cada fluxo </h4><br>  É o mesmo singleton, mas para cada thread que solicita uma dependência, um singleton será criado.  Para fazer isso, use o parâmetro familiar <code>ref</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Cache&gt;() with singleton(ref = threadLocal) { LRUCache(<span class="hljs-number"><span class="hljs-number">16</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) } }</code> </pre><br><h4>  Constantes como dependências incorporáveis </h4><br>  Você pode fornecer constantes como dependências.  A documentação chama a atenção para o fato de que com o <code>Kodein</code> você deve <code>Kodein</code> constantes de tipos simples sem herança ou interfaces, por exemplo, primitivas ou classes de dados. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { constant(tag = <span class="hljs-string"><span class="hljs-string">"maxThread"</span></span>) with <span class="hljs-number"><span class="hljs-number">8</span></span> constant(tag = <span class="hljs-string"><span class="hljs-string">"serverURL"</span></span>) with <span class="hljs-string"><span class="hljs-string">"https://my.server.url"</span></span></code> </pre><br><h4>  Crie dependências sem alterar o tipo </h4><br>  Por exemplo, você deseja fornecer a dependência como um singleton, mas não a oculta atrás da interface.  Você simplesmente não pode especificar o tipo ao chamar <code>bind</code> e usar <code>from</code> vez de <code>with</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind() from singleton { Gson() }</code> </pre><br>  A dependência no exemplo acima terá o tipo de retorno da função, ou seja, será <code>Gson</code> uma dependência do tipo <code>Gson</code> . <br><br><h4>  Criar dependências de subclasse de uma superclasse ou interface </h4><br>  <code>Kodein</code> permite fornecer dependência de maneiras diferentes para os descendentes de uma classe específica ou classes que implementam uma única interface. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Animal&gt;().subTypes() with { animalType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (animalType.jvmType) { Dog::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eagerSingleton</span></span></span><span class="hljs-class"> </span></span>{ Dog() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; provider { WildAnimal(animalType) } } }</code> </pre><br>  A classe <code>Animal</code> pode ser uma superclasse ou uma interface. Usando <code>.subtypes</code> , obtemos um <code>animalType</code> tipo <code>TypeToken&lt;*&gt;</code> , do qual já podemos obter uma classe Java e, dependendo dela, fornecer uma dependência de diferentes maneiras.  Esse recurso pode ser útil se você usar o <code>TypeToken</code> ou seus derivados como um parâmetro construtor para vários casos.  Além disso, você pode evitar código desnecessário com a mesma criação de dependência para diferentes tipos. <br><br><h4>  Crie dependências que precisam de outras dependências como parâmetros </h4><br>  Na maioria das vezes, não criamos apenas uma classe sem parâmetros como uma dependência, mas criamos uma classe para a qual precisamos passar parâmetros ao construtor. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductGateway</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api: IProductApi, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dispatchers: IDispatchersContainer) : IProductGateway</code> </pre><br>  Para criar uma classe com dependências que foram criadas anteriormente no <code>Kodein</code> basta passar uma chamada de função instance () como parâmetros.  Nesse caso, a ordem da criação não é importante. <br><br><pre> <code class="kotlin hljs">bind&lt;IDispatchersContainer&gt;() with singleton { DispatchersContainer() } bind&lt;IProductGateway&gt;() with singleton { ProductGateway(instance(), instance()) } bind&lt;IProductApi&gt;() with singleton { ProductApi() }</code> </pre><br>  Em vez de <code>instance()</code> pode haver chamadas para o <code>provider()</code> ou <code>factory()</code> ; examinaremos mais de perto esses métodos na seção sobre obtenção e implementação de dependências. <br><br><h4>  Crie uma dependência chamando o método de dependência criado anteriormente </h4><br>  Não parece muito bom, mas você pode chamar a <code>instance&lt;TYPE&gt;</code> para obter uma classe que já fornecemos em algum lugar e chamar o método dessa classe para obter uma nova dependência. <br><br><pre> <code class="kotlin hljs">bind&lt;DataSource&gt;() with singleton { MySQLDataSource() } bind&lt;Connection&gt;() with provider { instance&lt;DataSource&gt;().openConnection() }</code> </pre><br><h3>  Módulos </h3><br>  Usando o <code>Dagger2</code> , estou acostumado a <code>Dagger2</code> dependências de <code>Dagger2</code> .  No <code>Kodein</code> , à primeira vista, tudo não parece muito bom.  Você precisa criar muitas dependências diretamente na classe <code>Application</code> , e eu pessoalmente não gosto disso.  Mas existe uma solução, o <code>Kodein</code> também permite criar módulos e conectá-los nos locais onde for necessário. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } bind&lt;HttpClient&gt;() with singleton { provideHttpClient() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) bind&lt;ISchedulersContainer&gt;() with singleton { SchedulersContainer() } <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  Mas tenha cuidado, os módulos são apenas contêineres declarando métodos para obter dependências; eles mesmos não criam classes.  Portanto, se você declarar o recebimento da dependência como um singleton no módulo e importar esse módulo para duas instâncias diferentes do <code>Kodein</code> , receberá dois singlets diferentes, um por instância do <code>Kodein</code> . <br><br>  Além disso, o nome de cada módulo deve ser exclusivo.  No entanto, se você precisar importar um módulo de outro projeto, é difícil garantir a exclusividade do nome; para isso, é possível renomear o módulo ou adicionar um prefixo ao nome. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(apiModule.copy(name = <span class="hljs-string"><span class="hljs-string">"firstAPI"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondApiModule.copy(prefix = <span class="hljs-string"><span class="hljs-string">"secondAPI-"</span></span>))</code> </pre><br>  Estou acostumado a trabalhar quando os módulos dependem um do outro e formam algum tipo de hierarquia.  <code>Kodein</code> pode importar cada módulo para o <code>Kodein</code> uma vez; portanto, se você tentar importar dois módulos com os mesmos módulos dependentes em um <code>Kodein</code> , o aplicativo <code>Kodein</code> .  A solução é simples - você precisa usar a <code>importOnce(someModule)</code> para importar, que verificará se o módulo com o mesmo nome foi importado anteriormente e depois importará, se necessário. <br><br>  Por exemplo, nesses casos, o aplicativo falhará: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { importOnce(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br>  Mas se a chamada <code>importOnce</code> estiver em uma segunda tentativa de conexão, tudo funcionará.  Tome cuidado. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { importOnce(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br><h4>  Herança </h4><br>  Se você usar o mesmo módulo duas vezes, dependências diferentes serão criadas, mas e a herança e o comportamento de implementação semelhantes aos <code>Subcomponents</code> no <code>Dagger2</code> ?  Tudo é simples, você só precisa herdar da instância <code>Kodein</code> e terá acesso a todas as dependências dos pais no herdeiro. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;ISchedulersContainer&gt;() with singleton { SchedulersContainer() } <span class="hljs-comment"><span class="hljs-comment">//   } val subKodein = Kodein { extend(kodein) //   }</span></span></code> </pre><br><h4>  Redefinição </h4><br>  Por padrão, você não pode substituir a dependência, caso contrário, os usuários ficariam loucos procurando motivos para o aplicativo funcionar incorretamente.  Mas é possível fazer isso usando um parâmetro adicional da função de <code>bind</code> .  Essa funcionalidade será útil, por exemplo, para organizar testes. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Api&gt;() with singleton { ApiImpl() } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> bind&lt;Api&gt;(overrides = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) with singleton { OtherApiImpl() } }</code> </pre><br>  Por padrão, os módulos e suas dependências não podem substituir dependências já declaradas no objeto <code>Kodein</code> , mas ao importar um módulo, você pode indicar que as dependências existentes podem substituir suas dependências e, dentro deste módulo, você já pode especificar dependências que outras pessoas podem substituir. <br><br>  Não parece muito claro, vamos usar exemplos.  Nesses casos, o aplicativo falhará: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) }</code> </pre><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule, allowOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br>  E nisso, a dependência do módulo substitui a dependência declarada no objeto <code>Kodein</code> . <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;(overrides = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule, allowOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br>  Mas se você realmente quiser e entender o que está fazendo, poderá criar um módulo que, se houver dependências idênticas ao objeto <code>Kodein</code> redefinirá e o aplicativo não falhará.  Usamos o parâmetro <code>allowSilentOverride</code> para o módulo. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testModule = Kodein.Module(name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, allowSilentOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { bind&lt;EmailClient&gt;() with singleton { MockEmailClient() } }</code> </pre><br>  A documentação discute situações mais complexas com herança e redefinição de dependências, bem como com dependências de cópia em herdeiros, mas essas situações não serão consideradas aqui. <br><br><h3>  Recuperando e Injetando Dependências </h3><br>  Finalmente, descobrimos como declarar dependências de várias maneiras; é hora de descobrir como obtê-las em suas classes. <br><br>  <code>Kodein</code> desenvolvedores do <code>Kodein</code> compartilham duas maneiras de obter dependências - <code>injection</code> e <code>retieval</code> .  Em resumo, <code>injection</code> é quando a classe recebe todas as dependências quando é criada, ou seja, no construtor, e <code>retrieval</code> é quando a própria classe é responsável por obter suas dependências. <br><br>  Ao usar a <code>injection</code> sua classe não sabe nada sobre o <code>Kodein</code> e o código da classe é mais limpo, mas se você usar a <code>retrieval</code> , terá a oportunidade de gerenciar dependências com mais flexibilidade.  No caso de <code>retrieval</code> todas as dependências são obtidas preguiçosamente, somente no momento do primeiro apelo à dependência. <br><br><h4>  Métodos <code>Kodein</code> para usar dependências </h4><br>  Uma instância da classe <code>Kodein</code> possui três métodos que retornam uma dependência, uma fábrica de dependência ou um provedor de dependência - <code>instance()</code> , <code>factory()</code> e <code>provider()</code> respectivamente.  Portanto, se você fornecer uma dependência usando uma <code>factory</code> ou <code>provider</code> , poderá receber não apenas o resultado da execução da função, mas também a própria função.  Lembre-se de que você pode usar tags em todas as variações. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance(arg = <span class="hljs-string"><span class="hljs-string">"23.87"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numberFactory: (value: String) -&gt; BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> factory() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random: Random <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomProvider: () -&gt; Random <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> provider()</code> </pre><br><h4>  Injeção de dependência através do construtor </h4><br>  Como você já entendeu, será sobre <code>injection</code> .  Para implementar, você deve primeiro levar todas as dependências da classe para o construtor e, em seguida, criar uma instância da classe chamando <code>kodein.newInstance</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductApi</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: HttpClient, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson) : IProductApi <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } bind&lt;HttpClient&gt;() with singleton { provideHttpClient() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.newInstance { ProductApi(instance(), instance()) } }</code> </pre><br><h4>  Injeção de dependência em propriedades anuláveis </h4><br>  Pode ser que você não saiba se uma dependência foi declarada.  Se a dependência não for declarada na instância <code>Kodein</code> , o código do exemplo acima resultará em uma <code>Kodein.NotFoundException</code> .  Se você deseja obter <code>null</code> como resultado, se não houver dependência, existem três funções auxiliares para isso: <code>instanceOrNull()</code> , <code>factoryOrNull()</code> e <code>providerOrNull()</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductApi</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: HttpClient?, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson) : IProductApi <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.newInstance { ProductApi(instanceOrNull(), instance()) } }</code> </pre><br><h4>  Obtenha dependências dentro da classe. </h4><br>  Como já mencionado, no caso em que usamos <code>retrieval</code> , a inicialização de todas as dependências é lenta por padrão.  Isso permite que você obtenha dependências somente quando elas são necessárias e obtenha dependências nas classes que o sistema cria. <br><br>  <code>Activity</code> , <code>Fragment</code> e outras classes com seu próprio ciclo de vida, é tudo sobre eles. <br><br>  Para implementar dependências no <code>Activity</code> precisamos apenas de um link para uma instância do Kodein, após o qual podemos usar métodos conhecidos.  De fato, você já viu exemplos de <code>retrieval</code> acima, basta declarar uma propriedade e delegá-la a uma das funções: <code>instance()</code> , <code>factory()</code> ou <code>provider()</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"23.87"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numberFactory: (value: String) -&gt; BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.factory() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random: Random? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instanceOrNull() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomProvider: (() -&gt; Random)? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.providerOrNull()</code> </pre><br><h4>  Passando parâmetros para fábricas </h4><br>  Você já viu que, para passar um parâmetro para a fábrica, basta usar o parâmetro <code>arg</code> da função de <code>instance</code> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas e se houver vários parâmetros (eu disse anteriormente que pode haver até </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parâmetros em uma fábrica </font><font style="vertical-align: inherit;">)? </font><font style="vertical-align: inherit;">Você só precisa passar uma </font></font><code>arg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classe </font><font style="vertical-align: inherit;">para o parâmetro </font></font><code>M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que sobrecarregou os construtores e pode levar de 2 a 5 argumentos.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IColorPicker&gt;() with factory { r: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, g: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; RgbColorPicker(r, g, b, a) } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> picker: IColorPicker <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = M(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">211</span></span>, <span class="hljs-number"><span class="hljs-number">175</span></span>, <span class="hljs-number"><span class="hljs-number">215</span></span>))</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Forçar inicialização de dependência </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como eles disseram - por padrão, a inicialização é lenta, mas você pode criar um gatilho, vinculá-lo a uma propriedade, várias propriedades ou uma instância inteira </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, depois de puxar esse gatilho e as dependências serão inicializadas.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(trigger = myTrigger).instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> myTrigger.trigger() <span class="hljs-comment"><span class="hljs-comment">//     Gson</span></span></code> </pre><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinWithTrigger = kodein.on(trigger = myTrigger) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodeinWithTrigger.instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> myTrigger.trigger() <span class="hljs-comment"><span class="hljs-comment">//        kodeinWithTrigger</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criação de instância preguiçosa do Kodein </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes disso, constantemente criamos explicitamente uma instância </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas é possível adiar a inicialização dessa propriedade usando uma classe </font></font><code>LazyKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que assume uma função no construtor que deve retornar um objeto </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa abordagem pode ser útil se, por exemplo, não se souber se as dependências de uma determinada instância do Kodein são necessárias.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = LazyKodein { Kodein { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"13.4"</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> number.toPlainString() <span class="hljs-comment"><span class="hljs-comment">//     kodein   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma chamada para Kodein.lazy levará a um resultado semelhante. </font></font><br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein.lazy { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"13.4"</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> number.toPlainString() <span class="hljs-comment"><span class="hljs-comment">//     kodein   </span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicialização atrasada de Kodein </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para inicialização atrasada, </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existe um objeto </font></font><code>LateInitKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Você pode criar esse objeto, delegar a criação de propriedades a ele e depois de inicializar o próprio objeto, defina a propriedade para ele </font></font><code>baseKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, após o qual você já poderá acessar as dependências.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = LateInitKodein() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> kodein.baseKodein = <span class="hljs-comment"><span class="hljs-comment">/*     Kodein */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> gson.fromJson(someStr)</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obter todas as instâncias do tipo especificado </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode solicitar ao Kodein uma instância do tipo especificado e todos os seus descendentes no formulário </font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tudo está apenas dentro da tag especificada. </font><font style="vertical-align: inherit;">Para fazer isso, existem métodos </font></font><code>allInstances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>allProviders</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>allFactories</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.allInstances()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você imprimir no log, verá lá [32767, 136.88, 4562, 12.46]. </font><font style="vertical-align: inherit;">A dependência com a tag não está na lista.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simplifique a aquisição de dependências usando a interface KodeinAware </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa interface obriga a substituir a propriedade type </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em troca, fornece acesso a todas as funções disponíveis para a instância </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> allInstances() }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como você pode ver, agora você pode simplesmente escrever em </font></font><code>by allInstances()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez de </font></font><code>by kodein.allInstances()</code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, já falamos sobre o gatilho para receber dependências. </font><font style="vertical-align: inherit;">Na interface, </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">você pode substituir um gatilho e obter todas as dependências declaradas quando esse gatilho é chamado.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> allInstances() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate() kodeinTrigger.trigger() } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o acesso às dependências e à instância </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é lento, você pode delegar a inicialização da instância para a </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">função interna no Kotlin </font></font><code>lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Essa abordagem pode ser útil nas classes, dependendo do seu contexto, por exemplo, em </font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { (application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyApplication).kodein } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myFloat: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelas mesmas razões, você pode usar um modificador </font></font><code>lateinit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myFloat: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) kodein = (application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyApplication).kodein }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acesso a dependências sem delegar propriedades </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se, por algum motivo, você não quiser usar a delegação de propriedades, poderá usar o acesso direto através </font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(de direto). </font><font style="vertical-align: inherit;">A principal diferença é que a inicialização lenta será ido, a dependência será obtido imediatamente no momento da chamada </font></font><code>instance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e funções similares. </font><font style="vertical-align: inherit;">Você </font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode </font><font style="vertical-align: inherit;">obtê- </font><font style="vertical-align: inherit;">lo em uma instância existente do Kodein ou compilar do zero.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with singleton { BigDecimal.TEN } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> directKodein: DKodein = kodein.direct <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> directKodein2: DKodein = Kodein.direct { bind&lt;BigDecimal&gt;() with singleton { BigDecimal.ONE } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someNumber:BigDecimal = directKodein.instance() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someNumber2:BigDecimal = directKodein2.instance()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Kodein pode ser usado na estrutura </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, </font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na estrutura </font></font><code>DKodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, você pode experimentar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obter dependências em qualquer contexto </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obter </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">várias dependências do mesmo tipo </font><font style="vertical-align: inherit;">de um objeto, </font><font style="vertical-align: inherit;">já examinamos a opção de usar tags e fábricas com argumentos, mas há mais uma coisa: usar um contexto (e esse não é o contexto que está no Android). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferenças de dependência com tag:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma tag não pode ser usada dentro de uma função na qual criamos uma dependência </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ao usar o contexto, temos acesso à instância de contexto na função de criação de dependência </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freqüentemente, em vez do contexto, você pode usar uma fábrica com um argumento, e os desenvolvedores </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendam fazer isso se não tiver certeza do que usar. Mas o contexto pode ser útil, por exemplo, quando você não pode converter dois argumentos para o mesmo tipo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, você tem </font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Presenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e deseja, usando um objeto </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, fornecer várias dependências de tipos diferentes de maneiras diferentes, dependendo da classe em que são recebidas. Para liderar </font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Presenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para um tipo - você precisa de uma interface opcional, ea fábrica terá que verificar o tipo do argumento resultante. O esquema não é muito conveniente. Portanto, examinamos como usar o contexto:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with contexted&lt;CategoriesActivity&gt;().provider { context.getActivityBigDecimal() } bind&lt;BigDecimal&gt;() with contexted&lt;CategoriesPresenter&gt;().factory { initialValue:BigDecimal -&gt; context.getPresenterBigDecimal(initialValue) } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), AppKodeinAware { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActivityBigDecimal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = BigDecimal(<span class="hljs-string"><span class="hljs-string">"16.34"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> activityBigDecimal: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).instance() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesPresenter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppKodeinAware { fun getPresenterBigDecimal</span></span></span></span>(initialValue: BigDecimal) = initialValue * BigDecimal.TEN <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> presenterBigDecimal: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).instance(arg = BigDecimal(<span class="hljs-string"><span class="hljs-string">"31.74"</span></span>)) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um exemplo, é claro, será puxado sobre as orelhas e, na prática real, é improvável que você encontre exatamente essa situação, mas este exemplo mostra como o contexto funciona. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para declarar uma dependência, você não especifica </font></font><code>with provider()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas </font></font><code>with contexted&lt;OurContextClass&gt;().provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, onde </font></font><code>OurContextClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é o tipo de classe, cuja instância atuará como um contexto. </font></font><code>contexted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">só pode ser fornecedor ou fábrica. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O acesso a esse contexto em uma função que retorna a relação, através do nome de uma variável </font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obter uma dependência anexada a um contexto, primeiro é necessário especificar o contexto para o objeto </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por meio da função </font></font><code>on()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e solicitar a dependência. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da mesma forma, o contexto é usado no caso de </font></font><code>injection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = someContext).newInstance { ProductApi(instance(), instance()) } }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Extensões Android </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No começo do artigo, prometi considerar opções de expansão para </font></font><code>Android</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nada impede você de usá- </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lo como discutimos acima, mas você pode tornar tudo uma ordem de magnitude mais conveniente.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein embutido para Android </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma coisa muito útil é um módulo preparado para Android. </font><font style="vertical-align: inherit;">Para conectá-lo, é necessário que a classe </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implemente </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e inicialize a propriedade </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lentamente (para acessar a instância </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Em troca, você obtém um grande número de dependências declaradas que pode obter da classe </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, incluindo tudo o que precisa </font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como conectar - veja um exemplo.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein.lazy { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(androidModule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MyApplication</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//  } val inflater: LayoutInflater by instance() }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como você pode ver - você pode obter, por exemplo </font></font><code>LayoutInflater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para uma lista completa das dependências declaradas no módulo - </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">veja aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você deseja obter essas dependências fora das classes do Android que conhecem seu contexto, especifique o contexto explicitamente.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inflater: LayoutInflater <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = getActivity()).instance()</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obtenha rapidamente o Kodein principal através do closestKodein () </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É simples, no Android, alguns objetos dependem de outros. </font><font style="vertical-align: inherit;">No nível superior, há Aplicativo, abaixo do qual Atividade, e depois Fragmento. </font><font style="vertical-align: inherit;">Você pode implementar a atividade </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bem como chamada de inicialização </font></font><code>closestKodein()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, assim, receber uma cópia </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ds: DataSource <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() }</code> </pre><br> <code>closestKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você também pode obtê-lo fora das classes do Android, mas precisa de um contexto do Android no qual possa chamar a função. </font><font style="vertical-align: inherit;">Se você o usar </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, especifique também o contexto (substitua a propriedade correspondente e passe o contexto do Android para a função </font></font><code>kcontext()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span></span>(androidContext: Context) : KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> androidContext.closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinContext = kcontext(androidContext) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inflater: LayoutInflater <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criar um Kodein separado na Atividade </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pode ser necessário herdar do Kodein pai na Atividade e expandi-lo. </font><font style="vertical-align: inherit;">A solução é bastante simples.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parentKodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Kodein.lazy { extend(parentKodein) <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> } }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein que está passando por uma alteração na configuração </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sim você pode. </font><font style="vertical-align: inherit;">Existe uma função para isso </font></font><code>retainedKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ao usá-lo, o objeto </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não será recriado após uma alteração na configuração.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parentKodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> retainedKodein { extend(parentKodein) } }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O que não é dito no artigo? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu não pretendia ser completo, e eu mesmo não entendo algumas coisas o suficiente para tentar indicá-las. </font><font style="vertical-align: inherit;">Aqui está uma lista do que você pode aprender por conta própria, conhecendo os princípios básicos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escopos </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ligação de Instância </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ligação múltipla </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Retornos de chamada já </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fonte externa </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Armadilhas da versão apagada </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein configurável </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compatibilidade com JSR-330 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bem e links para a documentação: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Core 5.3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 5.3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Página inicial</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obrigado pela leitura, espero que o artigo seja útil para você! </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431696/">https://habr.com/ru/post/pt431696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431686/index.html">Exceto IoT: Miranet botnet lançou ataque a máquinas Linux</a></li>
<li><a href="../pt431688/index.html">Como o Clang compila uma função</a></li>
<li><a href="../pt431690/index.html">Solução de crackme da Kaspersky Lab</a></li>
<li><a href="../pt431692/index.html">Avanços na imunoterapia no tratamento da esclerose múltipla</a></li>
<li><a href="../pt431694/index.html">Classificar "Torre de Hanói"</a></li>
<li><a href="../pt431698/index.html">Análise de perguntas no estande hh.ru em # HolyJS18</a></li>
<li><a href="../pt431700/index.html">Um multímetro doméstico que eu nunca encontrei no mercado</a></li>
<li><a href="../pt431702/index.html">HI-FI soviético e seus criadores: fones de ouvido para um registro ou uma história esquecida Electronics TDK-3 “Quad”</a></li>
<li><a href="../pt431704/index.html">Leitura de fim de semana: como não estragar sua audição e fugir do barulho da cidade - 17 artigos e guias práticos</a></li>
<li><a href="../pt431706/index.html">Teoria da felicidade. Acidentes não são acidentais?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>