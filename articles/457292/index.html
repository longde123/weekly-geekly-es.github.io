<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úäüèΩ üë®üèº üÜñ WBOIT en OpenGL: transparencia sin ordenar üò≤ üëØ ü§ûüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta publicaci√≥n trata sobre la transparencia combinada independiente del orden ponderado (WBOIT), el truco que se cubri√≥ en JCGT en 2013. 

 Cuando a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WBOIT en OpenGL: transparencia sin ordenar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457292/">  Esta publicaci√≥n trata sobre la transparencia combinada independiente del orden ponderado (WBOIT), el truco que se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cubri√≥</a> en JCGT en 2013. <br><a name="habracut"></a><br>  Cuando aparecen varios objetos transparentes en una pantalla, el color de los p√≠xeles depende de cu√°l est√© m√°s cerca del espectador.  Aqu√≠ hay un conocido operador de mezcla utilizado en ese caso: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;C_&amp;#xA0;{near}&amp;#xA0;\&amp;#xA0;alpha&amp;#xA0;+&amp;#xA0;C_&amp;#xA0;{far}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(1)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ begin {matrix} C = C_ {near} \ alpha + C_ {far} (1- \ alpha) && (1) \ end {matrix} </script></p><br><br>  El pedido de fragmentos es importante.  El operador contiene el color (C <sub>cerca</sub> ) y la opacidad ( <i>Œ±</i> ) de un fragmento cercano y el color general (C <sub>lejos</sub> ) de todos los fragmentos detr√°s de √©l.  La opacidad puede variar de 0 a 1;  0 significa que el objeto es completamente transparente (invisible) y 1 significa que es completamente opaco. <br><br>  Para utilizar este operador, debe ordenar los fragmentos por profundidad.  Imagina qu√© maldici√≥n es.  En general, debe realizar una clasificaci√≥n por fotograma.  Si clasifica objetos, entonces puede que tenga que lidiar con superficies de formas irregulares que deben cortarse en secciones, y luego deben cortarse las PARTES cortadas de esas superficies (definitivamente debe hacerlo para las superficies de intersecci√≥n).  Si clasifica fragmentos, colocar√° la clasificaci√≥n real en sus sombreadores.  Este m√©todo se conoce como "Transparencia independiente del pedido" (OIT) y se basa en una lista vinculada almacenada en la memoria de video.  Es casi imposible predecir cu√°nta memoria debe asignarse para esa lista.  Y si tienes poca memoria, obtienes artefactos en la pantalla. <br><br>  Consid√©rese afortunado si puede regular la cantidad de objetos transparentes en su escena y ajustar sus posiciones relativas.  Pero si desarrolla un CAD, entonces depende de los usuarios colocar sus objetos, por lo que habr√° tantos objetos como quieran, y su ubicaci√≥n ser√° completamente arbitraria. <br><br>  Ahora puede ver por qu√© es tan tentador encontrar un operador de mezcla que no requiera una clasificaci√≥n preliminar.  Y hay un operador as√≠, en un art√≠culo que mencion√© al principio.  De hecho, hay varias f√≥rmulas, pero una de ellas los autores (y yo) consideramos la mejor: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;{{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;C_i&amp;#xA0;\&amp;#xA0;alpha_i}&amp;#xA0;\&amp;#xA0;over&amp;#xA0;{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;\&amp;#xA0;alpha_i}}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i))&amp;#xA0;+&amp;#xA0;C_0&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(2)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matriz}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matriz}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matriz}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ begin {matrix} C = {{\ sum_ {i = 1} ^ {n} C_i \ alpha_i} \ over {\ sum_ {i = 1} ^ {n} \ alpha_i}} (1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i)) + C_0 \ prod_ {i = 1} ^ {n} (1- \ alpha_i) && (2) \ end {matriz} </script></p><br><br><img src="https://habrastorage.org/webt/65/b9/oz/65b9ozbni1afvlupqfso9uve2ey.png" width="1000"><br><br>  En la captura de pantalla se pueden ver grupos de tri√°ngulos transparentes dispuestos en cuatro capas de profundidad.  En el lado izquierdo se renderizaron con WBOIT, y en el lado derecho se us√≥ la combinaci√≥n cl√°sica dependiente del orden, con la f√≥rmula (1) (a partir de ahora lo llamar√© CODB). <br><br>  Antes de que podamos comenzar a renderizar objetos transparentes, necesitamos renderizar todos los no transparentes.  Despu√©s de eso, los objetos transparentes se representan con la prueba de profundidad pero sin escribir nada en un b√∫fer de profundidad (se puede hacer de esta manera: <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> ). <br><br>  Ahora, echemos un vistazo a lo que sucede en alg√∫n momento con las coordenadas del espacio de pantalla (x, y).  Los fragmentos transparentes, que est√°n m√°s cerca que el no transparente, pasan la prueba de profundidad, sin importar c√≥mo se coloquen en relaci√≥n con los fragmentos transparentes ya renderizados.  Esos fragmentos transparentes que quedan detr√°s del no transparente, bueno, no pasan la prueba de profundidad y se descartan, naturalmente. <br><br>  C <sub>0</sub> en la f√≥rmula (2) es el color del fragmento no transparente representado en ese punto (x, y).  Tenemos n fragmentos transparentes en total que pasaron la prueba de profundidad, y tienen √≠ndices i ‚àà [1, n].  C <sub>i</sub> es el color del i-√©simo fragmento transparente y <i>Œ± <sub>i</sub></i> es su opacidad. <br><br>  La f√≥rmula (2) es ligeramente similar a la f√≥rmula (1), aunque no es muy obvia.  Reemplazar <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  con C <sub>cerca</sub> , C <sub>0</sub> con C <sub>lejos</sub> y <img src="https://habrastorage.org/webt/li/tu/em/lituem-w98r3gl7cee5184y6b7q.png" width="100">  con <i>Œ±</i> y f√≥rmula (1) ser√° exactamente lo que obtendr√°s.  De hecho, <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  es la <b>media aritm√©tica ponderada</b> de los colores de todos los fragmentos transparentes (existe una f√≥rmula similar en mec√°nica para el "centro de masa"), e ir√° por el color del fragmento C <sub>cercano</sub> .  C <sub>0</sub> es el color del fragmento no transparente detr√°s de todos esos fragmentos transparentes para los que calculamos la media aritm√©tica ponderada.  En otras palabras, reemplazamos todos los fragmentos transparentes con un fragmento de "media ponderada" y utilizamos el operador de mezcla est√°ndar - f√≥rmula (1).  Ahora, hay una f√≥rmula un poco sofisticada para <i>Œ±</i> , y todav√≠a tenemos que descubrir su significado. <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msubsup><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.233ex" height="2.901ex" viewBox="0 -832 14738.9 1249" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-61" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-6C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-70" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-68" x="1581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-61" x="2158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMAIN-3D" x="2965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMAIN-31" x="4021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMAIN-2212" x="4744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-70" x="5995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-72" x="6498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-6F" x="6950" y="0"></use><g transform="translate(7435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-6E" x="741" y="499"></use><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMAIN-31" x="1124" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMAIN-28" x="9204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMAIN-31" x="9594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMAIN-2212" x="10316" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-61" x="11567" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-6C" x="12097" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-70" x="12395" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-68" x="12899" y="0"></use><g transform="translate(13475,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhgJHw9bOZkZheBhxXLZTuZSi9aBgg#MJMAIN-29" x="14349" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> \ alpha = 1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i) </script></p><br>  Es una funci√≥n escalar en el espacio n-dimensional.  Todos los <i>Œ± <sub>i</sub></i> est√°n contenidos en [0, 1] por lo que su derivada parcial con respecto a cualquiera de <i>Œ± <sub>i</sub></i> es una constante no negativa.  Significa que la opacidad del fragmento de "media ponderada" aumenta cuando aumenta la opacidad de cualquiera de los fragmentos transparentes, que es exactamente lo que queremos.  Adem√°s, aumenta linealmente. <br><br>  Si la opacidad de alg√∫n fragmento es 0, entonces es completamente invisible.  No contribuye al color resultante en absoluto. <br><br>  Si al menos un fragmento tiene una opacidad de 1, entonces <i>Œ± tambi√©n</i> es 1.  Es decir, el fragmento no transparente se vuelve invisible, lo cual es bueno.  El problema es que los otros fragmentos transparentes (detr√°s de este fragmento con opacidad = 1) a√∫n se pueden ver a trav√©s de √©l y contribuir al color resultante: <br><br><img src="https://habrastorage.org/webt/3s/lm/3y/3slm3yxglf43xno7dyqu8g7ua-o.png" width="300"><br><br>  El tri√°ngulo naranja en esta imagen se encuentra en la parte superior, el tri√°ngulo verde se encuentra debajo y debajo del tri√°ngulo verde se encuentran los tri√°ngulos gris y cian.  El fondo es negro.  La opacidad del tri√°ngulo naranja es 1;  todos los dem√°s tienen opacidad = 0.5.  Aqu√≠ puedes ver que WBOIT se ve muy pobre.  El √∫nico lugar donde aparece el color naranja verdadero es el borde del tri√°ngulo verde delineado con una l√≠nea blanca no transparente.  Como acabo de mencionar, el fragmento no transparente es invisible si tiene un fragmento transparente encima con opacidad = 1. <br><br>  Se ve mejor en la siguiente imagen: <br><br><img src="https://habrastorage.org/webt/-3/dc/ey/-3dcey8p1s2ynmgq9oyatw1ojma.png" width="300"><br><br>  La opacidad del tri√°ngulo naranja es 1, el tri√°ngulo verde con la transparencia desactivada se representa con objetos no transparentes.  Parece que el color VERDE del tri√°ngulo detr√°s se filtra a trav√©s del tri√°ngulo superior como color NARANJA. <br><br>  La forma m√°s sencilla de hacer que su imagen se vea plausible es no establecer una alta opacidad en sus objetos.  En un proyecto donde uso esta t√©cnica, no configuro la opacidad m√°s de 0.5.  Es el CAD 3D donde los objetos se dibujan esquem√°ticamente y no necesitan verse muy realistas, por lo que esta restricci√≥n es aceptable. <br><br>  Con baja opacidad, las im√°genes izquierda y derecha son muy similares: <br><br><img src="https://habrastorage.org/webt/hz/pc/ud/hzpcud9vuojz7vk0rsofbidyumy.png" width="1000"><br><br>  Y difieren notablemente con altas opacidades: <br><br><img src="https://habrastorage.org/webt/iv/hq/_l/ivhq_lqrb8ofbxie323mtwpfg-q.png" width="1000"><br><br>  Aqu√≠ hay un poliedro transparente: <br><br><img src="https://habrastorage.org/webt/nm/oi/6u/nmoi6u1xvycmbwvt50z6pinofbg.png" width="500"><br><img src="https://habrastorage.org/webt/ej/9u/p1/ej9up1muignigkr73kn2mi5byrs.png" width="500"><br><br>  Tiene caras laterales naranjas y caras horizontales verdes, lo que desafortunadamente no es obvio, lo que significa que la imagen no parece cre√≠ble.  Donde sea que una cara naranja est√© en la parte superior, el color debe ser m√°s naranja, y donde est√° detr√°s de una cara verde, el color debe ser m√°s verde.  Mejor dibujarlos con un color: <br><br><img src="https://habrastorage.org/webt/a2/eg/bf/a2egbfdzwlwmaltuc4lpyna45gs.png" width="500"><br><br><h3>  Inyecte profundidad en el operador de mezcla </h3><br>  Para compensar la falta de clasificaci√≥n de profundidad, los autores del art√≠culo JCGT mencionado anteriormente idearon varias formas de inyectar profundidad en la f√≥rmula (2).  Complica la implementaci√≥n y hace que el resultado sea menos predecible.  Para que funcione, los par√°metros de fusi√≥n deben ajustarse de acuerdo con una escena 3D espec√≠fica.  No profundic√© en este tema, as√≠ que si quieres saber m√°s, lee el peri√≥dico. <br><br>  Los autores afirman que a veces WBOIT es capaz de hacer algo que CODB no puede hacer.  Por ejemplo, considere dibujar un humo como un sistema de part√≠culas con dos part√≠culas: humo oscuro y humo m√°s claro.  Cuando las part√≠culas se mueven y una part√≠cula pasa a trav√©s de otra, su color mezclado cambia instant√°neamente de oscuro a claro, lo que no es bueno.  El operador WBOIT con profundidad produce un resultado m√°s preferible con una transici√≥n suave del color.  El cabello o la piel modelados como un conjunto de tubos delgados tiene la misma propiedad. <br><br><h3>  El codigo </h3><br>  Ahora para la implementaci√≥n de OpenGL de la f√≥rmula (2).  Puedes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ver la implementaci√≥n</a> en GitHub.  Es una aplicaci√≥n basada en Qt, y las im√°genes que ves aqu√≠ provienen principalmente de ella. <br><br>  Si eres nuevo en el renderizado transparente, aqu√≠ hay un buen material b√°sico: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprende OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mezcla</a> <br><br>  Recomiendo leerlo antes de continuar con esta publicaci√≥n. <br><br>  Para evaluar la f√≥rmula (2) necesitamos 2 framebuffers adicionales, 3 texturas multisamle y un renderbuffer de profundidad.  Los objetos no transparentes se mostrar√°n en la primera textura, colorTextureNT.  Su tipo es GL_RGB10_A2.  La segunda textura (colorTexture) ser√° del tipo GL_RGBA16F.  Los primeros tres componentes de colorTexture contendr√°n esta parte de la f√≥rmula (2): <img src="https://habrastorage.org/webt/9p/7i/vm/9p7ivmikwxs8ltenmceiumeogoo.png" width="70">  y <img src="https://habrastorage.org/webt/i2/bg/uc/i2bguc_jhzovzvn6ybqfkkuds4q.png" width="50">  se escribir√° en el cuarto componente.  La √∫ltima textura, alphaTexture, del tipo GL_R16 contendr√° <img src="https://habrastorage.org/webt/ma/si/f0/masif074trzop-clpwvbwtfj92i.png" width="90">  . <br><br>  Primero, necesitamos crear todos esos objetos y obtener sus identificadores de OpenGL: <br><pre> <code class="cpp hljs"> f-&gt;glGenFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT ); f-&gt;glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> <br>  Utilizo Qt framewok, como recordar√°n, y todas las llamadas a OpenGL se realizan desde un objeto de tipo QOpenGLFunctions_4_5_Core, para el que siempre uso el nombre f. <br><br>  La asignaci√≥n de memoria viene a continuaci√≥n: <br><pre> <code class="cpp hljs"> f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGB16F, w, h, GL_TRUE ); f-&gt;glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); f-&gt;glRenderbufferStorageMultisample( GL_RENDERBUFFER, numOfSamples, GL_DEPTH_COMPONENT, w, h ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGBA16F, w, h, GL_TRUE ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_R16F, w, h, GL_TRUE );</code> </pre> <br>  Configuraci√≥n de Framebuffer: <br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer ); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D_MULTISAMPLE, alphaTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); GLenum attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1}; f-&gt;glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer );</code> </pre> <br>  Durante la segunda pasada de representaci√≥n, la salida del sombreador de fragmentos ir√° en dos texturas, que deben especificarse expl√≠citamente con glDrawBuffers. <br>  La mayor parte de este c√≥digo se ejecuta una vez, cuando se inicia el programa.  El c√≥digo para la asignaci√≥n de memoria de textura y buffer de renderizado se ejecuta cada vez que se cambia el tama√±o de la ventana.  Ahora procedemos al c√≥digo ejecutado cada vez que se actualiza el contenido de la ventana. <br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); <span class="hljs-comment"><span class="hljs-comment">// ... rendering non-transparent objects ... // ....... // done! (you didn't expect me to explain how do I render primitives in OpenGL, did you? // It's not relevant for this topic</span></span></code> </pre> <br>  Acabamos de renderizar todos los objetos no transparentes a colorTextureNT y escribimos profundidades en el buffer de renderizado.  Antes de utilizar ese mismo buffer de renderizado en la pr√≥xima pasada de renderizado, debemos asegurarnos de que todas las operaciones de escritura en el buffer de renderizado de profundidad de objetos no transparentes hayan finalizado.  Se logra con GL_FRAMEBUFFER_BARRIER_BIT.  Despu√©s de renderizar los objetos transparentes, llamaremos a la funci√≥n ApplyTextures () que realizar√° la pasada de renderizaci√≥n final donde el sombreador de fragmentos tomar√° muestras de las texturas colorTextureNT, colorTexture y alphaTexture para aplicar la f√≥rmula (2).  Las texturas deben estar listas para ese momento, as√≠ que usamos GL_TEXTURE_FETCH_BARRIER_BIT antes de invocar ApplyTextures (). <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearColor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearAlpha = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">0</span></span>, clearColor); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;clearAlpha); f-&gt;glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT); PrepareToTransparentRendering(); { <span class="hljs-comment"><span class="hljs-comment">// ... rendering transparent objects ... } CleanupAfterTransparentRendering(); f-&gt;glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO); ApplyTextures();</span></span></code> </pre> <br>  defaultFBO es un framebuffer que usamos para mostrar la imagen en la pantalla.  En la mayor√≠a de los casos es 0, pero en Qt es QOpenGLWidget :: defaultFramebufferObject (). <br><br>  En cada invocaci√≥n de un sombreador de fragmentos tendremos acceso al color y la opacidad del fragmento actual.  Pero en colorTexture debe aparecer una suma (y en alphaTexture un producto) de esas entidades.  Para eso, usaremos la mezcla.  Adem√°s, teniendo en cuenta que para la primera textura calculamos una suma, mientras que para la segunda calculamos un producto, debemos proporcionar diferentes configuraciones de fusi√≥n (glBlendFunc y glBlendEquation) para cada archivo adjunto. <br><br>  Aqu√≠ est√° el contenido de la funci√≥n PrepareToTransparentRendering (): <br><pre> <code class="cpp hljs"> f-&gt;glEnable(GL_DEPTH_TEST); f-&gt;glDepthMask(GL_FALSE); f-&gt;glDepthFunc(GL_LEQUAL); f-&gt;glDisable(GL_CULL_FACE); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glEnable(GL_BLEND); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_ONE, GL_ONE); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_FUNC_ADD); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_DST_COLOR, GL_ZERO); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FUNC_ADD);</code> </pre> <br><br>  Y contenido de la funci√≥n CleanupAfterTransparentRendering (): <br><pre> <code class="cpp hljs"> f-&gt;glDepthMask(GL_TRUE); f-&gt;glDisable(GL_BLEND);</code> </pre> <br>  En mi sombreador de fragmentos, w significa opacidad.  El producto de color yw - yw en s√≠ mismo - ir√° al primer par√°metro de salida, y 1 - w ir√° al segundo par√°metro de salida.  Se debe establecer un calificador de dise√±o para cada par√°metro de salida en forma de "ubicaci√≥n = X", donde X es un √≠ndice de un elemento en la matriz de archivos adjuntos, el que le dimos a la funci√≥n glDrawBuffers.  Para ser precisos, el par√°metro de salida con ubicaci√≥n = 0 va a la textura vinculada a GL_COLOR_ATTACHMENT1, y el par√°metro con ubicaci√≥n = 1 va a la textura vinculada a GL_COLOR_ATTACHMENT1.  Los mismos n√∫meros se usan en las funciones glBlendFunci y glBlendEquationi para indicar para qu√© color adjunto establecemos los par√°metros de fusi√≥n. <br><br>  El sombreador de fragmentos: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core in vec3 color; layout (location = 0) out vec4 outData; layout (location = 1) out float alpha; layout (location = 2) uniform float w; void main() { outData = vec4(w * color, w); alpha = 1 - w; }</span></span></code> </pre> <br>  En la funci√≥n ApplyTextures () simplemente dibujamos un rect√°ngulo que cubre toda la ventana gr√°fica.  El sombreador de fragmentos muestrea los datos de las tres texturas utilizando los coords de espacio de pantalla actuales como coords de textura, y un √≠ndice de muestra actual (gl_SampleID) como √≠ndice de muestra para texturas multimuestra.  La presencia de la variable gl_SampleID en el c√≥digo del sombreador hace que el sistema invoque el sombreador de fragmentos una vez por muestra (mientras que normalmente se invoca una vez por p√≠xel, escribiendo su salida en todas las muestras que caen dentro de una primitiva). <br><br>  El sombreador de v√©rtices es trivial: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core const vec2 p[4] = vec2[4]( vec2(-1, -1), vec2( 1, -1), vec2( 1, 1), vec2(-1, 1) ); void main() { gl_Position = vec4(p[gl_VertexID], 0, 1); }</span></span></code> </pre> <br><br>  El sombreador de fragmentos: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core out vec4 outColor; layout (location = 0) uniform sampler2DMS colorTextureNT; layout (location = 1) uniform sampler2DMS colorTexture; layout (location = 2) uniform sampler2DMS alphaTexture; void main() { ivec2 upos = ivec2(gl_FragCoord.xy); vec4 cc = texelFetch(colorTexture, upos, gl_SampleID); vec3 sumOfColors = cc.rgb; float sumOfWeights = cc.a; vec3 colorNT = texelFetch(colorTextureNT, upos, gl_SampleID).rgb; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sumOfWeights == 0) { outColor = vec4(colorNT, 1.0); return; } float alpha = 1 - texelFetch(alphaTexture, upos, gl_SampleID).r; colorNT = sumOfColors / sumOfWeights * alpha + colorNT * (1 - alpha); outColor = vec4(colorNT, 1.0); }</span></span></code> </pre> <br>  Y finalmente, la funci√≥n ApplyTextures (): <br><pre> <code class="cpp hljs"> f-&gt;glActiveTexture(GL_TEXTURE0); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); f-&gt;glActiveTexture(GL_TEXTURE1); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); f-&gt;glActiveTexture(GL_TEXTURE2); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glDisable(GL_DEPTH_TEST); f-&gt;glDrawArrays(GL_TRIANGLE_FAN, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br><br>  Al final, los recursos de OpenGL deben ser liberados.  Lo hago en el destructor de mi widget OpenGL: <br><pre> <code class="cpp hljs"> f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT); f-&gt;glDeleteRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457292/">https://habr.com/ru/post/457292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457282/index.html">"La muerte de Dios" o el colapso de las leyes generalmente aceptadas para construir equipos de TI y crear sistemas de TI en el siglo XXI</a></li>
<li><a href="../457284/index.html">WBOIT en OpenGL: transparencia sin ordenar</a></li>
<li><a href="../457286/index.html">La soluci√≥n de las tareas de WorldSkills del m√≥dulo de red en la competencia de "CCA". Parte 1 - Configuraci√≥n b√°sica</a></li>
<li><a href="../457288/index.html">Estaci√≥n de trabajo criptogr√°fica basada en tokens PKCS # 11. Firma electr√≥nica Parte 2</a></li>
<li><a href="../457290/index.html">Conferencia DEFCON 25. Garry Kasparov. "La √∫ltima batalla del cerebro". Parte 2</a></li>
<li><a href="../457294/index.html">"Live high" o mi historia desde la dilaci√≥n hasta el autodesarrollo</a></li>
<li><a href="../457298/index.html">Frontend Weekly Digest (17-23 de junio de 2019)</a></li>
<li><a href="../457300/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 370 (17 al 23 de junio de 2019)</a></li>
<li><a href="../457302/index.html">10 caracter√≠sticas para acelerar el an√°lisis de datos en Python</a></li>
<li><a href="../457304/index.html">Servicios de estad√≠sticas para aplicaciones m√≥viles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>