<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüé® ‚ùï üë®üèæ‚Äçüíº Contenedores, microservicios y mallas de servicio üë®üèæ‚Äçüöí üïó üõÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay toneladas de art√≠culos en el servicio de malla en Internet, y aqu√≠ hay otro. ¬°Hurra! Pero por que? Entonces, lo que quiero expresar mi opini√≥n es ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contenedores, microservicios y mallas de servicio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453204/"> Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">toneladas de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el</a> servicio de malla <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en</a> Internet, y aqu√≠ hay otro.  ¬°Hurra!  Pero por que?  Entonces, lo que quiero expresar mi opini√≥n es que ser√≠a mejor que aparecieran mallas de servicio hace 10 a√±os, antes de la aparici√≥n de plataformas de contenedores como Docker y Kubernetes.  No afirmo que mi punto de vista sea mejor o peor que otros, pero como las mallas de servicio son animales bastante complejos, la multiplicidad de puntos de vista ayudar√° a comprenderlos mejor. <br><br>  Hablar√© sobre la plataforma dotCloud, que se cre√≥ en m√°s de cien microservicios y admiti√≥ miles de aplicaciones en contenedores.  Explicar√© los problemas que encontramos durante su desarrollo y lanzamiento, y c√≥mo las mallas de servicio podr√≠an ayudar (o no). <br><a name="habracut"></a><br><h1>  Historia de dotCloud </h1><br>  Ya escrib√≠ sobre la historia de dotCloud y la elecci√≥n de la arquitectura para esta plataforma, pero habl√© un poco sobre el nivel de red.  Si no desea sumergirse en la lectura del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> sobre dotCloud, aqu√≠ hay un breve resumen: es una plataforma como servicio PaaS que permite a los clientes lanzar una amplia gama de aplicaciones (Java, PHP, Python ...), con soporte para una amplia gama de servicios de datos (MongoDB, MySQL, Redis ...) y un flujo de trabajo como Heroku: carga su c√≥digo en la plataforma, crea im√°genes de contenedores y los implementa. <br><br>  Te dir√© c√≥mo se dirigi√≥ el tr√°fico a la plataforma dotCloud.  No porque fuera especialmente genial (¬°aunque el sistema funcion√≥ bien para su √©poca!), Sino principalmente porque con la ayuda de herramientas modernas, un equipo modesto puede implementar f√°cilmente dicho dise√±o en poco tiempo si necesitan una forma de enrutar el tr√°fico entre un mont√≥n de microservicios o Un mont√≥n de aplicaciones.  Por lo tanto, puede comparar las opciones: qu√© sucede si desarrolla todo usted mismo o utiliza la malla de servicio existente.  Opci√≥n est√°ndar: h√°galo usted mismo o compre. <br><br><h1>  Enrutamiento de tr√°fico para aplicaciones alojadas </h1><br>  Las aplicaciones DotCloud pueden proporcionar puntos finales HTTP y TCP. <br><br>  <b>Los puntos finales HTTP se</b> agregan din√°micamente a la configuraci√≥n del cl√∫ster de equilibrador de carga de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hipache</a> .  Esto es similar a lo que hacen hoy los recursos de Kubernetes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ingress</a> y un equilibrador de carga como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Traefik</a> . <br><br>  Los clientes se conectan a puntos finales HTTP a trav√©s de sus respectivos dominios, siempre que el nombre de dominio apunte a equilibradores de carga dotCloud.  Nada especial <br><br>  <b>Los puntos finales TCP</b> est√°n asociados con un n√∫mero de puerto, que luego se pasa a todos los contenedores de esta pila a trav√©s de variables de entorno. <br><br>  Los clientes pueden conectarse a los puntos finales TCP utilizando el nombre de host apropiado (algo as√≠ como gateway-X.dotcloud.com) y el n√∫mero de puerto. <br><br>  Este nombre de host se resuelve en el cl√∫ster de servidores "nats" (no relacionado con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NATS</a> ), que enrutar√° las conexiones TCP entrantes al contenedor correcto (o, en el caso de servicios con equilibrio de carga, a los contenedores correctos). <br><br>  Si est√° familiarizado con Kubernetes, esto probablemente le recordar√° los servicios de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NodePort</a> . <br><br>  No hab√≠a un equivalente de los servicios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ClusterIP</a> en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plataforma dotCloud</a> : por simplicidad, el acceso a los servicios era el mismo tanto desde el interior como desde el exterior de la plataforma. <br><br>  Todo se organiz√≥ de manera bastante simple: las implementaciones iniciales de las redes de enrutamiento HTTP y TCP, probablemente solo unos cientos de l√≠neas de Python.  Algoritmos simples (dir√≠a ingenuos) que se finalizaron con el crecimiento de la plataforma y la llegada de requisitos adicionales. <br><br>  No se requiri√≥ una refactorizaci√≥n extensa del c√≥digo existente.  En particular, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las aplicaciones de 12 factores</a> pueden usar directamente la direcci√≥n obtenida a trav√©s de variables de entorno. <br><br><h1>  ¬øC√≥mo difiere esto de una malla de servicio moderna? </h1><br>  <b>Visibilidad</b> limitada  Generalmente no ten√≠amos m√©tricas para la cuadr√≠cula de enrutamiento TCP.  En cuanto al enrutamiento HTTP, las versiones posteriores tienen m√©tricas HTTP detalladas con c√≥digos de error y tiempos de respuesta, pero las mallas de servicio modernas van a√∫n m√°s lejos, proporcionando integraci√≥n con sistemas de recopilaci√≥n de m√©tricas como Prometheus, por ejemplo. <br><br>  La visibilidad es importante no solo desde un punto de vista operativo (para ayudar a solucionar problemas), sino tambi√©n cuando se lanzan nuevas funciones.  Se trata de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">despliegue</a> seguro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">azul-verde</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">despliegue de canarios</a> . <br><br>  <b>La eficiencia del enrutamiento</b> tambi√©n <b>es</b> limitada.  En la cuadr√≠cula de enrutamiento dotCloud, todo el tr√°fico ten√≠a que pasar por un grupo de nodos de enrutamiento dedicados.  Esto signific√≥ un posible cruce de varias fronteras AZ (zonas de accesibilidad) y un aumento significativo en el retraso.  Recuerdo c√≥mo solucion√© problemas con el c√≥digo que realizaba m√°s de cien consultas SQL por p√°gina y para cada consulta se abr√≠a una nueva conexi√≥n al servidor SQL.  Cuando se inicia localmente, la p√°gina se carga instant√°neamente, pero en dotCloud, la carga tarda unos segundos, ya que toma decenas de milisegundos para cada conexi√≥n TCP (y la consulta SQL posterior).  En este caso particular, las conexiones persistentes resolvieron el problema. <br><br>  Las mallas de servicio modernas mejoran con tales problemas.  En primer lugar, verifican que las conexiones se enrutan <i>en la fuente</i> .  El flujo l√≥gico es el mismo: <code> ‚Üí  ‚Üí </code> , pero ahora la malla funciona localmente y no en nodos remotos, por lo que la conexi√≥n <code> ‚Üí </code> es local y muy r√°pida (microsegundos en lugar de milisegundos). <br><br>  Las mallas de servicio modernas tambi√©n implementan algoritmos de equilibrio de carga m√°s inteligentes.  Al controlar el rendimiento de los backends, pueden enviar m√°s tr√°fico a backends m√°s r√°pidos, lo que conduce a un aumento en el rendimiento general. <br><br>  <b>La seguridad tambi√©n</b> es mejor.  La cuadr√≠cula de enrutamiento dotCloud funcion√≥ completamente en EC2 Classic y no cifr√≥ el tr√°fico (suponiendo que si alguien lograra poner un sniffer en el tr√°fico de la red EC2, ya tiene grandes problemas).  Las mallas de servicio modernas protegen de forma transparente todo nuestro tr√°fico, por ejemplo, con autenticaci√≥n mutua TLS y cifrado posterior. <br><br><h1>  Enrutamiento de tr√°fico para servicios de plataforma </h1><br>  Ok, discutimos el tr√°fico entre aplicaciones, pero ¬øqu√© pasa con la plataforma dotCloud en s√≠? <br><br>  La plataforma en s√≠ consist√≠a en aproximadamente un centenar de microservicios responsables de diversas funciones.  Algunos recibieron solicitudes de otros, y algunos eran trabajadores de fondo que se conectaron a otros servicios pero no aceptaron conexiones.  En cualquier caso, cada servicio debe conocer los puntos finales de las direcciones a las que es necesario conectarse. <br><br>  Muchos servicios de alto nivel pueden usar la cuadr√≠cula de enrutamiento descrita anteriormente.  De hecho, muchos de los m√°s de cientos de microservicios dotCloud se han implementado como aplicaciones regulares en la plataforma dotCloud.  Pero una peque√±a cantidad de servicios de bajo nivel (en particular, que implementan esta cuadr√≠cula de enrutamiento) necesitaba algo m√°s simple, con menos dependencias (ya que no pod√≠an depender de s√≠ mismos para el trabajo, un buen viejo problema de huevo y gallina). <br><br>  Estos servicios importantes de bajo nivel se implementaron ejecutando contenedores directamente en varios nodos clave.  Al mismo tiempo, los servicios de plataforma est√°ndar no estaban involucrados: el enlazador, el planificador y el corredor.  Si desea comparar con plataformas de contenedores modernas, es como lanzar un plano de control con <code>docker run</code> directamente en los nodos, en lugar de delegar la tarea de Kubernetes.  Esto es bastante similar al concepto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√≥dulos est√°ticos (hogares)</a> que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usa kubeadm</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bootkube</a> al cargar un cl√∫ster independiente. <br><br>  Estos servicios fueron expuestos de una manera simple y cruda: sus nombres y direcciones se enumeraron en el archivo YAML;  y cada cliente tuvo que tomar una copia de este archivo YAML para su implementaci√≥n. <br><br>  Por un lado, es extremadamente confiable porque no requiere el soporte de un almac√©n externo de clave / valor como Zookeeper (no lo olvide, en ese momento, etcd o Consul a√∫n no exist√≠a).  Por otro lado, esto dificultaba el traslado de servicios.  Cada vez que se mueven, todos los clientes deber√≠an haber recibido un archivo YAML actualizado (y posiblemente reiniciar).  No muy conveniente! <br><br>  Posteriormente, comenzamos a introducir un nuevo esquema, donde cada cliente se conectaba a un servidor proxy local.  En lugar de la direcci√≥n y el puerto, le basta con saber solo el n√∫mero de puerto del servicio y conectarse a trav√©s de <code>localhost</code> .  El servidor proxy local procesa esta conexi√≥n y la enruta al servidor real.  Ahora, al mover el back-end a otra m√°quina o escalar en lugar de actualizar todos los clientes, solo necesita actualizar todos estos servidores proxy locales;  y ya no se requiere reiniciar. <br><br>  (Tambi√©n se plane√≥ encapsular el tr√°fico en las conexiones TLS y colocar otro servidor proxy en el lado receptor, as√≠ como verificar los certificados TLS sin la participaci√≥n del servicio receptor, que est√° configurado para aceptar conexiones solo en el <code>localhost</code> . M√°s sobre esto m√°s adelante). <br><br>  Esto es muy similar al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SmartStack</a> de Airbnb, pero la diferencia significativa es que SmartStack se implementa y se implementa en producci√≥n, mientras que el sistema de enrutamiento interno dotCloud se coloc√≥ en una caja cuando dotCloud se convirti√≥ en Docker. <br><br>  Personalmente considero que SmartStack es uno de los predecesores de sistemas como Istio, Linkerd y Consul Connect, porque todos siguen el mismo patr√≥n: <br><br><ul><li>  Ejecutando proxies en cada nodo. <br></li><li>  Los clientes se conectan al proxy. <br></li><li>  El plano de administraci√≥n actualiza la configuraci√≥n del proxy al cambiar los backends. <br></li><li>  ... Beneficio! </li></ul><br><h1>  Implementaci√≥n moderna de una malla de servicios. </h1><br>  Si necesitamos implementar una grilla similar hoy, podemos usar principios similares.  Por ejemplo, configure la zona DNS interna asignando nombres de servicio a direcciones en <code>127.0.0.0/8</code> .  Luego ejecute HAProxy en cada nodo del cl√∫ster, acepte conexiones a cada direcci√≥n de servicio ( <code>127.0.0.0/8</code> en esta subred) y redirija / equilibre la carga a los backends correspondientes.  La configuraci√≥n de HAProxy se puede controlar mediante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">confd</a> , lo que le permite almacenar informaci√≥n de back-end en etcd o Consul y enviar autom√°ticamente la configuraci√≥n actualizada a HAProxy cuando sea necesario. <br><br>  ¬°As√≠ es como funciona Istio!  Pero con algunas diferencias: <br><br><ul><li>  Utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Envoy Proxy en</a> lugar de HAProxy. <br></li><li>  Guarda la configuraci√≥n de back-end a trav√©s de la API de Kubernetes en lugar de etcd o Consul. <br></li><li>  Los servicios son direcciones asignadas en la subred interna (direcciones Kubernetes ClusterIP) en lugar de 127.0.0.0/8. <br></li><li>  Tiene un componente opcional (Ciudadela) para agregar autenticaci√≥n mutua TLS entre el cliente y los servidores. <br></li><li>  Admite nuevas funciones como interrupci√≥n de circuitos, rastreo distribuido, despliegue de canarios, etc. </li></ul><br>  Echemos un vistazo r√°pido a algunas de las diferencias. <br><br><h3>  Enviado proxy </h3><br>  Enftoy Proxy fue escrito por Lyft [competidor de Uber en el mercado de taxis - aprox.  trans.].  Es muy similar a otros servidores proxy en muchos sentidos (por ejemplo, HAProxy, Nginx, Traefik ...), pero Lyft escribi√≥ el suyo porque necesitaban funciones que no est√°n en otros servidores proxy, y parec√≠a m√°s razonable hacer uno nuevo que expandir el existente. <br><br>  Enviado se puede usar solo.  Si tengo un servicio espec√≠fico que deber√≠a conectarse a otros servicios, puedo configurarlo para que se conecte a Envoy, y luego configurar y reconfigurar din√°micamente Envoy con la ubicaci√≥n de otros servicios, mientras recibo muchas caracter√≠sticas adicionales excelentes, por ejemplo, visibilidad.  En lugar de una biblioteca de cliente personalizada o incrustar el seguimiento de llamadas en el c√≥digo, dirigimos el tr√°fico a Envoy y recopila m√©tricas para nosotros. <br><br>  Pero Envoy tambi√©n puede funcionar como un plano de datos para una malla de servicio.  Esto significa que para esta malla de servicios, Envoy ahora est√° configurado <i>por el</i> plano de control. <br><br><h3>  Plano de control </h3><br>  En el plano de gesti√≥n, Istio se basa en la API de Kubernetes.  <i>Esto no es muy diferente de usar confd</i> , que se basa en etcd o Consul para ver un conjunto de claves en un almac√©n de datos.  Istio, a trav√©s de la API de Kubernetes, visualiza el conjunto de recursos de Kubernetes. <br><br>  <i>Entre los casos</i> : personalmente encontr√© <a href="">√∫til</a> esta <a href="">descripci√≥n de la API de Kubernetes</a> , que dice: <br><br><blockquote>  El Servidor API de Kubernetes es un "servidor tonto" que ofrece almacenamiento, control de versiones, verificaci√≥n, actualizaci√≥n y sem√°ntica de los recursos API. </blockquote><br>  Istio est√° dise√±ado para trabajar con Kubernetes;  y si desea usarlo fuera de Kubernetes, debe ejecutar una instancia del servidor API de Kubernetes (y el servicio auxiliar, etc.). <br><br><h3>  Direcciones de servicio </h3><br>  Istio se basa en las direcciones de ClusterIP que Kubernetes asigna, por lo que los servicios de Istio obtienen una direcci√≥n interna (no en el rango <code>127.0.0.0/8</code> ). <br><br>  El tr√°fico a la direcci√≥n de ClusterIP para un servicio espec√≠fico en el cl√∫ster de Kubernetes sin Istio es interceptado por kube-proxy y enviado a la parte del servidor de este proxy.  Si est√° interesado en los detalles t√©cnicos, entonces kube-proxy establece las reglas de iptables (o equilibradores de carga IPVS, dependiendo de c√≥mo lo configure) para reescribir las direcciones IP de destino de las conexiones que van a la direcci√≥n ClusterIP. <br><br>  Despu√©s de instalar Istio en el cl√∫ster de Kubernetes, nada cambia hasta que se activa expl√≠citamente para el consumidor dado o incluso para todo el espacio de nombres al introducir el contenedor del <code>sidecar</code> en hogares personalizados.  Este contenedor iniciar√° una instancia de Envoy y establecer√° una serie de reglas de iptables para interceptar el tr√°fico a otros servicios y redirigir ese tr√°fico a Envoy. <br><br>  Cuando se integra con Kubernetes DNS, esto significa que nuestro c√≥digo puede conectarse por el nombre del servicio, y todo "simplemente funciona".  En otras palabras, nuestro c√≥digo emite solicitudes como <code>http://api/v1/users/4242</code> , luego <code>api</code> resuelve la solicitud a <code>10.97.105.48</code> , las reglas de iptables interceptan conexiones desde 10.97.105.48 y las redirigen al proxy local de Envoy, y este proxy local dirigir√° solicitud de la API de back-end real.  Fuh! <br><br><h3>  Cositas extra </h3><br>  Istio tambi√©n proporciona encriptaci√≥n y autenticaci√≥n de extremo a extremo a trav√©s de mTLS (TLS mutuo).  El componente llamado <i>Ciudadela</i> es responsable de esto. <br><br>  Tambi√©n hay un componente de <i>Mezclador</i> que Envoy puede solicitar para <i>cada</i> solicitud para tomar una decisi√≥n especial sobre esta solicitud, dependiendo de varios factores, como encabezados, carga de back-end, etc. (no se preocupe: hay muchas maneras de asegurarse de que el Mezclador funcione, e incluso si se bloquea, Envoy continuar√° funcionando normalmente como un proxy). <br><br>  Y, por supuesto, mencionamos la visibilidad: Envoy recopila una gran cantidad de m√©tricas, al tiempo que proporciona un seguimiento distribuido.  En la arquitectura de microservicios, si una solicitud de API debe pasar por los microservicios A, B, C y D, cuando inicie sesi√≥n en el sistema, la traza distribuida agregar√° un identificador √∫nico a la solicitud y guardar√° este identificador a trav√©s de subconsultas en todos estos microservicios, lo que le permitir√° registrar todas las llamadas relacionadas, sus retrasos, etc. <br><br><h1>  Desarrollar o comprar </h1><br>  Istio tiene fama de ser un sistema complejo.  En contraste, construir una cuadr√≠cula de enrutamiento, que describ√≠ al principio de esta publicaci√≥n, es relativamente simple usando las herramientas existentes.  Entonces, ¬øtiene sentido crear su propia malla de servicio? <br><br>  Si tenemos necesidades modestas (no necesita visibilidad, un disyuntor y otras sutilezas), entonces pensamos en desarrollar su propia herramienta.  Pero si usamos Kubernetes, puede que ni siquiera sea necesario, porque Kubernetes ya proporciona herramientas b√°sicas para el descubrimiento de servicios y el equilibrio de carga. <br><br>  Pero si tenemos requisitos avanzados, entonces "comprar" una malla de servicio parece ser una opci√≥n mucho mejor.  (Esto no siempre es una "compra", porque Istio viene con c√≥digo fuente abierto, pero a√∫n necesitamos invertir tiempo de ingenier√≠a para comprender su trabajo, implementarlo y administrarlo). <br><br><h1>  ¬øQu√© elegir: Istio, Linkerd o Consul Connect? </h1><br>  Hasta ahora solo hemos hablado de Istio, pero este no es el √∫nico servicio de malla.  Una alternativa popular es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Linkerd</a> , y tambi√©n hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Consul Connect</a> . <br><br>  Que elegir <br><br>  Honestamente, no lo se.  Por el momento, no me considero lo suficientemente competente como para responder a esta pregunta.  Hay algunos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interesantes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">que</a> comparan estas herramientas e incluso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puntos de referencia</a> . <br><br>  Un enfoque prometedor es utilizar una herramienta como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SuperGloo</a> .  Implementa una capa de abstracci√≥n para simplificar y unificar las API proporcionadas por las mallas de servicio.  En lugar de estudiar API espec√≠ficas (y, en mi opini√≥n, relativamente complejas) de varias mallas de servicio, podemos usar construcciones SuperGloo m√°s simples, y cambiar f√°cilmente de una a otra, como si tuvi√©ramos un formato de configuraci√≥n intermedio que describa interfaces HTTP y backends capaces de generar la configuraci√≥n real para Nginx, HAProxy, Traefik, Apache ... <br><br>  Me entretuve un poco con Istio y SuperGloo, y en el pr√≥ximo art√≠culo quiero mostrar c√≥mo agregar Istio o Linkerd a un cl√∫ster existente usando SuperGloo, y cu√°nto podr√° hacer frente este √∫ltimo a su trabajo, es decir, le permite cambiar de una malla de servicio a otra sin reescribir las configuraciones. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453204/">https://habr.com/ru/post/453204/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453182/index.html">Todo el mundo en tu bolsillo o c√≥mo hacer una tarjeta m√≥vil en un par de d√≠as</a></li>
<li><a href="../453188/index.html">C√≥mo explicar a los gerentes que no son de TI los principios para construir una infraestructura de TI tolerante a fallas</a></li>
<li><a href="../453194/index.html">Resolvemos el problema del mejor inversor con PHDays 9</a></li>
<li><a href="../453196/index.html">Forrester Research: una comparaci√≥n de los diez principales proveedores de an√°lisis de composici√≥n de software</a></li>
<li><a href="../453200/index.html">Discusi√≥n: el proyecto OpenROAD pretende resolver la tarea de automatizar el dise√±o de procesadores</a></li>
<li><a href="../453206/index.html">Entrevista con Kelsey Moody: c√≥mo construir una empresa y poner fin a las patolog√≠as relacionadas con la edad</a></li>
<li><a href="../453212/index.html">Consumer Reports: el √∫ltimo piloto autom√°tico de Tesla est√° lejos de ser perfecto</a></li>
<li><a href="../453214/index.html">C√≥mo y por qu√© mantenerse en forma si es una persona de TI en un sitio remoto</a></li>
<li><a href="../453216/index.html">Sistemas de monitoreo de tr√°fico en redes VoIP. Segunda parte - Principios de organizaci√≥n</a></li>
<li><a href="../453218/index.html">Lo principal con YaC 2019: cien drones en las carreteras, Yandex.M√≥dulo, comida, casa inteligente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>