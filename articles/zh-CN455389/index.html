<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌕 👌🏽 🤛🏻 Haxe 4：新功能？ 👖 🃏 🛀🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我提请您注意亚历山大·库兹曼科 （ Alexander Kuzmenko） （自今年4月起正式担任Haxe编译器的开发人员）关于自Haxe 3.4发行以来Haxe语言发生的更改的报告的译文 。 



 自Haxe 3.4发布以来已经过去了两年半。 在此期间，发布了7个修补程序版本，5个Haxe 4...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haxe 4：新功能？</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455389/"><p> 我提请您注意<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">亚历山大·库兹曼科</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alexander Kuzmenko）</a> （自今年4月起正式担任Haxe编译器的开发人员）关于自Haxe 3.4发行以来Haxe语言发生的更改的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告的译文</a> 。 </p><br><img src="https://habrastorage.org/webt/0m/0e/mw/0m0emw609dcl9ycql2oa069lzfu.jpeg" alt="图片"><br><p> 自Haxe 3.4发布以来已经过去了两年半。 在此期间，发布了7个修补程序版本，5个Haxe 4预览版本和2个Haxe 4候选发布版本，距离新版本还有很长的路要走，并且几乎已经准备就绪（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">大约有20个问题</a>需要解决）。 </p><a name="habracut"></a><br><img src="https://habrastorage.org/webt/jh/wp/7_/jhwp7_vztjntd_31hhmpqqreabe.png" alt="很久以前..."><br><p>  Alexander感谢Haxe社区报告了bug，并希望参与该语言的开发。 由于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">haxe-evolution项目</a> ，类似以下内容将出现在Haxe 4中： </p><br><ul><li> 内联标记 </li><li> 在呼叫位置内联函数 </li><li> 箭头功能 </li></ul><br><img src="https://habrastorage.org/webt/kn/qf/fu/knqffu_thrc2godjucb5t4izbt0.png" alt="图片"><br><p> 另外，在该项目的框架内，还对以下可能的创新进行了讨论： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Promises</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">polymorphic this</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">default type</a> （默认类型参数）。 </p><br><p> 接下来，亚历山大谈到<b>了语言语法的变化</b> 。 </p><br><img src="https://habrastorage.org/webt/pg/jn/sy/pgjnsymvkyhlespf0rcj-dw6j8s.png" alt="描述函数类型的新语法"><br><p>第一个是用于描述函数类型语法的新语法。 旧的语法有点奇怪。 <br>  Haxe是一种多范式编程语言，始终支持一流的功能，但是用于描述函数类型的语法是从功能语言继承的（与其他范式不同）。 而且熟悉函数式编程的程序员希望使用这种语法的函数来支持自动循环。 但是在Haxe中并非如此。 <br> 据亚历山大说，旧语法的主要缺点是无法确定参数的名称，这就是为什么必须编写带有参数说明的长注释注释的原因。 <br> 但是现在我们有了一种用于描述函数类型的新语法（顺便说一句，它是作为haxe-evolution倡议的一部分添加到该语言中的），存在这样的机会（尽管这是可选的，但建议使用）。 新语法更易于阅读，甚至可以视为代码文档的一部分。 <br> 用于描述函数类型的旧语法的另一个缺点是它<code>Void-&gt;Void</code> -即使函数不接受任何参数，也需要指定函数参数的类型： <code>Void-&gt;Void</code> （此函数不带参数也不返回任何内容）。 <br> 在新语法中，这实现得更加优雅： <code>()-&gt;Void</code> </p><br><img src="https://habrastorage.org/webt/xv/nr/fq/xvnrfqcbcxakqrci6y_p1hibh_4.png" alt="箭头功能"><br><p> 第二个是箭头函数或lambda表达式-描述匿名函数的缩写。 社区一直在要求将它们添加到语言中，终于发生了！ <br> 在此类函数中， <code>-&gt;</code>字符序列<code>-&gt;</code>而不是<code>return</code>关键字（因此语法名称为“箭头功能”）。 <br> 在新语法中，仍然可以设置参数的类型（因为自动类型推断系统无法始终按照程序员希望的方式执行此操作，例如，编译器可以决定使用<code>Float</code>而不是<code>Int</code> ）。 <br> 新语法的唯一限制是无法显式设置返回类型。 如有必要，则可以选择使用旧语法或在函数主体中使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">check-type语法</a> ，这将告诉编译器返回类型。 </p><br><img src="https://habrastorage.org/webt/wh/ri/-8/whri-8d5u0nvjgkiybnrjp1vrag.png" alt="箭头函数在语法树中没有特殊表示"><br><p> 箭头函数在语法树中没有特殊表示；它们的处理方式与常规匿名函数相同。 序列<code>-&gt;</code>被<code>return</code>关键字替换。 </p><br><img src="https://habrastorage.org/webt/nd/8c/kt/nd8cktem7lhra7ll-qao6hdatva.png" alt="最终-现在是关键字"><br><p> 第三个更改-final现在已成为关键字（在Haxe 3中<code>final</code>是内置在编译器中的meta标签之一）。 <br> 如果将其应用于类，它将禁止从其继承，这同样适用于接口。 将<code>final</code>限定符应用于类方法将防止其在子类中被覆盖。 <br> 但是，在Haxe中，有一种方法可以解决由<code>final</code>关键字施加的限制-您可以为此使用<code>@:hack</code> meta标签（但是，仅在绝对必要的情况下才应这样做）。 </p><br><img src="https://habrastorage.org/webt/ec/v3/mp/ecv3mpajsnrn6kxkrwx3rwkqlwe.png" alt="在匿名结构中声明可选字段"><br><p> 第四个更改是在匿名结构中声明可选字段的方法。 以前， <code>@:optional</code>元标记用于此目的，现在只需在字段名称前面添加问号。 </p><br><img src="https://habrastorage.org/webt/r8/i3/qb/r8i3qbo2r2seeqtyns2yhsbr5r8.png" alt="摘要清单"><br><p> 第五，抽象枚举已成为Haxe类型家族的正式成员，现在使用<code>@:enum</code>关键字代替<code>@:enum</code> meta标签。 </p><br><img src="https://habrastorage.org/webt/ew/b3/xt/ewb3xtnkjr_fdk4jtcdj-ezboao.png" alt="关键字外部"><br><p> 类似的变化影响了<code>@:extern</code>元标记。 </p><br><img src="https://habrastorage.org/webt/pb/g3/ip/pbg3ipuxlefguxcw5m-2qybtuqq.png" alt="类型联合（类型交集）的新语法"><br><p> 第七是一种新型的交集语法，可以更好地反映扩展结构的本质。 <br> 相同的新语法用于限制类型参数约束；它可以更准确地传达对类型施加的约束。 对于不熟悉Haxe的人，可以将旧语法<code>MyClass&lt;T:(Type1, Type2)&gt;</code>视为将参数<code>T</code>的类型设置为<code>Type1</code>或<code>Type2</code> 。 新语法明确告诉我们<code>T</code>必须同时为<code>Type1</code>和<code>Type2</code> 。 </p><br><img src="https://habrastorage.org/webt/e9/un/cj/e9uncj0a6tk4uh0keuuopuwokgy.png" alt="声明空字典的简化语法"><br><p> 第八种能力是使用<code>[]</code>声明一个空的<code>Map</code>容器的能力（但是，如果您未显式指定变量的类型，则在这种情况下，编译器会将类型输出为数组）。 </p><br><p> 讨论了语法的变化之后，让我们继续介绍<b>该语言中</b>的<b>新功能</b> 。 <br> 让我们从新的键值迭代器开始 </p><br><img src="https://habrastorage.org/webt/gw/sg/3v/gwsg3vpv6qco2n61v4zxh0dfzvw.png" alt="键值迭代器"><br><p> 已添加新语法供其使用。 <br> 为了支持此类迭代器，该类型必须实现<code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code>方法<code>keyValueIterator():KeyValueIterator&lt;K, V&gt;</code>或<code>hasNext():Bool</code>方法<code>hasNext():Bool</code>和<code>next():{key:K, value:V}</code> 。 同时，类型<code>KeyValueIterator&lt;K, V&gt;</code>是匿名结构<code>Iterator&lt;{key:K, value:V}&gt;</code>常规迭代器的同义词。 <br> 已从Haxe标准库（ <code>String</code> ， <code>Map</code> ， <code>DynamicAccess</code> ）中为某些类型实现键值迭代器，并且正在为数组实现它们。 </p><br><img src="https://habrastorage.org/webt/67/-f/g0/67-fg0qimh9gu7b8qvkaazjf4ti.png" alt="支持内置类型的新迭代器"><br><p> 对于字符串，将字符串中的字符索引用作键，并将给定索引处的字符代码用作值（如果需要字符本身，则可以使用<code>String.fromCharCode()</code>方法）。 <br> 对于<code>Map</code>容器，新的迭代器的工作方式与旧的迭代方法相同，即，它在容器中接收一个键数组，并通过它，从而为每个键请求值。 <br> 对于<code>DynamicAccess</code> （匿名对象的包装器），迭代器使用反射工作（使用<code>Reflect.fields()</code>方法获取对象的字段列表，并使用<code>Reflect.fields()</code>方法按名称获取字段值）。 </p><br><img src="https://habrastorage.org/webt/ml/u7/qj/mlu7qjpnq86muxduteld_riofzu.png" alt="新的宏解释器"><br><p>  Haxe 4使用了全新的宏解释器“ eval”。 口译的作者西蒙·克拉耶夫斯基（Simon Krajewski） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Haxe官方博客</a>以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">去年的进度报告</a>中对此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">进行</a>了详细描述。 <br> 口译员工作的主要变化： </p><br><ul><li> 它比旧的宏解释器快几倍（平均四倍） </li><li> 支持交互式调试（以前，对于宏，只能使用控制台输出） </li><li> 它用于在解释器模式下运行编译器（以前使用neko。顺便说一句，eval在速度上也超过了neko）。 </li></ul><br><img src="https://habrastorage.org/webt/f3/ef/e8/f3efe8ko9czu8tdyo5kzjswkfto.png" alt="Unicode支持"><br><p> 对所有平台（neko除外）的Unicode支持是Haxe 4中最大的变化之一。西蒙<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在去年</a>详细<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讨论了这一点</a> 。 但是，这是Haxe中Unicode字符串支持的当前状态的简要概述： </p><br><ul><li> 对于Lua，PHP，Python和eval（宏解释器），实现了完全的Unicode支持（UTF8编码） </li><li> 对于其他平台（JavaScript，C＃，Java，Flash，HashLink和C ++），使用UTF16编码。 </li></ul><br><p> 因此，Haxe中的线条对于包含在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多语言主平面</a>中的字符的工作方式相同，但是对于该平面之外的字符（例如，表情符号），根据平台使用线条的代码可以产生不同的结果（但这仍然更好，而不是Haxe 3中的情况，当时每个平台都有自己的行为）。 </p><br><img src="https://habrastorage.org/webt/5o/o2/fp/5oo2fp2s4h2t9rpqnvfyrbwb7gs.png" alt="新的字符串迭代器"><br><p> 对于Unicode编码的字符串（在UTF8和UTF16中都是），已向Haxe标准库添加了特殊的迭代器，该迭代器在所有平台上对所有字符（在主要多语言平面内及以后）均适用： </p><br><pre> <code class="plaintext hljs">haxe.iterators.StringIteratorUnicode haxe.iterators.StringKeyValueIteratorUnicode</code> </pre> <br><img src="https://habrastorage.org/webt/3k/zv/xu/3kzvxup9p5crewap3u76tnfqhlg.png" alt="Unicode支持的功能"><br><p> 由于字符串的实现因平台而异，因此有必要牢记其工作的某些细微差别。 在UTF16中，每个字符占用2个字节，因此按索引访问字符串中的字符很快，但是只能在主多语言平面内进行。 另一方面，在UTF8中支持所有字符，但这是以缓慢搜索字符串中的字符为代价的（由于字符可以占用内存中不同数量的字节，因此按索引访问字符需要从头开始每次都在行中进行迭代）。 因此，在Lua和PHP中使用大型字符串时，需要记住访问任意字符的速度非常慢（同样在这些平台上，每次都会再次计算字符串长度）。 <br> 但是，尽管声明了对Python的完全Unicode支持，但此限制并不适用于它，因为其中的行以略有不同的方式实现：对于主多语言平面内的字符，它使用UTF16编码，而对于较宽的字符（3和更多字节）Python使用UTF32。 <br> 为eval宏解释器实现了其他优化：字符串“知道”它是否包含Unicode字符。 如果它不包含此类字符，则该字符串将被解释为由ASCII字符组成（每个字符占1个字节）。 还优化了eval中按索引的顺序访问：最后访问的字符的位置缓存在该行中。 因此，如果您首先转向字符串中的第10个字符，那么当您下次转向第20个字符时，eval并不是从行的开头而是从第10个开始寻找它。 另外，将缓存eval中的字符串长度，即仅在第一个请求时才计算得出。 </p><br><img src="https://habrastorage.org/webt/je/gi/ne/jegineguad8fp4dlqyhfbboxy8c.png" alt="命名空间对编译标志的支持"><br><p>  Haxe 4引入了对用于编译标志的名称空间的支持，这对于例如在编写自定义库时组织代码很有用。 <br> 同样，出现了用于编译标志的保留名称空间-target，编译器使用它来描述目标平台及其行为： </p><br><ul><li>  <code>target.name</code>平台名称（js，cpp，php等） </li><li>  <code>target.utf16</code>表示使用UTF16实现Unicode支持 </li><li>  <code>target.sys</code>指示sys软件包中的类是否可用（例如，用于文件系统） </li><li>  <code>target.static</code>指示平台是否为静态（在静态平台上，基本类型<code>Int</code> ， <code>Float</code>和<code>Bool</code>的值不能为<code>null</code> ） </li><li>  <code>target.threaded</code>指示平台是否支持多线程 </li></ul><br><img src="https://habrastorage.org/webt/qt/ue/c_/qtuec_vbswkwgylwnidy9xuaeou.png" alt="命名空间对元标记的支持"><br><p> 同样，出现了对元标记的名称空间支持。 到目前为止，该语言还没有为元标记保留的命名空间，但是这种情况将来可能会改变。 </p><br><img src="https://habrastorage.org/webt/cc/yj/ye/ccyjyemwz1ti9vgddvccyu4iqeq.png" alt="新型-ReadOnlyArray"><br><p>  <code>ReadOnlyArray</code>类型添加到Haxe标准库中-常规数组的抽象，其中常规方法仅可用于从数组中读取数据。 </p><br><img src="https://habrastorage.org/webt/jr/ia/2o/jria2ovebta0bwm-lezr7jvv7ao.png" alt="最终字段和局部变量"><br><p> 语言的另一项创新是最终领域和局部变量。 <br> 如果在声明类字段或局部变量时使用<code>final</code>而不是<code>var</code>关键字，则这意味着无法重新分配给定的字段或变量（如果编译器尝试执行此操作，则将引发错误）。 但是同时，它的状态可以更改，因此最终字段或变量不是常量。 </p><br><img src="https://habrastorage.org/webt/j-/8u/f9/j-8uf9asp_ivqbxn8kypatexma0.png" alt="编译器控制最终字段的初始化"><br><p>  final字段的值必须在声明时或在构造函数中初始化，否则编译器将引发错误。 </p><br><img src="https://habrastorage.org/webt/2h/yd/wi/2hydwitcbuwstefblzdr09sxqzk.png" alt="哈希链接"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HashLink</a>是一个具有自己的虚拟机的新平台，专门为Haxe创建。  HashLink支持所谓的“双重编译”-代码可以以字节码（速度非常快，可加快开发应用程序的调试过程）或C代码（以提高性能为特征）进行编译。 尼古拉斯将HashLink专门用于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Haxe的</a>几篇<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客文章，</a>并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在去年</a>的西雅图<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">会议上</a>谈到了他。  HashLink技术用于诸如Dead Cells和Northgard之类的流行游戏。 </p><br><img src="https://habrastorage.org/webt/zy/a4/eh/zya4eh5l7t3zqihviw5qvtcrsfc.png" alt="空安全"><br><p>  Haxe 4的另一个新的有趣功能是Null安全性，它仍处于试验阶段（由于误报和代码安全性检查不足）。 <br> 什么是空安全性？ 如果您的函数没有明确声明它可以接受<code>null</code>作为参数值，那么当您尝试向其传递<code>null</code>时，编译器将抛出相应的错误。 此外，对于可以将<code>null</code>作为值的函数参数，编译器将要求您编写其他代码以验证和处理这种情况。 <br> 默认情况下，此功能是禁用的，但是它不会影响代码执行的速度（如果仍然启用），因为所描述的检查仅在编译阶段执行。 可以为所有代码启用它，也可以为单个字段，类和包逐渐启用它（从而提供了向更安全代码的逐步过渡）。 您可以为此使用特殊的元标记和宏。 <br> 可以使用Null-security的模式有： <code>Strict</code> （最严格）， <code>Loose</code> （默认模式）和<code>Off</code> （用于禁用对单个程序包和类型的检查）。 </p><br><img src="https://habrastorage.org/webt/mn/9l/jh/mn9ljhu2_wwwonpjo7qhcoiasyw.png" alt="标准空安全检查模式"><br><p> 对于幻灯片上显示的功能，启用了Null安全检查。 我们看到这个函数有一个可选参数<code>s</code> ，也就是说，我们可以将<code>null</code>作为参数值传递给它。 尝试使用此类函数编译代码时，编译器将产生许多错误： </p><br><ul><li> 尝试访问对象<code>s</code>某些字段时（因为它可能为<code>null</code> ） </li><li> 尝试分配变量str时，如我们所见，该变量不应为<code>null</code> （否则，我们应将其声明为<code>String</code> ，而不是<code>Null&lt;String&gt;</code> ） </li><li> 尝试从函数返回对象<code>s</code> （因为该函数不应返回<code>null</code> ） </li></ul><br><p> 如何解决这些错误？ </p><br><img src="https://habrastorage.org/webt/ku/w-/l8/kuw-l8prqna5xq7c21ushemgtqs.png" alt="修复null安全错误"><br><p> 我们只需要向代码中添加<code>null</code>检查（在具有<code>null</code>检查的代码块内，编译器“知道” <code>s</code>不能为<code>null</code>并可以安全地使用它），并且还要确保该函数不会返回<code>null</code> ！ </p><br><img src="https://habrastorage.org/webt/x1/xj/jp/x1xjjpwn8ikrulbtulxj_iixlq4.png" alt="在执行Null安全性检查时，编译器会考虑程序的执行顺序"><br><p> 另外，在执行Null安全性检查时，编译器会考虑程序执行的顺序。 例如，如果在将参数<code>s</code>的值检查为null以终止函数（或引发异常）之后，编译器将“知道”在执行此检查后，参数<code>s</code>不再可以为<code>null</code> ，并且可以安全地使用它。 </p><br><img src="https://habrastorage.org/webt/6f/vq/cj/6fvqcjbu-dixmrxcfuwtd8mskvk.png" alt="严格模式用于执行null安全检查"><br><p> 如果编译器启用了严格的Null安全性检查模式，则在初始检查<code>null</code>与尝试访问对象字段之间执行任何可能将其设置为<code>null</code>代码之间的情况下，它将要求对<code>null</code>进行其他检查。 。 </p><br><img src="https://habrastorage.org/webt/ci/6m/u4/ci6mu4zsvkdjf33vvbetz30mf2m.png" alt="用于执行空安全性检查的宽松模式"><br><p> 在松散模式（默认情况下使用）下，编译器将不需要进行此类检查（顺便说一下，默认情况下TypeScript中也使用此行为）。 </p><br><img src="https://habrastorage.org/webt/je/wo/5q/jewo5qwzmavidsf-jss4bwug79i.png" alt="在执行检查空安全性时检查字段的初始化"><br><p> 另外，打开Null安全性检查时，编译器将检查类中的字段是否已初始化（直接在声明它们时或在构造函数中）。 否则，在尝试传递此类对象以及尝试在此类对象上调用方法时，编译器将引发错误，直到初始化该对象的所有字段为止。 可以通过使用元标记<code>@:nullSafety(Off)</code>标记类的各个字段来关闭此类检查。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">去年10月，</a>亚历山大（Alexander）进一步<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">谈论</a>了Haxe中的Null安全性。 </p><br><img src="https://habrastorage.org/webt/ui/f3/za/uif3zavird4vri76gqfiaukfsxo.png" alt="为JavaScript生成ES6类"><br><p>  Haxe 4引入了为JavaScript生成ES6类的功能；使用编译标志<code>js-es=6</code>启用了该功能。 </p><br><img src="https://habrastorage.org/webt/z7/5c/ow/z75cowptrmqn5bxfa7oerxkxsro.png" alt="就地功能"><br><p> 调用位置的嵌入功能（调用站点内联）提供了更多选项来控制代码性能和大小之间的平衡。  Haxe标准库中也使用了此功能。 <br> 她是什么样的人？ 它允许您仅在需要确保高性能的那些位置（例如，如有必要，在循环中调用足够大的方法）中嵌入函数体（使用<code>inline</code> ），而在其他地方未嵌入函数体。 结果，所生成代码的大小将略有增加。 </p><br><img src="https://habrastorage.org/webt/ke/0y/wf/ke0ywfco0j5pbynruiqr4mgqhxw.png" alt="自动扩展类型"><br><p> 自动使用（类型的自动扩展）意味着现在对于类型，您可以在类型声明的位置声明静态扩展。 这消除了每次使用use <code>using type;</code>构造的需要<code>using type;</code> 在每个使用类型和扩展方法的模块中。 目前，这种扩展仅用于传输，但是在最终发行版（和夜间构建）中，它不仅可以用于传输。 </p><br><img src="https://habrastorage.org/webt/ru/ts/6s/ruts6snzqmgjdbx1g0kmjc92oxw.png" alt="覆盖运算符以访问对象的字段"><br><p> 在Haxe 4中，可以重新定义用于访问抽象类型的对象字段的运算符（仅针对该类型中不存在的字段）。 为此，请使用标有<code>@:op(ab)</code>元标记的方法。 </p><br><img src="https://habrastorage.org/webt/qv/fu/fj/qvfufjhriheejf1q6i0epu82pw8.png" alt="内置标记"><br><p> 内置标记是Haxe的另一个实验功能。 内置标记代码没有被编译器作为xml文档处理-编译器将其视为包装在<code>@:markup</code>元标记中的字符串。           . </p><br><img src="https://habrastorage.org/webt/ms/an/zi/msanzicye9bpsmkbw55m6zcs34a.png" alt="   "><br><p>    -,   - <code>@:markup</code>    ,     . </p><br><img src="https://habrastorage.org/webt/pg/ek/2w/pgek2wa4v-ocjxauyq6e9oopvfc.png" alt="      untyped-"><br><p>               (  <code>untyped</code> ).           . ,   ,  <code>Js.build()</code>     - <code>@:markup</code>     ,        <code>&lt;js&gt;</code> ,     js-. </p><br><img src="https://habrastorage.org/webt/gk/vd/1f/gkvd1f3duuldpzde1zmmgvwbkza.png" alt=" -  - "><br><p>  Haxe 4     -  - ,    —       . </p><br><img src="https://habrastorage.org/webt/br/gp/0c/brgp0cim1eozg7jjcopjmtx1xys.png" alt="     "><br><p>       .  ,        .   ,   <code>Int</code> ,      ,    C. </p><br><img src="https://habrastorage.org/webt/cj/3g/lf/cj3glfbn9l5owjjunjtrsn2jzvw.png" alt="     "><br><p>         —       . </p><br><p> <b>     :</b> </p><br><img src="https://habrastorage.org/webt/y4/hl/fw/y4hlfwwz_db02rgmsj4f1jgw6r8.png" alt=" JVM- "><br><p>    JVM-   JDK,            Java-.    .         . </p><br><img src="https://habrastorage.org/webt/wj/ut/_z/wjut_zypg87r1f508zovsks2dio.png" alt=""><br><p>      ,     <code>async</code> / <code>await</code>  <code>yield</code> .       (   C#,       ).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>     Haxe    github. </p><br><img src="https://habrastorage.org/webt/ou/7r/gh/ou7rghzmynbwwvah6l7rumqpl8i.png" alt=",    "><br><p>  Haxe  <a href="">,    </a> .     ( )     .        ,    . </p><br><img src="https://habrastorage.org/webt/ty/y4/xw/tyy4xwdn9olejstawrdlqbux_tu.png" alt=" API     "><br><p>       API     .     ,   ,    API    . </p><br><p>      Haxe 4  ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455389/">https://habr.com/ru/post/zh-CN455389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455375/index.html">用Pascal编写UDR</a></li>
<li><a href="../zh-CN455377/index.html">物联网架构</a></li>
<li><a href="../zh-CN455379/index.html">（静态）在C ++程序中选择最佳容器</a></li>
<li><a href="../zh-CN455381/index.html">3CX技术支持做出响应：在PBX服务器上捕获SIP通信</a></li>
<li><a href="../zh-CN455387/index.html">了解弹性堆栈中的机器学习（又名Elasticsearch，又名ELK）</a></li>
<li><a href="../zh-CN455391/index.html">第1部分：非自然栖息地中的RISC-V / RocketChip</a></li>
<li><a href="../zh-CN455393/index.html">关于雷达中频谱估计的参数方法的使用-MUSIC方法。 文章的补充</a></li>
<li><a href="../zh-CN455397/index.html">我们如何在莫斯科办公室的华为上设计和实现新网络，第1部分</a></li>
<li><a href="../zh-CN455401/index.html">简单示例中的Cisco IOS的​​Tcl</a></li>
<li><a href="../zh-CN455403/index.html">从五分钱到神灵游戏</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>