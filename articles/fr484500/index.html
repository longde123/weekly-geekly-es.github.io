<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦊 📼 🧚🏻 Script pour ajouter des serveurs à partir de Google Cloud pour configurer ssh 💆🏻 🙋🏾 ❇️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Annotation. Un article sur un script très simple qui forme une configuration pour ssh Linux à partir d'une liste de serveurs. Testé sur Ubuntu 18, uti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Script pour ajouter des serveurs à partir de Google Cloud pour configurer ssh</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484500/"><p>  Annotation.  Un article sur un script très simple qui forme une configuration pour ssh Linux à partir d'une liste de serveurs.  Testé sur Ubuntu 18, utilise le SDK Goodle Cloud, Python 2.7, Bash. </p><br><p>  Après une forte augmentation du nombre de serveurs avec lesquels je dois travailler, j'ai réalisé que le stockage des mots de passe et la CMDB ne fournissaient plus un accès opérationnel comme à l'époque où je me souvenais par cœur de toutes les adresses IP et détails.  Peut-être parce que CMDB nous ne l'avons pas encore maîtrisé.  Néanmoins, il est en quelque sorte nécessaire de résoudre le problème de l'accès rapide via SSH à un grand nombre de serveurs. </p><br><p>  Suivant - du point de vue du terminal Linux (effectué sur Ubuntu 18).  Peut-être que cela fonctionne dans d'autres distributions et, probablement, il y a même un analogue sur Windows - je n'ai pas regardé. </p><br><p>  Les principales exigences: </p><br><ul><li>  Facile à répéter.  Plusieurs administrateurs <br>  et vous devez pouvoir configurer la même chose pour tout le monde.  De plus, nous autorisons le travail à distance - au moins chaque ordinateur portable a une situation, mais il arrive que vous ne travailliez pas sur votre ordinateur habituel «réglé et débogué». </li><li>  Les serveurs sont ajoutés, supprimés et modifiés.  Cela devrait être pris en considération. </li></ul><br><p> Pour ce faire, j'ai décidé d'utiliser des hôtes d'alias dans les paramètres ssh, d'obtenir la liste des serveurs via le client gcloud cli GCP et d'automatiser tout cela à l'aide de Python 2.7 (car c'était par défaut dans Ubuntu et j'ai décidé de l'étudier pour travailler avec des données).  Le script lui-même avec une description sous la coupe. </p><a name="habracut"></a><br><h1 id="postanovka-zadachi">  Énoncé du problème </h1><br><p>  L'idée était la suivante: conserver une liste de la connexion des serveurs d'alias et de leurs adresses actuelles de telle sorte que seul un nom puisse être utilisé pour établir une connexion.  Dans le même temps, la liste elle-même est périodiquement mise à jour à partir de GCP par API. </p><br><p>  En conséquence, il y avait plusieurs tâches: </p><br><ol><li>  Se connecter à l'hôte en tapant uniquement un nom mémorable (nous formons généralement les noms selon des règles strictes, il suffit donc de connaître le client et le système pour deviner presque certainement le nom du serveur).  Les noms peuvent être réels (si le serveur est entièrement créé par nous) ou alias à l'intérieur de notre cmdb (si le serveur est créé par le client et que le nom est attribué selon les règles du client).  Dans tous les cas, se souvenir d'un nom est plus facile qu'une adresse.  L'adresse change également. </li><li>  Obtenir une liste des hôtes actuels avec des adresses valides.  Parce que  la plate-forme principale est GCP et 90% des serveurs là-bas, alors ce problème sera résolu via leur API, et non par des outils de surveillance. </li><li>  Recherche par nom d'hôte.  Bien qu'ils soient plus faciles à retenir, le nombre augmente et la mémoire n'est pas illimitée :) Oui, et les nouveaux administrateurs sont plus faciles. </li><li>  Mettre à jour le groupe d'alias - adresse uniquement lorsque l'adresse change.  Cela est nécessaire pour abandonner la réécriture complète de tous les bundles.  Cela permettra le stockage des bundles non seulement pour les serveurs GCP.  Jusqu'à présent, ce problème n'a pas été résolu :( </li></ol><br><h1 id="opisanie-resheniya">  Description de la solution </h1><br><h2 id="alias-dlya-podklyucheniya">  Alias ​​pour se connecter </h2><br><p>  Tout ici est assez simple et n'a pas été décidé par moi.  L'utilitaire Linux ssh prend en charge la configuration d'alias dans le fichier de configuration. </p><br><p>  Emplacement du fichier: ~ / .ssh / config </p><br><p>  Le format de fichier que nous avons utilisé est très banal, mais en fait les possibilités sont beaucoup plus larges: </p><br><pre><code class="plaintext hljs">HOST alias_ HostName ip__-</code> </pre> <br><p>  Vous pouvez en savoir plus sur les options de configuration <a href="https://linuxize.com/post/using-the-ssh-config-file/" rel="nofollow">ici</a> , <a href="https://www.cyberciti.biz/faq/create-ssh-config-file-on-linux-unix/" rel="nofollow">ici</a> ou dans la <a href="https://www.ssh.com/ssh/config" rel="nofollow">documentation officielle</a> . </p><br><h3 id="dalneyshie-shagi">  Etapes supplémentaires </h3><br><ol><li>  Utilisez différentes clés pour vous connecter à différents groupes d'hôtes.  Une petite paranoïa en termes de sécurité ne fera pas de mal. </li><li>  Fournissez une sauvegarde de ce fichier pour vous protéger contre les modifications accidentelles et mettre à jour les erreurs de script. </li></ol><br><h2 id="poisk-po-imenam-hostov">  Rechercher des noms d'hôtes </h2><br><p>  Ici, la décision ne m'appartient pas du tout, mais à <a href="https://ben.lobaugh.net/" rel="nofollow">Ben Lobaugh</a> et est décrite <a href="https://ben.lobaugh.net/blog/203195/quickly-list-all-hosts-in-your-ssh-config" rel="nofollow">dans son article</a> . <br>  En bref, j'ai utilisé sed, qui, pour faciliter le démarrage (une règle très longue dans les paramètres) était abrégé via alias: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> sshhosts=<span class="hljs-string"><span class="hljs-string">"sed -rn 's/^\s*HOST\s+(.*)\s*/\1/ip' ~/.ssh/config"</span></span></code> </pre> <br><p>  Si vous avez besoin de trouver l'hôte par la partie nom, alors ce script est parfaitement complété par l'utilitaire grep et en conséquence il se présente comme ceci: </p><br><pre> <code class="bash hljs">sshhost | grep <span class="hljs-string"><span class="hljs-string">'---'</span></span></code> </pre> <br><p>  Il existe d'autres options, par exemple, comme décrit <a href="https://www.jamesridgway.co.uk/blog/list-ssh-hosts-from-your-ssh-config" rel="nofollow">ici</a> . </p><br><h3 id="avtozapolnenie-imeni-hosta">  Saisie semi-automatique du nom d'hôte </h3><br><p>  <strong>Merci pour la solution <a href="https://habr.com/ru/users/onix74/" class="user_link">onix74</a> !</strong> <br>  Ajoutez la ligne à ~ / .bash_completion: </p><br><pre> <code class="bash hljs">complete -W <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(grep "^HOST " ~/.ssh/config | grep -v "\*" | sed 's/[^ ]* *\(.*\)/\1/')</span></span></span><span class="hljs-string">"</span></span> ssh</code> </pre> <br><p>  Pour la commande ssh, la saisie semi-automatique fonctionnera selon la liste des serveurs d'alias.  C'est-à-dire  Vous pouvez utiliser ssh pour remplacer le nom du serveur ssh.  Cela fonctionne en bash. <br></p><h3 id="dalneyshie-shagi-1">  Etapes supplémentaires </h3><br><p>  J'ai l'intention de diviser les hôtes en groupes afin que vous puissiez sélectionner tous les serveurs d'un client particulier ou avec une application spécifique.  Il semble que cette fonctionnalité sera intéressante pour l'exécution de scripts de masse et la connexion Ansible;  ainsi que pour créer différents détails de connexion pour différents groupes.  Mais combien il a vraiment de sens reste à voir. </p><br><h2 id="poluchit-spisok-hostov-iz-gcp">  Obtenir une liste d'hôtes de GCP </h2><br><p>  Dans cette étape, tout est assez simple, à l'exception des réglages des paramètres (bien qu'ici c'est une question d'expérience).  J'ai décidé d'utiliser le SDK GCloud pour obtenir des données, car  alors que je l'utilise rarement, mais je suppose que cela me permettra parfois d'utiliser de moins en moins l'interface graphique et de simplifier considérablement la routine d'administration.  Par conséquent, l'argument principal est d'acquérir de l'expérience. <br>  Probablement, la même chose pourrait être faite en utilisant curl et l'API GCP REST, puis la solution serait plus universelle (car les SDK GCloud nécessitent une installation et une initialisation distinctes, ce qui n'est pas si compliqué, mais est toujours requis). </p><br><p>  Pour obtenir les informations nécessaires, j'ai dû utiliser le format json.  Bien que cela ait grandement simplifié le traitement ultérieur de la réponse reçue, cela a fait réfléchir un peu à la définition des paramètres de formatage dans le SDK. <br>  En conséquence, j'ai reçu la commande suivante: </p><br><pre> <code class="bash hljs">gcloud compute instances list --filter=<span class="hljs-string"><span class="hljs-string">"status:running"</span></span> --format=<span class="hljs-string"><span class="hljs-string">"json(name, status, networkInterfaces[].accessConfigs[])"</span></span></code> </pre> <br><p>  Il ne renvoie que les serveurs actuellement actifs (cela n'a aucun sens de se connecter aux autres) avec des informations sur leur nom et leur interface réseau.  Jusqu'à présent, une seule interface externe est utilisée pour chaque serveur. </p><br><p>  Le résultat final arrive en json: </p><br><pre> <code class="json hljs">[ ---...---- { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"-"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"networkInterfaces"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"accessConfigs"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"compute#accessConfig"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"External NAT"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"natIP"</span></span>: <span class="hljs-string"><span class="hljs-string">"ip-"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"networkTier"</span></span>: <span class="hljs-string"><span class="hljs-string">"PREMIUM"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"ONE_TO_ONE_NAT"</span></span> } ] } ], <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"RUNNING"</span></span> }, ----...--- ]</code> </pre> <br><h3 id="dalneyshie-shagi-2">  Etapes supplémentaires </h3><br><p>  Trouvez un format dont la sortie réduira ou même éliminera le traitement ultérieur. </p><br><h2 id="skript-sozdaniya-spiska-alias-po-dannym-iz-gcp">  Script pour créer une liste d'alias basée sur les données de GCP </h2><br><p>  Le script a été écrit en python 2.7 pour deux raisons: </p><br><ol><li>  J'ai décidé de l'étudier pour travailler avec des données; </li><li>  python 2.7 est par défaut sur la plupart des systèmes exécutant linux - il n'y aura aucun problème à l'utiliser ailleurs.  Étant donné que même gagner maintenant vous permet de mettre un deuxième système et d'utiliser Ubuntu comme terminal. </li></ol><br><p>  L'algorithme est le suivant: </p><br><ol><li>  Nous obtenons la liste des serveurs du Google Cloud à l'aide du SDK, initiant l'exécution de la commande dans la console à partir de python. </li><li>  Nous analysons le JSON résultant en types compatibles avec Python. </li><li>  Nous donnons la sortie au format nécessaire à la configuration ssh (si nécessaire, la sortie du script est redirigée vers ~ / .ssh / config ou vers un fichier intermédiaire). </li></ol><br><div class="spoiler">  <b class="spoiler_title">Afficher le script</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python import commands import json sComputeListOutput = commands.getoutput('gcloud compute instances list --filter="status:running" --format="json(name, status, networkInterfaces[].accessConfigs[])" ') s = json.loads(sComputeListOutput) for server in s: print 'HOST ',server['name'] print ' HostName ',server['networkInterfaces'][0]['accessConfigs'][0]['natIP']</span></span></code> </pre> </div></div><br><h2 id="obnovlenie-tolko-izmenennyh-dannyh">  Mise à jour uniquement des données modifiées </h2><br><p>  Cette tâche est toujours en cours.  J'ai l'intention de lire le fichier ssh / config dans le même script, de le comparer avec les valeurs reçues, puis de réécrire l'ensemble du résultat.  Ou générez un nouveau fichier séparément et effectuez une comparaison en utilisant une sorte de diff - cela vous permettra de confirmer manuellement toutes les modifications. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484500/">https://habr.com/ru/post/fr484500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484486/index.html">Un ordinateur qui refuse de mourir</a></li>
<li><a href="../fr484488/index.html">À quel point un système quantique est-il déroutant? La réponse n'est peut-être pas calculable.</a></li>
<li><a href="../fr484492/index.html">Classe PHP pour télécharger et télécharger des fichiers sur le serveur</a></li>
<li><a href="../fr484496/index.html">Utilisation de Cura sur une imprimante SLA Photon 3D</a></li>
<li><a href="../fr484498/index.html">Un système d'IA avertit les piétons dans les écouteurs de l'approche d'une voiture</a></li>
<li><a href="../fr484502/index.html">Facebook oblige les modérateurs à documenter leurs heures de travail à la seconde - allant même aux toilettes</a></li>
<li><a href="../fr484504/index.html">Fabriquer un ioniseur d'air pour moins de 10 $</a></li>
<li><a href="../fr484506/index.html">Je suis photographe et je vais me faire un outil de travail</a></li>
<li><a href="../fr484512/index.html">TOP 25 des plus grandes ICO: qu'en est-il maintenant?</a></li>
<li><a href="../fr484514/index.html">Routage universel pour les applications React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>