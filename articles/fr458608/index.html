<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥑 🆙 🕯️ Outils de développement Node.js File d'attente des travaux 👴🏼 😩 🙃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de la mise en œuvre du back-end d'applications Web et d'applications mobiles, même les plus simples, il est devenu courant d'utiliser des outils ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Outils de développement Node.js File d'attente des travaux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458608/">  Lors de la mise en œuvre du back-end d'applications Web et d'applications mobiles, même les plus simples, il est devenu courant d'utiliser des outils tels que: bases de données, serveur de messagerie (smtp), serveur redis.  L'ensemble des outils utilisés est en constante expansion.  Par exemple, les files d'attente de messages, à en juger par le nombre d'installations du package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">amqplib</a> (650 000 installations par semaine), sont utilisées avec les bases de données relationnelles (package mysql 460 000 installations par semaine et pg 800 000 installations par semaine). <br><br>  Aujourd'hui, je veux parler des files d'attente de travaux, qui sont jusqu'à présent utilisées un ordre de grandeur de moins, bien que le besoin s'en fasse sentir, dans presque tous les projets réels. <br><a name="habracut"></a><br>  Ainsi, les files d'attente de travaux vous permettent d'effectuer certaines tâches de manière asynchrone, en fait, d'effectuer une fonction avec les paramètres d'entrée donnés et à l'heure définie. <br><br>  Selon les paramètres, la tâche peut être effectuée: <br><br><ul><li>  immédiatement après l'ajout à la file d'attente des travaux; </li><li>  une fois à une heure définie; </li><li>  plusieurs fois dans les délais. </li></ul><br>  Les files d'attente de travaux vous permettent de transférer des paramètres vers un travail en cours d'exécution, de suivre et de réexécuter les travaux qui ont échoué et de définir une limite sur le nombre de travaux qui s'exécutent simultanément. <br><br>  La grande majorité des applications sur Node.js sont associées au développement d'une API REST pour les applications Web et mobiles.  La réduction du temps d'exécution de l'API REST est importante pour un travail confortable de l'utilisateur avec l'application.  Dans le même temps, un appel à l'API REST peut lancer des opérations longues et / ou gourmandes en ressources.  Par exemple, après avoir effectué un achat, vous devez envoyer à l'utilisateur un message push vers l'application mobile ou envoyer une demande pour effectuer un achat sur l'API REST CRM.  Ces requêtes peuvent être effectuées de manière asynchrone.  Comment le faire correctement si vous ne disposez pas d'un outil pour travailler avec les files d'attente de travaux?  Par exemple, vous pouvez envoyer un message à la file d'attente de messages, démarrer un travailleur qui lira ces messages et effectuera le travail nécessaire en fonction de ces messages. <br><br>  En fait, c'est ce que font les files d'attente de travaux.  Cependant, si vous regardez attentivement, les files d'attente de travaux présentent plusieurs différences fondamentales par rapport à la file d'attente de messages.  Premièrement, les messages (statiques) sont placés dans la file d'attente de messages et les files d'attente de travaux impliquent une sorte de travail (appel de fonction).  Deuxièmement, la file d'attente des travaux implique la présence d'un processeur (travailleur) qui effectuera le travail donné.  Dans ce cas, des fonctionnalités supplémentaires sont nécessaires.  Le nombre de processeurs doit être mis à l'échelle de manière transparente en cas de charge accrue.  D'un autre côté, il est nécessaire de limiter le nombre de tâches exécutées simultanément sur un processeur-travailleur afin de lisser les charges de pointe et d'empêcher le déni de service.  Cela montre qu'il existe un besoin d'un outil qui pourrait exécuter des tâches asynchrones en définissant divers paramètres, aussi simple que de faire une demande en utilisant l'API REST (ou mieux si c'est encore plus facile). <br><br>  À l'aide de files d'attente de messages, il est relativement simple d'implémenter une file d'attente de travaux qui s'exécute immédiatement après la mise en file d'attente d'un travail.  Mais souvent, il est nécessaire de terminer la tâche une fois à une heure définie ou selon un calendrier.  Pour ces tâches, un certain nombre de packages sont largement utilisés qui implémentent la logique cron sous Linux.  Afin de ne pas être infondé, je dirai que le package node-cron a 480 000 installations par semaine, node-schedule - 170 000 installations par semaine. <br><br>  L'utilisation de node-cron est, bien sûr, plus pratique que l'ascétique setInterval (), mais personnellement, j'ai rencontré un certain nombre de problèmes lors de son utilisation.  Si pour exprimer un inconvénient général, c'est le manque de contrôle sur le nombre de tâches exécutées simultanément (cela stimule les pics de charge: l'augmentation de la charge ralentit le travail des tâches, le ralentissement des tâches augmente le nombre de tâches exécutées simultanément, ce qui à son tour charge encore plus le système), l'incapacité d'exécuter le nœud pour augmenter la productivité -cron sur plusieurs cœurs (dans ce cas, toutes les tâches sont exécutées indépendamment sur chaque cœur) et le manque d'outils pour suivre et redémarrer les tâches terminées  Xia avec une erreur. <br><br>  J'espère avoir montré que la nécessité d'un tel outil comme la file d'attente des travaux est comparable à des outils tels que les bases de données.  Et ces fonds sont apparus, bien qu'ils ne soient pas encore largement utilisés.  Je vais énumérer les plus populaires d'entre eux: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Nom du package </th><th>  Nombre d'installations par semaine </th><th>  Nombre de likes </th></tr><tr><td>  kue </td><td>  29190 </td><td>  8753 </td></tr><tr><td>  file d'attente des abeilles </td><td>  aucune information </td><td>  1431 </td></tr><tr><td>  agenda </td><td>  25459 </td><td>  5488 </td></tr><tr><td>  taureau </td><td>  56232 </td><td>  5909 </td></tr></tbody></table></div><br><br>  Aujourd'hui, je vais considérer l'utilisation du package bull, avec lequel je travaille moi-même.  Pourquoi ai-je choisi ce forfait particulier (bien que je n'impose pas mon choix aux autres).  À ce moment, lorsque j'ai commencé à chercher une implémentation pratique de la file d'attente de messages, le projet de file d'attente d'abeilles était déjà arrêté.  L'implémentation de kue, selon les repères donnés dans le référentiel de la file d'attente d'abeilles, était loin derrière les autres implémentations et, en outre, ne contenait pas les moyens d'exécuter des tâches exécutées périodiquement.  Le projet d'agenda implémente des files d'attente avec stockage dans la base de données mongodb.  C'est un gros plus pour certains cas, si vous avez besoin d'une super-fiabilité lors du placement de tâches dans la file d'attente.  Mais ce n'est pas seulement un facteur décisif.  Naturellement, j'ai testé toutes les options d'endurance de la bibliothèque, générant un grand nombre de tâches dans la file d'attente, et je n'ai toujours pas pu obtenir un travail ininterrompu de l'agenda.  En dépassant un certain nombre de tâches, l'agenda s'est arrêté et a cessé de mettre des tâches à exécution. <br><br>  Par conséquent, j'ai opté pour bull qui implémente une API pratique, avec une vitesse et une évolutivité suffisantes, car le package bull utilise un serveur redis comme backend.  En particulier, vous pouvez utiliser un cluster de serveurs redis. <br><br>  Lors de la création d'une file d'attente, il est très important de sélectionner les paramètres optimaux pour la file d'attente des travaux.  Il existe de nombreux paramètres, et la valeur de certains d'entre eux ne m'a pas atteint tout de suite.  Après de nombreuses expériences, je me suis installé sur les paramètres suivants: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bull = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bull'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redis = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">6379</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxRetriesPerRequest</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">connectTimeout</span></span>: <span class="hljs-number"><span class="hljs-number">180000</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> defaultJobOptions = { <span class="hljs-attr"><span class="hljs-attr">removeOnComplete</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">removeOnFail</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> limiter = { <span class="hljs-attr"><span class="hljs-attr">max</span></span>: <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-attr"><span class="hljs-attr">duration</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-attr"><span class="hljs-attr">bounceBack</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> settings = { <span class="hljs-attr"><span class="hljs-attr">lockDuration</span></span>: <span class="hljs-number"><span class="hljs-number">600000</span></span>, <span class="hljs-comment"><span class="hljs-comment">// Key expiration time for job locks. stalledInterval: 5000, // How often check for stalled jobs (use 0 for never checking). maxStalledCount: 2, // Max amount of times a stalled job will be re-processed. guardInterval: 5000, // Poll interval for delayed jobs and added jobs. retryProcessDelay: 30000, // delay before processing next job in case of internal error. drainDelay: 5, // A timeout for when the queue is in drained state (empty waiting for jobs). }; const bull = new Bull('my_queue', { redis, defaultJobOptions, settings, limiter }); module.exports = { bull };</span></span></code> </pre> <br>  Dans des cas triviaux, il n'est pas nécessaire de créer de nombreuses files d'attente, car dans chaque file d'attente, vous pouvez spécifier des noms pour différentes tâches et associer un processeur-travailleur à chaque nom: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { bull } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../bull'</span></span>); bull.process(<span class="hljs-string"><span class="hljs-string">'push:news'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${__dirname}</span></span></span><span class="hljs-string">/push-news.js`</span></span>); bull.process(<span class="hljs-string"><span class="hljs-string">'push:status'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${__dirname}</span></span></span><span class="hljs-string">/push-status.js`</span></span>); ... bull.process(<span class="hljs-string"><span class="hljs-string">'some:job'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{ ... });</code> </pre><br>  J'utilise l'opportunité qui se présente au taureau «prêt à l'emploi» - pour paralléliser les processeurs sur plusieurs cœurs.  Pour ce faire, le deuxième paramètre définit le nombre de cœurs sur lesquels le processeur-travailleur sera lancé, et dans le troisième paramètre, le nom du fichier avec la définition de la fonction de traitement des travaux.  Si une telle fonctionnalité n'est pas nécessaire, vous pouvez simplement passer une fonction de rappel comme deuxième paramètre. <br><br>  La tâche est mise en file d'attente par un appel à la méthode add (), à laquelle le nom et l'objet de la file d'attente sont passés dans les paramètres, qui seront ensuite transmis au gestionnaire de tâches.  Par exemple, dans un hook ORM, après avoir créé une entrée avec de nouvelles actualités, je peux envoyer un message push de manière asynchrone à tous les clients: <br><br><pre> <code class="javascript hljs"> afterCreate(instance) { bull.add(<span class="hljs-string"><span class="hljs-string">'push:news'</span></span>, _.pick(instance, <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-string"><span class="hljs-string">'title'</span></span>, <span class="hljs-string"><span class="hljs-string">'message'</span></span>), options); }</code> </pre><br>  Le gestionnaire d'événements accepte dans les paramètres l'objet de tâche avec les paramètres passés à la méthode add () et la fonction done (), qui doivent être appelées pour confirmer que la tâche est terminée ou pour informer que la tâche s'est terminée avec une erreur: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">firebase</span></span>: { admin } } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../firebase'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { makePayload } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./makePayload'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">job, done</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { id, title, message } = job.data; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(id), <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'news'</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> payloadRu = makePayload(title.ru, message.ru, data); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> payloadEn = makePayload(title.en, message.en, data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ admin.messaging().send({ ...payloadRu, <span class="hljs-attr"><span class="hljs-attr">condition</span></span>: <span class="hljs-string"><span class="hljs-string">"'news' in topics &amp;&amp; 'ru' in topics"</span></span> }), admin.messaging().send({ ...payloadEn, <span class="hljs-attr"><span class="hljs-attr">condition</span></span>: <span class="hljs-string"><span class="hljs-string">"'news' in topics &amp;&amp; 'en' in topics"</span></span> }), ]) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> done(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, response)) .catch(done); };</code> </pre><br>  Pour afficher l'état de la file d'attente des travaux, vous pouvez utiliser l'outil arena-bull: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arena = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bull-arena'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redis = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">6379</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxRetriesPerRequest</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">connectTimeout</span></span>: <span class="hljs-number"><span class="hljs-number">180000</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arena = Arena({ <span class="hljs-attr"><span class="hljs-attr">queues</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'my_gueue'</span></span>, <span class="hljs-attr"><span class="hljs-attr">hostId</span></span>: <span class="hljs-string"><span class="hljs-string">'My Queue'</span></span>, redis, }, ], }, { <span class="hljs-attr"><span class="hljs-attr">basePath</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">disableListen</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { arena };</code> </pre><br>  Et enfin, un petit hack de vie.  Comme je l'ai dit, bull utilise un serveur redis comme backend.  Lorsque le serveur redis est redémarré, la probabilité de disparition du travail est très faible.  Mais sachant que les administrateurs système peuvent parfois simplement «vider le cache de radis», tout en supprimant toutes les tâches en particulier, j'étais principalement préoccupé par l'exécution périodique de tâches, qui dans ce cas s'arrêtaient pour toujours.  À cet égard, j'ai trouvé l'occasion de reprendre ces tâches périodiques: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cron = <span class="hljs-string"><span class="hljs-string">'*/10 * * * * *'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { bull } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./app/services/bull'</span></span>); bull.getRepeatableJobs() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">jobs</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(_.map(jobs, (job) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, cron] = job.key.split(<span class="hljs-regexp"><span class="hljs-regexp">/:{2,}/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bull.removeRepeatable(name, { cron }); }))) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> bull.add(<span class="hljs-string"><span class="hljs-string">'check:status'</span></span>, {}, { <span class="hljs-attr"><span class="hljs-attr">priority</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">repeat</span></span>: { cron } })); setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> bull.add(<span class="hljs-string"><span class="hljs-string">'check:status'</span></span>, {}, { <span class="hljs-attr"><span class="hljs-attr">priority</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">repeat</span></span>: { cron } }), <span class="hljs-number"><span class="hljs-number">60000</span></span>);</code> </pre><br>  Autrement dit, la tâche est d'abord exclue de la file d'attente, puis définie à nouveau, et tout cela (hélas) par setInterval ().  En fait, sans un tel piratage de la vie, je n'aurais probablement pas décidé d'utiliser des tâches périodiques sur le taureau. <br><br>  apapacy@gmail.com <br>  3 juillet 2019 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458608/">https://habr.com/ru/post/fr458608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458598/index.html">Reconnaissance des sources lumineuses sur les cartes de l'environnement</a></li>
<li><a href="../fr458600/index.html">Que sont les vélos électriques (examen de groupe en deux parties de cinq modèles de deux fabricants), partie 1</a></li>
<li><a href="../fr458602/index.html">Comment nous avons percé le grand pare-feu chinois (partie 1)</a></li>
<li><a href="../fr458604/index.html">Pourquoi les deux plus grands fabricants d'électronique ont uni leurs forces dans un nouveau projet de GPU</a></li>
<li><a href="../fr458606/index.html">Exécutez OpenVPN dans Docker en 2 secondes</a></li>
<li><a href="../fr458612/index.html">Cosmos. 7 ans</a></li>
<li><a href="../fr458614/index.html">Création d'un hook Reactive UsePosition () pour obtenir et suivre les coordonnées du navigateur</a></li>
<li><a href="../fr458622/index.html">Automatisation pour les plus petits. Première partie (qui est après zéro). Virtualisation du réseau</a></li>
<li><a href="../fr458624/index.html">Comment nous avons appris à dessiner des textes sur toile</a></li>
<li><a href="../fr458626/index.html">StealthWatch: concepts de base et exigences minimales. Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>