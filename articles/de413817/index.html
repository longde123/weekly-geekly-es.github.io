<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏼 👨🏻‍🚀 🗯️ Heterogene wettbewerbsfähige Datenverarbeitung in Echtzeit nur einmal 🚛 😳 🚶🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anmerkung 


 Die Verarbeitung von Daten in Echtzeit genau einmal ( genau einmal ) ist eine äußerst nicht triviale Aufgabe und erfordert einen ernstha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Heterogene wettbewerbsfähige Datenverarbeitung in Echtzeit nur einmal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413817/"><p><img src="https://habrastorage.org/webt/uf/mh/m-/ufmhm-q0wjfbdgbv4jn4ece8duw.jpeg" alt="Wettbewerbsforderer wurst"></p><br><h2 id="annotaciya">  Anmerkung </h2><br><p>  Die Verarbeitung von Daten in Echtzeit genau einmal ( <em>genau einmal</em> ) ist eine äußerst nicht triviale Aufgabe und erfordert einen ernsthaften und durchdachten Ansatz über die gesamte Berechnungskette hinweg.  Einige glauben sogar, dass eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">solche Aufgabe unmöglich ist</a> .  In der Realität möchte ich einen Ansatz haben, der eine fehlertolerante Verarbeitung ohne Verzögerung und die Verwendung verschiedener Datenspeicher ermöglicht und neue, noch strengere Anforderungen an das System stellt: <em>genau einmal gleichzeitig</em> und die Heterogenität der persistenten Schicht.  Bisher unterstützt eine solche Anforderung keines der vorhandenen Systeme. </p><br><p>  Der vorgeschlagene Ansatz wird konsequent die geheimen Bestandteile und die notwendigen Konzepte aufdecken, die es relativ einfach machen, eine heterogene <em>gleichzeitige, genau einmalige</em> Verarbeitung buchstäblich aus zwei Komponenten zu implementieren. </p><br><h2 id="vvedenie">  Einführung </h2><br><p>  Der Entwickler verteilter Systeme durchläuft mehrere Phasen: </p><br><p>  <em>Stufe 1: Algorithmen</em> .  Hier werden grundlegende Algorithmen, Datenstrukturen, Programmieransätze wie OOP usw. untersucht.  Der Code ist ausschließlich Single-Threaded.  Die Anfangsphase des Berufseinstiegs.  Es ist jedoch ziemlich kompliziert und kann Jahre dauern. </p><br><p>  <em>Stufe 2: Multithreading</em> .  Als nächstes stellen sich Fragen, wie man aus Eisen maximale Effizienz herausholen kann. Es gibt Multithreading, Asynchronität, Rennen, Debugging, Strace, schlaflose Nächte ... Viele bleiben in dieser Phase stecken und bekommen irgendwann sogar einen unerklärlichen Nervenkitzel.  Aber nur wenige verstehen die Architektur von virtuellem Speicher und Speichermodellen, sperrfreien / wartungsfreien Algorithmen und verschiedenen asynchronen Modellen.  Und fast niemand jemals - Multithread-Codeüberprüfung. </p><br><p>  <em>Stufe 3: Verteilung</em> .  Hier passiert so ein Müll, den weder in einem Märchen noch in einem Stift zu beschreiben ist. </p><a name="habracut"></a><br><p>  Es scheint, dass etwas kompliziert ist.  Wir machen die Transformation: viele Threads -&gt; viele Prozesse -&gt; viele Server.  Aber jeder Schritt der Transformation bringt qualitative Veränderungen mit sich, und alle fallen auf das System, zerdrücken es und verwandeln es in Staub. </p><br><p>  Hier geht es darum, die Fehlerbehandlungsdomäne und die Verfügbarkeit des gemeinsam genutzten Speichers zu ändern.  Wenn vorher immer ein Stück Speicher in jedem Thread verfügbar war und wenn gewünscht, in jedem Prozess, gibt es jetzt kein solches Stück und kann es nicht sein.  Jeder für sich, unabhängig und stolz. </p><br><p>  Wenn früher ein Fehler im Stream den Stream und den Prozess gleichzeitig vergrub, und das war gut, weil  führte nicht zu teilweisen Fehlern, jetzt werden teilweise Fehler zur Norm und jedes Mal vor jeder Aktion denken Sie: „Was wäre wenn?“.  Dies ist so ärgerlich und lenkt vom Schreiben der Aktionen selbst ab, dass der Code dadurch nicht zeitweise, sondern um Größenordnungen wächst.  Alles wird zu Nudeln der Fehlerbehandlung, Zustandsumschaltung und Kontexterhaltung, Wiederherstellung aufgrund von Fehlern einer Komponente, einer anderen Komponente, Unzugänglichkeit einiger Dienste usw.  usw.  Nachdem Sie die Überwachung für all diese Dinge vermasselt haben, können Sie auf Ihrem Lieblings-Laptop gut schlafen. </p><br><p>  Ob es sich um Multithreading handelt: Ich nahm den Mutex und ging, um das gemeinsame Gedächtnis zum Vergnügen zu zerstören.  Schönheit! </p><br><p>  Infolgedessen haben wir festgestellt, dass die Schlüssel- und kampferprobten Muster weggenommen wurden und die neuen, um sie zu ersetzen, aus irgendeinem Grund nicht geliefert wurden, und es stellte sich heraus, wie in einem Witz darüber, wie die Fee ihren Zauberstab schwang und der Turm vom Panzer fiel. </p><br><p>  Verteilte Systeme verfügen jedoch über eine Reihe bewährter Verfahren und bewährter Algorithmen.  Jeder Programmierer mit Selbstachtung sieht es jedoch als seine Pflicht an, bekannte Errungenschaften abzulehnen und trotz der gesammelten Erfahrungen eine beträchtliche Anzahl wissenschaftlicher Artikel und akademischer Forschung zu seinem eigenen Wohl zu fahren.  Wenn Sie sich mit Algorithmen und Multithreading beschäftigen können, wie können Sie dann mit der Verteilung in Konflikt geraten?  Hier kann es keine zwei Meinungen geben! </p><br><p>  Infolgedessen sind Systeme fehlerhaft, Daten divergieren und verschlechtern sich, Dienste sind regelmäßig nicht mehr zum Schreiben verfügbar oder sogar vollständig nicht mehr verfügbar, da plötzlich ein Knoten abstürzte, das Netzwerk ausfiel, Java viel Speicher verbrauchte und GC langweilig wurde, und es gibt viele andere Gründe, die sein Ende verzögern könnten an die Behörden. </p><br><p>  Doch auch mit bekannten und bewährten Ansätzen wird das Leben nicht einfacher, weil  Verteilte zuverlässige Grundelemente sind schwergewichtig und stellen ernsthafte Anforderungen an die Logik des ausführbaren Codes.  Daher werden die Ecken wo immer möglich abgeschnitten.  Und wie so oft, treten bei schnell geschnittenen Ecken Einfachheit und relative Skalierbarkeit auf, aber die Zuverlässigkeit, Verfügbarkeit und Konsistenz eines verteilten Systems verschwindet. </p><br><p>  Im Idealfall möchte ich überhaupt nicht denken, dass unser System verteilt und multithreaded ist, d. H.  Arbeiten Sie in der 1. Stufe (Algorithmen), ohne an die 2. (Multithreading + Asynchronität) und 3. (Verteilung) zu denken.  Diese Art der Isolierung von Abstraktionen würde die Einfachheit, Zuverlässigkeit und Geschwindigkeit des Schreibens von Code erheblich erhöhen.  Leider ist dies derzeit nur in Träumen möglich. </p><br><p>  Einzelne Abstraktionen ermöglichen jedoch eine relative Isolation.  Eines der typischen Beispiele ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwendung von Coroutinen</a> , bei denen anstelle von asynchronem Code synchron, d. H.  Wir gehen von der 2. Stufe zur 1. Stufe über, wodurch wir das Schreiben und die Wartung des Codes erheblich vereinfachen können. </p><br><p>  Der Artikel enthüllt sukzessive die Verwendung von sperrfreien Algorithmen, um ein zuverlässiges konsistentes verteiltes skalierbares Echtzeitsystem aufzubauen, d.h.  Wie sperrfreie Erfolge der 2. Stufe bei der Implementierung der 3. Stufe helfen und die Aufgabe auf Single-Threaded-Algorithmen der 1. Stufe reduzieren. </p><br><h2 id="postanovka-zadachi">  Erklärung des Problems </h2><br><p>  Diese Aufgabe zeigt nur einige wichtige Ansätze und wird als Beispiel für die Einführung von Problemen in den Kontext vorgestellt.  Es kann leicht auf komplexere Fälle verallgemeinert werden, was in Zukunft geschehen wird. </p><br><p>  <strong>Aufgabe: Echtzeit-Streaming-Datenverarbeitung</strong> . </p><br><p>  Es gibt zwei Zahlenströme.  Der Handler liest die Daten dieser Eingabestreams und wählt die letzten Nummern für einen bestimmten Zeitraum aus.  Diese Zahlen werden über dieses Zeitintervall gemittelt, d.h.  in einem verschiebbaren Datenfenster für eine bestimmte Zeit.  Der erhaltene Durchschnittswert muss für die nachfolgende Verarbeitung in die Ausgabewarteschlange geschrieben werden.  Wenn die Anzahl der Nummern im Fenster einen bestimmten Schwellenwert überschreitet, erhöhen Sie außerdem den Zähler in der externen Transaktionsdatenbank um eins. </p><br><p><img src="https://habrastorage.org/webt/nf/9d/jh/nf9djhbhsjmrumrg5eckb1h6u_c.png" alt="Anfängliche"></p><br><p>  Wir stellen einige Merkmale dieses Problems fest. </p><br><ol><li>  <em>Nichtdeterminismus</em> .  Es gibt zwei Ursachen für nicht deterministisches Verhalten: Dies ist ein Messwert aus zwei Streams sowie ein Zeitfenster.  Es ist klar, dass das Lesen auf verschiedene Arten durchgeführt werden kann und das Endergebnis davon abhängt, in welcher Reihenfolge die Daten extrahiert werden.  Das Zeitfenster ändert auch das Ergebnis von Anfang zu Start als  Die Datenmenge im Fenster hängt von der Arbeitsgeschwindigkeit ab. </li><li>  <em>Der Zustand des Handlers</em> .  Es gibt einen Status des Handlers in Form einer Reihe von Zahlen im Fenster, von denen die aktuellen und nachfolgenden Ergebnisse der Arbeit abhängen.  Das heißt,  Wir haben einen Stateful Handler. </li><li>  <em>Interaktion mit externem Speicher</em> .  Der Zählerwert in der externen Datenbank muss aktualisiert werden.  Der entscheidende Punkt ist, dass sich die Art des externen Speichers von der Speicherung des Status des Prozessors und der Threads unterscheidet. </li></ol><br><p>  All dies hat, wie unten gezeigt wird, schwerwiegende Auswirkungen auf die verwendeten Tools und die möglichen Implementierungsmethoden. </p><br><p>  Es bleibt eine kleine Berührung der Aufgabe, die die Aufgabe sofort von einem Bereich jenseits der Komplexität auf ein Unmögliches überträgt: Eine <em>gleichzeitige, genau einmalige</em> Garantie ist erforderlich. </p><br><h2 id="exactly-once">  Genau einmal </h2><br><p>  <em>Genau einmal wird</em> oft zu weit gefasst, was den Begriff selbst entmannt und die ursprünglichen Anforderungen der Aufgabe nicht mehr erfüllt.  Wenn es sich um ein System handelt, das lokal auf einem Computer ausgeführt wird, ist alles einfach: Nehmen Sie mehr, werfen Sie weiter.  In diesem Fall handelt es sich jedoch um ein verteiltes System, in dem: </p><br><ol><li>  Die Anzahl der Handler kann groß sein: Jeder Handler arbeitet mit seinen eigenen Daten.  Darüber hinaus können die Ergebnisse an verschiedenen Stellen hinzugefügt werden, beispielsweise in einer externen Datenbank, die möglicherweise sogar gemischt wird. </li><li>  Jeder Handler kann die Verarbeitung plötzlich beenden.  Ein fehlertolerantes System impliziert einen fortgesetzten Betrieb, selbst wenn einzelne Teile des Systems ausfallen. </li></ol><br><p>  Daher müssen wir darauf vorbereitet sein, dass der Handler fallen kann, und ein anderer Handler sollte die bereits geleistete Arbeit aufnehmen und die Verarbeitung fortsetzen. </p><br><p>  Es stellt sich sofort die Frage: Was bedeutet <em>genau einmal</em> , wenn der nicht deterministische Handler funktioniert?  Schließlich erhalten wir bei jedem Neustart im Allgemeinen unterschiedliche resultierende Zustände.  Die Antwort hier ist einfach: Mit <em>genau einmal</em> gibt es eine solche Systemausführung, bei der jeder Eingabewert genau einmal verarbeitet wird und das entsprechende Ausgabeergebnis ergibt.  Darüber hinaus muss sich diese Ausführung nicht physisch auf demselben Knoten befinden.  Das Ergebnis sollte jedoch so sein, als ob alles auf einem einzelnen logischen Knoten <em>ohne Abstürze verarbeitet wurde</em> . </p><br><h2 id="concurrent-exactly-once">  Genau einmal gleichzeitig </h2><br><p>  Um die Anforderungen zu verschärfen, führen wir ein neues Konzept ein: <em>genau einmal gleichzeitig</em> .  Der grundlegende Unterschied zu einfach <em>genau einmal</em> ist das Fehlen von Pausen während der Verarbeitung, als ob alles auf demselben Knoten <strong>ohne Tropfen</strong> und <strong>ohne Pausen verarbeitet worden wäre</strong> .  In unserer Aufgabe benötigen wir zur Vereinfachung der Darstellung <em>genau einmal</em> genau <em>gleichzeitig</em> , um einen Vergleich mit vorhandenen Systemen, die heute nicht verfügbar sind, nicht in Betracht zu ziehen. </p><br><p>  Die Konsequenzen einer solchen Anforderung werden nachstehend erörtert. </p><br><h2 id="tranzakcionnost">  Transaktion </h2><br><p>  Damit der Leser noch tiefer von der entstandenen Komplexität durchdrungen ist, schauen wir uns verschiedene schlechte Szenarien an, die bei der Entwicklung eines solchen Systems berücksichtigt werden müssen.  Wir werden auch versuchen, einen allgemeinen Ansatz zu verwenden, der es uns ermöglicht, das oben genannte Problem unter Berücksichtigung unserer Anforderungen zu lösen. </p><br><p>  Das erste, was mir in den Sinn kommt, ist die Notwendigkeit, den Status des Handlers sowie die Eingabe- und Ausgabestreams aufzuzeichnen.  Der Status der Ausgabestreams wird durch eine einfache Warteschlange von Zahlen und der Status der Eingabestreams durch die Position in ihnen beschrieben.  Im Wesentlichen ist ein Stream eine unendliche Warteschlange, und eine Position in der Warteschlange legt einen Ort eindeutig fest. </p><br><p><img src="https://habrastorage.org/webt/iu/h0/pf/iuh0pfzcezje80kdbsv3idyeu9a.jpeg" alt="Idee"></p><br><p>  Die folgende naive Implementierung eines Handlers erfolgt mithilfe einer Art Data Warehouse.  Zu diesem Zeitpunkt sind die spezifischen Eigenschaften des Repositorys für uns nicht wichtig.  Wir werden die Pseco-Sprache verwenden, um die Idee zu veranschaulichen (Pseco: = Pseudocode): </p><br><pre><code class="hljs pgsql">handle(input_queues, output_queues, state): #    input_indexes = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_input_indexes() #      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #         items, new_input_indexes = input_queues.get_from(input_indexes) #    state.queue.push(items) #     duration state.queue.trim_time_window(duration) avg = state.queue.avg() need_update_counter = state.queue.size() &gt; size_boundary # (A)      output_queues[<span class="hljs-number"><span class="hljs-number">0</span></span>].push(avg) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: # (B)      db.increment_counter() # (C)     <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_state(state) # (D)    <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_queue_indexes(new_input_indexes) # (E)    input_indexes = new_input_indexes</code> </pre> <br><p>  Hier ist ein einfacher Single-Threaded-Algorithmus, der Daten aus Eingabestreams liest und die gewünschten Werte gemäß der oben beschriebenen Aufgabe schreibt. </p><br><p>  Mal sehen, was passiert, wenn ein Knoten zu beliebigen Zeitpunkten fällt oder wenn die Arbeit wieder aufgenommen wird.  Es ist klar, dass im Falle eines Sturzes an den Punkten <code>(A)</code> und <code>(E)</code> alles in Ordnung ist: Entweder wurden die Daten noch nirgendwo aufgezeichnet und wir stellen einfach den Status wieder her und fahren auf dem anderen Knoten fort, oder alle erforderlichen Daten wurden bereits aufgezeichnet und fahren einfach mit dem nächsten Schritt fort. </p><br><p>  Im Falle eines Sturzes an allen anderen Punkten erwarten uns jedoch unerwartete Probleme.  Wenn an Punkt <code>(B)</code> ein Abfall auftritt, wird beim Neustart des Handlers der Status wiederhergestellt und der Durchschnittswert in ungefähr demselben Zahlenbereich neu aufgezeichnet.  Im Falle eines Abfalls an Punkt <code>(C)</code> zusätzlich zum durchschnittlichen Duplikat ein Duplikat im Inkrement des Werts auf.  Und im Falle eines Sturzes in <code>(D)</code> wir einen inkonsistenten Zustand des Handlers: Der Zustand entspricht einem neuen Zeitpunkt und wir lesen die Werte aus den alten Eingabeströmen. </p><br><p><img src="https://habrastorage.org/webt/fn/8z/6f/fn8z6f9t3y-fe2hzlepgnie7qps.jpeg" alt="Störungenungen"></p><br><p>  Gleichzeitig ändert sich beim Neuanordnen von Aufnahmevorgängen nichts grundlegend: Inkonsistenzen und Duplikate bleiben erhalten.  Wir kommen daher zu dem Schluss, dass alle Aktionen zum Ändern des Status des Handlers im Repository, in der Ausgabewarteschlange und in der Datenbank transaktional ausgeführt werden sollten, d. H.  alles ist gleichzeitig atomar. </p><br><p>  Dementsprechend ist es notwendig, einen Mechanismus zu entwickeln, damit verschiedene Speicher ihren Zustand transaktional ändern können und nicht unabhängig voneinander, sondern transaktional zwischen allen Speichern gleichzeitig.  Natürlich können Sie unseren Speicher in einer externen Datenbank speichern. Bei der Aufgabe wurde jedoch davon ausgegangen, dass das Datenbankmodul und das Modul für das Streaming-Datenverarbeitungsframework getrennt sind und unabhängig voneinander arbeiten.  Hier möchte ich den schwierigsten Fall betrachten, weil  einfache Fälle sind nicht interessant zu betrachten. </p><br><h2 id="konkurentnaya-otzyvchivost">  Wettbewerbsfähigkeit </h2><br><p>  Betrachten Sie die Wettbewerbsausführung genau einmal genauer.  Bei einem fehlertoleranten System müssen die Arbeiten ab einem bestimmten Zeitpunkt fortgesetzt werden.  Es ist klar, dass dieser Punkt irgendwann in der Vergangenheit liegen wird, weil  Um die Leistung aufrechtzuerhalten, ist es unmöglich, alle Momente von Statusänderungen in der Gegenwart und in der Zukunft zu speichern: Entweder das letzte Ergebnis von Operationen oder eine Gruppe von Werten zur Erhöhung des Durchsatzes wird gespeichert.  Dieses Verhalten führt uns sofort zu der Tatsache, dass es nach der Wiederherstellung des Status des Prozessors zu einer gewissen Verzögerung der Ergebnisse kommt, die mit zunehmender Größe der Wertegruppe und der Größe des Status zunimmt. </p><br><p>  Zusätzlich zu dieser Verzögerung gibt es auch Verzögerungen im System, die mit dem Laden des Zustands auf einen anderen Knoten verbunden sind.  Darüber hinaus dauert die Erkennung eines Problemknotens einige Zeit und oft viel.  Dies ist vor allem darauf zurückzuführen, dass bei einer kurzen Erkennungszeit häufige Fehlalarme möglich sind, die zu allen möglichen unangenehmen Spezialeffekten führen. </p><br><p>  Darüber hinaus stellt sich mit der Zunahme der Anzahl paralleler Prozessoren plötzlich heraus, dass nicht alle gleich gut funktionieren, auch wenn keine Fehler vorliegen.  Manchmal treten Blunts auf, die auch zu Verzögerungen bei der Verarbeitung führen.  Der Grund für solche Blunts kann vielfältig sein: </p><br><ol><li>  <em>Software</em> : GC-Pausen, Speicherfragmentierung, Allokatorpausen, Kernelunterbrechung und Aufgabenplanung, Probleme mit Gerätetreibern, die zu Verlangsamungen führen. </li><li>  <em>Hardware</em> : Hohe Festplatten- oder Netzwerklast, CPU-Drosselung aufgrund von Kühlproblemen, Überlastung usw., Verlangsamung der Festplatte aufgrund technischer Probleme. </li></ol><br><p>  Und dies ist keineswegs eine vollständige Liste von Problemen, die Handler verlangsamen können. </p><br><p>  Verlangsamung ist dementsprechend eine Selbstverständlichkeit, mit der man leben muss.  Manchmal ist dies kein ernstes Problem, und manchmal ist es äußerst wichtig, trotz Ausfällen oder Verlangsamungen eine hohe Verarbeitungsgeschwindigkeit aufrechtzuerhalten. </p><br><p>  Sofort entsteht die Idee der Duplizierung von Systemen: Lassen Sie uns für ein und denselben Datenstrom nicht einen, sondern zwei Prozessoren gleichzeitig oder sogar drei ausführen.  Das Problem hierbei ist, dass in diesem Fall leicht Duplikate und inkonsistentes Systemverhalten auftreten können.  In der Regel sind Frameworks nicht für dieses Verhalten ausgelegt und legen nahe, dass die Anzahl der Handler zu einem bestimmten Zeitpunkt einen nicht überschreitet.  Systeme, die die beschriebene Duplizierung der Ausführung ermöglichen, werden <em>genau einmal</em> als <em>gleichzeitig bezeichnet</em> . </p><br><p>  Mit dieser Architektur können Sie mehrere Probleme gleichzeitig lösen: </p><br><ol><li>  Ausfallsicheres Verhalten: Wenn einer der Knoten fällt, funktioniert der andere einfach weiter, als wäre nichts passiert.  Es ist keine zusätzliche Koordinierung erforderlich, da  Der zweite Handler wird unabhängig vom Status des ersten ausgeführt. </li><li>  Entfernen von Blunts: Wer zuerst das Ergebnis geliefert hat, ist gut für ihn.  Der andere muss nur einen neuen Zustand annehmen und von diesem Moment an fortfahren. </li></ol><br><p>  Insbesondere mit diesem Ansatz können Sie eine schwierige, schwierige Langzeitberechnung für eine vorhersehbarere Zeit durchführen, weil  die Wahrscheinlichkeit, dass beide dumm werden und deutlich weniger fallen. </p><br><h3 id="veroyatnostnaya-ocenka">  Wahrscheinlichkeitsbewertung </h3><br><p>  Versuchen wir, die Vorteile einer doppelten Leistung zu bewerten.  Angenommen, mit dem Handler passiert durchschnittlich jeden Tag etwas: Entweder ist der GC abgestumpft oder der Knoten liegt oder die Container sind krebsartig geworden.  Angenommen, wir bereiten Datenpakete in 10 Sekunden vor. </p><br><p>  Dann beträgt die Wahrscheinlichkeit, dass während der Erstellung des Pakets etwas passiert, <code>10 / (24 · 3600) ≃ 1e-4</code> . </p><br><p>  Wenn Sie zwei Handler parallel ausführen, beträgt die Wahrscheinlichkeit, dass beide fliegen, <code>≃ 1e-8</code> .  Diese Veranstaltung wird also in 23 Jahren stattfinden!  Ja, Systeme leben nicht so viel, was bedeutet, dass dies niemals passieren wird! </p><br><p>  Wenn die Vorbereitungszeit der Packung noch kürzer ist und / oder Blunts noch seltener auftreten, erhöht sich diese Zahl nur. </p><br><p>  Wir kommen daher zu dem Schluss, dass der betrachtete Ansatz die Zuverlässigkeit unseres gesamten Systems erheblich erhöht.  Es bleibt nur eine kleine Frage wie diese zu lösen: Wo kann man lesen, wie man ein <em>gleichzeitiges genau einmaliges</em> System erstellt?  Und die Antwort ist einfach: Sie müssen hier lesen. </p><br><h2 id="polutranzakcii">  Halbe Transaktion </h2><br><p>  Für die weitere Diskussion benötigen wir das Konzept einer <em>halben Transaktion</em> .  Der einfachste Weg, dies zu erklären, ist ein Beispiel. </p><br><p>  Überlegen Sie, ob Sie Geld von einem Bankkonto auf ein anderes überweisen möchten.  Der traditionelle Ansatz unter Verwendung von Transaktionen in der Pseco-Sprache kann wie folgt beschrieben werden: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): tx = db.begin_transaction() amount_from = tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Was ist jedoch, wenn diese Transaktionen uns nicht zur Verfügung stehen?  Mit Sperren kann dies wie folgt erfolgen: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #         lock_from = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) lock_to = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Dieser Ansatz kann zu Deadlocks führen  Sperren können in verschiedenen Sequenzen parallel genommen werden.  Um dieses Verhalten zu korrigieren, reicht es aus, eine Funktion einzuführen, die gleichzeitig mehrere Sperren in einer deterministischen Reihenfolge aufnimmt (z. B. nach Schlüsseln sortiert), wodurch mögliche Deadlocks vollständig beseitigt werden. </p><br><p>  Die Implementierung kann jedoch etwas vereinfacht werden: </p><br><pre> <code class="hljs vbscript">transfer(from, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): lock_from = db.lock(from) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(from) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: return <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(from, amount_from - amount) lock_from.release() #   , # .. db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>...)     lock_to = db.lock(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) return ok</code> </pre> <br><p>  Dieser Ansatz macht auch den Endzustand konsistent und bewahrt die Invarianten durch die Art der Verhinderung übermäßiger Ausgaben von Geldern.  Der Hauptunterschied zum vorherigen Ansatz besteht darin, dass wir in einer solchen Implementierung einen bestimmten Zeitraum haben, in dem sich die Konten in einem inkonsistenten Zustand befinden.  Eine solche Operation impliziert nämlich, dass sich der Gesamtzustand der Gelder auf den Konten nicht ändert.  In diesem Fall besteht zwischen <code>lock_from.release()</code> und <code>db.lock(to)</code> eine Zeitlücke, in der die Datenbank möglicherweise einen inkonsistenten Wert <code>db.lock(to)</code> : Der Gesamtbetrag kann vom richtigen nach unten abweichen. </p><br><p>  Tatsächlich haben wir eine Transaktion für die Überweisung von Geld in zwei halbe Transaktionen aufgeteilt: </p><br><ol><li>  Die erste halbe Transaktion führt einen Scheck durch und zieht den erforderlichen Betrag vom Konto ab. </li><li>  Die zweite halbe Transaktion schreibt den abgehobenen Betrag auf ein anderes Konto. </li></ol><br><p>  Es ist klar, dass die Aufteilung einer Transaktion in kleinere im Allgemeinen das Transaktionsverhalten verletzt.  Und das obige Beispiel ist keine Ausnahme.  Wenn jedoch alle Halbtransaktionen in der Kette vollständig erfüllt sind, stimmt das Ergebnis mit allen erhaltenen Invarianten überein.  Dies ist genau das, was eine wichtige Eigenschaft einer halben Transaktionskette ist. </p><br><p>  Wir verlieren vorübergehend an Konsistenz und erwerben dennoch ein weiteres nützliches Merkmal: die Unabhängigkeit des Betriebs und damit eine bessere Skalierbarkeit.  Die Unabhängigkeit manifestiert sich in der Tatsache, dass eine halbe Transaktion jedes Mal mit nur einer Zeile arbeitet, ihre Daten liest, prüft und ändert, ohne mit anderen Daten zu kommunizieren.  Auf diese Weise können Sie eine Datenbank mischen, deren Transaktionen nur mit einem Shard funktionieren.  Darüber hinaus kann dieser Ansatz im Fall von heterogenen Repositories verwendet werden, d.h.  Halbtransaktionen können bei einem Speichertyp beginnen und bei einem anderen enden.  Es sind solche nützlichen Eigenschaften, die in Zukunft verwendet werden. </p><br><p>  Es stellt sich eine berechtigte Frage: Wie kann man Half-Trance in verteilten Systemen implementieren und nicht harken?  Um dieses Problem zu beheben, müssen Sie den sperrfreien Ansatz berücksichtigen. </p><br><h2 id="lock-free">  Schlossfrei </h2><br><p>  Wie Sie wissen, verbessern sperrfreie Ansätze manchmal die Leistung von Multithread-Systemen, insbesondere im Fall eines wettbewerbsfähigen Zugriffs auf die Ressource.  Es ist jedoch völlig offensichtlich, dass ein solcher Ansatz in verteilten Systemen verwendet werden kann.  Lassen Sie uns genauer untersuchen, was sperrenfrei ist und warum diese Eigenschaft bei der Lösung unseres Problems hilfreich sein wird. </p><br><p>  Einige Entwickler verstehen manchmal nicht ganz, was sperrenfrei ist.  Der engstirnige Blick deutet darauf hin, dass dies etwas mit Anweisungen für Atomprozessoren zu tun hat.  Es ist wichtig zu verstehen, dass lock-free die Verwendung von „Atomen“ bedeutet, das Gegenteil ist nicht der Fall, das heißt,  Nicht alle „Atomics“ geben ein sperrenfreies Verhalten. </p><br><p>  Eine wichtige Eigenschaft des sperrfreien Algorithmus ist, dass mindestens ein Thread Fortschritte im System macht.  Aber aus irgendeinem Grund schreiben viele diese Eigenschaft als Definition zu (es ist eine so stumpfe Definition, die zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Wikipedia zu finden ist</a> ).  Hier muss eine wichtige Nuance hinzugefügt werden: Fortschritte werden auch bei Stumpfen eines oder mehrerer Threads erzielt.  Dies ist ein sehr kritischer Punkt, der oft übersehen wird und schwerwiegende Auswirkungen auf ein verteiltes System hat. </p><br><p>  Warum negiert das Fehlen einer Fortschrittsbedingung von mindestens einem Thread das Konzept eines sperrfreien Algorithmus?  Tatsache ist, dass in diesem Fall auch der übliche Spinlock sperrfrei ist.  In der Tat wird derjenige, der das Schloss genommen hat, Fortschritte machen.  Gibt es einen Thread mit Fortschritt =&gt; sperrenfrei? </p><br><p>  Lock-free bedeutet natürlich ohne Sperren, während Spinlock mit seinem Namen anzeigt, dass es sich um eine echte Sperre handelt.  Aus diesem Grund ist es wichtig, auch bei Blunts eine Bedingung für den Fortschritt hinzuzufügen.  Schließlich können diese Verzögerungen unbegrenzt dauern, weil  Die Definition sagt nichts über die obere Zeitlinie aus.  Und wenn ja, dann sind solche Verzögerungen in gewissem Sinne gleichbedeutend mit dem Abschalten von Flüssen.  In diesem Fall führen sperrfreie Algorithmen in diesem Fall zu Fortschritten. </p><br><p>  Aber wer hat gesagt, dass sperrfreie Ansätze ausschließlich für Multithread-Systeme gelten?  Durch Ersetzen von Threads im selben Prozess auf demselben Knoten durch Prozesse auf verschiedenen Knoten und des gemeinsam genutzten Speichers der Threads durch gemeinsam genutzten verteilten Speicher erhalten wir einen sperrfreien verteilten Algorithmus. </p><br><p>  Ein Knotenabfall in einem solchen System entspricht einer Verzögerung bei der Ausführung eines Threads für einige Zeit, weil  Es ist Zeit, die Arbeit wiederherzustellen.  Gleichzeitig ermöglicht der sperrfreie Ansatz anderen Teilnehmern des verteilten Systems, weiter zu arbeiten.  Darüber hinaus können spezielle sperrfreie Algorithmen parallel zueinander ausgeführt werden, um eine Wettbewerbsänderung zu erkennen und Duplikate auszuschneiden. </p><br><p>  <em>Der genau einmalige</em> Ansatz impliziert das Vorhandensein eines konsistenten verteilten Speichers.  Solche Speicher stellen in der Regel eine riesige persistente Schlüsselwerttabelle dar.  Mögliche Operationen: <code>set</code> , <code>get</code> , <code>del</code> .  Für den sperrfreien Ansatz ist jedoch eine kompliziertere Operation erforderlich: CAS oder Compare-and-Swap.  Lassen Sie uns diese Operation, die Verwendungsmöglichkeiten sowie die daraus resultierenden Ergebnisse genauer betrachten. </p><br><h3 id="cas">  Cas </h3><br><p>  CAS oder Compare-and-Swap ist das wichtigste und wichtigste Synchronisationsprimitiv für sperrfreie und wartungsfreie Algorithmen.  Sein Wesen kann durch das folgende Pseco veranschaulicht werden: </p><br><pre> <code class="hljs kotlin">CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, new): # ,   atomic,   atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() != expected: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(new) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Manchmal geben sie zur Optimierung nicht <code>true</code> oder <code>false</code> , sondern den vorherigen Wert, weil  Sehr oft werden solche Operationen in einer Schleife ausgeführt. Um den <code>expected</code> Wert zu erhalten, müssen Sie ihn zuerst lesen: </p><br><pre> <code class="hljs vala">CAS_optimized(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): # ,   atomic,   atomic: current = <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == expected: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current #  CAS   CAS_optimized CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.CAS_optimized(expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) == expected</code> </pre> <br><p>  Dieser Ansatz kann eine Lesung speichern.  Im Rahmen unserer Überprüfung werden wir eine einfache Form von <code>CAS</code> , weil  Falls gewünscht, kann eine solche Optimierung unabhängig durchgeführt werden. </p><br><p>  Bei verteilten Systemen wird jede Änderung versioniert.  Das heißt,  Zuerst lesen wir den Wert aus dem Speicher und erhalten die aktuelle Version der Daten.  Und dann versuchen wir zu schreiben und erwarten, dass sich die Version der Daten nicht geändert hat.  In diesem Fall wird die Version jedes Mal erhöht, wenn die Daten aktualisiert werden: </p><br><pre> <code class="hljs cs">CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected_version, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.get_version() != expected_version: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>, expected_version + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Mit diesem Ansatz können Sie die Aktualisierung von Werten genauer steuern und so <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das ABA-Problem</a> vermeiden.  Insbesondere wird die Versionierung von Etcd und Zookeeper unterstützt. </p><br><p>  Beachten Sie die wichtige Eigenschaft, die die Verwendung von <code>CAS_versioned</code> Operationen bietet.  Tatsache ist, dass eine solche Operation unbeschadet der übergeordneten Logik wiederholt werden kann.  Bei der Multithread-Programmierung hat diese Eigenschaft keinen besonderen Wert, da  Wenn die Operation dort fehlgeschlagen ist, wissen wir mit Sicherheit, dass sie nicht zutraf.  Bei verteilten Systemen wird diese Invariante verletzt, weil  Die Anfrage erreicht möglicherweise den Empfänger, aber die erfolgreiche Antwort ist nicht mehr vorhanden.  Daher ist es wichtig, Anforderungen erneut senden zu können, ohne befürchten zu müssen, Invarianten der Logik auf hoher Ebene zu brechen. </p><br><p>  Diese Eigenschaft <code>CAS_versioned</code> die Operation <code>CAS_versioned</code> .  Tatsächlich kann dieser Vorgang endlos wiederholt werden, bis die tatsächliche Antwort des Empfängers zurückgegeben wird.  Dies führt wiederum zu einer ganzen Reihe von Fehlern im Zusammenhang mit der Netzwerkinteraktion. </p><br><h3 id="primer">  Beispiel </h3><br><p>  Schauen wir uns an, wie Sie basierend auf <code>CAS_versioned</code> und <code>CAS_versioned</code> von einem Konto auf ein anderes übertragen können, das beispielsweise zu verschiedenen Kopien von Etcd gehört.  Hier <code>CAS_versioned</code> ich davon aus, dass die <code>CAS_versioned</code> Funktion basierend auf der bereitgestellten API bereits entsprechend implementiert ist. </p><br><pre> <code class="hljs pgsql">withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     version_from, amount_from = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.CAS_versioned(version_from, amount_from - amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: version_to, amount_to = <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.CAS_versioned(version_to, amount_to + amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  Hier haben wir unsere Operation in halbe Transaktionen unterteilt und führen jede halbe Transaktion über die Operation <code>CAS_versioned</code> .  Mit diesem Ansatz können Sie unabhängig mit jedem Konto arbeiten und heterogenen Speicher verwenden, der nicht miteinander verbunden ist.  Das einzige Problem, das uns hier erwartet, ist der Geldverlust im Falle eines Rückgangs des aktuellen Prozesses im Intervall zwischen den halben Transaktionen. </p><br><h2 id="ochered">  Warteschlange </h2><br><p>  Um fortzufahren, müssen Sie eine Ereigniswarteschlange implementieren.  Die Idee ist, dass Handler für die Kommunikation untereinander eine geordnete Nachrichtenwarteschlange benötigen, in der keine Daten verloren gehen oder dupliziert werden.  Dementsprechend wird jede Interaktion in der Handlerkette auf diesem Grundelement aufbauen.  Es ist auch ein nützliches Tool zum Analysieren und Überwachen eingehender und ausgehender Datenströme.  Darüber hinaus können Mutationen des Status der Handler auch über die Warteschlange durchgeführt werden. </p><br><p>  Die Warteschlange besteht aus zwei Operationen: </p><br><ol><li>  Fügen Sie am Ende der Warteschlange eine Nachricht hinzu. </li><li>  Empfangen einer Nachricht aus der Warteschlange am angegebenen Index. </li></ol><br><p>  In diesem Zusammenhang erwäge ich aus mehreren Gründen nicht, Nachrichten aus der Warteschlange zu entfernen: </p><br><ol><li>  Mehrere Prozessoren können aus derselben Warteschlange lesen.  Das Entfernen der Synchronisation ist eine nicht triviale, wenn auch nicht unmögliche Aufgabe. </li><li>  Es ist nützlich, eine Warteschlange für ein relativ langes Intervall (Tag oder Woche) zum Debuggen und Überwachen aufrechtzuerhalten.  Der Nutzen dieser Eigenschaft ist schwer zu überschätzen. </li><li>  Sie können alte Elemente entweder planmäßig löschen oder TTL für die Warteschlangenelemente festlegen.  Es ist wichtig sicherzustellen, dass die Prozessoren die Daten verarbeiten können, bevor der Besen eintrifft und alles bereinigt.  Wenn die Verarbeitungszeit in der Größenordnung von Sekunden und die TTL in der Größenordnung von Tagen liegt, sollte nichts davon passieren. </li></ol><br><p>  Um die Elemente zu speichern und die Addition effektiv zu implementieren, benötigen wir: </p><br><ol><li>  Der Wert mit dem aktuellen Index.  Dieser Index zeigt auf das Ende der Warteschlange zum Hinzufügen von Elementen. </li><li>  ,    . </li></ol><br><h3 id="kak-by-lock-free-ochered">   lock-free  </h3><br><p>          :        .        : </p><br><ol><li>    CAS     . </li><li>       . </li></ol><br><p>    ,    ,     . </p><br><ol><li> <strong>    lock-free</strong> .  ,      ,          . Lock-free?  Nein!   ,    2 :   .         lock-free,     — !    ,  ,        ,   .              .         , ..            ,     . </li><li> <strong>    </strong> .         ,               .    . </li></ol><br><p>  ,    lock-free         . </p><br><h3 id="lock-free-realizaciya-dobavleniya"> Lock-free   </h3><br><p> ,  ,     :   , ..      ,    : </p><br><pre> <code class="hljs pgsql">push(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_current_index() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #  ,    #    var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) #  = <span class="hljs-number"><span class="hljs-number">0</span></span>   , ..   # ,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   ,    queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) break #   , .   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(queue.get_current_index(), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) update_index(queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     cur_index, version = queue.get_current_index_versioned() #      , #  , .   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cur_index &gt;= <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: # -     , #        break <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> queue.current_index_var().CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #      ,   break # -  . # ,      ,  </code> </pre> <br><p>      .   ,            (     — ,  ,     ).       lock-free   .    ? </p><br><p>   ,   <code>push</code>     ,      ! ,             ,      . </p><br><p>        .       :         .   ,      -   ,  -               .  ,      , ..      .          .        ?       , ..     ,    ,        . </p><br><p>  ,       ,          .  Das heißt,    .        ,    ,     .          ,       . </p><br><p>  ,       .               ,   .    ,   ,     .       ,    . </p><br><h2 id="vzaimodeystvie-ocheredey">   </h2><br><p>  ,  ,   ,      . </p><br><p> <em></em> .       . </p><br><p>    ,      : </p><br><ol><li>  , ..  stateless. </li><li>  ,     — . </li></ol><br><p> ,    ,        <em>concurrent exactly-once</em> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>   .        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> #   state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)</code> </pre> <br><p>     <em>exactly-once</em> .   ,           ,    ,    . </p><br><p>    <em>exactly-once</em> ,     ,    . ..,  ,       ,       ,   ,    —      : </p><br><pre> <code class="hljs pgsql">#       get_next_index(queue): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_index() #     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> queue.has(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #    queue.push <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, queue.get_index()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> #      . #  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>    push_at(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   #    {PREPARING, <span class="hljs-number"><span class="hljs-number">0</span></span>} fsm_state = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   :   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): #  ,     input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,  push_at  <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, #        fsm_state = {PREPARING, input_index} state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(fsm_state)</code> </pre> <br><p>        <code>push_at</code> ?      ,   .   ,    ,  ,    .   ,               .             .          -  ,     lock-free . </p><br><p>  ,      : </p><br><ol><li>   :       . </li><li> ,  :      . </li></ol><br><p>   :   <em>concurrent</em>  <em>exactly-once</em> . </p><br><p>      ?   : </p><br><ol><li>       ,         ,   <code>push_at</code>     false.            . </li><li>       ,      . ,   ,       . </li></ol><br><p>     <em>concurrent exactly-once</em>   ?   ,     ,            .    ,           .            . </p><br><p>          : </p><br><pre> <code class="hljs pgsql">#     ,  ,     # ..       <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, #      <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. #       <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> push_at_idempotent(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   ,   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) #   , #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at_idempotent(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> fsm_state = {PREPARING, input_index} #     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>  : </p><br><p><img src="https://habrastorage.org/webt/rx/qi/ub/rxqiubplbrrdlokp_sniqhktmvu.png" alt="Einfach"></p><br><p>     ,     .     ,           . </p><br><p>             kernel panic,   ,    ..              .              .       :      ,    .  ,        . </p><br><p>  ,    <strong> </strong>    ,    . </p><br><h2 id="reshenie-nachalnoy-zadachi">    </h2><br><p>        :    . </p><br><p>       :  ,     ,    ,      ,      : </p><br><pre> <code class="hljs pgsql">#  : # - input_queues -   # - output_queues -   # - state -    # - <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> -    : state, inputs -&gt; state, outputs handle(input_queues, output_queues, state, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>): #        <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: # input_indexes       <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {HANDLING, user_state, input_indexes}: #       inputs = [queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(input_queues, input_indexes)] #   ,    next_indexes = next(inputs, input_indexes) #    #     user_state, outputs = <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(user_state, inputs) #      , #     fsm_state = {PREPARING, user_state, next_indexes, outputs, <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, user_state, input_indexes, outputs, output_pos}: #  ,      #    output_index = output_queues[output_pos].get_next_index() #     fsm_state = { WRITING, user_state, input_indexes, outputs, output_pos, output_index } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> { WRITING, user_state, input_indexes, outputs, output_pos, output_index }: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = outputs[output_pos] #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_queues[output_pos].push_at_idempotent( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index ): #  ,      output_pos += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,      PREPARING. #     #     fsm_state = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_pos == len(outputs): #   , #       {HANDLING, user_state, input_indexes} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #       #   , #         {PREPARING, user_state, input_indexes, outputs, output_pos} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/fe/mk/bg/femkbgvjaxyy2gi9ye5wkaufqf4.png" alt="Finale"></p><br><p>      : <code>HANDLING</code> .        , ..,  ,     .  ,      .    ,   <code>PREPARING</code>  <code>WRITING</code>   ,         .     ,      <code>HANDLING</code> . </p><br><p>  ,      ,       ,          .   ,           .  ,            . </p><br><p>      .         .               . </p><br><p><img src="https://habrastorage.org/webt/or/qk/tg/orqktgqgrdw-9tv0_wkl2wt_rye.png" alt="Finale"></p><br><p>   : </p><br><pre> <code class="hljs cpp">my_handler(state, inputs): #      state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.push(inputs) #    duration state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.trim_time_window(duration) #   avg = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.avg() need_update_counter = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.size() &gt; size_boundary <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, [ avg, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: # none      none ]</code> </pre> <br><p>  ,      ,           <em>concurrent exactly-once</em>     <code>handle</code> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle_db(input_queue, db): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #      tx = db.begin_transaction() #     . #      , #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = tx.get_current_index() #    tx.write_current_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) #      <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = intput_queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: #    tx.increment_counter() tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() #   ,      , #          </code> </pre> <br><p>    .  Weil       ,         , , ,    <em>concurrent exactly-once</em> .       . </p><br><h2 id="za-bortom">   </h2><br><p>   —            .        ,      ,     . </p><br><h3 id="optimizacii-dlya-konkretnogo-hranilischa">     </h3><br><p>      ,      ,       .           ,  ,          . </p><br><h3 id="asinhronnaya-publikaciya">   </h3><br><p>           .    ,     .  Weil        ,      .              .        . </p><br><h3 id="gruppirovka-znacheniy">   </h3><br><p>        —   . ,       ,     .    ,     -  ,   ,    .        , .. ,    ,        . </p><br><h3 id="dvoynoe-shardirovanie">   </h3><br><p>       .   ,     ,           .            ,    ,    . </p><br><h2 id="fundamentalnost-podhoda">   </h2><br><p>     . ,         .  :          ,      .     ,       . </p><br><p>      ,   ,      : </p><br><ol><li>    ,   .          . </li><li>     .      ,        . </li><li>          .    ,       .      ,   ,        .  Das heißt,          .     :    . </li></ol><br><p>     , , -,     ,  -,     . </p><br><p>     ,     .     : </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  <code>withdraw</code>     ,   ,  <code>deposit</code>    :      ?    <code>deposit</code>  -     (,   ,       ),    .  ,    ,    ,   ,        ?    ,   ,      - ,     . </p><br><p>     ,   ,   ,     . ,     ,   ,   .   ,     .   ,       ,       .  Weil     ,       ,        .      ,        :     ,     —  . </p><br><h3 id="dvuhfaznost-bez-blokirovok">    </h3><br><p>      ,       . </p><br><p>      :        ,  ,     ,   ,   .   ,        -  : </p><br><ul><li> <em></em> .            ,   , ,     ,     . </li><li> <em></em> .        . </li></ul><br><p>     , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><p> ,        , ..       ,      ,  .        ,       . </p><br><p>          :     lock-free   ,           .            , ..      ,  . </p><br><p>      CAS       . ,      : </p><br><pre> <code class="hljs swift">#     ,    handle(input, output, state): # ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">HANDLING</span></span>, ...}: #      fsm_state = {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, input_index}: #   ... output_index = ...get_next_index() fsm_state = {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...}: #  ,  output_index</code> </pre> <br><p>  ,     .          .      : </p><br><ol><li> <strong>PREPARING</strong> .     ,        . </li><li> <strong>WRITING</strong> .     .       ,       <strong>PREPARING</strong> . </li></ol><br><p>     ,      . ,          ,     —    .     : </p><br><ol><li>         .  ,    , ..     ,      . </li><li>            , ..       .         ,     . </li></ol><br><p>  ,  lock-free        ,        ,     . </p><br><h2 id="trebovaniya-k-konsistentnosti">    </h2><br><p>  ,     .     ,      <em>Stale Read</em> ,       .   —       CAS:              .       : </p><br><ul><li> <em>Distributed single register</em> —       (, etcd  Zookeeper): <br><ol><li> Linearizability </li><li> Sequential consistency </li></ol></li><li> <em>Transactional</em> —     (, MySQL, PostgreSQL  ..): <br><ol><li> Serializability </li><li> Snapshot Isolation </li><li> Repeatable Read </li><li> Read Committed </li></ol></li><li> <em>Distributed Transactional</em> — NewSQL : <br><ol><li> Strict Consistency </li><li>    </li></ol></li></ul><br><p>   :             ?   ,  ,   .         ,    ,     CAS                .        , ,   <em>Read My Writes</em> . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>        <em>exactly-once</em> .     , ..  ,  ,    ,    .       ,      ,  , , ..        ,     . </p><br><p>       lock-free       . </p><br><p>    : </p><br><ol><li> <strong></strong> :      . </li><li> <strong></strong> :       . </li><li> <strong></strong> :        : <em>exactly-once</em> . </li><li> <strong>Concurrent</strong> :       . </li><li> <strong>Real-time</strong> :     . </li><li> <strong>Lock-free</strong> :      ,     . </li><li> <strong>Deadlock free</strong> :      ,      . </li><li> <strong>Race condition free</strong> :     . </li><li> <strong>Hot-hot</strong> :        . </li><li> <strong>Hard stop</strong> :       . </li><li> <strong>No failover</strong> :                  . </li><li> <strong>No downtime</strong> :    . </li><li> <strong> </strong> :   ,    . </li><li> <strong></strong> :         . </li><li> <strong></strong> :         . </li><li> <strong></strong> :        . </li></ol><br><p>  ,        .  Aber das ist eine andere Geschichte. </p><br><p><img src="https://habrastorage.org/webt/ku/4j/nf/ku4jnf9-1pkdjfh_peshj0xd73w.jpeg" alt="Licht"></p><br><h2 id="novye-terminy">   </h2><br><p>       : </p><br><ol><li> Concurrent exactly-once. </li><li> Semi-transactions  . </li><li> Lock-free two-phase commit,       . </li></ol><br><h2 id="zadachi-dlya-samoistyazaniya">    </h2><br><ol><li>     . </li><li>  lock-free       . </li><li>    . </li></ol><br><h2 id="literatura">  Literatur </h2><br><p> [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">:  ABA.</a> <br> [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog: You Cannot Have Exactly-Once Delivery</a> <br> [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">:         .</a> <br> [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">:  3:  .</a> <br> [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">:  .</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413817/">https://habr.com/ru/post/de413817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413807/index.html">Bestimmung der ballistisch-zeitlichen Eigenschaften der Bewegung des Massenschwerpunkts eines Fallschirmjägers, der aus einem Flugzeug landet</a></li>
<li><a href="../de413809/index.html">Set-Top-Box und Experimente mit Android im LXC-Container</a></li>
<li><a href="../de413811/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 318 (4. - 10. Juni 2018)</a></li>
<li><a href="../de413813/index.html">PHP Digest Nr. 132 (27. Mai - 10. Juni 2018)</a></li>
<li><a href="../de413815/index.html">Gehen Sie Beitrag Workshop in Russland</a></li>
<li><a href="../de413819/index.html">Ehrlich gesagt über den IT-Markt in Russland</a></li>
<li><a href="../de413823/index.html">Der Boom bedeutungsloser Beschäftigung</a></li>
<li><a href="../de413827/index.html">Das Kubernetes-Projekt wird 4 Jahre alt</a></li>
<li><a href="../de413831/index.html">Die neue Version des Tesla Autopilot wird im August erstmals mit „vollständig autonomen Fahrfunktionen“ veröffentlicht.</a></li>
<li><a href="../de413837/index.html">Tower Defense zu einem Einheitsspiel machen - Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>