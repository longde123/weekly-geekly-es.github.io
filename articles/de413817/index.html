<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèº üë®üèª‚ÄçüöÄ üóØÔ∏è Heterogene wettbewerbsf√§hige Datenverarbeitung in Echtzeit nur einmal üöõ üò≥ üö∂üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anmerkung 


 Die Verarbeitung von Daten in Echtzeit genau einmal ( genau einmal ) ist eine √§u√üerst nicht triviale Aufgabe und erfordert einen ernstha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Heterogene wettbewerbsf√§hige Datenverarbeitung in Echtzeit nur einmal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413817/"><p><img src="https://habrastorage.org/webt/uf/mh/m-/ufmhm-q0wjfbdgbv4jn4ece8duw.jpeg" alt="Wettbewerbsforderer wurst"></p><br><h2 id="annotaciya">  Anmerkung </h2><br><p>  Die Verarbeitung von Daten in Echtzeit genau einmal ( <em>genau einmal</em> ) ist eine √§u√üerst nicht triviale Aufgabe und erfordert einen ernsthaften und durchdachten Ansatz √ºber die gesamte Berechnungskette hinweg.  Einige glauben sogar, dass eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">solche Aufgabe unm√∂glich ist</a> .  In der Realit√§t m√∂chte ich einen Ansatz haben, der eine fehlertolerante Verarbeitung ohne Verz√∂gerung und die Verwendung verschiedener Datenspeicher erm√∂glicht und neue, noch strengere Anforderungen an das System stellt: <em>genau einmal gleichzeitig</em> und die Heterogenit√§t der persistenten Schicht.  Bisher unterst√ºtzt eine solche Anforderung keines der vorhandenen Systeme. </p><br><p>  Der vorgeschlagene Ansatz wird konsequent die geheimen Bestandteile und die notwendigen Konzepte aufdecken, die es relativ einfach machen, eine heterogene <em>gleichzeitige, genau einmalige</em> Verarbeitung buchst√§blich aus zwei Komponenten zu implementieren. </p><br><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Der Entwickler verteilter Systeme durchl√§uft mehrere Phasen: </p><br><p>  <em>Stufe 1: Algorithmen</em> .  Hier werden grundlegende Algorithmen, Datenstrukturen, Programmierans√§tze wie OOP usw. untersucht.  Der Code ist ausschlie√ülich Single-Threaded.  Die Anfangsphase des Berufseinstiegs.  Es ist jedoch ziemlich kompliziert und kann Jahre dauern. </p><br><p>  <em>Stufe 2: Multithreading</em> .  Als n√§chstes stellen sich Fragen, wie man aus Eisen maximale Effizienz herausholen kann. Es gibt Multithreading, Asynchronit√§t, Rennen, Debugging, Strace, schlaflose N√§chte ... Viele bleiben in dieser Phase stecken und bekommen irgendwann sogar einen unerkl√§rlichen Nervenkitzel.  Aber nur wenige verstehen die Architektur von virtuellem Speicher und Speichermodellen, sperrfreien / wartungsfreien Algorithmen und verschiedenen asynchronen Modellen.  Und fast niemand jemals - Multithread-Code√ºberpr√ºfung. </p><br><p>  <em>Stufe 3: Verteilung</em> .  Hier passiert so ein M√ºll, den weder in einem M√§rchen noch in einem Stift zu beschreiben ist. </p><a name="habracut"></a><br><p>  Es scheint, dass etwas kompliziert ist.  Wir machen die Transformation: viele Threads -&gt; viele Prozesse -&gt; viele Server.  Aber jeder Schritt der Transformation bringt qualitative Ver√§nderungen mit sich, und alle fallen auf das System, zerdr√ºcken es und verwandeln es in Staub. </p><br><p>  Hier geht es darum, die Fehlerbehandlungsdom√§ne und die Verf√ºgbarkeit des gemeinsam genutzten Speichers zu √§ndern.  Wenn vorher immer ein St√ºck Speicher in jedem Thread verf√ºgbar war und wenn gew√ºnscht, in jedem Prozess, gibt es jetzt kein solches St√ºck und kann es nicht sein.  Jeder f√ºr sich, unabh√§ngig und stolz. </p><br><p>  Wenn fr√ºher ein Fehler im Stream den Stream und den Prozess gleichzeitig vergrub, und das war gut, weil  f√ºhrte nicht zu teilweisen Fehlern, jetzt werden teilweise Fehler zur Norm und jedes Mal vor jeder Aktion denken Sie: ‚ÄûWas w√§re wenn?‚Äú.  Dies ist so √§rgerlich und lenkt vom Schreiben der Aktionen selbst ab, dass der Code dadurch nicht zeitweise, sondern um Gr√∂√üenordnungen w√§chst.  Alles wird zu Nudeln der Fehlerbehandlung, Zustandsumschaltung und Kontexterhaltung, Wiederherstellung aufgrund von Fehlern einer Komponente, einer anderen Komponente, Unzug√§nglichkeit einiger Dienste usw.  usw.  Nachdem Sie die √úberwachung f√ºr all diese Dinge vermasselt haben, k√∂nnen Sie auf Ihrem Lieblings-Laptop gut schlafen. </p><br><p>  Ob es sich um Multithreading handelt: Ich nahm den Mutex und ging, um das gemeinsame Ged√§chtnis zum Vergn√ºgen zu zerst√∂ren.  Sch√∂nheit! </p><br><p>  Infolgedessen haben wir festgestellt, dass die Schl√ºssel- und kampferprobten Muster weggenommen wurden und die neuen, um sie zu ersetzen, aus irgendeinem Grund nicht geliefert wurden, und es stellte sich heraus, wie in einem Witz dar√ºber, wie die Fee ihren Zauberstab schwang und der Turm vom Panzer fiel. </p><br><p>  Verteilte Systeme verf√ºgen jedoch √ºber eine Reihe bew√§hrter Verfahren und bew√§hrter Algorithmen.  Jeder Programmierer mit Selbstachtung sieht es jedoch als seine Pflicht an, bekannte Errungenschaften abzulehnen und trotz der gesammelten Erfahrungen eine betr√§chtliche Anzahl wissenschaftlicher Artikel und akademischer Forschung zu seinem eigenen Wohl zu fahren.  Wenn Sie sich mit Algorithmen und Multithreading besch√§ftigen k√∂nnen, wie k√∂nnen Sie dann mit der Verteilung in Konflikt geraten?  Hier kann es keine zwei Meinungen geben! </p><br><p>  Infolgedessen sind Systeme fehlerhaft, Daten divergieren und verschlechtern sich, Dienste sind regelm√§√üig nicht mehr zum Schreiben verf√ºgbar oder sogar vollst√§ndig nicht mehr verf√ºgbar, da pl√∂tzlich ein Knoten abst√ºrzte, das Netzwerk ausfiel, Java viel Speicher verbrauchte und GC langweilig wurde, und es gibt viele andere Gr√ºnde, die sein Ende verz√∂gern k√∂nnten an die Beh√∂rden. </p><br><p>  Doch auch mit bekannten und bew√§hrten Ans√§tzen wird das Leben nicht einfacher, weil  Verteilte zuverl√§ssige Grundelemente sind schwergewichtig und stellen ernsthafte Anforderungen an die Logik des ausf√ºhrbaren Codes.  Daher werden die Ecken wo immer m√∂glich abgeschnitten.  Und wie so oft, treten bei schnell geschnittenen Ecken Einfachheit und relative Skalierbarkeit auf, aber die Zuverl√§ssigkeit, Verf√ºgbarkeit und Konsistenz eines verteilten Systems verschwindet. </p><br><p>  Im Idealfall m√∂chte ich √ºberhaupt nicht denken, dass unser System verteilt und multithreaded ist, d. H.  Arbeiten Sie in der 1. Stufe (Algorithmen), ohne an die 2. (Multithreading + Asynchronit√§t) und 3. (Verteilung) zu denken.  Diese Art der Isolierung von Abstraktionen w√ºrde die Einfachheit, Zuverl√§ssigkeit und Geschwindigkeit des Schreibens von Code erheblich erh√∂hen.  Leider ist dies derzeit nur in Tr√§umen m√∂glich. </p><br><p>  Einzelne Abstraktionen erm√∂glichen jedoch eine relative Isolation.  Eines der typischen Beispiele ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwendung von Coroutinen</a> , bei denen anstelle von asynchronem Code synchron, d. H.  Wir gehen von der 2. Stufe zur 1. Stufe √ºber, wodurch wir das Schreiben und die Wartung des Codes erheblich vereinfachen k√∂nnen. </p><br><p>  Der Artikel enth√ºllt sukzessive die Verwendung von sperrfreien Algorithmen, um ein zuverl√§ssiges konsistentes verteiltes skalierbares Echtzeitsystem aufzubauen, d.h.  Wie sperrfreie Erfolge der 2. Stufe bei der Implementierung der 3. Stufe helfen und die Aufgabe auf Single-Threaded-Algorithmen der 1. Stufe reduzieren. </p><br><h2 id="postanovka-zadachi">  Erkl√§rung des Problems </h2><br><p>  Diese Aufgabe zeigt nur einige wichtige Ans√§tze und wird als Beispiel f√ºr die Einf√ºhrung von Problemen in den Kontext vorgestellt.  Es kann leicht auf komplexere F√§lle verallgemeinert werden, was in Zukunft geschehen wird. </p><br><p>  <strong>Aufgabe: Echtzeit-Streaming-Datenverarbeitung</strong> . </p><br><p>  Es gibt zwei Zahlenstr√∂me.  Der Handler liest die Daten dieser Eingabestreams und w√§hlt die letzten Nummern f√ºr einen bestimmten Zeitraum aus.  Diese Zahlen werden √ºber dieses Zeitintervall gemittelt, d.h.  in einem verschiebbaren Datenfenster f√ºr eine bestimmte Zeit.  Der erhaltene Durchschnittswert muss f√ºr die nachfolgende Verarbeitung in die Ausgabewarteschlange geschrieben werden.  Wenn die Anzahl der Nummern im Fenster einen bestimmten Schwellenwert √ºberschreitet, erh√∂hen Sie au√üerdem den Z√§hler in der externen Transaktionsdatenbank um eins. </p><br><p><img src="https://habrastorage.org/webt/nf/9d/jh/nf9djhbhsjmrumrg5eckb1h6u_c.png" alt="Anf√§ngliche"></p><br><p>  Wir stellen einige Merkmale dieses Problems fest. </p><br><ol><li>  <em>Nichtdeterminismus</em> .  Es gibt zwei Ursachen f√ºr nicht deterministisches Verhalten: Dies ist ein Messwert aus zwei Streams sowie ein Zeitfenster.  Es ist klar, dass das Lesen auf verschiedene Arten durchgef√ºhrt werden kann und das Endergebnis davon abh√§ngt, in welcher Reihenfolge die Daten extrahiert werden.  Das Zeitfenster √§ndert auch das Ergebnis von Anfang zu Start als  Die Datenmenge im Fenster h√§ngt von der Arbeitsgeschwindigkeit ab. </li><li>  <em>Der Zustand des Handlers</em> .  Es gibt einen Status des Handlers in Form einer Reihe von Zahlen im Fenster, von denen die aktuellen und nachfolgenden Ergebnisse der Arbeit abh√§ngen.  Das hei√üt,  Wir haben einen Stateful Handler. </li><li>  <em>Interaktion mit externem Speicher</em> .  Der Z√§hlerwert in der externen Datenbank muss aktualisiert werden.  Der entscheidende Punkt ist, dass sich die Art des externen Speichers von der Speicherung des Status des Prozessors und der Threads unterscheidet. </li></ol><br><p>  All dies hat, wie unten gezeigt wird, schwerwiegende Auswirkungen auf die verwendeten Tools und die m√∂glichen Implementierungsmethoden. </p><br><p>  Es bleibt eine kleine Ber√ºhrung der Aufgabe, die die Aufgabe sofort von einem Bereich jenseits der Komplexit√§t auf ein Unm√∂gliches √ºbertr√§gt: Eine <em>gleichzeitige, genau einmalige</em> Garantie ist erforderlich. </p><br><h2 id="exactly-once">  Genau einmal </h2><br><p>  <em>Genau einmal wird</em> oft zu weit gefasst, was den Begriff selbst entmannt und die urspr√ºnglichen Anforderungen der Aufgabe nicht mehr erf√ºllt.  Wenn es sich um ein System handelt, das lokal auf einem Computer ausgef√ºhrt wird, ist alles einfach: Nehmen Sie mehr, werfen Sie weiter.  In diesem Fall handelt es sich jedoch um ein verteiltes System, in dem: </p><br><ol><li>  Die Anzahl der Handler kann gro√ü sein: Jeder Handler arbeitet mit seinen eigenen Daten.  Dar√ºber hinaus k√∂nnen die Ergebnisse an verschiedenen Stellen hinzugef√ºgt werden, beispielsweise in einer externen Datenbank, die m√∂glicherweise sogar gemischt wird. </li><li>  Jeder Handler kann die Verarbeitung pl√∂tzlich beenden.  Ein fehlertolerantes System impliziert einen fortgesetzten Betrieb, selbst wenn einzelne Teile des Systems ausfallen. </li></ol><br><p>  Daher m√ºssen wir darauf vorbereitet sein, dass der Handler fallen kann, und ein anderer Handler sollte die bereits geleistete Arbeit aufnehmen und die Verarbeitung fortsetzen. </p><br><p>  Es stellt sich sofort die Frage: Was bedeutet <em>genau einmal</em> , wenn der nicht deterministische Handler funktioniert?  Schlie√ülich erhalten wir bei jedem Neustart im Allgemeinen unterschiedliche resultierende Zust√§nde.  Die Antwort hier ist einfach: Mit <em>genau einmal</em> gibt es eine solche Systemausf√ºhrung, bei der jeder Eingabewert genau einmal verarbeitet wird und das entsprechende Ausgabeergebnis ergibt.  Dar√ºber hinaus muss sich diese Ausf√ºhrung nicht physisch auf demselben Knoten befinden.  Das Ergebnis sollte jedoch so sein, als ob alles auf einem einzelnen logischen Knoten <em>ohne Abst√ºrze verarbeitet wurde</em> . </p><br><h2 id="concurrent-exactly-once">  Genau einmal gleichzeitig </h2><br><p>  Um die Anforderungen zu versch√§rfen, f√ºhren wir ein neues Konzept ein: <em>genau einmal gleichzeitig</em> .  Der grundlegende Unterschied zu einfach <em>genau einmal</em> ist das Fehlen von Pausen w√§hrend der Verarbeitung, als ob alles auf demselben Knoten <strong>ohne Tropfen</strong> und <strong>ohne Pausen verarbeitet worden w√§re</strong> .  In unserer Aufgabe ben√∂tigen wir zur Vereinfachung der Darstellung <em>genau einmal</em> genau <em>gleichzeitig</em> , um einen Vergleich mit vorhandenen Systemen, die heute nicht verf√ºgbar sind, nicht in Betracht zu ziehen. </p><br><p>  Die Konsequenzen einer solchen Anforderung werden nachstehend er√∂rtert. </p><br><h2 id="tranzakcionnost">  Transaktion </h2><br><p>  Damit der Leser noch tiefer von der entstandenen Komplexit√§t durchdrungen ist, schauen wir uns verschiedene schlechte Szenarien an, die bei der Entwicklung eines solchen Systems ber√ºcksichtigt werden m√ºssen.  Wir werden auch versuchen, einen allgemeinen Ansatz zu verwenden, der es uns erm√∂glicht, das oben genannte Problem unter Ber√ºcksichtigung unserer Anforderungen zu l√∂sen. </p><br><p>  Das erste, was mir in den Sinn kommt, ist die Notwendigkeit, den Status des Handlers sowie die Eingabe- und Ausgabestreams aufzuzeichnen.  Der Status der Ausgabestreams wird durch eine einfache Warteschlange von Zahlen und der Status der Eingabestreams durch die Position in ihnen beschrieben.  Im Wesentlichen ist ein Stream eine unendliche Warteschlange, und eine Position in der Warteschlange legt einen Ort eindeutig fest. </p><br><p><img src="https://habrastorage.org/webt/iu/h0/pf/iuh0pfzcezje80kdbsv3idyeu9a.jpeg" alt="Idee"></p><br><p>  Die folgende naive Implementierung eines Handlers erfolgt mithilfe einer Art Data Warehouse.  Zu diesem Zeitpunkt sind die spezifischen Eigenschaften des Repositorys f√ºr uns nicht wichtig.  Wir werden die Pseco-Sprache verwenden, um die Idee zu veranschaulichen (Pseco: = Pseudocode): </p><br><pre><code class="hljs pgsql">handle(input_queues, output_queues, state): #    input_indexes = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_input_indexes() #      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #         items, new_input_indexes = input_queues.get_from(input_indexes) #    state.queue.push(items) #     duration state.queue.trim_time_window(duration) avg = state.queue.avg() need_update_counter = state.queue.size() &gt; size_boundary # (A)      output_queues[<span class="hljs-number"><span class="hljs-number">0</span></span>].push(avg) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: # (B)      db.increment_counter() # (C)     <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_state(state) # (D)    <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_queue_indexes(new_input_indexes) # (E)    input_indexes = new_input_indexes</code> </pre> <br><p>  Hier ist ein einfacher Single-Threaded-Algorithmus, der Daten aus Eingabestreams liest und die gew√ºnschten Werte gem√§√ü der oben beschriebenen Aufgabe schreibt. </p><br><p>  Mal sehen, was passiert, wenn ein Knoten zu beliebigen Zeitpunkten f√§llt oder wenn die Arbeit wieder aufgenommen wird.  Es ist klar, dass im Falle eines Sturzes an den Punkten <code>(A)</code> und <code>(E)</code> alles in Ordnung ist: Entweder wurden die Daten noch nirgendwo aufgezeichnet und wir stellen einfach den Status wieder her und fahren auf dem anderen Knoten fort, oder alle erforderlichen Daten wurden bereits aufgezeichnet und fahren einfach mit dem n√§chsten Schritt fort. </p><br><p>  Im Falle eines Sturzes an allen anderen Punkten erwarten uns jedoch unerwartete Probleme.  Wenn an Punkt <code>(B)</code> ein Abfall auftritt, wird beim Neustart des Handlers der Status wiederhergestellt und der Durchschnittswert in ungef√§hr demselben Zahlenbereich neu aufgezeichnet.  Im Falle eines Abfalls an Punkt <code>(C)</code> zus√§tzlich zum durchschnittlichen Duplikat ein Duplikat im Inkrement des Werts auf.  Und im Falle eines Sturzes in <code>(D)</code> wir einen inkonsistenten Zustand des Handlers: Der Zustand entspricht einem neuen Zeitpunkt und wir lesen die Werte aus den alten Eingabestr√∂men. </p><br><p><img src="https://habrastorage.org/webt/fn/8z/6f/fn8z6f9t3y-fe2hzlepgnie7qps.jpeg" alt="St√∂rungenungen"></p><br><p>  Gleichzeitig √§ndert sich beim Neuanordnen von Aufnahmevorg√§ngen nichts grundlegend: Inkonsistenzen und Duplikate bleiben erhalten.  Wir kommen daher zu dem Schluss, dass alle Aktionen zum √Ñndern des Status des Handlers im Repository, in der Ausgabewarteschlange und in der Datenbank transaktional ausgef√ºhrt werden sollten, d. H.  alles ist gleichzeitig atomar. </p><br><p>  Dementsprechend ist es notwendig, einen Mechanismus zu entwickeln, damit verschiedene Speicher ihren Zustand transaktional √§ndern k√∂nnen und nicht unabh√§ngig voneinander, sondern transaktional zwischen allen Speichern gleichzeitig.  Nat√ºrlich k√∂nnen Sie unseren Speicher in einer externen Datenbank speichern. Bei der Aufgabe wurde jedoch davon ausgegangen, dass das Datenbankmodul und das Modul f√ºr das Streaming-Datenverarbeitungsframework getrennt sind und unabh√§ngig voneinander arbeiten.  Hier m√∂chte ich den schwierigsten Fall betrachten, weil  einfache F√§lle sind nicht interessant zu betrachten. </p><br><h2 id="konkurentnaya-otzyvchivost">  Wettbewerbsf√§higkeit </h2><br><p>  Betrachten Sie die Wettbewerbsausf√ºhrung genau einmal genauer.  Bei einem fehlertoleranten System m√ºssen die Arbeiten ab einem bestimmten Zeitpunkt fortgesetzt werden.  Es ist klar, dass dieser Punkt irgendwann in der Vergangenheit liegen wird, weil  Um die Leistung aufrechtzuerhalten, ist es unm√∂glich, alle Momente von Status√§nderungen in der Gegenwart und in der Zukunft zu speichern: Entweder das letzte Ergebnis von Operationen oder eine Gruppe von Werten zur Erh√∂hung des Durchsatzes wird gespeichert.  Dieses Verhalten f√ºhrt uns sofort zu der Tatsache, dass es nach der Wiederherstellung des Status des Prozessors zu einer gewissen Verz√∂gerung der Ergebnisse kommt, die mit zunehmender Gr√∂√üe der Wertegruppe und der Gr√∂√üe des Status zunimmt. </p><br><p>  Zus√§tzlich zu dieser Verz√∂gerung gibt es auch Verz√∂gerungen im System, die mit dem Laden des Zustands auf einen anderen Knoten verbunden sind.  Dar√ºber hinaus dauert die Erkennung eines Problemknotens einige Zeit und oft viel.  Dies ist vor allem darauf zur√ºckzuf√ºhren, dass bei einer kurzen Erkennungszeit h√§ufige Fehlalarme m√∂glich sind, die zu allen m√∂glichen unangenehmen Spezialeffekten f√ºhren. </p><br><p>  Dar√ºber hinaus stellt sich mit der Zunahme der Anzahl paralleler Prozessoren pl√∂tzlich heraus, dass nicht alle gleich gut funktionieren, auch wenn keine Fehler vorliegen.  Manchmal treten Blunts auf, die auch zu Verz√∂gerungen bei der Verarbeitung f√ºhren.  Der Grund f√ºr solche Blunts kann vielf√§ltig sein: </p><br><ol><li>  <em>Software</em> : GC-Pausen, Speicherfragmentierung, Allokatorpausen, Kernelunterbrechung und Aufgabenplanung, Probleme mit Ger√§tetreibern, die zu Verlangsamungen f√ºhren. </li><li>  <em>Hardware</em> : Hohe Festplatten- oder Netzwerklast, CPU-Drosselung aufgrund von K√ºhlproblemen, √úberlastung usw., Verlangsamung der Festplatte aufgrund technischer Probleme. </li></ol><br><p>  Und dies ist keineswegs eine vollst√§ndige Liste von Problemen, die Handler verlangsamen k√∂nnen. </p><br><p>  Verlangsamung ist dementsprechend eine Selbstverst√§ndlichkeit, mit der man leben muss.  Manchmal ist dies kein ernstes Problem, und manchmal ist es √§u√üerst wichtig, trotz Ausf√§llen oder Verlangsamungen eine hohe Verarbeitungsgeschwindigkeit aufrechtzuerhalten. </p><br><p>  Sofort entsteht die Idee der Duplizierung von Systemen: Lassen Sie uns f√ºr ein und denselben Datenstrom nicht einen, sondern zwei Prozessoren gleichzeitig oder sogar drei ausf√ºhren.  Das Problem hierbei ist, dass in diesem Fall leicht Duplikate und inkonsistentes Systemverhalten auftreten k√∂nnen.  In der Regel sind Frameworks nicht f√ºr dieses Verhalten ausgelegt und legen nahe, dass die Anzahl der Handler zu einem bestimmten Zeitpunkt einen nicht √ºberschreitet.  Systeme, die die beschriebene Duplizierung der Ausf√ºhrung erm√∂glichen, werden <em>genau einmal</em> als <em>gleichzeitig bezeichnet</em> . </p><br><p>  Mit dieser Architektur k√∂nnen Sie mehrere Probleme gleichzeitig l√∂sen: </p><br><ol><li>  Ausfallsicheres Verhalten: Wenn einer der Knoten f√§llt, funktioniert der andere einfach weiter, als w√§re nichts passiert.  Es ist keine zus√§tzliche Koordinierung erforderlich, da  Der zweite Handler wird unabh√§ngig vom Status des ersten ausgef√ºhrt. </li><li>  Entfernen von Blunts: Wer zuerst das Ergebnis geliefert hat, ist gut f√ºr ihn.  Der andere muss nur einen neuen Zustand annehmen und von diesem Moment an fortfahren. </li></ol><br><p>  Insbesondere mit diesem Ansatz k√∂nnen Sie eine schwierige, schwierige Langzeitberechnung f√ºr eine vorhersehbarere Zeit durchf√ºhren, weil  die Wahrscheinlichkeit, dass beide dumm werden und deutlich weniger fallen. </p><br><h3 id="veroyatnostnaya-ocenka">  Wahrscheinlichkeitsbewertung </h3><br><p>  Versuchen wir, die Vorteile einer doppelten Leistung zu bewerten.  Angenommen, mit dem Handler passiert durchschnittlich jeden Tag etwas: Entweder ist der GC abgestumpft oder der Knoten liegt oder die Container sind krebsartig geworden.  Angenommen, wir bereiten Datenpakete in 10 Sekunden vor. </p><br><p>  Dann betr√§gt die Wahrscheinlichkeit, dass w√§hrend der Erstellung des Pakets etwas passiert, <code>10 / (24 ¬∑ 3600) ‚âÉ 1e-4</code> . </p><br><p>  Wenn Sie zwei Handler parallel ausf√ºhren, betr√§gt die Wahrscheinlichkeit, dass beide fliegen, <code>‚âÉ 1e-8</code> .  Diese Veranstaltung wird also in 23 Jahren stattfinden!  Ja, Systeme leben nicht so viel, was bedeutet, dass dies niemals passieren wird! </p><br><p>  Wenn die Vorbereitungszeit der Packung noch k√ºrzer ist und / oder Blunts noch seltener auftreten, erh√∂ht sich diese Zahl nur. </p><br><p>  Wir kommen daher zu dem Schluss, dass der betrachtete Ansatz die Zuverl√§ssigkeit unseres gesamten Systems erheblich erh√∂ht.  Es bleibt nur eine kleine Frage wie diese zu l√∂sen: Wo kann man lesen, wie man ein <em>gleichzeitiges genau einmaliges</em> System erstellt?  Und die Antwort ist einfach: Sie m√ºssen hier lesen. </p><br><h2 id="polutranzakcii">  Halbe Transaktion </h2><br><p>  F√ºr die weitere Diskussion ben√∂tigen wir das Konzept einer <em>halben Transaktion</em> .  Der einfachste Weg, dies zu erkl√§ren, ist ein Beispiel. </p><br><p>  √úberlegen Sie, ob Sie Geld von einem Bankkonto auf ein anderes √ºberweisen m√∂chten.  Der traditionelle Ansatz unter Verwendung von Transaktionen in der Pseco-Sprache kann wie folgt beschrieben werden: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): tx = db.begin_transaction() amount_from = tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Was ist jedoch, wenn diese Transaktionen uns nicht zur Verf√ºgung stehen?  Mit Sperren kann dies wie folgt erfolgen: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #         lock_from = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) lock_to = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Dieser Ansatz kann zu Deadlocks f√ºhren  Sperren k√∂nnen in verschiedenen Sequenzen parallel genommen werden.  Um dieses Verhalten zu korrigieren, reicht es aus, eine Funktion einzuf√ºhren, die gleichzeitig mehrere Sperren in einer deterministischen Reihenfolge aufnimmt (z. B. nach Schl√ºsseln sortiert), wodurch m√∂gliche Deadlocks vollst√§ndig beseitigt werden. </p><br><p>  Die Implementierung kann jedoch etwas vereinfacht werden: </p><br><pre> <code class="hljs vbscript">transfer(from, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): lock_from = db.lock(from) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(from) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: return <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(from, amount_from - amount) lock_from.release() #   , # .. db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>...)     lock_to = db.lock(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) return ok</code> </pre> <br><p>  Dieser Ansatz macht auch den Endzustand konsistent und bewahrt die Invarianten durch die Art der Verhinderung √ºberm√§√üiger Ausgaben von Geldern.  Der Hauptunterschied zum vorherigen Ansatz besteht darin, dass wir in einer solchen Implementierung einen bestimmten Zeitraum haben, in dem sich die Konten in einem inkonsistenten Zustand befinden.  Eine solche Operation impliziert n√§mlich, dass sich der Gesamtzustand der Gelder auf den Konten nicht √§ndert.  In diesem Fall besteht zwischen <code>lock_from.release()</code> und <code>db.lock(to)</code> eine Zeitl√ºcke, in der die Datenbank m√∂glicherweise einen inkonsistenten Wert <code>db.lock(to)</code> : Der Gesamtbetrag kann vom richtigen nach unten abweichen. </p><br><p>  Tats√§chlich haben wir eine Transaktion f√ºr die √úberweisung von Geld in zwei halbe Transaktionen aufgeteilt: </p><br><ol><li>  Die erste halbe Transaktion f√ºhrt einen Scheck durch und zieht den erforderlichen Betrag vom Konto ab. </li><li>  Die zweite halbe Transaktion schreibt den abgehobenen Betrag auf ein anderes Konto. </li></ol><br><p>  Es ist klar, dass die Aufteilung einer Transaktion in kleinere im Allgemeinen das Transaktionsverhalten verletzt.  Und das obige Beispiel ist keine Ausnahme.  Wenn jedoch alle Halbtransaktionen in der Kette vollst√§ndig erf√ºllt sind, stimmt das Ergebnis mit allen erhaltenen Invarianten √ºberein.  Dies ist genau das, was eine wichtige Eigenschaft einer halben Transaktionskette ist. </p><br><p>  Wir verlieren vor√ºbergehend an Konsistenz und erwerben dennoch ein weiteres n√ºtzliches Merkmal: die Unabh√§ngigkeit des Betriebs und damit eine bessere Skalierbarkeit.  Die Unabh√§ngigkeit manifestiert sich in der Tatsache, dass eine halbe Transaktion jedes Mal mit nur einer Zeile arbeitet, ihre Daten liest, pr√ºft und √§ndert, ohne mit anderen Daten zu kommunizieren.  Auf diese Weise k√∂nnen Sie eine Datenbank mischen, deren Transaktionen nur mit einem Shard funktionieren.  Dar√ºber hinaus kann dieser Ansatz im Fall von heterogenen Repositories verwendet werden, d.h.  Halbtransaktionen k√∂nnen bei einem Speichertyp beginnen und bei einem anderen enden.  Es sind solche n√ºtzlichen Eigenschaften, die in Zukunft verwendet werden. </p><br><p>  Es stellt sich eine berechtigte Frage: Wie kann man Half-Trance in verteilten Systemen implementieren und nicht harken?  Um dieses Problem zu beheben, m√ºssen Sie den sperrfreien Ansatz ber√ºcksichtigen. </p><br><h2 id="lock-free">  Schlossfrei </h2><br><p>  Wie Sie wissen, verbessern sperrfreie Ans√§tze manchmal die Leistung von Multithread-Systemen, insbesondere im Fall eines wettbewerbsf√§higen Zugriffs auf die Ressource.  Es ist jedoch v√∂llig offensichtlich, dass ein solcher Ansatz in verteilten Systemen verwendet werden kann.  Lassen Sie uns genauer untersuchen, was sperrenfrei ist und warum diese Eigenschaft bei der L√∂sung unseres Problems hilfreich sein wird. </p><br><p>  Einige Entwickler verstehen manchmal nicht ganz, was sperrenfrei ist.  Der engstirnige Blick deutet darauf hin, dass dies etwas mit Anweisungen f√ºr Atomprozessoren zu tun hat.  Es ist wichtig zu verstehen, dass lock-free die Verwendung von ‚ÄûAtomen‚Äú bedeutet, das Gegenteil ist nicht der Fall, das hei√üt,  Nicht alle ‚ÄûAtomics‚Äú geben ein sperrenfreies Verhalten. </p><br><p>  Eine wichtige Eigenschaft des sperrfreien Algorithmus ist, dass mindestens ein Thread Fortschritte im System macht.  Aber aus irgendeinem Grund schreiben viele diese Eigenschaft als Definition zu (es ist eine so stumpfe Definition, die zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Wikipedia zu finden ist</a> ).  Hier muss eine wichtige Nuance hinzugef√ºgt werden: Fortschritte werden auch bei Stumpfen eines oder mehrerer Threads erzielt.  Dies ist ein sehr kritischer Punkt, der oft √ºbersehen wird und schwerwiegende Auswirkungen auf ein verteiltes System hat. </p><br><p>  Warum negiert das Fehlen einer Fortschrittsbedingung von mindestens einem Thread das Konzept eines sperrfreien Algorithmus?  Tatsache ist, dass in diesem Fall auch der √ºbliche Spinlock sperrfrei ist.  In der Tat wird derjenige, der das Schloss genommen hat, Fortschritte machen.  Gibt es einen Thread mit Fortschritt =&gt; sperrenfrei? </p><br><p>  Lock-free bedeutet nat√ºrlich ohne Sperren, w√§hrend Spinlock mit seinem Namen anzeigt, dass es sich um eine echte Sperre handelt.  Aus diesem Grund ist es wichtig, auch bei Blunts eine Bedingung f√ºr den Fortschritt hinzuzuf√ºgen.  Schlie√ülich k√∂nnen diese Verz√∂gerungen unbegrenzt dauern, weil  Die Definition sagt nichts √ºber die obere Zeitlinie aus.  Und wenn ja, dann sind solche Verz√∂gerungen in gewissem Sinne gleichbedeutend mit dem Abschalten von Fl√ºssen.  In diesem Fall f√ºhren sperrfreie Algorithmen in diesem Fall zu Fortschritten. </p><br><p>  Aber wer hat gesagt, dass sperrfreie Ans√§tze ausschlie√ülich f√ºr Multithread-Systeme gelten?  Durch Ersetzen von Threads im selben Prozess auf demselben Knoten durch Prozesse auf verschiedenen Knoten und des gemeinsam genutzten Speichers der Threads durch gemeinsam genutzten verteilten Speicher erhalten wir einen sperrfreien verteilten Algorithmus. </p><br><p>  Ein Knotenabfall in einem solchen System entspricht einer Verz√∂gerung bei der Ausf√ºhrung eines Threads f√ºr einige Zeit, weil  Es ist Zeit, die Arbeit wiederherzustellen.  Gleichzeitig erm√∂glicht der sperrfreie Ansatz anderen Teilnehmern des verteilten Systems, weiter zu arbeiten.  Dar√ºber hinaus k√∂nnen spezielle sperrfreie Algorithmen parallel zueinander ausgef√ºhrt werden, um eine Wettbewerbs√§nderung zu erkennen und Duplikate auszuschneiden. </p><br><p>  <em>Der genau einmalige</em> Ansatz impliziert das Vorhandensein eines konsistenten verteilten Speichers.  Solche Speicher stellen in der Regel eine riesige persistente Schl√ºsselwerttabelle dar.  M√∂gliche Operationen: <code>set</code> , <code>get</code> , <code>del</code> .  F√ºr den sperrfreien Ansatz ist jedoch eine kompliziertere Operation erforderlich: CAS oder Compare-and-Swap.  Lassen Sie uns diese Operation, die Verwendungsm√∂glichkeiten sowie die daraus resultierenden Ergebnisse genauer betrachten. </p><br><h3 id="cas">  Cas </h3><br><p>  CAS oder Compare-and-Swap ist das wichtigste und wichtigste Synchronisationsprimitiv f√ºr sperrfreie und wartungsfreie Algorithmen.  Sein Wesen kann durch das folgende Pseco veranschaulicht werden: </p><br><pre> <code class="hljs kotlin">CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, new): # ,   atomic,   atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() != expected: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(new) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Manchmal geben sie zur Optimierung nicht <code>true</code> oder <code>false</code> , sondern den vorherigen Wert, weil  Sehr oft werden solche Operationen in einer Schleife ausgef√ºhrt. Um den <code>expected</code> Wert zu erhalten, m√ºssen Sie ihn zuerst lesen: </p><br><pre> <code class="hljs vala">CAS_optimized(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): # ,   atomic,   atomic: current = <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == expected: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current #  CAS   CAS_optimized CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.CAS_optimized(expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) == expected</code> </pre> <br><p>  Dieser Ansatz kann eine Lesung speichern.  Im Rahmen unserer √úberpr√ºfung werden wir eine einfache Form von <code>CAS</code> , weil  Falls gew√ºnscht, kann eine solche Optimierung unabh√§ngig durchgef√ºhrt werden. </p><br><p>  Bei verteilten Systemen wird jede √Ñnderung versioniert.  Das hei√üt,  Zuerst lesen wir den Wert aus dem Speicher und erhalten die aktuelle Version der Daten.  Und dann versuchen wir zu schreiben und erwarten, dass sich die Version der Daten nicht ge√§ndert hat.  In diesem Fall wird die Version jedes Mal erh√∂ht, wenn die Daten aktualisiert werden: </p><br><pre> <code class="hljs cs">CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected_version, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.get_version() != expected_version: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>, expected_version + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Mit diesem Ansatz k√∂nnen Sie die Aktualisierung von Werten genauer steuern und so <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das ABA-Problem</a> vermeiden.  Insbesondere wird die Versionierung von Etcd und Zookeeper unterst√ºtzt. </p><br><p>  Beachten Sie die wichtige Eigenschaft, die die Verwendung von <code>CAS_versioned</code> Operationen bietet.  Tatsache ist, dass eine solche Operation unbeschadet der √ºbergeordneten Logik wiederholt werden kann.  Bei der Multithread-Programmierung hat diese Eigenschaft keinen besonderen Wert, da  Wenn die Operation dort fehlgeschlagen ist, wissen wir mit Sicherheit, dass sie nicht zutraf.  Bei verteilten Systemen wird diese Invariante verletzt, weil  Die Anfrage erreicht m√∂glicherweise den Empf√§nger, aber die erfolgreiche Antwort ist nicht mehr vorhanden.  Daher ist es wichtig, Anforderungen erneut senden zu k√∂nnen, ohne bef√ºrchten zu m√ºssen, Invarianten der Logik auf hoher Ebene zu brechen. </p><br><p>  Diese Eigenschaft <code>CAS_versioned</code> die Operation <code>CAS_versioned</code> .  Tats√§chlich kann dieser Vorgang endlos wiederholt werden, bis die tats√§chliche Antwort des Empf√§ngers zur√ºckgegeben wird.  Dies f√ºhrt wiederum zu einer ganzen Reihe von Fehlern im Zusammenhang mit der Netzwerkinteraktion. </p><br><h3 id="primer">  Beispiel </h3><br><p>  Schauen wir uns an, wie Sie basierend auf <code>CAS_versioned</code> und <code>CAS_versioned</code> von einem Konto auf ein anderes √ºbertragen k√∂nnen, das beispielsweise zu verschiedenen Kopien von Etcd geh√∂rt.  Hier <code>CAS_versioned</code> ich davon aus, dass die <code>CAS_versioned</code> Funktion basierend auf der bereitgestellten API bereits entsprechend implementiert ist. </p><br><pre> <code class="hljs pgsql">withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     version_from, amount_from = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.CAS_versioned(version_from, amount_from - amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: version_to, amount_to = <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.CAS_versioned(version_to, amount_to + amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  Hier haben wir unsere Operation in halbe Transaktionen unterteilt und f√ºhren jede halbe Transaktion √ºber die Operation <code>CAS_versioned</code> .  Mit diesem Ansatz k√∂nnen Sie unabh√§ngig mit jedem Konto arbeiten und heterogenen Speicher verwenden, der nicht miteinander verbunden ist.  Das einzige Problem, das uns hier erwartet, ist der Geldverlust im Falle eines R√ºckgangs des aktuellen Prozesses im Intervall zwischen den halben Transaktionen. </p><br><h2 id="ochered">  Warteschlange </h2><br><p>  Um fortzufahren, m√ºssen Sie eine Ereigniswarteschlange implementieren.  Die Idee ist, dass Handler f√ºr die Kommunikation untereinander eine geordnete Nachrichtenwarteschlange ben√∂tigen, in der keine Daten verloren gehen oder dupliziert werden.  Dementsprechend wird jede Interaktion in der Handlerkette auf diesem Grundelement aufbauen.  Es ist auch ein n√ºtzliches Tool zum Analysieren und √úberwachen eingehender und ausgehender Datenstr√∂me.  Dar√ºber hinaus k√∂nnen Mutationen des Status der Handler auch √ºber die Warteschlange durchgef√ºhrt werden. </p><br><p>  Die Warteschlange besteht aus zwei Operationen: </p><br><ol><li>  F√ºgen Sie am Ende der Warteschlange eine Nachricht hinzu. </li><li>  Empfangen einer Nachricht aus der Warteschlange am angegebenen Index. </li></ol><br><p>  In diesem Zusammenhang erw√§ge ich aus mehreren Gr√ºnden nicht, Nachrichten aus der Warteschlange zu entfernen: </p><br><ol><li>  Mehrere Prozessoren k√∂nnen aus derselben Warteschlange lesen.  Das Entfernen der Synchronisation ist eine nicht triviale, wenn auch nicht unm√∂gliche Aufgabe. </li><li>  Es ist n√ºtzlich, eine Warteschlange f√ºr ein relativ langes Intervall (Tag oder Woche) zum Debuggen und √úberwachen aufrechtzuerhalten.  Der Nutzen dieser Eigenschaft ist schwer zu √ºbersch√§tzen. </li><li>  Sie k√∂nnen alte Elemente entweder planm√§√üig l√∂schen oder TTL f√ºr die Warteschlangenelemente festlegen.  Es ist wichtig sicherzustellen, dass die Prozessoren die Daten verarbeiten k√∂nnen, bevor der Besen eintrifft und alles bereinigt.  Wenn die Verarbeitungszeit in der Gr√∂√üenordnung von Sekunden und die TTL in der Gr√∂√üenordnung von Tagen liegt, sollte nichts davon passieren. </li></ol><br><p>  Um die Elemente zu speichern und die Addition effektiv zu implementieren, ben√∂tigen wir: </p><br><ol><li>  Der Wert mit dem aktuellen Index.  Dieser Index zeigt auf das Ende der Warteschlange zum Hinzuf√ºgen von Elementen. </li><li>  ,    . </li></ol><br><h3 id="kak-by-lock-free-ochered">   lock-free  </h3><br><p>          :        .        : </p><br><ol><li>    CAS     . </li><li>       . </li></ol><br><p>    ,    ,     . </p><br><ol><li> <strong>    lock-free</strong> .  ,      ,          . Lock-free?  Nein!   ,    2 :   .         lock-free,     ‚Äî !    ,  ,        ,   .              .         , ..            ,     . </li><li> <strong>    </strong> .         ,               .    . </li></ol><br><p>  ,    lock-free         . </p><br><h3 id="lock-free-realizaciya-dobavleniya"> Lock-free   </h3><br><p> ,  ,     :   , ..      ,    : </p><br><pre> <code class="hljs pgsql">push(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_current_index() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #  ,    #    var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) #  = <span class="hljs-number"><span class="hljs-number">0</span></span>   , ..   # ,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   ,    queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) break #   , .   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(queue.get_current_index(), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) update_index(queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     cur_index, version = queue.get_current_index_versioned() #      , #  , .   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cur_index &gt;= <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: # -     , #        break <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> queue.current_index_var().CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #      ,   break # -  . # ,      ,  </code> </pre> <br><p>      .   ,            (     ‚Äî ,  ,     ).       lock-free   .    ? </p><br><p>   ,   <code>push</code>     ,      ! ,             ,      . </p><br><p>        .       :         .   ,      -   ,  -               .  ,      , ..      .          .        ?       , ..     ,    ,        . </p><br><p>  ,       ,          .  Das hei√üt,    .        ,    ,     .          ,       . </p><br><p>  ,       .               ,   .    ,   ,     .       ,    . </p><br><h2 id="vzaimodeystvie-ocheredey">   </h2><br><p>  ,  ,   ,      . </p><br><p> <em></em> .       . </p><br><p>    ,      : </p><br><ol><li>  , ..  stateless. </li><li>  ,     ‚Äî . </li></ol><br><p> ,    ,        <em>concurrent exactly-once</em> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>   .        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> #   state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)</code> </pre> <br><p>     <em>exactly-once</em> .   ,           ,    ,    . </p><br><p>    <em>exactly-once</em> ,     ,    . ..,  ,       ,       ,   ,    ‚Äî      : </p><br><pre> <code class="hljs pgsql">#       get_next_index(queue): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_index() #     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> queue.has(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #    queue.push <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, queue.get_index()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> #      . #  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>    push_at(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   #    {PREPARING, <span class="hljs-number"><span class="hljs-number">0</span></span>} fsm_state = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   :   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): #  ,     input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,  push_at  <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, #        fsm_state = {PREPARING, input_index} state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(fsm_state)</code> </pre> <br><p>        <code>push_at</code> ?      ,   .   ,    ,  ,    .   ,               .             .          -  ,     lock-free . </p><br><p>  ,      : </p><br><ol><li>   :       . </li><li> ,  :      . </li></ol><br><p>   :   <em>concurrent</em>  <em>exactly-once</em> . </p><br><p>      ?   : </p><br><ol><li>       ,         ,   <code>push_at</code>     false.            . </li><li>       ,      . ,   ,       . </li></ol><br><p>     <em>concurrent exactly-once</em>   ?   ,     ,            .    ,           .            . </p><br><p>          : </p><br><pre> <code class="hljs pgsql">#     ,  ,     # ..       <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, #      <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. #       <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> push_at_idempotent(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   ,   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) #   , #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at_idempotent(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> fsm_state = {PREPARING, input_index} #     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>  : </p><br><p><img src="https://habrastorage.org/webt/rx/qi/ub/rxqiubplbrrdlokp_sniqhktmvu.png" alt="Einfach"></p><br><p>     ,     .     ,           . </p><br><p>             kernel panic,   ,    ..              .              .       :      ,    .  ,        . </p><br><p>  ,    <strong> </strong>    ,    . </p><br><h2 id="reshenie-nachalnoy-zadachi">    </h2><br><p>        :    . </p><br><p>       :  ,     ,    ,      ,      : </p><br><pre> <code class="hljs pgsql">#  : # - input_queues -   # - output_queues -   # - state -    # - <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> -    : state, inputs -&gt; state, outputs handle(input_queues, output_queues, state, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>): #        <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: # input_indexes       <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {HANDLING, user_state, input_indexes}: #       inputs = [queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(input_queues, input_indexes)] #   ,    next_indexes = next(inputs, input_indexes) #    #     user_state, outputs = <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(user_state, inputs) #      , #     fsm_state = {PREPARING, user_state, next_indexes, outputs, <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, user_state, input_indexes, outputs, output_pos}: #  ,      #    output_index = output_queues[output_pos].get_next_index() #     fsm_state = { WRITING, user_state, input_indexes, outputs, output_pos, output_index } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> { WRITING, user_state, input_indexes, outputs, output_pos, output_index }: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = outputs[output_pos] #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_queues[output_pos].push_at_idempotent( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index ): #  ,      output_pos += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,      PREPARING. #     #     fsm_state = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_pos == len(outputs): #   , #       {HANDLING, user_state, input_indexes} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #       #   , #         {PREPARING, user_state, input_indexes, outputs, output_pos} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/fe/mk/bg/femkbgvjaxyy2gi9ye5wkaufqf4.png" alt="Finale"></p><br><p>      : <code>HANDLING</code> .        , ..,  ,     .  ,      .    ,   <code>PREPARING</code>  <code>WRITING</code>   ,         .     ,      <code>HANDLING</code> . </p><br><p>  ,      ,       ,          .   ,           .  ,            . </p><br><p>      .         .               . </p><br><p><img src="https://habrastorage.org/webt/or/qk/tg/orqktgqgrdw-9tv0_wkl2wt_rye.png" alt="Finale"></p><br><p>   : </p><br><pre> <code class="hljs cpp">my_handler(state, inputs): #      state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.push(inputs) #    duration state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.trim_time_window(duration) #   avg = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.avg() need_update_counter = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.size() &gt; size_boundary <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, [ avg, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: # none      none ]</code> </pre> <br><p>  ,      ,           <em>concurrent exactly-once</em>     <code>handle</code> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle_db(input_queue, db): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #      tx = db.begin_transaction() #     . #      , #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = tx.get_current_index() #    tx.write_current_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) #      <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = intput_queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: #    tx.increment_counter() tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() #   ,      , #          </code> </pre> <br><p>    .  Weil       ,         , , ,    <em>concurrent exactly-once</em> .       . </p><br><h2 id="za-bortom">   </h2><br><p>   ‚Äî            .        ,      ,     . </p><br><h3 id="optimizacii-dlya-konkretnogo-hranilischa">     </h3><br><p>      ,      ,       .           ,  ,          . </p><br><h3 id="asinhronnaya-publikaciya">   </h3><br><p>           .    ,     .  Weil        ,      .              .        . </p><br><h3 id="gruppirovka-znacheniy">   </h3><br><p>        ‚Äî   . ,       ,     .    ,     -  ,   ,    .        , .. ,    ,        . </p><br><h3 id="dvoynoe-shardirovanie">   </h3><br><p>       .   ,     ,           .            ,    ,    . </p><br><h2 id="fundamentalnost-podhoda">   </h2><br><p>     . ,         .  :          ,      .     ,       . </p><br><p>      ,   ,      : </p><br><ol><li>    ,   .          . </li><li>     .      ,        . </li><li>          .    ,       .      ,   ,        .  Das hei√üt,          .     :    . </li></ol><br><p>     , , -,     ,  -,     . </p><br><p>     ,     .     : </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  <code>withdraw</code>     ,   ,  <code>deposit</code>    :      ?    <code>deposit</code>  -     (,   ,       ),    .  ,    ,    ,   ,        ?    ,   ,      - ,     . </p><br><p>     ,   ,   ,     . ,     ,   ,   .   ,     .   ,       ,       .  Weil     ,       ,        .      ,        :     ,     ‚Äî  . </p><br><h3 id="dvuhfaznost-bez-blokirovok">    </h3><br><p>      ,       . </p><br><p>      :        ,  ,     ,   ,   .   ,        -  : </p><br><ul><li> <em></em> .            ,   , ,     ,     . </li><li> <em></em> .        . </li></ul><br><p>     , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . </p><br><p> ,        , ..       ,      ,  .        ,       . </p><br><p>          :     lock-free   ,           .            , ..      ,  . </p><br><p>      CAS       . ,      : </p><br><pre> <code class="hljs swift">#     ,    handle(input, output, state): # ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">HANDLING</span></span>, ...}: #      fsm_state = {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, input_index}: #   ... output_index = ...get_next_index() fsm_state = {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...}: #  ,  output_index</code> </pre> <br><p>  ,     .          .      : </p><br><ol><li> <strong>PREPARING</strong> .     ,        . </li><li> <strong>WRITING</strong> .     .       ,       <strong>PREPARING</strong> . </li></ol><br><p>     ,      . ,          ,     ‚Äî    .     : </p><br><ol><li>         .  ,    , ..     ,      . </li><li>            , ..       .         ,     . </li></ol><br><p>  ,  lock-free        ,        ,     . </p><br><h2 id="trebovaniya-k-konsistentnosti">    </h2><br><p>  ,     .     ,      <em>Stale Read</em> ,       .   ‚Äî       CAS:              .       : </p><br><ul><li> <em>Distributed single register</em> ‚Äî       (, etcd  Zookeeper): <br><ol><li> Linearizability </li><li> Sequential consistency </li></ol></li><li> <em>Transactional</em> ‚Äî     (, MySQL, PostgreSQL  ..): <br><ol><li> Serializability </li><li> Snapshot Isolation </li><li> Repeatable Read </li><li> Read Committed </li></ol></li><li> <em>Distributed Transactional</em> ‚Äî NewSQL : <br><ol><li> Strict Consistency </li><li>    </li></ol></li></ul><br><p>   :             ?   ,  ,   .         ,    ,     CAS                .        , ,   <em>Read My Writes</em> . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>        <em>exactly-once</em> .     , ..  ,  ,    ,    .       ,      ,  , , ..        ,     . </p><br><p>       lock-free       . </p><br><p>    : </p><br><ol><li> <strong></strong> :      . </li><li> <strong></strong> :       . </li><li> <strong></strong> :        : <em>exactly-once</em> . </li><li> <strong>Concurrent</strong> :       . </li><li> <strong>Real-time</strong> :     . </li><li> <strong>Lock-free</strong> :      ,     . </li><li> <strong>Deadlock free</strong> :      ,      . </li><li> <strong>Race condition free</strong> :     . </li><li> <strong>Hot-hot</strong> :        . </li><li> <strong>Hard stop</strong> :       . </li><li> <strong>No failover</strong> :                  . </li><li> <strong>No downtime</strong> :    . </li><li> <strong> </strong> :   ,    . </li><li> <strong></strong> :         . </li><li> <strong></strong> :         . </li><li> <strong></strong> :        . </li></ol><br><p>  ,        .  Aber das ist eine andere Geschichte. </p><br><p><img src="https://habrastorage.org/webt/ku/4j/nf/ku4jnf9-1pkdjfh_peshj0xd73w.jpeg" alt="Licht"></p><br><h2 id="novye-terminy">   </h2><br><p>       : </p><br><ol><li> Concurrent exactly-once. </li><li> Semi-transactions  . </li><li> Lock-free two-phase commit,       . </li></ol><br><h2 id="zadachi-dlya-samoistyazaniya">    </h2><br><ol><li>     . </li><li>  lock-free       . </li><li>    . </li></ol><br><h2 id="literatura">  Literatur </h2><br><p> [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">:  ABA.</a> <br> [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog: You Cannot Have Exactly-Once Delivery</a> <br> [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">:         .</a> <br> [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">:  3:  .</a> <br> [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">:  .</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413817/">https://habr.com/ru/post/de413817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413807/index.html">Bestimmung der ballistisch-zeitlichen Eigenschaften der Bewegung des Massenschwerpunkts eines Fallschirmj√§gers, der aus einem Flugzeug landet</a></li>
<li><a href="../de413809/index.html">Set-Top-Box und Experimente mit Android im LXC-Container</a></li>
<li><a href="../de413811/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 318 (4. - 10. Juni 2018)</a></li>
<li><a href="../de413813/index.html">PHP Digest Nr. 132 (27. Mai - 10. Juni 2018)</a></li>
<li><a href="../de413815/index.html">Gehen Sie Beitrag Workshop in Russland</a></li>
<li><a href="../de413819/index.html">Ehrlich gesagt √ºber den IT-Markt in Russland</a></li>
<li><a href="../de413823/index.html">Der Boom bedeutungsloser Besch√§ftigung</a></li>
<li><a href="../de413827/index.html">Das Kubernetes-Projekt wird 4 Jahre alt</a></li>
<li><a href="../de413831/index.html">Die neue Version des Tesla Autopilot wird im August erstmals mit ‚Äûvollst√§ndig autonomen Fahrfunktionen‚Äú ver√∂ffentlicht.</a></li>
<li><a href="../de413837/index.html">Tower Defense zu einem Einheitsspiel machen - Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>