<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍⚖️ 🌇 🚶🏼 Reembalagem de pacotes em Gradle 👩🏾‍🤝‍👨🏽 🎊 👩‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No meu artigo, quero falar sobre outro truque que pode ser facilmente implementado usando Gradle - reembalando pacotes de bibliotecas. Todo mundo que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reembalagem de pacotes em Gradle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472002/"><p>  No meu artigo, quero falar sobre outro truque que pode ser facilmente implementado usando Gradle - reembalando pacotes de bibliotecas.  Todo mundo que trabalhou um pouco com esse sistema de construção sabe que ele pode resolver automaticamente conflitos de diferentes versões de bibliotecas e, se desejar, você pode influenciar isso, por exemplo, para corrigir uma versão específica de uma biblioteca: </p><br><pre><code class="java hljs">configurations.all { resolutionStrategy { force <span class="hljs-string"><span class="hljs-string">"org.ow2.asm:asm:7.2"</span></span> } }</code> </pre> <br><p>  Infelizmente, isso nem sempre ajuda a resolver o problema do conflito de versão.  Por exemplo, há um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problema conhecido de</a> que alguns dispositivos htc no firmware já possuem uma biblioteca gson e, se sua versão do gson for diferente da incorporada, poderão ocorrer problemas, pois o ClassLoader carregará apenas uma classe na memória e, nesse caso, será de sistema. </p><br><p>  Esse problema também pode ocorrer ao desenvolver bibliotecas.  Se você conectar 2 bibliotecas ao seu projeto que usam a mesma biblioteca de terceiros de versões diferentes, por exemplo 1 e 2, o Gradle resolverá e adotará a versão mais recente, a segunda.  Mas se não houver compatibilidade com versões anteriores nessa biblioteca de terceiros e a segunda versão não puder ser usada apenas em vez da primeira, haverá problemas que certamente serão muito difíceis de rastrear pelo rastreamento.  Uma biblioteca aguardando a primeira versão receberá as segundas aulas e apenas travará. </p><br><p>  Encontrei um conflito de versão ao escrever um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plug</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">in de graduação</a> , ele usa a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">asm</a> , que conflitava.  Depois de escrever o plug-in, verifiquei seu desempenho em um projeto de teste: está tudo bem, verifiquei em um projeto de estimação, está tudo bem também, mas quando o conectei a um projeto de trabalho real com várias dependências de terceiros, tive um problema. </p><br><p><img src="https://habrastorage.org/webt/ln/ed/ar/lnedary9es3gxlyadwfs1yn5xqg.png"></p><br><p>  A solução para o problema sob o corte. </p><a name="habracut"></a><br><h2 id="vse-zhe-rabotalo-chto-poshlo-ne-tak">  No entanto, funcionou, o que deu errado? </h2><br><p>  Temos o rastreamento completo do erro: </p><br><p><img src="https://habrastorage.org/webt/v6/xa/9h/v6xa9hz9b1ajpbztmtlbbowrbko.png"></p><br><p>  Vemos que o erro no construtor da biblioteca asm <code>ClassVisitor</code> está na linha 79.  Vamos dar uma olhada lá, mas ao tentar abrir o <code>ClassVisitor</code> , o estúdio ofereceu 2 opções </p><br><p><img src="https://habrastorage.org/webt/hv/v5/hw/hvv5hwcacmqoj7nompdir2xpxlk.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Meu plugin</a> usa asm versão <code>7.2</code> , então vamos lá e na linha 79 vemos o seguinte: </p><br><p><img src="https://habrastorage.org/webt/rp/88/uj/rp88ujzc58f15b-qwwqtvyikvze.png"></p><br><p>  Claramente não é disso que precisamos.  Agora vá para o <code>ClassVisitor</code> versão 6: </p><br><p><img src="https://habrastorage.org/webt/tb/gw/j9/tbgwj9rxcgnfpmeururnlpwftoe.png"></p><br><p>  Apenas nossa <code>IllegalArgumentException</code> sem uma mensagem.  Meu plug-in usa a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">versão</a> <code>Opcodes.ASM7</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">api 7 do</a> <code>Opcodes.ASM7</code> e, na versão 6 da biblioteca, essa API ainda não existe, portanto, uma <code>IllegalArgumentException</code> no construtor voa.  Podemos concluir que o plugin recebe uma versão incorreta da biblioteca. </p><br><p>  Pergunta de lixo, pensei, e fiz o seguinte: </p><br><pre> <code class="java hljs">configurations.all { resolutionStrategy { force <span class="hljs-string"><span class="hljs-string">"org.ow2.asm:asm:7.2"</span></span> } }</code> </pre> <br><p>  Para meu pesar, isso não teve absolutamente nenhum efeito.  Ainda não consegui descobrir o motivo exato pelo qual não é possível corrigir a versão asm excessivamente, embora o <code>./gradlew app:dependencies</code> mostre que a versão foi substituída pela 7.2.  Se alguém tiver pensamentos ou suposições, ficarei feliz em ouvir uma opinião. </p><br><h2 id="problemu-nado-kak-to-reshat">  O problema deve ser resolvido de alguma forma </h2><br><p>  Uma série de pesquisas e aprofundamentos no trabalho do granizo começou.  Como resultado, fui ao site da ASM, talvez eles saibam algo sobre isso.  Acontece que eles realmente sabem, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">resposta para a minha pergunta</a> estava na seção FAQ.  Eles dizem que, para substituir o pacote asm por outro, eles ainda oferecem um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">utilitário</a> para isso.  Ok, vamos tentar.  Você só precisa conectar o plug-in e fazer uma pequena configuração: </p><br><pre> <code class="java hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'org.anarres.jarjar'</span></span> ... dependencies { <span class="hljs-function"><span class="hljs-function">implementation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fileTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'build/jarjar'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, include: [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'*.jar'</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> implementation jarjar.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">repackage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'asm'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ from <span class="hljs-string"><span class="hljs-string">'org.ow2.asm:asm:7.2'</span></span> classRename <span class="hljs-string"><span class="hljs-string">"org.objectweb.asm.**"</span></span>, <span class="hljs-string"><span class="hljs-string">"stater.org.objectweb.asm.@1"</span></span> } }</code> </pre> <br><p>  <code>build/jarjar</code> nesse caso, o diretório no qual o arquivo jar da biblioteca asm com pacotes reembalados será gerado, portanto, é necessário abrir o acesso de dependência a esse diretório por meio do <code>fileTree</code> .  A biblioteca estará agora disponível com import <code>stater.org.objectweb.asm.*</code> Em vez de <code>org.objectweb.asm.*</code> .  Este plugin possui várias configurações, mas no meu exemplo, basta alterar os pacotes. </p><br><p>  Em seguida, percorra todo o projeto e altere a importação em todos os lugares, de <code>org.objectweb.asm</code> para <br>  <code>stater.org.objectweb.asm</code> .  Na minha opinião, um utilitário muito conveniente, muitas vezes mais fácil do que fazê-lo manualmente, especialmente ao atualizar a biblioteca, mudamos <code>from 'org.ow2.asm:asm:7.2'</code> para a nova versão e o apelido do jar reembalado com a nova versão será gerado em máquina automática </p><br><p>  Se você tiver apenas um projeto (não uma biblioteca), isso será suficiente para resolver conflitos insolúveis, como o gson mencionado no início do artigo.  Mas se você, como eu, escreve uma biblioteca, isso não é tudo. </p><br><p>  Resolvemos o problema de reembalagem, mas agora o <code>asm</code> conectado ao projeto não através da dependência do repositório remoto do maven, mas através do arquivo jar local, que simplesmente será perdido quando a sua biblioteca for implantada e haverá um erro <code>NoClassDefFoundError</code> .  Mas esse problema é bastante simples de resolver: </p><br><ol><li><p>  Em nosso arquivo gradle, crie uma nova configuração: </p><br><pre> <code class="java hljs">configurations { extraLibs implementation.extendsFrom(extraLibs) }</code> </pre> <br></li><li><p>  Em seguida, mudamos </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">implementation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fileTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'build/jarjar'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, include: [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'*.jar'</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span></code> </pre> <br><p>  em </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">extraLibs </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fileTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'build/jarjar'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, include: [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'*.jar'</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span></code> </pre> <br></li><li><p>  Redefinimos a tarefa responsável por coletar seu arquivo jar final e gravamos todas as bibliotecas com nossa nova configuração no apelido final do jar: </p><br><pre> <code class="plaintext hljs">jar { from { configurations.extraLibs.collect { it.isDirectory() ? it : zipTree(it) } } }</code> </pre> <br></li></ol><br><p>  Isso é tudo, implante nosso plug-in como antes, conecte-se ao projeto onde houve conflitos insolúveis e tudo funciona bem. <br>  Tal reembalagem torna nossa biblioteca mais tolerante a falhas quando conectada a vários tipos de projetos com outras bibliotecas. </p><br><h3 id="a-esli-prosto-podklyuchit-jar-fayl-konfliktuyuschey-biblioteki-k-plaginu-bez-pereupakovki">  E se você apenas conectar o arquivo jar da biblioteca conflitante ao plug-in sem reembalar? </h3><br><p>  Má ideia, não levará a nada de bom.  No processo de construção do projeto, há uma <code>check...DuplicateClasses</code> tarefa tão interessante <code>check...DuplicateClasses</code> , que simplesmente mata arquivos com os mesmos pacotes.  Ou seja, arquivos obtidos do arquivo jar da biblioteca conectada e arquivos da mesma biblioteca conectados através do repositório remoto.  O resultado será este erro: </p><br><p><img src="https://habrastorage.org/webt/9-/jo/y7/9-joy7dsnaqekwwqseztj_7hgsm.png"></p><br><p>  Só isso.  Obrigado a todos que leram! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tulsa para reembalagem</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Plug-in de exemplo</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472002/">https://habr.com/ru/post/pt472002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471990/index.html">Meta gramática para analisador PEG</a></li>
<li><a href="../pt471992/index.html">Implementando os recursos restantes do PEG</a></li>
<li><a href="../pt471994/index.html">Trabalhar no PEG no Core Developer Sprint</a></li>
<li><a href="../pt471998/index.html">F # 10: Listas</a></li>
<li><a href="../pt472000/index.html">“É fundamental que a comunidade estabeleça padrões”: Marchin Moskala sobre Kotlin</a></li>
<li><a href="../pt472004/index.html">Boost.Spirit, ou adicione "Espiritualidade" aos filtros da lista</a></li>
<li><a href="../pt472006/index.html">Por que é útil reinventar as rodas</a></li>
<li><a href="../pt472012/index.html">Kanban em meia hora</a></li>
<li><a href="../pt472014/index.html">OTUS. Nossos erros favoritos</a></li>
<li><a href="../pt472018/index.html">Sistema de controle de biblioteca na Flask-Potion, Parte 0: preparando tudo que você precisa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>