<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ú≥Ô∏è üóæ üì≥ Guide JavaScript Partie 8: Pr√©sentation des fonctionnalit√©s d'ES6 ‚èÆÔ∏è üéí üë©üèΩ‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, dans la huiti√®me partie de la traduction du manuel JavaScript, nous passerons en revue les fonctionnalit√©s du langage qui y figurait apr√®...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide JavaScript Partie 8: Pr√©sentation des fonctionnalit√©s d'ES6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431074/">  Aujourd'hui, dans la huiti√®me partie de la traduction du manuel JavaScript, nous passerons en revue les fonctionnalit√©s du langage qui y figurait apr√®s la sortie de la norme ES6.  D'une mani√®re ou d'une autre, nous avons rencontr√© plusieurs de ces opportunit√©s plus t√¥t, quelque part en les approfondissant, quelque part en tenant pour acquis.  Cette section du guide vise, avec la divulgation de certains sujets que nous n'avons pas abord√©s auparavant, √† rationaliser les connaissances d'un d√©veloppeur novice dans le domaine du JavaScript moderne. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: premier programme, fonctionnalit√©s linguistiques, normes</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2: style de code et structure du programme</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: variables, types de donn√©es, expressions, objets</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 4: caract√©ristiques</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 5: tableaux et boucles</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 6: exceptions, points-virgules, litt√©raux g√©n√©riques</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 7: mode strict, ce mot-cl√©, √©v√©nements, modules, calculs math√©matiques</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 8: Pr√©sentation des fonctionnalit√©s d'ES6</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 9: Pr√©sentation des normes ES7, ES8 et ES9</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">√Ä propos d'ES6</font> </h2><br>  La norme ES6, qui serait plus correcte d'appeler ES2015 ou ECMAScript 2015 (ce sont ses noms officiels, bien que tout le monde l'appelle ES6), est apparue 4 ans apr√®s la publication de la norme pr√©c√©dente - ES5.1.  Il a fallu une dizaine d'ann√©es pour d√©velopper tout ce qui entrait dans la norme ES5.1.  De nos jours, tout ce qui figurait dans cette norme est devenu l'outil habituel du d√©veloppeur JS.  Il convient de noter que ES6 a apport√© des modifications majeures √† la langue (tout en conservant une compatibilit√© descendante avec ses versions pr√©c√©dentes).  Afin d'appr√©cier l'ampleur de ces changements, on peut noter que la taille du document d√©crivant la norme ES5 est d'environ 250 pages, et la norme ES6 est d√©crite dans un document qui compte d√©j√† environ 600 pages. <br><br>  La liste des innovations les plus importantes de la norme ES2015 peut comprendre les √©l√©ments suivants: <br><br><ul><li>  Fonctions fl√©ch√©es </li><li>  Promesses </li><li>  G√©n√©rateurs </li><li> Mots <code>let</code> cl√©s <code>let</code> et <code>const</code> </li><li>  Cours </li><li>  Modules </li><li>  Support litt√©ral de mod√®le </li><li>  Prise en charge des param√®tres de fonction par d√©faut </li><li>  Op√©rateur de diffusion </li><li>  Affectation destructrice </li><li>  Am√©lioration des litt√©raux d'objets </li><li>  <code>for...of</code> boucle </li><li>  Prise en charge des structures de donn√©es <code>Map</code> and <code>Set</code> </li></ul><br>  Consid√©rez ces possibilit√©s. <br><br><h2>  <font color="#3AC1EF">Fonctions fl√©ch√©es</font> </h2><br>  Les fonctions fl√©ch√©es ont chang√© l'apparence du code JavaScript.  En termes d'apparence, leur utilisation rend les d√©clarations de fonctions plus courtes et plus faciles.  Voici la d√©claration d'une fonction r√©guli√®re. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Mais presque la m√™me (mais pas compl√®tement similaire √† la pr√©c√©dente) fonction de fl√®che. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Si le corps de la fonction fl√®che se compose d'une seule ligne, dont le r√©sultat doit √™tre renvoy√© par cette fonction, alors il est √©crit encore plus court. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething()</code> </pre> <br>  Si la fonction fl√®che ne prend qu'un seul param√®tre, vous pouvez l'√©crire comme suit. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomething(param)</code> </pre> <br>  Il est √† noter qu'avec l'av√®nement des fonctions fl√®ches, les fonctions ordinaires n'ont plus disparu, elles peuvent encore √™tre utilis√©es dans le code, elles fonctionnent de la m√™me mani√®re qu'auparavant. <br><br><h2>  <font color="#3AC1EF">Ce mot-cl√© figure dans les fonctions fl√©ch√©es</font> </h2><br>  Les fonctions fl√©ch√©es n'ont pas leur propre valeur, elles l'h√©ritent du contexte d'ex√©cution. <br><br>  Cela corrige le probl√®me, pour lequel, lors de l'utilisation de fonctions r√©guli√®res, il √©tait n√©cessaire d'utiliser des constructions comme <code>var that = this</code> pour pr√©server le contexte.  Cependant, comme cela a √©t√© montr√© dans les parties pr√©c√©dentes du manuel, cette modification affecte s√©rieusement les caract√©ristiques de l'utilisation des fonctions fl√©ch√©es et la port√©e de leur application. <br><br><h2>  <font color="#3AC1EF">Promesses</font> </h2><br>  Les promesses vous permettent de vous d√©barrasser du probl√®me bien connu appel√© ¬´enfer de rappel¬ª, bien que leur utilisation implique l'utilisation de structures assez complexes.  Ce probl√®me a √©t√© r√©solu dans la norme ES2017 avec l'av√®nement de la construction <code>async/await</code> , qui est bas√©e sur des promesses. <br><br>  Les d√©veloppeurs JavaScript ont utilis√© des promesses avant la norme ES2015, en utilisant diverses biblioth√®ques pour cela (par exemple - jQuery, q, deferred.js, vow).  Cela indique l'importance et la pertinence de ce m√©canisme.  Diff√©rentes biblioth√®ques l'impl√©mentent de diff√©rentes mani√®res, l'√©mergence d'une norme dans ce domaine peut √™tre consid√©r√©e comme un fait tr√®s positif. <br>  Voici le code √©crit √† l'aide des fonctions de rappel (rappels). <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  En utilisant des promesses, cela peut √™tre r√©√©crit comme suit. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) wait().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 1s'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wait() }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I promised to run after 2s'</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">G√©n√©rateurs</font> </h2><br>  Les g√©n√©rateurs sont des fonctions sp√©ciales qui peuvent suspendre leur propre ex√©cution et la reprendre.  Cela permet √† un autre code d'√™tre ex√©cut√© pendant que le g√©n√©rateur est inactif. <br><br>  Le g√©n√©rateur d√©cide lui-m√™me qu'il doit faire une pause et permettre √† un autre code, "en attente" de son tour, de s'ex√©cuter.  Dans le m√™me temps, le g√©n√©rateur a la possibilit√© de poursuivre son ex√©cution apr√®s que l'op√©ration, dont il attend les r√©sultats, soit termin√©e. <br><br>  Tout cela se fait gr√¢ce √† un seul mot-cl√© simple de <code>yield</code> .  Lorsque ce mot-cl√© est trouv√© dans le g√©n√©rateur, son ex√©cution est suspendue. <br>  Un g√©n√©rateur peut contenir plusieurs lignes avec ce mot-cl√©, interrompant sa propre ex√©cution plusieurs fois.  Les g√©n√©rateurs sont d√©clar√©s √† l'aide de la construction de <code>*function</code> .  Cet ast√©risque devant le mot <code>function</code> ne doit pas √™tre pris pour quelque chose comme un op√©rateur de d√©r√©f√©rencement de pointeur utilis√© dans des langages comme C, C ++ ou Go. <br><br>  Les g√©n√©rateurs marquent l'av√®nement d'un nouveau paradigme de programmation JavaScript.  En particulier, ils permettent l'√©change de donn√©es bidirectionnel entre le g√©n√©rateur et un autre code, et permettent la cr√©ation de boucles de longue dur√©e de vie qui ne ¬´suspendent¬ª pas le programme. <br><br>  Prenons un exemple illustrant les caract√©ristiques du fonctionnement des g√©n√©rateurs.  Voici le g√©n√©rateur lui-m√™me. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doubleThat = <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (input / <span class="hljs-number"><span class="hljs-number">2</span></span>))   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> another = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (doubleThat)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (input * doubleThat * another) }</code> </pre> <br>  Avec cette commande, nous l'initialisons. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> calc = calculator(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br>  Puis nous nous tournons vers son it√©rateur. <br><br><pre> <code class="javascript hljs">calc.next()</code> </pre> <br>  Cette commande d√©marre un it√©rateur, elle retourne un tel objet. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br>  Ici, ce qui suit se produit.  Le code ex√©cute une fonction en utilisant la valeur d' <code>input</code> transmise au constructeur du g√©n√©rateur.  Le code g√©n√©rateur est ex√©cut√© jusqu'√† ce que le mot-cl√© <code>yield</code> soit trouv√©.  √Ä ce stade, il renvoie le r√©sultat de la division de l' <code>input</code> par <code>2</code> , ce qui, puisque l' <code>input</code> est <code>10</code> , donne le nombre <code>5</code> .  Nous obtenons ce nombre gr√¢ce √† l'it√©rateur et, avec lui, une indication que le g√©n√©rateur n'est pas encore termin√© (la propri√©t√© <code>done</code> dans l'objet retourn√© par l'it√©rateur est d√©finie sur <code>false</code> ), c'est-√†-dire que la fonction n'a √©t√© suspendue. <br>  La prochaine fois que l'it√©rateur sera appel√©, nous passerons le num√©ro <code>7</code> au g√©n√©rateur. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre> <br>  En r√©ponse √† cela, l'it√©rateur nous renvoie l'objet suivant. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> value: <span class="hljs-number"><span class="hljs-number">14</span></span> }</code> </pre> <br>  Ici, le nombre <code>7</code> √©t√© utilis√© pour calculer la valeur <code>doubleThat</code> . <br><br>  √Ä premi√®re vue, il peut sembler que le code d' <code>input / 2</code> ressemble √† un argument d'une fonction, mais ce n'est que la valeur renvoy√©e √† la premi√®re it√©ration.  Ici, nous sautons cette valeur et utilisons la nouvelle valeur d'entr√©e <code>7</code> , en la multipliant par <code>2</code> .  Apr√®s cela, nous arrivons au deuxi√®me mot cl√© <code>yield</code> , par cons√©quent, la valeur obtenue dans la deuxi√®me it√©ration est <code>14</code> . <br><br>  √Ä la prochaine it√©ration, qui est la derni√®re, nous passons le nombre <code>100</code> au g√©n√©rateur. <br><br><pre> <code class="javascript hljs">calc.next(<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  En r√©ponse, nous obtenons l'objet suivant. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> value: <span class="hljs-number"><span class="hljs-number">14000</span></span> }</code> </pre> <br>  L'it√©ration est termin√©e (le mot-cl√© <code>yield</code> ne se trouve plus dans le g√©n√©rateur), le r√©sultat de l'√©valuation de l'expression <code>(input * doubleThat * another)</code> retourn√© dans l'objet, soit - <code>10 * 14 * 100</code> et une indication de l'ach√®vement de l'it√©rateur ( <code>done: true</code> ). <br><br><h2>  <font color="#3AC1EF">Mots-cl√©s let et const</font> </h2><br>  JavaScript a toujours utilis√© le mot cl√© <code>var</code> pour d√©clarer des variables.  Ces variables ont une port√©e fonctionnelle.  Les mots cl√©s <code>let</code> et <code>const</code> , respectivement, vous permettent de d√©clarer des variables et des constantes qui ont une port√©e de bloc. <br><br>  Cela signifie que, par exemple, une variable d√©clar√©e √† l'aide du mot cl√© <code>let</code> dans une boucle, √† l'int√©rieur d'un bloc <code>if</code> , ou √† l'int√©rieur d'un bloc de code normal limit√© par des accolades, n'ira pas au-del√† de ce bloc.  Les variables d√©clar√©es avec <code>var</code> ne sont pas conserv√©es dans de tels blocs, devenant disponibles dans la fonction au niveau de laquelle elles sont d√©clar√©es. <br><br>  Le mot cl√© <code>const</code> fonctionne exactement comme <code>let</code> , mais avec lui, les constantes immuables sont d√©clar√©es. <br><br>  Dans le code JS moderne, le mot-cl√© <code>var</code> est rarement utilis√©.  Il a c√©d√© la place aux mots cl√©s <code>let</code> et <code>const</code> .  Dans le m√™me temps, ce qui peut sembler inhabituel, le mot-cl√© <code>const</code> est tr√®s largement utilis√© aujourd'hui, ce qui indique la popularit√© des id√©es d'immunit√© des entit√©s dans la programmation moderne. <br><br><h2>  <font color="#3AC1EF">Cours</font> </h2><br>  Il s'est av√©r√© que JavaScript √©tait le seul langage extr√™mement r√©pandu utilisant le mod√®le d'h√©ritage prototype.  Les programmeurs passant √† JS √† partir de langages qui impl√©mentent le m√©canisme d'h√©ritage bas√© sur les classes se sentaient mal √† l'aise dans un tel environnement.  La norme ES2015 a introduit la prise en charge des classes en JavaScript.  Il s'agit essentiellement de ¬´sucre syntaxique¬ª autour des m√©canismes internes de JS utilisant des prototypes.  Cependant, cela affecte la fa√ßon exacte dont les applications JS √©crivent. <br><br>  Les m√©canismes d'h√©ritage JavaScript ressemblent d√©sormais √† des m√©canismes similaires dans d'autres langages orient√©s objet. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name } hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, I am '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name + <span class="hljs-string"><span class="hljs-string">'.'</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ hello() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.hello() + <span class="hljs-string"><span class="hljs-string">' I am an actor.'</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomCruise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Actor(<span class="hljs-string"><span class="hljs-string">'Tom Cruise'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(tomCruise.hello())</code> </pre> <br>  Ce programme affiche le texte <code>Hello, I am Tom Cruise. I am an actor</code> sur la console <code>Hello, I am Tom Cruise. I am an actor</code>  <code>Hello, I am Tom Cruise. I am an actor</code> . <br>  Dans les classes JS, les variables d'instance ne peuvent pas √™tre d√©clar√©es; elles doivent √™tre initialis√©es dans les constructeurs. <br><br><h3>  <font color="#3AC1EF">Constructeur de classe </font> </h3><br>  Les classes ont une m√©thode sp√©ciale, <code>constructor</code> , qui est appel√©e lorsqu'une instance de la classe est cr√©√©e √† l'aide du <code>new</code> mot cl√©. <br><br><h3>  <font color="#3AC1EF">‚ñç Mot-cl√© super</font> </h3><br>  Le <code>super</code> mot <code>super</code> cl√© vous permet d'acc√©der √† la classe parent √† partir des classes descendantes. <br><br><h3>  <font color="#3AC1EF">‚ñç Getters et setters</font> </h3><br>  Le getter d'une propri√©t√© peut √™tre d√©fini comme suit. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ get fullName() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.firstName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.lastName}</span></span></span><span class="hljs-string">`</span></span> } }</code> </pre> <br>  Le passeur peut √™tre d√©crit comme indiqu√© ci-dessous. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ set age(years) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.theAge = years } }</code> </pre> <br>  Ils travaillent avec des getters et des setters comme s'ils n'√©taient pas des fonctions, mais des propri√©t√©s ordinaires des objets. <br><br><h2>  <font color="#3AC1EF">Modules</font> </h2><br>  Avant la norme ES2015, il y avait plusieurs approches concurrentes pour travailler avec des modules.  En particulier, nous parlons des technologies RequireJS et CommonJS.  Cette situation a conduit √† un d√©saccord dans la communaut√© des d√©veloppeurs JS. <br><br>  De nos jours, gr√¢ce √† la standardisation des modules dans ES2015, la situation se normalise progressivement. <br><br><h3>  <font color="#3AC1EF">‚ñç Importer des modules</font> </h3><br>  Les modules sont import√©s √† l'aide d'une construction du formulaire <code>import...from...</code>  Voici quelques exemples. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { React, Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyLibrary <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Exportation de modules</font> </h3><br>  Les m√©canismes internes du module sont ferm√©s du monde ext√©rieur, mais √† partir du module, vous pouvez exporter tout ce qu'il peut offrir √† d'autres modules.  Cela se fait √† l'aide du mot-cl√© d' <code>export</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Litt√©raux de mod√®le</font> </h3><br>  Les litt√©raux de mod√®le sont une nouvelle fa√ßon de d√©crire les cha√Ænes en JavaScript.  Voici √† quoi √ßa ressemble. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aString = <span class="hljs-string"><span class="hljs-string">`A string`</span></span></code> </pre> <br>  De plus, l'utilisation de la syntaxe des litt√©raux de mod√®le vous permet d'incorporer des expressions dans des cha√Ænes et de les interpoler.  Cela se fait en utilisant une construction de la forme <code>${a_variable}</code> .  Voici un exemple simple de son utilisation: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${v}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-comment"><span class="hljs-comment">//something test</span></span></code> </pre> <br>  Voici un exemple plus compliqu√©, illustrant la possibilit√© d'√©valuer des expressions et de substituer leurs r√©sultats dans une cha√Æne. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str2 = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${foo() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span></code> </pre> <br>  Gr√¢ce √† l'utilisation de litt√©raux de mod√®le, il est devenu beaucoup plus facile de d√©clarer des cha√Ænes multi-lignes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str3 = <span class="hljs-string"><span class="hljs-string">`Hey this string is awesome!`</span></span></code> </pre> <br>  Comparez cela avec ce que vous avez d√ª faire pour d√©crire les cha√Ænes multilignes lors de l'utilisation des fonctionnalit√©s disponibles dans la langue avant ES2015. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">'One\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Two\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'Three'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Param√®tres de fonction par d√©faut</font> </h2><br>  D√©sormais, les fonctions prennent en charge les param√®tres utilis√©s par d√©faut - dans le cas o√π les arguments correspondants ne leur sont pas transmis lors de l'appel des fonctions. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, testing = true</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } foo()</code> </pre> <br><h2>  <font color="#3AC1EF">Op√©rateur de diffusion</font> </h2><br>  L'op√©rateur d'√©talement (op√©rateur d'extension) vous permet de ¬´d√©velopper¬ª des tableaux, des objets ou des cha√Ænes.  Cet op√©rateur ressemble √† trois points ( <code>...</code> ).  Tout d'abord, consid√©rez-le avec un exemple de tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br>  Voici comment cr√©er un nouveau tableau bas√© sur ce tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = [...a, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]</code> </pre> <br>  Voici comment cr√©er une copie du tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = [...a]</code> </pre> <br>  Cet op√©rateur fonctionne √©galement avec les objets.  Par exemple, voici comment l'utiliser pour cloner un objet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newObj = { ...oldObj }</code> </pre> <br>  En appliquant l'op√©rateur d'√©talement √† une cha√Æne, vous pouvez le convertir en un tableau, dont chaque √©l√©ment contient un caract√®re de cette cha√Æne. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hey = <span class="hljs-string"><span class="hljs-string">'hey'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrayized = [...hey] <span class="hljs-comment"><span class="hljs-comment">// ['h', 'e', 'y']</span></span></code> </pre> <br>  Cet op√©rateur, en plus des variantes ci-dessus de son application, est pratique √† utiliser lors de l'appel de fonctions qui attendent une liste normale d'arguments, en leur passant un tableau avec ces arguments. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">foo, bar</span></span></span><span class="hljs-function">) =&gt;</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] f(...a)</code> </pre> <br>  Auparavant, cela se faisait √† l'aide d'une construction de la forme <code>f.apply(null, a)</code> , mais un tel code est plus difficile √† √©crire et il est moins lisible. <br><br><h2>  <font color="#3AC1EF">Affectation destructrice</font> </h2><br>  La technique d'assignation d√©structurante permet, par exemple, de prendre un objet, d'en extraire certaines valeurs et de les placer dans des variables ou constantes nomm√©es. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: <span class="hljs-string"><span class="hljs-string">'Tom'</span></span>, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: <span class="hljs-string"><span class="hljs-string">'Cruise'</span></span>, <span class="hljs-attr"><span class="hljs-attr">actor</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">54</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {<span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: name, age} = person</code> </pre> <br>  Ici, les propri√©t√©s <code>firstName</code> et <code>age</code> sont r√©cup√©r√©es de l'objet.  La propri√©t√© <code>age</code> est √©crite dans la constante d√©clar√©e avec le m√™me nom et la propri√©t√© <code>firstName</code> , apr√®s extraction, tombe dans le <code>name</code> constant. <br><br>  L'affectation destructive convient √©galement pour travailler avec des tableaux. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, , , fifth] = a</code> </pre> <br>  Les <code>first</code> , <code>second</code> et <code>fifth</code> constantes obtiennent respectivement les premier, deuxi√®me et cinqui√®me √©l√©ments du tableau. <br><br><h2>  <font color="#3AC1EF">Am√©lioration des litt√©raux d'objets</font> </h2><br>  ES2015 a consid√©rablement √©tendu la capacit√© de d√©crire des objets √† l'aide de litt√©raux d'objets. <br><br><h3>  <font color="#3AC1EF">‚ñç Simplification de l'inclusion de variables dans les objets</font> </h3><br>  Auparavant, pour affecter une variable √† une propri√©t√© d'un objet, il √©tait n√©cessaire d'utiliser la construction suivante. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">something</span></span>: something }</code> </pre> <br>  Maintenant, la m√™me chose peut √™tre faite comme √ßa. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-string"><span class="hljs-string">'y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { something }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Prototypes</font> </h3><br>  Le prototype de l'objet peut maintenant √™tre d√©fini en utilisant la construction suivante. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Mot-cl√© super</font> </h3><br>  En utilisant le <code>super</code> mot <code>super</code> cl√©, les objets peuvent acc√©der aux objets prototypes.  Par exemple, pour appeler leurs m√©thodes qui portent le m√™me nom que les m√©thodes de ces objets eux-m√™mes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anObject = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span>, <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'zoo'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { <span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: anObject, test() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.test() + <span class="hljs-string"><span class="hljs-string">'x'</span></span> } } x.test() <span class="hljs-comment"><span class="hljs-comment">//zoox</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Noms de propri√©t√© calcul√©s</font> </h3><br>  Les noms de propri√©t√© calcul√©s sont form√©s au stade de la cr√©ation d'objet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = { [<span class="hljs-string"><span class="hljs-string">'a'</span></span> + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + <span class="hljs-string"><span class="hljs-string">'b'</span></span>]: <span class="hljs-string"><span class="hljs-string">'z'</span></span> } x.a_b <span class="hljs-comment"><span class="hljs-comment">//z</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Pour ... de boucle</font> </h2><br>  En 2009, dans la norme ES5, des boucles <code>forEach()</code> sont apparues.  Il s'agit d'une conception utile, dont l'inconv√©nient est le fait que de tels cycles sont tr√®s difficiles √† interrompre.  Le classique <code>for</code> boucle dans les situations o√π vous devez interrompre l'ex√©cution de la boucle avant son ach√®vement normal est un choix beaucoup plus appropri√©. <br><br>  Un <code>for...of</code> cycle est apparu dans ES2015, qui, d'une part, se distingue par sa syntaxe concise et la commodit√© de <code>forEach</code> , et d'autre part, il prend en charge la possibilit√© d'une sortie anticip√©e du cycle. <br><br>  Voici quelques exemples <code>for...of</code> exemples <code>for...of</code> boucles. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    for (const v of ['a', 'b', 'c']) { console.log(v); } //           entries() for (const [i, v] of ['a', 'b', 'c'].entries()) { console.log(i, v); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Mapper et d√©finir des structures de donn√©es</font> </h2><br>  ES2015 a introduit les structures de donn√©es <code>Map</code> and <code>Set</code> (ainsi que leurs versions ¬´faibles¬ª <code>WeakMap</code> et <code>WeakSet</code> , dont l'utilisation am√©liore les performances du ¬´garbage collector¬ª - le m√©canisme responsable de la gestion de la m√©moire dans les moteurs JS).  Ce sont des structures de donn√©es tr√®s populaires qui, avant l'apparition de leur impl√©mentation officielle, devaient √™tre imit√©es √† l'aide des outils linguistiques disponibles. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Aujourd'hui, nous avons pass√© en revue les caract√©ristiques de la norme ES2015, qui ont grandement influenc√© l'√©tat actuel de la langue.  Notre prochain sujet sera consacr√© aux fonctionnalit√©s des normes ES2016, ES2017 et ES2018. <br><br>  <b>Chers lecteurs!</b>  Quelles innovations de la norme ES6 trouvez-vous les plus utiles? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431074/">https://habr.com/ru/post/fr431074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431064/index.html">Manifeste du programmeur rigide</a></li>
<li><a href="../fr431066/index.html">DEFCON 16. Comment puis-je vous joindre? Permettez-moi d'√©num√©rer les moyens. 2e partie</a></li>
<li><a href="../fr431068/index.html">L'art de l'√©ducation: l'id√©ologie des machines √† sous</a></li>
<li><a href="../fr431070/index.html">Hara mange? Nous parlons des habitudes alimentaires d'un sp√©cialiste informatique moderne</a></li>
<li><a href="../fr431072/index.html">Guide JavaScript partie 7: mode strict, ce mot-cl√©, √©v√©nements, modules, math√©matiques</a></li>
<li><a href="../fr431076/index.html">Les frameworks Node.js les plus populaires de 2018</a></li>
<li><a href="../fr431078/index.html">Guide de gestion des erreurs JavaScript</a></li>
<li><a href="../fr431080/index.html">Comment organiser des bureaux distants et ne pas perdre une √©quipe dans l'espace</a></li>
<li><a href="../fr431082/index.html">Kotlin: √† la recherche d'un responsable marketing</a></li>
<li><a href="../fr431084/index.html">Dans toute situation incompr√©hensible - √©crire des scripts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>