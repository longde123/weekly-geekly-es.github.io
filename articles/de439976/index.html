<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍤 👋🏾 ™️ Wird Node.js immer langsamer sein als Golang? 👩🏿‍🎤 🚦 🔱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es besteht das Gefühl, dass es buchstäblich jede Woche ein neues "Web-Framework" für Node.js gibt, das als etwas bezeichnet wird, das schneller funkti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wird Node.js immer langsamer sein als Golang?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/439976/">  Es besteht das Gefühl, dass es buchstäblich jede Woche ein neues "Web-Framework" für Node.js gibt, das als etwas bezeichnet wird, das schneller funktioniert als alles, was davor war.  Jeder weiß, dass Express langsam ist, aber kann das nächste Framework die Leistung des Node.js-E / A-Subsystems wirklich verbessern?  Das einzige, was es tun kann, ist, die übermäßige Belastung des von Express erzeugten Systems zu beseitigen.  Es wird nicht darüber gesprochen, etwas Grundlegendes zu verbessern.  Um die Situation radikal zu verbessern, müssen Sie auf einer tieferen Ebene arbeiten und dürfen keine neuen Abstraktionen über Node.js hinzufügen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/ca9/67d/fb9/ca967dfb9d2f8e6128460295b5245e65.jpg" alt="Bild"></a> <br><br>  Was braucht es, um Serveranwendungen auf der Node.js-Plattform zu erstellen, die viel schneller laufen als heute? <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Situationsanalyse</font> </h2><br>  Express ist eines der ältesten Webframeworks für Node.js.  Es basiert auf den Standardfunktionen dieser Plattform und bietet Entwicklern eine praktische Oberfläche, die auf dem Konzept der Anwendung basiert, und ermöglicht Ihnen die Verwaltung von URL-Routen, -Parametern, -Methoden und dergleichen. <br><br>  Express ist einfach und hilft Programmierern, Anwendungen schnell zu entwickeln.  Das einzige, was ihm fehlt, ist Leistung.  Ständig erscheinende Projekte wie Fastify sind bestrebt, Entwicklern die gleichen Funktionen wie Express zu bieten, jedoch mit weniger Leistungsverlust.  Sie selbst verursachen jedoch eine zusätzliche Belastung des Systems und beeinträchtigen die Leistung erheblich.  Sie sind stark eingeschränkt durch das, was die Node.js.-Plattform bieten kann.  Und es kann im Vergleich zu Wettbewerbern nicht so viel geben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/748/266/c8a/748266c8a017e8c15fb882d06c2100fd.png"></div><br>  <i><font color="#999999">Die Anzahl der HTTP-Anforderungen, die von verschiedenen Servern pro Sekunde verarbeitet werden</font></i> <br><br>  Achten Sie auf die rote Linie.  Dies ist die maximale Plattform Node.js.  Unabhängig davon, ob ihre Namen das Wort „schnell“ enthalten oder nicht, können sie diese Grenze nicht überschreiten.  Dies ist tatsächlich eine sehr niedrige Leistungsgrenze, wenn die Node.js-Plattform mit ihren beliebten Alternativen wie Golang verglichen wird. <br><br>  Glücklicherweise unterstützt Node.js C ++ - Add-Ons, Google V8-Ordner, mit denen Sie JavaScript und C ++ binden und alle Mechanismen aus JavaScript aufrufen können, selbst wenn diese Mechanismen von einer anderen Plattform als der Node.js-Plattform bereitgestellt werden. <br><br>  Dies ermöglicht die Erweiterung und Verbesserung der Funktionen von JavaScript-Anwendungen und ermöglicht es Ihnen, neue Leistungsniveaus zu erreichen.  Auf diese Weise können JavaScript-Programme alles Mögliche aus der Google V8-Engine herausholen, ohne darauf beschränkt zu sein, was die Entwickler von Node.js für ausreichend befunden haben. <br><br><h2>  <font color="#3AC1EF">Über µWebSockets.js</font> </h2><br>  Anfang dieses Monats habe ich ein neues Projekt veröffentlicht - <a href="">µWebSockets.js</a> .  GitHub wird als Hosting für seinen Code verwendet, nicht für npm, aber Sie können es für Node.js mit npm wie folgt installieren: <br><br><pre><code class="plaintext hljs">npm install uNetworking/uWebSockets.js#v15.0.0</code> </pre> <br>  Für die Arbeit mit µWebSockets.js benötigen Sie keinen Compiler.  Linux, MacOS und Windows werden unterstützt.  Die ursprüngliche Version des Systems ist 15.0.0, die Versionsnummerierung erfolgt nach den Regeln der semantischen Versionierung. <br><br>  µWebSockets.js ist ein alternativer Webserver für in JS geschriebene Backend-Anwendungen.  Es besteht aus ungefähr 6.000 Zeilen C- und C ++ - Code und übertrifft die besten in Golang geschriebenen Lösungen erheblich.  Daher hat die bitfinex.com-Börse bereits beide Handels-APIs (REST und WebSocket) auf µWebSockets.js portiert und führt sie schrittweise in die Produktion ein.  Paolo Ardoino von Bitfinex merkt an, dass dies ein großartiges Projekt ist.  Ich möchte sagen, dass die Tatsache, dass ich die Möglichkeit hatte, µWebSockets.js zu veröffentlichen, ausschließlich auf die Unterstützung durch BitMEX, Bitfinex und Coinbase zurückzuführen ist. <br><br><h2>  <font color="#3AC1EF">Funktionen von µWebSockets.js</font> </h2><br>  µWebSockets.js ist ein neues Projekt, das unter der Apache 2.0-Lizenz veröffentlicht wurde und eine Fortsetzung dessen ist, was als "uws" bekannt ist.  Dieses Projekt ist ein vollständiger Stapel für Google V8, der auf der Kernel-Ebene des Betriebssystems beginnt, die Standardfunktionen von Node.js vollständig ersetzt und ein stabiles, sicheres, standardkonformes, schnelles und leichtes E / A-Subsystem für Node.js darstellt.  So sieht die Interaktion der JS-Anwendung mit dem Betriebssystem mit µWebSockets.js aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ef/b7e/416/4efb7e416344ba928f85143ad1dbba62.png"></div><br>  <i><font color="#999999">Interaktion der JS-Anwendung mit dem Betriebssystem unter Verwendung von µWebSockets.js</font></i> <br><br>  Wie Sie sehen können, besteht das Projekt aus mehreren Ebenen.  Jede Ebene hängt nur von der vorherigen Ebene ab.  Diese Architektur vereinfacht die Identifizierung und Korrektur von Fehlern sowie die Implementierung von Arbeiten zur Erweiterung der Lösung aufgrund der Implementierung neuer Funktionen. <br><br>  Es ist zu beachten, dass die <code>µSockets</code> Schicht selbst aus drei Unterschichten besteht, die Mechanismen für die Arbeit mit Ereignissen und mit dem Netzwerk sowie Tools zum Schutz von Daten darstellen.  Auf diese Weise können bei Bedarf Teile der Lösung ersetzt und dem System alternative Implementierungen bestimmter Funktionen hinzugefügt werden, ohne dass der Code auf einer höheren Ebene geändert werden muss. <br><br>  Wenn Sie beispielsweise OpenSSL durch etwas ersetzen müssen, ändern Sie <code>ssl.c</code> Datei <code>ssl.c</code> mit ihren sechshundert Codezeilen nach Ihren <code>ssl.c</code> .  Andere Schichten des Systems wissen jedoch nicht einmal, was SSL ist.  Dieser Ansatz führt neben der Bequemlichkeit, einige Teile des Systems durch andere zu ersetzen, auch zu einer Vereinfachung des Fehlererkennungsprozesses. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/719/113/b42/719113b4261fee20a799f8412e332f53.png"></div><br>  <i><font color="#999999">ΜSockel innere Unterschichten</font></i> <br><br>  Die hier vorgestellte Architektur unterscheidet sich stark von der monolithischen Architektur, die in Node.js verwendet wird. In derselben Quellcodedatei finden Sie Aufrufe von libuv, Befehle für die Arbeit mit dem System sowie Aufrufe von OpenSSL und V8.  In Node.js ist dies alles gemischt, und niemand hat sich vorgenommen, einzelne Teile dieser Plattform zu isolieren.  Dies erschwert das Vornehmen wichtiger Änderungen an Node.js. <br><br><h2>  <font color="#3AC1EF">Informationen zur Entwicklung von µWebSockets.js</font> </h2><br>  Hier ist ein extrem vereinfachtes und verkürztes Beispiel für die Arbeit mit µWebSockets.js, dessen Hauptaufgabe darin besteht, die grundlegenden Funktionen des Systems zu demonstrieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* SSL-   */</span></span> uWS.SSLApp({   <span class="hljs-attr"><span class="hljs-attr">key_file_name</span></span>: <span class="hljs-string"><span class="hljs-string">'misc/key.pem'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">cert_file_name</span></span>: <span class="hljs-string"><span class="hljs-string">'misc/cert.pem'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">passphrase</span></span>: <span class="hljs-string"><span class="hljs-string">'1234'</span></span> }).get(<span class="hljs-string"><span class="hljs-string">'/hello'</span></span>, (res, req) =&gt; {   <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>   res.end(<span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>); }).ws(<span class="hljs-string"><span class="hljs-string">'/*'</span></span>, {   <span class="hljs-attr"><span class="hljs-attr">open</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ws, req</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'A WebSocket connected via URL: '</span></span> + req.getUrl() + <span class="hljs-string"><span class="hljs-string">'!'</span></span>);   },   <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ws, message, isBinary</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-comment"><span class="hljs-comment">/* OK   false          *     */</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ok = ws.send(message, isBinary);   },   <span class="hljs-attr"><span class="hljs-attr">drain</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ws</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'WebSocket backpressure: '</span></span> + ws.getBufferedAmount());   },   <span class="hljs-attr"><span class="hljs-attr">close</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ws, code, message</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'WebSocket closed'</span></span>);   } }).listen(port, (token) =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token) {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Listening to port '</span></span> + port);   } });</code> </pre> <br>  In gewissem Sinne können wir sagen, dass µWebSockets.js, die SSL verwenden, Gorilla WebSocket, eine Implementierung des WebSocket-Protokolls auf Go, ohne SSL umgehen können.  Das heißt, es stellt sich heraus, dass JS-Code Nachrichten mit SSL noch schneller austauschen kann als unter bestimmten Bedingungen in Go ohne SSL geschriebener Code.  Ich glaube, dass dies ein hervorragendes Ergebnis ist. <br><br><h2>  <font color="#3AC1EF">Schnelle Implementierung des WebSocket-Protokolls</font> </h2><br>  Socket.IO kann in vielerlei Hinsicht als das Äquivalent von Express in Echtzeit betrachtet werden.  Beide Projekte sind vor langer Zeit entstanden. Es ist einfach, mit ihnen zu arbeiten. Sie sind beliebt.  Sie sind aber unter anderem auch langsam. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7eb/459/06d/7eb45906d3bb8f8867ed5f689223d441.png"></div><br>  <i><font color="#999999">Verschiedene WebSocket-Implementierungen</font></i> <br><br>  Die Aufgaben, die der Socket.IO-Entwickler zu lösen hilft, beschränken sich auf die Implementierung der Funktionen zum Veröffentlichen und Abonnieren von Nachrichten sowie auf die Fähigkeit, Nachrichten zu senden und zu empfangen. <br><br>  Gleichzeitig ist die Verwendung einiger Ersatzmechanismen für die Arbeit mit dem WebSocket-Protokoll erwähnenswert, da Browser diese Technologie seit langem unterstützen.  SSL-Verkehr kann von Unternehmens-Proxys nicht interpretiert werden. Er wird wie jeder HTTP-Verkehr durch sie geleitet. Daher blockiert die Verwendung des WebSocket-Protokolls über SSL den entsprechenden Verkehr nicht.  Es können Ersatzmechanismen zur Unterstützung von WebSocket bereitgestellt werden, deren Verwendung jedoch keinen Sinn macht.  Sie erhöhen die Komplexität von Entscheidungen nur unangemessen. <br><br>  Eines der Ziele von µWebSockets.js ist es, Entwicklern ähnliche Funktionen wie in Socket.IO zu bieten, damit µWebSockets.js Socket.IO vollständig ersetzen kann, ohne dass übergeordnete Wrapper erforderlich sind .  Dies ist möglich, wenn kein spezielles Nicht-Standardprotokoll verwendet wird. <br><br>  Viele Unternehmen haben Probleme beim Veröffentlichen und Abonnieren von Nachrichten, während sie mit WebSocket arbeiten.  Es sollte beachtet werden, dass in der beschriebenen Version von µWebSockets.js diesen Funktionen nicht viel Aufmerksamkeit geschenkt wurde, aber jetzt ernsthafte Arbeiten an ihnen durchgeführt werden.  Das Ergebnis wird sehr schnell sein (Tests zeigen, dass µWebSockets.js bereits schneller als Redis ist).  Also bleibt dran. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Derzeit entwickelt sich µWebSockets.js, dem Projekt werden neue Funktionen hinzugefügt und Fehler behoben.  Es wird einige Zeit dauern, um die kleinen Mängel zu beseitigen, die für die ersten Veröffentlichungen neuer Programme charakteristisch sind.  Beachten Sie, dass dies ein großes Projekt ist, das aus vielen tausend in C und C ++ geschriebenen Codezeilen besteht, die in drei Repositorys gespeichert sind.  <a href="">Hier</a> liegt der JavaScript-Wrapper - uWebSockets.js.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein</a> in C ++ geschriebener Webserver - uWebSockets.  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ist die Basisbibliothek, die in C - uSockets geschrieben ist. <br><br>  Das fragliche Projekt wird von Unternehmen verwendet, deren Programme die E / A-Subsysteme stark belasten.  In diesen Unternehmen sind Stabilität und Sicherheit, die völlig natürlich und offensichtlich sind, die wichtigsten Merkmale der von ihnen verwendeten Software. <br><br>  <b>Liebe Leser!</b>  Planen Sie, µWebSockets.js in Ihren Projekten zu verwenden? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439976/">https://habr.com/ru/post/de439976/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439966/index.html">Einfacher Parser für arithmetische Operationen</a></li>
<li><a href="../de439968/index.html">Generationsraum und Opportunity Space</a></li>
<li><a href="../de439970/index.html">Bericht über Probleme und Zugänglichkeit des Internets im Zeitraum 2018-2019</a></li>
<li><a href="../de439972/index.html">io_submit: Eine Alternative zu Epoll, von der Sie noch nie gehört haben</a></li>
<li><a href="../de439974/index.html">Persönliche agile Transformation: Eine flexible Reise zur Produktivität</a></li>
<li><a href="../de439978/index.html">Docker lernen, Teil 2: Begriffe und Konzepte</a></li>
<li><a href="../de439980/index.html">Docker lernen, Teil 3: Docker-Dateien</a></li>
<li><a href="../de439982/index.html">React Tutorial, Teil 16: Die vierte Phase der Arbeit an einer TODO-Anwendung, Ereignisverarbeitung</a></li>
<li><a href="../de439984/index.html">React Tutorial, Teil 17: Die fünfte Phase der Arbeit an einer TODO-Anwendung, Ändern des Status von Komponenten</a></li>
<li><a href="../de439986/index.html">Chips VS Bedrohungen für die Containerisierungstechnologie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>