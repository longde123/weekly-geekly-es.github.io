<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🔧 🧑🏽 👦🏾 Trik kecil dengan Elasticsearch 🤳🏿 💻 🥣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan singkat, bukan untuk saya sendiri, tentang trik kecil untuk pemulihan data di Elasticsearch. Bagaimana cara memperbaiki indeks merah jika tida...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trik kecil dengan Elasticsearch</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416955/">  Catatan singkat, bukan untuk saya sendiri, tentang trik kecil untuk pemulihan data di Elasticsearch.  Bagaimana cara memperbaiki indeks merah jika tidak ada cadangan, apa yang harus dilakukan jika saya menghapus dokumen, dan tidak ada salinan yang tersisa - sayangnya dalam dokumentasi resmi mereka diam tentang fitur ini. <br><a name="habracut"></a><br><h2>  Cadangan </h2><br><img src="https://habrastorage.org/webt/ov/ua/p_/ovuap_rbyndffch-bceedhmlzis.png"><br><br>  Hal pertama yang harus dilakukan adalah mengatur cadangan data penting.  Cara ini dilakukan dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>dokumentasi resmi</b></a> . <br><br>  Secara keseluruhan, tidak ada yang rumit.  Dalam versi paling sederhana, buat bola di server lain, pasang ke semua simpul elastis dengan cara yang nyaman (nfs, smbfs, apa pun).  Selanjutnya, gunakan cron, aplikasi Anda atau apa pun untuk mengirim permintaan foto berkala. <br><br>  Cuplikan pertama akan panjang, yang berikutnya hanya akan berisi delta antara status indeks.  Perhatikan bahwa jika Anda melakukan berkala <b>forcemerge,</b> delta akan menjadi waktu yang sangat besar dan, sesuai, snapshot akan jauh seperti pertama kali. <br><br>  Apa yang harus dipertimbangkan: <br><br><ul><li> Periksa status cadangan, misalnya menggunakan _cat: <code>curl localhost:9200/_cat/snapshots/ <b>yourbackuprepo</b> /</code> .  <b>Jepretan sebagian</b> atau <b>Gagal</b> bukanlah milik Anda. </li><li>  Dimulai dengan ES 6.x, elastis sangat menuntut header permintaan.  Jika Anda melakukannya secara manual (bukan melalui API), periksa apakah Anda memiliki <code>Content-Type: application/json</code> , jika tidak semua permintaan Anda terputus dan cadangan tidak terjadi </li><li>  Snapshot tidak dapat dikembalikan ke indeks terbuka.  Itu harus ditutup atau dihapus terlebih dahulu.  Namun, Anda dapat memulihkan snapshot berdampingan menggunakan rename_pattern, rename_replacement ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat contoh di dok</a> ).  Selain itu, ketika foto dipulihkan, pengaturannya juga dipulihkan, termasuk alias, jumlah replika, dll.  Jika Anda tidak membutuhkan ini, tambahkan index_settings ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat dock sebagai contoh</a> ) dengan perubahan yang diperlukan pada permintaan pengembalian. </li><li>  Repos (bola) dengan snapshot dapat dihubungkan ke lebih dari satu cluster dan mengembalikan snapshots dari cluster mana saja ke cluster lainnya.  Yang utama adalah versi elastisnya kompatibel. </li></ul><br>  Secara umum, lihat dokumentasi, ada topik ini lebih atau kurang diungkapkan. <br><br><h2>  Elasticdump </h2><br><img src="https://habrastorage.org/webt/w_/5e/xy/w_5exyoyb7acppvivweuwj1kmiq.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Utilitas kecil</a> pada nodejs yang memungkinkan Anda untuk menyalin data dari satu indeks ke indeks lain, cluster, file, stdout. <br><br>  Ngomong-ngomong, output ke file atau stdout dapat digunakan sebagai metode cadangan alternatif - outputnya adalah json valid reguler (sesuatu seperti sql dump), yang dapat digunakan kembali seperti yang Anda inginkan.  Misalnya, Anda bisa menempelkan output dalam pipa, di mana skrip Anda entah bagaimana akan mengubah data dan mengirimkannya ke repositori lain, seperti clickhouse.  Konversi js paling sederhana dapat dilakukan secara langsung dengan elasticdump itu sendiri, ada kunci yang sesuai <b>--transformasi</b> .  Secara umum, penerbangan mewah. <br><br>  Dari perangkap: <br><br><ul><li>  Sebagai metode cadangan, ini jauh lebih lambat daripada snapshot.  Plus, cadangan diperpanjang dari waktu ke waktu, sehingga hasil pada indeks yang sering berubah mungkin tidak konsisten.  Ingatlah selalu. </li><li>  Jangan gunakan nodejs dari repositori debian, ada terlalu lama versi yang secara negatif mempengaruhi stabilitas alat. </li><li>  Stabilitas dapat bervariasi, terutama jika salah satu pihak kelebihan beban.  Jangan mencoba mem-backup dari satu server ke server lain dengan menjalankan alat di mesin kantor - semua lalu lintas akan mengalir melaluinya. </li><li>  Gambar menyalin pemetaan.  Jika Anda memiliki sesuatu yang rumit di sana, buatlah indeks secara manual, dan baru kemudian isikan data ke dalamnya. </li><li>  Terkadang masuk akal untuk mengubah ukuran chunk (parameter --limit).  Opsi ini secara langsung memengaruhi kecepatan penyalinan. </li></ul><br>  Untuk menggabungkan sejumlah besar indeks pada saat yang sama, ada multielasticdump dengan serangkaian opsi yang disederhanakan, tetapi semua indeks bergabung secara paralel. <br><br>  <b>Catat!</b>  Penulis utilitas mengatakan bahwa ia tidak lagi memiliki waktu untuk mendukung, sehingga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>program mencari pengelola baru</b></a> . <br><br>  Dari pengalaman pribadi: utilitas bermanfaat, diselamatkan lebih dari sekali.  Kecepatan dan stabilitasnya begitu-begitu, saya ingin penggantian yang memadai, tetapi sejauh ini tidak ada yang ada di cakrawala. <br><br><h2>  Periksaindeks </h2><br>  Jadi, kita mulai mendekati sisi gelap.  Situasi: indeks sudah merah.  Dalam log - ada yang salah, cek tidak sesuai dengan jumlah, Anda mungkin mendapat memori atau disk: <br><br> <code>org.apache.lucene.index.CorruptIndexException: checksum failed (hardware problem?)</code> <br> <br>  Tentu saja, ini tidak pernah terjadi dengan admin ibu, karena mereka memiliki perangkat keras kelas atas dengan replikasi tiga kali lipat, memori superECC dengan koreksi benar-benar semua tingkat kesalahan dengan cepat, dan umumnya snapshot dikonfigurasikan setiap detik. <br><br>  Tetapi kenyataan sayangnya kadang-kadang meminta opsi seperti itu, ketika cadangan relatif lama (jika Anda memiliki gigabytes per jam diindeks, apakah cadangan terlalu lama 2 jam yang lalu?), Tidak ada tempat untuk memulihkan data, replikasi tidak punya waktu dan hal-hal seperti itu. <br><br>  Tentu saja, jika ada snapshot, backup atau sejenisnya.  - Luar biasa, bangun dan jangan khawatir.  Dan jika tidak?  Untungnya, setidaknya beberapa data masih bisa disimpan. <br><br>  Pertama-tama, tutup indeks dan / atau matikan elastisnya, buat salinan cadangan pecahan yang gagal. <br><br>  Lucene (yaitu berfungsi sebagai backend dalam elasticsearch) memiliki metode CheckIndex yang luar biasa.  Kita hanya perlu memanggilnya karena pecahannya.  Lucene akan memeriksa semua segmennya dan menghapus yang rusak.  Ya, data akan hilang, tetapi setidaknya tidak semuanya.  Meskipun ada betapa beruntungnya itu. <br><br>  Setidaknya ada 2 cara. <br><br><h3>  Metode 1: Langsung di situs </h3><br>  Script yang begitu sederhana akan membantu kita. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash pushd /usr/share/elasticsearch/lib java -cp lucene-core*.jar -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex "$@" popd</span></span></code> </pre><br>  Menyebutnya tanpa parameter, kami mendapatkan sesuatu seperti ini: <br><br><pre> <code class="hljs vhdl"><span class="hljs-literal"><span class="hljs-literal">ERROR</span></span>: index path <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> specified Usage: java org.apache.lucene.index.CheckIndex pathToIndex [-exorcise] [-crossCheckTermVectors] [-segment X] [-segment Y] [-dir-impl X] -exorcise: actually write a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> segments_N <span class="hljs-keyword"><span class="hljs-keyword">file</span></span>, removing any problematic segments -fast: just verify <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> checksums, omitting logical integrity checks -crossCheckTermVectors: verifies that term vectors match postings; THIS <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> VERY SLOW! -codec X: <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> exorcising, codec <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> write the <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> segments_N <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> -verbose: print additional details -segment X: only check the specified segments. This can be specified multiple times, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> check more than one segment, eg '-segment _2 -segment _a'. You can<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the -exorcise option -dir-impl X: <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> a specific FSDirectory implementation. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> no <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> specified the org.apache.lucene.store <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> will be used. **<span class="hljs-literal"><span class="hljs-literal">WARNING</span></span>**: -exorcise *LOSES DATA*. This should only be used <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> an emergency basis as it will cause documents (perhaps many) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be permanently removed from the index. Always make a backup copy <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> your index before running this! Do <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> run this tool <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> an index that <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> actively being written <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>. You have been warned! Run without -exorcise, this tool will <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> the index, <span class="hljs-keyword"><span class="hljs-keyword">report</span></span> version information <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">report</span></span> any exceptions it hits <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> what action it would take <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> -exorcise were specified. <span class="hljs-keyword"><span class="hljs-keyword">With</span></span> -exorcise, this tool will remove any segments that have issues <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> write a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> segments_N <span class="hljs-keyword"><span class="hljs-keyword">file</span></span>. This means <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> documents contained <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the affected segments will be removed. This tool exits <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> code <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the index cannot be opened <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> has any corruption, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.</code> </pre><br>  Sebenarnya, kita bisa menjalankan tes indeks, atau membuat CheckIndex "memperbaikinya", memotong semua yang rusak. <br><br>  Indeks Lucene hidup dalam kira-kira dengan cara yang sama: / var / lib / elasticsearch / node / 0 / indexes / str4ngEHashVa1uE / 0 / index /, di mana 0 dan 0 adalah nomor node pada server dan jumlah shard pada node.  Nilai menakutkan di antara mereka - nama internal indeks - dapat diperoleh dari output lokal curl: 9200 / _cat / indeks. <br><br>  Saya biasanya membuat salinan ke direktori lain, dan memperbaiki di tempat.  Kemudian saya memulai kembali elasticsearch.  Sebagai aturan, semuanya diambil, meskipun dengan kehilangan data.  Terkadang indeks masih tidak ingin dibaca karena file * rusak * di folder pecahan.  Pindahkan mereka ke tempat yang aman untuk sementara waktu. <br><br><h3>  Metode 2: Luke </h3><br><img src="https://habrastorage.org/webt/t3/8s/pi/t38spiezlwrxrxynldo8qnj9bh0.png"><br>  (gambar dari Internet) <br><br>  Ada utilitas bagus untuk bekerja dengan Lucene yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disebut <b>Luke</b></a> . <br><br>  Masih lebih sederhana di sini.  Cari tahu versi Lucene dari elasticsearch Anda: <br><br><pre> <code class="bash hljs">$ curl localhost:9200 { <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"node00"</span></span>, <span class="hljs-string"><span class="hljs-string">"cluster_name"</span></span> : <span class="hljs-string"><span class="hljs-string">"main"</span></span>, <span class="hljs-string"><span class="hljs-string">"cluster_uuid"</span></span> : <span class="hljs-string"><span class="hljs-string">"UCbEivvLTcyWSQElOipgTQ"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span> : { <span class="hljs-string"><span class="hljs-string">"number"</span></span> : <span class="hljs-string"><span class="hljs-string">"6.2.4"</span></span>, <span class="hljs-string"><span class="hljs-string">"build_hash"</span></span> : <span class="hljs-string"><span class="hljs-string">"ccec39f"</span></span>, <span class="hljs-string"><span class="hljs-string">"build_date"</span></span> : <span class="hljs-string"><span class="hljs-string">"2018-04-12T20:37:28.497551Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"build_snapshot"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"lucene_version"</span></span> : <span class="hljs-string"><span class="hljs-string">"7.2.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"minimum_wire_compatibility_version"</span></span> : <span class="hljs-string"><span class="hljs-string">"5.6.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"minimum_index_compatibility_version"</span></span> : <span class="hljs-string"><span class="hljs-string">"5.0.0"</span></span> }, <span class="hljs-string"><span class="hljs-string">"tagline"</span></span> : <span class="hljs-string"><span class="hljs-string">"You Know, for Search"</span></span> }</code> </pre><br>  Ambil versi Lukas yang sama.  Kami membuka di dalamnya indeks (salinan tentu saja) dengan daw <b>Jangan buka IndexReader (saat membuka indeks rusak)</b> .  Selanjutnya, klik Alat / Periksa Indeks.  Pertama saya sarankan untuk menjalankan kering, dan hanya dalam mode perbaikan.  Tindakan selanjutnya serupa - salin kembali elastis, restart / buka indeks. <br><br><h2>  Pulihkan Dokumen yang Dihapus </h2><br>  Situasi: Anda melakukan kueri destruktif yang menghapus banyak / semua data yang Anda butuhkan.  Dan tidak ada tempat untuk mengembalikan, atau sangat mahal.  Yah, tentu saja, SSZB bahwa tidak ada cadangan, tetapi ini juga terjadi. <br><br>  Sayangnya atau untungnya, Lucene tidak pernah menghapus apa pun secara langsung.  Filosofinya lebih dekat dengan Kontrak Karya, sehingga data yang dihapus sebenarnya tidak dihapus, tetapi hanya ditandai sebagai yang dihapus.  Penghapusan itu sendiri terjadi selama optimasi indeks - data langsung dari segmen disalin ke segmen yang baru dibuat, segmen lama hanya dihapus.  Secara umum, sementara status indeks yang dihapus bukan 0, ada peluang untuk mengeluarkannya. <br><br><pre> <code class="bash hljs">$ curl localhost:9200/_cat/indices?v health status index uuid pri rep docs.count docs.deleted store.size pri.store.size green open data.0 R0fgvfPnTUaoI2KKyQsgdg 5 1 7238685 1291566 45.1gb 22.6gb</code> </pre><br>  Setelah dipenjara tidak ada kesempatan. <br><br>  Jadi, pertama-tama, tutup indeks, hentikan elastis, salin indeks (file) ke tempat yang aman. <br><br>  Tidak mungkin mengeluarkan dokumen yang dihapus secara individu.  Anda hanya dapat memulihkan semua dokumen yang dihapus di segmen yang ditentukan. <br><br>  Untuk versi Lucene di bawah 4, semuanya sangat sederhana.  API Lucene memiliki fungsi yang disebut undeleteAll.  Anda dapat memanggilnya langsung dari <b>Luke</b> dari paragraf sebelumnya. <br><br>  Untuk versi yang lebih baru, sayangnya, fungsionalitasnya terpotong.  Tapi tetap saja masih ada jalan.  Informasi tentang dokumen langsung disimpan dalam file * .liv.  Namun, menghapusnya saja akan membuat indeks tidak dapat dibaca.  Diperlukan untuk memperbaiki file segment_N sehingga benar-benar lupa tentang keberadaan mereka. <br><br>  Buka file segment_N (N adalah bilangan bulat) di Hex editor favorit Anda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Dokumentasi resmi</b></a> akan membantu kami menavigasi: <br><pre> <code class="bash hljs">segments_N: Header, LuceneVersion, Version, NameCounter, SegCount, MinSegmentLuceneVersion, &lt;SegName, SegID, SegCodec, DelGen, DeletionCount, FieldInfosGen, DocValuesGen, UpdatesFiles&gt;SegCount, CommitUserData, Footer</code> </pre> <br>  Dari semua ini, kita membutuhkan nilai DelGen (Int64) dan DeletionCount (Int32).  Yang pertama harus ditetapkan sama dengan -1, dan yang kedua 0. <br><br><img src="https://habrastorage.org/webt/8t/3s/dg/8t3sdgluq35ibmu0att0yzjapju.png"><br><br>  Tidak sulit untuk menemukan mereka, mereka tepat di belakang SegCodec, yang merupakan string yang sangat mencolok seperti Lucene62.  Dalam tangkapan layar ini, Anda dapat melihat bahwa DelGen memiliki nilai 3, dan DeletionCount - 184614. Kami mengganti yang pertama dengan 0xFFFFFFFFFFFFFFFFFF, dan yang kedua dengan 0x00000000.  Ulangi untuk semua segmen yang diperlukan, simpan. <br><br>  Namun, indeks tetap tidak akan mau memuat, mengutip kesalahan checksum.  Masih lebih sederhana di sini.  Ambil Luke, muat indeks dengan IndexReader yang dinonaktifkan, Alat / Periksa Indeks.  Kami melakukan uji coba dan segera mengetahui bahwa segment_N rusak.  Pemeriksaan ini dan itu diharapkan, tetapi ini dan itu diterima. <br><br><pre> <code class="bash hljs">Caused by: org.apache.lucene.index.CorruptIndexException: checksum failed (hardware problem?) : expected=51fbdb5c actual=6e964d17</code> </pre> <br>  Omong kosong!  Kami mengambil checksum yang diharapkan dan memasukkannya dalam 4 byte terakhir file. <br><br><img src="https://habrastorage.org/webt/h5/1q/q-/h51qq-yrc9s_jbwrpq1n92d8qm8.png"><br><br>  Simpan.  Kami menjalankan CheckIndex lagi untuk memastikan semuanya OK dan indeks sedang memuat. <br><br>  Dan lagi! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416955/">https://habr.com/ru/post/id416955/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416945/index.html">Seperti yang kami lakukan BelAZ. Bagian 1 - Setrika</a></li>
<li><a href="../id416947/index.html">Mainkan game sebelum Olimpiade: eSports menjadi resmi</a></li>
<li><a href="../id416949/index.html">Peningkatan skala besar Mr. Steven untuk menginstal jaringan perburuan empat kali lipat lebih besar telah selesai</a></li>
<li><a href="../id416951/index.html">Cluster Kubernetes dalam layanan VPC</a></li>
<li><a href="../id416953/index.html">Buat shader air kartun untuk web. Bagian 1</a></li>
<li><a href="../id416957/index.html">Mesin laser mana yang harus dibeli? Ulasan Mesin Laser Raylogic 11G yang Andal</a></li>
<li><a href="../id416959/index.html">Apple Memperkenalkan Fitur Anti-Pencurian iOS Baru</a></li>
<li><a href="../id416961/index.html">Resolusi konflik otomatis menggunakan transformasi operasional</a></li>
<li><a href="../id416967/index.html">Seperti yang kami lakukan BelAZ. Bagian 3 - commissioning bagian</a></li>
<li><a href="../id416969/index.html">Pembenaran matematis Pythagoras dari skala musik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>