<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèº üî£ üìê Nous d√©veloppons le module processeur NIOS II pour IDA Pro ü¶è ü•ö üç∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Capture d'√©cran de l'interface IDA Pro Disassembler 

 IDA Pro est un c√©l√®bre d√©monteur utilis√© par les chercheurs en s√©curit√© de l'information du mon...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous d√©veloppons le module processeur NIOS II pour IDA Pro</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/424085/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/141/008/5b2/1410085b245c7ef6a18074b47dda1b6b.gif" alt="image"></a> <br><br>  <i>Capture d'√©cran de l'interface IDA Pro Disassembler</i> <br><br>  IDA Pro est un c√©l√®bre d√©monteur utilis√© par les chercheurs en s√©curit√© de l'information du monde entier depuis de nombreuses ann√©es.  Chez Positive Technologies, nous utilisons √©galement cet outil.  De plus, nous avons pu d√©velopper notre propre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">module processeur de d√©sassembleur pour l'architecture de microprocesseur NIOS II</a> , ce qui augmente la vitesse et la commodit√© de l'analyse de code. <br><br>  Aujourd'hui, je vais raconter l'histoire de ce projet et montrer ce qui s'est finalement pass√©. <a name="habracut"></a><br><br><h2>  Contexte </h2><br>  Tout a commenc√© en 2016, lorsque nous avons d√ª d√©velopper notre propre module processeur pour analyser le firmware en une seule t√¢che.  Le d√©veloppement a √©t√© effectu√© √† partir de z√©ro sur le manuel <a href="">Nios II Classic Processor Reference Guide</a> , qui √©tait alors le plus pertinent.  Au total, ce travail a pris environ deux semaines. <br><br>  Le module processeur a √©t√© d√©velopp√© pour la version IDA 6.9.  Pour la vitesse, IDA Python a √©t√© choisi.  √Ä l'endroit o√π r√©sident les modules du processeur - le sous-r√©pertoire procs dans le r√©pertoire d'installation IDA Pro - il y a trois modules Python: msp430, ebc, spu.  Vous pouvez y voir comment le module est organis√© et comment la fonctionnalit√© de d√©montage de base peut √™tre impl√©ment√©e: <br><br><ul><li>  analyser les instructions et les op√©randes, </li><li>  leur simplification et leur affichage, </li><li>  cr√©er des d√©calages, des r√©f√©rences crois√©es, ainsi que le code et les donn√©es auxquels ils se r√©f√®rent </li><li>  traitement des constructions de commutateurs, </li><li>  g√©rer les manipulations avec la pile et les variables de pile. </li></ul><br>  Environ une telle fonctionnalit√© a √©t√© mise en ≈ìuvre √† l'√©poque.  Heureusement, l'outil a √©t√© utile dans le processus de travail sur une autre t√¢che, au cours de laquelle, un an plus tard, il a √©t√© activement utilis√© et affin√©. <br><br>  J'ai d√©cid√© de partager l'exp√©rience de la cr√©ation du module processeur avec la communaut√© lors des PHDays 8. La pr√©sentation a suscit√© un int√©r√™t (le reportage vid√©o a √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publi√©</a> sur le site PHDays), m√™me le cr√©ateur d'IDA Pro Ilfak Gilfanov √©tait pr√©sent.  L'une de ses questions √©tait de savoir si la prise en charge d'IDA Pro version 7 √©tait impl√©ment√©e. √Ä ce moment-l√†, elle n'√©tait pas l√†, mais apr√®s la repr√©sentation, j'ai promis de faire une version appropri√©e du module.  C'est l√† que le plaisir a commenc√©. <br><br>  Maintenant, le dernier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel d'Intel</a> , qui a √©t√© utilis√© pour v√©rifier et v√©rifier les erreurs.  J'ai consid√©rablement r√©vis√© le module, ajout√© un certain nombre de nouvelles fonctionnalit√©s, y compris la r√©solution de ces probl√®mes qui ne pouvaient pas √™tre vaincus auparavant.  Bien s√ªr, j'ai ajout√© la prise en charge de la 7e version d'IDA Pro.  Voici ce qui s'est pass√©. <br><br><h2>  Mod√®le logiciel NIOS II </h2><br>  NIOS II est un processeur logiciel d√©velopp√© pour les FPGA Altera (qui fait d√©sormais partie d'Intel).  Du point de vue des programmes, il pr√©sente les caract√©ristiques suivantes: ordre des octets du petit endian, espace d'adressage 32 bits, jeu d'instructions 32 bits, c'est-√†-dire que 4 octets, 32 registres g√©n√©raux et 32 ‚Äã‚Äãregistres sp√©ciaux sont utilis√©s pour coder chaque commande. <br><br><h2>  D√©montage et r√©f√©rences de code </h2><br>  Nous avons donc ouvert un nouveau fichier dans IDA Pro, avec le firmware du processeur NIOS II.  Apr√®s avoir install√© le module, nous le verrons dans la liste des processeurs IDA Pro.  Le choix du processeur est indiqu√© sur la figure. <br><br><img src="https://habrastorage.org/webt/9x/wd/ni/9xwdnil54uqjf3wru4nqcc0fkr8.png"><br><br>  Supposons que le module n'ait pas encore impl√©ment√© m√™me une analyse de base des commandes.  √âtant donn√© que chaque commande prend 4 octets, nous regroupons les octets en quatre, puis tout ressemblera √† ceci. <br><br><img src="https://habrastorage.org/webt/be/v9/_j/bev9_jokezmrwfxgr5gtscagrma.png"><br><br>  Apr√®s avoir impl√©ment√© la fonctionnalit√© de base des instructions de d√©codage et des op√©randes, les afficher √† l'√©cran et analyser les instructions de transfert de contr√¥le, l'octet d√©fini dans l'exemple ci-dessus est converti en le code suivant. <br><br><img src="https://habrastorage.org/webt/w6/zm/5c/w6zm5c7rzp0ee0qec2twmkzdnxe.png"><br><br>  Comme le montre l'exemple, des r√©f√©rences crois√©es sont √©galement g√©n√©r√©es √† partir des commandes de transfert de contr√¥le (dans ce cas, vous pouvez voir le saut conditionnel et l'appel de proc√©dure). <br><br>  Une des propri√©t√©s utiles qui peuvent √™tre impl√©ment√©es dans les modules de processeur est les commentaires de commande.  Si vous d√©sactivez la sortie des valeurs d'octets et activez la sortie des commentaires, la m√™me section de code ressemblera d√©j√† √† ceci. <br><br><img src="https://habrastorage.org/webt/gu/ia/u0/guiau0csjjbidgimzewinug4pvq.png"><br><br>  Ici, si vous avez rencontr√© pour la premi√®re fois le code assembleur d'une nouvelle architecture, √† l'aide de commentaires, vous pouvez comprendre ce qui se passe.  De plus, les exemples de code seront sous la m√™me forme - avec des commentaires, afin de ne pas regarder le manuel NIOS II, mais de comprendre imm√©diatement ce qui se passe dans la section de code, qui est donn√©e √† titre d'exemple. <br><br><h2>  Pseudo-instructions et simplification des commandes </h2><br>  Certaines commandes NIOS II sont de pseudo instructions.  Il n'y a pas d'opcodes s√©par√©s pour ces √©quipes, et elles sont elles-m√™mes mod√©lis√©es comme des cas sp√©ciaux d'autres √©quipes.  Dans le processus de d√©montage, une simplification des instructions est effectu√©e - le remplacement de certaines combinaisons par des pseudo-instructions.  Les pseudo-instructions dans NIOS II peuvent g√©n√©ralement √™tre divis√©es en quatre types: <br><br><ul><li>  lorsque l'une des sources est nulle (r0) et peut √™tre retir√©e de la consid√©ration, </li><li>  lorsque l'√©quipe a une valeur n√©gative et que l'√©quipe est remplac√©e par le contraire, </li><li>  lorsque la condition est invers√©e, </li><li>  lorsque le d√©calage 32 bits est entr√© dans deux √©quipes en plusieurs parties (le plus jeune et le plus √¢g√©) et qu'il est remplac√© par une commande. </li></ul><br>  Les deux premiers types ont √©t√© mis en ≈ìuvre, car le remplacement de la condition ne donne rien de sp√©cial, et les d√©calages 32 bits ont plus d'options que celles pr√©sent√©es dans le manuel. <br><br>  Par exemple, pour la premi√®re vue, consid√©rez le code. <br><br><img src="https://habrastorage.org/webt/ix/if/kt/ixifktzau98plchui3ypjf0qn6c.png"><br><br>  On voit que l'utilisation du registre z√©ro dans les calculs se retrouve souvent ici.  Si vous regardez attentivement cet exemple, vous remarquerez que toutes les commandes, √† l'exception du transfert de contr√¥le, sont des options permettant de saisir simplement des valeurs dans des registres sp√©cifiques. <br><br>  Apr√®s avoir impl√©ment√© le traitement des pseudo instructions, nous obtenons la m√™me section de code, mais maintenant il semble plus lisible, et au lieu de variations des commandes or et add, nous obtenons des variations de la commande mov. <br><br><img src="https://habrastorage.org/webt/ka/4j/_q/ka4j_qwz2elzmsmccfrewbtn9cc.png"><br><br><h2>  Variables de pile </h2><br>  L'architecture NIOS II prend en charge la pile et, en plus du pointeur de pile sp, il existe √©galement un pointeur vers la trame de pile fp.  Prenons un exemple d'une petite proc√©dure qui utilise une pile. <br><br><img src="https://habrastorage.org/webt/82/_o/1v/82_o1v_n-ojrlgtveqtfjln2vve.png"><br><br>  De toute √©vidence, l'espace est r√©serv√© aux variables locales sur la pile.  On peut supposer que le registre ra est stock√© dans la variable de pile puis restaur√© √† partir de celle-ci. <br><br>  Apr√®s avoir ajout√© des fonctionnalit√©s au module qui suit les modifications du pointeur de pile et cr√©e des variables de pile, le m√™me exemple ressemblera √† ceci. <br><br><img src="https://habrastorage.org/webt/zg/pk/fx/zgpkfxblezz4cp78gfqswegbjza.png"><br><br>  Maintenant, le code semble un peu plus clair, et vous pouvez d√©j√† nommer les variables de pile et analyser leur fonction en suivant les r√©f√©rences crois√©es.  La fonction dans l'exemple est de type __fastcall et ses arguments dans les registres r4 et r5 sont pouss√©s sur la pile pour appeler une sous-proc√©dure de type _stdcall. <br><br><h2>  Num√©ros 32 bits et d√©calages </h2><br>  La particularit√© de NIOS II est qu'en une seule op√©ration, c'est-√†-dire lors de l'ex√©cution d'une seule commande, il est possible d'enregistrer au plus une valeur directe de 2 octets (16 bits).  D'autre part, les registres du processeur et l'espace d'adressage sont de 32 bits, c'est-√†-dire que pour l'adressage, 4 octets doivent √™tre entr√©s dans le registre. <br><br>  Pour r√©soudre ce probl√®me, des d√©placements en deux parties sont utilis√©s.  Un m√©canisme similaire est utilis√© dans les processeurs de PowerPC: l'offset se compose de deux parties, la plus ancienne et la plus jeune, et est entr√© dans le registre par deux commandes.  Dans PowerPC, c'est comme suit. <br><br><img src="https://habrastorage.org/webt/n8/qm/5z/n8qm5zedw9ffnckmjclzmhfwkh8.png"><br><br>  Dans cette approche, des liaisons crois√©es sont form√©es √† partir des deux √©quipes, bien qu'en fait, l'adresse soit configur√©e dans la deuxi√®me commande.  Cela peut parfois √™tre g√™nant lors du comptage du nombre de r√©f√©rences crois√©es. <br><br>  Les propri√©t√©s de d√©calage pour la partie la plus ancienne utilisent le type non standard HIGHA16, parfois le type HIGH16 est utilis√©, pour la partie la plus jeune - LOW16. <br><br><img src="https://habrastorage.org/webt/l-/u3/6r/l-u36riq53_ejmry2mwdv7qewp4.png"><br><br>  Il n'y a rien de compliqu√© dans le calcul des nombres en deux parties 32 bits.  Des difficult√©s surviennent dans la formation d'op√©randes comme compensations pour deux √©quipes distinctes.  Tout ce traitement incombe au module processeur.  Il n'y a aucun exemple de comment impl√©menter cela (en particulier en Python) dans le SDK IDA. <br><br>  Dans le rapport sur les PHDays, les biais √©taient un probl√®me non r√©solu.  Pour r√©soudre le probl√®me, nous avons trich√©: d√©calage 32 bits uniquement √† partir de la partie la plus jeune - sur la base.  La base est calcul√©e comme la partie la plus ancienne, d√©cal√©e vers la gauche de 16 bits. <br><br><img src="https://habrastorage.org/webt/ip/lc/60/iplc60jwuylhovnugr8qgyxorbq.png"><br><br>  Avec cette approche, une r√©f√©rence crois√©e est form√©e uniquement avec la commande pour entrer la partie inf√©rieure du d√©calage 32 bits. <br><br>  La base est visible dans les propri√©t√©s de d√©calage et la propri√©t√© est marqu√©e afin de la consid√©rer comme un nombre, de sorte qu'un grand nombre de r√©f√©rences crois√©es √† l'adresse elle-m√™me ne sont pas form√©es, que nous prenons comme base. <br><br><img src="https://habrastorage.org/webt/_3/ui/wy/_3uiwyr9jt0lpipfsounaz07q3c.png"><br><br>  Dans le code de NIOS II, le m√©canisme suivant est trouv√© pour entrer des nombres 32 bits dans le registre.  Tout d'abord, la partie la plus ancienne du d√©calage est entr√©e dans le registre avec la commande movhi.  Puis la partie la plus jeune le rejoint.  Cela peut √™tre fait de trois mani√®res (par des commandes): ajouter addi, soustraire subi, OR logique ori. <br><br>  Par exemple, dans la section suivante du code, les registres sont d√©finis sur des nombres de 32 bits, qui sont ensuite entr√©s dans des registres - arguments avant d'appeler la fonction. <br><br><img src="https://habrastorage.org/webt/rs/4l/ms/rs4lmsgotpjsjrb92qh6gkk9s-y.png"><br><br>  Apr√®s avoir ajout√© le calcul de d√©calage, nous obtenons la repr√©sentation suivante de ce bloc de code. <br><br><img src="https://habrastorage.org/webt/sg/3c/i_/sg3ci__0-wvfkj-5j40xuemubva.png"><br><br>  Le d√©calage 32 bits r√©sultant s'affiche √† c√¥t√© de la commande pour entrer dans sa partie inf√©rieure.  Cet exemple est assez illustratif, et nous pourrions m√™me facilement calculer tous les nombres 32 bits dans l'esprit en ajoutant simplement les parties mineures et les plus √©lev√©es.  √Ä en juger par les valeurs, il ne s'agit probablement pas de biais. <br><br>  Consid√©rez le cas o√π la soustraction est utilis√©e lors de l'entr√©e dans la partie la plus jeune.  Dans cet exemple, il ne sera pas possible de d√©terminer les nombres finaux 32 bits (d√©calages) lors du d√©placement. <br><br><img src="https://habrastorage.org/webt/i-/8x/yt/i-8xyto-q5iqeiffz3hua-d29ew.png"><br><br>  Apr√®s avoir appliqu√© le calcul des nombres 32 bits, nous obtenons le formulaire suivant. <br><br><img src="https://habrastorage.org/webt/tf/da/8-/tfda8-uw3xkthiqqe930jut8ovs.png"><br><br>  Ici, nous voyons que maintenant, si l'adresse est dans l'espace d'adressage, un d√©calage est form√© dessus, et la valeur qui a √©t√© form√©e √† la suite de la connexion des parties junior et senior n'est plus affich√©e √† c√¥t√©.  Ici, ils ont obtenu un d√©calage de la ligne "22/10/08".  Pour que le reste des d√©calages pointe vers des adresses valides, augmentons un peu le segment. <br><br><img src="https://habrastorage.org/webt/0i/qq/fh/0iqqfhcomre0yd3siixym3vt0o8.png"><br><br>  Apr√®s avoir augment√© le segment, nous obtenons que maintenant tous les nombres calcul√©s sur 32 bits sont des d√©calages et indiquent des adresses valides. <br><br>  Il a √©t√© mentionn√© ci-dessus qu'il existe une autre option pour calculer les d√©calages lorsqu'une commande logique OU est utilis√©e.  Voici un exemple de code dans lequel deux d√©calages sont calcul√©s de cette mani√®re. <br><br><img src="https://habrastorage.org/webt/xr/or/am/xroramzy4_lj_g3po7yxo-m0sxy.png"><br><br>  Celui qui est √©valu√© dans le registre r8 est ensuite pouss√© sur la pile. <br><br>  Apr√®s la conversion, on peut voir que dans ce cas les registres sont configur√©s aux adresses du d√©but des proc√©dures, c'est-√†-dire que l'adresse de la proc√©dure est pouss√©e sur la pile. <br><br><img src="https://habrastorage.org/webt/wr/au/qm/wrauqmfpotzlhjdiz4_i8mnghri.png"><br><br><h2>  Lecture et √©criture par rapport √† la base </h2><br>  Avant cela, nous avons consid√©r√© les cas o√π un nombre 32 bits entr√© √† l'aide de deux commandes pouvait √™tre juste un nombre et √©galement un d√©calage.  Dans l'exemple suivant, la base est entr√©e dans la partie sup√©rieure du registre, puis la lecture ou l'√©criture se produit par rapport √† elle. <br><br><img src="https://habrastorage.org/webt/ho/2v/ve/ho2vvexmp7367xll5prt5xwpc8m.png"><br><br>  Apr√®s avoir trait√© de telles situations, nous obtenons le d√©calage des variables √† partir des commandes de lecture et d'√©criture elles-m√™mes.  De plus, selon la dimension de l'op√©ration, la taille de la variable elle-m√™me est fix√©e. <br><br><img src="https://habrastorage.org/webt/cl/pi/g-/clpig-mgt5xtsshbvp67wh9rrdg.png"><br><br><h2>  Constructions de commutation </h2><br>  Les constructions de commutateur trouv√©es dans les fichiers binaires peuvent faciliter l'analyse.  Par exemple, par le nombre de cas de s√©lection dans la construction du commutateur, vous pouvez localiser le commutateur responsable du traitement d'un certain protocole ou syst√®me de commande.  Par cons√©quent, la t√¢che se pose de reconna√Ætre le commutateur lui-m√™me et ses param√®tres.  Consid√©rez la section de code suivante. <br><br><img src="https://habrastorage.org/webt/g9/t7/7u/g9t77ugtkercggcjphfq9xfam_0.png"><br><br>  Le thread d'ex√©cution s'arr√™te √† la transition du registre jmp r2.  De plus, il y a des blocs de code vers lesquels il y a des liens √† partir des donn√©es, et √† la fin de chaque bloc, il y a un saut vers la m√™me √©tiquette.  De toute √©vidence, il s'agit d'une construction de commutateur et ces blocs individuels en g√®rent des cas sp√©cifiques.  Ci-dessus, vous pouvez √©galement voir la v√©rification du nombre de cas et le saut par d√©faut. <br><br>  Apr√®s avoir ajout√© le traitement des commutateurs, ce code ressemblera √† ceci. <br><br><img src="https://habrastorage.org/webt/rm/qj/hw/rmqjhwhrknmc_cycqu5d57kjpmq.png"><br><br>  Maintenant, le saut lui-m√™me est indiqu√©, l'adresse de la table avec les d√©calages, le nombre de cas, ainsi que chaque cas avec le num√©ro correspondant. <br><br>  Le tableau lui-m√™me avec les d√©calages des options est le suivant.  Pour √©conomiser de l'espace, les cinq premiers √©l√©ments sont donn√©s. <br><br><img src="https://habrastorage.org/webt/9b/ke/x9/9bkex9oxlk_vv4nrpdya3nckv3m.png"><br><br>  En effet, le traitement du switch consiste √† parcourir le code et √† rechercher tous ses composants.  Autrement dit, un sch√©ma d'organisation du commutateur est d√©crit.  Parfois, il peut y avoir des exceptions dans les r√©gimes.  Cela peut √™tre la raison pour laquelle les commutateurs apparemment clairs ne sont pas reconnus dans les modules de processeur existants.  Il s'av√®re que le v√©ritable commutateur ne rel√®ve tout simplement pas du sch√©ma d√©fini √† l'int√©rieur du module processeur.  Il y a encore des options possibles lorsque le circuit semble √™tre l√†, mais il y a d'autres √©quipes √† l'int√©rieur qui ne sont pas impliqu√©es dans le circuit, ou les √©quipes principales sont r√©organis√©es, ou il est interrompu par des transitions. <br><br>  Le module processeur NIOS II reconna√Æt un commutateur avec de telles instructions ¬´√©trang√®res¬ª entre les commandes principales, ainsi qu'avec les emplacements r√©arrang√©s des commandes principales et avec des coupures de circuit.  Un chemin de retour est utilis√© le long du chemin d'ex√©cution, en tenant compte des transitions possibles qui coupent le circuit, avec l'installation de variables internes qui signalent diff√©rents √©tats du module de reconnaissance.  Par cons√©quent, environ 10 options d'organisation de commutateur diff√©rentes trouv√©es dans le micrologiciel sont reconnues. <br><br><h2>  Instruction personnalis√©e </h2><br>  Il y a une fonctionnalit√© int√©ressante dans l'architecture NIOS II - l'instruction personnalis√©e.  Il donne acc√®s √† 256 instructions d√©finies par l'utilisateur qui sont possibles dans l'architecture NIOS II.  Dans son travail, en plus des registres √† usage g√©n√©ral, l'instruction personnalis√©e peut acc√©der √† un ensemble sp√©cial de 32 registres personnalis√©s.  Apr√®s avoir impl√©ment√© la logique d'analyse de la commande personnalis√©e, nous obtenons le formulaire suivant. <br><br><img src="https://habrastorage.org/webt/ws/8d/zo/ws8dzozz7aext7buc0g3re8kwno.png"><br><br>  Vous pouvez remarquer que les deux derni√®res instructions ont le m√™me num√©ro d'instruction et semblent effectuer les m√™mes actions. <br><br>  Selon les instructions personnalis√©es, il existe un <a href="">manuel s√©par√©</a> .  Selon lui, l'une des options les plus compl√®tes et les plus √† jour pour le jeu d'instructions personnalis√© est le jeu d'instructions NIOS II Floating Point Hardware 2 Component (FPH2) pour travailler avec la virgule flottante.  Apr√®s avoir impl√©ment√© l'analyse des commandes FPH2, l'exemple ressemblera √† ceci. <br><br><img src="https://habrastorage.org/webt/ex/-q/1g/ex-q1g9sszau_hhllau3_xrvgdw.png"><br><br>  √Ä partir des mn√©moniques des deux derni√®res √©quipes, nous nous assurons qu'elles effectuent vraiment la m√™me action - la commande fadds. <br><br><h2>  Transitions par valeur de registre </h2><br>  Dans le firmware √©tudi√©, une situation est souvent rencontr√©e lorsqu'un saut est effectu√© en fonction de la valeur du registre, dans lequel un d√©calage de 32 bits, qui d√©termine la place du saut, est entr√© auparavant. <br><br>  Prenons un morceau de code. <br><br><img src="https://habrastorage.org/webt/sj/ej/ys/sjejysq65hywye8w6usdbshkc60.png"><br><br>  Dans la derni√®re ligne, il y a un saut dans la valeur du registre, alors qu'il est clair qu'avant l'adresse de la proc√©dure est entr√©e dans le registre, qui commence dans la premi√®re ligne de l'exemple.  Dans ce cas, il est √©vident que le saut est fait √† son d√©but. <br><br>  Apr√®s avoir ajout√© la fonctionnalit√© de reconnaissance des sauts, le formulaire suivant est obtenu. <br><br><img src="https://habrastorage.org/webt/ov/tm/j2/ovtmj2lcb_8lrx8qmxvekuul0lw.png"><br><br>  √Ä c√¥t√© de la commande jmp r8, l'adresse o√π le saut se produit s'il √©tait possible de calculer s'affiche.  Une r√©f√©rence crois√©e est √©galement form√©e entre l'√©quipe et l'adresse o√π le saut a lieu.  Dans ce cas, le lien est visible sur la premi√®re ligne, le saut lui-m√™me s'effectue √† partir de la derni√®re ligne. <br><br><h2>  Valeur du registre GP (pointeur global), sauvegarde et chargement </h2><br>  Il est courant d'utiliser un pointeur global configur√© sur une adresse et les variables sont adress√©es par rapport √† celle-ci.  NIOS II utilise le registre gp (global pointer) pour stocker le pointeur global.  √Ä un moment donn√©, en r√®gle g√©n√©rale, dans les proc√©dures d'initialisation du micrologiciel, la valeur d'adresse est entr√©e dans le registre gp.  Le module processeur g√®re cette situation;  Pour illustrer cela, voici des exemples de code et la fen√™tre de sortie IDA Pro lorsque les messages de d√©bogage sont activ√©s dans le module processeur. <br><br>  Dans cet exemple, le module processeur recherche et calcule la valeur du registre gp dans la nouvelle base de donn√©es.  Lors de la fermeture de la base de donn√©es idb, la valeur gp est stock√©e dans la base de donn√©es. <br><br><img src="https://habrastorage.org/webt/cx/ll/hk/cxllhko-hugm77k68idqqam4wzm.png"><br><br>  Lors du chargement d'une base de donn√©es idb existante et si la valeur gp a d√©j√† √©t√© trouv√©e, elle est charg√©e √† partir de la base de donn√©es, comme indiqu√© dans le message de d√©bogage dans l'exemple suivant. <br><br><img src="https://habrastorage.org/webt/-y/z7/1u/-yz71u_odhytnmobj0dlfb73v-k.png"><br><br><h2>  Lire et √©crire sur gp </h2><br>  Les op√©rations courantes sont la lecture et l'√©criture avec un d√©calage par rapport au registre gp.  Par exemple, dans l'exemple suivant, trois lectures et un enregistrement de ce type sont effectu√©s. <br><br><img src="https://habrastorage.org/webt/6b/0l/-b/6b0l-bqxv1qiuw5nvh3i08vvstk.png"><br><br>  Puisque nous avons d√©j√† obtenu la valeur de l'adresse qui est stock√©e dans le registre gp, nous pouvons traiter ce type de lecture et d'√©criture. <br><br>  Apr√®s avoir ajout√© un traitement pour les situations de lecture et d'√©criture par rapport au registre gp, nous obtenons une image plus pratique. <br><br><img src="https://habrastorage.org/webt/wx/st/c1/wxstc1auiw0z0gvfzwmcooocooq.png"><br><br>  Ici, vous pouvez voir quelles variables sont accessibles, suivre leur utilisation et identifier leur objectif. <br><br><h2>  Adressage par rapport √† gp </h2><br>  Il existe une autre utilisation du registre gp pour l'adressage des variables. <br><br><img src="https://habrastorage.org/webt/ng/nn/oc/ngnnocz7scbya0x41l7gagf4bew.png"><br><br>  Par exemple, nous voyons ici que les registres sont configur√©s par rapport au registre gp pour certaines variables ou zones de donn√©es. <br><br>  Apr√®s avoir ajout√© une fonctionnalit√© qui reconna√Æt de telles situations, se convertit en d√©calages et ajoute des r√©f√©rences crois√©es, nous obtenons le formulaire suivant. <br><br><img src="https://habrastorage.org/webt/sm/0d/nd/sm0dndgvrmn2xwivnfux3ol-t1e.png"><br><br>  Ici, vous pouvez d√©j√† voir quelles zones relatives aux registres gp sont configur√©es, et il devient plus clair ce qui se passe. <br><br><h2>  Adressage par rapport √† sp </h2><br>  De m√™me, dans l'exemple suivant, les registres sont r√©gl√©s sur certaines zones de m√©moire, cette fois par rapport au registre sp - pointeur vers la pile. <br><br><img src="https://habrastorage.org/webt/p1/nv/k7/p1nvk7gox_d3cwi1gof80k_oizq.png"><br><br>  De toute √©vidence, les registres sont r√©gl√©s sur certaines variables locales.  De telles situations - la d√©finition d'arguments dans des tampons locaux avant les appels de proc√©dure - sont assez courantes. <br><br>  Apr√®s avoir ajout√© le traitement (conversion des valeurs directes en d√©calages), nous obtenons le formulaire suivant. <br><br><img src="https://habrastorage.org/webt/mg/8s/ps/mg8spswm9tq-_zjj-80s0s6lbnk.png"><br><br>  Maintenant, il devient clair qu'apr√®s l'appel de proc√©dure, les valeurs sont charg√©es √† partir des variables dont les adresses ont √©t√© pass√©es en param√®tre avant l'appel de fonction. <br><br><h2>  Renvois du code aux champs de structure </h2><br>  La d√©finition de structures et leur utilisation dans IDA Pro peuvent faciliter l'analyse de code. <br><br><img src="https://habrastorage.org/webt/l6/4u/8u/l64u8ubhx9-ypg1vo914_fa8vta.png"><br><br>  En regardant cette partie du code, nous pouvons comprendre que le champ field_8 est incr√©ment√© et, √©ventuellement, est un compteur de l'occurrence d'un √©v√©nement.  Si les champs de lecture et d'√©criture sont s√©par√©s dans le code √† une grande distance, les r√©f√©rences crois√©es peuvent aider. <br><br>  Consid√©rez la structure elle-m√™me. <br><br><img src="https://habrastorage.org/webt/px/zf/lt/pxzflte9x7kmxfrnipa_yjerstc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que l'acc√®s aux domaines des structures soit, comme nous le voyons, il n'y a pas de r√©f√©rences crois√©es du code aux √©l√©ments des structures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s que de telles situations soient trait√©es, pour notre cas, tout ressemblera √† ceci. </font></font><br><br><img src="https://habrastorage.org/webt/k_/7t/zu/k_7tzupju7tyyje9r-i6ed6ra08.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe d√©sormais des r√©f√©rences crois√©es pour structurer les champs d'√©quipes sp√©cifiques qui travaillent avec ces champs. </font><font style="vertical-align: inherit;">Des r√©f√©rences crois√©es avant et arri√®re sont cr√©√©es, et vous pouvez suivre par diverses proc√©dures o√π les valeurs des champs de structure sont lues et o√π elles sont entr√©es.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âcarts entre manuel et r√©alit√© </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le manuel, lors du d√©codage de certaines commandes, certains bits doivent prendre des valeurs strictement d√©finies. </font><font style="vertical-align: inherit;">Par exemple, pour une commande de retour √† partir d'une exception eret, les bits 22 √† 26 doivent √™tre 0x1E. </font></font><br><br><img src="https://habrastorage.org/webt/6r/o4/ys/6ro4ys-mrzuck_-stdnjctilwq8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici un exemple de cette commande √† partir d'un firmware. </font></font><br><br><img src="https://habrastorage.org/webt/te/lv/at/telvatwfv4tmdjpaurhickredpo.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En ouvrant un autre firmware dans un endroit avec un contexte similaire, nous rencontrons une situation diff√©rente. </font></font><br><br><img src="https://habrastorage.org/webt/ss/p3/qg/ssp3qgrbyu4stqyfht6mmzitgmi.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces octets n'ont pas √©t√© automatiquement convertis en commande, bien qu'il y ait traitement de toutes les commandes. </font><font style="vertical-align: inherit;">A en juger par l'environnement, et m√™me une adresse similaire, il devrait s'agir de la m√™me √©quipe. </font><font style="vertical-align: inherit;">Examinons attentivement les octets. </font><font style="vertical-align: inherit;">Il s'agit de la m√™me commande eret, √† l'exception du fait que les bits 22 √† 26 ne sont pas √©gaux √† 0x1E, mais √©gaux √† z√©ro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons corriger un peu l'analyse de cette commande. </font><font style="vertical-align: inherit;">Maintenant, il ne correspond pas tout √† fait au manuel, mais il correspond √† la r√©alit√©.</font></font><br><br><img src="https://habrastorage.org/webt/as/fn/nl/asfnnlau91zf6y1aan-f3l__wz0.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prise en charge IDA 7 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis IDA 7.0, l'API fournie par Python IDA pour les scripts normaux a beaucoup chang√©. Quant aux modules processeurs, les changements sont colossaux. Malgr√© cela, le module processeur NIOS II a pu √™tre refait pour la version 7, et il a fonctionn√© avec succ√®s. </font></font><br><br><img src="https://habrastorage.org/webt/-w/zh/z_/-wzhz_lzuq_ad226tgx_0abl3ke.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seul moment incompr√©hensible: lors du chargement d'un nouveau fichier binaire sous NIOS II dans IDA 7, l'analyse automatique initiale pr√©sente dans IDA 6.9 ne se produit pas.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus de la fonctionnalit√© de d√©montage de base, dont des exemples sont dans le SDK, le module processeur impl√©mente de nombreuses fonctionnalit√©s diff√©rentes qui facilitent le travail de l'explorateur de code. </font><font style="vertical-align: inherit;">Il est clair que tout cela peut √™tre fait manuellement, mais, par exemple, quand il y a des milliers et des dizaines de milliers de d√©calages de diff√©rents types sur un fichier binaire avec un firmware de quelques m√©gaoctets, pourquoi y consacrer du temps? </font><font style="vertical-align: inherit;">Laissez le module processeur le faire pour nous. </font><font style="vertical-align: inherit;">Apr√®s tout, comment sont les fonctionnalit√©s agr√©ables d'une navigation rapide √† travers le code √©tudi√© en utilisant des r√©f√©rences crois√©es! </font><font style="vertical-align: inherit;">Cela fait de l'IDA un outil aussi pratique et agr√©able que nous le connaissons. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Publi√© par</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anton Dorfman, Positive Technologies</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424085/">https://habr.com/ru/post/fr424085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424071/index.html">Th√©orie du bonheur. Thermodynamique des in√©galit√©s de classe</a></li>
<li><a href="../fr424073/index.html">Ex√©cution de code √† distance dans le moteur de base de donn√©es Microsoft JET</a></li>
<li><a href="../fr424077/index.html">La France exige de mondialiser le ¬´droit √† l'oubli¬ª - ce qu'il peut affecter</a></li>
<li><a href="../fr424081/index.html">RESS - Nouvelle architecture pour les applications mobiles</a></li>
<li><a href="../fr424083/index.html">Un service de n√©gociation sur la bourse Robinhood a √©t√© accus√© de vendre des donn√©es sur les applications utilisateur √† des commer√ßants √† haute fr√©quence</a></li>
<li><a href="../fr424087/index.html">Appareil Android contr√¥l√© par Bluetooth contr√¥l√© par Arduino - cycle complet (partie 1)</a></li>
<li><a href="../fr424089/index.html">Les conf√©rences sont mauvaises. Ou bien?</a></li>
<li><a href="../fr424091/index.html">WiX.Py: nous collectons le package MSI "en trois lignes"</a></li>
<li><a href="../fr424093/index.html">De la radio antique aux enceintes DIY: 12 cha√Ænes YouTube pour un appareil acoustique</a></li>
<li><a href="../fr424099/index.html">D√©terminer la maturit√© d'une past√®que √† l'aide de Keras: un cycle complet, d'une id√©e √† un programme sur Google Play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>