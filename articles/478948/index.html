<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèº üñ®Ô∏è üë®üèø‚ÄçüöÄ Busque vulnerabilidades en Samsung TrustZone o AFL fuzz all üé† üë∞üèΩ üë∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Con el tiempo, aparecen m√°s y m√°s tecnolog√≠as de protecci√≥n, por lo que los piratas inform√°ticos tienen que apretarse m√°s el cintur√≥n. Sin embargo, es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Busque vulnerabilidades en Samsung TrustZone o AFL fuzz all</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/478948/"><p><img src="https://habrastorage.org/webt/uk/fw/rl/ukfwrlxwv9vr1rrwahfzdidi9na.jpeg"></p><br><p>  Con el tiempo, aparecen m√°s y m√°s tecnolog√≠as de protecci√≥n, por lo que los piratas inform√°ticos tienen que apretarse m√°s el cintur√≥n.  Sin embargo, esta moneda tiene dos caras: las tecnolog√≠as de defensa tambi√©n crean una superficie de ataque adicional, y para sortearlas, solo necesita usar vulnerabilidades en su c√≥digo. </p><br><p> Veamos una de estas tecnolog√≠as: ARM TrustZone.  Sus implementaciones contienen una gran cantidad de c√≥digo, y para buscar vulnerabilidades en ellas, necesita alg√∫n tipo de forma autom√°tica.  Utilizamos el viejo m√©todo probado: fuzzing.  Pero inteligente! </p><br><p>  Crearemos aplicaciones especiales que aparecieron con la introducci√≥n de la tecnolog√≠a TrustZone: los trustlets.  Para describir en detalle el m√©todo de fuzzing que hemos elegido, primero pasamos a la teor√≠a sobre TrustZone, los sistemas operativos confiables y la interacci√≥n con un sistema operativo convencional.  Esto no es por mucho tiempo.  Vamos! </p><a name="habracut"></a><br><h2 id="arm-trustzone">  ARM TrustZone </h2><br><p>  La tecnolog√≠a TrustZone en procesadores ARM le permite transferir el procesamiento de informaci√≥n confidencial a un entorno seguro aislado.  Tal procesamiento se lleva a cabo, por ejemplo, por Keystore, servicios de huellas digitales en el sistema operativo Android, tecnolog√≠as de protecci√≥n de derechos de autor DRM, etc. </p><br><p>  <a href="https://habr.com/ru/post/309618/">Ya se ha</a> <a href="https://habr.com/ru/company/aladdinrd/blog/342924/">escrito mucho</a> sobre el dispositivo TrustZone, por lo que solo lo recordaremos brevemente. </p><br><p><img src="https://habrastorage.org/webt/eu/ny/dg/eunydg_xqmclgf_f47vvwrsdplw.png"></p><br><p>  TrustZone divide el "mundo" (en t√©rminos de TrustZone - World) en dos: Mundo Normal y Mundo Seguro, y agrega cuatro modos de ejecuci√≥n al procesador: </p><br><ul><li>  EL3 - modo monitor - el modo en que se inicia el sistema y cu√°l es el modo de ejecuci√≥n m√°s preferido; </li><li>  S-EL2 - modo de hipervisor confiable; </li><li>  S-EL1: modo de sistema operativo confiable; </li><li>  S-EL0: el modo de aplicaciones confiables (aplicaciones confiables, TA, trustlets) o trustlets. </li></ul><br><p>  En SoC con tecnolog√≠a TrustZone, dos sistemas operativos pueden funcionar simult√°neamente.  Uno que funciona en Normal World se llama Rich OS, y el segundo de Secure World es TEE (Trusted Execution Environment) OS.  Ya hay m√°s de una docena de estos sistemas operativos de confianza.  Nos centraremos en uno espec√≠fico: Trustonic Kinibi.  En particular, se usa en tel√©fonos Samsung con SoC Exynos inclusive hasta el Galaxy S9. </p><br><h2 id="trustonic-kinibi">  Trustonic kinibi </h2><br><p>  Trustonic <a href="https://www.nfcworld.com/2012/12/18/321625/arm-gemalto-and-gd-introduce-alternative-to-nfc-secure-elements/">fue creado por ARM, Gemalto y Giesecke &amp; Devrient (G&amp;D)</a> y continu√≥ desarrollando el sistema operativo Giesecke &amp; Devrient (G&amp;D) Mobicore bajo el nombre de Kinibi. </p><br><p>  El sistema operativo Kinibi es compatible con los <a href="https://globalplatform.org/technical-committees/trusted-execution-environment-tee-committee/">est√°ndares del entorno de ejecuci√≥n confiable de la plataforma global</a> .  Su diagrama estructural se muestra en la figura. </p><br><p><img src="https://habrastorage.org/webt/rn/uj/ff/rnujffhmytxef_pzu99cje21fa4.jpeg"></p><br><p>  Como puede ver, la implementaci√≥n de TrustZone incluye componentes no solo en el "mundo protegido", sino tambi√©n componentes en el "mundo normal".  Para comprender los principales, es mejor mirar el esquema de este sistema desde el punto de vista del desarrollador. </p><br><p><img src="https://habrastorage.org/webt/jf/lr/ok/jflrokza7l-sn8mh84m1a29smjs.jpeg"></p><br><p>  A un nivel bajo en un mundo protegido, adem√°s del microkernel, funcionan los controladores y un administrador de tiempo de ejecuci√≥n.  Y en el mundo normal, funciona un controlador especial, que garantiza que el procesador pase al mundo protegido a pedido de las aplicaciones.  A nivel de espacio de usuario, operan aplicaciones y componentes que proporcionan API para conectar aplicaciones entre los mundos normales y seguros.  Tambi√©n en el mundo normal, funciona un demonio especial que proporciona el lanzamiento inicial de algunos trustlets, y a trav√©s del cual pasan todas las solicitudes de trustlets de las aplicaciones cliente. </p><br><p>  Hay dos conjuntos de API en Kinibi: la API de plataforma global (indicada en verde) y la API heredada (roja).  Ambos conjuntos proporcionan aproximadamente el mismo conjunto de funciones, solo el primero fue construido de acuerdo con los est√°ndares de la Plataforma Global, y el segundo, al parecer, fue anterior al est√°ndar y, por lo tanto, se llama Legacy.  A pesar de que, a juzgar por el nombre, debe alejarse de su uso, solo se utiliza la API heredada en los trustlets de Samsung. </p><br><h2 id="vzaimodeystvie-mezhdu-mirami">  Interacci√≥n entre mundos. </h2><br><p>  Para aprovechar las oportunidades que brinda la tecnolog√≠a TrustZone, las aplicaciones en el mundo normal, llamadas aplicaciones cliente, se comunican con aplicaciones confiables: trustlets.  Los Trustlets implementan varias funciones: autenticaci√≥n, gesti√≥n de claves, trabajo con componentes de hardware que implementan funciones de seguridad, etc. </p><br><p>  Las solicitudes a trustlets se transmiten utilizando memoria compartida especial.  El mundo normal y el mundo protegido, seg√∫n la tecnolog√≠a TrustZone, est√°n aislados entre s√≠ en los niveles superiores (EL0 y S-EL0) de la memoria, y para crear una regi√≥n de memoria compartida entre ellos, llamada World Shared Memory (WSM), la API proporcionada por el protegido El mundo </p><br><p>  La interacci√≥n general entre la aplicaci√≥n cliente y el trustlet se parece a esto: </p><br><p><img src="https://habrastorage.org/webt/6x/91/jb/6x91jbisi920sjwv_vmjch1ltqo.jpeg"></p><br><ol><li>  La aplicaci√≥n cliente accede al daemon con el UID del trustlet con el que desea establecer una sesi√≥n; </li><li>  El daemon usa el controlador para contactar al sistema operativo de confianza con una solicitud para descargar el trustlet; </li><li>  El sistema operativo confiable carga el trustlet en el espacio de direcciones del mundo protegido; </li><li>  La aplicaci√≥n cliente nuevamente crea un b√∫fer WSM a trav√©s de una solicitud al daemon y escribe datos en √©l para la solicitud a la confianza; </li><li>  La aplicaci√≥n del cliente notifica al mundo protegido la disponibilidad de la solicitud; </li><li>  En un mundo seguro, la solicitud se env√≠a al trustlet deseado para su procesamiento, y el trustlet escribe el resultado de su trabajo en el b√∫fer WSM; </li><li>  El ciclo de solicitud y respuesta puede repetirse; </li><li>  La aplicaci√≥n cliente finaliza la sesi√≥n con una confianza. </li></ol><br><p>  Los pseudoc√≥digos de la sesi√≥n de interacci√≥n para la aplicaci√≥n cliente y para el trustlet se ven bastante repetitivos.  Para una aplicaci√≥n cliente: </p><br><pre><code class="plaintext hljs">void main() { uint8_t* tciBuffer; uint32_t tciLength; uint8_t* mem; uint32_t mem_size; mcOpenDevice(MC_DEVICE_ID_DEFAULT); mcMallocWsm(MC_DEVICE_ID_DEFAULT, 0, tciLength, &amp;tciBuffer, 0); session.deviceId = MC_DEVICE_ID_DEFAULT; mcOpenSession(&amp;session, &amp;uuid, tciBuffer, tciLength); mcMap(&amp;session, mem, mem_size, &amp;mapInfo); mcNotify(&amp;session); mcWaitNotification(&amp;session, -1); mcUnmap(&amp;session, mem1, &amp;mapInfo1); mcCloseSession(&amp;session); mcFreeWsm(MC_DEVICE_ID_DEFAULT, tciBuffer); mcCloseDevice(MC_DEVICE_ID_DEFAULT); }</code> </pre> <br><p>  Para trustlet: </p><br><pre> <code class="plaintext hljs">void tlMain(uint8_t *tciData, uint32_t tciLen) { // Check TCI size if (sizeof(tci_t) &gt; tciLen) { // TCI too small -&gt; end Trusted Application tlApiExit(EXIT_ERROR); } // Trusted Application main loop for (;;) { // Wait for a notification to arrive tlApiWaitNotification(INFINITE_TIMEOUT); // Process command // Notify the TLC tlApiNotify(); } }</code> </pre> <br><p>  <code>mcNotify</code> / <code>tlApiNotify</code> y <code>mcWaitNotification</code> / <code>tlApiWaitNotification</code> : estas son las mismas funciones de notificaci√≥n de que una solicitud / respuesta est√° lista para recibir en otro mundo, y la funci√≥n de esperar el procesamiento de la solicitud.  Adem√°s, la aplicaci√≥n cliente tiene la capacidad de usar la funci√≥n mcMap.  Le permite crear otro b√∫fer WSM, si es necesario.  En total, con esta funci√≥n, puede crear solo cuatro de estos b√∫feres. </p><br><p>  Con las aplicaciones cliente, est√° claro: para los tel√©fonos Samsung, estas son aplicaciones normales de Android.  ¬øPero qu√© son los trustlets? </p><br><h2 id="trastlety-kinibi">  Kinibi Trustlets </h2><br><p>  Los Trustlets se encuentran en el sistema de archivos normal del dispositivo y son archivos que contienen c√≥digo ejecutable.  Este no es el formato ELF o APK habitual para Android.  Los trastlets en el sistema operativo Kinibi tienen su propio formato de carga MobiCore (MCLF).  Se describe en los componentes de nivel de <a href="">espacio de usuario de c√≥digo abierto</a> que Trustonic ha publicado en Github.  La estructura del archivo trustlet se puede representar esquem√°ticamente en dicha imagen (el trustlet est√° a la izquierda). </p><br><p><img src="https://habrastorage.org/webt/6n/wl/3w/6nwl3wam_zcbljj0qalgybotnsw.jpeg"></p><br><p>  Las siguientes caracter√≠sticas se pueden distinguir para los trustlets: </p><br><ul><li>  se ejecutan en un espacio de direcciones aislado, es decir, un trustlet no ve otro; </li><li>  no tiene acceso a la memoria del mundo normal, con la excepci√≥n de los buffers WSM, a la memoria del sistema operativo TEE y a la memoria f√≠sica; </li><li>  est√°n ubicados en la memoria en secciones con diferentes derechos de lectura, escritura y ejecuci√≥n; </li><li>  Los buffers WSM residen en memoria no ejecutable; </li><li>  Arranque sin ASLR </li><li>  usan la API proporcionada por mclib, una biblioteca que implementa la API de plataforma global y la API heredada para el mundo protegido; </li><li>  puede acceder a controladores protegidos mediante la funci√≥n <code>tlApi_callDriver</code> . </li></ul><br><p>  Como puede ver, los trustlets tienen capacidades bastante limitadas.  Adem√°s, usan algunos mecanismos de defensa, como varios atributos de memoria, y tambi√©n la mayor√≠a de los trustlets usan canarios de pila para proteger contra la sobrescritura de la pila.  Pero Kinibi no tiene ASLR, aunque <a href="https://www.trustonic.com/news/research/providing-random-numbers-without-kernel-rng/">est√° planeado</a> en nuevas versiones. </p><br><p>  A pesar de todas las restricciones, los trustlets son un objetivo muy interesante para un atacante por las siguientes razones: </p><br><ul><li>  Esta es una ventana en TrustZone desde el nivel de espacio de usuario en Android; </li><li>  pueden servir como punto de partida para aumentar los privilegios al n√∫cleo del sistema operativo TEE; </li><li>  los trustlets tienen acceso a informaci√≥n protegida, donde incluso el kernel de Android no tiene acceso. </li></ul><br><p>  Como dispositivo de prueba, utilizamos el Samsung Galaxy S8.  Si busca trastlets en √©l, resulta que hay bastantes. </p><br><p><img src="https://habrastorage.org/webt/oi/-2/uw/oi-2uwkk_mdvw7dpyqb1k0_2ubc.png"></p><br><p>  Es decir, hay mucho c√≥digo.  Usar an√°lisis est√°tico de c√≥digo binario para buscar vulnerabilidades parece una mala idea.  El an√°lisis din√°mico tan simple simplemente no funcionar√°, solo porque los trastlets tienen su propio formato, diferente de lo que se puede ejecutar en los sistemas operativos tradicionales.  Ser√≠a bueno usar el m√©todo probado de retroalimentaci√≥n difusa, y de alguna manera detectar el bloqueo de los trustlets cuando suceden.  Intentemos resolver este interesante problema. </p><br><h2 id="kak-zhe-eto-fazzit">  ¬øC√≥mo funciona este fuzz? </h2><br><p>  Para aquellos que a√∫n no se han reunido con la maravillosa herramienta AFL y sus muchos complementos, recomendamos leer <a href="https://habr.com/ru/company/dsec/blog/435644/">este buen art√≠culo</a> .  Y probablemente todos los dem√°s sepan que AFL puede confundir archivos ELF.  Adem√°s, incluso los archivos binarios se compilaron inicialmente sin instrumentaci√≥n AFL.  Esto se logra a trav√©s del modo qemu.  AFL utiliza una compilaci√≥n especial del emulador qemu, en el que la funcionalidad de la instrumentaci√≥n binaria de las instrucciones de bifurcaci√≥n se agrega al modo de usuario qemu.  Esto le permite utilizar el control de cobertura de c√≥digo incluso para archivos binarios.  Y una ventaja de esto es la capacidad de difuminar los archivos ejecutables no solo de la arquitectura nativa, sino de todas las arquitecturas que admite qemu.  Pero para usar este modo en nuestra tarea, necesitamos convertir de alguna manera los trustlets al formato ELF. </p><br><p>  Echemos un vistazo m√°s de cerca a los archivos de confianza.  Gracias al formato abierto, <a href="https://github.com/ghassani/mclf-ida-loader">hay un</a> cargador para IDA Pro para ellos.  Si abre cualquier trustlet, excepto, de hecho, su c√≥digo, puede ver que usa las funciones de la biblioteca mclib.  Es interesante que todas las llamadas a tales funciones pasen por una funci√≥n en la direcci√≥n registrada en el encabezado del trastlet.  Por ejemplo, as√≠ es como se ve la funci√≥n tlApiLogvPrintf en el c√≥digo del trustlet, que, obviamente, se ocupa de la salida de cadenas. </p><br><p><img src="https://habrastorage.org/webt/lh/tx/zb/lhtxzbfra6o6pmp_urykpw8lq9w.png"></p><br><p>  Se puede ver que reenv√≠a todos los par√°metros m√°s all√° de otra funci√≥n.  Esta es la funci√≥n de programaci√≥n mclib, cuya direcci√≥n est√° escrita en el encabezado MCLF en un campo llamado <code>tlApiLibEntry</code> .  Es decir, las funciones de biblioteca llamadas de esta manera son las √∫nicas dependencias para los trustlets; los trastlets no tienen ning√∫n otro enlace fuera.  Esto significa que si implementamos stubs para funciones API, podemos ejecutar el c√≥digo de confianza en un entorno Linux normal, por supuesto, primero convirti√©ndolo en un archivo ELF de alguna manera.  Y eso significa que podemos depurarlo y difuminarlo. </p><br><p>  Para convertir un trustlet en un archivo ELF, puede tomar un archivo preparado, por ejemplo, compilar una aplicaci√≥n vac√≠a con la funci√≥n principal y agregar secciones del trustlet junto con su encabezado.  F√°cil!  Tambi√©n es necesario transferir de alguna manera el control al c√≥digo del trustlet.  Tampoco hay problema con esto, el encabezado trastlet contiene la direcci√≥n de su punto de entrada.  Definimos esta direcci√≥n en nuestra funci√≥n <code>main</code> como la direcci√≥n de la funci√≥n y la llamamos.  Despu√©s de pensar y experimentar, podemos delinear el siguiente plan para resolver nuestro problema: </p><br><ol><li>  implementar transferencia de ejecuci√≥n al punto de entrada del trustlet; </li><li>  implementar funciones de biblioteca o ap√©ndices a ellos; </li><li>  implementa la funci√≥n de despacho y escribe su direcci√≥n en el encabezado del tralet; </li><li>  organizar secciones del trustlet a las direcciones deseadas. </li></ol><br><p>  Como necesitamos convertir muchos trustlets en elfos a la vez, debemos pensar en automatizar estas tareas.  Para cada trustlet, se deben determinar autom√°ticamente los siguientes par√°metros: punto de entrada, direcciones de las secciones del trustlet y el tama√±o del b√∫fer de entrada WSM.  Agregue esto al plan. </p><br><ol><li>  Defina el punto de entrada, las direcciones de secci√≥n y el tama√±o del b√∫fer WSM. </li></ol><br><h2 id="sobiraem-elfa">  Recoger el duende </h2><br><p>  1) <strong>punto de entrada</strong> </p><br><p>  El primer elemento del plan es f√°cil de implementar con el siguiente c√≥digo.  Se puede agregar a la funci√≥n <code>main</code> de nuestro archivo ELF de origen. </p><br><pre> <code class="plaintext hljs">typedef void (*tlMain_t)(const void* tciBuffer, const uint32_t tciBufferLen); tlMain_t tlMain = sym_tlMain; tlMain(tciBuffer, tciBufferLen);</code> </pre> <br><p>  Compilamos nuestro c√≥digo en un archivo objeto. </p><br><pre> <code class="plaintext hljs">$(CC) $(INCLUDE) -g -c tlrun.c</code> </pre> <br><p>  El <code>sym_tlMain</code> debe agregarse al archivo de objeto.  Esto se puede hacer usando objcopy. </p><br><pre> <code class="plaintext hljs">arm-linux-gnueabi-objcopy --add-symbol sym_tlMain=$(TLMAIN) tlrun.o tlrun.o.1</code> </pre> <br><p>  Como resultado, obtenemos <code>tlrun.o.1</code> , una fuente compilada con la funci√≥n <code>main</code> que transfiere el control al c√≥digo de confianza. </p><br><p>  2) <strong>funciones de biblioteca</strong> </p><br><p>  Para implementar funciones de biblioteca, primero necesitamos una lista de todas estas funciones.  Hab√≠a una vez una filtraci√≥n de Qualcomm con un mont√≥n de materiales para dispositivos m√≥viles basados ‚Äã‚Äãen sus procesadores.  Entre estos materiales tambi√©n se encontraban algunas im√°genes, archivos de encabezado e im√°genes de depuraci√≥n de algunos componentes para el sistema operativo mobicore.  De all√≠ tomamos prototipos de funciones de biblioteca con sus n√∫meros, pasados ‚Äã‚Äãcomo par√°metro a la funci√≥n de despacho.  Para funciones con un prop√≥sito conocido como <code>tlApiMalloc</code> o <code>tlApiLogvPrintf</code> realizamos las implementaciones correspondientes utilizando funciones similares de libc.  Y las funciones no son tan claras, por ejemplo, reemplazamos <code>tlApiSecSPICmd</code> con stubs simples que muestran su nombre y devuelven el estado OK.  La API completa se compila en <code>tllib.o</code> </p><br><pre> <code class="plaintext hljs">$(CC) $(INCLUDE) -g -c tllib.c</code> </pre> <br><p>  3) <strong>funci√≥n de env√≠o</strong> </p><br><p>  Similar a la direcci√≥n del punto de entrada, agregue el s√≠mbolo, su direcci√≥n es la misma para todos los trustlets: </p><br><pre> <code class="plaintext hljs">arm-linux-gnueabi-objcopy --add-symbol sym_tlApiLibEntry=0x108c tlrun.o tlrun.o.1</code> </pre> <br><p>  La implementaci√≥n de la funci√≥n de programaci√≥n es trivial.  Solo es necesario tener en cuenta que su direcci√≥n debe estar escrita en el encabezado.  Dado que no sabemos de antemano en qu√© direcci√≥n se ubicar√° nuestra funci√≥n de env√≠o despu√©s de vincular e iniciar, debemos escribir su direcci√≥n en el encabezado del trustlet que ya est√° en tiempo de ejecuci√≥n.  Por ejemplo, al iniciar un archivo antes de que la funci√≥n <code>main</code> comience a ejecutarse. </p><br><pre> <code class="plaintext hljs">void (*sym_tlApiLibEntry)(int num) __attribute__((weak)); void tlApiLibEntry(int num) __attribute__((noplt)); __attribute__((constructor)) void init() { sym_tlApiLibEntry = tlApiLibEntry; }</code> </pre> <br><p>  4) <strong>secciones</strong> </p><br><p>  Agregue secciones al archivo objeto, tambi√©n usamos <code>objcopy</code> . </p><br><pre> <code class="plaintext hljs">arm-linux-gnueabi-objcopy --add-section .tlbin_text=.text.bin \ --set-section-flags .tlbin_text=code,contents,alloc,load \ --add-section .tlbin_data=.data.bin \ --set-section-flags .tlbin_data=contents,alloc,load \ --add-section .tlbin_bss=.bss.bin \ --set-section-flags .tlbin_bss=contents,alloc,load \ tlrun.o.1 tlrun.o.2</code> </pre> <br><p>  Aqu√≠ <code>.tlbin_text</code> es el nombre de la secci√≥n del trustlet, y <code>.text.bin</code> es el nombre del archivo con un volcado de esta secci√≥n.  Puede volcar el archivo con el mismo IDA. </p><br><p>  Como resultado de esta conversi√≥n, se agregar√° una confianza binaria al archivo ELF de origen. </p><br><p>  5) <strong>Automatizaci√≥n</strong> </p><br><p>  Para todo el ensamblaje, decidimos utilizar un Makefile grande com√∫n a todos los trustlets y uno peque√±o, conectado a √©l para cada trustlet individual con sus par√°metros.  Para cada trustlet, debe definir un punto de entrada, direcciones de secci√≥n y tama√±o de b√∫fer WSM.  Los dos primeros par√°metros son f√°ciles de obtener con un script simple para la IDA, y determinar el tama√±o del b√∫fer a veces no es tan simple de automatizar.  Tambi√©n puede automatizar esta tarea, o puede pasar 10 minutos para determinarla para todos los trustlets analizando su c√≥digo manualmente.  Estos par√°metros se pueden establecer como variables en su peque√±o Makefile. </p><br><pre> <code class="plaintext hljs">TLMAIN := 0x98F5D TLTEXT := 1000 TLDATA := c0000 TLBSS := c10e0 TLTCI_LEN := 4096</code> </pre> <br><p>  Y en un Makefile grande, use estos par√°metros de esta manera: </p><br><pre> <code class="plaintext hljs">$(CC) $(INCLUDE) -g -DTCILEN=$(TLTCI_LEN) -c tlrun.c # ... $(CC) -g tlrun.o.2 tllib.o --section-start=.tlbin_text=$(TLTEXT),--section-start=.tlbin_data=$(TLDATA),--section-start=.tlbin_bss=$(TLBSS) -o tlrun</code> </pre> <br><p>  Entonces, convertimos el trustlet en un archivo ELF con la ubicaci√≥n correcta de las secciones del trustlet en la memoria y las direcciones correctas en el encabezado.  En teor√≠a, incluso puede ejecutarse correctamente y difuminarse a√∫n m√°s.  Bueno, vamos a verlo! </p><br><h2 id="fazzing">  Fuzzing </h2><br><p>  Dado que AFL usa qemu para ejecutar c√≥digo de arquitectura no nativo, para empezar ser√≠a bueno verificar si nuestro elfo se est√° ejecutando bajo el emulador.  Y luego los problemas comenzaron de inmediato. </p><br><div class="spoiler">  <b class="spoiler_title">Problema n√∫mero 1: cadena de herramientas</b> <div class="spoiler_text"><p>  Para compilar el c√≥digo y compilar el archivo, utilizamos la cadena de herramientas arm-linux-gnueabihf.  "hf" al final significa que el compilador usa soporte de hardware Hard Float en procesadores ARM.  Cuando intent√© ejecutar nuestro archivo con el emulador qemu, se bloque√≥ de inmediato, emitiendo un "error de segmentaci√≥n".  Teniendo en cuenta que en nuestro c√≥digo no hab√≠a trabajo con n√∫meros de punto flotante en ninguna parte, la raz√≥n de este bloqueo era completamente incomprensible.  Despu√©s de pensar un poco, decidimos intentar usar la cadena de herramientas sin Hard float arm-linux-gnueabi.  Y tenemos suerte!  El archivo funcion√≥ y el resultado comenz√≥ a aparecer en la consola. </p><br><p><img src="https://habrastorage.org/webt/vu/t1/he/vut1hesxzshpmwvirmmvilzpoaw.png"></p><br><p>  Entonces puedes difuminar.  Lanzamos AFL y aqu√≠ ... </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Problema n√∫mero 2: instrumentaci√≥n</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/s-/c_/zr/s-c_zrsukymj9mugaex_hpzt5e4.png"></p><br><p>  Por alguna raz√≥n, AFL no ve la instrumentaci√≥n.  Al principio no estaba completamente claro cu√°l era el problema.  qemu est√° construido correctamente, la opci√≥n -Q (modo qemu) est√° configurada.  Maldiciendo, tuve que ingresar al c√≥digo fuente de los parches AFL para qemu.  Resulta que en los parches AFL, al descargar el archivo ELF, qemu busca la secci√≥n de c√≥digo y establece los l√≠mites de las direcciones donde va a producir la instrumentaci√≥n.  El problema es que si hay varias secciones de c√≥digo, por alguna raz√≥n solo se instrumentar√° la primera de ellas.  Este es un error o una caracter√≠stica, pero tenemos dos secciones de c√≥digo, y el punto de entrada - principal - est√° en el segundo.  Obviamente, no ve la instrumentaci√≥n en el inicio, ¬°porque no est√° en la segunda secci√≥n!  Al ver m√°s all√° de la fuente, puede ver que cuando se activa la variable de entorno AFL_INST_LIBS, los l√≠mites de la instrumentaci√≥n se vuelven infinitos.  Enci√©ndelo y enci√©ndelo. </p></div></div><br><p><img src="https://habrastorage.org/webt/6l/8d/qt/6l8dqtepbkflj0lutrcb_af4nl4.png"></p><br><p>  Fuzzing funciona! </p><br><p>  La idea fue confirmada!  Lanzamos fuzzing con comentarios sobre archivos binarios de formato personalizado.  Como puede ver, incluso encuentra alg√∫n tipo de accidente.  Por lo tanto, obtuvimos una forma confiable de eliminar dichos binarios, detectar errores en su c√≥digo y tambi√©n ejecutarlos en Linux regular y depurar convenientemente con las herramientas existentes.  Clase! </p><br><p>  Durante varios d√≠as, llevamos a cabo el borrado de todos los trustlets.  Como resultado, tuvimos muchos datos de entrada que generaron bloqueos y la tarea de analizar todos estos bloqueos. </p><br><h2 id="analiziruem-krashi">  Analizando Crash </h2><br><p>  En total, para 23 fideicomisos, AFL encontr√≥ 477 casos de prueba que generaban un choque.  Una gran cantidad que absolutamente no quiero procesar manualmente.  Entre este conjunto de casos de prueba, hay casi id√©nticos que generan bloqueo en el mismo lugar.  Para eliminar la redundancia de los casos de prueba, puede usar la herramienta afl-cmin.  Despu√©s de pasar por todos los trastlets, quedaban 225 casos por analizar.  De todos modos, mucho!  Para facilitar de alguna manera nuestra tarea, decidimos usar herramientas de an√°lisis din√°mico que ayudar√°n a identificar con mayor precisi√≥n un error de software y cualquiera de sus propiedades.  Esto ayudar√° a evaluar la usabilidad de los errores y la complejidad de su funcionamiento. </p><br><p>  Entonces, para usar alg√∫n tipo de herramientas de an√°lisis din√°mico, necesitamos al menos ejecutar nuestros trustlets convertidos en el sistema ARM nativo, y no bajo la virtualizaci√≥n qemu.  Linux o Android pueden ser adecuados para esto. </p><br><div class="spoiler">  <b class="spoiler_title">Tema 3: secciones</b> <div class="spoiler_text"><p>  Decidimos tomar un sistema de 32 bits con Linux, porque  Trustlets de 32 bits, y Linux es m√°s conveniente y tiene m√°s herramientas de an√°lisis din√°mico que Android.  Y aqu√≠ result√≥ que cuando se lanz√≥, nuestros elfos inmediatamente emitieron una falla de segmentaci√≥n. </p><br><p>  Result√≥ que el problema es lo inusual de nuestros binarios.  Al crearlos, debe colocar las secciones del trustlet en las direcciones deseadas, donde la direcci√≥n de la secci√≥n de c√≥digo del trustlet siempre es 0x1000.  Esta es la primera secci√≥n del archivo, y frente a ella sigue siendo el encabezado ELF en 0x0.  Y en Linux, las dos primeras p√°ginas del espacio de direcciones, hasta la direcci√≥n 0x2000, est√°n reservadas para tareas de utilidad, por lo que cuando el cargador intenta proyectar una secci√≥n all√≠, se produce un error. </p><br><p>  Al final result√≥ que, hay una salida de esta situaci√≥n.  En un kernel de 64 bits, tal reserva de las primeras p√°ginas en la memoria no ocurre, y esta disposici√≥n de secciones se hace posible.  Dado que nuestros archivos son de 32 bits, es conveniente crear primero un entorno de 32 bits en un sistema de 64 bits.  El paquete <code>debootstrap</code> es excelente para estos fines. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Problema n√∫mero 4: sin herramientas</b> <div class="spoiler_text"><p>  Ahora que nuestros trustlets redise√±ados funcionan en el sistema ARM nativo, necesitamos probar herramientas de an√°lisis din√°mico en ellos.  Entre los m√©todos de an√°lisis din√°mico de archivos binarios est√°n la depuraci√≥n y la instrumentaci√≥n binaria din√°mica (DBI).  Gdb es genial para el primero.  Y para el segundo, no hay muchas opciones: bajo ARM, esencialmente solo hay tres marcos DBI estables: DynamoRIO, Valgrind y Frida.  El primero tiene muchas buenas herramientas para rastrear y detectar errores, pero el cargador de archivos ELF, que se implementa en √©l, no pudo hacer frente a la carga de nuestros archivos.  Valgrind es un marco bastante poderoso, y tiene herramientas callgrind adecuadas para nosotros para el rastreo y la verificaci√≥n de memoria para monitorear las operaciones de memoria.  Result√≥ que producen resultados que no son muy convenientes para el an√°lisis, por lo que no son adecuados para su uso en modo autom√°tico en muchos archivos.  Y no tuvimos tiempo de probar Frida.  Si alguien tuvo experiencia en el uso de Linux en ARM, escriba sus impresiones en los comentarios. </p></div></div><br><p>  Como puede ver, solo podemos contentarnos con el depurador.  Pero el uso de scripts para gdb, incluso esto, ya simplifica enormemente nuestro trabajo. </p><br><div class="spoiler">  <b class="spoiler_title">Problema # 5: funciones de biblioteca</b> <div class="spoiler_text"><p>  Otro problema que qued√≥ claro desde el principio fueron las funciones de la biblioteca que usa el trastlet.  Los reemplazamos con stubs, con la excepci√≥n de las funciones que se pueden reemplazar con otras similares de libc.  Obviamente, si en la l√≥gica del trastlet alg√∫n c√≥digo procesa el resultado de una de estas funciones de c√≥digo auxiliar, es muy probable que se bloquee porque espera datos completamente diferentes, y esto no significa necesariamente un error en el c√≥digo. </p><br><p>  Hay bastantes funciones para las que no es tan f√°cil simular el comportamiento de una funci√≥n real: </p><br><ul><li>  tlApiSecSPICmd; </li><li>  tlApi_callDriver; </li><li>  tlApiWrapObjectExt; </li><li>  tlApiUnWrapObjectExt; </li><li>  tlApiCipherDoFinal; </li><li>  tlApiSignatureSign; </li><li>  ... </li></ul><br><p>  Para no perder el tiempo estudiando casos tan dudosos, simplemente decidimos no considerar los casos de prueba que usan estas funciones. </p></div></div><br><h2 id="rezultaty-fazzinga">  Resultados difusos </h2><br><p>  En modo autom√°tico, utilizando scripts, recopilamos la siguiente informaci√≥n sobre todos los trustlets: </p><br><ul><li>  Traidlet UID </li><li>  identificador de choque; </li><li>  tipo de error (tipo de se√±al durante un choque); </li><li>  La direcci√≥n donde ocurre el error </li><li>  Funciones API utilizadas por el trastlet. </li></ul><br><p>  Al final result√≥ que, es muy conveniente poner toda esta informaci√≥n en la base de datos, y luego seleccionar los casos m√°s interesantes para el an√°lisis mediante consultas SQL y agregar informaci√≥n basada en los resultados del an√°lisis. </p><br><p><img src="https://habrastorage.org/webt/k_/uk/mm/k_ukmmhlewkiem_fvzwfms-eiai.png"></p><br><p>  Por ejemplo, con esta consulta puede mostrar todos los casos de prueba en los que se produce el error de falla de segmentaci√≥n: </p><br><pre> <code class="plaintext hljs">select * from main where type = "SIGSEGV";</code> </pre> <br><p>  Y filtre los casos de prueba que usan la funci√≥n <code>tlApiSecSPICmd</code> , que hemos implementado como stub: </p><br><pre> <code class="plaintext hljs">select * from main where api not like "tlApiSecSPICmd";</code> </pre> <br><p>  Por lo tanto, se encontraron errores de diferentes tipos en todos los trustlets.  Algunos de ellos no generaron vulnerabilidades, pero hubo aquellos que son vulnerabilidades y pueden ser utilizados por un atacante.  Considere la m√°s interesante de las vulnerabilidades encontradas. </p><br><h2 id="sve-2019-14126">  SVE-2019-14126 </h2><br><p><img src="https://habrastorage.org/webt/ji/zy/hr/jizyhrbu1vcna9da47r_s0dmjdy.png"></p><br><p>  La vulnerabilidad se encontr√≥ en el keylet trustlet en el c√≥digo para procesar el contenido del b√∫fer TCI al analizar la estructura ASN.1 codificada de acuerdo con las reglas DER.  Se utilizan dos campos en esta estructura como dimensiones: uno al asignar memoria din√°mica y el otro al copiarlo.  Obviamente, si el segundo tama√±o es m√°s grande que el primero, se produce un desbordamiento del mont√≥n.  Tales vulnerabilidades generalmente conducen a la posibilidad de que un atacante ejecute el c√≥digo, por lo que intentamos hacer un exploit completo para esta vulnerabilidad.  Al evaluar la posibilidad de explotaci√≥n, tambi√©n se deben tener en cuenta todas las restricciones de los fideicomisos enumerados anteriormente. </p><br><p>  Teniendo a mano un desbordamiento de pila y en base a estas restricciones, uno puede imaginar la siguiente estrategia de operaci√≥n: </p><br><ol><li>  encuentre alg√∫n puntero de funci√≥n en un lugar accesible para reescribir, por ejemplo, en la secci√≥n .bss; </li><li>  Usando el desbordamiento encontrado, cree un bloque de memoria de mont√≥n en este lugar; </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> iniciar la asignaci√≥n de memoria en una ubicaci√≥n determinada y sobrescribir el puntero de funci√≥n; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> iniciar una llamada de funci√≥n puntero sobrescrito. </font></font></li></ol><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer esto, por supuesto, debe comprender en detalle c√≥mo funciona el mont√≥n en el sistema operativo Kinibi. </font><font style="vertical-align: inherit;">Para hacer esto, tuvimos que aplicar ingenier√≠a inversa a las funciones de asignaci√≥n y liberaci√≥n de memoria mclib, pero ahora se puede encontrar una buena descripci√≥n de la operaci√≥n </font><font style="vertical-align: inherit;">de almacenamiento din√°mico </font><font style="vertical-align: inherit;">en </font></font><a href="https://downloads.immunityinc.com/infiltrate2019-slidepacks/eloi-sanfelix-exploiting-trusted-apps-in-samsung-tee/TEE.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este informe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la conferencia ZeroCon en abril.</font></font></p><br><p>     ‚Äî        .bss.            ,   .bss       .               , ,  ,    ,       . </p><br><p><img src="https://habrastorage.org/webt/l8/ng/jb/l8ngjbgjfox8nubn0ipgjmay70s.jpeg"></p><br><p>  ,       .bss,      . </p><br><p>        ,      . ,       ,    ,    ,       .bss,   .     <em></em>     code-reuse. </p><br><p>     ROP. ,    ROP,            .bss.      ,      ,          .   ,     ,             .     , , ,   . </p><br><p>  ROP,    JOP. JOP ‚Äî  Jump Oriented Programming.  JOP            . </p><br><p>     JOP ,    ROPGadget.     ,     JOP,      : </p><br><pre> <code class="plaintext hljs">ROPgadget --binary tlrun --thumb --range 0x1000-0xbeb44 | grep -E "; b.+ r[0-9]+$"</code> </pre> <br><p>  !       . </p><br><p><img src="https://habrastorage.org/webt/ti/oz/96/tioz96g4dhzaugtxtlr0d4sq4cc.png"></p><br><p>       .  ROP             .  ,  ROP-   <a href="https://en.wikipedia.org/wiki/Weird_machine">weird machine</a> ,    .   JOP     ,          .   ARM,      ,  ,     ‚Äî LDMIA (Load Memory Increment Address). </p><br><p><img src="https://habrastorage.org/webt/i6/vm/pu/i6vmpufz2lpz6aoeapmujzc7xa0.png"></p><br><p>      ,  ,         ,   ,   .         ,            .        JOP! </p><br><p>       LDMIA   . - capstone,    ROPGadget,     LDMLO. </p><br><p><img src="https://habrastorage.org/webt/hm/5l/vi/hm5lvigl8qx96w_xtjasd2ngeie.png"></p><br><p>    !   .         ,         ,  .   stack cookie  ,    . </p><br><pre> <code class="plaintext hljs">*(int*)&amp;mem1[offset] = SUPER_GADGET; // r2 *(int*)&amp;mem1[offset + 4] = 0; // r3 *(int*)&amp;mem1[offset + 8] = 0; // r4 *(int*)&amp;mem1[offset + 12] = SUPER_GADGET; // r5 *(int*)&amp;mem1[offset + 16] = 0x9560b; // r7 offset += 0x14; *(int*)&amp;mem1[offset] = 0; // r2 *(int*)&amp;mem1[offset + 4] = 0; // r3 *(int*)&amp;mem1[offset + 8] = 0; // r4 *(int*)&amp;mem1[offset + 12] = 0; // r5 *(int*)&amp;mem1[offset + 16] = 0x96829; // r7 offset += 0x14; *(int*)&amp;mem1[offset] = SUPER_GADGET; // r2 *(int*)&amp;mem1[offset + 4] = 0; // r3 *(int*)&amp;mem1[offset + 8] = 0x3d5f4; // r4 *(int*)&amp;mem1[offset + 12] = mapInfo3.sVirtualAddr; // r5 *(int*)&amp;mem1[offset + 16] = 0x218c7; // r7</code> </pre> <br><p> Hello, world       . </p><br><pre> <code class="plaintext hljs">strcpy(mem3 + 0x100, "Hello world from TEE!\n"); *(int*)&amp;mem1[offset] = 0x7d081b1; // r2 *(int*)&amp;mem1[offset + 4] = 0; // r3 *(int*)&amp;mem1[offset + 8] = mapInfo3.sVirtualAddr + 0x100; // r4 *(int*)&amp;mem1[offset + 12] = 0; // r5 *(int*)&amp;mem1[offset + 16] = 0x9545b; // r7</code> </pre> <br><p><img src="https://habrastorage.org/webt/qt/ay/jo/qtayjouk0l2xu35tl2v2faovzlw.png"></p><br><p>  "Hello, world!"   , , ,   keymaster, ,   .        ,     . ,  <a href="http://bits-please.blogspot.com/2016/06/extracting-qualcomms-keymaster-keys.html"> </a> Gal Beniamini  TEE Qualcomm         ,  ,  offline-     Android.          TEE OS     EL-3,         . </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p> ARM TrustZone             ,            .     Secure World         Android,              .  , , Samsung   <a href="">bug bounty</a>      TrustZone,     . </p><br><p><img src="https://habrastorage.org/webt/ai/rq/ii/airqiifvmexik-gscxzzpu1ohbo.png"></p><br><p>      AFL  qemu,         ""  .            .              ,        .     ! </p><br><h2 id="poleznye-ssylki">  Enlaces utiles </h2><br><ul><li> <a href="https://blog.quarkslab.com/reverse-engineering-samsung-s6-sboot-part-i.html">Reverse Engineering Samsung S6 SBOOT</a> </li><li> <a href="https://medium.com/taszksec/unbox-your-phone-part-i-331bbf44c30c">Unbox Your Phone</a> </li><li> <a href="https://googleprojectzero.blogspot.com/2017/07/trust-issues-exploiting-trustzone-tees.html">Trust Issues: Exploiting TrustZone TEEs</a> </li><li> <a href="https://downloads.immunityinc.com/infiltrate2019-slidepacks/eloi-sanfelix-exploiting-trusted-apps-in-samsung-tee/TEE.pdf">TEE Exploitation: Exploiting Trusted Apps on Samsung's TEE at Zer0con 2019</a> </li><li> <a href="https://i.blackhat.com/USA-19/Thursday/us-19-Peterlin-Breaking-Samsungs-ARM-TrustZone.pdf">BREAKING SAMSUNG'S ARM TRUSTZONE at BlackHat USA 2019</a> </li><li> <a href="https://cfp.recon.cx/reconmtl2019/talk/DYGNJQ/">The road to Qualcomm TrustZone apps fuzzing</a> </li><li> <a href="http://allsoftwaresucks.blogspot.com/2019/05/reverse-engineering-samsung-exynos-9820.html">Reverse-engineering Samsung Exynos 9820 bootloader and TZ</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/478948/">https://habr.com/ru/post/478948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../478930/index.html">C√≥mo usar MySQL sin contrase√±a (y riesgos de seguridad)</a></li>
<li><a href="../478932/index.html">Docker para el front-end. Parte 1. ¬øPor qu√©?</a></li>
<li><a href="../478934/index.html">El m√≥dulo de biblioteca est√°ndar de Python m√°s √∫til que todo el mundo olvida constantemente</a></li>
<li><a href="../478938/index.html">Aprendemos promesas basadas en la especificaci√≥n Ecmascript. Conocido</a></li>
<li><a href="../478942/index.html">Gran experimento porno: la historia de Internet para adultos</a></li>
<li><a href="../478950/index.html">Los resultados de la semana: Huawei se adapta a las sanciones, Putin firma leyes sensacionales y ShutterStock est√° bloqueado en Rusia</a></li>
<li><a href="../478952/index.html">Un mes con Onyx Boox Note Pro</a></li>
<li><a href="../478954/index.html">RE: Miedo y asco en TI</a></li>
<li><a href="../478956/index.html">Presentamos 3CX V16 Update 4 Beta con un cliente Chrome VoIP y una aplicaci√≥n de video para Android</a></li>
<li><a href="../478958/index.html">Gu√≠a completa de actualizaci√≥n de Windows 10 para empresas de cualquier tama√±o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>