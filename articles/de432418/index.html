<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèø üë®üèº‚Äçüè´ üóØÔ∏è Analysieren von Lambda-Ausdr√ºcken in Java ü§æ üòû üéë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von einem √úbersetzer: LambdaMetafactory ist wahrscheinlich einer der am meisten untersch√§tzten Java 8-Mechanismen. Wir haben ihn k√ºrzlich entdeckt, ab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analysieren von Lambda-Ausdr√ºcken in Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/432418/"><p><img src="https://habrastorage.org/webt/nh/bc/r2/nhbcr2a_t-abgnja2uip1sl-uki.jpeg" alt="Bild"></p><br><p>  <em>Von einem √úbersetzer: LambdaMetafactory ist wahrscheinlich einer der am meisten untersch√§tzten Java 8-Mechanismen. Wir haben ihn k√ºrzlich entdeckt, aber seine F√§higkeiten bereits gesch√§tzt.</em>  <em>Version 7.0 des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CUBA-</a> Frameworks verbessert die Leistung, indem reflektierende Aufrufe zugunsten der Erzeugung von Lambda-Ausdr√ºcken vermieden werden.</em>  <em>Eine der Anwendungen dieses Mechanismus in unserem Framework ist das Binden von Anwendungsereignishandlern durch Anmerkungen, eine h√§ufige Aufgabe, ein Analogon von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">EventListener</a> aus Spring.</em>  <em>Wir glauben, dass die Kenntnis der Prinzipien von LambdaFactory in vielen Java-Anwendungen n√ºtzlich sein kann, und wir beeilen uns, diese √úbersetzung mit Ihnen zu teilen.</em> </p><br><p> In diesem Artikel werden einige wenig bekannte Tricks beim Arbeiten mit Lambda-Ausdr√ºcken in Java 8 und die Einschr√§nkungen dieser Ausdr√ºcke gezeigt.  Die Zielgruppe des Artikels sind hochrangige Java-Entwickler, Forscher und Toolkit-Entwickler.  Ohne <code>com.sun.*</code> wird nur die √∂ffentliche Java-API verwendet <code>com.sun.*</code> Und andere interne Klassen, sodass der Code zwischen verschiedenen JVM-Implementierungen portierbar ist. </p><a name="habracut"></a><br><h3 id="korotkoe-predislovie">  Kurzes Vorwort </h3><br><p>  Lambda-Ausdr√ºcke wurden in Java 8 verwendet, um anonyme Methoden zu implementieren. <br>  in einigen F√§llen als Alternative zu anonymen Klassen.  Auf Bytecode-Ebene wird der Lambda-Ausdruck durch die <code>invokedynamic</code> .  Diese Anweisung wird verwendet, um eine funktionale Schnittstellenimplementierung zu erstellen, und ihre einzige Methode delegiert den Aufruf an die tats√§chliche Methode, die den im Hauptteil des Lambda-Ausdrucks definierten Code enth√§lt. </p><br><p>  Zum Beispiel haben wir den folgenden Code: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; strings)</span></span></span></span>{ strings.forEach(item -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Item = %s"</span></span>, item)); }</code> </pre> <br><p>  Dieser Code wird vom Java-Compiler in Folgendes konvertiert: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda_forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Java  System.out.println("Item = %s", item); } private static CallSite bootstrapLambda(Lookup lookup, String name, MethodType type) { // //lookup =  VM //name = "lambda_forEach",  VM //type = String -&gt; void MethodHandle lambdaImplementation = lookup.findStatic(lookup.lookupClass(), name, type); return LambdaMetafactory.metafactory(lookup, "accept", MethodType.methodType(Consumer.class), //  - MethodType.methodType(void.class, Object.class), //  Consumer.accept    lambdaImplementation, //     - type); } void printElements(List&lt;String&gt; strings) { Consumer&lt;String&gt; lambda = invokedynamic# bootstrapLambda, #lambda_forEach strings.forEach(lambda); }</span></span></code> </pre> <br><p>  Die <code>invokedynamic</code> Anweisung kann grob als solcher Java-Code dargestellt werden: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CallSite cs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; strings)</span></span></span><span class="hljs-function"> </span></span>{ Consumer&lt;String&gt; lambda; <span class="hljs-comment"><span class="hljs-comment">//begin invokedynamic if (cs == null) cs = bootstrapLambda(MethodHandles.lookup(), "lambda_forEach", MethodType.methodType(void.class, String.class)); lambda = (Consumer&lt;String&gt;)cs.getTarget().invokeExact(); //end invokedynamic strings.forEach(lambda); }</span></span></code> </pre> <br><p>  Wie Sie sehen k√∂nnen, wird <code>LambdaMetafactory</code> verwendet, um eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CallSite</a> zu erstellen, die eine Factory-Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereitstellt</a> , die einen Handler f√ºr die Zielmethode zur√ºckgibt.  Diese Methode gibt die Implementierung der Funktionsschnittstelle mit <code>invokeExact</code> .  Wenn der Lambda-Ausdruck erfasste Variablen <code>invokeExact</code> akzeptiert <code>invokeExact</code> diese Variablen als tats√§chliche Parameter. </p><br><p>  In Oracle JRE 8 generiert die Metafactory mithilfe von ObjectWeb Asm dynamisch eine Java-Klasse, die eine Klasse erstellt, die eine funktionale Schnittstelle implementiert.  Der erstellten Klasse k√∂nnen zus√§tzliche Felder hinzugef√ºgt werden, wenn der Lambda-Ausdruck externe Variablen erfasst.  Dieser sieht aus wie anonyme Java-Klassen, es gibt jedoch die folgenden Unterschiede: </p><br><ul><li>  Eine anonyme Klasse wird vom Java-Compiler generiert. </li><li>  Die Klasse zum Implementieren des Lambda-Ausdrucks wird zur Laufzeit von der JVM erstellt. </li></ul><br><hr><br><p>  <strong>Die Implementierung der Metafactory h√§ngt vom JVM-Hersteller und der Version ab</strong> </p><br><hr><br><p>  Nat√ºrlich wird die <code>invokedynamic</code> nicht nur f√ºr Lambda-Ausdr√ºcke in Java verwendet.  Es wird haupts√§chlich verwendet, wenn dynamische Sprachen in der JVM-Umgebung ausgef√ºhrt werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die</a> in Java integrierte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nashorn-</a> JavaScript- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Engine</a> verwendet diese Anweisung in gro√üem Umfang. </p><br><p>  Als n√§chstes konzentrieren wir uns auf die <code>LambdaMetafactory</code> Klasse und ihre Funktionen.  Weiter <br>  In diesem Abschnitt wird davon ausgegangen, dass Sie sehr gut verstehen, wie metafabrische Methoden funktionieren und was <code>MethodHandle</code> </p><br><h2 id="tryuki-s-lyambda-vyrazheniyami">  Tricks mit Lambda-Ausdr√ºcken </h2><br><p>  In diesem Abschnitt zeigen wir, wie dynamische Lambdas f√ºr allt√§gliche Aufgaben erstellt werden. </p><br><h3 id="proveryaemye-isklyucheniya-i-lyambdy">  √úberpr√ºfte Ausnahmen und Lambdas </h3><br><p>  Es ist kein Geheimnis, dass alle in Java vorhandenen Funktionsschnittstellen keine gepr√ºften Ausnahmen unterst√ºtzen.  Die Vorteile gepr√ºfter Ausnahmen gegen√ºber regul√§ren Ausnahmen sind eine sehr langj√§hrige (und immer noch hei√üe) Debatte. </p><br><p>  Was aber, wenn Sie Code mit aktivierten Ausnahmen in Lambda-Ausdr√ºcken in Kombination mit Java Streams verwenden m√ºssen?  Beispielsweise m√ºssen Sie eine Liste von Zeichenfolgen in eine Liste von URLs wie folgt konvertieren: </p><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"http://localhost/"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://github.com"</span></span>).stream() .map(URL::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) .collect(Collectors.toList())</code> </pre> <br><p>  Eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausl√∂sbare</a> Ausnahme wird im Konstruktor der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">URL (String)</a> deklariert, sodass sie nicht direkt als Methodenreferenz in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Functiion-</a> Klasse verwendet werden kann. </p><br><p>  Sie werden sagen: "Nein, vielleicht, wenn Sie diesen Trick hier anwenden": </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uncheckCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Callable&lt;T&gt; callable)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callable.call(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sneakyThrow(e); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;E extends Throwable, T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sneakyThrow0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> E </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (E)t; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sneakyThrow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Util.&lt;RuntimeException, T&gt;sneakyThrow0(e); } <span class="hljs-comment"><span class="hljs-comment">//   //return s.filter(a -&gt; uncheckCall(a::isActive)) // .map(Account::getNumber) // .collect(toSet());</span></span></code> </pre> <br><p>  Dies ist ein schmutziger Hack.  Und hier ist warum: </p><br><ul><li>  Der Try-Catch-Block wird verwendet. </li><li>  Die Ausnahme wird erneut ausgel√∂st. </li><li>  Die schmutzige Verwendung der Typl√∂schung in Java. </li></ul><br><p>  Das Problem kann auf "legalere" Weise gel√∂st werden, indem die folgenden Fakten bekannt sind: </p><br><ul><li>  √úberpr√ºfte Ausnahmen werden nur auf Java-Compilerebene erkannt. </li><li>  Der <code>throws</code> Abschnitt besteht nur aus Metadaten f√ºr eine Methode ohne semantischen Wert auf JVM-Ebene. </li><li>  √úberpr√ºfte und normale Ausnahmen sind auf Bytecode-Ebene in der JVM nicht zu unterscheiden. </li></ul><br><p>  Die L√∂sung besteht darin, die <code>Callable.call</code> Methode in eine Methode ohne <code>throws</code> Abschnitt zu verpacken: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;V&gt; <span class="hljs-function"><span class="hljs-function">V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callUnchecked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Callable&lt;V&gt; callable)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callable.call(); }</code> </pre> <br><p>  Dieser Code wird nicht kompiliert, da die <code>Callable.call</code> Methode im Abschnitt " <code>Callable.call</code> " gepr√ºfte Ausnahmen deklariert <code>Callable.call</code> .  Wir k√∂nnen diesen Abschnitt jedoch mit einem dynamisch aufgebauten Lambda-Ausdruck entfernen. </p><br><p>  Zuerst m√ºssen wir eine funktionale Schnittstelle deklarieren, die keinen <code>throws</code> . <br>  aber wer kann den Anruf an <code>Callable.call</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SilentInvoker</span></span></span><span class="hljs-class"> </span></span>{ MethodType SIGNATURE = MethodType.methodType(Object.class, Callable.class);<span class="hljs-comment"><span class="hljs-comment">//  INVOKE &lt;V&gt; V invoke(final Callable&lt;V&gt; callable); }</span></span></code> </pre> <br><p>  Der zweite Schritt besteht darin, eine Implementierung dieser Schnittstelle mit <code>LambdaMetafactory</code> zu erstellen und den Aufruf der <code>SilentInvoker.invoke</code> Methode an die <code>Callable.call</code> Methode zu <code>Callable.call</code> .  Wie bereits erw√§hnt, wird der <code>SilentInvoker.invoke</code> auf Bytecode-Ebene ignoriert, sodass die <code>SilentInvoker.invoke</code> Methode die <code>SilentInvoker.invoke</code> Methode aufrufen <code>Callable.call</code> , ohne Ausnahmen zu deklarieren: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SilentInvoker SILENT_INVOKER; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MethodHandles.Lookup lookup = MethodHandles.lookup(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CallSite site = LambdaMetafactory.metafactory(lookup, <span class="hljs-string"><span class="hljs-string">"invoke"</span></span>, MethodType.methodType(SilentInvoker.class), SilentInvoker.SIGNATURE, lookup.findVirtual(Callable.class, <span class="hljs-string"><span class="hljs-string">"call"</span></span>, MethodType.methodType(Object.class)), SilentInvoker.SIGNATURE); SILENT_INVOKER = (SilentInvoker) site.getTarget().invokeExact();</code> </pre> <br><p>  Drittens schreiben wir eine <code>Callable.call</code> , die <code>Callable.call</code> ohne Ausnahmen zu deklarieren: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;V&gt; <span class="hljs-function"><span class="hljs-function">V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callUnchecked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Callable&lt;V&gt; callable)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*no throws*/</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SILENT_INVOKER.invoke(callable); }</code> </pre> <br><p>  Jetzt k√∂nnen Sie Streams ohne Probleme mit aktivierten Ausnahmen neu schreiben: </p><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"http://localhost/"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://dzone.com"</span></span>).stream() .map(url -&gt; callUnchecked(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(url))) .collect(Collectors.toList());</code> </pre> <br><p>  Dieser Code wird problemlos kompiliert, da <code>callUnchecked</code> keine gepr√ºften Ausnahmen deklariert.  Dar√ºber hinaus kann der Aufruf dieser Methode mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">monomorphem Inline-Caching integriert werden</a> , da nur eine Klasse in der gesamten JVM die <code>SilentOnvoker</code> Schnittstelle implementiert </p><br><p>  Wenn die Implementierung von <code>Callable.call</code> zur Laufzeit eine Ausnahme <code>Callable.call</code> , wird sie von der aufrufenden Funktion ohne Probleme <code>Callable.call</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ callUnchecked(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(<span class="hljs-string"><span class="hljs-string">"Invalid URL"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Exception e){ System.out.println(e); }</code> </pre> <br><p>  Trotz der M√∂glichkeiten dieser Methode sollten Sie immer die folgende Empfehlung beachten: </p><br><hr><br><p>  <strong>Versteckte Ausnahmen mit callUnchecked nur ausblenden, wenn Sie sicher sind, dass der aufgerufene Code keine Ausnahmen ausl√∂st</strong> </p><br><hr><br><p>  Das folgende Beispiel zeigt ein Beispiel f√ºr diesen Ansatz: </p><br><pre> <code class="java hljs">callUnchecked(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(<span class="hljs-string"><span class="hljs-string">"https://dzone.com"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// URL        MalformedURLException</span></span></code> </pre> <br><p>  Die vollst√§ndige Implementierung dieser Methode ist <a href="">hier</a> , sie ist Teil des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SNAMP</a> Open Source- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekts</a> . </p><br><h3 id="rabotaem-s-getters-i-setters">  Arbeiten mit Gettern und Setzern </h3><br><p>  Dieser Abschnitt ist n√ºtzlich f√ºr diejenigen, die Serialisierung / Deserialisierung f√ºr verschiedene Datenformate wie JSON, Thrift usw. schreiben.  Dar√ºber hinaus kann es sehr n√ºtzlich sein, wenn Ihr Code stark von der Reflexion f√ºr Getters und Setter in JavaBeans abh√§ngt. </p><br><p>  Ein in JavaBean deklarierter Getter ist eine Methode namens <code>getXXX</code> ohne Parameter und mit einem anderen R√ºckgabedatentyp als <code>void</code> .  Ein in JavaBean deklarierter Setter ist eine Methode namens <code>setXXX</code> mit einem Parameter und der R√ºckgabe von <code>void</code> .  Diese beiden Notationen k√∂nnen als funktionale Schnittstellen dargestellt werden: </p><br><ul><li>  Getter kann durch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Function-</a> Klasse dargestellt werden, in der das Argument der Wert <code>this</code> . </li><li>  Setter kann durch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BiConsumer-</a> Klasse dargestellt werden, in der das erste Argument <code>this</code> ist und das zweite der Wert, der an Setter √ºbergeben wird. </li></ul><br><p>  Jetzt werden wir zwei Methoden erstellen, die jeden Getter oder Setter in diese konvertieren k√∂nnen <br>  funktionale Schnittstellen.  Dabei spielt es keine Rolle, dass beide Schnittstellen generisch sind.  Nach dem L√∂schen von Typen <br>  Der reale Datentyp ist <code>Object</code> .  Das automatische <code>LambdaMetafactory</code> von R√ºckgabetyp und Argumenten kann mit <code>LambdaMetafactory</code> .  Dar√ºber hinaus hilft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Guava-Bibliothek</a> beim Zwischenspeichern von Lambda-Ausdr√ºcken f√ºr dieselben Getter und Setter. </p><br><p>  Erster Schritt: Erstellen Sie einen Cache f√ºr Getter und Setter.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Method-</a> Klasse der Reflection-API stellt einen echten Getter oder Setter dar und wird als Schl√ºssel verwendet. <br>  Der Cache-Wert ist eine dynamisch aufgebaute Funktionsschnittstelle f√ºr einen bestimmten Getter oder Setter. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Cache&lt;Method, Function&gt; GETTERS = CacheBuilder.newBuilder().weakValues().build(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Cache&lt;Method, BiConsumer&gt; SETTERS = CacheBuilder.newBuilder().weakValues().build();</code> </pre> <br><p>  Zweitens werden wir Factory-Methoden erstellen, die eine Instanz der Funktionsschnittstelle basierend auf Verweisen auf Getter oder Setter erstellen. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodHandles.Lookup lookup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodHandle getter)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CallSite site = LambdaMetafactory.metafactory(lookup, <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, MethodType.methodType(Function.class), MethodType.methodType(Object.class, Object.class), <span class="hljs-comment"><span class="hljs-comment">//signature of method Function.apply after type erasure getter, getter.type()); //actual signature of getter try { return (Function) site.getTarget().invokeExact(); } catch (final Exception e) { throw e; } catch (final Throwable e) { throw new Error(e); } } private static BiConsumer createSetter(final MethodHandles.Lookup lookup, final MethodHandle setter) throws Exception { final CallSite site = LambdaMetafactory.metafactory(lookup, "accept", MethodType.methodType(BiConsumer.class), MethodType.methodType(void.class, Object.class, Object.class), //signature of method BiConsumer.accept after type erasure setter, setter.type()); //actual signature of setter try { return (BiConsumer) site.getTarget().invokeExact(); } catch (final Exception e) { throw e; } catch (final Throwable e) { throw new Error(e); } }</span></span></code> </pre> <br><p>  Die automatische Typkonvertierung zwischen Argumenten vom Typ <code>Object</code> in funktionalen Schnittstellen (nach dem L√∂schen des Typs) und realen Argumenttypen und dem R√ºckgabewert wird unter Verwendung der Differenz zwischen <code>samMethodType</code> und <code>instantiatedMethodType</code> (dem dritten bzw. f√ºnften Argument der metafactory-Methode) erreicht.  Der Typ der erstellten Instanz der Methode - dies ist die Spezialisierung der Methode, die die Implementierung des Lambda-Ausdrucks bereitstellt. </p><br><p>  Drittens werden wir eine Fassade f√ºr diese Fabriken mit Unterst√ºtzung f√ºr das Caching erstellen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reflectGetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodHandles.Lookup lookup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method getter)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GETTERS.get(getter, () -&gt; createGetter(lookup, lookup.unreflect(getter))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutionException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReflectiveOperationException(e.getCause()); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BiConsumer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reflectSetter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodHandles.Lookup lookup, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Method setter)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SETTERS.get(setter, () -&gt; createSetter(lookup, lookup.unreflect(setter))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutionException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReflectiveOperationException(e.getCause()); } }</code> </pre> <br><p>  Methodeninformationen, die von einer Instanz der <code>Method</code> Klasse mithilfe der Java Reflection-API abgerufen wurden, k√∂nnen problemlos in ein <code>MethodHandle</code> konvertiert werden.  Beachten Sie, dass Klasseninstanzmethoden immer ein verstecktes erstes Argument haben, mit dem <code>this</code> an diese Methode √ºbergeben wird.  Statische Methoden haben keinen solchen Parameter.  Beispielsweise sieht die tats√§chliche Signatur der Methode <code>Integer.intValue()</code> wie <code>int intValue(Integer this)</code> .  Dieser Trick wird bei der Implementierung von funktionalen Wrappern f√ºr Getter und Setter verwendet. </p><br><p>  Und jetzt ist es Zeit, den Code zu testen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Date d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiConsumer&lt;Date, Long&gt; timeSetter = reflectSetter(MethodHandles.lookup(), Date.class.getDeclaredMethod(<span class="hljs-string"><span class="hljs-string">"setTime"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>.class)); timeSetter.accept(d, <span class="hljs-number"><span class="hljs-number">42L</span></span>); <span class="hljs-comment"><span class="hljs-comment">//the same as d.setTime(42L); final Function&lt;Date, Long&gt; timeGetter = reflectGetter(MethodHandles.lookup(), Date.class.getDeclaredMethod("getTime")); System.out.println(timeGetter.apply(d)); //the same as d.getTime() //output is 42</span></span></code> </pre> <br><p>  Dieser Ansatz mit zwischengespeicherten Gettern und Setzern kann effektiv in Serialisierungs- / Deserialisierungsbibliotheken (wie Jackson) verwendet werden, die Getter und Setter w√§hrend der Serialisierung und Deserialisierung verwenden. </p><br><hr><br><p>  <strong>Das Aufrufen von Funktionsschnittstellen mit dynamisch generierten Implementierungen mit <code>LambdaMetaFactory</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erheblich schneller</a> als das Aufrufen √ºber die Java Reflection-API</strong> </p><br><hr><br><p>  Die Vollversion des Codes finden Sie <a href="">hier</a> , sie ist Teil der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SNAMP-</a> Bibliothek. </p><br><h2 id="ogranicheniya-i-bagi">  Einschr√§nkungen und Fehler </h2><br><p>  In diesem Abschnitt werden einige Fehler und Einschr√§nkungen im Zusammenhang mit Lambda-Ausdr√ºcken im Java-Compiler und in der JVM erl√§utert.  Alle diese Einschr√§nkungen k√∂nnen in OpenJDK und Oracle JDK mit <code>javac</code> Version 1.8.0_131 f√ºr Windows und Linux reproduziert werden. </p><br><h3 id="sozdanie-lyambda-vyrazheniy-iz-obrabotchikov-metodov">  Erstellen von Lambda-Ausdr√ºcken aus Methodenhandlern </h3><br><p>  Wie Sie wissen, kann ein Lambda-Ausdruck mithilfe von <code>LambdaMetaFactory</code> dynamisch <code>LambdaMetaFactory</code> .  Dazu m√ºssen Sie einen Handler definieren - die <code>MethodHandle</code> Klasse, die die Implementierung der einzigen Methode angibt, die in der Funktionsschnittstelle definiert ist.  Schauen wir uns dieses einfache Beispiel an: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestClass</span></span></span><span class="hljs-class"> </span></span>{ String value = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TestClass obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestClass(); obj.setValue(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MethodHandles.Lookup lookup = MethodHandles.lookup(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CallSite site = LambdaMetafactory.metafactory(lookup, <span class="hljs-string"><span class="hljs-string">"get"</span></span>, MethodType.methodType(Supplier.class, TestClass.class), MethodType.methodType(Object.class), lookup.findVirtual(TestClass.class, <span class="hljs-string"><span class="hljs-string">"getValue"</span></span>, MethodType.methodType(String.class)), MethodType.methodType(String.class)); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Supplier&lt;String&gt; getter = (Supplier&lt;String&gt;) site.getTarget().invokeExact(obj); System.out.println(getter.get());</code> </pre> <br><p>  Dieser Code entspricht: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TestClass obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestClass(); obj.setValue(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Supplier&lt;String&gt; elementGetter = () -&gt; obj.getValue(); System.out.println(elementGetter.get());</code> </pre> <br><p>  Was aber, wenn wir den Methodenhandler, der auf <code>getValue</code> durch den Handler ersetzen, den die Getterfelder darstellen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CallSite site = LambdaMetafactory.metafactory(lookup, <span class="hljs-string"><span class="hljs-string">"get"</span></span>, MethodType.methodType(Supplier.class, TestClass.class), MethodType.methodType(Object.class), lookup.findGetter(TestClass.class, <span class="hljs-string"><span class="hljs-string">"value"</span></span>, String.class), <span class="hljs-comment"><span class="hljs-comment">//field getter instead of method handle to getValue MethodType.methodType(String.class));</span></span></code> </pre> <br><p>  Dieser Code sollte wie erwartet funktionieren, da <code>findGetter</code> einen Handler zur√ºckgibt, der auf die <code>findGetter</code> verweist und die richtige Signatur hat.  Wenn Sie diesen Code ausf√ºhren, wird jedoch die folgende Ausnahme angezeigt: </p><br><pre> <code class="plaintext hljs">java.lang.invoke.LambdaConversionException: Unsupported MethodHandle kind: getField</code> </pre> <br><p>  Interessanterweise funktioniert der Getter f√ºr das Feld <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einwandfrei,</a> wenn wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MethodHandleProxies verwenden</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Supplier&lt;String&gt; getter = MethodHandleProxies .asInterfaceInstance(Supplier.class, lookup.findGetter(TestClass.class, <span class="hljs-string"><span class="hljs-string">"value"</span></span>, String.class) .bindTo(obj));</code> </pre> <br><p>  Es ist zu beachten, dass <code>MethodHandleProxies</code> keine gute M√∂glichkeit ist, Lambda-Ausdr√ºcke dynamisch zu erstellen, da diese Klasse <code>MethodHandle</code> einfach in eine Proxy-Klasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einschlie√üt</a> und invocationHandler.invoke an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MethodHandle.invokeWithArguments delegiert</a> .  Dieser Ansatz verwendet Java Reflection und ist sehr langsam. </p><br><p>  Wie bereits gezeigt, k√∂nnen nicht alle Methodenhandler zur Laufzeit zum Erstellen von Lambda-Ausdr√ºcken verwendet werden. </p><br><hr><br><p>  <strong>Es k√∂nnen nur wenige Arten von Methodenhandlern verwendet werden, um Lambda-Ausdr√ºcke dynamisch zu erstellen.</strong> </p><br><hr><br><p>  Hier sind sie: </p><br><ul><li>  REF_invokeInterface: Kann mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lookup.findVirtual</a> f√ºr Schnittstellenmethoden erstellt werden </li><li>  REF_invokeVirtual: Kann mit Lookup.findVirtual f√ºr virtuelle Methoden der Klasse erstellt werden </li><li>  REF_invokeStatic: Erstellt mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lookup.findStatic</a> f√ºr statische Methoden </li><li>  REF_newInvokeSpecial: Kann mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lookup.findConstructor</a> f√ºr Konstruktoren erstellt werden </li><li>  REF_invokeSpecial: Kann mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lookup.findSpecial</a> erstellt werden <br>  f√ºr private Methoden und fr√ºhzeitiges Binden mit virtuellen Methoden der Klasse </li></ul><br><p>  Andere Arten von <code>LambdaConversionException</code> Fehler aus. </p><br><h3 id="generic-isklyucheniya">  Allgemeine Ausnahmen </h3><br><p>  Dieser Fehler h√§ngt mit dem Java-Compiler und der M√∂glichkeit zusammen, generische Ausnahmen im Abschnitt " <code>throws</code> zu deklarieren.  Das folgende Codebeispiel veranschaulicht dieses Verhalten: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExtendedCallable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-function">V </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> E</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExtendedCallable&lt;URL, MalformedURLException&gt; urlFactory = () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(<span class="hljs-string"><span class="hljs-string">"http://localhost"</span></span>); urlFactory.call();</code> </pre> <br><p>  Dieser Code muss kompiliert werden, da der Konstruktor der <code>URL</code> Klasse eine <code>MalformedURLException</code> .  Aber es wird nicht kompiliert.  Die folgende Fehlermeldung wird angezeigt: </p><br><pre> <code class="plaintext hljs">Error:(46, 73) java: call() in &lt;anonymous Test$CODEgt; cannot implement call() in ExtendedCallable overridden method does not throw java.lang.Exception</code> </pre> <br><p>  Wenn wir jedoch den Lambda-Ausdruck durch eine anonyme Klasse ersetzen, wird der Code kompiliert: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExtendedCallable&lt;URL, MalformedURLException&gt; urlFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExtendedCallable&lt;URL, MalformedURLException&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> URL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> MalformedURLException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(<span class="hljs-string"><span class="hljs-string">"http://localhost"</span></span>); } }; urlFactory.call();</code> </pre> <br><p>  Daraus folgt: </p><br><hr><br><p>  <strong>Die Typinferenz f√ºr generische Ausnahmen funktioniert in Kombination mit Lambda-Ausdr√ºcken nicht richtig</strong> </p><br><hr><br><h3 id="ogranicheniya-tipov-parametrizacii">  Einschr√§nkungen des Parametrisierungstyps </h3><br><p>  Mit dem Zeichen <code>&amp;</code> : <code>&lt;T extends A &amp; B &amp; C &amp; ... Z&gt;</code> k√∂nnen Sie ein generisches Objekt mit verschiedenen <code>&lt;T extends A &amp; B &amp; C &amp; ... Z&gt;</code> erstellen. <br>  Diese Methode zur Bestimmung generischer Parameter wird selten verwendet, wirkt sich jedoch aufgrund einiger Einschr√§nkungen in gewisser Weise auf Lambda-Ausdr√ºcke in Java aus: </p><br><ul><li>  Jede Typeinschr√§nkung mit Ausnahme der ersten muss eine Schnittstelle sein. </li><li>  Eine reine Version einer Klasse mit einem solchen generischen Wert ber√ºcksichtigt nur die erste Typbeschr√§nkung aus der Liste. </li></ul><br><p>  Die zweite Einschr√§nkung f√ºhrt zu unterschiedlichen Verhaltensweisen des Codes zur Kompilierungszeit und zur Laufzeit, wenn eine Bindung an den Lambda-Ausdruck auftritt.  Dieser Unterschied kann mit dem folgenden Code demonstriert werden: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutableInteger</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntSupplier</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//mutable container of int value private int value; public MutableInteger(final int v) { value = v; } @Override public int intValue() { return value; } @Override public long longValue() { return value; } @Override public float floatValue() { return value; } @Override public double doubleValue() { return value; } @Override public int getAsInt() { return intValue(); } @Override public void accept(final int value) { this.value = value; } } static &lt;T extends Number &amp; IntSupplier&gt; OptionalInt findMinValue(final Collection &lt;T&gt; values) { return values.stream().mapToInt(IntSupplier::getAsInt).min(); } final List &lt;MutableInteger&gt; values = Arrays.asList(new MutableInteger(10), new MutableInteger(20)); final int mv = findMinValue(values).orElse(Integer.MIN_VALUE); System.out.println(mv);</span></span></code> </pre> <br><p>  Dieser Code ist absolut korrekt und wird erfolgreich kompiliert.  Die <code>MutableInteger</code> Klasse erf√ºllt die Einschr√§nkungen des generischen Typs T: </p><br><ul><li>  <code>MutableInteger</code> erbt von <code>Number</code> . </li><li>  <code>MutableInteger</code> implementiert <code>IntSupplier</code> . </li></ul><br><p>  Der Code st√ºrzt jedoch mit einer Ausnahme zur Laufzeit ab: </p><br><pre> <code class="java hljs">java.lang.BootstrapMethodError: call site initialization exception at java.lang.invoke.CallSite.makeSite(CallSite.java:<span class="hljs-number"><span class="hljs-number">341</span></span>) at java.lang.invoke.MethodHandleNatives.linkCallSiteImpl(MethodHandleNatives.java:<span class="hljs-number"><span class="hljs-number">307</span></span>) at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:<span class="hljs-number"><span class="hljs-number">297</span></span>) at Test.minValue(Test.java:<span class="hljs-number"><span class="hljs-number">77</span></span>) Caused by: java.lang.invoke.LambdaConversionException: Invalid receiver type <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span></span>; not a subtype of implementation type <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">util</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntSupplier</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">at</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoke</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractValidatingLambdaMetafactory</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">validateMetafactoryArgs</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractValidatingLambdaMetafactory</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">:233) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">at</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoke</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaMetafactory</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">metafactory</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaMetafactory</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">:303) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">at</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoke</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallSite</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">makeSite</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallSite</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">:302)</span></span></code> </pre> <br><p>  Dies liegt daran, dass die JavaStream-Pipeline nur einen reinen Typ erfasst, in unserem Fall die <code>Number</code> Klasse, und die <code>IntSupplier</code> Schnittstelle nicht implementiert.  Dieses Problem kann behoben werden, indem der Parametertyp explizit in einer separaten Methode deklariert wird, die als Referenz auf die Methode verwendet wird: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntSupplier i)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i.getAsInt(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T extends Number &amp; IntSupplier&gt; <span class="hljs-function"><span class="hljs-function">OptionalInt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findMinValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Collection&lt;T&gt; values)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values.stream().mapToInt(UtilsTest::getInt).min(); }</code> </pre> <br><p>  Dieses Beispiel zeigt eine falsche Typinferenz im Compiler und zur Laufzeit. </p><br><hr><br><p>  <strong>Die Behandlung mehrerer generischer Einschr√§nkungen f√ºr Parametertypen in Verbindung mit der Verwendung von Lambda-Ausdr√ºcken zur Kompilierungszeit und zur Laufzeit ist nicht konsistent</strong> </p><br><hr></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432418/">https://habr.com/ru/post/de432418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432408/index.html">Fintech Digest: Vorbereitung f√ºr die Trennung kleiner Banken von Visa und Mastercard, einem Rentenrechner und nicht nur</a></li>
<li><a href="../de432410/index.html">Entit√§ten im DDD-Stil mit Entity Framework Core</a></li>
<li><a href="../de432412/index.html">Highload ++: So helfen Sie dem ERP-System, 500.000 Anfragen pro Sekunde zu bew√§ltigen</a></li>
<li><a href="../de432414/index.html">Alte Geheimnisse f√ºr schnelles Debuggen: Animieren des Quellcodes</a></li>
<li><a href="../de432416/index.html">Abh√§ngige Typen - Die Zukunft der Programmiersprachen</a></li>
<li><a href="../de432420/index.html">Einf√ºhrung in Git Merge und Git Rebase: Warum und wann sie verwendet werden sollen</a></li>
<li><a href="../de432422/index.html">Offline-Modus unter iOS und Funktionen seiner Implementierung unter Realm</a></li>
<li><a href="../de432424/index.html">HyperFlex Certified Infrastructure f√ºr SAP HANA</a></li>
<li><a href="../de432426/index.html">Debuggen eines Fehlers, der nicht abgespielt wird</a></li>
<li><a href="../de432428/index.html">Zentraler Bus gegen Service Mesh: Wie man einen Mitap in eine Schlacht verwandelt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>