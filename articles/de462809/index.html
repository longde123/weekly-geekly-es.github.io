<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ üíÜüèª üõÄüèº WinForms: Fehler, Holmes üññüèº ‚òùüèø üî≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir suchen gerne nach Fehlern in Microsoft-Projekten. Warum? Es ist ganz einfach: Ihre Projekte sind normalerweise leicht zu √ºberpr√ºfen (Sie k√∂nnen in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WinForms: Fehler, Holmes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/462809/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/aeb/a84/71baeba847a8865aef0cc8148effbb8c.png" alt="Bild 5"></div><br>  Wir suchen gerne nach Fehlern in Microsoft-Projekten.  Warum?  Es ist ganz einfach: Ihre Projekte sind normalerweise leicht zu √ºberpr√ºfen (Sie k√∂nnen in einer Visual Studio-Umgebung arbeiten, f√ºr die PVS-Studio ein praktisches Plugin hat) und sie enthalten nur wenige Fehler.  Aus diesem Grund lautet der √ºbliche Arbeitsalgorithmus wie folgt: Suchen und Herunterladen eines Open Source-Projekts von MS;  √ºberpr√ºfe es;  w√§hle interessante Fehler;  Stellen Sie sicher, dass es nur wenige davon gibt.  Schreiben Sie einen Artikel, ohne zu vergessen, die Entwickler zu loben.  Gro√üartig!  Win-Win-Win: Es hat ein wenig gedauert, die Chefs sind froh, neue Materialien im Blog zu sehen, und Karma ist in Ordnung.  Aber diesmal "ging etwas schief".  Mal sehen, was wir im Quellcode von Windows Forms gefunden haben und ob wir diesmal hoch √ºber Microsoft sprechen sollten. <br><a name="habracut"></a><br>  <b>Einf√ºhrung</b> <br><br>  Anfang Dezember 2018 k√ºndigte Microsoft die Ver√∂ffentlichung von .NET Core 3 Preview 1 an. Etwas fr√ºher (etwa Mitte Oktober) begann GitHub, die Quellen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows Forms</a> - der .NET Core UI-Plattform zum Erstellen von Windows-Desktopanwendungen - aktiv offenzulegen .  Sie k√∂nnen die Commit-Statistiken <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier sehen</a> .  Jetzt kann jeder den WinForms-Quellcode zur √úberpr√ºfung herunterladen. <br><br>  Ich habe auch die Quellen heruntergeladen, um dort mit PVS-Studio nach Fehlern zu suchen.  Die √úberpr√ºfung verursachte keine Schwierigkeiten.  Wir brauchten: Visual Studio 2019, .NET Core 3.0 SDK-Vorschau, PVS-Studio.  Und hier haben wir das Protokoll der Warnungen des Analysators. <br><br>  Nachdem ich den PVS-Studio-Bericht erhalten habe, sortiere ich ihn normalerweise nach Diagnosenummern in aufsteigender Reihenfolge (das Fenster mit dem PVS-Studio-Nachrichtenprotokoll in der Visual Studio-Umgebung bietet verschiedene Optionen zum Sortieren und Filtern der Liste).  Sie k√∂nnen mit Gruppen √§hnlicher Fehler arbeiten, was die Quellcode-Analyse erheblich vereinfacht.  Ich markiere interessante Fehler in der Liste mit einem "Stern" und erst dann, nachdem ich das gesamte Protokoll analysiert habe, schreibe ich Codefragmente aus und beschreibe sie.  Da es normalerweise nur wenige Fehler gibt, "r√ºhre" ich sie und versuche, die interessantesten am Anfang und Ende des Artikels zu platzieren.  Aber diesmal stellte sich heraus, dass es viele Fehler gab (eh, die Intrige wurde schon lange nicht mehr gespeichert), und ich werde sie in der Reihenfolge der Anzahl der Diagnosen zitieren. <br><br>  Was haben wir gefunden?  833 hohe und mittlere Warnungen (249 bzw. 584) wurden f√ºr 540.000 Codezeilen (ohne leere) in 1670 cs-Dateien ausgegeben.  Und ja, traditionell habe ich die Tests nicht √ºberpr√ºft und die niedrigen Warnungen nicht ber√ºcksichtigt (es gab 215 davon).  Nach meinen fr√ºheren Beobachtungen sind die Warnungen f√ºr das MS-Projekt zu viele.  Aber nicht alle Warnungen sind Fehler. <br><br>  F√ºr dieses Projekt betrug die Anzahl der Fehlalarme etwa 30%.  In etwa 20% der F√§lle konnte ich einfach keine genaue Schlussfolgerung ziehen, ob es sich um einen Fehler handelte oder nicht, da ich mit dem Code nicht gut genug vertraut war.  Und mindestens 20% der Fehler, die ich verpasst habe, k√∂nnen als "menschlicher Faktor" abgeschrieben werden: Eile, M√ºdigkeit usw.  √úbrigens ist auch der gegenteilige Effekt m√∂glich: Bei einigen Triggern des gleichen Typs, deren Anzahl 70-80 erreichen k√∂nnte, habe ich "vorletzter" gesucht, was manchmal die Anzahl der Fehler erh√∂hen k√∂nnte, die ich f√ºr real hielt. <br><br>  Auf jeden Fall weisen 30% der Warnungen auf echte Fehler hin. Dies ist ein ziemlich gro√üer Prozentsatz, wenn Sie ber√ºcksichtigen, dass der Analysator nicht vorkonfiguriert war. <br><br>  Die Anzahl der Fehler, die ich gefunden habe, betrug ungef√§hr 240, was im Bereich der angegebenen Statistiken liegt.  Meiner Meinung nach ist dies nicht das herausragendste Ergebnis f√ºr ein MS-Projekt (obwohl es nur 0,44 Fehler pro 1000 Codezeilen macht), und es gibt wahrscheinlich auch mehr echte Fehler im WinForms-Code.  Ich schlage vor, die Gr√ºnde am Ende des Artikels zu ber√ºcksichtigen und nun die interessantesten Fehler zu sehen. <br><br>  <b>Fehler</b> <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3003</a> Die Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Musters</a> 'if (A) {...} else if (A) {...}' wurde erkannt.  Es besteht die Wahrscheinlichkeit eines logischen Fehlers.  √úberpr√ºfen Sie die Zeilen: 213, 224. ButtonStandardAdapter.cs 213 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PaintWorker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PaintEventArgs e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> up, CheckState state)</span></span></span><span class="hljs-function"> </span></span>{ up = up &amp;&amp; state == CheckState.Unchecked; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } .... }</code> </pre> <br>  <i>Wenn</i> und <i>sonst wenn</i> Bl√∂cke den gleichen Zustand pr√ºfen.  Es sieht aus wie Kopieren und Einf√ºgen.  Ist es ein Fehler?  Wenn Sie sich die Deklaration der <i>IsHighContrastHighlighted-</i> Methode <i>ansehen</i> , k√∂nnen Sie dies bezweifeln: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsHighContrastHighlighted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SystemInformation.HighContrast &amp;&amp; Application.RenderWithVisualStyles &amp;&amp; (Control.Focused || Control.MouseIsOver || (Control.IsDefault &amp;&amp; Control.Enabled)); }</code> </pre> <br>  Die Methode kann wahrscheinlich unterschiedliche Werte f√ºr sequentielle Aufrufe zur√ºckgeben.  Und was in der Aufrufermethode passiert, sieht nat√ºrlich seltsam aus, hat aber das Recht zu existieren.  Ich w√ºrde den Autoren jedoch raten, sich dieses Codefragment anzusehen.  Nur f√ºr den Fall.  Es ist auch ein gutes Beispiel daf√ºr, wie schwierig es ist, bei der Analyse von unbekanntem Code Schlussfolgerungen zu ziehen. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3004</a> Die Anweisung 'then' entspricht der Anweisung 'else'.  RichTextBox.cs 1018 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SelectionCharOffset { get { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> selCharOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... NativeMethods.CHARFORMATA cf = GetCharFormat(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if the effects member contains valid info if ((cf.dwMask &amp; RichTextBoxConstants.CFM_OFFSET) != 0) { selCharOffset = cf.yOffset; // &lt;= } else { // The selection contains characters of different offsets, // so we just return the offset of the first character. selCharOffset = cf.yOffset; // &lt;= } .... } .... }</span></span></code> </pre> <br>  Und hier gibt es definitiv einen Fehler beim Kopieren und Einf√ºgen.  Unabh√§ngig von der Bedingung <i>erh√§lt die</i> Variable <i>selCharOffset</i> immer den gleichen Wert. <br><br>  Es gibt zwei weitere solche Fehler im WinForms-Code: <ul><li>  V3004 Die Anweisung 'then' entspricht der Anweisung 'else'.  SplitContainer.cs 1700 </li><li>  V3004 Die Anweisung 'then' entspricht der Anweisung 'else'.  ToolstripProfessionalRenderer.cs 371 </li></ul><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3008</a> Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 681, 680. ProfessionalColorTable.cs 681 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitSystemColors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Dictionary&lt;KnownColors, Color&gt; rgbTable)</span></span></span><span class="hljs-function"> </span></span>{ .... rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonFace; rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonShadow; .... }</code> </pre> <br>  Die Methode f√ºllt das <i>rgbTable-</i> W√∂rterbuch.  Der Analysator zeigte auf ein Codefragment, bei dem verschiedene Werte nacheinander zweimal auf denselben Schl√ºssel geschrieben werden.  Die Dinge w√§ren in Ordnung, aber es gibt immer noch 16 solcher Fragmente in dieser Methode.  Es sieht nicht mehr nach einem einzigartigen Fehler aus.  Aber warum sie das tun, bleibt mir ein R√§tsel.  Ich habe keine Anzeichen von automatisch generiertem Code gefunden.  Im Editor sieht es so aus: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/006/f68/827/006f688275da3701f28abe7918835ce9.png" alt="Bild 3"></div><br>  Ich gebe Ihnen die ersten zehn Warnungen auf der Liste: <br><br><ol><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 785, 784. ProfessionalColorTable.cs 785 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 787, 786. ProfessionalColorTable.cs 787 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 789, 788. ProfessionalColorTable.cs 789 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 791, 790. ProfessionalColorTable.cs 791 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 797, 796. ProfessionalColorTable.cs 797 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 799, 798. ProfessionalColorTable.cs 799 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 807, 806. ProfessionalColorTable.cs 807 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 815, 814. ProfessionalColorTable.cs 815 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 817, 816. ProfessionalColorTable.cs 817 </li><li>  V3008 Der Variablen werden zweimal hintereinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 823, 822. ProfessionalColorTable.cs 823 </li></ol><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3011</a> Es wurden zwei entgegengesetzte Bedingungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">festgestellt</a> .  Die zweite Bedingung ist immer falsch.  √úberpr√ºfen Sie die Zeilen: 5242, 5240. DataGrid.cs 5242 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckHierarchyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (checkHierarchy &amp;&amp; listManager != null &amp;&amp; myGridTable != null) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myGridTable == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { // there was nothing to check return; } for (int j = 0; j &lt; myGridTable.GridColumnStyles.Count; j++) { DataGridColumnStyle gridColumn = myGridTable.GridColumnStyles[j]; } checkHierarchy = false; } }</span></span></code> </pre> <br>  Der <i>R√ºckgabeoperator</i> wird niemals ausgef√ºhrt.  H√∂chstwahrscheinlich ist die Bedingung <i>myGridTable! = Null</i> im externen <i>if-</i> Block sp√§ter w√§hrend des Refactorings hinzugef√ºgt worden.  Und jetzt ist die √úberpr√ºfung von <i>myGridTable == null</i> bedeutungslos.  Um die Codequalit√§t zu verbessern, sollten Sie diese Pr√ºfung entfernen. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3019</a> M√∂glicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schl√ºsselwort 'as' mit null verglichen.  √úberpr√ºfen Sie die Variablen 'left', 'cscLeft'.  TypeCodeDomSerializer.cs 611 <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3019</a> M√∂glicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schl√ºsselwort 'as' mit null verglichen.  √úberpr√ºfen Sie die Variablen 'right', 'cscRight'.  TypeCodeDomSerializer.cs 615 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object left, object right)</span></span></span><span class="hljs-function"> </span></span>{ OrderedCodeStatementCollection cscLeft = left as OrderedCodeStatementCollection; OrderedCodeStatementCollection cscRight = right as OrderedCodeStatementCollection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == left) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cscLeft.Order - cscRight.Order; <span class="hljs-comment"><span class="hljs-comment">// &lt;= }</span></span></code> </pre> <br>  Der Analysator hat gleichzeitig zwei Warnungen f√ºr die <i>Vergleichsmethode</i> generiert.  Was ist das Problem?  Es ist so, dass die Werte f√ºr <i>cscLeft</i> und <i>cscRight</i> √ºberhaupt nicht auf <i>Null</i> gepr√ºft werden.  Sie erhalten diesen Wert m√∂glicherweise nach erfolglosem <i>Umwandeln</i> in den <i>OrderedCodeStatementCollection-</i> Typ.  Dann wird im letzten <i>R√ºckgabeausdruck</i> eine Ausnahme ausgel√∂st.  Diese Situation ist m√∂glich, wenn alle Pr√ºfungen f√ºr <i>links</i> und <i>rechts</i> bestanden sind und nicht zu einem vorl√§ufigen Verlassen der Methode f√ºhren. <br><br>  Um den Code zu <i>korrigieren</i> , sollten Sie √ºberall <i>cscLeft / cscRight</i> anstelle von <i>left / right verwenden</i> . <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3020</a> Eine bedingungslose Unterbrechung innerhalb einer Schleife.  SelectionService.cs 421 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISelectionService.SetSelectedComponents( ICollection components, SelectionTypes selectionType) { .... <span class="hljs-comment"><span class="hljs-comment">// Handle the click case object requestedPrimary = null; int primaryIndex; if (fPrimary &amp;&amp; 1 == components.Count) { foreach (object o in components) { requestedPrimary = o; if (o == null) { throw new ArgumentNullException(nameof(components)); } break; } } .... }</span></span></code> </pre> <br>  Dieses Fragment bezieht sich eher auf den "Code-Geruch".  Hier liegt kein Fehler vor.  Es stellen sich jedoch Fragen zur Organisation der <i>foreach-</i> Schleife.  Es ist klar, warum es hier ben√∂tigt wird: weil Elemente der Sammlung extrahiert werden m√ºssen, die als <i>ICollection √ºbergeben wurden</i> .  Aber warum ben√∂tigte die Schleife, die urspr√ºnglich f√ºr eine einzelne Iteration konzipiert war (Voraussetzung ist das Vorhandensein eines einzelnen Elements in den Auflistungskomponenten), zus√§tzliche Unterst√ºtzung, z. B. <i>break</i> ?  Wahrscheinlich kann die Antwort wie folgt betrachtet werden: "Historisch gesehen ist dies geschehen."  Der Code sieht h√§sslich aus. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022</a> Ausdruck 'ocxState! = Null' ist immer wahr.  AxHost.cs 2186 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State OcxState { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... ocxState = value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ocxState != null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { axState[manualUpdate] = ocxState._GetManualUpdate(); licenseKey = ocxState._GetLicenseKey(); } else { axState[manualUpdate] = false; licenseKey = null; } .... } }</span></span></code> </pre> <br>  Aufgrund eines logischen Fehlers ist in diesem Fragment "toter Code" aufgetreten.  Ausdr√ºcke im <i>else-</i> Block werden niemals ausgef√ºhrt. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3027</a> Die Variable 'e' wurde im logischen Ausdruck verwendet, bevor sie im gleichen logischen Ausdruck gegen null verifiziert wurde.  ImageEditor.cs 99 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... ImageEditor e = ....; Type myClass = GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!myClass.Equals(e.GetType()) &amp;&amp; e != null &amp;&amp; myClass.IsInstanceOfType(e)) { .... } .... }</code> </pre> <br>  Die Variable <i>e</i> in der Bedingung wird zuerst verwendet und dann gegen <i>Null</i> gepr√ºft.  Hallo, <i>NullReferenceException</i> . <br><br>  Noch ein solcher Fehler: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3027</a> Die Variable 'dropDownItem' wurde im logischen Ausdruck verwendet, bevor sie im selben logischen Ausdruck gegen null verifiziert wurde.  ToolStripMenuItemDesigner.cs 1351 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterInSituEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ToolStripItem toolItem)</span></span></span><span class="hljs-function"> </span></span>{ .... ToolStripDropDownItem dropDownItem = toolItem as ToolStripDropDownItem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(dropDownItem.Owner is ToolStripDropDownMenu) &amp;&amp; dropDownItem != null &amp;&amp; dropDownItem.Bounds.Width &lt; commitedEditorNode.Bounds.Width) { .... } .... }</code> </pre> <br>  Die Situation ist √§hnlich wie in der vorherigen, jedoch mit der Variablen <i>dropDownItem</i> .  Ich denke, dass solche Fehler auf unachtsames Refactoring zur√ºckzuf√ºhren sind.  Wahrscheinlich wurde sp√§ter ein Teil der Bedingung <i>(DropDownItem.Owner ist ToolStripDropDownMenu)</i> in den Code eingef√ºgt. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3030</a> Wiederkehrende Pr√ºfung.  Die Bedingung 'columnCount&gt; 0' wurde bereits in Zeile 3900 √ºberpr√ºft. ListView.cs 3903 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal ColumnHeader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, ColumnHeader ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> refreshSubItems)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Add the column to our internal array int columnCount = (columnHeaders == null ? 0 : columnHeaders.Length); if (columnCount &gt; 0) { ColumnHeader[] newHeaders = new ColumnHeader[columnCount + 1]; if (columnCount &gt; 0) { System.Array.Copy(columnHeaders, 0, newHeaders, 0, columnCount); } .... } .... }</span></span></code> </pre> <br>  Ein Fehler, der harmlos erscheinen mag.  In der Tat wird eine unn√∂tige Pr√ºfung durchgef√ºhrt, die die Betriebslogik nicht beeinflusst.  Und manchmal geschieht dies sogar, wenn Sie den Status einer visuellen Komponente erneut √ºberpr√ºfen m√ºssen, z. B. um die Anzahl der Eintr√§ge in der Liste abzurufen.  In diesem Fall wird die <i>lokale</i> Variable <i>columnCount</i> jedoch zweimal √ºberpr√ºft.  Es ist sehr verd√§chtig.  Entweder wollten sie eine andere Variable pr√ºfen oder sie haben bei einer der Pr√ºfungen eine falsche Bedingung verwendet. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3061 Der</a> Parameter 'lprcClipRect' wird vor seiner Verwendung immer im Methodenk√∂rper neu geschrieben.  WebBrowserSiteBase.cs 281 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UnsafeNativeMethods.IOleInPlaceSite.GetWindowContext( out UnsafeNativeMethods.IOleInPlaceFrame ppFrame, out UnsafeNativeMethods.IOleInPlaceUIWindow ppDoc, NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect, NativeMethods.tagOIFI lpFrameInfo) { ppDoc = null; ppFrame = Host.GetParentContainer(); lprcPosRect.left = Host.Bounds.X; lprcPosRect.top = Host.Bounds.Y; .... lprcClipRect = WebBrowserHelper.GetClipRect(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (lpFrameInfo != null) { lpFrameInfo.cb = Marshal.SizeOf&lt;NativeMethods.tagOIFI&gt;(); lpFrameInfo.fMDIApp = false; .... } return NativeMethods.S_OK; }</span></span></code> </pre> <br>  Ein offensichtlicher Fehler.  Ja, der Parameter <i>lprcClipRect</i> wird tats√§chlich mit einem neuen Wert initialisiert, ohne ihn in irgendeiner Weise zu verwenden.  Aber wozu f√ºhrt es am Ende?  Ich denke, dass irgendwo im aufrufenden Code die durch diesen Parameter √ºbergebene Referenz unver√§ndert bleibt, obwohl dies nicht beabsichtigt war.  Sch√§tzen Sie wirklich den Umgang mit anderen Variablen in dieser Methode.  Sogar der Name (Pr√§fix "Get") weist darauf hin, dass eine Initialisierung innerhalb der Methode √ºber √ºbergebene Parameter durchgef√ºhrt wird.  Und so ist es auch.  Die ersten beiden Parameter ( <i>ppFrame</i> und <i>ppDoc</i> ) werden mit dem Modifikator <i>out √ºbergeben</i> und erhalten neue Werte.  Die Referenzen <i>lprcPosRect</i> und <i>lpFrameInfo</i> werden verwendet, um auf Klassenfelder zuzugreifen und diese zu initialisieren.  Nur <i>lprcClipRect f√§llt</i> auf.  Wahrscheinlich ist f√ºr diesen Parameter der Modifikator <i>out</i> oder <i>ref</i> erforderlich. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3066</a> M√∂glicherweise falsche Reihenfolge der Argumente, die an die Methode 'AdjustCellBorderStyle' √ºbergeben wurden: 'isFirstDisplayedRow' und 'isFirstDisplayedColumn'.  DataGridViewComboBoxCell.cs 1934 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataGridViewCellMouseEventArgs e)</span></span></span><span class="hljs-function"> </span></span>{ .... dgvabsEffective = AdjustCellBorderStyle( DataGridView.AdvancedCellBorderStyle, dgvabsPlaceholder, singleVerticalBorderAdded, singleHorizontalBorderAdded, isFirstDisplayedRow, <span class="hljs-comment"><span class="hljs-comment">// &lt;= isFirstDisplayedColumn); // &lt;= .... }</span></span></code> </pre> <br>  Der Analysator vermutete, dass die letzten beiden Argumente verwechselt wurden.  Schauen wir uns die Deklaration der <i>AdjustCellBorderStyle-</i> Methode an: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> DataGridViewAdvancedBorderStyle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustCellBorderStyle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DataGridViewAdvancedBorderStyledataGridViewAdvancedBorderStyleInput, DataGridViewAdvancedBorderStyle dataGridViewAdvancedBorderStylePlaceholder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleVerticalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleHorizontalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedColumn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedRow)</span></span></span><span class="hljs-function"> </span></span>{ .... }</code> </pre> <br>  Sieht aus wie ein Fehler.  Ja, einige Argumente werden h√§ufig in umgekehrter Reihenfolge √ºbergeben, um beispielsweise einige Variablen auszutauschen.  Aber ich denke nicht, dass dies der Fall ist.  Nichts in den Anrufer- oder Angerufenen-Methoden weist auf dieses Verwendungsmuster hin.  Zun√§chst werden Variablen vom Typ <i>bool verwechselt</i> .  Zweitens sind die Namen der Methoden ebenfalls regelm√§√üig: kein "Swap" oder "Reverse".  Au√üerdem ist es nicht so schwer, so einen Fehler zu machen.  Menschen nehmen die Reihenfolge des Paares "Zeile / Spalte" oft unterschiedlich wahr.  F√ºr mich ist zum Beispiel die "Zeile / Spalte" bekannt.  F√ºr den Autor der Methode namens <i>AdjustCellBorderStyle</i> ist die √ºblichere Reihenfolge nat√ºrlich "Spalte / Zeile". <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3070</a> Nicht initialisierte Variable 'LANG_USER_DEFAULT' wird beim Initialisieren der Variablen 'LOCALE_USER_DEFAULT' verwendet.  NativeMethods.cs 890 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT); .... }</code> </pre> <br>  Seltener Fehler.  Die Initialisierungsreihenfolge von Klassenfeldern ist verwechselt.  Zur Berechnung des Wertes des Feldes <i>LOCALE_USER_DEFAULT wird</i> das Feld <i>LANG_USER_DEFAULT</i> verwendet, das noch nicht initialisiert ist und den Wert 0 hat. Die Variable <i>LANG_USER_DEFAULT</i> wird <i>√ºbrigens an</i> keiner anderen Stelle im Code verwendet.  Ich ging eine Extrameile und schrieb ein kleines Konsolenprogramm, das die Situation simuliert.  Ich habe einige im WinForms-Code verwendete Konstanten durch ihre tats√§chlichen Werte ersetzt: <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELANGID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> primary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sub)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((((ushort)(sub)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) | (ushort)(primary)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAKELCID(lgid, <span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sort)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &amp; lgid) | (((<span class="hljs-number"><span class="hljs-number">0x000f</span></span>) &amp; sort) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>)); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Program</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.Console.WriteLine(NativeMethods.LOCALE_USER_DEFAULT); } }</code> </pre> <br>  Infolgedessen zeigt die Konsole <i>Folgendes an</i> : 0. Tauschen wir nun die Deklarationen der Felder <i>LOCALE_USER_DEFAULT</i> und <i>LANG_USER_DEFAULT aus</i> .  Das Ergebnis der Programmausf√ºhrung lautet wie folgt: 1024. Ich denke, hier gibt es nichts mehr zu kommentieren. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die Inspektion von "ces".  CodeDomSerializerBase.cs 562 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeserializeStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IDesignerSerializationManager manager, CodeStatement statement)</span></span></span><span class="hljs-function"> </span></span>{ .... CodeExpressionStatement ces = statement as CodeExpressionStatement; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ces != null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... DeserializeExpression(manager, null, ces.Expression); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } .... }</span></span></code> </pre> <br>  Der Code, der ziemlich regelm√§√üig "abst√ºrzen" sollte, da Sie in den <i>else-</i> Zweig gelangen k√∂nnen, wenn die <i>ces-</i> Referenz gleich <i>null ist</i> . <br><br>  Ein weiteres √§hnliches Beispiel: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung.  Betrachten Sie die 'comboBox'.  ComboBox.cs 6610 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateOwnerDrawRegions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ComboBox comboBox, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comboBox != null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Rectangle topOwnerDrawArea = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, comboBox.Width, innerBorder.Top); .... }</code> </pre> <br>  Der paradoxe Code.  Anscheinend wurde die <i>Pr√ºfung if (comboBox! = Null)</i> mit <i>if (comboBox == null)</i> verwechselt.  Und so erhalten wir eine weitere <i>NullReferenceException.</i> <br><br>  Wir haben zwei ziemlich offensichtliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080-</a> Fehler betrachtet, bei denen Sie eine m√∂gliche Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullreferenzen</a> innerhalb einer Methode visuell verfolgen k√∂nnen.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080-</a> Diagnose ist jedoch viel effizienter und kann solche Fehler f√ºr Methodenaufrufketten finden.  Vor nicht allzu langer Zeit haben wir den Datenfluss und die interprozeduralen Analysemechanismen erheblich verbessert.  Sie k√∂nnen dies im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullable Referenztypen in C # 8.0 und statische Analyse</a> " lesen.  In WinForms wird jedoch ein solcher Fehler festgestellt: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung innerhalb der Methode bei 'reader.NameTable'.  √úberpr√ºfen Sie das erste Argument: contentReader.  ResXResourceReader.cs 267 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnsureResData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... XmlTextReader contentReader = null; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileContents != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reader != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileName != null || stream != null) { .... contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } SetupNameTable(contentReader); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } finally { .... } .... }</span></span></code> </pre> <br>  Schauen Sie, was mit der Variablen <i>contentReader</i> im Methodenk√∂rper passiert.  Nach der Initialisierung mit null wird es bei einer der Pr√ºfungen erneut initialisiert.  Die Reihe der Pr√ºfungen endet jedoch nicht mit dem <i>else-</i> Block.  Dies bedeutet, dass in einigen seltenen F√§llen (oder aufgrund zuk√ºnftiger Umgestaltungen) die Referenz <b>m√∂glicherweise</b> immer noch null bleibt.  Anschlie√üend wird es an die <i>SetupNameTable-</i> Methode √ºbergeben, wo es ohne √úberpr√ºfung verwendet wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupNameTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlReader reader)</span></span></span><span class="hljs-function"> </span></span>{ reader.NameTable.Add(ResXResourceWriter.TypeStr); reader.NameTable.Add(ResXResourceWriter.NameStr); .... }</code> </pre> <br>  Dies ist m√∂glicherweise unsicherer Code. <br><br>  Und noch ein Fehler, bei dem der Analysator die Anrufkette durchlaufen musste, um das Problem zu erkennen: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080</a> M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie das Layout.  DockAndAnchorLayout.cs 156 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Rectangle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IArrangedElement element, Rectangle displayRect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> measureOnly)</span></span></span><span class="hljs-function"> </span></span>{ .... AnchorInfo layout = GetAnchorInfo(element); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = layout.Left + displayRect.X; .... }</code> </pre> <br>  Der Analysator behauptet, dass es m√∂glich ist, eine <i>Nullreferenz</i> von der <i>GetAnchorInfo-</i> Methode <i>abzurufen</i> , was bei der Berechnung des <i>linken</i> Werts eine Ausnahme verursacht.  Lassen Sie uns die gesamte Anrufkette durchgehen und pr√ºfen, ob sie wahr ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnchorInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IArrangedElement element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (AnchorInfo)element.Properties.GetObject(s_layoutInfoProperty); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>=&gt; GetObject(key, out _); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> found)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> keyIndex = SplitKey(key, out <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> element); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LocateObjectEntry(keyIndex, out <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index)) { found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } <span class="hljs-comment"><span class="hljs-comment">// We have found the relevant entry. See if // the bitmask indicates the value is used. if (((1 &lt;&lt; element) &amp; s_objEntries[index].Mask) == 0) { found = false; return null; } found = true; switch (element) { case 0: return s_objEntries[index].Value1; .... default: Debug.Fail("Invalid element obtained from LocateObjectEntry"); return null; } }</span></span></code> </pre> <br>  In einigen F√§llen gibt die <i>GetObject-</i> Methode, die die Aufrufkette beendet, <i>null zur√ºck</i> , die ohne zus√§tzliche √úberpr√ºfungen an die Aufrufermethode √ºbergeben wird.  Wahrscheinlich ist es notwendig, eine solche Situation in der <i>GetAnchorDestination-</i> Methode <i>abzudecken</i> . <br><br>  Es gibt ziemlich viele solcher Fehler im WinForms-Code, <b>mehr als 70</b> .  Sie sehen alle gleich aus und ich werde sie im Artikel nicht beschreiben. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3091</a> Empirische Analyse.  M√∂glicherweise ist im Zeichenfolgenliteral ein Tippfehler vorhanden: "ShowCheckMargin".  Das Wort 'ShowCheckMargin' ist verd√§chtig.  PropertyNames.cs 136 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNames</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowImageMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowCheckMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; .... }</code> </pre> <br>  Ein gutes Beispiel f√ºr einen Fehler, der nicht so leicht zu finden ist.  Bei der Initialisierung der Klassenfelder wird derselbe Wert verwendet, obwohl der Autor des Codes dies offensichtlich nicht beabsichtigt hat (Kopieren und Einf√ºgen ist schuld).  Der Analysator kam zu diesem Schluss, indem er die Namen der Variablen und die Werte der zugewiesenen Zeichenfolgen verglich.  Ich habe nur fehlerhafte Zeilen angegeben, aber Sie sollten √ºberpr√ºfen, wie es im Code-Editor aussieht: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/196/4de/3131964de8f3f5161678c44086ed2e40.png" alt="Bild 2"></div><br>  Die Erkennung solcher Fehler zeigt die Leistungsf√§higkeit und die unendliche Aufmerksamkeitsspanne statischer Analysewerkzeuge. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095</a> Das Objekt 'currentForm' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 3386, 3404. Application.cs 3386 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunMessageLoopInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reason, ApplicationContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... hwndOwner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef( null, UnsafeNativeMethods.GetWindowLong( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(currentForm, currentForm.Handle), <span class="hljs-comment"><span class="hljs-comment">// &lt;= NativeMethods.GWL_HWNDPARENT)); .... if (currentForm != null &amp;&amp; ....) .... }</span></span></code> </pre> <br>  Das ist klassisch.  Die Variable <i>currentForm</i> wird ohne Pr√ºfung verwendet.  Aber dann wird im Code auf <i>Null</i> gepr√ºft.  In diesem Fall kann ich Ihnen raten, beim Arbeiten mit Referenztypen aufmerksamer zu sein und auch statische Analyseger√§te zu verwenden :). <br><br>  Noch ein solcher Fehler: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095</a> Das Objekt 'backgroundBrush' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 2331, 2334. DataGrid.cs 2331 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color BackgroundColor { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value.Equals(backgroundBrush.Color)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if (backgroundBrush != null &amp;&amp; BackgroundBrush != DefaultBackgroundBrush) .... } } }</span></span></code> </pre> <br>  Im WinForms-Code sind <b>mehr als 60</b> solcher Fehler aufgetreten.  Meiner Meinung nach sind alle eher kritisch und erfordern die Aufmerksamkeit der Entwickler.  Aber es ist nicht mehr so ‚Äã‚Äãinteressant, im Artikel dar√ºber zu erz√§hlen, deshalb werde ich mich auf die beiden oben genannten beschr√§nken. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> Das Objekt '_propInfo' wurde verwendet und in verschiedenen Ausf√ºhrungszweigen gegen Null verifiziert.  √úberpr√ºfen Sie die Zeilen: 996, 982. Binding.cs 996 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPropValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object value)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_propInfo != null) .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _propInfo.SetValue(_control, value); } .... }</code> </pre> <br>  Der Vollst√§ndigkeit halber - auch eine Art Klassiker, Fehler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> .  Die gegenteilige Situation.  Zun√§chst verwendet der Entwickler eine potenziell <i>Null-</i> Referenz sicher, nachdem er sie mit Null verglichen hat, h√∂rt jedoch auf, sie im Code weiter auszuf√ºhren. <br><br>  Und noch ein solcher Fehler: <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> Das Objekt 'owner' wurde verwendet, nachdem es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 64, 60. FlatButtonAppearance.cs 64 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BorderSize { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner != null &amp;&amp; owner.ParentInternal != null) { LayoutTransaction.DoLayoutIf(....); } owner.Invalidate(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } }</span></span></code> </pre> <br>  Sch√∂n  Dies ist jedoch der Standpunkt eines externen Forschers.  Immerhin hat der Analysator neben diesen beiden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> <b>mehr als 50</b> solcher Muster im WinForms-Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gefunden</a> .  Entwickler haben viel zu tun. <br><br>  Und schlie√ülich gibt es meiner Meinung nach einen interessanten Fehler. <br><br>  PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3137</a> Die Variable 'hCurrentFont' wird zugewiesen, aber am Ende der Funktion nicht verwendet.  DeviceContext2.cs 241 <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { WindowsFont selectedFont; .... <span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisposeFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> disposing)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (disposing) { DeviceContexts.RemoveDeviceContext(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedFont != null &amp;&amp; selectedFont.Hfont != IntPtr.Zero) { IntPtr hCurrentFont = IntUnsafeNativeMethods.GetCurrentObject( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, hDC), IntNativeMethods.OBJ_FONT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hCurrentFont == selectedFont.Hfont) { <span class="hljs-comment"><span class="hljs-comment">// select initial font back in IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(null, hInitialFont)); hCurrentFont = hInitialFont; // &lt;= } selectedFont.Dispose(disposing); selectedFont = null; } } .... }</span></span></code> </pre> <br>  Mal sehen, was den Analysator alarmiert hat und warum er m√∂glicherweise auf ein Problem hinweist, dass einer Variablen ein Wert zugewiesen wurde, der jedoch nie im Code verwendet wurde. <br><br>  Die Datei <i>DeviceContext2.cs</i> enth√§lt eine <i>Teilklasse</i> .  Die <i>DisposeFont-</i> Methode wird verwendet, um Ressourcen nach der Arbeit mit Grafiken <i>freizugeben</i> : Ger√§tekontext und Schriftarten.  Zum besseren Verst√§ndnis habe ich die gesamte <i>DisposeFont-</i> Methode angegeben.  <i>Achten Sie</i> auf die lokale Variable <i>hCurrentFont</i> .  Das Problem ist, dass die Deklaration dieser Variablen in der Methode das gleichnamige Klassenfeld verbirgt.  Ich habe zwei Methoden der <i>DeviceContext-</i> Klasse gefunden, bei denen das <b>Feld</b> mit dem Namen <i>hCurrentFont</i> verwendet wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WindowsFont font)</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = font.Hfont; .... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = hInitialFont; }</code> </pre> <br>  Schauen Sie sich die <i>ResetFont-</i> Methode an.  In der letzten Zeile steht genau das, was die <i>DisposeFont-</i> Methode im Unterblock tut, <i>wenn</i> (darauf zeigt der Analysator).  Dieses gleichnamige <i>hCurrentFont-</i> Feld wird in einem anderen Teil der <i>Teilklasse</i> in der Datei <i>DeviceContext.cs deklariert</i> : <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { .... IntPtr hInitialFont; .... IntPtr hCurrentFont; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Somit wurde ein offensichtlicher Fehler gemacht.  Eine andere Frage liegt in ihrer Bedeutung.  Aufgrund der Arbeit der <i>DisposeFont-</i> Methode in dem Abschnitt mit dem Kommentar " <i>W√§hlen</i> Sie die urspr√ºngliche Schriftart wieder aus" wird das Feld " <i>hCurrentFont</i> " nicht initialisiert.  Ich denke, nur die Autoren des Codes k√∂nnen ein genaues Urteil abgeben. <br><br>  <b>Schlussfolgerungen</b> <br><br>  Dieses Mal muss ich MS ein wenig kritisieren.  In WinForms gibt es viele Fehler, die die Aufmerksamkeit der Entwickler erfordern.  Vielleicht liegt es an der Eile, mit der MS an .NET Core 3 und Komponenten, einschlie√ülich WinForms, arbeitet.  Meiner Meinung nach ist der WinForms-Code immer noch "roh", aber ich hoffe, dass sich die Situation bald zum Besseren √§ndert. <br><br>  Der zweite Grund f√ºr die gro√üe Anzahl von Fehlern kann sein, dass unser Analysator einfach besser darin geworden ist, nach ihnen zu suchen :). <br><br>  √úbrigens wird bald ein Artikel meines Kollegen Sergey Vasiliev ver√∂ffentlicht, in dem er viele Probleme im Code von .NET Core-Bibliotheken sucht und findet.  Ich hoffe, dass seine Arbeit auch zur Verbesserung der Eigenschaften der .NET-Plattform beitr√§gt, da wir immer versuchen, die Entwickler √ºber die Ergebnisse der Analyse ihrer Projekte zu informieren. <br><br>  Und f√ºr diejenigen, die ihre Produkte selbst verbessern oder nach Fehlern in Projekten anderer suchen m√∂chten, empfehle ich, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio herunterzuladen und auszuprobieren</a> . <br><br>  Sauberer Code f√ºr alle! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462809/">https://habr.com/ru/post/de462809/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462799/index.html">RAVIS und DAB bei einem niedrigen Start. DRM beleidigt. Die seltsame Zukunft des Digitalradios der Russischen F√∂deration</a></li>
<li><a href="../de462801/index.html">15 unverzichtbare Tools f√ºr Produktmanager im Jahr 2019</a></li>
<li><a href="../de462803/index.html">Migration von einem ERP-System zu einem anderen</a></li>
<li><a href="../de462805/index.html">Analyse: Wie Geld beim Handel an der B√∂rse tats√§chlich gesch√ºtzt ist</a></li>
<li><a href="../de462807/index.html">WinForms: Fehler, Holmes</a></li>
<li><a href="../de462811/index.html">Warum brauchen wir Generika in Go?</a></li>
<li><a href="../de462813/index.html">Jekaterinburg, 14. August - Atlassian User Group mitap</a></li>
<li><a href="../de462815/index.html">Mein dritter Tag mit Haiku: Das ganze Bild nimmt Gestalt an</a></li>
<li><a href="../de462819/index.html">M√§ngel im Sprachunterricht in der GUS: eine polyglotte Sichtweise</a></li>
<li><a href="../de462821/index.html">So bewerten Sie Computer, die noch nicht vorhanden sind</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>