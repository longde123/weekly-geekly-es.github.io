<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏻 🚋 🔛 Criptografía en Java 🛂 👸🏾 ◻️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les presento la traducción del artículo "Criptografía Java" de Jakob Jenkov. 


 Esta publicación es una traducción del primer artículo de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criptografía en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444764/"><p> Hola Habr!  Les presento la traducción del artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Criptografía Java"</a> de Jakob Jenkov. </p><br><p>  Esta publicación es una traducción del primer artículo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">criptografía de Java</a> de una serie de artículos para principiantes que desean aprender los conceptos básicos de la criptografía en Java. </p><a name="habracut"></a><br><h2 id="oglavlenie">  Tabla de contenido: </h2><br><ol><li>  Criptografía Java </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cifrado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Messagedigest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mac</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Firma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Par de llaves</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Generador de claves</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">KeyPairGenerator</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Keystore</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Keytool</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Certificado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CertificateFactory</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CertPath</a> </li></ol><br><h1 id="java-cryptography">  Criptografía Java </h1><br><p>  <strong>La API de criptografía de Java</strong> proporciona la capacidad de cifrar y descifrar datos en Java, así como administrar claves, firmas y autenticar mensajes (autenticar), calcular hashes criptográficos y mucho más. </p><br><p>  Este artículo explica los conceptos básicos sobre cómo utilizar la API de criptografía de Java para realizar diversas tareas que requieren cifrado seguro. </p><br><p>  Este artículo no explica los conceptos básicos de la teoría criptográfica.  Tendrá que ver esta información en otro lugar. </p><br><h2 id="rasshirenie-kriptografii-java">  Extensión de criptografía de Java </h2><br><p>  La API de criptografía de Java es proporcionada por la llamada <strong>Java Cryptography Extension</strong> (JCE).  JCE ha sido durante mucho tiempo parte de la plataforma Java.  Inicialmente, JCE se separó de Java debido a restricciones de exportación en tecnología de cifrado en los Estados Unidos.  Por lo tanto, los algoritmos de cifrado más fuertes no se incluyeron en la plataforma estándar de Java.  Estos algoritmos de cifrado más sólidos se pueden aplicar si su empresa se encuentra en los EE. UU., Pero en otros casos tendrá que usar algoritmos más débiles o implementar sus propios algoritmos de cifrado y conectarlos a JCE. </p><br><p>  Desde 2017, las reglas para exportar algoritmos de cifrado en los Estados Unidos se han relajado significativamente, y en la mayoría de las partes del mundo puede usar estándares de cifrado internacionales a través de Java JCE. </p><br><p>  Arquitectura de criptografía de Java </p><br><p>  <strong>Java Cryptography Architecture (JCA)</strong> es el nombre del diseño interno de API de criptografía en Java.  JCA se estructura en torno a varias clases principales e interfaces de propósito general.  Los proveedores proporcionan la funcionalidad real de estas interfaces.  Por lo tanto, puede usar la clase Cipher para cifrar y descifrar algunos datos, pero la implementación específica del cifrado (algoritmo de cifrado) depende del proveedor particular utilizado. </p><br><p>  También puede implementar y conectar sus propios proveedores, pero debe tener cuidado con esto.  ¡Implementar correctamente el cifrado sin agujeros de seguridad es difícil!  Si no sabe lo que está haciendo, probablemente sea mejor usar el proveedor de Java incorporado o un proveedor de confianza como Bouncy Castle. </p><br><h3 id="osnovnye-klassy-i-interfeysy">  Principales clases e interfaces </h3><br><p>  La API de criptografía de Java consta de los siguientes paquetes de Java: </p><br><ul><li>  java.security </li><li>  java.security.cert </li><li>  java.security.spec </li><li>  java.security.interfaces </li><li>  javax.crypto </li><li>  javax.crypto.spec </li><li>  javax.crypto.interfaces </li></ul><br><p>  Las principales clases e interfaces de estos paquetes: </p><br><ul><li>  Proveedor </li><li>  SecureRandom </li><li>  Cifrado </li><li>  Messagedigest </li><li>  Firma </li><li>  Mac </li><li>  Algoritmo Parámetros </li><li>  AlgorithmParameterGenerator </li><li>  Keyfactory </li><li>  SecretKeyFactory </li><li>  KeyPairGenerator </li><li>  Generador de claves </li><li>  Keyagreement </li><li>  Keystore </li><li>  CertificateFactory </li><li>  CertPathBuilder </li><li>  CertPathValidator </li><li>  CertStore </li></ul><br><h3 id="provider-postavschik-kriptografii">  Proveedor </h3><br><p>  La clase de proveedor (java.security.Provider) es la clase central en la API de cifrado de Java.  Para utilizar la API criptográfica de Java, debe instalar un proveedor de criptografía.  El SDK de Java viene con su propio proveedor de criptografía.  A menos que establezca explícitamente el proveedor de criptografía, se utilizará el proveedor predeterminado.  Sin embargo, este proveedor criptográfico puede no admitir los algoritmos de cifrado que desea utilizar.  Por lo tanto, es posible que deba instalar su propio proveedor de criptografía. </p><br><p>  Uno de los proveedores de criptografía más populares para la API de criptografía Java se llama Bouncy Castle.  Aquí hay un ejemplo en el que BouncyCastleProvider está configurado como proveedor criptográfico: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.bouncycastle.jce.provider.BouncyCastleProvider; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.security.Security; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProviderExample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Security.addProvider(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BouncyCastleProvider()); } }</code> </pre> <br><h3 id="cipher-shifr">  Cifrado </h3><br><p>  La clase Cipher (javax.crypto.Cipher) representa un algoritmo criptográfico.  Un cifrado se puede usar tanto para el cifrado como para descifrar datos.  La clase Cipher se explica con más detalle en las siguientes secciones, con una breve descripción a continuación. </p><br><p>  Crear una instancia de la clase de cifrado que utiliza el algoritmo de cifrado AES para uso interno: </p><br><pre> <code class="java hljs">Cipher cipher = Cipher.getInstance(<span class="hljs-string"><span class="hljs-string">"AES/CBC/PKCS5Padding"</span></span>);</code> </pre> <br><p>  El <em>método Cipher.getInstance (...)</em> acepta una cadena que determina qué algoritmo de cifrado usar, así como algunos otros parámetros del algoritmo. <br>  En el ejemplo anterior: </p><br><ul><li>  AES - algoritmo de cifrado </li><li>  CBC es un modo en el que el algoritmo AES puede funcionar. </li><li>  PKCS5Padding es cómo el algoritmo AES debe procesar los últimos bytes de datos para el cifrado.  ¿Qué significa exactamente esto? Busque en el manual de criptografía en su conjunto y no en este artículo. </li></ul><br><h4 id="inicializaciya-shifra">  Inicialización de cifrado </h4><br><p>  Antes de usar una instancia de cifrado, debe inicializarla.  La instancia de cifrado se inicializa llamando al método <em>init ()</em> .  El método <em>init ()</em> toma dos parámetros: </p><br><ul><li>  Modo: cifrado / descifrado </li><li>  Clave </li></ul><br><p>  El primer parámetro indica el modo de operación de la instancia de cifrado: para cifrar o descifrar datos.  El segundo parámetro indica qué clave usan para cifrar o descifrar datos. </p><br><p>  Un ejemplo: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] keyBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>}; String algorithm = <span class="hljs-string"><span class="hljs-string">"RawBytes"</span></span>; SecretKeySpec key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecretKeySpec(keyBytes, algorithm); cipher.init(Cipher.ENCRYPT_MODE, key);</code> </pre><br><p>  Tenga en cuenta que el método de creación de claves en este ejemplo no es seguro y no debe usarse en la práctica.  Este artículo en las siguientes secciones explicará cómo crear claves de manera más segura. </p><br><p>  Para inicializar una instancia de cifrado para descifrar datos, debe usar Cipher.DECRYPT_MODE, por ejemplo: </p><br><pre> <code class="java hljs">cipher.init(Cipher.DECRYPT_MODE, key);</code> </pre> <br><h4 id="shifrovanie-ili-deshifrovanie-dannyh">  Cifrado o descifrado de datos </h4><br><p>  Después de inicializar el cifrado, puede comenzar a cifrar o descifrar los datos llamando a los métodos <em>update ()</em> o <em>doFinal ()</em> .  El método <em>update ()</em> se usa si está encriptando o desencriptando un dato.  Se llama al método <em>doFinal ()</em> cuando encripta la última pieza de datos o si el bloque de datos que pasa a <em>doFinal ()</em> es un conjunto único de datos para encriptar. </p><br><p>  Un ejemplo de encriptación de datos usando el método <em>doFinal ()</em> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] plainText = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] cipherText = cipher.doFinal(plainText);</code> </pre> <br><p>  Para descifrar los datos, debe pasar el texto cifrado (datos) al <em>método doFinal ()</em> o <em>doUpdate ()</em> . </p><br><h3 id="keys-klyuchi">  Llaves </h3><br><p>  Para cifrar o descifrar datos, necesita una clave.  Existen dos tipos de claves, según el tipo de algoritmo de cifrado que se use: </p><br><ul><li>  Llaves simétricas </li><li>  Llaves asimétricas </li></ul><br><p>  Las claves simétricas se utilizan para algoritmos de cifrado simétricos.  Los algoritmos de cifrado simétrico usan la misma clave para el cifrado y descifrado. <br>  Las claves asimétricas se utilizan para algoritmos de cifrado asimétricos.  Los algoritmos de cifrado asimétrico usan una clave para el cifrado y otra para el descifrado.  Los algoritmos de cifrado de clave pública y privada son ejemplos de algoritmos de cifrado asimétrico. </p><br><p>  De alguna manera, la parte que necesita descifrar los datos debe conocer la clave necesaria para descifrar los datos.  Si el descifrador no es parte del cifrado de datos, las dos partes deben acordar una clave o intercambiar una clave.  Esto se llama intercambio de claves. </p><br><h4 id="bezopasnost-klyucha">  Seguridad clave </h4><br><p>  Las claves deben ser difíciles de adivinar para que un atacante no pueda recoger fácilmente una clave de cifrado.  En el ejemplo de la sección anterior sobre la clase Cipher, se utilizó una clave muy simple y codificada.  En la práctica, esto no vale la pena hacerlo.  Si la clave de las partes es fácil de adivinar, será fácil para un atacante descifrar los datos cifrados y posiblemente crear mensajes falsos por su cuenta.  Es importante hacer una clave que sea difícil de adivinar.  Por lo tanto, la clave debe consistir en bytes aleatorios.  Cuantos más bytes aleatorios, más difícil es adivinar, porque hay más combinaciones posibles. </p><br><h4 id="generaciya-klyucha">  Generación clave </h4><br><p>  Para generar claves de cifrado aleatorias, puede usar la clase Java KeyGenerator.  KeyGenerator se describirá con más detalle en los siguientes capítulos, aquí hay un pequeño ejemplo de su uso aquí: </p><br><pre> <code class="java hljs">KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"AES"</span></span>); SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> keyBitSize = <span class="hljs-number"><span class="hljs-number">256</span></span>; keyGenerator.init(keyBitSize, secureRandom); SecretKey secretKey = keyGenerator.generateKey();</code> </pre> <br><p>  La instancia de SecretKey resultante se puede pasar al método <em>Cipher.init ()</em> , por ejemplo, así: </p><br><pre> <code class="java hljs">cipher.init(Cipher.ENCRYPT_MODE, secretKey);</code> </pre> <br><h4 id="generaciya-pary-klyuchey">  Generación de pares de claves </h4><br><p>  Los algoritmos de cifrado asimétrico utilizan un par de claves que consta de una clave pública y una clave privada para cifrar y descifrar datos.  Para crear un par de claves asimétricas, puede usar KeyPairGenerator (java.security.KeyPairGenerator).  KeyPairGenerator se describirá con más detalle en los siguientes capítulos, a continuación se muestra un ejemplo simple de Java KeyPairGenerator: </p><br><pre> <code class="java hljs">SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"DSA"</span></span>); KeyPair keyPair = keyPairGenerator.generateKeyPair();</code> </pre> <br><h4 id="hranilische-klyuchey--key-store">  Tienda de llaves </h4><br><p>  Java KeyStore es una base de datos que puede contener claves.  Java KeyStore está representado por la clase KeyStore (java.security.KeyStore).  Un almacén de claves puede contener claves de los siguientes tipos: </p><br><ul><li>  Claves privadas </li><li>  Claves públicas y certificados (Claves públicas + certificados) </li><li>  Llaves secretas </li></ul><br><p>  Las claves privadas y públicas se utilizan en cifrado asimétrico.  La clave pública puede tener un certificado asociado.  Un certificado es un documento que prueba la identidad de una persona, organización o dispositivo que afirma poseer una clave pública. </p><br><p>  El certificado suele estar firmado digitalmente por la parte que confía como prueba. <br>  Las claves privadas se utilizan en el cifrado simétrico. La clase KeyStore es bastante compleja, por lo que se describe con más detalle más adelante en un capítulo separado sobre Java KeyStore. </p><br><h4 id="instrument-upravleniya-klyuchami-keytool">  Herramienta de administración de claves (Keytool) </h4><br><p>  Java Keytool es una herramienta de línea de comandos que puede funcionar con archivos Java KeyStore.  Keytool puede generar pares de claves en un archivo KeyStore, exportar certificados e importar certificados en KeyStore y algunas otras funciones.  Keytool viene con una instalación de Java.  Keytool se describe con más detalle más adelante en un capítulo separado sobre Java Keytool. </p><br><h3 id="daydzhest-soobscheniya-messagedigest">  Resumen del mensaje </h3><br><p>  Cuando recibe datos cifrados del otro lado, ¿puede estar seguro de que nadie ha cambiado los datos cifrados en el camino hacia usted? </p><br><p>  Por lo general, la solución es calcular el resumen del mensaje a partir de los datos antes de cifrarlo, luego cifrar los datos y el resumen del mensaje, y enviarlo a través de la red.  Un resumen de mensaje es un valor hash calculado en función de los datos del mensaje.  Si se modifica al menos un byte en los datos cifrados, el resumen del mensaje calculado a partir de los datos también cambiará. </p><br><p>  Cuando recibe datos cifrados, los descifra, calcula el resumen del mensaje a partir de ellos y compara el resumen calculado del mensaje con el resumen del mensaje enviado junto con los datos cifrados.  Si los dos resúmenes de mensajes son iguales, existe una alta probabilidad (pero no del 100%) de que los datos no se hayan cambiado. </p><br><p>  Java MessageDigest (java.security.MessageDigest) se puede utilizar para calcular resúmenes de mensajes.  Para crear una instancia de MessageDigest, se llama al método <em>MessageDigest.getInstance ()</em> .  Hay varios algoritmos de resumen de mensajes diferentes.  Debe especificar qué algoritmo desea usar al crear la instancia de MessageDigest.  El trabajo con MessageDigest se describirá con más detalle en el capítulo Java MessageDigest. </p><br><h4 id="kratkoe-vvedenie-v-klass-messagedigest">  Una breve introducción a la clase MessageDigest: </h4><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>);</code> </pre> <br><p>  Este ejemplo crea una instancia de MessageDigest que utiliza el algoritmo de cifrado interno criptográfico SHA-256 para calcular resúmenes de mensajes. </p><br><p>  Para calcular el resumen del mensaje de algunos datos, llame al método <em>update ()</em> o <em>digest ()</em> .  El método <em>update ()</em> se puede llamar varias veces y el resumen del mensaje se actualiza dentro del objeto.  Cuando haya pasado todos los datos que desea incluir en el resumen del mensaje, llame al <em>resumen ()</em> y recupere el resumen del resumen del mensaje. </p><br><p>  Un ejemplo de llamar a <em>update ()</em> varias veces, seguido de una llamada a <em>digest ()</em> : </p><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data1 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); messageDigest.update(data1); messageDigest.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digest = messageDigest.digest();</code> </pre> <br><p>  También puede llamar a <em>digest ()</em> una vez, pasando todos los datos para calcular el resumen del mensaje.  Un ejemplo: </p><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data1 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digest = messageDigest.digest(data1);</code> </pre> <br><h3 id="kod-autentifikacii-soobscheniya-mac">  Código de autenticación de mensaje (MAC) </h3><br><p>  La clase Java Mac se usa para crear un MAC (Código de autenticación de mensaje) a partir de un mensaje.  El MAC es similar a un resumen del mensaje, pero utiliza una clave adicional para cifrar el resumen del mensaje.  Solo teniendo los datos de origen y la clave, puede verificar el MAC.  Por lo tanto, un MAC es una forma más segura de proteger un bloque de datos de modificaciones que un resumen de mensaje.  La clase Mac se describe con más detalle en el capítulo Java Mac, seguido de una breve introducción. </p><br><p>  Una instancia de Java Mac se crea llamando al método <em>Mac.getInstance ()</em> , pasando el nombre del algoritmo para usar como parámetro.  Así es como se ve: </p><br><pre> <code class="java hljs">Mac mac = Mac.getInstance(<span class="hljs-string"><span class="hljs-string">"HmacSHA256"</span></span>);</code> </pre> <br><p>  Antes de crear un MAC a partir de datos, debe inicializar la instancia de Mac con la clave.  Aquí hay un ejemplo de inicialización de una instancia de Mac con una clave: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] keyBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span> ,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>}; String algorithm = <span class="hljs-string"><span class="hljs-string">"RawBytes"</span></span>; SecretKeySpec key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecretKeySpec(keyBytes, algorithm); mac.init(key);</code> </pre> <br><p>  Después de inicializar la instancia de Mac, puede calcular el MAC a partir de los datos llamando a los métodos <em>update ()</em> y <em>doFinal ()</em> .  Si tiene todos los datos para calcular el MAC, puede llamar inmediatamente al método <em>doFinal ()</em> .  Así es como se ve: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); mac.update(data); mac.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] macBytes = mac.doFinal();</code> </pre> <br><h3 id="podpis-signature">  Firma </h3><br><p>  La clase Signature (java.security.Signature) se usa para firmar datos digitalmente.  Cuando se firman los datos, se crea una firma digital a partir de estos datos.  Por lo tanto, la firma se separa de los datos. </p><br><p>  Se crea una firma digital creando un resumen de mensaje (hash) a partir de los datos y encriptando este resumen de mensaje con la clave privada del dispositivo, persona u organización que debe firmar los datos.  El resumen del mensaje cifrado se denomina firma digital. </p><br><p>  Para crear una instancia de Signature, se llama al método <em>Signature.getInstance (...)</em> : </p><br><pre> <code class="java hljs">Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>);</code> </pre> <br><h4 id="podpis-dannyh">  Firma de datos </h4><br><p>  Para firmar datos, debe inicializar la instancia de firma en modo firma llamando al método initSign (...), pasando la clave privada para firmar los datos.  Un ejemplo de inicialización de una instancia de firma en modo de firma: </p><br><pre> <code class="java hljs">signature.initSign(keyPair.getPrivate(), secureRandom);</code> </pre> <br><p>  Después de inicializar la instancia de firma, se puede usar para firmar los datos.  Esto se hace llamando al método update (), pasando los datos de la firma como un parámetro.  Puede llamar al método update () varias veces para complementar los datos para crear la firma.  Después de pasar todos los datos al método update (), se llama al método sign () para obtener una firma digital.  Así es como se ve: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature.update(data); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digitalSignature = signature.sign();</code> </pre> <br><h4 id="proverka-podpisi">  Verificación de firma </h4><br><p>  Para verificar la firma, debe inicializar la instancia de firma en modo de verificación llamando al <em>método initVerify (...)</em> , pasando como parámetro la clave pública que se utiliza para verificar la firma.  Un ejemplo de inicialización de una instancia de firma en modo de verificación se ve así: </p><br><pre> <code class="java hljs">Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature.initVerify(keyPair.getPublic());</code> </pre> <br><p>  Después de la inicialización en modo de verificación, los datos firmados se transmiten al método <em>update ()</em> .  Una llamada al método <em>verificar ()</em> devuelve <em>verdadero</em> o <em>falso</em> dependiendo de si la firma se puede verificar o no.  Aquí está la verificación de firma: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature2.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> verified = signature2.verify(digitalSignature);</code> </pre> <br><h4 id="polnyy-primer-podpisi-i-proverki">  Firma completa y ejemplo de verificación </h4><br><pre> <code class="java hljs">SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"DSA"</span></span>); KeyPair keyPair = keyPairGenerator.generateKeyPair(); Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature.initSign(keyPair.getPrivate(), secureRandom); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature.update(data); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digitalSignature = signature.sign(); Signature signature2 = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature2.initVerify(keyPair.getPublic()); signature2.update(data); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> verified = signature2.verify(digitalSignature); System.out.println(<span class="hljs-string"><span class="hljs-string">"verified = "</span></span> + verified);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444764/">https://habr.com/ru/post/444764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444752/index.html">La historia de SXSW: cómo comenzó todo</a></li>
<li><a href="../444756/index.html">DARPA desarrollará un motor nuclear de cohete</a></li>
<li><a href="../444758/index.html">Diferencias técnicas de los sistemas de BI (Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../444760/index.html">Máquina CNC de lo que yacía en el garaje</a></li>
<li><a href="../444762/index.html">CSTroN: un monitor casero en una matriz CSTN clásica con una entrada VGA y una placa de control FPGA</a></li>
<li><a href="../444766/index.html">Los empleados de Facebook tenían acceso a las contraseñas de usuario de Facebook e Instagram</a></li>
<li><a href="../444768/index.html">Reducción de la dependencia de datos etiquetados para redes de contención generativa</a></li>
<li><a href="../444770/index.html">Cómo buscamos una fuga de datos en SimilarWeb</a></li>
<li><a href="../444774/index.html">Error con la migración de ru-RU locale en Google Chrome y cómo deshacerse de ella</a></li>
<li><a href="../444776/index.html">No tengas miedo de intentarlo, o cómo me convertí en programador a la edad de más de 18 años</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>