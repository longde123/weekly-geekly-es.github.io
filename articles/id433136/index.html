<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¼â€ğŸš’ âšœï¸ ğŸ™‹ğŸ½ System.Transaksi Infrastruktur di Dunia .NET ğŸ¤¦ğŸ¼ ğŸ¥’ ğŸ™ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernahkah Anda melihat konstruksi seperti using (var scope = new TransactionScope(TransactionScopeOption.Required)) di C #? Ini berarti bahwa kode yan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.Transaksi Infrastruktur di Dunia .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/custis/blog/433136/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/df/aq/ctdfaqnuvdjaw6tobyxja78mk-s.png"></div><br>  Pernahkah Anda melihat konstruksi seperti <code>using (var scope = new TransactionScope(TransactionScopeOption.Required))</code> di C #?  Ini berarti bahwa kode yang berjalan di blok <code>using</code> dalam transaksi dan setelah keluar dari blok ini perubahan akan dilakukan atau dibatalkan.  Kedengarannya bisa dimengerti sampai Anda mulai menggali lebih dalam.  Dan semakin dalam Anda menggali, "aneh dan aneh" itu menjadi.  Dalam kasus apa pun, ketika saya menjadi lebih akrab dengan kelas <code>TransactionScope</code> dan, secara umum, dengan transaksi NET., Banyak pertanyaan muncul. <br><br>  Apa kelas <code>TransactionScope</code> ?  Segera setelah kami menggunakan konstruk <code>using (var scope = new TransactionScope())</code> , apakah semua yang ada di program kami langsung menjadi transaksional?  Apa itu "Manajer Sumber Daya" dan "Manajer Transaksi"?  Bisakah saya menulis manajer sumber daya saya sendiri dan bagaimana cara "terhubung" ke instance <code>TransactionScope</code> dibuat?  Apa itu transaksi terdistribusi dan apakah benar transaksi terdistribusi dalam SQL Server atau Oracle Database sama dengan transaksi .NET terdistribusi? <br><br>  Dalam publikasi ini, saya mencoba mengumpulkan materi yang membantu menemukan jawaban atas pertanyaan-pertanyaan ini dan membangun pemahaman transaksi di dunia .NET. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Isi</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa transaksi dan masalah apa yang mereka pecahkan?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transaksi apa yang dipertimbangkan di sini</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TL; bagian DR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transaksi berdasarkan System.Transaksi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa ini</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manajer sumber daya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jenis Manajer Sumber Daya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan TransactionScope</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penerapan Transaksi Perangkat Lunak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh manajer sumber daya yang berubah-ubah</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TL; bagian DR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transaksi Terdistribusi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa ini</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Protokol transaksional</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fiksasi bifasik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lembar contekan System.Transations</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Batasan dan Alternatif Transaksi Terdistribusi oleh Perangkat Lunak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jadi, apakah itu dalam. NET Core?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transaksi Terdistribusi dan WCF</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TL; bagian DR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan Boks</a> </div></div><br><a name="Introduction"></a><h2>  Pendahuluan </h2><br><a name="Transactions"></a><h4>  Apa transaksi dan masalah apa yang mereka pecahkan? </h4><br>  Transaksi yang dipermasalahkan di sini adalah operasi yang memindahkan sistem dari satu kondisi yang dapat diterima ke kondisi lain dan dijamin tidak meninggalkan sistem dalam keadaan yang tidak dapat diterima bahkan jika situasi yang tidak terduga muncul.  Seperti apa kondisi yang dapat diterima ini, dalam kasus umum, tergantung pada konteksnya.  Di sini kami akan mempertimbangkan situasi yang dapat diterima di mana data yang kami proses merupakan bagian integral.  Dapat dipahami bahwa perubahan yang membentuk transaksi dilakukan bersama atau tidak dilakukan.  Selain itu, perubahan pada satu transaksi dapat diisolasi dari perubahan yang dilakukan pada sistem oleh transaksi lainnya.  Persyaratan dasar untuk transaksi dilambangkan dengan akronim ACID.  Untuk kenalan pertama dengan mereka, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel di Wikipedia</a> cocok. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4r/p7/2b/4rp72bf2l_qdxmlhawxsjslkj-i.png" width="250"></div><br>  Contoh klasik dari suatu transaksi adalah transfer uang antara dua akun.  Dalam situasi ini, menarik uang dari akun No. 1 tanpa mengkredit ke akun No. 2 tidak dapat diterima, dengan cara yang sama seperti menyetor ke akun No. 2 tanpa menarik dari akun No. 1. Dengan kata lain, kami ingin kedua operasi penarikan dan pemberian kredit - dilakukan segera.  Jika salah satu dari mereka gagal, maka operasi kedua tidak boleh dilakukan.  Anda dapat menyebut prinsip ini "semua atau tidak sama sekali."  Selain itu, diharapkan bahwa operasi dilakukan secara serentak bahkan jika terjadi kegagalan sistemik seperti pemadaman listrik, yaitu, bahwa kita melihat sistem dalam keadaan yang dapat diterima segera setelah tersedia setelah pemulihan. <br><br>  Dalam istilah matematika, kita dapat mengatakan bahwa berkenaan dengan sistem ada invarian yang pasti ingin kita pertahankan.  Sebagai contoh, jumlah pada kedua akun: perlu bahwa setelah transaksi (pengiriman uang) jumlahnya tetap sama seperti sebelumnya.  By the way, dalam contoh transfer uang klasik, akuntansi juga muncul - area subjek di mana konsep transaksi muncul secara alami. <br><br>  Kami menggambarkan contoh mentransfer uang antara dua akun.  Gambar pertama menunjukkan situasi ketika transfer 50 rubel dari akun No. 1 ke akun No. 2 selesai dengan sukses.  Warna hijau menunjukkan bahwa sistem berada dalam kondisi yang dapat diterima (data lengkap). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sn/az/ra/snazracqgy0u8fdxtrtksb8jc7g.png"></div><br>  Sekarang bayangkan bahwa transfer dilakukan di luar transaksi dan setelah menarik uang dari akun No. 1, terjadi kegagalan, di mana uang yang ditarik tidak dikreditkan ke akun No. 2. Sistem akan berada dalam keadaan yang tidak dapat diterima (warna merah). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/8h/ph/yj8hphqu7cszpcdvnboh97h3xfe.png"></div><br>  Jika terjadi kesalahan antara operasi penarikan dan pemberian kredit, tetapi transfer dilakukan sebagai bagian dari satu transaksi, operasi penarikan akan dibatalkan.  Akibatnya, sistem akan tetap dalam kondisi semula yang dapat diterima. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/6b/wi/3d6bwim5vko1yam5mhiv1ekl9ve.png"></div><br>  Saya akan memberikan contoh situasi dari pengalaman perusahaan kami di mana transaksi berguna: akuntansi untuk barang (akuntansi untuk jumlah barang dari berbagai jenis yang ada di toko-toko tertentu dan dalam perjalanan), akuntansi untuk sumber daya penyimpanan (akuntansi untuk volume kamar yang ditempati oleh barang dari jenis tertentu, volume kamar, gratis untuk penempatan barang, jumlah barang yang dapat dipindahkan oleh karyawan dan sistem penyimpanan otomatis per hari). <br><br>  Masalah yang muncul saat integritas data dilanggar sudah jelas.  Informasi yang disediakan oleh sistem tidak hanya menjadi salah - ia kehilangan kontak dengan kenyataan dan berubah menjadi omong kosong. <br><br><a name="KindsOfTransactions"></a><h4>  Transaksi apa yang dipertimbangkan di sini </h4><br>  Manfaat yang diberikan oleh transaksi diketahui.  Jadi, untuk menjaga integritas data, apakah kita memerlukan basis data relasional, karena di situlah transaksi dilakukan?  Tidak juga.  Dikatakan di atas bahwa konsep transaksi tergantung pada konteksnya, dan sekarang kita akan secara singkat mempertimbangkan transaksi apa yang dapat kita bicarakan ketika membahas sistem informasi. <br><br>  Untuk memulainya, kami memisahkan konsep transaksi domain perihal (transaksi bisnis) dan transaksi sistem.  Yang kedua dapat diimplementasikan di tempat yang berbeda dan dengan cara yang berbeda. <br><br>  Mari kita pergi dari level tertinggi - area subjek.  Orang yang tertarik dapat menyatakan bahwa ada beberapa negara yang dapat diterima dan dia tidak ingin melihat sistem informasi di luar negara-negara ini.  Kami tidak akan memberikan contoh tambahan: mentransfer uang antar rekening cocok di sini.  Kami hanya mengklarifikasi bahwa transfer belum tentu merupakan transfer uang antara rekening penyelesaian dua pelanggan bank.  Yang tidak kalah penting adalah tugas akuntansi, ketika akun harus mencerminkan sumber dan tujuan dana organisasi, dan transfer harus mencerminkan perubahan dalam distribusi dana berdasarkan sumber dan tujuan ini.  Ini adalah contoh <b>transaksi domain perihal</b> . <br><br>  Sekarang mari kita lihat contoh paling umum dan menarik dari implementasi transaksi sistem.  Dalam transaksi sistem, berbagai cara teknis menyediakan persyaratan area subjek.  Solusi klasik yang terbukti dari jenis ini adalah <strong>transaksi DBMS relasional</strong> (contoh pertama).  Sistem manajemen basis data modern (baik yang bersifat relasional <a href="">maupun yang tidak terlalu</a> ) menyediakan mekanisme transaksi yang memungkinkan Anda untuk menyimpan (melakukan) semua perubahan yang dilakukan selama periode kerja tertentu, atau membuangnya (memutar kembali).  Ketika menggunakan mekanisme seperti itu, operasi penarikan uang dari satu akun dan mengkredit ke akun lain yang membentuk transaksi area subjek, sarana DBMS akan digabungkan menjadi sistem transaksi dan akan dieksekusi bersama atau tidak dilakukan sama sekali. <br><br>  Menggunakan DBMS, tentu saja, tidak perlu.  Secara kasar, Anda biasanya dapat menerapkan mekanisme transaksi DBMS dalam bahasa pemrograman favorit Anda dan menikmati analog yang tidak stabil dan bermasalah dari alat yang ada.  Tetapi "sepeda" Anda dapat dioptimalkan untuk situasi tertentu di area subjek. <br><br>  Ada opsi yang lebih menarik.  Bahasa pemrograman industri modern (C # dan Java di tempat pertama) menawarkan alat yang dirancang khusus untuk mengatur transaksi yang melibatkan subsistem yang sama sekali berbeda, dan bukan hanya DBMS.  Dalam publikasi ini, kami akan memanggil perangkat lunak transaksi tersebut.  Dalam kasus C #, ini adalah <b>transaksi dari System.Transaksi namespace</b> (contoh kedua), dan mereka dijelaskan di bawah ini. <br><br>  Sebelum pindah ke <code>System.Transactions</code> transaksi, seseorang tidak dapat gagal untuk menyebutkan satu lagi fenomena menarik.  Alat <code>System.Transactions</code> memungkinkan programmer untuk secara mandiri menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memori transaksi terprogram</a> .  Dalam hal ini, operasi program yang mempengaruhi keadaan sistem (dalam kasus bahasa pemrograman imperatif klasik, ini adalah operasi penugasan) secara default termasuk dalam transaksi yang dapat dilakukan dan dikembalikan seperti halnya transaksi DBMS.  Dengan pendekatan ini, kebutuhan untuk menggunakan mekanisme sinkronisasi (dalam C # - <code>lock</code> , dalam Java - <code>synchronized</code> ) berkurang secara signifikan.  Pengembangan lebih lanjut dari ide ini adalah <strong>memori transaksional perangkat lunak, didukung pada level platform</strong> (contoh ketiga).  Mukjizat semacam itu diharapkan dapat ditemukan dalam bahasa yang keanggunannya melampaui penerapan industri - Clojure.  Dan untuk bahasa pekerja-tani, ada perpustakaan plug-in yang menyediakan fungsionalitas memori transaksional terprogram. <br><br>  Sistem transaksi dapat mencakup beberapa sistem informasi, dalam hal ini mereka didistribusikan.  Terdistribusi dapat berupa transaksi dan perangkat lunak DBMS;  itu semua tergantung pada fungsionalitas apa yang didukung oleh alat transaksi tertentu.  Transaksi didistribusikan lebih rinci dibahas di bagian yang sesuai.  Saya akan memberikan gambar untuk membuatnya lebih mudah untuk memahami topik yang dibahas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/yd/4s/diyd4spwelqhd61eoetfacuncjm.png"></div><br><a name="TLDR1"></a><h4>  TL; bagian DR </h4><br>  Ada proses yang terdiri dari beberapa operasi (atom) yang tidak dapat dipisahkan yang diterapkan pada sistem, dalam kasus umum belum tentu bersifat informasi.  Setiap operasi yang tidak dapat dibagi dapat membuat sistem dalam keadaan tidak dapat diterima ketika integritas data terganggu.  Misalnya, jika transfer uang antara dua akun diwakili oleh dua operasi penarikan dari akun No. 1 yang tidak terpisahkan dan mengkredit ke akun No. 2, maka hanya satu dari operasi ini yang akan melanggar integritas data.  Uang entah menghilang di antah berantah, atau muncul di antah berantah.  Suatu transaksi menggabungkan operasi yang tidak dapat dibagi sehingga semuanya dilakukan bersama-sama (tentu saja, secara berurutan, jika perlu) atau tidak dilakukan sama sekali.  Kita dapat berbicara tentang transaksi domain dan transaksi dalam sistem teknis yang biasanya menerapkan transaksi domain. <br><br><a name="SystemTransactions"></a><h2>  Transaksi berdasarkan System.Transaksi </h2><br><a name="WhatIsIt1"></a><h4>  Apa ini </h4><br>  Di dunia .NET, ada kerangka kerja perangkat lunak yang dirancang oleh pencipta platform manajemen transaksi.  Dari perspektif programmer transaksional, kerangka kerja ini terdiri dari <code>TransactionScope</code> , <code>TransactionScopeOption</code> , <code>TransactionScopeAsyncFlowOption</code> dan <code>TransactionOptions</code> <code>System.Transactions</code> . Namespace <code>TransactionOptions</code> .  Jika kita berbicara tentang .NET Standard, maka semua ini tersedia mulai dengan <a href="">versi 2.0</a> . <br><br>  Transaksi dari <code>System.Transactions</code> namespace didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">standar X / Open XA dari The Open Group</a> .  Standar ini memperkenalkan banyak istilah yang dibahas di bawah ini, dan yang paling penting, menjelaskan transaksi terdistribusi, yang juga tercakup dalam publikasi ini di bagian khusus.  Implementasi transaksi perangkat lunak di platform lain, misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, Java,</a> didasarkan pada standar yang sama. <br><br>  Kasus penggunaan transaksi khas untuk programmer C # adalah sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { <span class="hljs-comment"><span class="hljs-comment">// -  ,    . scope.Complete(); }</span></span></code> </pre> <br>  Di dalam blok <code>using</code> adalah kode yang melakukan pekerjaan, yang hasilnya harus dilakukan atau dibatalkan bersama-sama.  Contoh klasik dari pekerjaan tersebut adalah membaca dan menulis ke database atau mengirim dan menerima pesan dari antrian.  Ketika kontrol meninggalkan blok <code>using</code> , transaksi akan dilakukan.  Jika Anda menghapus panggilan <code>Complete</code> , transaksi akan dibatalkan.  Cukup sederhana. <br><br>  Ternyata selama pengembalian transaksi, semua operasi yang dilakukan di dalam blok <code>using</code> akan dibatalkan?  Dan jika saya menetapkan variabel nilai yang berbeda, maka variabel ini akan mengembalikan nilai lama?  Ketika saya pertama kali melihat desain yang sama, saya pikir begitu.  Sebenarnya, tentu saja, tidak semua perubahan akan dibatalkan, tetapi hanya yang sangat <i>istimewa</i> .  Jika semua perubahan dibatalkan, maka ini akan menjadi memori transaksional perangkat lunak yang dijelaskan di atas.  Sekarang mari kita lihat apa perubahan khusus ini yang dapat berpartisipasi dalam transaksi program berdasarkan <code>System.Transactions</code> . <br><br><a name="ResourceManagers"></a><h4>  Manajer sumber daya </h4><br>  Untuk sesuatu untuk mendukung transaksi berdasarkan <code>System.Transactions</code> , perlu bahwa ia memiliki informasi bahwa transaksi saat ini sedang berlangsung, dan bahwa itu terdaftar di beberapa peserta pendaftaran transaksi.  Anda dapat memperoleh informasi tentang apakah pekerjaan transaksional sedang berlangsung dengan memeriksa properti statis <code>Current</code> of <code>System.Transactions.Transaction</code> class.  Memasuki blok <code>using</code> tipe yang ditunjukkan di atas hanya menyetel properti ini, jika belum disetel sebelumnya.  Dan untuk mendaftar sebagai peserta dalam transaksi, Anda dapat menggunakan metode bertipe <code>Transaction.Enlist <i>Smth</i></code> .  Selain itu, Anda perlu mengimplementasikan antarmuka yang diperlukan oleh metode ini.  Resource Manager - ini hanyalah "sesuatu" yang mendukung interaksi dengan transaksi dari <code>System.Transactions</code> (definisi yang lebih spesifik diberikan di bawah). <br><br>  Apa itu manajer sumber daya?  Jika kita bekerja dari C # dengan DBMS, misalnya, SQL Server atau Database Oracle, maka kita biasanya menggunakan driver yang sesuai, dan mereka adalah sumber daya pengelolaan.  Dalam kode, mereka diwakili oleh jenis <code>System.Data.SqlClient.SqlConnection</code> dan <code>Oracle.ManagedDataAccess.Client.OracleConnection</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mereka juga mengatakan</a> bahwa MSMQ mendukung transaksi berdasarkan <code>System.Transactions</code> .  Dipandu oleh pengetahuan dan contoh-contoh yang diambil dari Internet, Anda dapat membuat manajer sumber daya Anda sendiri.  Contoh paling sederhana diberikan pada bagian selanjutnya. <br><br>  Selain manajer sumber daya, kita juga harus memiliki Manajer Transaksi, yang akan memantau transaksi dan memberikan pesanan kepada manajer sumber daya secara tepat waktu.  Bergantung pada manajer sumber daya mana yang terlibat dalam transaksi (karakteristik apa yang mereka miliki dan di mana mereka berada), manajer transaksi yang berbeda terhubung ke pekerjaan.  Dalam hal ini, pemilihan versi yang sesuai adalah otomatis dan tidak memerlukan intervensi seorang programmer. <br><br>  Lebih spesifik, manajer sumber daya adalah turunan dari kelas yang mengimplementasikan antarmuka <code>System.Transactions.IEnlistmentNotification</code> khusus.  Instance kelas, seperti yang diarahkan oleh klien, terdaftar sebagai peserta dalam transaksi menggunakan <code>System.Transactions.Transaction.Current</code> properti statis.Transaksi.Transaksi.Current.  Selanjutnya, manajer transaksi memanggil metode dari antarmuka yang ditentukan sebagaimana diperlukan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tw/ea/vp/tweavpimeod539do_fkzpr6yzrw.png"></div><br>  Jelas bahwa pada saat run time, himpunan manajer sumber daya yang terlibat dalam transaksi dapat berubah.  Misalnya, setelah memasukkan blok <code>using</code> , pertama-tama kita dapat melakukan sesuatu di SQL Server, dan kemudian di Oracle Database.  Tergantung pada set manajer sumber daya ini, manajer transaksi yang digunakan ditentukan.  Untuk lebih tepatnya, protokol transaksional yang digunakan ditentukan oleh himpunan manajer sumber daya, dan manajer transaksi yang mendukungnya ditentukan berdasarkan protokol.  Kita akan melihat protokol transaksional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nanti</a> ketika kita berbicara tentang transaksi yang didistribusikan.  Mekanisme untuk secara otomatis memilih manajer transaksi yang sesuai pada waktu berjalan ketika mengubah manajer sumber daya yang terlibat dalam transaksi disebut Promosi Transaksi. <br><br><a name="KindsOfResourceManagers"></a><h4>  Jenis Manajer Sumber Daya </h4><br>  Manajer sumber daya dapat dibagi menjadi dua kelompok besar: tahan lama dan variabel. <br><br>  Durable Resource Manager - manajer sumber daya yang mendukung transaksi bahkan jika sistem informasi tidak tersedia (misalnya, ketika komputer dinyalakan kembali).  Volatile Resource Manager - manajer sumber daya yang tidak mendukung transaksi jika sistem informasi tidak tersedia.  Manajer sumber daya yang tidak konsisten hanya mendukung transaksi dalam memori. <br><br>  Manajer sumber daya jangka panjang klasik adalah DBMS (atau driver DBMS untuk platform perangkat lunak).  Tidak peduli apa yang terjadi - setidaknya kerusakan pada sistem operasi, setidaknya pemadaman listrik - DBMS akan menjamin integritas data setelah kembali ke kondisi kerja.  Untuk ini, tentu saja, Anda harus membayar beberapa ketidaknyamanan, tetapi dalam artikel ini kami tidak akan mempertimbangkannya.  Contoh dari manajer sumber daya non-persisten adalah memori transaksional perangkat lunak yang disebutkan di atas. <br><br><a name="TransactionScope"></a><h4>  Menggunakan TransactionScope </h4><br>  Saat membuat objek bertipe <code>TransactionScope</code> Anda dapat menentukan beberapa parameter. <br><br>  Pertama, ada pengaturan yang memberi tahu runtime apa yang dibutuhkan: <br><br><ol><li>  Gunakan transaksi yang sudah ada saat ini; </li><li>  Pastikan untuk membuat yang baru; </li><li>  sebaliknya, jalankan kode di dalam blok <code>using</code> luar transaksi. </li></ol><br>  <code>System.Transactions.TransactionScopeOption</code> bertanggung jawab untuk semua ini. <br><br>  Kedua, Anda dapat mengatur tingkat isolasi transaksi.  Ini adalah parameter yang memungkinkan Anda menemukan kompromi antara independensi perubahan dan kecepatan.  Level paling independen - serializable - memastikan bahwa tidak ada situasi di mana perubahan yang dilakukan dalam satu transaksi yang belum dilakukan dapat dilihat dalam transaksi lain.  Setiap level berikutnya menambahkan satu situasi spesifik seperti itu, ketika secara bersamaan menjalankan transaksi dapat saling memengaruhi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara default, transaksi dibuka pada tingkat serializable, yang bisa jadi tidak menyenangkan (lihat, misalnya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komentar ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menetapkan tingkat isolasi transaksi selama pembuatan </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah nasihat untuk manajer sumber daya. Mereka bahkan mungkin tidak mendukung semua level yang terdaftar </font></font><code>System.Transactions.IsolationLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Selain itu, harus diingat bahwa ketika menggunakan pool koneksi untuk bekerja dengan database, koneksi yang tingkat isolasi transaksi telah diubah akan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mempertahankan level ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setelah kembali ke pool </font><font style="vertical-align: inherit;">. Sekarang, ketika programmer menerima koneksi ini dari pool dan bergantung pada nilai default, ia akan mengamati perilaku yang tidak terduga. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skenario kerja tipikal c</font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan perangkap yang signifikan (yaitu, transaksi bersarang) tercakup dengan baik dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel ini tentang "Habr"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="Applicability"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penerapan Transaksi Perangkat Lunak </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harus dikatakan bahwa di hampir semua sistem informasi dalam operasi komersial, proses diluncurkan yang dapat menyebabkan sistem ke keadaan yang tidak dapat diterima. </font><font style="vertical-align: inherit;">Oleh karena itu, mungkin perlu untuk mengontrol proses ini, mencari tahu apakah keadaan sistem saat ini dapat diterima, dan, jika tidak, kembalikan. </font><font style="vertical-align: inherit;">Transaksi perangkat lunak - alat siap pakai untuk menjaga sistem dalam keadaan yang dapat diterima. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam setiap kasus, konstruktif untuk mempertimbangkan biaya:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengintegrasikan proses ke dalam infrastruktur transaksi perangkat lunak (proses-proses ini juga perlu memperhatikan </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">banyak hal lain);</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memelihara infrastruktur ini (misalnya, biaya menyewa peralatan dengan Windows on board); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pelatihan karyawan (karena topik transaksi .NET tidak umum). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita tidak boleh lupa bahwa proses transaksi mungkin diminta untuk melaporkan kemajuannya ke "dunia luar", misalnya, untuk membuat jurnal tindakan di luar transaksi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas, penolakan transaksi perangkat lunak akan membutuhkan penciptaan atau implementasi beberapa cara lain untuk menjaga integritas data, yang juga akan memiliki nilainya. </font><font style="vertical-align: inherit;">Pada akhirnya, mungkin ada kasus-kasus di mana pelanggaran integritas data sangat jarang terjadi sehingga lebih mudah untuk memulihkan keadaan sistem yang dapat diterima dengan intervensi bedah daripada mempertahankan mekanisme pemulihan otomatis.</font></font><br><br><a name="Example"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contoh manajer sumber daya yang berubah-ubah </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita lihat contoh manajer sumber daya sederhana yang tidak mendukung pemulihan dari kegagalan sistem. Kami akan memiliki blok memori transaksional perangkat lunak yang menyimpan beberapa nilai yang dapat dibaca dan ditulis. Dengan tidak adanya transaksi, blok ini berperilaku seperti variabel normal, dan di hadapan transaksi, ia menyimpan nilai awal, yang dapat dikembalikan setelah transaksi tersebut dibatalkan. Kode untuk manajer sumber daya disajikan di bawah ini:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Stm</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Transactions</span></span>.<span class="hljs-title"><span class="hljs-title">IEnlistmentNotification</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T _current; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T _original; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _enlisted; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _current; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Enlist()) { _original = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } _current = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stm</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { _current = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; _original = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enlist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_enlisted) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentTx = System.Transactions.Transaction.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentTx == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; currentTx.EnlistVolatile(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, System.Transactions.EnlistmentOptions.None); _enlisted = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> IEnlistmentNotification public void Commit(System.Transactions.Enlistment enlistment) { _original = _current; _enlisted = false; } public void InDoubt(System.Transactions.Enlistment enlistment) { _enlisted = false; } public void Prepare(System.Transactions.PreparingEnlistment preparingEnlistment) { preparingEnlistment.Prepared(); } public void Rollback(System.Transactions.Enlistment enlistment) { _current = _original; _enlisted = false; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> IEnlistmentNotification }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dapat dilihat bahwa satu-satunya persyaratan formal adalah implementasi antarmuka </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Yang menarik, metode </font></font><code>Enlist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(yang bukan merupakan bagian </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dan </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Metode </font></font><code>Enlist</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya memeriksa apakah kode yang diberikan bekerja dalam kerangka transaksi, dan, jika demikian, mendaftarkan instance kelasnya sebagai manajer sumber daya yang tidak konstan. Metode </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini dipanggil oleh manajer transaksi sebelum melakukan perubahan. Manajer sumber daya kami menandakan kesiapannya untuk berkomitmen dengan memanggil metode </font></font><code>System.Transactions.PreparingEnlistment.Prepared</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini adalah kode yang menunjukkan contoh menggunakan manajer sumber daya kami:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stm&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { stm.Value = <span class="hljs-number"><span class="hljs-number">2</span></span>; scope.Complete(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membaca properti </font><font style="vertical-align: inherit;">segera setelah keluar dari blok </font></font><code>stm.Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka nilai yang diharapkan akan diharapkan di sana </font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dan jika Anda menghapus panggilan </font></font><code>scope.Complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, transaksi akan dibatalkan dan properti </font></font><code>stm.Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan memiliki nilai yang </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditetapkan sebelum dimulainya transaksi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan panggilan yang disederhanakan ketika bekerja dengan transaksi </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditunjukkan pada diagram di bawah ini.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/09/je/1d/09je1dkghhmmwts6rvaufuntpna.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dapat dilihat bahwa dalam contoh ini, tidak semua kemungkinan yang disediakan oleh infrastruktur dipertimbangkan </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami akan mempertimbangkannya lebih lengkap setelah kami mengenal protokol transaksional dan mendistribusikan transaksi di bagian selanjutnya.</font></font><br><br><a name="TLDR2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TL; bagian DR </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seorang programmer dapat menggunakan kelas </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengeksekusi beberapa kode dalam transaksi yang ada atau baru. Suatu transaksi dilakukan jika dan hanya jika </font></font><code>TransactionScope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode dipanggil </font><font style="vertical-align: inherit;">pada instance kelas yang ada </font></font><code>Dispose</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, meskipun metode itu dipanggil sebelumnya</font></font><code>Complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Seorang programmer dapat menunjukkan apakah dia ingin memulai transaksi baru, mengambil keuntungan dari yang sudah ada, atau, sebaliknya, mengeksekusi kode di luar transaksi yang sudah ada. Hanya manajer sumber daya yang terlibat dalam transaksi - komponen perangkat lunak yang menerapkan fungsi tertentu. Manajer sumber daya bisa bersifat jangka panjang (pulih dari kegagalan sistem) dan intermiten (tidak pulih). DBMS adalah contoh manajer sumber daya yang berumur panjang. Manajer sumber daya dikoordinasikan oleh manajer transaksi - komponen perangkat lunak yang secara otomatis dipilih oleh runtime tanpa partisipasi programmer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajer sumber daya tidak konsisten adalah kelas yang mengimplementasikan antarmuka </font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam metode ini</font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengkonfirmasikan kesiapannya untuk melakukan perubahan atau, sebaliknya, menandakan kemunduran perubahan. </font><font style="vertical-align: inherit;">Ketika penelepon melakukan sesuatu dengan manajer sumber daya, dia memeriksa untuk melihat apakah transaksi terbuka sekarang, dan jika terbuka, masuk menggunakan metode </font></font><code>System.Transactions.Transaction.EnlistVolatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="DistributedTransactions"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transaksi Terdistribusi </font></font></h2><br><a name="WhatIsIt2"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa ini </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaksi terdistribusi melibatkan beberapa subsistem informasi (pada kenyataannya, tidak semuanya begitu sederhana, lebih lanjut tentang ini di bawah). </font><font style="vertical-align: inherit;">Dapat dipahami bahwa perubahan dalam semua sistem yang terlibat dalam transaksi terdistribusi harus dilakukan atau dibatalkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berbagai cara untuk mengimplementasikan transaksi disajikan di atas: DBMS, infrastruktur </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan memori transaksional terprogram yang dibangun ke dalam platform. </font><font style="vertical-align: inherit;">Transaksi terdistribusi juga dapat disediakan dengan alat-alat ini. </font><font style="vertical-align: inherit;">Misalnya, dalam Oracle Database, mengubah (dan benar-benar membaca) data dalam beberapa database dalam satu transaksi secara otomatis mengubahnya menjadi yang terdistribusi. </font><font style="vertical-align: inherit;">Selanjutnya, kita akan berbicara tentang transaksi yang didistribusikan perangkat lunak, yang mungkin termasuk manajer sumber daya yang heterogen.</font></font><br><br><a name="TransactionProtocols"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protokol transaksional </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokol transaksional adalah seperangkat prinsip dimana aplikasi yang terlibat dalam transaksi berinteraksi. Di dunia .NET, protokol berikut ini paling sering ditemukan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ringan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak ada lebih dari satu manajer sumber daya tahan lama yang digunakan. Semua interaksi transaksional terjadi dalam domain aplikasi yang sama, atau manajer sumber daya mendukung promosi dan komitmen satu fase (implementasi </font></font><code>IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OleTx.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interoperabilitas antara beberapa domain aplikasi dan beberapa komputer diperbolehkan. Anda dapat menggunakan banyak manajer sumber daya yang tahan lama. Semua komputer yang berpartisipasi harus menjalankan Windows. Gunakan Panggilan Prosedur Jarak Jauh (RPC). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WS-AT.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interoperabilitas antara beberapa domain aplikasi dan beberapa komputer diperbolehkan. Anda dapat menggunakan banyak manajer sumber daya yang tahan lama. Komputer yang berpartisipasi mungkin menjalankan berbagai OS, bukan hanya Windows. Hypertext Transmission Protocol (HTTP) digunakan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telah dicatat di atas bahwa protokol transaksi saat ini mempengaruhi pilihan manajer transaksi, dan karakteristik sumber daya kontrol yang terlibat dalam transaksi mempengaruhi pilihan protokol. Sekarang kami daftar manajer transaksi yang terkenal. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajer Transaksi Ringan (LTM)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diperkenalkan di .NET Framework 2.0 dan yang lebih baru. Mengelola transaksi menggunakan protokol Ringan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajer Transaksi Kernel (KTM)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diperkenalkan pada Windows Vista dan Windows Server 2008. Mengelola transaksi menggunakan protokol Ringan. Itu dapat memanggil Sistem File Transaksional (TxF) dan Transaksional Registry (TxR) pada Windows Vista dan Windows 2008. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koordinator Transaksi Terdistribusi (MSDTC)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mengelola transaksi menggunakan protokol OleTx dan WS-AT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga harus diingat bahwa beberapa manajer sumber daya tidak mendukung semua protokol yang terdaftar. Misalnya, MSMQ dan SQL Server 2000 tidak mendukung Ringan, sehingga transaksi yang melibatkan MSMQ atau SQL Server 2000 akan dikelola oleh MSDTC, bahkan jika mereka adalah satu-satunya peserta. Secara teknis, batasan ini muncul dari kenyataan bahwa manajer sumber daya yang ditentukan, menerapkan, tentu saja, antarmuka</font></font><code>System.Transactions.IEnlistmentNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jangan mengimplementasikan antarmuka </font></font><code>System.Transactions.IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini berisi, antara lain, metode </font></font><code>Promote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang dipanggil runtime, jika perlu, untuk beralih ke manajer transaksi yang lebih curam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambiguitas konsep transaksi terdistribusi sekarang menjadi jelas. </font><font style="vertical-align: inherit;">Misalnya, Anda dapat mendefinisikan transaksi terdistribusi sebagai transaksi di mana ia berpartisipasi:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setidaknya dua dari manajer sumber daya; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> manajer sumber daya variabel sewenang-wenang dan setidaknya dua berumur panjang; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setidaknya dua dari setiap manajer sumber daya selalu berada di komputer yang berbeda. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena itu, lebih baik untuk selalu mengklarifikasi transaksi tertentu yang terlibat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan dalam konteks ini, MSDTC terutama dibahas. </font><font style="vertical-align: inherit;">Ini adalah komponen perangkat lunak Windows yang mengelola transaksi terdistribusi. </font><font style="vertical-align: inherit;">Ada antarmuka grafis untuk mengkonfigurasi dan memantau transaksi, yang dapat ditemukan dalam utilitas "Layanan Komponen", mengikuti jalur "Komputer - Komputer Saya - Koordinator Transaksi Terdistribusi - DTC Lokal".</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vo/35/gc/vo35gcdta3c9qx5w5cnsuxkbzz8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk konfigurasi, pilih item "Properti" di menu konteks simpul "DTC Lokal", dan untuk memantau transaksi yang didistribusikan, pilih item "Statistik transaksi" di panel pusat. </font></font><br><br><a name="TwoPhaseCommit"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fiksasi bifasik </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika beberapa manajer sumber daya berpartisipasi dalam transaksi, hasil pekerjaan mereka mungkin berbeda: misalnya, salah satu dari mereka selesai dengan sukses, dan dia siap untuk melakukan perubahan, dan yang lainnya memiliki kesalahan, dan dia akan memutar balik perubahan. Namun, esensi dari transaksi terdistribusi terletak pada kenyataan bahwa perubahan dalam semua sumber daya kontrol yang terlibat dalam transaksi itu dilakukan bersama-sama atau dibatalkan. Oleh karena itu, dalam kasus seperti itu, protokol fiksasi dua fase biasanya digunakan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, inti dari protokol ini adalah sebagai berikut. Selama </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fase pertama</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajer sumber daya yang terlibat dalam transaksi menyiapkan informasi yang cukup untuk pulih dari kegagalan (jika merupakan manajer sumber daya jangka panjang) dan untuk penyelesaian yang berhasil sebagai hasil dari komitmen. Dari sudut pandang teknis, manajer sumber daya menandakan bahwa ia telah menyelesaikan fase pertama dengan memanggil metode </font></font><code>System.Transactions.PreparingEnlistment.Prepared</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam metode tersebut </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Atau manajer sumber daya dapat memberi tahu Anda bahwa perubahan telah dibatalkan dengan memanggil metode </font></font><code>ForceRollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika semua manajer sumber daya yang terlibat dalam transaksi "memilih", yaitu, mereka memberi tahu manajer transaksi apakah mereka ingin melakukan atau mengembalikan perubahan, </font><b><font style="vertical-align: inherit;">tahap kedua</font></b><font style="vertical-align: inherit;"> dimulai</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pada saat ini, manajer sumber daya diinstruksikan untuk melakukan perubahan mereka (jika semua peserta memilih untuk memperbaiki) atau untuk menolak perubahan (jika setidaknya satu peserta memilih untuk mengembalikan). Secara teknis, ini dinyatakan dalam doa metode </font></font><code>Commit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang diterapkan oleh manajer sumber daya </font><font style="vertical-align: inherit;">dan </font><font style="vertical-align: inherit;">metode </font><font style="vertical-align: inherit;">yang mereka gunakan </font></font><code>System.Transactions.Enlistment.Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajer sumber daya juga dapat memanggil metode </font></font><code>System.Transactions.Enlistment.Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selama fase pertama. Dalam hal ini, dipahami bahwa ia tidak akan melakukan perubahan apa pun (misalnya, hanya berfungsi untuk membaca) dan tidak akan berpartisipasi dalam fase kedua. Baca lebih lanjut tentang komitmen dua fase </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di Microsoft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika koneksi antara manajer transaksi dan setidaknya salah satu manajer sumber daya terputus, transaksi menjadi beku ("ragu", tidak diragukan). </font><font style="vertical-align: inherit;">Manajer transaksi, dengan memanggil metode </font></font><code>InDoubt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, memberi tahu manajer sumber daya yang tersedia tentang peristiwa ini yang dapat merespons dengan tepat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masih ada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fiksasi tiga fase</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan modifikasi dengan kelebihan dan kekurangannya. </font><font style="vertical-align: inherit;">Protokol komit tiga fase kurang umum, mungkin karena memerlukan lebih banyak biaya komunikasi antara subsistem yang berinteraksi.</font></font><br><br><a name="Interfaces"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cheat sheet pada antarmuka System.Transactions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sesuatu itu sulit. Untuk menyortir sedikit, saya akan menjelaskan secara singkat antarmuka namespace utama yang </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diperlukan untuk membuat manajer sumber daya. Berikut adalah diagram kelas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/rj/sx/bsrjsxptqz6w3g7l6zxawrzeyco.png"></div><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IEnlistmentNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manajer sumber daya mengimplementasikan antarmuka ini. Manajer transaksi memanggil metode yang diterapkan dalam urutan berikut. Selama fase pertama, ia memanggil metode </font></font><code>Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(kecuali bintang-bintang berkumpul untuk memanggil metode </font></font><code>ISinglePhaseNotification.SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seperti yang dijelaskan dalam paragraf berikutnya). Di bawah metode ini, manajer sumber daya menyimpan informasi yang diperlukan untuk pulih dari kegagalan, mempersiapkan komitmen akhir dari perubahan di pihaknya, dan memberikan suara untuk melakukan atau mengembalikan perubahan. Jika ada datang tahap kedua, tergantung pada ketersediaan sumber daya dan kontrol dari hasil voting dari transaksi kontrol adalah salah satu dari tiga metode: </font></font><code>Commit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>InDoubt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISinglePhaseNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajer sumber daya mengimplementasikan antarmuka ini jika ia ingin memberikan manajer transaksi kesempatan untuk mengoptimalkan eksekusi dengan mengurangi fase komit kedua. Jika manajer transaksi hanya melihat satu manajer sumber daya, maka pada tahap komit pertama ia mencoba memanggil metode manajer sumber daya </font></font><code>SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(sebagai gantinya </font></font><code>IEnlistmentNotification.Prepare</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dan dengan demikian mengecualikan pemungutan suara dan transisi ke fase kedua. Pendekatan ini memiliki kelebihan dan kekurangan, yang paling jelas ditulis oleh Microsoft di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ITransactionPromoter.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manajer sumber daya mengimplementasikan antarmuka ini (tidak hanya secara langsung, tetapi melalui antarmuka</font></font><code>IPromotableSinglePhaseNotification</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), jika dia ingin memberikan manajer transaksi dengan kemampuan untuk mematuhi protokol Ringan bahkan ketika panggilan jarak jauh, sampai kondisi lain muncul yang memerlukan komplikasi protokol. Ketika Anda perlu menyulitkan protokol, metode akan dipanggil </font></font><code>Promote</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPromotableSinglePhaseNotification.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manajer sumber daya mengimplementasikan antarmuka ini dalam urutan, pertama, untuk mengimplementasikan antarmuka </font></font><code>ITransactionPromoter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kedua, sehingga manajer transaksi dapat menggunakan komit fase tunggal, metode panggilan </font></font><code>IPromotableSinglePhaseNotification.SinglePhaseCommit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>IPromotableSinglePhaseNotification.Rollback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Manajer transaksi memanggil metode </font></font><code>IPromotableSinglePhaseNotification.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menandai keberhasilan pendaftaran manajer sumber daya dengan cara yang disederhanakan. Lebih atau kurang, ini dapat dipahami dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dokumen Microsoft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat sedikit lagi</font></font><code>System.Transactions.Enlistment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan ahli warisnya. Jenis instance ini disediakan oleh manajer transaksi ketika ia memanggil metode antarmuka yang diterapkan oleh manajer sumber daya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/bd/xc/qibdxcddktegq5h2xnpuaelygj0.png"></div><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendaftaran. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajer sumber daya dapat memanggil metode tunggal dari jenis ini - </font></font><code>Done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, - untuk menandai keberhasilan penyelesaian bagian pekerjaannya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mempersiapkan Pendaftaran. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan instance dari jenis ini selama fase komit pertama, manajer sumber daya dapat menandakan niatnya untuk melakukan atau memutar balik perubahan. </font><font style="vertical-align: inherit;">Manajer sumber daya yang berumur panjang juga bisa mendapatkan informasi yang diperlukan untuk pulih dari kegagalan sistem. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SinglePhaseEnlistment. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan instance dari jenis ini, manajer sumber daya dapat mengirimkan informasi kepada manajer transaksi tentang hasil pekerjaannya menggunakan skema yang disederhanakan (komitmen fase tunggal).</font></font><br><br><a name="LimitationsAndAlternatives"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Batasan dan Alternatif Transaksi Terdistribusi oleh Perangkat Lunak </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebuah studi singkat tentang pendapat yang ditemukan di Internet menunjukkan bahwa di banyak daerah, transaksi yang didistribusikan tidak lagi populer. Lihatlah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komentar jahat ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , misalnya </font><font style="vertical-align: inherit;">. Objek utama kritik, yang disebutkan secara singkat di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , adalah sifat sinkron (memblokir) transaksi yang didistribusikan. Jika pengguna mengirim permintaan selama pemrosesan transaksi terdistribusi diatur, maka ia akan menerima respons hanya setelah (berhasil atau dengan kesalahan) semua subsistem yang termasuk dalam transaksi selesai berfungsi. Pada saat yang sama, ada pendapat yang didukung oleh penelitian bahwa protokol komitmen dua fase menunjukkan kinerja yang buruk, terutama dengan peningkatan jumlah subsistem yang terlibat dalam transaksi, seperti disebutkan, misalnya, dalam</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">publikasi ini di "HabrÃ©"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika pencipta sistem lebih suka mengembalikan jawaban kepada pengguna sesegera mungkin, menunda koordinasi data untuk nanti, maka beberapa solusi lain akan lebih cocok untuknya. Dalam konteks teorema Brewer (teorema </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CAP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), kita dapat mengatakan bahwa transaksi terdistribusi cocok untuk kasus-kasus di mana konsistensi data lebih penting daripada ketersediaan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada batasan praktis lain dalam penggunaan transaksi yang didistribusikan perangkat lunak. Misalnya, secara eksperimental ditetapkan bahwa transaksi terdistribusi menggunakan protokol OleTx tidak boleh melintasi domain jaringan. Bagaimanapun, upaya panjang untuk membuat mereka bekerja tidak berhasil. Selain itu, terungkap bahwa interaksi antara beberapa contoh Oracle Database (transaksi database terdistribusi) memberlakukan pembatasan serius pada penerapan transaksi perangkat lunak yang didistribusikan (sekali lagi, gagal untuk memulai).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa alternatif untuk transaksi terdistribusi? Pertama, saya harus mengatakan bahwa itu akan sangat sulit dilakukan tanpa transaksi teknis (normal, tidak didistribusikan). Mungkin ada beberapa proses dalam sistem yang dapat mengganggu integritas data untuk sementara waktu, dan bagaimanapun juga perlu untuk memberikan pengawasan terhadap proses tersebut. Dengan cara yang sama, dalam hal area subjek, sebuah konsep dapat muncul yang mencakup proses yang diimplementasikan oleh serangkaian proses dalam sistem teknis yang berbeda, yang harus dimulai dan berakhir di bidang data integral. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beralih ke alternatif untuk transaksi terdistribusi, kami dapat mencatat solusi berdasarkan layanan pesan, seperti RabbitMQ dan Apache Kafka. Dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">publikasi ini tentang "HabrÃ©"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> empat solusi tersebut dipertimbangkan:</font></font><br><br><ol><li>   ,        ,    ; </li><li>    ,           (Transaction Log Tailing); </li><li>       ,       ; </li><li>             (Event Sourcing). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternatif lain adalah template Saga. Ini melibatkan kaskade subsistem dengan transaksi lokalnya. Setelah menyelesaikan pekerjaan, setiap sistem memanggil yang berikut (baik secara mandiri atau dengan bantuan koordinator). Untuk setiap transaksi ada transaksi pembatalan terkait, dan alih-alih mentransfer kontrol, subsistem dapat memulai pembatalan perubahan yang dibuat sebelumnya oleh subsistem sebelumnya. Di "HabrÃ©" ada beberapa artikel bagus tentang templat "Saga". Misalnya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">publikasi ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyediakan informasi umum tentang mempertahankan prinsip-prinsip ACID dalam layanan-layanan microser, dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> merinci contoh penerapan templat Saga dengan koordinator.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di perusahaan kami, beberapa produk berhasil menggunakan transaksi yang didistribusikan perangkat lunak melalui WCF, tetapi ada opsi lain. Suatu ketika, ketika kami mencoba berteman dengan sistem baru dengan transaksi terdistribusi, kami memiliki banyak masalah, termasuk tabrakan dengan batasan yang dijelaskan di atas dan masalah paralel dengan memperbarui infrastruktur perangkat lunak. Oleh karena itu, dalam kondisi kekurangan sumber daya untuk menjalankan keputusan modal lainnya, kami menerapkan taktik berikut. Pihak yang dipanggil menangkap perubahan dalam kasus apa pun, tetapi mencatat bahwa mereka dalam keadaan konsep, sehingga perubahan ini belum mempengaruhi operasi sistem yang disebut. Kemudian, penelepon, ketika menyelesaikan pekerjaannya melalui transaksi terdistribusi, DBMS mengaktifkan perubahan yang dibuat oleh sistem yang dipanggil. Dengan cara inialih-alih transaksi yang didistribusikan perangkat lunak, kami menggunakan transaksi DBMS terdistribusi, yang dalam hal ini ternyata jauh lebih andal.</font></font><br><br><a name="NetCore"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jadi, apakah itu dalam. NET Core? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam .NET Core (dan bahkan dalam .NET Standard) ada semua jenis yang diperlukan untuk mengatur transaksi dan membuat manajer sumber daya Anda sendiri. </font><font style="vertical-align: inherit;">Sayangnya, dalam .NET Core, transaksi berbasis </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki batasan serius: mereka hanya bekerja dengan protokol yang Ringan. </font><font style="vertical-align: inherit;">Misalnya, jika dua manajer sumber daya tahan lama digunakan dalam kode, maka saat runtime, lingkungan akan mengeluarkan pengecualian segera setelah manajer kedua dipanggil.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faktanya adalah bahwa mereka mencoba untuk membuat .NET Core independen dari sistem operasi, sehingga tautan ke manajer transaksi seperti KTM dan MSDTC dikecualikan, yaitu mereka diperlukan untuk mendukung transaksi dengan properti yang ditentukan. </font><font style="vertical-align: inherit;">Ada kemungkinan bahwa koneksi manajer transaksi akan diimplementasikan dalam bentuk plug-in, tetapi sejauh ini telah ditulis dengan garpu rumput, sehingga Anda tidak dapat bergantung pada penggunaan industri dari transaksi yang didistribusikan di .NET Core. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari pengalaman, Anda dapat memverifikasi perbedaan dalam transaksi terdistribusi dalam .NET Framework dan .NET Core dengan menulis kode yang sama, menyusun dan menjalankannya pada platform yang berbeda.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh kode yang memanggil SQL Server dan Oracle Database secara berurutan.</font></font></b> <div class="spoiler_text"><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Transactions.TransactionScope(System.Transactions.TransactionScopeOption.Required)) { MsSqlServer(); Oracle(); scope.Complete(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Oracle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Oracle.ManagedDataAccess.Client.OracleConnection(<span class="hljs-string"><span class="hljs-string">"User Id=some_user;Password=some_password;Data Source=some_db"</span></span>)) { conn.Open(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cmd = conn.CreateCommand()) { cmd.CommandText = <span class="hljs-string"><span class="hljs-string">"update t_hello set id_hello = 2 where id_hello = 1"</span></span>; cmd.ExecuteNonQuery(); } conn.Close(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MsSqlServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Data.SqlClient.SqlConnectionStringBuilder { DataSource = <span class="hljs-string"><span class="hljs-string">"some_computer\\some_db"</span></span>, UserID = <span class="hljs-string"><span class="hljs-string">"some_user"</span></span>, Password = <span class="hljs-string"><span class="hljs-string">"some_password"</span></span>, InitialCatalog = <span class="hljs-string"><span class="hljs-string">"some_scheme"</span></span>, Enlist = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Data.SqlClient.SqlConnection(builder.ConnectionString)) { conn.Open(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cmd = conn.CreateCommand()) { cmd.CommandText = <span class="hljs-string"><span class="hljs-string">"update t_hello set id_hello = 2 where id_hello = 1"</span></span>; cmd.ExecuteNonQuery(); } conn.Close(); } }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyek siap bangun </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada di GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menjalankan contoh untuk .NET Core gagal. </font><font style="vertical-align: inherit;">Tempat dan jenis pengecualian yang dilemparkan bergantung pada urutan panggilan DBMS, tetapi dalam hal apa pun, pengecualian ini menunjukkan operasi transaksi yang tidak valid. </font><font style="vertical-align: inherit;">Menjalankan contoh untuk .NET Framework berhasil jika MSDTC berjalan saat ini; </font><font style="vertical-align: inherit;">namun, dalam antarmuka grafis MSDTC, Anda dapat mengamati registrasi transaksi terdistribusi.</font></font><br><br><a name="WCF"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transaksi Terdistribusi dan WCF </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows Communication Foundation (WCF) adalah .NET framework untuk mengatur dan menjalankan layanan jaringan. Dibandingkan dengan pendekatan REST dan ASP.NET Web API yang lebih modis, ia memiliki kelebihan dan kekurangannya sendiri. WCF adalah teman yang sangat baik dengan transaksi .NET, dan dalam dunia .NET Framework, nyaman untuk menggunakannya untuk mengatur transaksi yang didistribusikan antara klien dan layanan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di .NET Core, teknologi ini hanya berfungsi di sisi klien, yaitu, Anda tidak dapat membuat layanan, tetapi Anda hanya bisa merujuk ke yang sudah ada. Namun, ini tidak terlalu penting, karena, sebagaimana disebutkan di atas, dengan transaksi terdistribusi di .NET Core, semuanya tidak berjalan dengan baik. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara kerja WCF</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagi pembaca yang tidak terbiasa dengan WCF, berikut adalah informasi latar belakang terpendek tentang apa teknologi ini dalam praktiknya. Konteks - dua sistem informasi yang disebut klien dan layanan. Klien saat runtime mengakses sistem informasi lain yang mendukung layanan yang menarik bagi klien, dan mengharuskan beberapa operasi dilakukan. Kemudian manajemen dikembalikan ke klien.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat layanan di WCF, Anda biasanya perlu menulis antarmuka yang menjelaskan kontrak untuk layanan yang dibuat dan kelas yang mengimplementasikan antarmuka ini. Kelas dan antarmuka ditandai dengan atribut WCF khusus yang membedakan mereka dari jenis lainnya dan menentukan beberapa detail perilaku selama penemuan dan doa layanan. Tipe-tipe ini dibungkus dengan sesuatu yang berfungsi sebagai server (misalnya, dalam DLL yang diatur IIS), dan dilengkapi dengan file konfigurasi (ada opsi), di mana rincian implementasi layanan ditunjukkan. Setelah memulai, layanan dapat diakses, misalnya, di alamat jaringan; di browser Internet Anda dapat melihat kontrak yang diterapkan oleh layanan yang diminta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seorang programmer yang ingin mengakses layanan WCF yang ada menggunakan utilitas konsol atau antarmuka grafis yang dibangun ke dalam lingkungan pengembangan untuk membentuk tipe dalam C # (atau dalam bahasa lain yang didukung) yang sesuai dengan kontrak layanan di alamat layanan. File dengan jenis yang diperoleh termasuk dalam proyek aplikasi klien, dan setelah itu programmer menggunakan istilah yang sama yang terkandung dalam antarmuka layanan, menikmati manfaat dari kemajuan (pengetikan statis). Selain itu, file konfigurasi klien menentukan karakteristik teknis dari layanan yang dipanggil (itu juga dapat dikonfigurasi dalam kode, tanpa file konfigurasi).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF mendukung berbagai jenis transportasi, enkripsi dan parameter teknis lainnya yang lebih halus. </font><font style="vertical-align: inherit;">Kebanyakan dari mereka disatukan oleh konsep "mengikat" (Binding). </font><font style="vertical-align: inherit;">Ada tiga parameter penting untuk layanan WCF:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alamat di mana itu tersedia; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengikat </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kontrak (antarmuka). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua parameter ini diatur dalam file konfigurasi layanan dan klien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di perusahaan kami, WCF (dengan dan tanpa transaksi terdistribusi) banyak digunakan dalam produk yang diimplementasikan, namun, mengingat tren mode, penggunaannya dalam produk baru masih dipertanyakan. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana cara memulai transaksi terdistribusi di WCF</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk memulai transaksi berbasis di WCF </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, programmer perlu menetapkan beberapa atribut dalam kode, pastikan bahwa binding menggunakan dukungan transaksi terdistribusi, </font></font><code>transactionFlow="true"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bahwa </font><font style="vertical-align: inherit;">itu ditulis pada klien dan dalam layanan, </font><font style="vertical-align: inherit;">dan bahwa manajer transaksi yang sesuai berjalan di semua komputer yang terlibat (kemungkinan besar , itu akan menjadi MSDTC).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Binding transaksi terdistribusi: NetTcpBinding, NetNamedPipeBinding, WSHttpBinding, WSDualHttpBinding, dan WSFederationHttpBinding. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode (operasi) dari antarmuka layanan harus ditandai dengan atribut </font></font><code>System.ServiceModel.TransactionFlowAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kemudian, dengan parameter atribut tertentu dan ketika mengatur parameter </font></font><code>TransactionScopeRequired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atribut </font><font style="vertical-align: inherit;">, </font></font><code>System.ServiceModel.OperationBehaviorAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transaksi akan didistribusikan antara klien dan layanan. </font><font style="vertical-align: inherit;">Selain itu, secara default, layanan dianggap memilih untuk melakukan transaksi, kecuali ada pengecualian yang dilemparkan pada saat run time. </font><font style="vertical-align: inherit;">Untuk mengubah perilaku ini, Anda harus menetapkan nilai parameter </font></font><code>TransactionAutoComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atribut yang </font><font style="vertical-align: inherit;">sesuai </font></font><code>System.ServiceModel.OperationBehaviorAttribute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode untuk layanan WCF sederhana yang mendukung transaksi terdistribusi.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.ServiceModel.ServiceContract</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMyService</span></span> { [System.ServiceModel.OperationContract] [System.ServiceModel.TransactionFlow(System.ServiceModel.TransactionFlowOption.Mandatory)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyService</span></span> : <span class="hljs-title"><span class="hljs-title">IMyService</span></span> { [System.ServiceModel.OperationBehavior(TransactionScopeRequired = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] [System.ServiceModel.TransactionFlow(System.ServiceModel.TransactionFlowOption.Mandatory)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(input)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.Length; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas, ini berbeda dari kode layanan biasa hanya dalam penggunaan atribut </font></font><code>System.ServiceModel.TransactionFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan pengaturan khusus atribut </font></font><code>System.ServiceModel.OperationBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konfigurasi sampel untuk layanan ini.</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">&lt;system.serviceModel&gt; &lt;services&gt; &lt;service name=<span class="hljs-string"><span class="hljs-string">"WcfWithTransactionsExample.MyService"</span></span> behaviorConfiguration=<span class="hljs-string"><span class="hljs-string">"serviceBehavior"</span></span>&gt; &lt;endpoint address=<span class="hljs-string"><span class="hljs-string">""</span></span> binding=<span class="hljs-string"><span class="hljs-string">"wsHttpBinding"</span></span> bindingConfiguration=<span class="hljs-string"><span class="hljs-string">"mainWsBinding"</span></span> contract=<span class="hljs-string"><span class="hljs-string">"WcfWithTransactionsExample.IMyService"</span></span>/&gt; &lt;endpoint address=<span class="hljs-string"><span class="hljs-string">"mex"</span></span> contract=<span class="hljs-string"><span class="hljs-string">"IMetadataExchange"</span></span> binding=<span class="hljs-string"><span class="hljs-string">"mexHttpBinding"</span></span>/&gt; &lt;/service&gt; &lt;/services&gt; &lt;bindings&gt; &lt;wsHttpBinding&gt; &lt;binding name=<span class="hljs-string"><span class="hljs-string">"mainWsBinding"</span></span> maxReceivedMessageSize=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> maxBufferPoolSize=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> transactionFlow=<span class="hljs-string"><span class="hljs-string">"true"</span></span> closeTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> openTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> receiveTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span> sendTimeout=<span class="hljs-string"><span class="hljs-string">"00:10:00"</span></span>&gt; &lt;security mode=<span class="hljs-string"><span class="hljs-string">"None"</span></span>/&gt; &lt;readerQuotas maxArrayLength=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span> maxStringContentLength=<span class="hljs-string"><span class="hljs-string">"209715200"</span></span>/&gt; &lt;/binding&gt; &lt;/wsHttpBinding&gt; &lt;/bindings&gt; &lt;/system.serviceModel&gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa pengikatan adalah tipe WSHttpBinding dan atribut digunakan </font></font><code>transactionFlow="true"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></div></div><br><a name="TLDR3"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TL; bagian DR </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaksi terdistribusi mencakup beberapa manajer sumber daya, dan semua perubahan harus dilakukan atau dibatalkan. Beberapa DBMS modern menerapkan transaksi terdistribusi yang menyediakan mekanisme yang nyaman untuk menghubungkan beberapa database. Transaksi yang didistribusikan perangkat lunak (tidak diterapkan dalam DBMS) dapat mencakup kombinasi yang berbeda dari manajer sumber daya pada komputer yang berbeda yang menjalankan sistem operasi yang berbeda, tetapi mereka memiliki batasan yang harus diperhitungkan sebelum mengandalkannya. Alternatif modern untuk transaksi terdistribusi adalah solusi pengiriman pesan. Di .NET Core, transaksi yang didistribusikan belum didukung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF adalah salah satu alat standar dan terbukti untuk membuat dan mengakses layanan di dunia .NET, mendukung beberapa jenis transportasi dan enkripsi. </font><font style="vertical-align: inherit;">WCF adalah teman yang sangat dekat dengan transaksi terdistribusi berdasarkan </font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Menyiapkan transaksi terdistribusi untuk WCF terdiri dari menandai kode dengan beberapa atribut dan menambahkan beberapa kata dalam layanan dan file konfigurasi klien. </font><font style="vertical-align: inherit;">Tidak semua binding WCF mendukung transaksi yang didistribusikan. </font><font style="vertical-align: inherit;">Selain itu, jelas bahwa transaksi di WCF memiliki batasan yang sama seperti tanpa menggunakan WCF. </font><font style="vertical-align: inherit;">Platform .NET Core sejauh ini hanya memungkinkan Anda untuk mengakses layanan di WCF, daripada membuatnya.</font></font><br><br><a name="Conclusion"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesimpulan Boks </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posting ini adalah ikhtisar dasar-dasar transaksi perangkat lunak .NET. Beberapa kesimpulan mengenai tren dalam transaksi perangkat lunak dapat ditemukan di bagian tentang penerapan dan keterbatasan subjek yang dibahas, dan sebagai kesimpulan, tesis utama publikasi dikumpulkan. Saya kira mereka dapat digunakan sebagai lembar contekan ketika mempertimbangkan transaksi perangkat lunak sebagai salah satu opsi untuk menerapkan sistem teknis atau untuk menyegarkan informasi yang relevan dalam memori. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaksi (bidang studi, DBMS, perangkat lunak)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Persyaratan bidang subjek kadang-kadang dirumuskan dalam bentuk transaksi - operasi yang, dimulai di bidang data integral, setelah selesai (termasuk tidak berhasil) juga harus datang ke bidang data integral (mungkin sudah berbeda). Persyaratan ini biasanya diterapkan sebagai sistem transaksi. Contoh klasik dari suatu transaksi adalah transfer uang antara dua akun, yang terdiri dari dua operasi yang tidak dapat dibagi - menarik uang dari satu akun dan mengkredit yang lain. Selain transaksi terkenal yang diterapkan oleh DBMS, ada juga transaksi perangkat lunak, misalnya, di dunia .NET. Manajer sumber daya adalah komponen perangkat lunak yang menyadari keberadaan transaksi tersebut dan memiliki kemampuan untuk dimasukkan di dalamnya, yaitu, melakukan atau mengembalikan perubahan yang dilakukan.Manajer sumber daya menerima instruksi tentang melakukan dan mengembalikan perubahan dari manajer transaksi, yang merupakan dasar dari infrastruktur</font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajer sumber daya yang tahan lama dan terputus-putus.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manajer sumber daya jangka panjang mendukung pemulihan data setelah kegagalan sistem. Driver DBMS untuk .NET biasanya menawarkan fungsi seperti itu. Manajer sumber daya yang terputus-putus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mendukung pemulihan bencana. Memori transaksional terprogram - cara mengelola objek dalam RAM - dapat dilihat sebagai contoh manajer sumber daya yang berubah-ubah. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaksi dan .NET Resource Manager.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Programmer .NET menggunakan transaksi perangkat lunak dan membuat manajer sumber dayanya sendiri menggunakan tipe dari namespace</font></font><code>System.Transactions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Infrastruktur ini memungkinkan penggunaan transaksi berbagai sarang dan isolasi (dengan keterbatasan yang diketahui). Menggunakan transaksi tidak rumit, dan itu terdiri dari membungkus kode di blok </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan karakteristik tertentu. Namun, manajer sumber daya yang dimasukkan dengan cara ini dalam transaksi harus mempertahankan fungsionalitas yang diperlukan untuk bagian mereka. Menggunakan manajer sumber daya yang heterogen dalam suatu transaksi atau menggunakan satu manajer dengan cara yang berbeda dapat secara otomatis mengubah transaksi menjadi transaksi yang terdistribusi. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaksi terdistribusi (DBMS, perangkat lunak).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaksi terdistribusi mencakup beberapa subsistem, perubahan yang harus disinkronkan, yaitu, mereka dilakukan bersama-sama atau dibatalkan. Transaksi terdistribusi diimplementasikan dalam beberapa DBMS modern. Transaksi yang didistribusikan perangkat lunak (ini bukan yang diterapkan oleh DBMS) memberlakukan batasan tambahan pada proses dan platform yang berinteraksi. Transaksi yang didistribusikan secara bertahap keluar dari mode, memberi jalan ke solusi berdasarkan layanan pesan. Untuk mengubah transaksi biasa menjadi transaksi terdistribusi, programmer tidak perlu melakukan apa-apa: ketika seorang manajer sumber daya dengan karakteristik tertentu termasuk dalam transaksi pada saat run time, manajer transaksi akan secara otomatis melakukan apa pun yang diperlukan. Transaksi perangkat lunak reguler tersedia dalam .NET Core dan .NET Standard, dan transaksi yang didistribusikan tidak tersedia.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaksi terdistribusi melalui WCF. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WCF adalah salah satu alat .NET standar untuk membuat dan menjalankan layanan, yang juga mendukung protokol standar. </font><font style="vertical-align: inherit;">Dengan kata lain, layanan WCF yang dikonfigurasi dengan cara tertentu dapat diakses dari aplikasi apa pun, tidak hanya .NET atau Windows. </font><font style="vertical-align: inherit;">Untuk membuat transaksi terdistribusi di atas WCF, Anda perlu menandai jenis yang membuat layanan dengan atribut tambahan dan membuat perubahan minimal pada layanan dan file konfigurasi klien. </font><font style="vertical-align: inherit;">Anda tidak bisa membuat layanan WCF di .NET Core dan .NET Standard, tetapi Anda bisa membuat klien WCF. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh untuk memeriksa Sistem. Transaksi di GitHub</font></font></a> <br><br><div class="spoiler">  <b class="spoiler_title">Referensi</b> <div class="spoiler_text"><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konsep dasar </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ACID</a> ( Â«Â») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ( Microsoft) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ( Microsoft) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ( Â«Â») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ( Â«Â») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ( Â«Â») <br><br><h4>     </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   X/Open XA</a> ( The Open Group) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Transaction API</a> ( Â«Â») <br> <a href="">     Cache</a> (  InterSystems) <br><br><h4>   .NET </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   .NET</a> (   Tech Blog Collection) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     TransactionScope</a> (Â«Â») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  ,     </a> ( Microsoft) <br> <a href="">   .NET Standard 2.0</a> ( .NET Standard  GitHub) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">       </a> ( YarFullStack) <br><br><h4>    </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     </a> (Â«Â») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     </a> (Â«Â») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    Â«Â»     </a> (Â«Â») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     Â«Â»  </a> (Â«Â») <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    </a> (Â«Â») <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editorial</font></font></b> <div class="spoiler_text"><ul><li> 20.12.2018 . </li><li> 21.12.2018  .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">OlegAxenow</a> . </li><li> 23.12.2018      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">qw1</a> . </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433136/">https://habr.com/ru/post/id433136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433122/index.html">React-Hot-Loader v4.6</a></li>
<li><a href="../id433126/index.html">Tinjauan Zabbix: Cara mengatur tinjauan kode untuk memantau konfigurasi</a></li>
<li><a href="../id433128/index.html">Apa yang Profesional IT Mainkan dan Jangan Main (Bulletin 2018)</a></li>
<li><a href="../id433130/index.html">Semoga kekuatan bersama kita: kekebalan kita sendiri terhadap kanker</a></li>
<li><a href="../id433132/index.html">"Kalender Tester" untuk bulan Desember. Coba pendekatan yang berbeda</a></li>
<li><a href="../id433138/index.html">Lima prinsip desain produk saat Pemesanan</a></li>
<li><a href="../id433140/index.html">Modul Google Pay Client Siap</a></li>
<li><a href="../id433142/index.html">Klasik abadi, atau ikhtisar vektor serangan baru melalui Microsoft Office</a></li>
<li><a href="../id433144/index.html">.NET Core 2.2 dirilis. Apa yang baru? (1 dari 3)</a></li>
<li><a href="../id433146/index.html">[Kompetisi] 25 konsol game teratas (kocok dulu)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>