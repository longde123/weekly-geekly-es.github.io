<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🏫 👨🏽‍🎨 🕴🏼 Menulis ekstensi browser yang aman 🤶 🏘️ 👦🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Berbeda dengan arsitektur "client-server" yang umum, aplikasi desentralisasi ditandai oleh: 


- Tidak perlu menyimpan database dengan login dan kata ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis ekstensi browser yang aman</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/451796/"><p><img src="https://habrastorage.org/webt/nt/7v/c8/nt7vc8scuypj0o2ngtj1n6fqjlw.png"></p><br><p>  Berbeda dengan arsitektur "client-server" yang umum, aplikasi desentralisasi ditandai oleh: </p><br><ul><li>  Tidak perlu menyimpan database dengan login dan kata sandi pengguna.  Akses informasi disimpan secara eksklusif oleh pengguna sendiri, dan konfirmasi keasliannya terjadi pada tingkat protokol. </li><li>  Tidak perlu menggunakan server.  Logika aplikasi dapat dieksekusi pada jaringan blockchain, di mana dimungkinkan untuk menyimpan jumlah data yang diperlukan. </li></ul><br><p>  Ada 2 repositori yang relatif aman untuk kunci pengguna - dompet perangkat keras dan ekstensi browser.  Sebagian besar dompet perangkat keras seaman mungkin, tetapi sulit digunakan dan jauh dari gratis, tetapi ekstensi browser adalah kombinasi sempurna antara keamanan dan kemudahan penggunaan, dan juga bisa sepenuhnya gratis bagi pengguna akhir. </p><br><p>  Mengingat semua ini, kami ingin membuat ekstensi yang paling aman, yang menyederhanakan pengembangan aplikasi terdesentralisasi, menyediakan API sederhana untuk bekerja dengan transaksi dan tanda tangan. <br>  Kami akan memberi tahu Anda tentang pengalaman di bawah ini. </p><br><p>  <strong>Artikel ini akan memberikan petunjuk langkah demi langkah tentang cara menulis ekstensi browser, dengan contoh kode dan tangkapan layar.</strong>  Anda dapat menemukan semua kode di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> .  Setiap komit secara logis sesuai dengan bagian dari artikel ini. </p><a name="habracut"></a><br><h2 id="kratkaya-istoriya-brauzernyh-rasshireniy">  Sejarah Singkat Ekstensi Peramban </h2><br><p>  Ekstensi peramban telah ada selama beberapa waktu.  Di Internet Explorer, mereka muncul pada tahun 1999, di Firefox - pada tahun 2004.  Namun, untuk waktu yang sangat lama tidak ada standar tunggal untuk ekstensi. </p><br><p>  Kita dapat mengatakan bahwa itu muncul bersama dengan ekstensi di Google Chrome versi keempat.  Tentu saja, tidak ada spesifikasi saat itu, tetapi Chrome API yang menjadi basisnya: setelah menaklukkan sebagian besar pasar browser dan memiliki toko aplikasi bawaan, Chrome sebenarnya menetapkan standar untuk ekstensi browser. </p><br><p>  Mozilla memiliki standar sendiri, tetapi, melihat popularitas ekstensi untuk Chrome, perusahaan memutuskan untuk membuat API yang kompatibel.  Pada 2015, atas prakarsa Mozilla, sebuah grup khusus diciptakan di dalam World Wide Web Consortium (W3C) untuk mengerjakan spesifikasi untuk ekstensi lintas browser. </p><br><p> Berdasarkan ekstensi API yang sudah ada untuk Chrome.  Pekerjaan itu didukung oleh Microsoft (Google menolak untuk berpartisipasi dalam pengembangan standar), dan sebagai hasilnya, muncul rancangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi</a> . </p><br><p>  Secara formal, spesifikasinya didukung oleh Edge, Firefox dan Opera (perhatikan bahwa Chrome tidak ada dalam daftar ini).  Tetapi pada kenyataannya, standar ini sebagian besar kompatibel dengan Chrome, karena sebenarnya ditulis berdasarkan ekstensi-nya.  Baca lebih lanjut tentang API WebExtensions di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h2 id="struktura-rasshireniya">  Struktur ekstensi </h2><br><p>  Satu-satunya file yang diperlukan untuk ekstensi adalah manifes (manifest.json).  Dia adalah "titik masuk" ke ekstensi. </p><br><h3 id="manifest">  Terwujud </h3><br><p>  Berdasarkan spesifikasi, file manifes adalah file JSON yang valid.  Penjelasan lengkap tentang kunci manifes dengan informasi tentang kunci mana yang didukung di mana browser dapat ditemukan di <a href="">sini</a> . </p><br><p>  Kunci yang tidak ada dalam spesifikasi mungkin "diabaikan" (baik Chrome dan Firefox melaporkan kesalahan, tetapi ekstensi terus berfungsi). </p><br><p>  Dan saya ingin menarik beberapa poin. </p><br><ol><li>  <strong>background</strong> - objek yang mencakup bidang-bidang berikut: <br><ol><li>  <strong>skrip</strong> - larik skrip yang akan dieksekusi dalam konteks latar belakang (kita akan membicarakannya nanti); </li><li>  <strong>halaman</strong> - alih-alih skrip yang akan dieksekusi pada halaman kosong, Anda dapat menentukan html dengan konten.  Dalam hal ini, bidang skrip akan diabaikan, dan skrip perlu dimasukkan ke halaman dengan konten; </li><li>  <strong>persistent</strong> - bendera biner, jika tidak ditentukan, browser akan "membunuh" proses latar belakang ketika menganggap bahwa itu tidak melakukan apa-apa, dan restart jika perlu.  Kalau tidak, halaman akan diturunkan hanya ketika browser ditutup.  Tidak didukung di Firefox. </li></ol></li><li>  <strong>content_scripts</strong> - array objek yang memungkinkan Anda memuat skrip yang berbeda ke halaman web yang berbeda.  Setiap objek berisi bidang-bidang penting berikut: <br><ol><li>  <strong>cocok</strong> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pola url</a> yang dengannya ditentukan apakah skrip konten tertentu akan disertakan atau tidak. </li><li>  <strong>js</strong> - daftar skrip yang akan dimuat ke dalam pertandingan ini; </li><li> <strong>exclude_matches</strong> - mengecualikan URL <code>match</code> dari bidang kecocokan yang cocok dengan bidang ini. </li></ol></li><li>  <strong>page_action</strong> - pada kenyataannya, itu adalah objek yang bertanggung jawab atas ikon yang muncul di sebelah bilah alamat di browser, dan interaksi dengannya.  Ini juga memungkinkan Anda untuk menampilkan jendela sembulan, yang ditetapkan menggunakan HTML, CSS, dan JS-nya. <br><ol><li>  <strong>default_popup</strong> - path ke file HTML dengan antarmuka popup, mungkin berisi CSS dan JS. </li></ol></li><li>  <strong>izin</strong> - larik untuk mengelola hak ekstensi.  Ada 3 jenis hak yang dijelaskan secara rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> </li><li>  <strong>web_accessible_resources</strong> - sumber daya ekstensi yang dapat diminta halaman web, misalnya, gambar, JS, CSS, file HTML. </li><li>  <strong>externally_connectable</strong> - di sini Anda dapat secara eksplisit menentukan ID ekstensi lain dan domain halaman web tempat Anda dapat terhubung.  Sebuah domain bisa menjadi level kedua atau lebih tinggi.  Tidak berfungsi di Firefox. </li></ol><br><h2 id="kontekst-vypolneniya">  Konteks eksekusi </h2><br><p>  Ekstensi memiliki tiga konteks eksekusi kode, yaitu, aplikasi terdiri dari tiga bagian dengan berbagai tingkat akses ke API browser. </p><br><h3 id="extension-context">  Konteks ekstensi </h3><br><p>  Sebagian besar API tersedia di sini.  Dalam konteks ini, "hidup": </p><br><ol><li>  <strong>Halaman latar belakang</strong> - bagian "backend" dari ekstensi.  File ditunjukkan dalam manifes oleh tombol "latar belakang". </li><li>  <strong>Halaman</strong> popup - <strong>halaman</strong> popup yang muncul ketika Anda mengklik ikon ekstensi.  Dalam manifes, <code>browser_action</code> -&gt; <code>default_popup</code> . </li><li>  <strong>Halaman khusus</strong> - <strong>halaman</strong> ekstensi, "tinggal" di tab terpisah dari formulir <code>chrome-extension://&lt;id_&gt;/customPage.html</code> . </li></ol><br><p>  Konteks ini ada secara independen dari jendela dan tab browser.  <strong>Halaman</strong> latar belakang ada dalam satu salinan dan selalu berfungsi (pengecualiannya adalah halaman acara, ketika skrip latar belakang diluncurkan pada suatu acara dan mati setelah dijalankan).  <strong>Halaman</strong> popup ada ketika jendela popup terbuka, dan <strong>halaman Custom</strong> - sementara tab dengan itu terbuka.  Tidak ada akses ke tab lain dan isinya dari konteks ini. </p><br><h3 id="content-script-context">  Konteks skrip konten </h3><br><p>  File skrip konten diluncurkan bersama dengan setiap tab browser.  Dia memiliki akses ke bagian dari API ekstensi dan ke pohon DOM halaman web.  Skrip konten bertanggung jawab untuk berinteraksi dengan halaman.  Ekstensi yang memanipulasi pohon DOM melakukan hal ini dalam skrip konten - misalnya, pemblokir iklan atau penerjemah.  Juga, skrip konten dapat berkomunikasi dengan halaman melalui <code>postMessage</code> standar. </p><br><h3 id="web-page-context">  Konteks halaman web </h3><br><p>  Ini sebenarnya halaman web itu sendiri.  Itu tidak ada hubungannya dengan ekstensi dan tidak memiliki akses di sana, kecuali domain halaman ini tidak secara eksplisit ditentukan dalam manifes (lebih lanjut tentang ini di bawah). </p><br><h2 id="obmen-soobscheniyami">  Olahpesan </h2><br><p>  Bagian aplikasi yang berbeda harus saling bertukar pesan.  Untuk melakukan ini, ada <code>runtime.sendMessage</code> API untuk mengirim pesan <code>background</code> dan <code>tabs.sendMessage</code> untuk mengirim pesan ke halaman (ke skrip konten, popup atau halaman web jika ada <code>tabs.sendMessage</code> <code>externally_connectable</code> ).  Berikut ini adalah contoh ketika mengakses API Chrome. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     JSON   const msg = {a: 'foo', b: 'bar'}; // extensionId   ,      ''  ( ui   ) chrome.runtime.sendMessage(extensionId, msg); //    chrome.runtime.onMessage.addListener((msg) =&gt; console.log(msg)) //       id chrome.tabs.sendMessage(tabId, msg) //      id , ,   chrome.tabs.query( {currentWindow: true, active : true}, function(tabArray){ tabArray.forEach(tab =&gt; console.log(tab.id)) } )</span></span></code> </pre> <br><p>  Untuk komunikasi penuh, Anda dapat membuat koneksi melalui <code>runtime.connect</code> .  Sebagai tanggapan, kami mendapatkan <code>runtime.Port</code> , di mana, saat terbuka, Anda dapat mengirim sejumlah pesan.  Di sisi klien, misalnya <code>contentscript</code> , terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   extensionId        .    const port = chrome.runtime.connect({name: "knockknock"}); port.postMessage({joke: "Knock knock"}); port.onMessage.addListener(function(msg) { if (msg.question === "Who's there?") port.postMessage({answer: "Madame"}); else if (msg.question === "Madame who?") port.postMessage({answer: "Madame... Bovary"});</span></span></code> </pre><br><p>  Server atau latar belakang: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    '' .  , popup    chrome.runtime.onConnect.addListener(function(port) { console.assert(port.name === "knockknock"); port.onMessage.addListener(function(msg) { if (msg.joke === "Knock knock") port.postMessage({question: "Who's there?"}); else if (msg.answer === "Madame") port.postMessage({question: "Madame who?"}); else if (msg.answer === "Madame... Bovary") port.postMessage({question: "I don't get it."}); }); }); //     .     ,      chrome.runtime.onConnectExternal.addListener(function(port) { ... });</span></span></code> </pre> <br><p>  Ada juga acara <code>onDisconnect</code> dan metode <code>disconnect</code> . </p><br><h2 id="shema-prilozheniya">  Garis besar aplikasi </h2><br><p>  Mari kita buat ekstensi browser yang menyimpan kunci pribadi, menyediakan akses ke informasi publik (alamat, kunci publik berkomunikasi dengan halaman dan memungkinkan aplikasi pihak ketiga untuk meminta tanda tangan transaksi. </p><br><h2 id="razrabotka-prilozheniya">  Pengembangan aplikasi </h2><br><p>  Aplikasi kita harus berinteraksi dengan pengguna dan menyediakan halaman API untuk metode panggilan (misalnya, untuk menandatangani transaksi).  Ini tidak akan bekerja dengan <code>contentscript</code> saja, karena hanya memiliki akses ke DOM, tetapi tidak ke halaman JS.  Kami tidak dapat terhubung melalui <code>runtime.connect</code> , karena API diperlukan di semua domain, dan hanya yang spesifik yang dapat ditentukan dalam manifes.  Hasilnya, skema akan terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/fa/b3/gx/fab3gxq823kwybj9yk_kv8wlogy.png"></p><br><p>  Akan ada skrip lain - <code>inpage</code> , yang akan kami <code>inpage</code> ke halaman.  Ini akan berjalan dalam konteksnya dan menyediakan API untuk bekerja dengan ekstensi. </p><br><h3 id="nachalo">  Mulai </h3><br><p>  Semua kode ekstensi peramban tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Dalam proses deskripsi, akan ada tautan ke komit. </p><br><p>  Mari kita mulai dengan manifes: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-comment"><span class="hljs-comment">//   , .        chrome://extensions/?id=&lt;id &gt; "name": "Signer", "description": "Extension demo", "version": "0.0.1", "manifest_version": 2, // ,     background,     "background": { "scripts": ["background.js"] }, //  html   popup "browser_action": { "default_title": "My Extension", "default_popup": "popup.html" }, //  . //    :   url   http  https   // contenscript context   contentscript.js.         "content_scripts": [ { "matches": [ "http://*/*", "https://*/*" ], "js": [ "contentscript.js" ], "run_at": "document_start", "all_frames": true } ], //    localStorage  idle api "permissions": [ "storage", // "unlimitedStorage", //"clipboardWrite", "idle" //"activeTab", //"webRequest", //"notifications", //"tabs" ], //   ,       .      fetche'   xhr "web_accessible_resources": ["inpage.js"] }</span></span></code> </pre> <br><p>  Buat background.js, popup.js, inpage.js, dan contentcript.js kosong.  Tambahkan popup.html - dan aplikasi kami sudah dapat diunduh ke Google Chrome dan pastikan itu berfungsi. </p><br><p>  Untuk memverifikasi ini, Anda dapat mengambil kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> .  Selain apa yang kami lakukan, tautan tersebut dikonfigurasi untuk membangun proyek menggunakan webpack.  Untuk menambahkan aplikasi ke browser, di chrome: // ekstensi Anda harus memilih memuat dibuka dan folder dengan ekstensi yang sesuai - dalam kasus kami, dist. </p><br><p><img src="https://habrastorage.org/webt/ws/ng/qz/wsngqza3qdcjtxycbcwk4awpfqm.png"></p><br><p>  Sekarang ekstensi kami sudah terpasang dan berfungsi.  Anda dapat menjalankan alat pengembang untuk konteks yang berbeda sebagai berikut: </p><br><p>  popup -&gt; </p><br><p><img src="https://habrastorage.org/webt/m3/pr/9d/m3pr9dww991nvn9jsfwj8mvndqq.png"></p><br><p>  Akses ke konsol skrip konten dilakukan melalui konsol halaman itu sendiri di mana ia diluncurkan. <img src="https://habrastorage.org/webt/3t/gn/6v/3tgn6vao3ilxdwyz9zxraegz9vo.png"></p><br><p>  <strong>Olahpesan</strong> </p><br><p>  Jadi, kita perlu membuat dua saluran komunikasi: inpage &lt;-&gt; background dan popup &lt;-&gt; background.  Anda dapat, tentu saja, hanya mengirim pesan ke port dan menciptakan protokol Anda, tetapi saya lebih suka pendekatan yang saya amati pada proyek metamask open-source. </p><br><p>  Ini adalah ekstensi browser untuk bekerja dengan jaringan Ethereum.  Di dalamnya, berbagai bagian aplikasi berkomunikasi melalui RPC menggunakan pustaka dnode.  Ini memungkinkan Anda untuk dengan cepat dan mudah mengatur pertukaran jika Anda memberikan aliran nodejs sebagai transportasi (artinya objek yang mengimplementasikan antarmuka yang sama): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"dnode/browser"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//           ,         // C // API,     const dnode = Dnode({ hello: (cb) =&gt; cb(null, "world") }) // ,     dnode.  nodejs .     'readable-stream' connectionStream.pipe(dnode).pipe(connectionStream) //  const dnodeClient = Dnode() //         API    //    world dnodeClient.once('remote', remote =&gt; { remote.hello(((err, value) =&gt; console.log(value))) })</span></span></code> </pre> <br><p>  Sekarang kita akan membuat kelas aplikasi.  Ini akan membuat objek API untuk popup dan halaman web, dan juga membuat dnode untuk mereka: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   API  ui popupApi(){ return { hello: cb =&gt; cb(null, 'world') } } //   API   pageApi(){ return { hello: cb =&gt; cb(null, 'world') } } //  popup ui connectPopup(connectionStream){ const api = this.popupApi(); const dnode = Dnode(api); connectionStream.pipe(dnode).pipe(connectionStream); dnode.on('remote', (remote) =&gt; { console.log(remote) }) } //   connectPage(connectionStream, origin){ const api = this.popupApi(); const dnode = Dnode(api); connectionStream.pipe(dnode).pipe(connectionStream); dnode.on('remote', (remote) =&gt; { console.log(origin); console.log(remote) }) } }</span></span></code> </pre> <br><p>  Selanjutnya, alih-alih objek Chrome global, kami menggunakan extentionApi, yang merujuk ke Chrome di peramban dari Google dan ke peramban lainnya.  Ini dilakukan untuk kompatibilitas lintas-browser, tetapi cukup chrome.runtime.connect dapat digunakan dalam kerangka kerja artikel ini. </p><br><p>  Buat instance aplikasi dalam skrip latar belakang: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(); <span class="hljs-comment"><span class="hljs-comment">// onConnect    '' (contentscript, popup,   ) extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); //      ,          ,   ui if (processName === 'contentscript'){ const origin = remotePort.sender.url app.connectPage(portStream, origin) }else{ app.connectPopup(portStream) } }</span></span></code> </pre> <br><p>  Karena dnode bekerja dengan stream, dan kami mendapatkan port, kelas adaptor diperlukan.  Itu dibuat menggunakan pustaka stream yang dapat dibaca, yang mengimplementasikan stream nodejs di browser: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Duplex} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'readable-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortStream</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Duplex</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(port){ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>({<span class="hljs-attr"><span class="hljs-attr">objectMode</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port = port; port.onMessage.addListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); port.onDisconnect.addListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onDisconnect.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) } _onMessage(msg) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Buffer.isBuffer(msg)) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> msg._isBuffer; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(msg); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(msg) } } _onDisconnect() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.destroy() } _read(){} _write(msg, encoding, cb) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Buffer.isBuffer(msg)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = msg.toJSON(); data._isBuffer = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port.postMessage(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port.postMessage(msg) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'PortStream - disconnected'</span></span>)) } cb() } }</code> </pre> <br><p>  Sekarang buat koneksi di UI: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupUi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupUi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,       ,   stream,  dnode const backgroundPort = extensionApi.runtime.connect({name: 'popup'}); const connectionStream = new PortStream(backgroundPort); const dnode = Dnode(); connectionStream.pipe(dnode).pipe(connectionStream); const background = await new Promise(resolve =&gt; { dnode.once('remote', api =&gt; { resolve(api) }) }); //   API    if (DEV_MODE){ global.background = background; } }</span></span></code> </pre> <br><p>  Kemudian kami membuat koneksi di skrip konten: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; setupConnection(); injectScript(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backgroundPort = extensionApi.runtime.connect({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'contentscript'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backgroundStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortStream(backgroundPort); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pageStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PostMessageStream({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'content'</span></span>, <span class="hljs-attr"><span class="hljs-attr">target</span></span>: <span class="hljs-string"><span class="hljs-string">'page'</span></span>, }); pageStream.pipe(backgroundStream).pipe(pageStream); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// inject in-page script let script = document.createElement('script'); script.src = extensionApi.extension.getURL('inpage.js'); const container = document.head || document.documentElement; container.insertBefore(script, container.children[0]); script.onload = () =&gt; script.remove(); } catch (e) { console.error('Injection failed.', e); } }</span></span></code> </pre> <br><p>  Karena kita tidak memerlukan API dalam skrip konten, tetapi langsung di halaman, kita melakukan dua hal: </p><br><ol><li>  Kami membuat dua aliran.  Salah satunya adalah menuju halaman, di atas postMessage.  Untuk ini, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket ini</a> dari pencipta metamask.  Aliran kedua adalah ke latar belakang di atas port yang diterima dari <code>runtime.connect</code> .  Pip mereka.  Sekarang halaman akan memiliki aliran ke latar belakang. </li><li>  Suntikkan skrip ke DOM.  Kami memompa skrip (akses ke sana diizinkan dalam manifes) dan membuat tag <code>script</code> dengan isinya di dalam: </li></ol><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; setupConnection(); injectScript(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    const backgroundPort = extensionApi.runtime.connect({name: 'contentscript'}); const backgroundStream = new PortStream(backgroundPort); //    const pageStream = new PostMessageStream({ name: 'content', target: 'page', }); pageStream.pipe(backgroundStream).pipe(pageStream); } function injectScript(){ try { // inject in-page script let script = document.createElement('script'); script.src = extensionApi.extension.getURL('inpage.js'); const container = document.head || document.documentElement; container.insertBefore(script, container.children[0]); script.onload = () =&gt; script.remove(); } catch (e) { console.error('Injection failed.', e); } }</span></span></code> </pre> <br><p>  Sekarang buat objek api di inpage dan mulai secara global: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; setupInpageApi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupInpageApi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    const connectionStream = new PostMessageStream({ name: 'page', target: 'content', }); const dnode = Dnode(); connectionStream.pipe(dnode).pipe(connectionStream); //   API const pageApi = await new Promise(resolve =&gt; { dnode.once('remote', api =&gt; { resolve(api) }) }); //   window global.SignerApp = pageApi; }</span></span></code> </pre> <br><p>  Kami siap untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panggilan Prosedur Jarak Jauh (RPC) dengan API terpisah untuk halaman dan UI</a> .  Saat menghubungkan halaman baru ke latar belakang, kita dapat melihat ini: </p><br><p><img src="https://habrastorage.org/webt/cy/r_/pm/cyr_pmgm-u5hes5lefaf85gk91m.png"></p><br><p>  API dan asal kosong.  Di sisi halaman, kita bisa memanggil fungsi halo seperti ini: </p><br><p><img src="https://habrastorage.org/webt/3p/fd/tv/3pfdtv17ejnjzh94uajezgz0lce.png"></p><br><p>  Bekerja dengan fungsi callback di JS modern adalah ide yang buruk, oleh karena itu kami akan menulis pembantu kecil untuk membuat dnode yang memungkinkan Anda meneruskan API ke utilitas dalam suatu objek. </p><br><p>  Objek API sekarang akan terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ popupApi() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">hello</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-string"><span class="hljs-string">"world"</span></span> } } ... }</code> </pre> <br><p>  Mendapatkan objek dari jarak jauh sebagai berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {cbToPromise, transformMethods} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../../src/utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pageApi = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { dnode.once(<span class="hljs-string"><span class="hljs-string">'remote'</span></span>, remoteApi =&gt; { <span class="hljs-comment"><span class="hljs-comment">//      callback  promise resolve(transformMethods(cbToPromise, remoteApi)) }) });</span></span></code> </pre> <br><p>  Panggilan fungsi mengembalikan janji: </p><br><p><img src="https://habrastorage.org/webt/g7/qq/og/g7qqogo60hrjqm5pre7f5miehs0.png"></p><br><p>  Versi dengan fungsi asinkron tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Secara umum, pendekatan dengan RPC dan stream tampaknya cukup fleksibel: kita dapat menggunakan multiplexing uap dan membuat beberapa API berbeda untuk tugas yang berbeda.  Pada prinsipnya, dnode dapat digunakan di mana saja, hal utama adalah untuk membungkus transportasi dalam bentuk aliran nodejs. </p><br><p>  Alternatifnya adalah format JSON, yang mengimplementasikan protokol JSON RPC 2. Namun, ia bekerja dengan transport spesifik (TCP dan HTTP (S)), yang tidak berlaku dalam kasus kami. </p><br><h3 id="vnutrenniy-steyt-i-localstorage">  Status internal dan penyimpanan lokal </h3><br><p>  Kita perlu menyimpan keadaan internal aplikasi - setidaknya, kunci untuk penandatanganan.  Kami dapat dengan mudah menambahkan status ke aplikasi dan metode untuk mengubahnya di popup API: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store = { <span class="hljs-attr"><span class="hljs-attr">keys</span></span>: [], }; } addKey(key){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.keys.push(key) } removeKey(index){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.keys.splice(index,<span class="hljs-number"><span class="hljs-number">1</span></span>) } popupApi(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">addKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (key) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addKey(key), <span class="hljs-attr"><span class="hljs-attr">removeKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (index) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.removeKey(index) } } ... }</code> </pre> <br><p>  Di latar belakang, kami akan membungkus semuanya dalam suatu fungsi dan menulis objek aplikasi ke jendela sehingga Anda dapat bekerja dengannya dari konsol: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupApp(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEV_MODE) { global.app = app; } extensionApi.runtime.onConnect.addListener(connectRemote); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectRemote</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">remotePort</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processName = remotePort.name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> portStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortStream(remotePort); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (processName === <span class="hljs-string"><span class="hljs-string">'contentscript'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> origin = remotePort.sender.url; app.connectPage(portStream, origin) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { app.connectPopup(portStream) } } }</code> </pre> <br><p>  Tambahkan beberapa tombol dari konsol UI dan lihat apa yang terjadi dengan keadaan: </p><br><p><img src="https://habrastorage.org/webt/n7/xr/eb/n7xrebxybxbquxx8z8uozgwpfqm.png"></p><br><p>  Status harus persisten sehingga ketika Anda me-restart kunci tidak hilang. </p><br><p>  Kami akan menyimpannya di Penyimpanan lokal, menimpa dengan setiap perubahan.  Selanjutnya, akses ke sana juga akan diperlukan untuk UI, dan saya juga ingin berlangganan perubahan.  Berdasarkan hal ini, akan lebih mudah untuk membuat penyimpanan yang dapat diobservasi dan berlangganan perubahannya. </p><br><p>  Kami akan menggunakan pustaka mobx ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/mobxjs/mobx</a> ).  Pilihan ada pada dirinya, karena saya tidak harus bekerja dengannya, tetapi saya benar-benar ingin mempelajarinya. </p><br><p>  Tambahkan inisialisasi kondisi awal dan buat toko dapat diamati: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable, action} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(initState = {}) { <span class="hljs-comment"><span class="hljs-comment">//  store      ,       proxy,      this.store = observable.object({ keys: initState.keys || [], }); } // ,   observable    @action addKey(key) { this.store.keys.push(key) } @action removeKey(index) { this.store.keys.splice(index, 1) } ... }</span></span></code> </pre> <br><p>  "Di bawah tenda" mobx mengganti semua bidang penyimpanan dengan proxy dan memotong semua panggilan ke sana.  Anda dapat berlangganan banding ini. </p><br><p>  Lebih jauh, saya akan sering menggunakan istilah "saat perubahan", meskipun ini tidak sepenuhnya benar.  Mobx melacak akses ke bidang.  Getter dan setter dari objek proxy yang dibuat pustaka digunakan. </p><br><p>  Dekorator aksi memiliki dua tujuan: </p><br><ol><li>  Dalam mode ketat dengan flag menegakkanAksi, mobx melarang mengubah status secara langsung.  Ini dianggap praktik yang baik untuk bekerja dalam mode ketat. </li><li>  Bahkan jika fungsi mengubah keadaan beberapa kali - misalnya, kami mengubah beberapa bidang menjadi beberapa baris kode - pengamat diberitahu hanya ketika itu selesai.  Ini sangat penting untuk frontend, di mana pembaruan keadaan yang tidak perlu menyebabkan rendering elemen yang tidak perlu.  Dalam kasus kami, baik yang pertama maupun yang kedua tidak terlalu relevan, namun, kami akan mengikuti praktik terbaik.  Dekorator memutuskan untuk menggantung pada semua fungsi yang mengubah keadaan bidang yang diamati. </li></ol><br><p>  Di latar belakang, tambahkan inisialisasi dan simpan status di localStorage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {reaction, toJS} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  . /  / localStorage  JSON    'store' import {loadState, saveState} from "./utils/localStorage"; const DEV_MODE = process.env.NODE_ENV !== 'production'; setupApp(); function setupApp() { const initState = loadState(); const app = new SignerApp(initState); if (DEV_MODE) { global.app = app; } // Setup state persistence //  reaction  ,     .    ,    const localStorageReaction = reaction( () =&gt; toJS(app.store), // -  saveState // ,      ,    ); extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); if (processName === 'contentscript') { const origin = remotePort.sender.url app.connectPage(portStream, origin) } else { app.connectPopup(portStream) } } }</span></span></code> </pre> <br><p>  Fungsi reaksi menarik di sini.  Dia memiliki dua argumen: </p><br><ol><li>  Pemilih data. </li><li>  Penangan yang akan dipanggil dengan data ini setiap kali ada perubahan. </li></ol><br><p>  Tidak seperti redux, di mana kita secara eksplisit mendapatkan negara sebagai argumen, mobx mengingat yang bisa kita amati di dalam pemilih, dan hanya ketika mengubahnya mereka memanggil pawang. </p><br><p>  Sangat penting untuk memahami dengan tepat bagaimana mobx memutuskan mana yang dapat kita ikuti berlangganan.  Jika saya menulis pemilih dalam kode seperti ini <code>() =&gt; app.store</code> , maka reaksi tidak akan pernah dipanggil, karena repositori itu sendiri tidak dapat diamati, hanya bidangnya yang seperti itu. </p><br><p>  Jika saya menulis seperti ini <code>() =&gt; app.store.keys</code> , maka tidak ada yang akan terjadi lagi, karena ketika menambahkan / menghapus elemen array, tautan ke sana tidak akan berubah. </p><br><p>  Untuk pertama kalinya, Mobx melakukan fungsi pemilih dan memantau hanya mereka yang dapat kita akses.  Ini dilakukan melalui getter proxy.      <code>toJS</code> .    ,        .         – ,  . </p><br><p>   popup    .         localStorage: </p><br><p><img src="https://habrastorage.org/webt/fr/dh/6t/frdh6tc_bt_v3zywmgjrnptngcw.png"></p><br><p>   background-    . </p><br><p>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br><h2 id="bezopasnoe-hranenie-privatnyh-klyuchey">     </h2><br><p>       :    ,   ,        .   localStorage        . </p><br><p>       locked,        .        locked  . </p><br><p> Mobx      ,       .  —   computed properties.     view   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable, action} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     .  crypto-js import {encrypt, decrypt} from "./utils/cryptoUtils"; export class SignerApp { constructor(initState = {}) { this.store = observable.object({ //     .   null -  locked password: null, vault: initState.vault, //    .     view  . get locked(){ return this.password == null }, get keys(){ return this.locked ? undefined : SignerApp._decryptVault(this.vault, this.password) }, get initialized(){ return this.vault !== undefined } }) } //      @action initVault(password){ this.store.vault = SignerApp._encryptVault([], password) } @action lock() { this.store.password = null } @action unlock(password) { this._checkPassword(password); this.store.password = password } @action addKey(key) { this._checkLocked(); this.store.vault = SignerApp._encryptVault(this.store.keys.concat(key), this.store.password) } @action removeKey(index) { this._checkLocked(); this.store.vault = SignerApp._encryptVault([ ...this.store.keys.slice(0, index), ...this.store.keys.slice(index + 1) ], this.store.password ) } ... //    api // private _checkPassword(password) { SignerApp._decryptVault(this.store.vault, password); } _checkLocked() { if (this.store.locked){ throw new Error('App is locked') } } //   /  static _encryptVault(obj, pass){ const jsonString = JSON.stringify(obj) return encrypt(jsonString, pass) } static _decryptVault(str, pass){ if (str === undefined){ throw new Error('Vault not initialized') } try { const jsonString = decrypt(str, pass) return JSON.parse(jsonString) }catch (e) { throw new Error('Wrong password') } } }</span></span></code> </pre> <br><p>        .   .    locked        .   API     . </p><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   rypto-js</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CryptoJS <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'crypto-js'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      .        5000  function strengthenPassword(pass, rounds = 5000) { while (rounds-- &gt; 0){ pass = CryptoJS.SHA256(pass).toString() } return pass } export function encrypt(str, pass){ const strongPass = strengthenPassword(pass); return CryptoJS.AES.encrypt(str, strongPass).toString() } export function decrypt(str, pass){ const strongPass = strengthenPassword(pass) const decrypted = CryptoJS.AES.decrypt(str, strongPass); return decrypted.toString(CryptoJS.enc.Utf8) }</span></span></code> </pre> <br><p>    idle API,       —  . , ,   <code>idle</code> , <code>active</code>  <code>locked</code> .  idle   ,  locked ,    .        localStorage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {reaction, toJS} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {loadState, saveState} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/localStorage"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IDLE_INTERVAL = <span class="hljs-number"><span class="hljs-number">30</span></span>; setupApp(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initState = loadState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(initState); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEV_MODE) { global.app = app; } <span class="hljs-comment"><span class="hljs-comment">//     ,    , reaction   reaction( () =&gt; ({ vault: app.store.vault }), saveState ); //  ,    extensionApi.idle.setDetectionInterval(IDLE_INTERVAL); //             extensionApi.idle.onStateChanged.addListener(state =&gt; { if (['locked', 'idle'].indexOf(state) &gt; -1) { app.lock() } }); // Connect to other contexts extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); if (processName === 'contentscript') { const origin = remotePort.sender.url app.connectPage(portStream, origin) } else { app.connectPopup(portStream) } } }</span></span></code> </pre> <br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br><h3 id="tranzakcii">  Transaksi </h3><br><p> ,     :      .     WAVES   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">waves-transactions</a> . </p><br><p>       ,   ,  —    ,    : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {action, observable, reaction} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {signTx} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-transactions'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {decrypt, encrypt} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/cryptoUtils"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... @action newMessage(data, origin) { <span class="hljs-comment"><span class="hljs-comment">//       id, ,    . const message = observable.object({ id: uuid(), // ,  uuid origin, // Origin      data, // status: 'new', //   : new, signed, rejected  failed timestamp: Date.now() }); console.log(`new message: ${JSON.stringify(message, null, 2)}`); this.store.messages.push(message); //     mobx   .        return new Promise((resolve, reject) =&gt; { reaction( () =&gt; message.status, //    (status, reaction) =&gt; { //       reaction,        switch (status) { case 'signed': resolve(message.data); break; case 'rejected': reject(new Error('User rejected message')); break; case 'failed': reject(new Error(message.err.message)); break; default: return } reaction.dispose() } ) }) } @action approve(id, keyIndex = 0) { const message = this.store.messages.find(msg =&gt; msg.id === id); if (message == null) throw new Error(`No msg with id:${id}`); try { message.data = signTx(message.data, this.store.keys[keyIndex]); message.status = 'signed' } catch (e) { message.err = { stack: e.stack, message: e.message }; message.status = 'failed' throw e } } @action reject(id) { const message = this.store.messages.find(msg =&gt; msg.id === id); if (message == null) throw new Error(`No msg with id:${id}`); message.status = 'rejected' } ... }</span></span></code> </pre> <br><p>         ,  <code>observable</code>    <code>store.messages</code> . </p><br><p>    <code>observable</code> ,  mobx        messages.     ,       ,      . </p><br><p>    ,      .    reaction,    ""   . </p><br><p>   <code>approve</code>  <code>reject</code>  :     ,   ,  . </p><br><p> Approve  reject    API UI, newMessage —  API : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... popupApi() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">addKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (key) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addKey(key), <span class="hljs-attr"><span class="hljs-attr">removeKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (index) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.removeKey(index), <span class="hljs-attr"><span class="hljs-attr">lock</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lock(), <span class="hljs-attr"><span class="hljs-attr">unlock</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (password) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unlock(password), <span class="hljs-attr"><span class="hljs-attr">initVault</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (password) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initVault(password), <span class="hljs-attr"><span class="hljs-attr">approve</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (id, keyIndex) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.approve(id, keyIndex), <span class="hljs-attr"><span class="hljs-attr">reject</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (id) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reject(id) } } pageApi(origin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">signTransaction</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (txParams) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newMessage(txParams, origin) } } ... }</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/jt/bp/nu/jtbpnu9tbhryijukstktnti3wbu.png"></p><br><p>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  UI</a> . </p><br><h2 id="ui"> UI </h2><br><p>      .   UI   <code>observable</code>     API ,     .  <code>observable</code>   API,   background: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {cbToPromise, setupDnode, transformMethods} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {initApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./ui/index"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupUi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupUi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,     const backgroundPort = extensionApi.runtime.connect({name: 'popup'}); const connectionStream = new PortStream(backgroundPort); //   observable   background'a let backgroundState = observable.object({}); const api = { //  ,    observable updateState: async state =&gt; { Object.assign(backgroundState, state) } }; //  RPC  const dnode = setupDnode(connectionStream, api); const background = await new Promise(resolve =&gt; { dnode.once('remote', remoteApi =&gt; { resolve(transformMethods(cbToPromise, remoteApi)) }) }); //   background observable   background.state = backgroundState; if (DEV_MODE) { global.background = background; } //   await initApp(background) }</span></span></code> </pre><br><p>       .  react-. Background-     props. , ,       store  ,       : </p><br><pre> <code class="plaintext hljs">import {render} from 'react-dom' import App from './App' import React from "react"; //    background     props export async function initApp(background){ render( &lt;App background={background}/&gt;, document.getElementById('app-content') ); }</code> </pre><br><p>   mobx       .     observer   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mobx-react</a>  ,         observable,    .    mapStateToProps  connect,   redux.    " ": </p><br><pre> <code class="plaintext hljs">import React, {Component, Fragment} from 'react' import {observer} from "mobx-react"; import Init from './components/Initialize' import Keys from './components/Keys' import Sign from './components/Sign' import Unlock from './components/Unlock' @observer //          render,    observable     export default class App extends Component { //              , //   observable   background    ,    render() { const {keys, messages, initialized, locked} = this.props.background.state; const {lock, unlock, addKey, removeKey, initVault, deleteVault, approve, reject} = this.props.background; return &lt;Fragment&gt; {!initialized ? &lt;Init onInit={initVault}/&gt; : locked ? &lt;Unlock onUnlock={unlock}/&gt; : messages.length &gt; 0 ? &lt;Sign keys={keys} message={messages[messages.length - 1]} onApprove={approve} onReject={reject}/&gt; : &lt;Keys keys={keys} onAdd={addKey} onRemove={removeKey}/&gt; } &lt;div&gt; {!locked &amp;&amp; &lt;button onClick={() =&gt; lock()}&gt;Lock App&lt;/button&gt;} {initialized &amp;&amp; &lt;button onClick={() =&gt; deleteVault()}&gt;Delete all keys and init&lt;/button&gt;} &lt;/div&gt; &lt;/Fragment&gt; } }</code> </pre> <br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  UI</a> . </p><br><p>          UI      UI.     <code>getState</code>  <code>reaction</code> ,  <code>remote.updateState</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {action, observable, reaction} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {signTx} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-transactions'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {decrypt, encrypt} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/cryptoUtils"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// public getState() { return { keys: this.store.keys, messages: this.store.newMessages, initialized: this.store.initialized, locked: this.store.locked } } ... // connectPopup(connectionStream) { const api = this.popupApi(); const dnode = setupDnode(connectionStream, api); dnode.once('remote', (remote) =&gt; { //  reaction   ,          ui  const updateStateReaction = reaction( () =&gt; this.getState(), (state) =&gt; remote.updateState(state), //     . fireImmediatly   reaction    . //  ,    . Delay   debounce {fireImmediately: true, delay: 500} ); //      dnode.once('end', () =&gt; updateStateReaction.dispose()) }) } ... }</span></span></code> </pre> <br><p>    <code>remote</code>  <code>reaction</code>   ,      UI. </p><br><p>   —       : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// Reaction    . reaction( () =&gt; app.store.newMessages.length &gt; 0 ? app.store.newMessages.length.toString() : '', text =&gt; extensionApi.browserAction.setBadgeText({text}), {fireImmediately: true} ); ... }</span></span></code> </pre> <br><p> ,  . -    : </p><br><p><img src="https://habrastorage.org/webt/yo/cz/9b/yocz9bncoevwxrict_3dl_vphek.png"></p><br><p><img src="https://habrastorage.org/webt/ee/8e/uj/ee8eujkmg5iwgfholkyxneqsim4.png"></p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br><p>  <strong>Kesimpulan</strong> </p><br><p>      ,     ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> .         . </p><br><p>        ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br><p> <strong>,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">siemarell</a></strong> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451796/">https://habr.com/ru/post/id451796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451784/index.html">Drive hibrid untuk penyimpanan Enterprise. Pengalaman Menggunakan Seagate EXOS</a></li>
<li><a href="../id451786/index.html">Jalankan tes instrumental di Firebase Test Lab. Bagian 1: proyek iOS</a></li>
<li><a href="../id451790/index.html">Bahaya pengumpulan data dalam game</a></li>
<li><a href="../id451792/index.html">Empat sniffer javascript yang menjebak Anda di toko online</a></li>
<li><a href="../id451794/index.html">Piksel Indentasi Tekstur</a></li>
<li><a href="../id451798/index.html">Migrasi data dengan mongoDB dan Spring Boot</a></li>
<li><a href="../id451800/index.html">Membuat modem sonar sederhana</a></li>
<li><a href="../id451802/index.html">Komunitas .Net dari Raiffeisenbank mengundang ke Broadcast mitap UPD</a></li>
<li><a href="../id451806/index.html">iOS Digest No. 5 (27 April - 16 Mei)</a></li>
<li><a href="../id451812/index.html">Sekarang pengembang yang baik diukur oleh pandangan dan pelanggan - dan ini buruk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>