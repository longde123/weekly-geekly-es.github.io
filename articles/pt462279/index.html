<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌨️ 👦🏻 🈁 Construindo funis comportamentais na linguagem R, com base nos dados obtidos da API Yandex.Metrica Logs ⚒️ 🧑🏿‍🤝‍🧑🏿 🛎️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A análise de um funil de vendas é uma tarefa típica do marketing na Internet e, em particular, do comércio eletrônico. Com sua ajuda, você pode: 


- ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Construindo funis comportamentais na linguagem R, com base nos dados obtidos da API Yandex.Metrica Logs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462279/"><p>  A análise de um funil de vendas é uma tarefa típica do marketing na Internet e, em particular, do comércio eletrônico.  Com sua ajuda, você pode: </p><br><ul><li>  Descubra quais das etapas da compra você está perdendo clientes em potencial. </li><li>  Simular o volume de entrada de receita adicional, no caso de expansão de cada etapa no caminho da compra. </li><li> Avalie a qualidade do tráfego adquirido em várias plataformas de publicidade. </li><li>  Avalie a qualidade do processamento de aplicativos recebidos para cada um dos gerentes. </li></ul><br><p>  Neste artigo, falarei sobre como solicitar dados na linguagem R da API Yandex Metrics Logs, criar e visualizar um funil com base neles. </p><br><p> Uma das principais vantagens da linguagem R é a presença de um grande número de pacotes que expandem sua funcionalidade básica.  Neste artigo, veremos os <code>rym</code> , <code>funneljoin</code> e <code>ggplot2</code> . </p><br><p>  Usando o <code>rym</code> carregamos dados da API de logs, usamos o <code>funneljoin</code> para criar um funil comportamental e usamos o <code>ggplot2</code> visualizar o resultado. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/903/ac7/75e/903ac775e293295d418a628a673f73d6.jpg" alt="imagem"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Conteúdo </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Solicitar dados das métricas Yandex da API de logs</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instalação do pacote Rym</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhando com métricas Yandex da API de logs usando o pacote rym</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Autorização na API Yandex Metrics</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Solicitar dados da API Yandex Metrica</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Funil de construção funil</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instalando funneljoin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pós-processamento de dados recebidos da API de Logs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tipos de funil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Etapas do funil</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visualização de funil</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visualização do funil comum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visualização de funil por canais de tráfego</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclusão</a> </li></ul><br><h1 id="zapros-dannyh-iz-logs-api-yandeks-metriki">  Solicitar dados das métricas Yandex da API de logs </h1><br><p>  Quem não sabe o que é a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API de logs</a> aqui é uma citação da ajuda oficial do Yandex. </p><br><blockquote>  A API de logs permite que você receba dados não agregados coletados pelo Yandex.Metrica.  Essa API é destinada a usuários do serviço que desejam processar dados estatísticos de forma independente e usá-los para resolver problemas analíticos exclusivos. </blockquote><p>  Para trabalhar com a API Yandex.Metrica Logs no R, usaremos o pacote <code>rym</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Links úteis para o pacote rym</b> <div class="spoiler_text"><p>  Referências: </p><br><ul><li>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Documentação do pacote Rym</a></em> </li><li>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Página do pacote Rym no CRAN</a></em> </li><li>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Página do pacote Rym no github</a></em> </li><li>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Seminário on-line sobre pacotes Rym</a></em> </li></ul></div></div><br><p>  <code>rym</code> -R, que é uma interface para interagir com a API Yandex Metrica.  Permite trabalhar com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerenciamento</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, a</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relatórios</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, a API do Gore compatível com o Google Analytics v3</a> e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API de logs</a> . </p><br><h2 id="ustnovka-paketa-rym">  Instalação do pacote Rym </h2><br><p>  Para trabalhar com qualquer pacote no R, ele deve primeiro ser instalado e baixado.  Instale um pacote uma vez usando o comando <code>install.packages()</code> .  É necessário conectar o pacote em cada nova sessão de trabalho em R usando a função <code>library()</code> . </p><br><p>  Para instalar e conectar o pacote <code>rym</code> use o seguinte código: </p><br><pre> <code class="plaintext hljs">install.packages("rym") library(rym)</code> </pre> <br><h2 id="rabota-s-logs-api-yandeks-metriki-s-pomoschyu-paketa-rym">  Trabalhando com métricas Yandex da API de logs usando o pacote rym </h2><br><p>  Para criar funis comportamentais, precisamos fazer o download de uma tabela de todas as visitas feitas no seu site e preparar os dados para análises adicionais. </p><br><h3 id="avtorizaciya-v-api-yandeks-metriki">  Autorização na API Yandex Metrics </h3><br><p>  O trabalho com a API começa com a autorização.  No pacote <code>rym</code> o processo de autorização é parcialmente automatizado e inicia quando qualquer uma de suas funções é chamada. </p><br><p>  Na primeira vez em que você acessar a API, você será redirecionado ao navegador para confirmar a permissão para acessar suas métricas Yandex para o pacote <code>rym</code> .  Após a confirmação, você será redirecionado para a página onde um código de confirmação de autorização será gerado para você.  Ele deve ser copiado e colado no console do R como uma resposta à solicitação <code>"Enter authorize code:"</code> . </p><br><p>  Em seguida, você pode salvar as credenciais em um arquivo local, respondendo <code>y</code> ou <code>yes</code> à solicitação <code>"Do you want save API credential in local file ..."</code> .  Nesse caso, nas próximas chamadas para a API, você não precisará se autenticar novamente pelo navegador, e as credenciais serão carregadas do arquivo local. </p><br><h3 id="zapros-dannyh-iz-api-yandeks-metriki">  Solicitar dados da API Yandex Metrica </h3><br><p>  A primeira coisa que pedimos da API do Yandex Metrics é uma lista de contadores disponíveis e metas configuradas.  Isso é feito usando as <code>rym_get_counters()</code> e <code>rym_get_goals()</code> . </p><br><pre> <code class="plaintext hljs">#   library(rym) #    counters &lt;- rym_get_counters(login = " ") #    goals &lt;- rym_get_goals("0000000", #    login = " ")</code> </pre> <br><p>  Usando o exemplo de código acima, substitua <code>" "</code> pelo seu nome de usuário Yandex, sob o qual as métricas de Yandex necessárias estão disponíveis.  E <code>"0000000"</code> para o número do contador que você precisa.  Você pode ver os números dos contadores disponíveis na tabela de <em>contadores</em> carregados. </p><br><p>  A tabela de contadores disponíveis - <em>contadores</em> tem o seguinte formato: </p><br><pre> <code class="plaintext hljs"># A tibble: 2 x 9 id status owner_login name code_status site permission type gdpr_agreement_accepted &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; 1 11111111 Active site.ru1 Aerosus CS_NOT_FOUND site.ru edit simple 0 2 00000000 Active site.ru Aerosus RU CS_OK site.ru edit simple 1</code> </pre> <br><p>  O campo <em>id</em> mostra os números de todos os contadores métricos Yandex disponíveis. </p><br><p>  A tabela de <em>objetivos</em> é a seguinte: </p><br><pre> <code class="plaintext hljs"># A tibble: 4 x 5 id name type is_retargeting conditions &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; 1 47873638    url 0 type:contain, url:site.ru/checkout/cart/ 2 47873764    url 0 type:contain, url:site.ru/onestepcheckout/ 3 47874133     url 0 type:contain, url:/checkout/onepage/success 4 50646283     action 0 type:exact, url:click_phone</code> </pre> <br><p>  I.e.  no contador com o qual trabalho, as seguintes ações são configuradas: </p><br><ul><li>  Ir para a cesta </li><li>  Ir para pagamento </li><li>  Página de agradecimento por encomendar </li><li>  Clique no botão do telefone </li></ul><br><p>  No futuro, para conversão de dados, usaremos os pacotes incluídos na biblioteca <code>tidyr</code> : <code>tidyr</code> , <code>dplyr</code> .  Portanto, antes de usar o exemplo de código a seguir, instale e conecte esses pacotes ou toda a biblioteca <code>tidyverse</code> . </p><br><pre> <code class="plaintext hljs"># install.packages("tidyverse") # library(tidyverse) install.packages(c("dplyr", "tidyr")) library(dplyr) library(tidyr)</code> </pre> <br><p>  A função <code>rym_get_logs()</code> permite solicitar dados das métricas da API de logs de métricas do Yandex. </p><br><pre> <code class="plaintext hljs">#      logs &lt;- rym_get_logs(counter = "0000000", date.from = "2019-04-01", date.to = "2019-06-30", fields = "ym:s:visitID, ym:s:clientID, ym:s:date, ym:s:goalsID, ym:s:lastTrafficSource, ym:s:isNewUser", login = " ") %&gt;% mutate(ym.s.date = as.Date(ym.s.date), ym.s.clientID = as.character(ym.s.clientID))</code> </pre> <br><p>  Os principais argumentos para a função <code>rym_get_logs()</code> : </p><br><ul><li>  número do contador do qual você solicita logs; </li><li>  date.from - data de início; </li><li>  date.to - data final; </li><li>  fields - uma lista dos campos que você deseja carregar; </li><li>  login - login Yandex sob o qual o <em>contador</em> especificado no <em>contador</em> está disponível. </li></ul><br><p>  Portanto, solicitamos dados de visita da API de logs que contém as seguintes colunas: </p><br><ul><li>  ym: s: visitID - ID da visita </li><li>  ym: s: clientID - ID do usuário no site </li><li>  ym: s: date - Data da visita </li><li>  ym: s: goalsID - Identificador dos objetivos alcançados durante esta visita </li><li>  ym: s: lastTrafficSource - Fonte de tráfego </li><li>  ym: s: isNewUser - Primeira visita do visitante </li></ul><br><blockquote>  Para obter uma lista completa dos campos disponíveis, consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ajuda da</a> API de logs. </blockquote><p>  Os dados recebidos são suficientes para criarmos um funil, com relação ao qual o trabalho com a API de logs é concluído, e passamos à próxima etapa - pós-processamento dos dados baixados. </p><br><h1 id="postroenie-voronok-paket-funneljoin">  Funil de construção funil </h1><br><blockquote>  Uma parte significativa das informações fornecidas nesta seção é obtida no pacote README do funneljoin, disponível por <a href="">referência</a> . </blockquote><p>  <code>funneljoin</code> objetivo <code>funneljoin</code> é simplificar a análise de funil do comportamento do usuário.  Por exemplo, sua tarefa é encontrar pessoas que visitaram seu site e depois se registraram e descobrir quanto tempo se passou entre a primeira visita e o registro.  Ou você precisa encontrar usuários que visualizaram o cartão do produto e o adicionaram à cesta em dois dias.  O pacote <code>funneljoin</code> e a função <code>after_join()</code> ajudam a resolver esses problemas. </p><br><p>  <strong>Argumentos <code>after_join()</code> :</strong> </p><br><ul><li>  x - um conjunto de dados contendo informações sobre a conclusão do primeiro evento (no primeiro exemplo, visitando o site, na segunda visualização do cartão do produto). </li><li>  y - um conjunto de dados com informações sobre a conclusão do segundo evento (no primeiro exemplo de registro, no segundo, adicionando o produto à cesta). </li><li>  by_time - uma coluna contendo informações sobre a data em que os eventos ocorreram nas tabelas <em>xey</em> . </li><li>  by_user - uma coluna com identificadores de usuário nas tabelas <em>xey</em> . </li><li>  mode - o método usado para conectar: ​​"interno", "completo", "anti", "semi", "direito", "esquerdo".  Em vez disso, você também pode usar o <code>after_mode_join</code> (por exemplo, <code>after_inner_join</code> vez de <code>after_join (..., mode = "inner")</code> ). </li><li>  type - o tipo de sequência usada para definir pares de eventos, como "first-first", "last-first", "any-firststafter".  Descrito com mais detalhes na seção "Tipos de funis". </li><li>  max_gap / min_gap (opcional) - filtre pela duração máxima e mínima do tempo entre o primeiro e o segundo evento. </li><li>  gap_col (opcional) - se deve retornar uma coluna <em>.gap</em> numérica com uma diferença de horário entre os eventos.  O padrão é FALSE. </li></ul><br><h2 id="ustanovka-funneljoin">  Instalando funneljoin </h2><br><p>  No momento da redação deste artigo, o pacote <code>funneljoin</code> não <code>funneljoin</code> publicado no CRAN, portanto você pode instalá-lo no GitHub.  Para instalar pacotes do GitHub, você precisará de um pacote adicional - <code>devtools</code> . </p><br><pre> <code class="plaintext hljs">install.packages("devtools") devtools::install_github("robinsones/funneljoin")</code> </pre> <br><h2 id="postobrabotka-dannyh-poluchennyh-iz-logs-api">  Pós-processamento de dados recebidos da API de Logs </h2><br><p>  Para um estudo mais detalhado da construção funcional do funil, precisamos trazer os dados obtidos da API do Logs para o formato desejado.  A maneira mais conveniente de manipular dados, como escrevi acima, é fornecida pelos <code>dplyr</code> e <code>dplyr</code> . </p><br><p>  Para começar, faça o seguinte: </p><br><ol><li>  Nesse caso, uma linha da tabela de <em>logs</em> contém informações sobre uma visita e a coluna <em>ym.s.goalsID</em> é uma matriz do formulário - <code>[0,1,0,...]</code> , que contém identificadores de objetivos alcançados durante essa visita.  Para trazer a matriz para um formato adequado para trabalhos futuros, é necessário remover caracteres extras dela, no nosso caso, colchetes. </li><li>  É necessário reformatar a tabela para que uma linha contenha informações sobre uma meta alcançada durante a visita.  I.e.  se três metas foram atingidas durante uma visita, essa visita será dividida em três linhas e cada linha, na coluna <em>ym.s.goalsID,</em> conterá o identificador de apenas uma meta. </li><li>  Anexe uma tabela com uma lista de objetivos à tabela de logs para entender exatamente quais objetivos foram alcançados durante cada visita. </li><li>  Renomeie a coluna de <em>nome</em> com os objetivos para <em>eventos</em> . </li></ol><br><p>  Todas as ações acima são implementadas usando o seguinte código: </p><br><div class="spoiler">  <b class="spoiler_title">Código de pós-processamento para dados recebidos da API de logs</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#      logs_goals &lt;- logs %&gt;% mutate(ym.s.goalsID = str_replace_all(ym.s.goalsID, #     "\\[|\\]", "") %&gt;% str_split(",")) %&gt;% #     unnest(cols = c(ym.s.goalsID)) %&gt;% mutate(ym.s.goalsID = as.integer(ym.s.goalsID)) %&gt;% #  id     left_join(goals, by = c("ym.s.goalsID" = "id")) %&gt;% #      rename(events = name) #     events</code> </pre> </div></div><br><p>  Uma pequena explicação do código.  O operador <code>%&gt;%</code> é chamado de pipeline e torna o código mais legível e compacto.  De fato, ele pega o resultado da execução de uma função e a passa como o primeiro argumento para a próxima função.  Assim, é obtido um tipo de transportador, que permite não obstruir a RAM com variáveis ​​supérfluas que armazenam resultados intermediários. </p><br><p>  A função <code>str_replace_all</code> remove colchetes na coluna <em>ym.s.goalsID</em> .  <code>str_split</code> divide os identificadores de destino da coluna <em>ym.s.goalsID</em> em valores separados e <code>unnest</code> os em linhas separadas, duplicando os valores de todas as outras colunas. </p><br><p>  Usando <code>mutate</code> convertemos identificadores de destino para o tipo inteiro. </p><br><p>  <code>left_join</code> tabela de <em>metas</em> ao resultado, que armazena informações sobre as metas configuradas.  Usando a coluna <em>ym.s.goalsID</em> da tabela atual e a coluna de <em>ID</em> da tabela de <em>metas</em> como chave. </p><br><p>  Por fim, a função <code>rename</code> renomeia a coluna de <em>nome</em> para <em>eventos</em> . </p><br><p>  Agora a tabela <em>logs_goals</em> tem a <em>aparência</em> necessária para mais trabalhos. </p><br><p>  Em seguida, crie três novas tabelas: </p><br><ul><li>  first_visits - datas das primeiras sessões para todos os novos usuários </li><li>  carrinho - datas de adição de produtos ao carrinho </li><li>  pedidos - pedidos </li></ul><br><div class="spoiler">  <b class="spoiler_title">Código de criação da tabela</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#      first_visits &lt;- logs_goals %&gt;% filter(ym.s.isNewUser == 1 ) %&gt;% #     select(ym.s.clientID, #   clientID ym.s.date) #   date #       cart &lt;- logs_goals %&gt;% filter(events == "  ") %&gt;% select(ym.s.clientID, ym.s.date) #   orders &lt;- logs_goals %&gt;% filter(events == "   ") %&gt;% select(ym.s.clientID, ym.s.date)</code> </pre> </div></div><br><p>  Cada nova tabela é o resultado da filtragem da tabela principal <em>logs_goals</em> obtida na última etapa.  A filtragem é realizada pela função de <code>filter</code> . </p><br><p>  Para criar funis, basta deixar informações sobre o ID do usuário e a data do evento, que são armazenadas nas colunas <em>ym.s.clientID</em> e <em>ym.s.date</em> , nas novas tabelas.  As colunas desejadas foram selecionadas usando a função de <code>select</code> . </p><br><h2 id="tipy-voronok">  Tipos de funil </h2><br><p>  O argumento <em>type</em> aceita qualquer combinação dos valores <code>first</code> , <code>last</code> , <code>any</code> e <code>lastbefore</code> com <code>first</code> , <code>last</code> , <code>any</code> e <code>firstafter</code> .  A seguir, é apresentado um exemplo das combinações mais úteis que você pode usar: </p><br><ul><li>  <code>first-first</code> : obtenha os primeiros eventos <em>xey</em> para cada usuário.  Por exemplo, queremos obter a data da <strong>primeira</strong> visita e a data da <strong>primeira</strong> compra. Nesse caso, use o tipo de funil <code>first-first</code> . </li></ul><br><pre> <code class="plaintext hljs">#    first-first first_visits %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "first-first")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 42 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1552251706539589249 2019-04-18 2019-05-15 2 1554193975665391000 2019-04-02 2019-04-15 3 1554317571426012455 2019-04-03 2019-04-04 4 15544716161033564779 2019-04-05 2019-04-08 5 1554648729526295287 2019-04-07 2019-04-11 6 1554722099539384487 2019-04-08 2019-04-17 7 1554723388680198551 2019-04-08 2019-04-08 8 15547828551024398507 2019-04-09 2019-05-13 9 1554866701619747784 2019-04-10 2019-04-10 10 1554914125524519624 2019-04-10 2019-04-10 # ... with 32 more rows</code> </pre> <br><p>  Temos uma tabela na qual 1 linha contém dados sobre a data da primeira visita do usuário ao site e a data do primeiro pedido. </p><br><ul><li>  <code>first-firstafter</code> : obtenha o <em>x</em> mais antigo, depois o primeiro <em>y</em> aconteceu após o primeiro <em>x</em> .  Por exemplo, um usuário visitou seu site repetidamente e, durante as visitas, ele adicionou produtos à cesta, se você precisar obter a data de adição do <strong>primeiro</strong> produto à cesta e a data do pedido <strong>mais próximo</strong> , use o tipo de funil de <code>first-firstafter</code> . </li></ul><br><pre> <code class="plaintext hljs">cart %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "first-firstafter")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 49 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1551433754595068897 2019-04-02 2019-04-05 2 1552251706539589249 2019-05-15 2019-05-15 3 1552997205196001429 2019-05-23 2019-05-23 4 1553261825377658768 2019-04-11 2019-04-11 5 1553541720631103579 2019-04-04 2019-04-05 6 1553761108775329787 2019-04-16 2019-04-16 7 1553828761648236553 2019-04-03 2019-04-03 8 1554193975665391000 2019-04-13 2019-04-15 9 1554317571426012455 2019-04-04 2019-04-04 10 15544716161033564779 2019-04-08 2019-04-08 # ... with 39 more rows</code> </pre> <br><ul><li>  <code>lastbefore-firstafter</code> : primeiro <em>x</em> seguido por <em>y</em> antes do próximo <em>x</em> .  Por exemplo, um usuário visitou seu site repetidamente, algumas das sessões terminaram com uma compra.  Se você precisar obter a data da última sessão antes da compra e a data da compra que se seguiu, use o tipo de funil <code>lastbefore-firstafter</code> . </li></ul><br><pre> <code class="plaintext hljs">first_visits %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "lastbefore-firstafter")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 50 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1551433754595068897 2019-04-05 2019-04-05 2 1552251706539589249 2019-05-15 2019-05-15 3 1552251706539589249 2019-05-16 2019-05-16 4 1552997205196001429 2019-05-23 2019-05-23 5 1553261825377658768 2019-04-11 2019-04-11 6 1553541720631103579 2019-04-05 2019-04-05 7 1553761108775329787 2019-04-16 2019-04-16 8 1553828761648236553 2019-04-03 2019-04-03 9 1554193975665391000 2019-04-15 2019-04-15 10 1554317571426012455 2019-04-04 2019-04-04 # ... with 40 more rows</code> </pre> <br><p>  Nesse caso, recebemos uma tabela na qual uma linha contém a data em que o último produto foi adicionado à cesta antes de cada pedido ser concluído e a data do próprio pedido. </p><br><ul><li>  <code>any-firstafter</code> : obtém todos os <em>x</em> e o primeiro <em>y</em> depois dele.  Por exemplo, um usuário visitou repetidamente seu site, durante cada visita ele adicionou vários produtos à cesta e fez pedidos periodicamente com todos os produtos adicionados.  Se você precisar obter as datas de todas as adições à cesta e as datas de seus pedidos, use o tipo de funil a <code>any-firstafter</code> . </li></ul><br><pre> <code class="plaintext hljs">cart %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "any-firstafter")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 239 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1551433754595068897 2019-04-02 2019-04-05 2 1551433754595068897 2019-04-02 2019-04-05 3 1551433754595068897 2019-04-03 2019-04-05 4 1551433754595068897 2019-04-03 2019-04-05 5 1551433754595068897 2019-04-03 2019-04-05 6 1551433754595068897 2019-04-05 2019-04-05 7 1551433754595068897 2019-04-05 2019-04-05 8 1551433754595068897 2019-04-05 2019-04-05 9 1551433754595068897 2019-04-05 2019-04-05 10 1551433754595068897 2019-04-05 2019-04-05 # ... with 229 more rows</code> </pre> <br><ul><li>  any-any: obtém todos os <em>x</em> e todos os <em>y</em> próximos a cada <em>x</em> .  Por exemplo, você deseja receber uma lista de todas as visitas ao site com todos os pedidos subsequentes feitos por cada usuário. </li></ul><br><pre> <code class="plaintext hljs">first_visits %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "any-any")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 122 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1552251706539589249 2019-04-18 2019-05-15 2 1552251706539589249 2019-04-18 2019-05-15 3 1552251706539589249 2019-04-18 2019-05-15 4 1552251706539589249 2019-04-18 2019-05-16 5 1554193975665391000 2019-04-02 2019-04-15 6 1554193975665391000 2019-04-02 2019-04-25 7 1554317571426012455 2019-04-03 2019-04-04 8 15544716161033564779 2019-04-05 2019-04-08 9 1554648729526295287 2019-04-07 2019-04-11 10 1554722099539384487 2019-04-08 2019-04-17 # ... with 112 more rows</code> </pre> <br><h3 id="shagi-po-voronke">  Etapas do funil </h3><br><p>  Os exemplos acima demonstram o trabalho com a função <code>after_inner_join()</code> ; é conveniente usá-la nos casos em que todos os eventos são separados por tabelas separadas; no nosso caso, de acordo com as <em>tabelas first_visits</em> , <em>cart</em> e <em>orders</em> . </p><br><p>  Mas a API de logs fornece informações sobre todos os eventos em uma tabela e as <code>funnel_start()</code> e <code>funnel_step()</code> serão uma maneira mais conveniente de criar uma sequência de ações.  <code>funnel_start</code> ajuda a definir a primeira etapa do funil e leva cinco argumentos: </p><br><ul><li>  tbl - tabela de eventos; </li><li>  moment_type - O primeiro evento no funil; </li><li>  moment - O nome da coluna que contém o nome do evento; </li><li>  tstamp - Nome da coluna com a data em que o evento ocorreu; </li><li>  usuário - O nome da coluna com identificadores de usuário. </li></ul><br><pre> <code class="plaintext hljs">logs_goals %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = "   ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 52 x 2 ym.s.clientID `ym.s.date_   ` &lt;chr&gt; &lt;date&gt; 1 1556018960123772801 2019-04-24 2 1561216372134023321 2019-06-22 3 1556955573636389438 2019-05-04 4 1559220890220134879 2019-05-30 5 1553261825377658768 2019-04-11 6 1561823182372545402 2019-06-29 7 1556047887455246275 2019-04-23 8 1554722099539384487 2019-04-17 9 1555420652241964245 2019-04-17 10 1553541720631103579 2019-04-05 # ... with 42 more rows</code> </pre> <br><p>  <code>funnel_start</code> retorna uma tabela com as <em>colunas ym.s.clientI</em> e <em>ym.s.date_</em> <code>ym.s.date_   </code> (o nome da sua coluna com a data, _ e o nome do evento). </p><br><p>  As etapas a seguir podem ser adicionadas usando a função <code>funnel_step()</code> .  No <code>funnel_start</code> já especificamos os identificadores de todas as colunas necessárias, agora precisamos especificar qual evento será a próxima etapa no funil usando o argumento <em>moment_type</em> , e o <em>tipo de</em> conexão é o <em>tipo</em> (por exemplo, <code>"first-first"</code> , <code>"first-any"</code> ). </p><br><pre> <code class="plaintext hljs">logs_goals %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = "  ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID") %&gt;% funnel_step(moment_type = "   ", type = "first-last")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 319 x 3 ym.s.clientID `ym.s.date_  ` `ym.s.date_   ` &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1550828847886891355 2019-04-01 NA 2 1551901759770098825 2019-04-01 NA 3 1553595703262002507 2019-04-01 NA 4 1553856088331234886 2019-04-01 NA 5 1554044683888242311 2019-04-01 NA 6 1554095525459102609 2019-04-01 NA 7 1554100987632346537 2019-04-01 NA 8 1551433754595068897 2019-04-02 2019-04-05 9 1553627918798485452 2019-04-02 NA 10 155418104743178061 2019-04-02 NA # ... with 309 more rows</code> </pre> <br><p>  Com <code>funnel_step</code> você pode criar funis com qualquer número de etapas.  Para criar um funil completo para cada usuário, no meu exemplo, você pode usar o seguinte código: </p><br><div class="spoiler">  <b class="spoiler_title">Código para criar um funil completo para cada usuário</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#         #     events - " " logs_goals &lt;- logs_goals %&gt;% filter(ym.s.isNewUser == 1 ) %&gt;% mutate(events = " ") %&gt;% bind_rows(logs_goals) #     logs_goals %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = " ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID") %&gt;% funnel_step(moment_type = "  ", type = "first-last") %&gt;% funnel_step(moment_type = "  ", type = "first-last") %&gt;% funnel_step(moment_type = "   ", type = "first-last")</code> </pre> </div></div><br><p>  E agora a cereja no bolo é <code>summarize_funnel()</code> .  Uma função que permite exibir a porcentagem de usuários que passaram da etapa anterior para a próxima e a porcentagem de usuários que passaram da primeira etapa para cada uma subseqüente. </p><br><pre> <code class="plaintext hljs">my_funnel &lt;- logs_goals %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = " ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID") %&gt;% funnel_steps(moment_type = c("  ", "  ", "   "), type = "first-last") %&gt;% summarize_funnel()</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 4 x 4 moment_type nb_step pct_cumulative pct_step &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1   18637 1 NA 2    1589 0.0853 0.0853 3    689 0.0494 0.579 4     34 0.0370 0.749</code> </pre> <br><p> <code>nb_step</code> —   ,   , <code>pct_cumulative</code> —      ,  <code>pct_step</code> —    . </p><br><h1 id="vizualizaciya-voronki">   </h1><br><p>    <em>my_funnel</em>   ,        <code>ggplot2</code> . </p><br><p> <code>ggplot2</code> —       R,      .     ,      ,  . </p><br><p>  <code>ggplot2</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> ,     2005 .    ,    photoshop,  ,       . </p><br><h3 id="vizualizaciya-obschey-voronki">    </h3><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># install.packages("ggplot2") library(ggplot2) my_funnel %&gt;% mutate(padding = (sum(my_funnel$nb_step) - nb_step) / 2) %&gt;% gather(key = "variable", value = "val", -moment_type) %&gt;% filter(variable %in% c("nb_step", "padding")) %&gt;% arrange(desc(variable)) %&gt;% mutate(moment_type = factor(moment_type, levels = c("   ", "  ", "  ", " "))) %&gt;% ggplot( aes(x = moment_type) ) + geom_bar(aes(y = val, fill = variable), stat='identity', position='stack') + scale_fill_manual(values = c('coral', NA) ) + geom_text(data = my_funnel, aes(y = sum(my_funnel$nb_step) / 2, label = paste(round(round(pct_cumulative * 100,2)), '%')), colour='tomato4', fontface = "bold") + coord_flip() + theme(legend.position = 'none') + labs(x='moment', y='volume')</code> </pre> </div></div><br><p>         : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/260/763/bcf/260763bcf4c60a84ab713d2931e95ebe.png" alt="Visualização de funil"></p><br><p>     . </p><br><ol><li>         <em>my_funnel</em> . </li><li> <code>ggplot</code> —      ,    ,     ,    X     <em>moment_type</em> . </li><li> <code>geom_bar</code> —  —  ,            <code>aes</code> . </li><li> <code>scale_fill_manual</code> —    ,         ,    . </li><li> <code>geom_text</code> —   ,   %    . </li><li> <code>coord_flip</code> —   ,     . </li><li> <code>theme</code> —      : ,   ..           . </li><li> <code>labs</code> —     . </li></ol><br><h3 id="vizualizaciya-voronki-v-razreze-kanalov-trafika">       </h3><br><p>     ,   ,  ,      ,    . </p><br><p>           <code>lapply</code> ,       R.        ,      ,        <code>bind_rows</code> . </p><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#        first_visits &lt;- rename(first_visits, firstSource = ym.s.lastTrafficSource) #          logs_goals &lt;- select(first_visits, ym.s.clientID, firstSource) %&gt;% left_join(logs_goals, ., by = "ym.s.clientID") #     my_multi_funnel &lt;- lapply(c("ad", "organic", "direct"), function(source) { logs_goals %&gt;% filter(firstSource == source) %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = " ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID") %&gt;% funnel_steps(moment_type = c("  ", "  ", "   "), type = "first-last") %&gt;% summarize_funnel() %&gt;% mutate(firstSource = source) }) %&gt;% bind_rows() #  </code> </pre></div></div><br><pre> <code class="plaintext hljs"># A tibble: 12 x 5 moment_type nb_step pct_cumulative pct_step firstSource &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1   14392 1 NA ad 2    154 0.0107 0.0107 ad 3    63 0.00438 0.409 ad 4     14 0.000973 0.222 ad 5   3372 1 NA organic 6    68 0.0202 0.0202 organic 7    37 0.0110 0.544 organic 8     13 0.00386 0.351 organic 9   607 1 NA direct 10    49 0.0807 0.0807 direct 11    21 0.0346 0.429 direct 12     8 0.0132 0.381 direct</code> </pre> <br><p>     <em>my_multi_funnel</em> ,        . </p><br><div class="spoiler"> <b class="spoiler_title">       </b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#    my_multi_funnel %&gt;% mutate(padding = ( 1 - pct_cumulative) / 2 ) %&gt;% gather(key = "variable", value = "val", -moment_type, -firstSource) %&gt;% filter(variable %in% c("pct_cumulative", "padding")) %&gt;% arrange(desc(variable)) %&gt;% mutate(moment_type = factor(moment_type, levels = c("   ", "  ", "  ", " ")), variable = factor(variable, levels = c("pct_cumulative", "padding"))) %&gt;% ggplot( aes(x = moment_type) ) + geom_bar(aes(y = val, fill = variable), stat='identity', position='stack') + scale_fill_manual(values = c('coral', NA) ) + geom_text(data = my_multi_funnel_df, aes(y = 1 / 2, label =paste(round(round(pct_cumulative * 100, 2)), '%')), colour='tomato4', fontface = "bold") + coord_flip() + theme(legend.position = 'none') + labs(x='moment', y='volume') + facet_grid(. ~ firstSource)</code> </pre> </div></div><br><p>      : <br><img src="https://habrastorage.org/getpro/habr/post_images/12d/9a7/631/12d9a7631235b42f1081d996fa7eec62.png" alt="Funil do canal"></p><br><p>     ? </p><br><ol><li>   <code>first_visits</code>    <code>ym.s.lastTrafficSource</code>  <code>firstSource</code> . </li><li>   <code>left_join</code>          <em>ym.s.clientID</em> .                 <code>firstSource</code> . </li><li>   <code>lapply</code>        ad, organic  direct.         <code>bind_rows</code> . </li><li>      <code>facet_grid(. ~ firstSource)</code> ,         <code>firstSource</code> . </li></ol><br><h1 id="ps">  PS </h1><br><p>    .       <strong>PS</strong>      ,       R.           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">R4marketing</a> ,          R        . </p><br><p>    : </p><br><ul><li> ; </li><li> ; </li><li> ; </li><li>         R. </li></ul><br><h1 id="zaklyuchenie">  Conclusão </h1><br><p>  ,    ,        R     : </p><br><ol><li>             .; </li><li>   R    RStudio; </li><li>   <code>rym</code> , <code>funneljoin</code>  <code>ggplot2</code> ; </li><li>    <code>rym</code>   <code>rym_get_logs()</code>    .; </li><li>    <code>funneljoin</code>      . </li><li>      <code>ggplot2</code> . </li></ol><br><p>           ,     Logs API  ,      : CRM, 1   . ,         :  ,    -. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462279/">https://habr.com/ru/post/pt462279/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462269/index.html">John Romero para Doom: 80s Game Dev</a></li>
<li><a href="../pt462271/index.html">Código de bloqueio no iOS: como a Apple mudou de defesa em defesa para proteger uma única fronteira</a></li>
<li><a href="../pt462273/index.html">Gerencie seu suporte para laptop com o digispark</a></li>
<li><a href="../pt462275/index.html">Introdução ao PVS-Studio Static Analyzer for Java</a></li>
<li><a href="../pt462277/index.html">Comunicado técnico Grupo Mail.ru 2019</a></li>
<li><a href="../pt462283/index.html">Brinquedo GAZ-66 no painel de controle. Parte 1</a></li>
<li><a href="../pt462293/index.html">Como as tecnologias de desenvolvimento rápido podem se tornar uma fonte de vulnerabilidades desagradáveis</a></li>
<li><a href="../pt462295/index.html">O tamanho do diretório não vale nosso esforço</a></li>
<li><a href="../pt462297/index.html">Habr Weekly # 12 / OneWeb, estações contra agregadores, salários em TI, “querido, matamos a Internet” não eram permitidos na Federação Russa</a></li>
<li><a href="../pt462299/index.html">Arredondando para o todo no .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>