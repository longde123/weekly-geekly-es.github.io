<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öíÔ∏è üîè üë©üèΩ‚Äç‚öñÔ∏è Cat√©gories d'expressions en C ++ üíÜüèæ üåÜ ü§∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les cat√©gories d'expressions, telles que lvalue et rvalue , se rapportent davantage aux concepts th√©oriques fondamentaux du langage C ++ qu'aux aspect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cat√©gories d'expressions en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441742/"><p>  Les cat√©gories d'expressions, telles que <strong>lvalue</strong> et <strong>rvalue</strong> , se rapportent davantage aux concepts th√©oriques fondamentaux du langage C ++ qu'aux aspects pratiques de son utilisation.  Pour cette raison, de nombreux programmeurs m√™me exp√©riment√©s ont une vague id√©e de ce qu'ils signifient.  Dans cet article, je vais essayer d'expliquer la signification de ces termes aussi simple que possible, en diluant la th√©orie avec des exemples pratiques.  Je ferai une r√©serve tout de suite: l'article ne pr√©tend pas fournir la description la plus compl√®te et rigoureuse des cat√©gories d'expressions; pour plus de d√©tails, je recommande de contacter directement la source: standard du langage C ++. </p><a name="habracut"></a><br><blockquote>  L'article contiendra beaucoup de termes en anglais, cela est d√ª au fait que certains d'entre eux sont difficiles √† traduire en russe, tandis que d'autres sont traduits dans diff√©rentes sources de diff√©rentes mani√®res.  Par cons√©quent, j'indiquerai souvent des termes anglais, en les surlignant <em>en italique</em> . </blockquote><br><h2 id="nemnogo-istorii">  Un peu d'histoire </h2><br><p>  Les termes <strong>lvalue</strong> et <strong>rvalue</strong> sont <strong>r√©apparus</strong> en C. Il convient de noter que la confusion √©tait initialement pr√©sente dans la terminologie, car ils se r√©f√®rent √† des expressions et non √† des valeurs.  Historiquement, une <strong>lvalue</strong> est ce qui peut √™tre laiss√© de l'op√©rateur d'affectation, et une <strong>rvalue</strong> est ce qui ne peut √™tre que <em>droit</em> . </p><br><pre><code class="plaintext hljs">lvalue = rvalue;</code> </pre> <br><p>  Cependant, une telle d√©finition simplifie et d√©forme quelque peu l'essence.  La norme C89 d√©finit <strong>lvalue</strong> comme un <em>localisateur d'objets</em> , c'est-√†-dire  Un objet avec un emplacement m√©moire identifiable.  Par cons√©quent, tout ce qui ne correspondait pas √† cette d√©finition a √©t√© inclus dans la cat√©gorie valeur. </p><br><h2 id="byarn-speshit-na-pomosch">  Bjarn se pr√©cipite √† la rescousse </h2><br><p>  En C ++, la terminologie des cat√©gories d'expression a √©volu√© assez fortement, surtout apr√®s l'adoption de la norme C ++ 11, qui a introduit les concepts de liens <strong>rvalue</strong> et de <em>s√©mantique de d√©placement</em> .  L'histoire de l'√©mergence d'une nouvelle terminologie est d√©crite de mani√®re int√©ressante dans l'article de Straustrup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´New¬ª Value Terminology</a> . </p><br><p>  La nouvelle terminologie, plus rigoureuse, repose sur 2 propri√©t√©s: </p><br><ul><li>  la pr√©sence d'identit√© ( <em>identit√©</em> ), c'est-√†-dire un param√®tre permettant de comprendre si deux expressions se r√©f√®rent ou non √† la m√™me entit√© (par exemple, une adresse en m√©moire); </li><li>  la capacit√© de se d√©placer ( <em>peut √™tre d√©plac√©</em> ) - prend en charge la s√©mantique du mouvement. </li></ul><br><p>  Les expressions exprimant une identit√© sont g√©n√©ralis√©es sous le terme <strong>glvalue</strong> ( <em>valeurs g√©n√©ralis√©es</em> ), les expressions itin√©rantes sont appel√©es <strong>rvalue</strong> .  Les combinaisons de ces deux propri√©t√©s ont identifi√© 3 cat√©gories principales d'expressions: </p><br><table><thead><tr><th></th><th>  Avoir une identit√© </th><th>  D√©pourvu d'identit√© </th></tr></thead><tbody><tr><td>  <strong>Ne peut pas √™tre d√©plac√©</strong> </td><td>  lvalue </td><td>  - </td></tr><tr><td>  <strong>Peut √™tre d√©plac√©</strong> </td><td>  xvalue </td><td>  valeur </td></tr></tbody></table><br><p>  En fait, la norme C ++ 17 a introduit le concept d' <em>√©lision</em> de <em>copie</em> - formaliser des situations o√π le compilateur peut et doit √©viter de copier et de d√©placer des objets.  √Ä cet √©gard, la <strong>valeur</strong> ne <strong>peut</strong> pas n√©cessairement √™tre d√©plac√©e.  Des d√©tails et des exemples peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Cependant, cela n'affecte pas la compr√©hension du sch√©ma g√©n√©ral des cat√©gories d'expressions. </p><br><p>  Dans la norme C ++ moderne, la structure des cat√©gories est pr√©sent√©e sous la forme d'un tel sch√©ma: </p><br><p><img src="https://habrastorage.org/webt/2r/ut/w5/2rutw544jnidqrhi4cgwnc848xg.png" alt="image"></p><br><p>  Examinons en termes g√©n√©raux les propri√©t√©s des cat√©gories, ainsi que les expressions de langage qui sont incluses dans chacune des cat√©gories.  Je note tout de suite que les listes d'expressions ci-dessous pour chaque cat√©gorie ne peuvent pas √™tre consid√©r√©es comme compl√®tes; pour des informations plus pr√©cises et d√©taill√©es, reportez-vous directement √† la norme C ++. </p><br><h2 id="glvalue">  glvalue </h2><br><p>  Les expressions de la cat√©gorie <strong>glvalue</strong> ont les propri√©t√©s suivantes: </p><br><ul><li>  peut √™tre implicitement converti en <strong>valeur</strong> ; </li><li>  peut √™tre polymorphe, c'est-√†-dire que pour eux les concepts de type statique et dynamique ont un sens; </li><li>  ne peut pas √™tre de type <strong>void</strong> - cela d√©coule directement de la propri√©t√© d'avoir une identit√©, car pour les expressions de type <strong>void</strong> , aucun param√®tre de ce type ne les distinguerait les unes des autres; </li><li>  peut avoir un <em>type incomplet</em> , par exemple, sous la forme d'une <em>d√©claration directe</em> (si autoris√© pour une expression particuli√®re). </li></ul><br><h2 id="rvalue">  rvalue </h2><br><p>  Les expressions de la cat√©gorie <strong>rvalue</strong> ont les propri√©t√©s suivantes: </p><br><ul><li>  vous ne pouvez pas obtenir l'adresse <strong>rvalue</strong> en m√©moire - cela d√©coule directement du manque de propri√©t√© d'identit√©; </li><li>  ne peut pas √™tre sur le c√¥t√© gauche d'une affectation ou d'une instruction d'affectation compos√©e; </li><li>  peut √™tre utilis√© pour initialiser un lien <strong>lvalue</strong> constant ou <strong>un</strong> lien <strong>rvalue</strong> , tandis que la dur√©e de vie de l'objet s'√©tend √† la dur√©e de vie du lien; </li><li>  s'il est utilis√© comme argument lors de l'appel d'une fonction qui a 2 versions surcharg√©es: l'une accepte une r√©f√©rence <strong>lvalue</strong> constante et l'autre une r√©f√©rence <strong>rvalue</strong> , alors la version qui accepte la r√©f√©rence <strong>rvalue</strong> est s√©lectionn√©e.  C'est cette propri√©t√© qui est utilis√©e pour impl√©menter la <em>s√©mantique de d√©placement</em> : </li></ul><br><pre> <code class="plaintext hljs">class A { public: A() = default; A(const A&amp;) { std::cout &lt;&lt; "A::A(const A&amp;)\n"; } A(A&amp;&amp;) { std::cout &lt;&lt; "A::A(A&amp;&amp;)\n"; } }; ......... A a; A b(a); //  A(const A&amp;) A c(std::move(a)); //  A(A&amp;&amp;)</code> </pre> <br><blockquote>  Techniquement, A &amp;&amp; est une <strong>rvalue</strong> et peut √™tre utilis√© pour initialiser √† la fois une r√©f√©rence <strong>lvalue</strong> constante et une r√©f√©rence <strong>rvalue</strong> .  Mais gr√¢ce √† cette propri√©t√©, il n'y a pas d'ambigu√Øt√©; une option constructeur est accept√©e qui accepte une r√©f√©rence <strong>rvalue</strong> . </blockquote><br><h2 id="lvalue">  lvalue </h2><br><p>  Propri√©t√©s: </p><br><ul><li>  toutes les propri√©t√©s <strong>glvalue</strong> (voir ci-dessus); </li><li>  vous pouvez prendre l'adresse (en utilisant l'op√©rateur unaire int√©gr√© <code>&amp;</code> ); </li><li>  les valeurs l modifiables peuvent √™tre sur le c√¥t√© gauche de l'op√©rateur d'affectation ou des op√©rateurs d'affectation compos√©s; </li><li>  peut √™tre utilis√© pour initialiser une r√©f√©rence √† une <strong>valeur l</strong> (constante et non constante). </li></ul><br><p>  Les expressions suivantes appartiennent √† la cat√©gorie <strong>lvalue</strong> : </p><br><ul><li>  le nom d'une variable, d'une fonction ou d'un champ de classe de tout type.  M√™me si la variable est une r√©f√©rence <strong>rvalue</strong> , le nom de cette variable dans l'expression est une <strong>lvalue</strong> ; </li></ul><br><pre> <code class="plaintext hljs">void func() {} ......... auto* func_ptr = &amp;func; // :     auto&amp; func_ref = func; // :     int&amp;&amp; rrn = int(123); auto* pn = &amp;rrn; // :    auto&amp; rn = rrn; // :  lvalue-</code> </pre> <br><ul><li>  appeler une fonction ou un op√©rateur surcharg√© qui renvoie une r√©f√©rence <strong>lvalue</strong> , ou une expression de conversion au type d'une r√©f√©rence <strong>lvalue</strong> ; </li><li>  op√©rateurs d'affectation int√©gr√©s, op√©rateurs d'affectation compos√©s ( <code>=</code> , <code>+=</code> , <code>/=</code> , etc.), pr√©-incr√©mentation et pr√©-incr√©mentation int√©gr√©s ( <code>++a</code> , <code>--b</code> ), op√©rateur de d√©r√©f√©rence de pointeur int√©gr√© ( <code>*p</code> ); </li><li>  op√©rateur d'acc√®s int√©gr√© par index ( <code>a[n]</code> ou <code>n[a]</code> ), lorsque l'un des op√©randes est un tableau <strong>lvalue</strong> ; </li><li>  appeler une fonction ou une instruction surcharg√©e qui renvoie une r√©f√©rence <strong>rvalue</strong> √† une fonction; </li><li>  cha√Æne litt√©rale telle que <code>"Hello, world!"</code>  . </li></ul><br><blockquote>  Un litt√©ral de cha√Æne diff√®re de tous les autres litt√©raux en C ++ pr√©cis√©ment en ce qu'il est une <strong>valeur l</strong> (bien qu'immuable).  Par exemple, vous pouvez obtenir son adresse: </blockquote><br><pre> <code class="plaintext hljs">auto* p = &amp;‚ÄùHello, world!‚Äù; //   ,   </code> </pre> <br><h2 id="prvalue">  valeur </h2><br><p>  Propri√©t√©s: </p><br><ul><li>  toutes les propri√©t√©s <strong>rvalue</strong> (voir ci-dessus); </li><li>  ne peut pas √™tre polymorphe: les types d'expression statique et dynamique co√Øncident toujours; </li><li>  ne peut pas √™tre de type incomplet (sauf pour le type <strong>void</strong> , cela sera discut√© ci-dessous); </li><li>  ne peut pas avoir un type abstrait ou √™tre un tableau d'√©l√©ments d'un type abstrait. </li></ul><br><p>  Les expressions suivantes appartiennent √† la cat√©gorie <strong>prvalue</strong> : </p><br><ul><li>  litt√©ral (sauf cha√Æne), par exemple <code>42</code> , <code>true</code> ou <code>nullptr</code> ; </li><li>  un appel de fonction ou un op√©rateur surcharg√© qui renvoie une non-r√©f√©rence ( <code>str.substr(1, 2)</code> , <code>str1 + str2</code> , <code>it++</code> ) ou une expression de conversion en un type non-r√©f√©rence (par exemple, <code>static_cast&lt;double&gt;(x)</code> , <code>std::string{}</code> , <code>(int)42</code> ); </li><li>  post-incr√©mentation et post-d√©cr√©mentation <code>b--</code> ( <code>a++</code> , <code>b--</code> ), op√©rations math√©matiques int√©gr√©es ( <code>a + b</code> , <code>a % b</code> , <code>a &amp; b</code> , <code>a &lt;&lt; b</code> , etc.), op√©rations logiques int√©gr√©es ( <code>a &amp;&amp; b</code> , <code>a || b</code> <code>!a</code> , etc.), les op√©rations de comparaison ( <code>a &lt; b</code> , <code>a == b</code> , <code>a &gt;= b</code> , etc.), l'op√©ration int√©gr√©e de prise de l'adresse ( <code>&amp;a</code> ); </li><li>  <strong>ce</strong> pointeur; </li><li>  √©l√©ment de liste; </li><li>  param√®tre de mod√®le atypique, s'il ne s'agit pas d'une classe; </li><li>  expression lambda, par exemple <code>[](int x){ return x * x; }</code>  <code>[](int x){ return x * x; }</code> . </li></ul><br><h2 id="xvalue">  xvalue </h2><br><p>  Propri√©t√©s: </p><br><ul><li>  toutes les propri√©t√©s <strong>rvalue</strong> (voir ci-dessus); </li><li>  toutes les propri√©t√©s <strong>glvalue</strong> (voir ci-dessus). </li></ul><br><p>  Exemples d'expressions <strong>xvalue</strong> : </p><br><ul><li>  appeler une fonction ou un op√©rateur int√©gr√© qui renvoie une r√©f√©rence <strong>rvalue</strong> , par exemple <em>std :: move (x)</em> ; </li></ul><br><blockquote>  et en fait, pour le r√©sultat de l'appel √† <em>std :: move (),</em> vous ne pouvez pas obtenir une adresse en m√©moire ou initialiser un lien vers celle-ci, mais en m√™me temps, cette expression peut √™tre polymorphe: </blockquote><br><pre> <code class="plaintext hljs">struct XA { virtual void f() { std::cout &lt;&lt; "XA::f()\n"; } }; struct XB : public XA { virtual void f() { std::cout &lt;&lt; "XB::f()\n"; } }; XA&amp;&amp; xa = XB(); auto* p = &amp;std::move(xa); //  auto&amp; r = std::move(xa); //  std::move(xa).f(); //  ‚ÄúXB::f()‚Äù</code> </pre> <br><ul><li>  op√©rateur d'acc√®s int√©gr√© par index ( <code>a[n]</code> ou <code>n[a]</code> ) lorsque l'un des op√©randes est un tableau <strong>rvalue</strong> . </li></ul><br><h2 id="nekotorye-osobye-sluchai">  Quelques cas particuliers </h2><br><h3 id="operator-zapyataya">  Op√©rateur virgule </h3><br><p>  Pour l'op√©rateur de virgule int√©gr√©, la cat√©gorie d'expression correspond toujours √† la cat√©gorie d'expression du deuxi√®me op√©rande. </p><br><pre> <code class="plaintext hljs">int n = 0; auto* pn = &amp;(1, n); // lvalue auto&amp; rn = (1, n); // lvalue 1, n = 2; // lvalue auto* pt = &amp;(1, int(123)); // , rvalue auto&amp; rt = (1, int(123)); // , rvalue</code> </pre> <br><h2 id="vyrazheniya-tipa-void">  Expressions nulles </h2><br><p>  Les appels √† des fonctions qui renvoient <strong>void</strong> , saisissent des expressions de conversion √† <strong>void</strong> et <strong>l√®vent des</strong> exceptions sont consid√©r√©s <strong>comme des</strong> expressions de valeur, mais ils ne peuvent pas √™tre utilis√©s pour initialiser des r√©f√©rences ou comme arguments de fonctions. </p><br><h2 id="ternarnyy-operator-sravneniya">  Op√©rateur de comparaison ternaire </h2><br><p>  D√©finition de la cat√©gorie d'expression <code>a ? b : c</code>  <code>a ? b : c</code> - le cas n'est pas trivial, tout d√©pend des cat√©gories des deuxi√®me et troisi√®me arguments ( <code>b</code> et <code>c</code> ): </p><br><ul><li>  si <code>b</code> ou <code>c</code> sont de type <strong>void</strong> , alors la cat√©gorie et le type de l'expression enti√®re correspondent √† la cat√©gorie et au type de l'autre argument.  Si les deux arguments sont de type <strong>void</strong> , le r√©sultat est une <strong>valeur de</strong> type <strong>void</strong> ; </li><li>  si <code>b</code> et <code>c</code> sont des <strong>valeurs de gl du</strong> m√™me type, alors le r√©sultat est une <strong>valeur de gl du</strong> m√™me type; </li><li>  dans d'autres cas, le r√©sultat est une valeur. </li></ul><br><p>  Pour l'op√©rateur ternaire, un certain nombre de r√®gles sont d√©finies selon lesquelles des conversions implicites peuvent √™tre appliqu√©es aux arguments b et c, mais cela d√©passe quelque peu la <strong><em>port√©e de l'article; si</em></strong> vous √™tes int√©ress√©, je vous recommande de vous <strong><em>r√©f√©rer √† la section Op√©rateur conditionnel [expr.cond]</em></strong> de la norme. </p><br><pre> <code class="plaintext hljs">int n = 1; int v = (1 &gt; 2) ? throw 1 : n; // lvalue, .. throw   void,    n ((1 &lt; 2) ? n : v) = 2; //  lvalue,  ,   ((1 &lt; 2) ? n : int(123)) = 2; //   , ..    prvalue</code> </pre> <br><h2 id="obrascheniya-k-polyam-i-metodam-klassov-i-struktur">  R√©f√©rences aux domaines et aux m√©thodes des classes et des structures </h2><br><p>  Pour les expressions de la forme <code>am</code> et <code>p-&gt;m</code> (nous parlons ici de l'op√©rateur int√©gr√© <code>-&gt;</code> ), les r√®gles suivantes s'appliquent: </p><br><ul><li>  si <code>m</code> est un √©l√©ment d'√©num√©ration ou une m√©thode de classe non statique, alors l'expression enti√®re est consid√©r√©e comme une <strong>valeur</strong> (bien que le lien ne puisse pas √™tre initialis√© avec une telle expression); </li><li>  si <code>a</code> est une valeur <strong>r</strong> et que <code>m</code> est un champ non statique d'un type non r√©f√©rence, alors l'expression enti√®re appartient √† la cat√©gorie <strong>xvalue</strong> ; </li><li>  sinon c'est une <strong>valeur l</strong> . </li></ul><br><p>  Pour les pointeurs vers les membres de la classe ( <code>a.*mp</code> et <code>p-&gt;*mp</code> ), les r√®gles sont similaires: </p><br><ul><li>  si <code>mp</code> est un pointeur vers une m√©thode de classe, alors l'expression enti√®re est consid√©r√©e comme une <strong>valeur</strong> ; </li><li>  si <code>a</code> est une valeur <strong>r</strong> et que <code>mp</code> est un pointeur vers un champ de donn√©es, alors l'expression enti√®re se r√©f√®re √† la valeur <strong>x</strong> ; </li><li>  sinon c'est une <strong>valeur l</strong> . </li></ul><br><h2 id="bitovye-polya">  Champs de bits </h2><br><p>  Les champs de bits sont un outil pratique pour la programmation de bas niveau, cependant, leur impl√©mentation sort quelque peu de la structure g√©n√©rale des cat√©gories d'expression.  Par exemple, un appel √† un champ de bits semble √™tre une <strong>valeur l</strong> , <strong>car il</strong> peut √™tre pr√©sent sur le c√¥t√© gauche de l'op√©rateur d'affectation.  En m√™me temps, cela ne fonctionnera pas pour prendre l'adresse du champ de bits ou initialiser une liaison non constante par eux.  Vous pouvez initialiser une r√©f√©rence constante √† un champ de bits, mais une copie temporaire de l'objet sera cr√©√©e: </p><br><blockquote>  <strong><em>Champs de bits [class.bit]</em></strong> <br>  <em>Si l'initialiseur pour une r√©f√©rence de type const T &amp; est une valeur l qui se r√©f√®re √† un champ de bits, la r√©f√©rence est li√©e √† un temporaire initialis√© pour contenir la valeur du champ de bits;</em>  <em>la r√©f√©rence n'est pas directement li√©e au champ binaire.</em> </blockquote><br><pre> <code class="plaintext hljs">struct BF { int f:3; }; BF b; bf = 1; // OK auto* pb = &amp;b.f; //  auto&amp; rb = bf; // </code> </pre> <br><h2 id="vmesto-zaklyucheniya">  Au lieu d'une conclusion </h2><br><p>  Comme je l'ai mentionn√© dans l'introduction, la description ci-dessus ne pr√©tend pas √™tre compl√®te, mais donne seulement une id√©e g√©n√©rale des cat√©gories d'expressions.  Cette vue permettra de mieux comprendre les paragraphes de la norme et les messages d'erreur du compilateur. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441742/">https://habr.com/ru/post/fr441742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441728/index.html">R√©sum√© du concours en ligne pour le jeu Blotto</a></li>
<li><a href="../fr441732/index.html">Notes du Biorobot</a></li>
<li><a href="../fr441736/index.html">Automatisez la conversion des fichiers Word vers d'autres formats</a></li>
<li><a href="../fr441738/index.html">Bases thermoacoustiques</a></li>
<li><a href="../fr441740/index.html">Habra megarating: les meilleurs articles et statistiques de Habr depuis 12 ans. Partie 1/2</a></li>
<li><a href="../fr441744/index.html">Obtenir des liens vers des profils Vk √† partir des r√©sultats de SearchFace en utilisant Python (mais ce n'est pas pr√©cis)</a></li>
<li><a href="../fr441750/index.html">Projets sur CodeFest: Comment un manager peut-il survivre dans un monde en constante √©volution?</a></li>
<li><a href="../fr441752/index.html">ZTE a montr√© une montre smartphone Œ±</a></li>
<li><a href="../fr441754/index.html">Histoires de r√©ussite de Kubernetes en production. Partie 10: Reddit</a></li>
<li><a href="../fr441756/index.html">Pour la plate-forme russe des PC industriels, ils ont pris les processeurs Baikal-T1 et Alt OS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>