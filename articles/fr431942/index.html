<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋🏾 👩🏼‍🎓 👩🏼‍⚖️ Injection de dépendance hiérarchique dans React et MobX State Tree en tant que modèle de domaine 🧤 🧚🏼 🙆🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Après quelques projets sur React, j'ai eu la chance de travailler sur une application sous Angular 2. Franchement, je n'ai pas été impressionné. Mais ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Injection de dépendance hiérarchique dans React et MobX State Tree en tant que modèle de domaine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431942/"><p><img src="https://habrastorage.org/webt/78/ou/57/78ou57kbv7kdv7llnfl-_cwmxpw.png" align="left">  Après quelques projets sur React, j'ai eu la chance de travailler sur une application sous Angular 2. Franchement, je n'ai pas été impressionné.  Mais une chose a été retenue: la gestion de la logique et de l'état de l'application à l'aide de l'injection de dépendance.  Et je me suis demandé s'il était pratique de gérer l'état dans React en utilisant DDD, une architecture en couches et une injection de dépendances? </p><br><p>  Si vous êtes intéressé par la façon de procéder, et surtout, pourquoi - bienvenue dans la coupe! </p><a name="habracut"></a><br><p> Pour être honnête, même sur le backend, DI est rarement utilisé à son maximum.  Sauf dans les très grandes applications.  Et dans les petites et moyennes, même avec une DI, chaque interface n'a généralement qu'une seule implémentation.  Mais l'injection de dépendance a toujours ses avantages: </p><br><ul><li>  Le code est mieux structuré et les interfaces agissent comme des contrats explicites. </li><li>  La création de stubs dans les tests unitaires est simplifiée. </li></ul><br><p>  Mais les bibliothèques de test modernes pour JS, telles que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jest</a> , vous permettent d'écrire moki simplement sur la base du système modulaire ES6.  Donc, ici, nous ne tirerons pas beaucoup de profit de DI. </p><br><p>  Le deuxième point demeure - la gestion de la portée et de la durée de vie des objets.  Sur le serveur, la durée de vie est généralement liée à l'ensemble de l'application (Singleton) ou à la demande.  Et sur le client, l'unité de code principale est le composant.  Nous y serons attachés. </p><br><p> Si nous devons utiliser l'état au niveau de l'application, le moyen le plus simple consiste à définir la variable au niveau du module ES6 et à l'importer si nécessaire.  Et si l'état n'est nécessaire qu'à l'intérieur du composant - nous le mettons simplement dans <strong><code>this.state</code></strong> .  Pour tout le reste, il y a <strong><code>Context</code></strong> .  Mais le <strong><code>Context</code></strong> est trop bas: </p><br><ul><li>  Nous ne pouvons pas utiliser de contexte en dehors de l'arborescence des composants React.  Par exemple, dans une couche de logique métier. </li><li>  Nous ne pouvons pas utiliser plus d'un contexte dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code><strong>Class.contextType</strong></code></a> .  Pour déterminer la dépendance vis-à-vis de plusieurs services différents, nous devrons construire une «pyramide d'horreur» d'une manière nouvelle: </li></ul><br><img src="https://habrastorage.org/webt/as/4r/2n/as4r2ncj0zh_2dmpoxbuahkio74.png"><br><br><p>  Le nouveau crochet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code><strong>useContext()</strong></code></a> corrige légèrement la situation des composants fonctionnels.  Mais nous ne nous débarrasserons pas des nombreux <strong><code>&lt;Context.Provider&gt;</code></strong> .  Jusqu'à ce que nous transformions notre contexte en localisateur de service et son composant parent en racine de composition.  Mais ici ce n'est pas loin de DI, alors commençons! </p><br><blockquote>  Vous pouvez ignorer cette partie et aller directement à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">description de l'architecture.</a> </blockquote><br><h2 id="realizaciya-mehanizma-di">  Implémentation du mécanisme DI </h2><br><p>  Nous avons d'abord besoin d'un contexte React: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InjectorContext= React.createContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre> <br><p>  Puisque React utilise le constructeur de composants pour ses besoins, nous utiliserons Property Injection.  Pour ce faire, définissez le décorateur <strong><code>@inject</code></strong> , qui: </p><br><ul><li>  définit la propriété <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code><strong>Class.contextType</strong></code></a> , </li><li>  obtient le type de dépendance </li><li>  recherche un objet <strong><code>Injector</code></strong> et résout la dépendance. </li></ul><br><div class="spoiler">  <b class="spoiler_title">inject.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"reflect-metadata"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target, key</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  static cotextType target.constructor.contextType = InjectorContext; //    const type = Reflect.getMetadata("design:type", target, key); //  property Object.defineProperty(target, key, { configurable: true, enumerable: true, get() { //  Injector       const instance = getInstance(getInjector(this), type); Object.defineProperty(this, key, { enumerable: true, writable: true, value: instance }); return instance; }, // settet     Dependency Injection set(instance) { Object.defineProperty(this, key, { enumerable: true, writable: true, value: instance }); } }); }</span></span></code> </pre> </div></div><br><p>  Maintenant, nous pouvons définir des dépendances entre des classes arbitraires: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { inject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-ioc"</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooService</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BarService</span></span></span><span class="hljs-class"> </span></span>{ @inject foo: FooService; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ @inject foo: FooService; @inject bar: BarService; }</code> </pre> <br><p>  Pour ceux qui n'acceptent pas les décorateurs, nous définissons la fonction <strong><code>inject()</code></strong> avec cette signature: </p><br><pre> <code class="javascript hljs">type Constructor&lt;T&gt; = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (...args: any[]) =&gt; T; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target: Object, type: Constructor&lt;T&gt; | Function</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">inject.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target, keyOrType</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFunction(keyOrType)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getInstance(getInjector(target), keyOrType); } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> </div></div><br><p>  Cela vous permettra de définir explicitement les dépendances: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooService</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BarService</span></span></span><span class="hljs-class"> </span></span>{ foo = inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, FooService); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ foo = inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, FooService); bar = inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, BarService); <span class="hljs-comment"><span class="hljs-comment">//   static contextType = InjectorContext; }</span></span></code> </pre> <br><p>  Qu'en est-il des composants fonctionnels?  Pour eux, nous pouvons implémenter Hook <strong><code>useInstance()</code></strong> </p><br><div class="spoiler">  <b class="spoiler_title">hooks.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { useRef, useContext } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> injector = useContext(InjectorContext); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ref.current || (ref.current = getInstance(injector, type)); }</code> </pre> </div></div><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { useInstance } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-ioc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = useInstance(FooService); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = useInstance(BarService); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">; }</span></span></code> </pre> <br><p>  Nous allons maintenant déterminer à quoi pourrait ressembler notre <strong><code>Injector</code></strong> , comment le trouver et comment résoudre les dépendances.  L'injecteur doit contenir une référence au parent, un cache d'objets pour les dépendances déjà résolues et un dictionnaire de règles pour les dépendances non encore résolues. </p><br><div class="spoiler">  <b class="spoiler_title">injector.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs">type Binding = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">injector: Injector</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Injector</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    Injector _parent?: Injector; //    _bindingMap: Map&lt;Function, Binding&gt;; //      _instanceMap: Map&lt;Function, Object&gt;; }</span></span></code> </pre> </div></div><br><p>  Pour les composants React, <strong><code>Injector</code></strong> est disponible via le champ <strong><code>this.context</code></strong> , et pour les classes de dépendance, nous pouvons temporairement placer <strong><code>Injector</code></strong> dans une variable globale.  Pour accélérer la recherche d'un injecteur pour chaque classe, nous mettrons en cache le lien vers <strong><code>Injector</code></strong> dans un champ caché. </p><br><div class="spoiler">  <b class="spoiler_title">injector.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> INJECTOR = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span> === <span class="hljs-string"><span class="hljs-string">"function"</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>() : <span class="hljs-string"><span class="hljs-string">"__injector__"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentInjector = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInjector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> injector = target[INJECTOR]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (injector) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> injector; } injector = currentInjector || target.context; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (injector <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Injector) { target[INJECTOR] = injector; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> injector; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> </div></div><br><p>  Pour trouver une règle de liaison spécifique, nous devons remonter l'arborescence des injecteurs à l'aide de la fonction <strong><code>getInstance()</code></strong> </p><br><div class="spoiler">  <b class="spoiler_title">injector.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">injector, type</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (injector) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> instance = injector._instanceMap.get(type); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instance !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> binding = injector._bindingMap.get(type); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binding) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prevInjector = currentInjector; currentInjector = injector; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { instance = binding(injector); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { currentInjector = prevInjector; } injector._instanceMap.set(type, instance); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } injector = injector._parent; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; }</code> </pre> </div></div><br><p>  Enfin, passons à l'enregistrement des dépendances.  Pour ce faire, nous avons besoin du <strong><code>provider()</code></strong> HOC <strong><code>provider()</code></strong> , qui prend un tableau de liaisons de dépendance vers leurs implémentations et enregistre un nouvel <strong><code>Injector</code></strong> via <strong><code>InjectorContext.Provider</code></strong> </p><br><div class="spoiler">  <b class="spoiler_title">provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> provider = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...definitions</span></span></span><span class="hljs-function">) =&gt;</span></span> Wrapped =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bindingMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); addBindings(bindingMap, definitions); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Provider</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Injector</span></span></span><span class="hljs-class"> </span></span>{ _parent = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context; _bindingMap = bindingMap; _instanceMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;InjectorContext.Provider value={this}&gt; &lt;Wrapped {...this.props} /&gt; &lt;/InjectorContext.Provider&gt; ); } static contextType = InjectorContext; static register(...definitions) { addBindings(bindingMap, definitions); } }; };</code> </pre> </div></div><br><p>  Et aussi, un ensemble de fonctions de liaison qui implémentent diverses stratégies pour créer des instances de dépendance. </p><br><div class="spoiler">  <b class="spoiler_title">bindings.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toClass = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">constructor</span></span></span><span class="hljs-function"> =&gt;</span></span> asBinding(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">injector</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(); if (!instance[INJECTOR]) { instance[INJECTOR] = injector; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toFactory = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">depsOrFactory, factory</span></span></span><span class="hljs-function">) =&gt;</span></span> asBinding( factory ? <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">injector</span></span></span><span class="hljs-function"> =&gt;</span></span> factory(...depsOrFactory.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function"> =&gt;</span></span> getInstance(injector, type))) : depsOrFactory ); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toExisting = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function"> =&gt;</span></span> asBinding(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">injector</span></span></span><span class="hljs-function"> =&gt;</span></span> getInstance(injector, type)); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toValue = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> asBinding(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> value); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IS_BINDING = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span> === <span class="hljs-string"><span class="hljs-string">"function"</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>() : <span class="hljs-string"><span class="hljs-string">"__binding__"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asBinding</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">binding</span></span></span><span class="hljs-function">) </span></span>{ binding[IS_BINDING] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> binding; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addBindings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bindingMap, definitions</span></span></span><span class="hljs-function">) </span></span>{ definitions.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">definition</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> token, binding; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(definition)) { [token, binding = token] = definition; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { token = binding = definition; } bindingMap.set(token, binding[IS_BINDING] ? binding : toClass(binding)); }); }</code> </pre> </div></div><br><p>  Nous pouvons maintenant enregistrer des liaisons de dépendance au niveau d'un composant arbitraire sous la forme d'un ensemble de paires <strong><code>[&lt;&gt;, &lt;&gt;]</code></strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { provider, toClass, toValue, toFactory, toExisting } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-ioc"</span></span>; @provider( <span class="hljs-comment"><span class="hljs-comment">//    [FirstService, toClass(FirstServiceImpl)], //     [SecondService, toValue(new SecondServiceImpl())], //    [ThirdService, toFactory( [FirstService, SecondService], (first, second) =&gt; ThirdServiceFactory.create(first, second) )], //      [FourthService, toExisting(FirstService)] ) class MyComponent extends React.Component { // ... }</span></span></code> </pre> <br><p>  Ou sous forme abrégée pour les classes: </p><br><pre> <code class="javascript hljs">@provider( <span class="hljs-comment"><span class="hljs-comment">// [FirstService, toClass(FirstService)] FirstService, // [SecondService, toClass(SecondServiceImpl)] [SecondService, SecondServiceImpl] ) class MyComponent extends React.Component { // ... }</span></span></code> </pre> <br><p>  Puisque la durée de vie d'un service est déterminée par le composant fournisseur dans lequel il est enregistré, nous pouvons définir pour chaque service une méthode de nettoyage <strong><code>.dispose()</code></strong> .  Dans celui-ci, nous pouvons nous désinscrire de certains événements, fermer des sockets, etc.  Lorsque vous supprimez le fournisseur du DOM, il appellera <strong><code>.dispose()</code></strong> sur tous les services qu'il crée. </p><br><div class="spoiler">  <b class="spoiler_title">provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> provider = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...definitions</span></span></span><span class="hljs-function">) =&gt;</span></span> Wrapped =&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... return class Provider extends Injector { // ... componentWillUnmount() { this._instanceMap.forEach(instance =&gt; { if (isObject(instance) &amp;&amp; isFunction(instance.dispose)) { instance.dispose(); } }); } // ... }; };</span></span></code> </pre> </div></div><br><p>  Pour séparer le code et le chargement paresseux, nous devrons peut-être inverser la méthode d'enregistrement des services auprès des fournisseurs.  Le décorateur <strong><code>@registerIn()</code></strong> nous aidera avec cela. </p><br><div class="spoiler">  <b class="spoiler_title">provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> registrationQueue = []; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> registerIn = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getProvider, binding</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> =&gt; { registrationQueue.push(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { getProvider().register(binding ? [<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>, binding] : <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>); }); return <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>; };</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">injector.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">injector, type</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (registrationQueue.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { registrationQueue.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">registration</span></span></span><span class="hljs-function"> =&gt;</span></span> { registration(); }); registrationQueue.length = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (injector) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> </div></div><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { registerIn } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-ioc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HomePage } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../components/HomePage"</span></span>; @registerIn(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> HomePage) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyLazyLoadedService</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><img src="https://habrastorage.org/webt/gu/w5/d-/guw5d-sj0h53wnapsftgqeqnvvg.png"><br><p>  Ainsi, pour 150 lignes et 1 Ko de code, vous pouvez implémenter un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conteneur DI hiérarchique</a> presque complet. </p><br><h2 id="arhitektura-prilozheniya">  Architecture d'application </h2><br><p>  Enfin, passons à l'essentiel - comment organiser l'architecture de l'application.  Il y a trois options possibles, selon la taille de l'application, la complexité du sujet et notre paresse. </p><br><h3 id="1-the-ugly">  1. Le laid </h3><br><p>  Nous avons un DOM virtuel, ce qui signifie qu'il devrait être rapide.  Au moins avec cette sauce, React a été servi à l'aube d'une carrière.  Par conséquent, n'oubliez pas le lien vers le composant racine (par exemple, en utilisant le décorateur <strong><code>@observer</code></strong> ).  Et nous appellerons <strong><code>.forceUpdate()</code></strong> dessus après chaque action affectant les services partagés (par exemple, en utilisant le décorateur <strong><code>@action</code></strong> ) </p><br><div class="spoiler">  <b class="spoiler_title">observer.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Wrapped</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ componentDidMount() { observerRef = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } componentWillUnmount() { observerRef = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Wrapped</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...this.props</span></span></span></span><span class="xml"><span class="hljs-tag">} /&gt;</span></span></span><span class="xml">; } } } let observerRef = null;</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">action.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_target, _key, descriptor</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> method = descriptor.value; descriptor.value = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; runningCount++; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = method.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { runningCount--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runningCount === <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; observerRef) { observerRef.forceUpdate(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> runningCount = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> </div></div><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserService</span></span></span><span class="hljs-class"> </span></span>{ @action doSomething() {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ @inject userService: UserService; } @provider(UserService) @observer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  Cela fonctionnera même.  Mais ... vous comprenez vous-même :-) </p><br><h3 id="2-the-bad">  2. Le mauvais </h3><br><p>  Nous ne sommes pas satisfaits de tout rendre pour chaque éternuement.  Mais nous voulons toujours utiliser <del>  presque </del>  objets et tableaux réguliers pour stocker l'état.  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MobX</a> ! </p><br><p>  Nous démarrons plusieurs stockages de données avec des actions standard: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { observable, action } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mobx"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserStore</span></span></span><span class="hljs-class"> </span></span>{ byId = observable.map&lt;number, User&gt;(); @action add(user: User) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.byId.set(user.id, user); } <span class="hljs-comment"><span class="hljs-comment">// ... } export class PostStore { // ... }</span></span></code> </pre> <br><p>  Nous retirons la logique métier, les E / S, etc. à la couche services: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { action } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mobx"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { inject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-ioc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AccountService</span></span></span><span class="hljs-class"> </span></span>{ @inject userStore userStore; @action updateUserInfo(userInfo: Partial&lt;User&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userStore.byId.get(userInfo.id); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(user, userInfo); } }</code> </pre> <br><p>  Et nous les distribuons en composants: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { observer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mobx-react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { provider, inject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-ioc"</span></span>; @provider(UserStore, PostStore) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{} @provider(AccountService) @observer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AccountPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span>{} @observer <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserForm</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ @inject accountService: AccountService; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Il en va de même pour les composants fonctionnels et sans décorateurs</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { action } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mobx"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { inject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-ioc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AccountService</span></span></span><span class="hljs-class"> </span></span>{ userStore = inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, UserStore); updateUserInfo = action(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">userInfo: Partial&lt;User&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userStore.byId.get(userInfo.id); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(user, userInfo); }); }</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { observer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mobx-react-lite"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { provider, useInstance } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-ioc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = provider(UserStore, PostStore)(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... }); const AccountPage = provider(AccountService)(observer(props =&gt; { // ... })); const UserFrom = observer(props =&gt; { const accountService = useInstance(AccountService); // ... });</span></span></code> </pre> </div></div><br><p>  Le résultat est une architecture classique à trois niveaux. </p><br><h3 id="3-the-good">  3. Le bien </h3><br><p>  Parfois, le sujet devient si complexe qu'il est déjà gênant de travailler avec lui à l'aide d'objets simples (ou d'un modèle anémique en termes de DDD).  Cela est particulièrement visible lorsque les données ont une structure relationnelle avec de nombreuses relations.  Dans de tels cas, la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MobX State Tree</a> vient à la rescousse, vous permettant d'appliquer les principes de la conception pilotée par domaine dans l'architecture de l'application frontale. </p><br><p>  La conception d'un modèle commence par une description des types: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// models/Post.ts import { types as t, Instance } from "mobx-state-tree"; export const Post = t .model("Post", { id: t.identifier, title: t.string, body: t.string, date: t.Date, rating: t.number, author: t.reference(User), comments: t.array(t.reference(Comment)) }) .actions(self =&gt; ({ voteUp() { self.rating++; }, voteDown() { self.rating--; }, addComment(comment: Comment) { self.comments.push(comment); } })); export type Post = Instance&lt;typeof Post&gt;;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">models / User.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { types <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t, Instance } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mobx-state-tree"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User = t.model(<span class="hljs-string"><span class="hljs-string">"User"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: t.identifier, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: t.string }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> type User = Instance&lt;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> User&gt;;</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">modèles / Comment.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { types <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t, Instance } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mobx-state-tree"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { User } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./User"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comment = t .model(<span class="hljs-string"><span class="hljs-string">"Comment"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: t.identifier, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: t.string, <span class="hljs-attr"><span class="hljs-attr">date</span></span>: t.Date, <span class="hljs-attr"><span class="hljs-attr">rating</span></span>: t.number, <span class="hljs-attr"><span class="hljs-attr">author</span></span>: t.reference(User) }) .actions(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">self</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ voteUp() { self.rating++; }, voteDown() { self.rating--; } })); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> type Comment = Instance&lt;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> Comment&gt;;</code> </pre> </div></div><br><p>  Et le type de magasin de données: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// models/index.ts import { types as t } from "mobx-state-tree"; export { User, Post, Comment }; export default t.model({ users: t.map(User), posts: t.map(Post), comments: t.map(Comment) });</span></span></code> </pre> <br><p>  Les types d'entité contiennent l'état du modèle de domaine et les opérations de base avec celui-ci.  Des scénarios plus complexes, y compris les E / S, sont implémentés dans la couche services. </p><br><div class="spoiler">  <b class="spoiler_title">services / DataContext.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Instance, unprotect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mobx-state-tree"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Models <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../models"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataContext</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> create() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> models = Models.create(); unprotect(models); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> models; } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface DataContext extends Instance&lt;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> Models&gt; {}</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">services / AuthService.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mobx"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { User } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../models"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{ @observable currentUser: User; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">services / PostService.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { inject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-ioc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { action } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mobx"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Post } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../models"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostService</span></span></span><span class="hljs-class"> </span></span>{ @inject dataContext: DataContext; @inject authService: AuthService; <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> publishPost(postInfo: Partial&lt;Post&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">"/posts"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">"POST"</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(postInfo) }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { id } = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.json(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.savePost(id, postInfo); } @action savePost(id: string, <span class="hljs-attr"><span class="hljs-attr">postInfo</span></span>: Partial&lt;Post&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> post = Post.create({ id, <span class="hljs-attr"><span class="hljs-attr">rating</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">date</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(), <span class="hljs-attr"><span class="hljs-attr">author</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.authService.currentUser.id, <span class="hljs-attr"><span class="hljs-attr">comments</span></span>: [], ...postInfo }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dataContext.posts.put(post); } }</code> </pre> </div></div><br><p>  La principale caractéristique de MobX State Tree est le travail efficace avec les instantanés de données.  À tout moment, nous pouvons obtenir l'état sérialisé de toute entité, collection ou même l'état complet de l'application à l'aide de la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code><strong>getSnapshot()</strong></code></a> .  Et de la même manière, nous pouvons appliquer un instantané à n'importe quelle partie du modèle en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code><strong>applySnapshot()</strong></code></a> .  Cela nous permet d'initialiser l'état à partir du serveur dans plusieurs lignes de code, de charger depuis LocalStorage ou même d'interagir avec lui via Redux DevTools. </p><br><p>  Puisque nous utilisons un modèle relationnel normalisé, nous avons besoin de la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">normalizr</a> pour charger les données.  Il vous permet de traduire l'arborescence JSON en tables plates d'objets regroupés par <strong><code>id</code></strong> , selon le schéma de données.  Juste au format que MobX State Tree est nécessaire comme instantané. </p><br><p>  Pour ce faire, définissez les schémas d'objets téléchargés depuis le serveur: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"normalizr"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UserSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> schema.Entity(<span class="hljs-string"><span class="hljs-string">"users"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CommentSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> schema.Entity(<span class="hljs-string"><span class="hljs-string">"comments"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">author</span></span>: UserSchema }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PostSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> schema.Entity(<span class="hljs-string"><span class="hljs-string">"posts"</span></span>, { <span class="hljs-comment"><span class="hljs-comment">//   - //      author: UserSchema, comments: [CommentSchema] }); export { UserSchema, PostSchema, CommentSchema };</span></span></code> </pre> <br><p>  Et chargez les données dans le stockage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { inject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-ioc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { normalize } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"normalizr"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { applySnapshot } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mobx-state-tree"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostService</span></span></span><span class="hljs-class"> </span></span>{ @inject dataContext: DataContext; <span class="hljs-comment"><span class="hljs-comment">// ... async loadPosts() { const response = await fetch("/posts.json"); const posts = await response.json(); const { entities } = normalize(posts, [PostSchema]); applySnapshot(this.dataContext, entities); } // ... }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">posts.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"    React"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: <span class="hljs-string"><span class="hljs-string">"  -     React..."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-12-10T18:18:58.512Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rating"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"comments"</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hmmm..."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-12-10T18:18:58.512Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rating"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span> } }] }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">234</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Lorem ipsum"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: <span class="hljs-string"><span class="hljs-string">"Lorem ipsum dolor sit amet..."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-12-10T18:18:58.512Z"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rating"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Marcus Tullius Cicero"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"comments"</span></span>: [] } ]</code> </pre> </div></div><br><p>  Enfin, enregistrez les services dans les composants appropriés: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { observer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"mobx-react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { provider, inject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-ioc"</span></span>; @provider(AuthService, PostService, [ DataContext, toFactory(DataContext.create) ]) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ @inject postService: PostService; componentDidMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.postService.loadPosts(); } }</code> </pre> <br><p>  Il s'avère que la même architecture à trois couches, mais avec la possibilité de maintenir l'état et la vérification d'exécution des types de données (en mode DEV).  Ce dernier vous permet de vous assurer que si aucune exception ne se produit, l'état de l'entrepôt de données correspond à la spécification. </p><br><img src="https://habrastorage.org/webt/po/3u/vi/po3uvia2jujcg9q7w1ptr8kvwzk.png"><br><p><br></p><br><hr><br><p>  Pour ceux qui étaient intéressés, un lien vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> et une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démo</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431942/">https://habr.com/ru/post/fr431942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431932/index.html">Fort Byte Car (et plus) Native American</a></li>
<li><a href="../fr431934/index.html">Comment l'intelligence artificielle aide-t-elle à travailler avec des documents juridiques? Conférence d'Egor Budnikov d'ABBYY</a></li>
<li><a href="../fr431936/index.html">Résultats du concours TechnoText</a></li>
<li><a href="../fr431938/index.html">Racine de cube entier dans Verilog</a></li>
<li><a href="../fr431940/index.html">Les gens s'épuisent s'ils ne sentent pas leur valeur. Que faire à ce sujet?</a></li>
<li><a href="../fr431944/index.html">Yealink Meeting Server 2.0 - Nouvelles fonctionnalités de vidéoconférence</a></li>
<li><a href="../fr431946/index.html">Semaine de la sécurité 49: piratage de Dell et Marriott</a></li>
<li><a href="../fr431948/index.html">Deep Mind a appris à son IA à prédire la structure des protéines</a></li>
<li><a href="../fr431950/index.html">Comment prévoir la demande et automatiser les achats à l'aide de l'apprentissage automatique: cas Ozon</a></li>
<li><a href="../fr431954/index.html">L'ancien vice-président de Sun et DEC devient président de MIPS / Wave, parle de la Russie et de RISC / V</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>