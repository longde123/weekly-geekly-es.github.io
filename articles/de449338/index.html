<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòü üèôÔ∏è üîä Julia. Webdienste üêï üëÅÔ∏è üòê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir betrachten weiterhin Technologien Julia. Und heute werden wir √ºber Pakete sprechen, die zum Erstellen von Webdiensten entwickelt wurden. Es ist ke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Julia. Webdienste</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449338/"><p><img src="https://habrastorage.org/webt/ez/8k/mw/ez8kmwwtsavwdve31oj9__-kj6e.png"></p><br><p>  Wir betrachten weiterhin Technologien Julia.  Und heute werden wir √ºber Pakete sprechen, die zum Erstellen von Webdiensten entwickelt wurden.  Es ist kein Geheimnis, dass die Hauptnische der Julia-Sprache das Hochleistungsrechnen ist.  Daher ist es ein ziemlich logischer Schritt, direkt Webdienste zu erstellen, die diese Berechnungen bei Bedarf durchf√ºhren k√∂nnen.  Nat√ºrlich sind Webdienste nicht die einzige M√∂glichkeit, in einer Netzwerkumgebung zu kommunizieren.  Da sie heute in verteilten Systemen am h√§ufigsten verwendet werden, werden wir die Erstellung von Diensten in Betracht ziehen, die HTTP-Anforderungen bedienen. </p><br><p>  Beachten Sie, dass es aufgrund der Jugend von Julia eine Reihe konkurrierender Pakete gibt.  Daher werden wir versuchen herauszufinden, wie und warum sie verwendet werden.  Vergleichen Sie dabei die Implementierung desselben JSON-Webdienstes mit ihrer Hilfe. </p><a name="habracut"></a><br><p>  Die Infrastruktur von Julia hat sich in den letzten ein oder zwei Jahren aktiv entwickelt.  Und in diesem Fall ist dies nicht nur eine Online-Phrase, die f√ºr einen sch√∂nen Anfang des Textes eingeschrieben ist, sondern eine Betonung der Tatsache, dass sich alles intensiv √§ndert und das, was vor ein paar Jahren relevant war, jetzt veraltet ist.  Wir werden jedoch versuchen, stabile Pakete hervorzuheben und Empfehlungen zur Implementierung von Webdiensten mit deren Hilfe zu geben.  Aus Gr√ºnden der Bestimmtheit erstellen wir einen Webdienst, der eine POST-Anforderung mit JSON-Daten im folgenden Format akzeptiert: </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"something"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: <span class="hljs-string"><span class="hljs-string">"something"</span></span> }</code> </pre> <br><p>  Wir gehen davon aus, dass der von uns erstellte Service nicht RESTful ist.  Unsere Hauptaufgabe besteht darin, die Methoden zur Beschreibung von Routen und Anforderungshandlern genau zu ber√ºcksichtigen. </p><br><h2 id="paket-httpjl">  HTTP.jl-Paket </h2><br><p>  Dieses Paket ist die Hauptimplementierung des HTTP-Protokolls in Julia und wird schrittweise mit neuen Funktionen erweitert.  Dieses Paket implementiert nicht nur typische Strukturen und Funktionen zum Ausf√ºhren von HTTP-Client-Anforderungen, sondern implementiert auch Funktionen zum Erstellen von HTTP-Servern.  Gleichzeitig hat das Paket w√§hrend seiner Entwicklung Funktionen erhalten, die es dem Programmierer recht bequem machen, Handler zu registrieren und so typische Dienste zu erstellen.  In den neuesten Versionen ist au√üerdem das WebSocket-Protokoll integriert, dessen Implementierung zuvor als Teil eines separaten Pakets WebSocket.jl vorgenommen wurde.  Das hei√üt, HTTP.jl kann derzeit die meisten Anforderungen eines Programmierers erf√ºllen.  Schauen wir uns einige Beispiele genauer an. </p><br><h3 id="klient-http">  HTTP-Client </h3><br><p>  Wir beginnen die Implementierung mit dem Client-Code, mit dem wir die Funktionsf√§higkeit √ºberpr√ºfen. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. import HTTP import JSON.json const PORT = "8080" const HOST = "127.0.0.1" const NAME = "Jemand" #    struct Document title::String body::String end #         Base.show(r::HTTP.Messages.Response) = println(r.status == 200 ? String(r.body) : "Error: " * r.status) #    r = HTTP.get("http://$(HOST):$(PORT)") show(r) #   /user/:name r = HTTP.get("http://$(HOST):$(PORT)/user/$(NAME)"; verbose=1) show(r) #  JSON- POST- doc = Document("Some document", "Test document with some content.") r = HTTP.post( "http://$(HOST):$(PORT)/resource/process", [("Content-Type" =&gt; "application/json")], json(doc); verbose=3) show(r)</span></span></code> </pre> <br><p>  Das HTTP-Paket enth√§lt Methoden, die mit den Namen der HTTP-Protokollbefehle √ºbereinstimmen.  In diesem Fall verwenden wir <code>get</code> und <code>post</code> .  Mit dem optionalen <code>verbose</code> benannten Argument k√∂nnen Sie die Menge der auszugebenden Debugging-Informationen festlegen.  So <code>verbose=1</code> beispielsweise <code>verbose=1</code> : </p><br><pre> <code class="plaintext hljs">GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1)</code> </pre> <br><p>  Und im Fall von <code>verbose=3</code> wir bereits einen vollst√§ndigen Satz gesendeter und empfangener Daten: </p><br><pre> <code class="plaintext hljs">DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "POST /resource/process HTTP/1.1\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "Content-Type: application/json\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "Host: 127.0.0.1\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "Content-Length: 67\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f Ô∏è-&gt; "\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 e1c6 Ô∏è-&gt; "{\"title\":\"Some document\",\"body\":\"Test document with some content.\"}" (unsafe_write) DEBUG: 2019-04-21T22:40:40.963 eb4f Ô∏è&lt;- "HTTP/1.1 200 OK\r\n" (readuntil) DEBUG: "Content-Type: application/json\r\n" DEBUG: "Transfer-Encoding: chunked\r\n" DEBUG: "\r\n" DEBUG: 2019-04-21T22:40:40.963 eb4f Ô∏è&lt;- "5d\r\n" (readuntil) DEBUG: 2019-04-21T22:40:40.963 eb4f Ô∏è&lt;- "{\"body\":\"Test document with some content.\",\"server_mark\":\"confirmed\",\"title\":\"Some document\"}" (unsafe_read) DEBUG: 2019-04-21T22:40:40.968 eb4f Ô∏è&lt;- "\r\n" (readuntil) DEBUG: "0\r\n" DEBUG: 2019-04-21T22:40:40.968 eb4f Ô∏è&lt;- "\r\n" (readuntil)</code> </pre> <br><p>  In Zukunft werden wir nur <code>verbose=1</code> verwenden, um nur minimale Informationen dar√ºber zu sehen, was passiert. </p><br><p>  Ein paar Kommentare zum Code. </p><br><pre> <code class="julia hljs">doc = Document(<span class="hljs-string"><span class="hljs-string">"Some document"</span></span>, <span class="hljs-string"><span class="hljs-string">"Test document with some content."</span></span>)</code> </pre> <br><p>  Da wir zuvor die Dokumentstruktur deklariert haben (au√üerdem unver√§nderlich), steht standardm√§√üig ein Konstruktor daf√ºr zur Verf√ºgung, dessen Argumente den deklarierten Feldern der Struktur entsprechen.  Um es in JSON zu konvertieren, verwenden wir das Paket <code>JSON.jl</code> und seine Methode <code>json(doc)</code> . <br>  Achten Sie auf das Fragment: </p><br><pre> <code class="julia hljs">r = HTTP.post( <span class="hljs-string"><span class="hljs-string">"http://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(HOST)</span></span></span><span class="hljs-string">:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(PORT)</span></span></span><span class="hljs-string">/resource/process"</span></span>, [(<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>)], json(doc); verbose=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  Da wir JSON √ºbergeben, m√ºssen Sie den Typ <code>application/json</code> im <code>Content-Type</code> Header explizit angeben.  Die Header werden (wie alle anderen auch) an die <code>HTTP.post</code> Methode √ºbergeben, wobei ein Array (Vektortyp, aber kein Dict-Typ) verwendet wird, das die Header-Name-Wert-Paare enth√§lt. </p><br><p>  F√ºr einen Gesundheitstest f√ºhren wir drei Abfragen durch: </p><br><ul><li>  GET-Anforderung an die Root-Route; </li><li>  GET-Anfrage im Format / Benutzer / Name, wobei Name der √ºbertragene Name ist; </li><li>  POST-Anforderung / Ressource / Prozess mit √ºbergebenem JSON-Objekt.  Wir erwarten dasselbe Dokument, jedoch mit dem <code>server_mark</code> Feld <code>server_mark</code> . </li></ul><br><p>  Wir werden diesen Client-Code verwenden, um alle Server-Implementierungsoptionen zu testen. </p><br><h3 id="server-http">  HTTP-Server </h3><br><p>  Nachdem Sie den Client herausgefunden haben, ist es Zeit, mit der Implementierung des Servers zu beginnen.  Zun√§chst werden wir den Dienst nur mit Hilfe von <code>HTTP.jl</code> , um ihn als <code>HTTP.jl</code> , f√ºr die keine Installation anderer Pakete erforderlich ist.  Wir erinnern Sie daran, dass alle anderen Pakete <code>HTTP.jl</code> </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. import Sockets import HTTP import JSON #    #    index(req::HTTP.Request) = HTTP.Response(200, "Hello World") #     function welcome_user(req::HTTP.Request) # dump(req) user = "" if (m = match( r".*/user/([[:alpha:]]+)", req.target)) != nothing user = m[1] end return HTTP.Response(200, "Hello " * user) end #  JSON function process_resource(req::HTTP.Request) # dump(req) message = JSON.parse(String(req.body)) @info message message["server_mark"] = "confirmed" return HTTP.Response(200, JSON.json(message)) end #      const ROUTER = HTTP.Router() HTTP.@register(ROUTER, "GET", "/", index) HTTP.@register(ROUTER, "GET", "/user/*", welcome_user) HTTP.@register(ROUTER, "POST", "/resource/process", process_resource) HTTP.serve(ROUTER, Sockets.localhost, 8080)</span></span></code> </pre> <br><p>  Im Beispiel sollten Sie den folgenden Code beachten: </p><br><pre> <code class="julia hljs">dump(req)</code> </pre> <br><p>  druckt alles, was dem Objekt bekannt ist, auf die Konsole.  Einschlie√ülich Datentypen, Werte sowie aller verschachtelten Felder und ihrer Werte.  Diese Methode ist sowohl f√ºr die Bibliotheksrecherche als auch f√ºr das Debuggen n√ºtzlich. </p><br><p>  String </p><br><pre> <code class="julia hljs">(m = match( <span class="hljs-string"><span class="hljs-string">r".*/user/([[:alpha:]]+)"</span></span>, req.target))</code> </pre> <br><p>  ist ein regul√§rer Ausdruck, der die Route analysiert, auf der der Handler registriert ist.  Das Paket <code>HTTP.jl</code> keine automatischen M√∂glichkeiten zum Identifizieren eines Musters in einer Route. </p><br><p>  Innerhalb des <code>process_resource</code> analysieren wir den JSON, der vom Service akzeptiert wird. </p><br><pre> <code class="julia hljs">message = JSON.parse(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(req.body))</code> </pre> <br><p>  Der Zugriff auf Daten erfolgt √ºber das Feld <code>req.body</code> .  Beachten Sie, dass die Daten in einem Byte-Array-Format vorliegen.  Um mit ihnen als Zeichenfolge zu arbeiten, wird daher eine explizite Konvertierung in eine Zeichenfolge durchgef√ºhrt.  Die <code>JSON.parse</code> Methode ist eine <code>JSON.jl</code> , die Daten deserialisiert und ein Objekt erstellt.  Da das Objekt in diesem Fall ein assoziatives Array (Dict) ist, k√∂nnen wir ihm leicht einen neuen Schl√ºssel hinzuf√ºgen.  String </p><br><pre> <code class="julia hljs">message[<span class="hljs-string"><span class="hljs-string">"server_mark"</span></span>] = <span class="hljs-string"><span class="hljs-string">"confirmed"</span></span></code> </pre> <br><p>  <code>server_mark</code> Schl√ºssel <code>server_mark</code> mit dem <code>confirmed</code> Wert hinzu. </p><br><p>  Der Dienst wird <code>HTTP.serve(ROUTER, Sockets.localhost, 8080)</code> wenn die Zeile <code>HTTP.serve(ROUTER, Sockets.localhost, 8080)</code> . </p><br><p>  Die Steuerantwort f√ºr den Dienst basierend auf HTTP.jl (erhalten, wenn der Clientcode mit <code>verbose=1</code> ): </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) Hello World GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) Hello Jemand POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><p>  Vor dem Hintergrund des Debuggens von Informationen mit <code>verbose=1</code> wir deutlich die Zeilen: <code>Hello World</code> , <code>Hello Jemand</code> , <code>"server_mark":"confirmed"</code> . </p><br><p>  Nach dem Anzeigen des Service-Codes stellt sich nat√ºrlich die Frage, warum wir alle anderen Pakete ben√∂tigen, wenn in HTTP alles so einfach ist.  Darauf gibt es eine sehr einfache Antwort.  HTTP - erm√∂glicht die Registrierung dynamischer Handler, aber selbst eine elementare Implementierung des Lesens einer statischen Bilddatei aus einem Verzeichnis erfordert eine separate Implementierung.  Daher betrachten wir auch Pakete, die sich auf die Erstellung von Webanwendungen konzentrieren. </p><br><h2 id="paket-muxjl">  Mux.jl-Paket </h2><br><p>  Dieses Paket ist als Zwischenschicht f√ºr auf Julia implementierte Webanwendungen positioniert.  Die Implementierung ist sehr leicht.  Der Hauptzweck besteht darin, eine einfache M√∂glichkeit zur Beschreibung von Handlern bereitzustellen.  Dies bedeutet nicht, dass sich das Projekt nicht entwickelt, sondern nur langsam.  Sehen Sie sich jedoch den Code f√ºr unseren Service an, der dieselben Routen bedient. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. using Mux using JSON @app test = ( Mux.defaults, page(respond("&lt;h1&gt;Hello World!&lt;/h1&gt;")), page("/user/:user", req -&gt; "&lt;h1&gt;Hello, $(req[:params][:user])!&lt;/h1&gt;"), route("/resource/process", req -&gt; begin message = JSON.parse(String(req[:data])) @info message message["server_mark"] = "confirmed" return Dict( :body =&gt; JSON.json(message), :headers =&gt; [("Content-Type" =&gt; "application/json")] ) end), Mux.notfound() ) serve(test, 8080) Base.JLOptions().isinteractive == 0 &amp;&amp; wait()</span></span></code> </pre> <br><p>  Hier werden die Routen mit der <code>page</code> .  Die Webanwendung wird mit dem Makro <code>@app</code> deklariert.  Die Argumente f√ºr die <code>page</code> sind die Route und der Handler.  Ein Handler kann als eine Funktion angegeben werden, die eine Anforderung als Eingabe akzeptiert, oder er kann als vorhandene Lambda-Funktion angegeben werden.  Von den zus√§tzlichen n√ºtzlichen Funktionen ist <code>Mux.notfound()</code> vorhanden, um die angegebene Antwort " <code>Not found</code> zu senden.  Und das Ergebnis, das an den Client gesendet werden soll, muss nicht wie im vorherigen Beispiel in <code>HTTP.Response</code> , da Mux dies selbst tun wird.  Sie m√ºssen das JSON-Parsing jedoch weiterhin selbst durchf√ºhren, ebenso wie das Serialisieren des Objekts f√ºr die Antwort - <code>JSON.json(message)</code> . </p><br><pre> <code class="julia hljs"> message = JSON.parse(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(req[:data])) message[<span class="hljs-string"><span class="hljs-string">"server_mark"</span></span>] = <span class="hljs-string"><span class="hljs-string">"confirmed"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>( :body =&gt; JSON.json(message), :headers =&gt; [(<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>)] )</code> </pre> <br><p>  Die Antwort wird als assoziatives Array mit den Feldern <code>:body</code> <code>:headers</code> gesendet. </p><br><p>  Das Starten des Servers mit der <code>serve(test, 8080)</code> Methode <code>serve(test, 8080)</code> ist asynchron. Eine der Optionen in Julia zum Organisieren des Wartens auf den Abschluss besteht darin, den folgenden Code aufzurufen: </p><br><pre> <code class="julia hljs">Base.JLOptions().isinteractive == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; wait()</code> </pre> <br><p>  Ansonsten macht der Dienst dasselbe wie die vorherige Version auf <code>HTTP.jl</code> </p><br><p>  Kontrollantwort f√ºr den Dienst: </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) &lt;h1&gt;Hello World!&lt;/h1&gt; GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) &lt;h1&gt;Hello, Jemand!&lt;/h1&gt; POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><h2 id="paket-bukdujl">  Paket Bukdu.jl </h2><br><p>  Das Paket wurde unter dem Einfluss des Phoenix-Frameworks entwickelt, das wiederum auf Elixir implementiert ist und die Umsetzung von Webbuilding-Ideen der Ruby-Community in Projektion auf Elixir darstellt.  Das Projekt entwickelt sich sehr aktiv und ist als Werkzeug zum Erstellen einer RESTful-API und leichter Webanwendungen positioniert.  Es gibt Funktionen zur Vereinfachung der JSON-Serialisierung und -Deserialisierung.  Dies fehlt in <code>HTTP.jl</code> und <code>Mux.jl</code>  Schauen wir uns die Implementierung unseres Webdienstes an. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. using Bukdu using JSON #   struct WelcomeController &lt;: ApplicationController conn::Conn end #   index(c::WelcomeController) = render(JSON, "Hello World") welcome_user(c::WelcomeController) = render(JSON, "Hello " * c.params.user) function process_resource(c::WelcomeController) message = JSON.parse(String(c.conn.request.body)) @info message message["server_mark"] = "confirmed" render(JSON, message) end #   routes() do get("/", WelcomeController, index) get("/user/:user", WelcomeController, welcome_user, :user =&gt; String) post("/resource/process", WelcomeController, process_resource) end #   Bukdu.start(8080) Base.JLOptions().isinteractive == 0 &amp;&amp; wait()</span></span></code> </pre> <br><p>  Das erste, worauf Sie achten sollten, ist die Deklaration der Struktur zum Speichern des Controller-Status. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WelcomeController &lt;: ApplicationController conn::Conn <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  In diesem Fall handelt es sich um einen konkreten Typ, der als Nachkomme des abstrakten Typs <code>ApplicationController</code> . </p><br><p>  Methoden f√ºr die Steuerung werden in √§hnlicher Weise in Bezug auf fr√ºhere Implementierungen deklariert.  Es gibt einen kleinen Unterschied im Handler unseres JSON-Objekts. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> process_resource(c::WelcomeController) message = JSON.parse(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(c.conn.request.body)) <span class="hljs-meta"><span class="hljs-meta">@info</span></span> message message[<span class="hljs-string"><span class="hljs-string">"server_mark"</span></span>] = <span class="hljs-string"><span class="hljs-string">"confirmed"</span></span> render(JSON, message) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Wie Sie sehen k√∂nnen, wird die Deserialisierung auch unabh√§ngig mit der <code>JSON.parse</code> Methode durchgef√ºhrt, aber die <code>JSON.parse</code> Methode <code>render(JSON, message)</code> wird zum Serialisieren der Antwort verwendet. </p><br><p>  Die Deklaration der Routen erfolgt im traditionellen Stil f√ºr Rubisten, einschlie√ülich der Verwendung des <code>do...end</code> -Endblocks. </p><br><pre> <code class="julia hljs">routes() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, WelcomeController, index) get(<span class="hljs-string"><span class="hljs-string">"/user/:user"</span></span>, WelcomeController, welcome_user, :user =&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) post(<span class="hljs-string"><span class="hljs-string">"/resource/process"</span></span>, WelcomeController, process_resource) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Au√üerdem wird auf herk√∂mmliche Weise f√ºr Rubisten ein Segment in der Routenzeile <code>/user/:user</code> deklariert.  Mit anderen Worten, der variable Teil des Ausdrucks, auf den √ºber den in der Vorlage angegebenen Namen zugegriffen werden kann.  Es wird syntaktisch als Vertreter des Typs <code>Symbol</code> .  √úbrigens bedeutet der Typ <code>Symbol</code> f√ºr Julia im Wesentlichen dasselbe wie f√ºr Ruby - dies ist eine unver√§nderliche Zeichenfolge, die im Speicher durch eine einzelne Instanz dargestellt wird. </p><br><p>  Dementsprechend k√∂nnen wir, nachdem wir eine Route mit einem variablen Teil deklariert und auch den Typ dieses variablen Teils angegeben haben, auf die Daten verweisen, die bereits durch den zugewiesenen Namen analysiert wurden.  Bei der Methode, die die Anforderung verarbeitet, greifen wir einfach √ºber einen Punkt in der Form <code>c.params.user</code> auf das Feld zu. </p><br><pre> <code class="julia hljs">welcome_user(c::WelcomeController) = render(JSON, <span class="hljs-string"><span class="hljs-string">"Hello "</span></span> * c.params.user)</code> </pre> <br><p>  Kontrollantwort f√ºr den Dienst: </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) "Hello World" GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) "Hello Jemand" POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><p>  Abschluss des Service f√ºr die Konsole: </p><br><pre> <code class="plaintext hljs">&gt;./bukdu_json.jl INFO: Bukdu Listening on 127.0.0.1:8080 INFO: GET WelcomeController index 200 / INFO: GET WelcomeController welcome_user 200 /user/Jemand INFO: Dict{String,Any}("body"=&gt;"Test document with some content.","title"=&gt;"Some document") INFO: POST WelcomeController process_resource200 /resource/process</code> </pre> <br><h2 id="paket-geniejl">  Paket Genie.jl </h2><br><p>  Ein ehrgeiziges Projekt, das als MVC-Webframework positioniert ist.  In seinem Ansatz sind die ‚ÄûRails‚Äú auf Julia ziemlich deutlich sichtbar, einschlie√ülich der vom Generator erstellten Verzeichnisstruktur.  Das Projekt wird jedoch aus unbekannten Gr√ºnden entwickelt. Dieses Paket ist nicht im Julia-Paket-Repository enthalten.  Das hei√üt, die Installation ist nur √ºber das Git-Repository mit dem folgenden Befehl m√∂glich: </p><br><pre> <code class="julia hljs">julia&gt;] <span class="hljs-comment"><span class="hljs-comment"># switch to pkg&gt; mode pkg&gt; add https://github.com/essenciary/Genie.jl</span></span></code> </pre> <br><p>  Der Code unseres Dienstes in Genie lautet wie folgt (wir verwenden keine Generatoren): </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. #     import Genie import Genie.Router: route, @params, POST import Genie.Requests: jsonpayload, rawpayload import Genie.Renderer: json! #      route("/") do "Hello World!" end route("/user/:user") do "Hello " * @params(:user) end route("/resource/process", method = POST) do message = jsonpayload() # if message == nothing # dump(Genie.Requests.rawpayload()) # end message["server_mark"] = "confirmed" return message |&gt; json! end #   Genie.AppServer.startup(8080) Base.JLOptions().isinteractive == 0 &amp;&amp; wait()</span></span></code> </pre> <br><p>  Hier sollten Sie auf das Format der Erkl√§rung achten. </p><br><pre> <code class="julia hljs">route(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Dieser Code ist Ruby-Programmierern sehr vertraut.  Der <code>do...end</code> Block als Handler und die Route als Argument f√ºr die Methode.  Beachten Sie, dass dieser Code f√ºr Julia in der folgenden Form umgeschrieben werden kann: </p><br><pre> <code class="julia hljs">route(req -&gt; <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span>, <span class="hljs-string"><span class="hljs-string">"/"</span></span>)</code> </pre> <br><p>  Das hei√üt, die Handlerfunktion steht an erster Stelle, die Route an zweiter Stelle.  Aber f√ºr unseren Fall lassen wir den Rubinstil. </p><br><p>  Genie packt das Ausf√ºhrungsergebnis automatisch in eine HTTP-Antwort.  Im Mindestfall m√ºssen wir nur das Ergebnis des richtigen Typs zur√ºckgeben, z. B. String.  Von den zus√§tzlichen Annehmlichkeiten wird eine automatische √úberpr√ºfung des Eingabeformats und seiner Analyse implementiert.  F√ºr JSON m√ºssen Sie beispielsweise nur die Methode <code>jsonpayload()</code> . </p><br><pre> <code class="julia hljs">route(<span class="hljs-string"><span class="hljs-string">"/resource/process"</span></span>, method = POST) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> message = jsonpayload() <span class="hljs-comment"><span class="hljs-comment"># if message == nothing # dump(Genie.Requests.rawpayload()) # end message["server_mark"] = "confirmed" return message |&gt; json! end</span></span></code> </pre> <br><p>  Achten Sie auf das hier auskommentierte Codefragment.  Die Methode <code>jsonpayload()</code> gibt <code>nothing</code> wenn das Eingabeformat aus irgendeinem Grund nicht als JSON erkannt wird.  Beachten Sie, dass nur aus diesem Grund der Header <code>[("Content-Type" =&gt; "application/json")]</code> zu unserem HTTP-Client hinzugef√ºgt wird, da Genie sonst nicht einmal anf√§ngt, die Daten als JSON zu analysieren.  Falls etwas Unverst√§ndliches <code>rawpayload()</code> ist, ist es n√ºtzlich, <code>rawpayload()</code> auf das zu <code>rawpayload()</code> was es ist.  Da dies jedoch nur eine Debugging-Phase ist, sollten Sie sie nicht im Code belassen. </p><br><p>  Sie sollten auch darauf achten, das Ergebnis in der Formatnachricht <code>message |&gt; json!</code>  .  Die <code>json!(str)</code> -Methode wird hier als letzte in die Pipeline aufgenommen.  Es bietet eine Serialisierung von Daten im JSON-Format und stellt au√üerdem sicher, dass Genie den richtigen <code>Content-Type</code> hinzuf√ºgt.  Beachten Sie auch die Tatsache, dass das Wort <code>return</code> in den meisten F√§llen in den obigen Beispielen redundant ist.  Julia gibt wie Ruby beispielsweise immer das Ergebnis der letzten Operation oder den Wert des zuletzt angegebenen Ausdrucks zur√ºck.  Das hei√üt, das Wort <code>return</code> ist optional. </p><br><p>  Die Funktionen von Genie enden hier nicht, aber wir ben√∂tigen sie nicht, um einen Webdienst zu implementieren. </p><br><p>  Kontrollantwort f√ºr den Dienst: </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) Hello World! GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) Hello Jemand POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><p>  Abschluss des Service f√ºr die Konsole: </p><br><pre> <code class="plaintext hljs">&gt;./genie_json.jl [ Info: Ready! 2019-04-24 17:18:51:DEBUG:Main: Web Server starting at http://127.0.0.1:8080 2019-04-24 17:18:51:DEBUG:Main: Web Server running at http://127.0.0.1:8080 2019-04-24 17:19:21:INFO:Main: / 200 2019-04-24 17:19:21:INFO:Main: /user/Jemand 200 2019-04-24 17:19:22:INFO:Main: /resource/process 200</code> </pre> <br><h2 id="paket-juliawebapijl">  Paket JuliaWebAPI.jl </h2><br><p>  Dieses Paket wurde in jenen Tagen als Zwischenschicht f√ºr die Erstellung von Webanwendungen positioniert, als HTTP.jl nur eine Bibliothek war, die das Protokoll implementiert.  Der Autor dieses Pakets implementierte auch einen Servercode-Generator basierend auf der Swagger-Spezifikation (OpenAPI und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://editor.swagger.io/</a> ) - siehe das Projekt <a href="">https://github.com/JuliaComputing/Swagger.jl</a> , und dieser Generator verwendete JuliaWebAPI .jl.  Das Problem mit JuliaWebAPI.jl besteht jedoch darin, dass die M√∂glichkeit, den Hauptteil der Anforderung (z. B. JSON), die √ºber eine POST-Anforderung an den Server gesendet wurde, zu verarbeiten, nicht implementiert wird.  Der Autor glaubte, dass die √úbergabe von Parametern in einem Schl√ºsselwertformat f√ºr alle Gelegenheiten geeignet ist ... Die Zukunft dieses Pakets ist nicht klar.  Alle seine Funktionen sind bereits in vielen anderen Paketen implementiert, einschlie√ülich HTTP.jl.  Das Swagger.jl-Paket verwendet es auch nicht mehr. </p><br><h2 id="websocketsjl">  WebSockets.jl </h2><br><p>  Eine fr√ºhe Implementierung des WebSocket-Protokolls.  Das Paket wurde lange Zeit als Hauptimplementierung dieses Protokolls verwendet. Derzeit ist seine Implementierung jedoch im Paket HTTP.jl enthalten.  Das WebSockets.jl-Paket selbst verwendet HTTP.jl, um eine Verbindung herzustellen. Jetzt sollten Sie es jedoch nicht in neuen Entwicklungen verwenden.  Es sollte aus Kompatibilit√§tsgr√ºnden als Paket betrachtet werden. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Diese √úberpr√ºfung zeigt verschiedene M√∂glichkeiten zum Implementieren eines Webdienstes f√ºr Julia.  Der einfachste und universellste Weg ist die direkte Verwendung des Pakets HTTP.jl.  Auch die Pakete Bukdu.jl und Genie.jl sind sehr n√ºtzlich.  Zumindest sollte ihre Entwicklung √ºberwacht werden.  In Bezug auf das Mux.jl-Paket werden seine Vorteile jetzt vor dem Hintergrund von HTTP.jl aufgel√∂st.  Daher ist pers√∂nliche Meinung nicht zu verwenden.  Genie.jl ist ein sehr vielversprechendes Framework.  Bevor Sie es jedoch verwenden, m√ºssen Sie zumindest verstehen, warum der Autor es nicht als offizielles Paket registriert. </p><br><p>  Beachten Sie, dass der JSON-Deserialisierungscode in den Beispielen ohne Fehlerbehandlung verwendet wurde.  In allen F√§llen au√üer Genie ist es erforderlich, Analysefehler zu behandeln und den Benutzer dar√ºber zu informieren.  Ein Beispiel f√ºr einen solchen Code f√ºr HTTP.jl: </p><br><pre> <code class="julia hljs"> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> message = <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> body = <span class="hljs-built_in"><span class="hljs-built_in">IOBuffer</span></span>(HTTP.payload(req)) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> message = JSON.parse(body) <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> err <span class="hljs-meta"><span class="hljs-meta">@error</span></span> err.msg <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HTTP.Response(<span class="hljs-number"><span class="hljs-number">400</span></span>, string(err.msg)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Generell k√∂nnen wir sagen, dass es in Julia bereits gen√ºgend Mittel gibt, um Webdienste zu erstellen.  Das hei√üt, es besteht keine Notwendigkeit, das Rad neu zu erfinden, um sie zu schreiben.  Der n√§chste Schritt besteht darin, zu bewerten, wie Julia der Belastung in den vorhandenen Benchmarks standhalten kann, wenn jemand bereit ist, sie zu √ºbernehmen.  Lassen Sie uns jedoch zun√§chst auf diese √úberpr√ºfung eingehen. </p><br><h2 id="ssylki">  Referenzen </h2><br><ul><li>  <a href="">https://github.com/JuliaWeb/HTTP.jl</a> </li><li>  <a href="">https://github.com/JuliaWeb/Mux.jl</a> </li><li>  <a href="">https://github.com/wookay/Bukdu.jl</a> </li><li>  <a href="">https://github.com/essenciary/Genie.jl</a> </li><li>  <a href="">https://github.com/JuliaComputing/Swagger.jl</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449338/">https://habr.com/ru/post/de449338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449324/index.html">Lasten, Smartphones, Riesenunternehmen: Heisenbug 2019 Piter-Programm</a></li>
<li><a href="../de449326/index.html">WebRTC und Video√ºberwachung: Wie wir die Verz√∂gerung von Videos von Kameras besiegt haben</a></li>
<li><a href="../de449330/index.html">Koh√§rente optische CFP2-ACO / CFP2-DCO-WDM-Module (100G / 200G) und ihre Anwendung in DWDM-Systemen</a></li>
<li><a href="../de449334/index.html">Wie aus technischer √úbersetzung ein Mini-Detektiv wird</a></li>
<li><a href="../de449336/index.html">HIV - Behandlungen von der ersten Medizin bis heute</a></li>
<li><a href="../de449340/index.html">Block Orakel basiertes zuf√§lliges Orakel basierend auf digitaler Signatur</a></li>
<li><a href="../de449342/index.html">Zuf√§lliges Orakel basierend auf der digitalen Blockchain-Signatur</a></li>
<li><a href="../de449344/index.html">Kodim - Pizza</a></li>
<li><a href="../de449346/index.html">MODX Digest # 4 (8. - 22. April 2019)</a></li>
<li><a href="../de449348/index.html">Buildroot - Teil 2. Erstellen der Konfiguration Ihres Boards; Anwendung von externen Baum-, Rootfs-Overlay- und Post-Build-Skripten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>