<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï° üçõ üå¥ Programmierung und Datenaustausch mit ARDUINO √ºber WIFI √ºber ESP8266 Teil Eins üëµüèæ üëéüèª üèåÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie viele andere hausgemachte Produkte verwende ich regelm√§√üig AVR-Mikrocontroller f√ºr alle Arten von Amateurhandwerk. Und dank des Arduino-Konzepts s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmierung und Datenaustausch mit ARDUINO √ºber WIFI √ºber ESP8266 Teil Eins</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/406559/">  Wie viele andere hausgemachte Produkte verwende ich regelm√§√üig AVR-Mikrocontroller f√ºr alle Arten von Amateurhandwerk.  Und dank des Arduino-Konzepts sehen diese Handarbeiten jetzt auch elegant aus.  In der Tat erhalten wir f√ºr etwa 300-400 Rubel eine mehrschichtige Miniaturplatte mit einer Maske, einem Siebdruck und den Peripherieger√§ten f√ºr den Mikrocontroller, die vollst√§ndig darauf gez√ºchtet wurden (au√üerdem in der SMD-Version!).  Ich spreche nicht von allen Arten von Plug-Ins der gleichen "Arduino" -Serie: Sensoren, Controller, Displays und ganze Sets, die zus√§tzlichen Peripherieger√§te, die wir so sehr brauchen.  Und wieder ist alles preiswert und in hervorragender Leistung.  Sie m√ºssen praktisch nichts mehr z√ºchten und auf das "Knie" l√∂ten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/dcc/5a0/51d/dcc5a051d0554a7a86eaf37d51702ce6.jpg"></div><br>  Aber all diese verschiedenen Amateurhandwerke erfordern nat√ºrlich eine <b>vorl√§ufige Programmierung.</b>  Und sp√§ter, mit verschiedenen Verbesserungen, muss ich diese Handwerke st√§ndig neu flashen.  Es ist klar, dass es bequemer ist, dies aus der Ferne zu tun, als sie st√§ndig auf einen normalen Programmierer zu ziehen.  Dank derselben Arduino-Plattform gibt es hier im Allgemeinen viele Optionen: Bluetooth, ZigBee, ein Funkkanal mit Ihrem pers√∂nlichen Protokoll, IR und sogar Wi-Fi.  Mit allen k√∂nnen Sie einen drahtlosen Kontakt mit Ihrem Mikrocontroller herstellen.  Aber wir werden bei der letzten Option aufh√∂ren.  Es gibt vier Hauptgr√ºnde: <br><br>  1: modern, das Internet der Dinge! <br><br>  2: In jeder Wohnung gibt es einen WLAN-Router. Registrieren Sie Ihre Ger√§te im Heimnetzwerk und voila! <br><br>  3: Ihr Handwerk macht einen revolution√§ren Sprung in ihrer Entwicklung;  Sie k√∂nnen nicht nur aus der Ferne programmiert werden, sondern auch mit der Welt um sie herum kommunizieren: Die elektronische Uhr nimmt unabh√§ngig die genaue Zeit von den NTP-Serveruhren ab, Executive-Ger√§te werden vom anderen Ende der Stadt oder des Landes aus gesteuert, Registrierungsger√§te speichern die gesammelten Daten in Wolke etc.  usw. <br><br>  4: Es gibt eine wunderbare Serie von ESP8266-Chips, auf denen <s>dies nicht</s> einfach zu implementieren ist. <br><a name="habracut"></a><br>  In diesem Artikel werden am Beispiel eines mechanischen Arms an Servos die Fernprogrammierung und der Datenaustausch mit einem PC (oder was auch immer) mit Ger√§ten, die auf AVR-Mikrocontrollern basieren, zerlegt und demonstriert.  Ich m√∂chte sofort darauf hinweisen, dass alle nachfolgend aufgef√ºhrten Programme rein demonstrativ sind und keinen kommerziellen Wert haben.  Behauptungen, wie zum Beispiel, warum der Programmierer so kastriert und schlecht funktionsf√§hig ist oder warum es keine zus√§tzlichen Dienste gibt, die √ºberall sind, werden daher nicht akzeptiert.  Da die Codes offen sind, kann jeder sie nach eigenem Ermessen beenden, aber ich habe immer noch genug f√ºr die Arbeit. <br><br>  Es wird davon ausgegangen, dass der Leser bereits mit den Arduino-Modulen (Shields) sowie dem Anschluss und der Firmware des ESP8266 vertraut ist.  Tats√§chlich wurde im Web eine gro√üe Menge an Material ver√∂ffentlicht, das die Grundlagen der Arbeit mit diesen Ger√§ten erkl√§rt, und ich m√∂chte dies hier nicht wiederholen.  F√ºr Anf√§nger gibt es am Ende des Artikels eine Liste n√ºtzlicher Links zu diesen Themen, unter denen Sie viele Informationen finden <s>, warum bei Ihnen alles nicht funktioniert</s> .  Aus meiner Erfahrung als ehemaliger Elektronikingenieur kann ich verantwortungsbewusst erkl√§ren, dass 99% der Probleme wie folgt sind: <br><br>  1. Schlechte Kontakte.  Da die "Arduino" -Schilde bedeuten, dass sie durch Dr√§hte vom Typ "Vater-Mutter" und nicht durch L√∂ten miteinander geschaltet werden, verschwindet sehr oft irgendwo etwas.  Schau es dir an.  Und tats√§chlich ist Elektronik, wie sie sagen, die Wissenschaft der Kontakte. <br><br>  2. Stromprobleme.  Liefern Sie keine 5 Volt, wenn 3.3 erforderlich ist.  Manchmal kommt Rauch vom ESP8266.  Auf der anderen Seite werden logische Signale von F√ºnf-Volt-Ger√§ten problemlos verarbeitet. <br><br>  3. Probleme mit ausreichender Leistung.  ESP8266 hat eine abscheuliche Natur und kann manchmal fast dreihundert Milliampere verbrauchen, obwohl es vorher mit drei√üig zufrieden sein konnte.  Dementsprechend ist die gebrechliche Stabilisator 3,3 Volt Platine "Arduino", an die man nichts addieren kann, angeschlossen, sie sinkt sofort auf mikroskopische Werte.  Und Sie k√∂nnen nicht verstehen, warum es funktioniert, dann nicht. <br><br>  4. Verwechslung mit Schlussfolgerungen.  √úberpr√ºfen Sie immer, welche Signale wohin gehen.  Der RXD-Empf√§nger muss eine Verbindung zum TXD-Sender sowie von TXD zu RXD herstellen, aber MOSI muss eine Verbindung zu MOSI und MISO zu MISO usw. herstellen. <br><br>  5. Verlassen Sie sich beim ESP8266 nicht auf Pull-up-Widerst√§nde im Stromkreis, sondern ziehen Sie die Kabel immer √ºber externe Widerst√§nde mit 5 bis 10 Kilo Ohm und nicht nur √ºber einen Jumper auf Null oder Strom.  Andernfalls k√∂nnen Sie bestenfalls einen beispiellosen Stromverbrauch erzielen und dann den unangenehmen Geruch von verbranntem Kunststoff riechen. <br><br>  6. Schw√§rme von Software.  Da Software f√ºr einzelne Benutzer von denselben Enthusiasten geschrieben wurde, treten beim Aktualisieren von Versionen derselben Firmware regelm√§√üig St√∂rungen in der Firmware selbst und Fehler auf.  Es wird durch Crawlen in den entsprechenden Foren behandelt, manchmal sogar auf Englisch.  Einige Genossen behaupteten sogar, der ESP-Chip selbst sei feucht wie das Wetter in St. Petersburg, aber andererseits gibt es auch die Meinung, dass sich die Situation seit 2014 (dem Jahr, in dem er erstmals ver√∂ffentlicht wurde) dramatisch verbessert hat (im Gegensatz zum Wetter). <br><br>  7. Geheimnisvolle St√∂rungen.  Dies ist ein seltenes, aber nervenaufreibendes Ph√§nomen.  Zum Beispiel hatte ich kein entferntes "Arduino" -Ger√§t.  Vielmehr geschah es aber mit Fehlern.  Aber es ging ohne Fehler, wenn ein Kabel vom Programmierer daran hing (aber ohne den Programmierer selbst).  "AHA", sagte ich mir und l√∂te einen 15 pF-Kondensator zwischen den Daten√ºbertragungsstift und den Synchronisationsstift.  Alles hat funktioniert.  Aber der Tag ist vorbei. <br><br>  Beginnen wir also mit dem einfachsten.  Wir haben einen MechArm f√ºr mechanische Gliedma√üen (aber nicht das, was Howard Volovits zusammengebaut hat), hergestellt in China, und einen PC mit Windows.  Die Aufgabe besteht darin, das Programm aus der Ferne zu flashen und vom Computer aus zu verwalten. <br><img src="https://habrastorage.org/web/296/4e6/530/2964e653055742f1a6641f06f2d767b1.jpg"><br>  F√ºr den Steuerungscontroller nehmen wir einen niedlichen Miniatur-Arduino-Nano-Schal mit einem ATmega328P-Stein.  Dieses Board wird perfekt in den mechanischen Arm gedr√ºckt. <br><img src="https://habrastorage.org/web/45f/320/2e5/45f3202e545d485faa6d1b5fb71bc574.jpg"><br>  Jetzt entscheiden wir, wie wir es programmieren wollen.  Es gibt drei Hauptmethoden, die f√ºr Remote-Firmware am besten geeignet sind: √ºber die SPI-Schnittstelle, √ºber den integrierten Bootloader und √ºber den JTAG-Port. <br><br>  Die einfachste Option ist nat√ºrlich der eingebaute Bootloader (Bootloader).  Dies ist eine Speichervoreinstellung in FLASH, einem Programm, das einen Code gem√§√ü einem bestimmten Protokoll empf√§ngt (z. B. unter Verwendung des einfachsten UART) und ihn mit speziellen Befehlen an den Speicherort des geladenen Programms schreibt.  Dies funktioniert beispielsweise mit dem Bootloader ARDUINO IDE.  Nach einem Zur√ºcksetzen oder Starten wartet der Bootloader einige Zeit auf den Empfang von Daten. Wenn er nicht wartet, startet er die Ausf√ºhrung des Programms von der Nulladresse aus.  Wenn die Daten ankommen, schreibt er sie in den Programmabschnitt.  Nach dem n√§chsten Zur√ºcksetzen wird das heruntergeladene Programm gestartet.  Im Detail habe ich vielleicht falsch beschrieben, aber das Wesentliche ist genau das.  Daher ben√∂tigen wir nur drei Ausg√§nge f√ºr die Programmierung: RTD-Empf√§nger, RESET-Reset und GND-Masse.  Im Allgemeinen wird der TRD-Sender auch zur √úberpr√ºfung des aufgezeichneten Programms verwendet. Bei einfachen Demonstrationsanwendungen (nicht f√ºr ein Kernkraftwerk) kann die √úberpr√ºfung jedoch weggelassen werden. <br><br>  Der Loader selbst ist in Assemblersprache geschrieben. Beispiele f√ºr einfache Loader finden Sie in den Datenbl√§ttern von AVR.  Sie k√∂nnen einen vorhandenen Bootloader graben, wenn er gemeinfrei ist, und ihn einfach in einer vorgefertigten Form verwenden, wenn das Protokoll bekannt ist, nach dem er funktioniert.  Die einzige Einschr√§nkung besteht darin, dass Sie AVR in einem speziellen Modus konfigurieren m√ºssen, indem Sie spezielle Sicherungsbits blinken lassen, was von einem normalen Programmierer ausgef√ºhrt wird. Anschlie√üend k√∂nnen Sie den Bootloader auch in den Speicher des Mikrocontrollers n√§hen (dh Sie k√∂nnen nicht einmal auf einen Programmierer verzichten). <br><br>  Die zweite Option ist die Programmierung √ºber die serielle SPI-Schnittstelle.  Hier gibt es keinen internen Bootloader, aber wir programmieren, indem wir spezielle Befehle und dann Daten √ºber die oben genannte Schnittstelle senden.  Hier haben wir einen externen Bootloader, aber Sie m√ºssen ihn noch schreiben.  Neben RESET und GND werden vier zus√§tzliche MOSI-Ausg√§nge f√ºr √úbertragung, MISO-Daten, SLK-Synchronisation und CS-Chip-Auswahl verwendet.  Im Allgemeinen k√∂nnen Sie jedoch auch MISO und CS entfernen.  Daten werden nur akzeptiert (dann erfolgt keine √úberpr√ºfung des Programms), und wir haben nur einen Kristall. <br><br>  Jeder Ansatz hat seine Vor- und Nachteile (und ich habe JTAG √ºberhaupt nicht in Betracht gezogen, da das menschliche Leben kurz ist).  Aber am Ende neigte ich mich zu SPI, weil ich zu faul war, um in Assembler zu schreiben, aber ich fand keine offenen, vorgefertigten Bootloader (ich sah einfach nicht gut aus). <br><br>  Um einen Funkkanal aufzubauen, habe ich mich, wie bereits erw√§hnt, f√ºr den derzeit weithin bekannten ESP8266-Chip entschieden - einen Mikrocontroller bzw. einen ganzen SoC (System-on-Chip) des chinesischen Herstellers Espressif mit Wi-Fi-Schnittstelle.  Neben Wi-Fi zeichnet es sich durch die M√∂glichkeit aus, Programme aus einem externen Flash-Speicher auszuf√ºhren.  Und speziell f√ºr mein Projekt habe ich den ESP8266-07 mit 512 KB Speicher an Bord genommen. <br><br><img src="https://habrastorage.org/web/e50/03b/ab1/e5003bab173c4deca207971fd82261f0.jpg"><br>  Im Allgemeinen ist jeder ESP8266 geeignet, wenn zus√§tzliche Beine f√ºr die Implementierung von SPI vorhanden sind.  Daher passt der einfachste ESP8266-01 nicht zu uns, da er nur sehr wenige Abschnitte f√ºr Eingangs- / Ausgangsanschl√ºsse hat.  Andererseits betr√§gt der Preisunterschied weniger als einhundert Rubel, und sie sind gleicherma√üen verf√ºgbar.  Gro√üe Debug-Boards mit ESP, bei denen eine Reihe von Peripherieger√§ten der Einfachheit halber verwendet werden, sind ebenfalls nicht f√ºr uns geeignet, da sie nicht dort ankommen, wo wir sie in unseren mechanischen Arm schieben m√∂chten. <br><br>  Das globale Wesen der Idee im Allgemeinen war wie folgt.  Der in den Mikrocontroller geladene Programmk√∂rper wird drahtlos √ºber WI-FI (innerhalb Ihres Heimnetzwerks) vom Computer zum ESP √ºbertragen.  Und ESP schreibt dieses Programm bereits per Kabel √ºber die SPI-Schnittstelle direkt in den FLASH-Speicher des Mikrocontrollers.  Dann wird es nat√ºrlich zur√ºckgesetzt und das geladene Programm kann ausgef√ºhrt werden.  Dar√ºber hinaus muss das ESP √ºber eine unabh√§ngige Einheit verf√ºgen, die auch den Datenaustausch mit dem Mikrocontroller verwaltet, da wir nicht nur programmieren, sondern auch Daten mit ihm austauschen m√∂chten.  Insbesondere f√ºr ein Projekt mit MechArm senden wir nach der Aufzeichnung des Programms immer noch Servosteuerungssignale, um diese Hand in Bewegung zu setzen.  Daher ist es f√ºr uns auf dem ESP selbst ratsam, einen TCP-Server f√ºr die Programm√ºbertragung und einen UDP-Server f√ºr die Steuerung von MechArm zu erstellen.  Dementsprechend treten diese Server dem Heimnetzwerk bei und h√∂ren genau zu, ob es jemanden gibt, der neuen Code auf MechaArm hochladen oder jemandem zuwinken m√∂chte. <br><br>  Ich habe im Web festgestellt, dass Sie mit der Firmware bereits AVR √ºber die Luft programmieren k√∂nnen. Das Hauptproblem besteht jedoch darin, dass diese Firmware f√ºr andere Zwecke nicht mehr verwendet werden kann.  Nach dem Programmieren m√∂chten wir auch remote mit AVR kommunizieren. <br><br>  Welche Software werden wir verwenden: <br><br>  F√ºr den PC habe ich alles in JAVA, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IntelliJ IDEA geschrieben</a> .  Grunds√§tzlich k√∂nnen Sie jedoch alles tun. Die Hauptsache f√ºr uns ist, einen Client zu schreiben, der das Programm zum Flashen von AVR an ESP8266 sendet. <br><br>  Ich selbst schreibe Programme f√ºr AVR in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ATMEL STUDIO</a> , in C-Sprache, selten in Assembler.  Ich verwende im Prinzip keine Arduino-Skizzen, fast jede notwendige Bibliothek wird in ein oder zwei Stunden geschrieben, mit einem vollst√§ndigen Verst√§ndnis ihrer Arbeit.  Ich habe Skizzen ausprobiert, aber solange Sie kein Betriebssystem auf dem AVR haben, werden Skizzen einem Freund Peripherieger√§te wegnehmen und regelm√§√üig fehlschlagen.  Ja, die Arduino IDE selbst ist im Vergleich zu ATMEL STUDIO nat√ºrlich eine sehr primitive Sache.  Aber hier ist die Frage nat√ºrlich umstritten, f√ºr Geistes- und Schulkinder wird es wahrscheinlich mit Skizzen lustiger und einfacher. <br><br>  F√ºr die Programmierung des ESP8266 habe ich die NodeMCU-Firmware verwendet und Programme in Lua geschrieben.  Nein, ich w√ºrde gerne in Java und C schreiben, aber es gibt keine in ESP.  Die Sprache Lu, wie sie auf unsere Aufgabe angewendet wird, ist nicht schwierig, ein paar Kleinigkeiten zu meistern.  Und tats√§chlich habe ich zum Herunterladen und Debuggen von Programmen auf ESP den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IDE ESPlorer verwendet</a> .  Ein kostenloses Inlandsprodukt (aber Sie k√∂nnen es dem Autor spenden), das nat√ºrlich nicht mit den oben genannten Umgebungen verglichen werden kann, aber wie das Geschenkpferd sagt ... Um ESPlorer zu verwenden und auf LUA zu schreiben, m√ºssen wir zuerst die Basis-Firmware (vom Hersteller geliefert) im ESP8266-Chip auf √§ndern neue.  Das NODE MCU PyFlasher-Programm wird uns bei diesem Vorhaben helfen.  Ich meine, es wird helfen, es erneut zu flashen.  Und wir werden die Firmware selbst erstellen und in die H√§nde der Ersteller-Website bekommen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NodeMCU</a> . Und mehr √ºber diesen Prozess k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">:</a> <br><br>  Alles ist sehr zug√§nglich und verst√§ndlich.  Wir f√ºgen den Basisbibliotheken SPI-Unterst√ºtzung und Bitoperationen hinzu (in LUA sind in unserem Fall Bitoperationen √ºberladen und von diesen unbrauchbar).  Viele Bibliotheken sollten nicht in die Firmware der Bibliotheken verschoben werden, da aufgrund des Vorhandenseins verschiedener Software auf dem ESP8266 nur noch sehr wenig Speicher √ºbrig ist, eine Art erb√§rmliche 20 kB. <br><br>  Nat√ºrlich k√∂nnen Sie auch nur die fertige Firmware nehmen, von der viele bereits im Internet h√§ngen, aber ich empfehle sie nicht.  Zumindest, weil einige von ihnen keine Unterst√ºtzung f√ºr Bitoperationen haben (und wir sie brauchen) und es keine Regulierung der Daten√ºbertragungsrate √ºber SPI gibt. <br>  Dementsprechend werden sie standardm√§√üig mit einer Geschwindigkeit von 40 MHz geteilt durch einen kleinen Koeffizienten √ºbertragen, und daher hat der AVR keine Zeit, sie zu verdauen. <br><br>  Wer zu faul ist, um Firmware zu erstellen, kann meine aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cloud</a> herunterladen. <br><br>  Jetzt haben wir die Firmware und m√ºssen sie in den ESP8266 anstatt in den Basis-Firmware laden.  Dazu ben√∂tigen wir einen einfachen USB-Adapter - UART. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/48a/a27/8c7/48aa278c709446c38f3c89dd7b063bb6.jpg"></div><br>  Wir verbinden die TXD-Beine mit RXD und RXD mit TXD, wir machen die gemeinsame Masse, verwenden aber anscheinend keinen praktischen 3,3-V-Ausgang am Adapter.  In den meisten F√§llen wird der ESP8266 ihn vollst√§ndig entleeren.  Deshalb f√ºttern wir es separat.  Dann versetzen wir das ESP in den Programmiermodus (GP0 auf den Boden, falls jemand es vergessen hat) und f√ºhren den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NODE MCU PyFlasher aus</a> . <br><br><img src="https://habrastorage.org/web/437/bd0/676/437bd067628f4a9db96466bb8d0d793b.png"><br><br>  Vergessen Sie nicht, den Flash-Speicher zu l√∂schen (ja, l√∂scht alle Daten). Andernfalls verbleibt je nach Firmware-Version nach der Programmierung m√∂glicherweise unn√∂tiger M√ºll im Speicher, der bei weiteren Arbeiten den M√ºll in die Konsole wirft.  Vorher habe ich Software verwendet, bei der es keine M√∂glichkeit gab, den Speicher vorher zu l√∂schen. Ich war schrecklich gequ√§lt, da nichts funktionierte.  Und der Sarg wurde gerade ge√∂ffnet, nur die Wahrheit im englischen Forum der Macher von NODE MCU. <br><br>  Nachdem wir die erforderliche Firmware erworben haben, k√∂nnen wir jetzt LUA-Programme (es gibt auch MicroPython, aber ich habe es nicht verwendet) mit sehr praktischen APIs von NODE MCU schreiben und debuggen.  Wir starten den bereits erw√§hnten ESPlorer. <br><br><img src="https://habrastorage.org/web/8c0/a47/d1f/8c0a47d1fbfa41c8a1413852852a1513.png"><br><br>  Wir konfigurieren es auch f√ºr die Verwendung mit ESP8266 und stellen die Parameter der seriellen Verbindung ein.  Alles ist ganz einfach und wird im Internet immer wieder angegeben. <br><br>  Jetzt schreiben wir das Programm auf LUA, das wir dann auf ESP8266 hochladen: <br><br><div class="spoiler">  <b class="spoiler_title">Lua Bootloader f√ºr AVR geschrieben auf ESP8266</b> <div class="spoiler_text"><pre><code class="lua hljs">&lt;b&gt;<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstrProgrammingEnable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- instruction for MC "enable programming"&lt;/b&gt; p=0 while p&lt;31 do p=p+1 pin=8 gpio.write(pin, gpio.LOW) spi.send(1, 0xAC,0x53) read = spi.recv( 1, 8) spi.send(1,0,0) gpio.write(pin, gpio.HIGH) if (string.byte(read)== 83) then print("connection established") p=33 if(p==31) then print("no connection") end end end end &lt;b&gt;function ProgrammingDisable ()&lt;/b&gt; pin=2--END OF ESET FOR MK gpio.mode(pin, gpio.INPUT) pin=8 gpio.mode(pin, gpio.INPUT) pin=5--CLK MASTER for SPI gpio.mode(pin, gpio.INPUT) pin=6--MISO MASTER for SPI gpio.mode(pin, gpio.INPUT) pin=7--MOSI MASTER for SPI gpio.mode(pin, gpio.INPUT) end &lt;b&gt;function ProgrammingEnable ()&lt;/b&gt; pin=2-- RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) pin=2--POZITIV FOR 4MSEC RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(4) gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) tmr.delay(25000) end &lt;b&gt;function InstrFlashErase() &lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0xAC,0x80,0,0) gpio.write(pin, gpio.HIGH) tmr.delay(15000) pin=2--RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(20000) gpio.write(pin, gpio.LOW) print( "FLASH is erased") InstrProgrammingEnable () end &lt;b&gt;function InstrStorePAGE(H, address, data)&lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,H,0,address,data) gpio.write(pin, gpio.HIGH) tmr.delay(500) end &lt;b&gt;function InstrWriteFLASH(page_address_low,page_address_high)&lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0x4C,page_address_high,page_address_low,0) gpio.write(pin, gpio.HIGH) tmr.delay(5000)--        end &lt;b&gt;function Programming (payload)&lt;/b&gt; pin=8--CS MASTER for SPI gpio.mode(pin, gpio.OUTPUT, gpio.PULLUP) pin=4--LED LIGHTS ON LOW gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) print(string.len(payload)) page_count = 7 --  1  for k =0 ,page_count ,1 do--quantity of pages for i=0 , 127, 2 do-- -1 address = i/2 data=payload:byte(i+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x40,address,data) -- tmr.delay(100)-- otherwise not in time write data =payload:byte(i+1+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x48,address,data) -- tmr.delay(100) end page_address_low=bit.band(k ,3)*64 -- 3   11 page_address_high=k/4+frame1024*2 tmr.delay(1000) InstrWriteFLASH(page_address_low,page_address_high) tmr.wdclr() end pin=4--LED gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) end &lt;b&gt;--MAIN BLOCK&lt;/b&gt; wifi.setmode(wifi.STATION) --wifi.sta.config(" ","") -- set SSID and password of your access point station_cfg={} tmr.delay(30000) station_cfg.ssid=" " tmr.delay(30000) station_cfg.pwd="" tmr.delay(30000) wifi.sta.config(station_cfg) tmr.delay(30000) wifi.sta.connect() tmr.delay(1000000) print(wifi.sta.status()) print(wifi.sta.getip()) while ( wifi.sta.status()~=1 ) do if( wifi.sta.status()==5) then break end end sv=net.createServer(net.TCP,30) tmr.delay(100) print("SERVER READY") sv:listen(4000,function(c) c:on("receive", function(c, payload) print(payload) if (payload =="program\r\n") then c:send("ready\r\n") print("ready for program\r\n") spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8,320,spi.FULLDUPLEX) ProgrammingEnable () tmr.delay(100) InstrProgrammingEnable () tmr.delay(100) InstrFlashErase() tmr.delay(100) frame1024=0--    st=net.createServer(net.TCP,30) st:listen(4001,function(c) c:on("receive", function(c, payload) tmr.wdclr() Programming (payload) frame1024=frame1024+1 end) end) end if (payload =="data\r\n") then c:send("ready\r\n") print("ready for data\r\n") srv=net.createServer(net.UDP) tmr.delay(1000) pin=10 gpio.write(pin, gpio.HIGH) uart.setup(0,9600,8,0,1,0) srv:listen(5000) srv:on("receive", function(srv, pl) pl=pl*1 --print(pl) uart.write(0,pl) tmr.wdclr() end) end if (payload =="stop\r\n") then if(st~=nil) then st:close() frame1024=0 ProgrammingDisable () print("stop program") end if(srv~=nil) then srv:close() print("stop data") end end end) end) end)</span></span></code> </pre> <br><br></div></div><br>  Wo die relevanten Funktionen die folgenden Aktionen ausf√ºhren: <br><br>  <b>Funktion InstrProgrammingEnable ()</b> - <b>Versetzt</b> den Mikrocontroller mit einem speziellen Befehl, der √ºber SPI gesendet wird, in den Programmiermodus. <br><br>  <b>Funktion ProgrammingEnable ()</b> - Setzen Sie den AVR einfach f√ºr 25 ms zur√ºck, bevor Sie mit der Programmierung beginnen <br><br>  <b>Funktion ProgrammingDisable ()</b> - Nach dem Ende der Programmierung √ºbersetzen wir die SPI-Ausg√§nge in ESP8266 in einen inaktiven Zustand, damit sie uns bei der Ausf√ºhrung von Code auf dem Mikrocontroller nicht st√∂ren (pl√∂tzlich werden sie dort verwendet). <br><br>  <b>Funktion InstrFlashErase ()</b> - Wir l√∂schen den Flash-Speicher auf dem Mikrocontroller vor dem Programmieren.  Warum dies erkl√§rt werden muss, ist nicht notwendig. <br><br>  <b>Funktion InstrStorePAGE (H, Adresse, Daten)</b> - Dieser Befehl schreibt das Byte des Programms in den internen Puffer des Mikrocontrollers.  Dies ist jedoch nicht die Flash-Aufzeichnung selbst, da der Flash hier Seite f√ºr Seite mit 128 Bytes geschrieben wird. <br><br>  <b>Funktion InstrWriteFLASH (page_address_low, page_address_high)</b> - aber dies ist eine Flash-Aufzeichnung und es braucht Zeit, achten Sie auf die Zeitverz√∂gerung von 5.000 Œºs. <br><br>  <b>Funktionsprogrammierung (Nutzlast)</b> - die gr√∂√üte und wichtigste Funktion mit den oben genannten Funktionen.  Es nimmt das √ºbertragene Programm in Bl√∂cken von 1024 Bytes, teilt sie in Bytes auf und bildet die Adressen f√ºr sie, sendet es dann an den Mikrocontroller im internen Puffer und initialisiert den Flash-Datensatz alle 128 Bytes.  Dann nimmt er das n√§chste Kilobyte Code und wiederholt den Vorgang, nat√ºrlich mit einem Versatz in den Adressen, um weiter zu schreiben und den aufgezeichneten nicht zu √ºberschreiben.  Zuerst habe ich versucht, das gesamte Programm weiterzuleiten, aber wenn ich in ESP8266 6 Kilobyte √ºberschreite, endet der verf√ºgbare Speicher einfach und es st√ºrzt ab.  Ein Kilobyte erwies sich als die bequemste Einheit, da es ordentlich in Teile unterteilt und bequem √ºber TCP √ºbertragen wird (wir m√ºssen es noch vom Computer beziehen).  Eine gr√∂√üere Gr√∂√üe wird auch nicht ben√∂tigt, TCP, wissen Sie, begrenzt in der aktuellen Version das √ºbertragene Paket auf 1500 oder Bytes (aber aus irgendeinem Grund wurde 1440 irgendwie an mich √ºbertragen). <br><br>  Als w√§re nichts kompliziert, aber ein paar Fallstricke mussten √ºberwunden werden. <br><br>  Als n√§chstes kommt MAIN BLOCK.  Darin wir: <br><br>  Wir sind in einem drahtlosen Netzwerk registriert. <br><br>  Zuerst erstellen wir einen TCP-Server, der drei Befehle abh√∂rt: <br><br>  1. "Programm" (wir werden programmieren) <br><br>  2. "Daten" (wir werden die Daten √§ndern), <br><br>  3. "Stop" (wir stoppen alles). <br><br>  Wenn wir programmieren, initialisieren wir zuerst das SPI und erstellen einen weiteren TCP-Server, der die Daten (Firmware-Code) pro Kilobyte erfasst und die Mikrocontroller-Programmierfunktionen f√ºr diese aufruft.  Ich verstehe, dass es albern aussieht, einen zweiten Server zu erstellen, aber dies ist eine Notwendigkeit, da die lokale API das Erstellen nur eines Sockets unterst√ºtzt und wir die Befehle "program" und "data" von den √ºbertragenen Daten trennen m√ºssen, da sie sich nach Augenmerk nicht unterscheiden, es gibt Bytes und Hier sind Bytes. <br><br>  Wenn wir nicht programmieren, sondern Daten austauschen und in unserem Fall an den Mikrocontroller senden m√∂chten, senden wir zuerst die Zeichenfolge ‚ÄûDaten‚Äú √ºber TCP.  Als Reaktion darauf wird ein UDP-Server erstellt (ich erinnere Sie daran, dass wir nicht dynamisch mit einer mechanischen Hand verwalten und dass wir keine Verz√∂gerungen bei der Bildung von TCP-Paketen ben√∂tigen und tats√§chlich ein Byte als ganzen TCP-Frame √ºber den Z√§hler senden).  Und UDP-Datagramme werden klein sein und sich schnell bilden. <br><br>  Nachdem der UART initialisiert wurde und jedes drahtlos empfangene Byte bereits √ºber die TXD-Leitung an den Mikrocontroller gesendet wurde, muss dieser empfangen werden, wenn das entsprechende Programm dort aktualisiert wird.  Der Datenaustausch in eine andere Richtung ist ebenfalls nicht schwer zu organisieren, aber ich habe ihn noch nicht implementiert. <br><br>  Nun, mit dem Befehl "stop" schlie√üen die oben genannten Server (mit Ausnahme des allerersten) die Verbindungen und der Hauptserver wechselt wieder in den Wartezustand der Befehle "program" und "data". <br><br>  Da die SPI-Schnittstelle in ESP8266, E / A-Ports f√ºr die Signale CS, CLK, MISO, MOSI, RESET (f√ºr AVR) programmgesteuert emuliert wird, k√∂nnen Sie alle verf√ºgbaren verwenden und nicht die in meinem Bootloader angegebenen.  Au√üerdem stellte sich heraus, dass CS und MISO grunds√§tzlich auch in diesem Fall unterbrochen werden k√∂nnen, es wird ohne sie funktionieren.  Nun, ein Pin wird auf der in die ESP8266-Platine eingebauten LED verwendet, so dass sie manchmal blinkt und anzeigt, dass das Programm noch aktiv ist. <br><br>  √úberpr√ºfungen auf Aufnahmefehler werden nicht durchgef√ºhrt (mit Ausnahme der ersten Anforderung an AVR, aber diese Informationen werden einfach auf der Konsole angezeigt), das EEPROM ist nicht programmiert, mehr als 32 KB sind nicht gen√§ht - kurz gesagt, es gibt noch viel zu tun.  Die SPI-Austauschgeschwindigkeit betr√§gt ungef√§hr 115 Kbit. In wenigen Sekunden wird alles geflasht, ungef√§hr wie bei einem normalen seriellen Programmierer wie ISP500. <br><br>  Nehmen Sie den Code, geben Sie Ihre Netzwerke und Kennw√∂rter ein, kompilieren Sie ihn im ESplorer, nennen Sie ihn "init" (damit er beim Neustart beginnt) und senden Sie ihn an ESP8266.  Es sollte funktionieren.  Zumindest im Sinne einer Arbeit als drahtloser Programmierer. <br><br>  Jetzt werden wir uns mit der gesch√§ftsf√ºhrenden Partei befassen - einem Personal Computer. <br><br>  Tats√§chlich m√ºssen wir die HEX-Datei, in die Ihre in der ATMEL STUDIO-Umgebung geschriebenen Programme umgewandelt werden, √ºber WI-FI an den uns bekannten Socket-Port senden (in diesem Fall 4000).  Der kleine Haken ist, dass wir eine bin√§re BIN-Datei f√ºr die √úbertragung ben√∂tigen und ATMEL STUDIO uns nur mit einem HEX gef√§llt.  Es gibt zwei Auswege;  oder konvertieren Sie es mit einem speziellen Programmkonverter wie WinHex in das BIN-Format oder machen Sie es selbst in Ihrem Programm.  Ich habe es noch nicht getan, aber es scheint nicht schwierig zu sein, da muss man den Titel abschneiden und etwas anderes tun. <br><br>  Aus diesem Grund habe ich das Bootloader-Programm in JAVA geschrieben (haupts√§chlich, weil ich nicht wei√ü, wie ich etwas anderes machen soll) und in der einfach sch√∂nen und kostenlosen IntelliJ IDEA-Umgebung gearbeitet.  Es wird ein TCP-Client erstellt, der nach einem Server sucht, der auf ESP8266 ausgef√ºhrt wird.  Wenn es findet, kontaktiert es ihn und sendet ihm eine Datei, die sich an einer solchen Adresse befindet.  Der Code ist unten. <br><br><div class="spoiler">  <b class="spoiler_title">PC-basierter JAVA-Datei-Downloader</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Net</span></span></span><span class="hljs-class"> </span></span>{ &lt;b&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Http_client(<span class="hljs-number"><span class="hljs-number">4000</span></span>); }&lt;/b&gt; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http_client</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port; String s; String Greetings_from_S; Http_client(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = port; start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//192.168.1.113 -  ESP8266   .  ,      //    ,    try (Socket socket = new Socket("192.168.1.113", port)) { PrintWriter pw = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()),true); pw.println("program");// Greetings with SERVER System.out.println("program"); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); Greetings_from_S = br.readLine(); System.out.println(Greetings_from_S); if(Greetings_from_S.equals("ready")) { try { File file = new File("d:BlinkOUT.bin");//    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); byte [] data = new byte[bis.available()]; bis.read(data); byte [] data_buffer = new byte[1024]; int frames = data.length/1024; System.out.println(frames); int residy = data.length%1024; for (int i = 0; i &lt; frames;i++) { for (int k = 0; k&lt; (1024); k++) { data_buffer[k] = data[k+1024*(i)]; } sendingChunk(data_buffer); } byte [] data_buffer2= new byte[residy]; for (int i = 0; i &lt; residy;i++) { data_buffer2[i] = data[i+1024*(frames)]; } sendingChunk(data_buffer2); pw.println("stop");// System.out.println("stop program"); } catch (Exception e) { System.out.println(e); } } } catch (Exception e) { System.out.println(e); } } public void sendingChunk (byte [] data_buffer){ try (Socket socket = new Socket("192.168.1.113", 4001)){ BufferedOutputStream bos = new BufferedOutputStream((socket.getOutputStream())); bos.write(data_buffer); bos.flush(); System.out.println(data_buffer.length); } catch (Exception e) { System.out.println(e); } } }</span></span></code> </pre><br><br></div></div><br>  Hier wurde nat√ºrlich zu viel verwundet, alle Arten von Ready werden grunds√§tzlich nicht ben√∂tigt.  Wenn die TCP-Verbindung hergestellt ist, wird sie hergestellt.  Das einzige Problem war, dass die Datei in keiner Weise in geraden Teilen von 1024 Bytes gesendet werden wollte, wie ich es wirklich brauchte, obwohl ich die Gr√∂√üe ausdr√ºcklich angegeben habe.  Anscheinend gibt es eine Art endg√ºltigen Puffer, auf den von JAVA nicht zugegriffen werden kann, und er sendet Pakete in der gew√ºnschten Gr√∂√üe, was f√ºr die empfangende Seite v√∂llig inakzeptabel ist.  Zuerst habe ich versucht zu verz√∂gern, damit der Puffer es leid wird, auf die n√§chsten Teile zu warten und sie so zu senden, wie sie sind.  Aber die Verz√∂gerung begann zu wirken, als sie 10 Sekunden erreichte, was f√ºr ein √ºbertragenes Kilobyte irgendwie etwas zu viel schien. <br><br>  Aber dann bemerkte ich, dass aus irgendeinem Grund das erste St√ºck immer glatt l√§uft, welches bestellt wurde, und bereits ab dem zweiten beginnt eine unvorhersehbare Bacchanalia.  Daher habe ich den Client dazu gebracht, die Verbindung zu √∂ffnen, einen Teil des Codes in 1024 Bytes zu senden und die Verbindung zu schlie√üen.  Und so weiter, bis die gesamte Datei gesendet wird.  Alles hat gut funktioniert. <br><br>  Sie m√ºssen lediglich die JAVA-Laufzeit auf dem Computer installieren.  Normalerweise beginne ich jedoch sofort mit IntelliJ IDEA, da Sie dort immer sehen k√∂nnen, was in der Konsole passiert (aber hier ben√∂tigen Sie eine JAVA-Umgebung).  Obwohl Sie nat√ºrlich auf intelligente Weise eine GUI erstellen m√ºssen.  Das hei√üt, das Fenster, in das der Pfad zur Datei f√§llt, die M√∂glichkeit, die Portnummern im Fenster zu √§ndern, und andere notwendige Dinge.  Und all dies in Form einer ausf√ºhrbaren Datei zu sammeln. <br><br>  Und Tapericha, wie Koroviev sagte, kehren wir zu den B√ºrgern zur√ºck, und zwar zu dem mechanischen Glied MechArm, das ganz am Anfang erw√§hnt wurde.  Wir haben jetzt die M√∂glichkeit, es remote zu programmieren und dann zu verwalten.  Fahren wir mit dem Steuerprogramm auf der Seite des Mikrocontrollers fort. <br><br>  In diesem Fall m√ºssen wir vier Servos steuern.  Hier sind die. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/d29/b6c/8ee/d29b6c8ee960405b9070649d8dc0b2a2.jpg"></div><br>  Ein solcher Antrieb wird durch Rechteckimpulse einer Periode von 20 ms (50 Hz) mit einem Tastverh√§ltnis von 2 bis 4 Prozent gesteuert.  Das hei√üt, 2% sind eine vollst√§ndige Drehung in die eine Richtung, 4% in die andere.  Die Aufgabe ist nur f√ºr die im AVR integrierte PWM. <br><br><img src="https://habrastorage.org/web/9a8/385/2f6/9a83852f6093435abf70b5a8f8d5f29c.png"><br><br>  Ein Servoantrieb wird verwendet, um sich nach links und rechts zu bewegen.  der zweite auf sich selbst - von sich selbst;  drittens auf und ab;  Die vierte ist die Klaue selbst, die zusammengedr√ºckt und expandiert werden muss.  Alles ist in C geschrieben und in ATMEL STUDIO zu einer HEX-Datei kompiliert.  Eine etwas seltsame Art von Programm ist auf die Tatsache zur√ºckzuf√ºhren, dass die Hand anfangs von der Tastatur aus gesteuert wurde, die mit Dr√§hten an den Mikrocontroller gebunden war.  Aber die Dr√§hte von gestern m√ºssen wir weiterentwickeln. <br><br>  Sie k√∂nnen nat√ºrlich Skizzen f√ºr Servos von "ARDUINO" verwenden, aber ich mochte sie nicht.  Es ist interessanter, sich selbst zu schreiben.  Au√üerdem sollten alle vier Servos gleichzeitig und nicht im Multiplexmodus arbeiten, wenn die PWM nacheinander auf jedes Servo umschaltet.  Denn niemand hat die Schwerkraft aufgehoben, und ein angehobenes Glied senkt sich sofort ab, wenn die Steuerimpulse nicht mehr zum entsprechenden Servoantrieb gelangen.  Ich bin mir nicht sicher, ob die Skizze ‚ÄûARDUINO‚Äú den gleichzeitigen Betrieb von vier Servos erm√∂glicht.  Aber wir k√∂nnen selbst ein Programm schreiben, das die notwendigen Anforderungen erf√ºllt.  In Ermangelung eines Betriebssystems, das die L√§mmer von den Ziegen trennt, ist die Verwendung von Skizzen, die um die Peripherieger√§te des Mikrocontrollers konkurrieren (und wir wissen nicht einmal, welche im Voraus), zu fehlerhaft. <br><br>  Hier ist der Code selbst, den wir mit dem ESP8266-07 in den Arduino Nano schreiben. <br><br><div class="spoiler">  <b class="spoiler_title">Programm zur Steuerung von MechArm f√ºr Mikrocontroller AVRmega328P</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 16000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;stdint.h&gt;//    #include &lt;avr/interrupt.h&gt; #include &lt;math.h&gt; //  #include &lt;stdio.h&gt; // - #include &lt;avr/eeprom.h&gt; #include &lt;setjmp.h&gt; #include &lt;stdlib.h&gt; //  #define UART_BAUD_RATE 115200 //  1    20 #define COUNTER1_OFF TCCR1B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER1_ON TCCR1B=0b00000011 //  0       0  1 #define COUNTER0_OFF TCCR0B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER0_ON TCCR0B=0b00000100 //  2       B2(PD6)  3(PD7) #define COUNTER2_OFF TCCR2B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER2_ON TCCR2B=0b00000110 volatile uint16_t period_20ms; volatile uint8_t State_of_keyboard; volatile uint8_t start_position [6]; volatile int8_t number_servo; ISR(USART_RX_vect)//   UART { State_of_keyboard=UDR0; return; } ISR(TIMER0_COMPA_vect)//  0    { PORTB &amp;=~(1&lt;&lt;0); TIMSK0&amp;=~(1&lt;&lt;OCIE0A); TIFR0 |=(1&lt;&lt;OCF0A); return; } ISR(TIMER0_COMPB_vect) //  1    { PORTB &amp;=~(1&lt;&lt;1); TIFR0 |=(1&lt;&lt;OCF0B); TIMSK0 &amp;=~(1&lt;&lt;OCIE0B); return; } ISR(TIMER2_COMPA_vect)//  2(PD6)    { PORTD &amp;=~(1&lt;&lt;6); TIFR2 |=(1&lt;&lt;OCF2A); TIMSK2 &amp;=~(1&lt;&lt;OCIE2A); return; } ISR(TIMER2_COMPB_vect)//  3(PD7)    { PORTD &amp;=~(1&lt;&lt;7); TIFR2 |=(1&lt;&lt;OCF2B); TIMSK2 &amp;=~(1&lt;&lt;OCIE2B); return; } ISR(TIMER1_OVF_vect){//   20      COUNTER1_OFF; COUNTER0_OFF; COUNTER2_OFF; TIFR0 |=(1&lt;&lt;OCF0A); TIFR0 |=(1&lt;&lt;OCF0B); TIFR2 |=(1&lt;&lt;OCF2A); TIFR2 |=(1&lt;&lt;OCF2B); TIFR1 |=(1&lt;&lt;TOV1); PORTB |=(1&lt;&lt;0)|(1&lt;&lt;1); PORTD |=(1&lt;&lt;6)|(1&lt;&lt;7); TCNT1 = period_20ms; //  20  TCNT0 = 0; TCNT2 = 0; TIMSK0|=(1&lt;&lt;OCIE0A)|(1&lt;&lt;OCIE0B); TIMSK2|=(1&lt;&lt;OCIE2A)|(1&lt;&lt;OCIE2B); OCR0A=start_position[1];//  0  0 OCR0B=start_position[2];//  0  1 OCR2A=start_position[3];//  0  2 OCR2B=start_position[4];//  0  3 COUNTER1_ON; COUNTER2_ON; COUNTER0_ON; return; } void time_delay(long i) { cli();sei(); long k; i*=2000; for(k=0;k&lt;i;k++){;;}; } void timer_counter0_1_2_INIT()//   0,1,2 { // 1 TCCR1A &amp;=~(1&lt;&lt;COM1A0)|~(1&lt;&lt;COM1A1)|~(1&lt;&lt;COM1B0)|~(1&lt;&lt;COM1B1);//   TCCR1A &amp;=~(1&lt;&lt;WGM10)|~(1&lt;&lt;WGM11); TCCR1B &amp;=~(1&lt;&lt;WGM12)|~(1&lt;&lt;WGM13);//    period_20ms=60575; TCNT1 = period_20ms; TIMSK1|=(1&lt;&lt;TOIE1);//|    //TIFR0   TOV0 // 0 TCCR0A &amp;=~(1&lt;&lt;COM0A0)|~(1&lt;&lt;COM0A1)|~(1&lt;&lt;COM0B0)|~(1&lt;&lt;COM0B1);//   TCCR0A &amp;=~(1&lt;&lt;WGM00)|~(1&lt;&lt;WGM01); TCCR0B &amp;=~(1&lt;&lt;WGM02);//    // 2 TCCR2A &amp;=~(1&lt;&lt;COM2A0)|~(1&lt;&lt;COM2A1)|~(1&lt;&lt;COM2B0)|~(1&lt;&lt;COM2B1);//   TCCR2A &amp;=~(1&lt;&lt;WGM20)|~(1&lt;&lt;WGM21); TCCR2B &amp;=~(1&lt;&lt;WGM22);//    COUNTER1_ON; } void servo_reset() { start_position[1]=97;//  0  0 start_position[2]=70;//  0  1 start_position[3]=92;//  0  2 start_position[4]=124; // 0  3 COUNTER1_ON; time_delay(100); } void servo_go( int8_t moven, uint8_t servo_position_max, uint8_t servo_position_min)// { switch (moven){ case 1: start_position[number_servo]++; if(start_position[number_servo]==servo_position_max){start_position[number_servo]--;};//  +90  break; case 2: start_position[number_servo]--; if(start_position[number_servo]==servo_position_min){start_position[number_servo]++;};//6  -90  break; }; time_delay(20); return; } //PORTB-0,1, PORTD - 6,7 -  , 8-  COUNTER 0 int main(void) { uint8_t servo_positionmin=0, servo_positionmax=0; int8_t const servo_position1max = 122, servo_position1min=58; //  int8_t const servo_position2max = 120, servo_position2min=36;// int8_t const servo_position3max = 125, servo_position3min=68;// int8_t const servo_position4max = 129, servo_position4min=108;// 128 108 sei(); DDRD = 0B11000010; //   D2-D5  , D0  RX, D1  TX, D6 D7   3  4 PORTD = 0B00111110; //     DDRB |=(1&lt;&lt;0)|(1&lt;&lt;1);//         PORTB &amp;=(~1&lt;&lt;0)|(~1&lt;&lt;1); UCSR0A=0;// UART UCSR0B=0b10010000; UCSR0C=0b00000110; UBRR0L=103;//  115200 UBRR0H=0; timer_counter0_1_2_INIT(); servo_reset(); PORTB |=(1&lt;&lt;5); while (1) { switch (State_of_keyboard) { case 1://   1 PD0(PB0) number_servo=1; servo_positionmin=servo_position1min; servo_positionmax=servo_position1max; break; case 2: //   1 PD0(PB0) number_servo=1; servo_positionmin=servo_position1min; servo_positionmax=servo_position1max; break; case 5: number_servo=2; //   2 PD1(PB1) servo_positionmin=servo_position2min; servo_positionmax=servo_position2max; break; case 6: number_servo=2; //   2 PD1(PB1) servo_positionmin=servo_position2min; servo_positionmax=servo_position2max; break; case 7: number_servo=3;//   3 PD6 servo_positionmin=servo_position3min; servo_positionmax=servo_position3max; break; case 8: number_servo=3;//   3 PD6 servo_positionmin=servo_position3min; servo_positionmax=servo_position3max; break; case 3: number_servo=4; //   4 PD7 servo_positionmin=servo_position4min; servo_positionmax=servo_position4max; break;//  case 4: number_servo=4; //   4 PD7 servo_positionmin=servo_position4min; servo_positionmax=servo_position4max; break;//  // c    - ,       4-  //        ,         } if(State_of_keyboard==1||State_of_keyboard==3||State_of_keyboard==5||State_of_keyboard==7) { servo_go(1,servo_positionmax,servo_positionmin);// } if(State_of_keyboard==2||State_of_keyboard==4||State_of_keyboard==6||State_of_keyboard==8) //     { servo_go(2,servo_positionmax,servo_positionmin);// } time_delay(20); } }</span></span></span></span></code> </pre><br><br></div></div><br>  Das Wesentliche des Programms geht aus dem Text und den Kommentaren hervor.  Wir verwenden einen T1-Z√§hler f√ºr einen beispielhaften Zeitraum von 20 ms und T0, T2-Z√§hler f√ºr die Ausgabe von PWM-Signalen an vier Leitungen des E / A-Ports, da jeder dieser beiden Z√§hler auf zwei Ger√§ten arbeiten kann. <br>  Das Programm setzt die Anfangspositionen der Servos durch Laden der Z√§hlregister OCR0A, OCR0B, OCR2A, OCR2B.  Es werden auch Einschr√§nkungskonstanten eingef√ºhrt, da wir nicht immer eine 180-Grad-Spanne ben√∂tigen.  Durch Unterbrechung von UART f√§ngt das Programm die von ESP8266 gesendete Nummer (von 1 bis 8) ab und √ºbersetzt sie in einen Befehl f√ºr das entsprechende Servo.  Es gibt vier Laufwerke, die jeweils in zwei Richtungen arbeiten, sodass Ganzzahlen von eins bis acht ausreichen.  Sobald die Nummer ausgew√§hlt ist, wird der Inhalt der obigen Z√§hlerregister entweder inkrementiert oder dekrementiert, wodurch sich das Tastverh√§ltnis des Steuerimpulses und der Drehwinkel des ausgew√§hlten Servoantriebs √§ndern.  Die von uns nicht ausgew√§hlten Antriebe behalten den alten Wert des Drehwinkels bei (da sich der Inhalt der entsprechenden Register, obwohl sie aktualisiert wurden, nicht ge√§ndert haben) und halten den mechanischen Arm weiterhin in derselben Position. <br><br>  Jetzt m√ºssen wir nur noch ein Steuerungsprogramm schreiben, entschuldigen Sie die Tautalogie, um eine mechanische Hand direkt vom Computer √ºber WI-FI zu steuern. <br>  Der Code ist ebenfalls in JAVA geschrieben, aber ein wenig geadelt.  Es gab eine grafische Benutzeroberfl√§che und die M√∂glichkeit, die Portnummern und die Netzwerkadresse des ESP8266 zu bearbeiten. <br><br><img src="https://habrastorage.org/web/d48/d3e/27a/d48d3e27af904919b00d0873de532d3d.png"><br><br>  Was dort passiert, ist aus dem Fenster ersichtlich.  Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stelle den</a> Text des Programms hier nicht zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verf√ºgung</a> (er ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> verf√ºgbar), und zwar aus folgendem Grund: Ungef√§hr 95% seines Volumens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">entfallen</a> auf die Fenstererstellung und Signalverarbeitung √ºber die Tastatur.  Aber das Wesentliche ist das gleiche wie im vorherigen Programm auf JAVA.  Es wird ein Client erstellt, nur UDP, der abh√§ngig von der gedr√ºckten Taste eine Nummer von 1 bis 8 an die angegebene Adresse am angegebenen Port sendet. <br>  Oder Sie k√∂nnen die ausf√ºhrbare Datei sofort <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier erhalten</a> .  F√ºr 64-Bit-Computer mit Windows.  Auch eine installierte JAVA-Umgebung ist nicht erforderlich.  Alles wurde bereits in 178 MB verschoben. <br><br>  Also wurde der mechanische Stift zusammengebaut, getestet und seinem Bruder zu seinem Jubil√§um pr√§sentiert.  Kann Plastikstapel mit Wodka √ºber Skype aus einer anderen Stadt abholen.  Obwohl f√ºr den mechanischen Arm von Howard Volovitsa aus der Serie "The Big Bang Theory", ist sie noch weit weg. <br><br>  In den folgenden Artikeln (falls jemand interessiert ist) k√∂nnen wir es jedoch von einem Mobiltelefon aus verwalten, dasselbe mit einem Allrad-Roboterwagen tun und die Uhrzeit in elektronischen Uhren von Uhrenservern im Internet aktualisieren.  Dann legen wir das alte Smartphone auf den Wagen und fahren das Video mit Mustererkennung zum neuronalen Netzwerk und geben die Steuersignale an die Motoren zur√ºck, <s>oh, etwas tr√§gt mich schon ...</s> <br><br>  Und das alles mit dem sch√∂nen ESP8266. <br>  Ich w√ºrde mich freuen, wenn jemand den Artikel interessant finden w√ºrde. <br><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pinbelegung und Spezifikationen von ESP8266</a> <br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anschlie√üen des ESP8266.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnellstart.</a> <br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NodeMCU-Firmware-Update √ºber die Cloud</a> <br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NODE MCU PyFlasher</a> <br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ESPlorer - IDE f√ºr ESP8266</a> <br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C Programmierung f√ºr AVR</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[7] </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Artikel√ºbersicht </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ‚ÄûProgrammieren von Mikrocontrollern in C-Sprache‚Äú</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [8] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschreibung der NodeMCU-API</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [9] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua-Referenz</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [10] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua-Skripte und -Module</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [11] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntelliJ IDEA</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [12] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden Sie Java jetzt auf Ihren Desktop-Computer herunter! </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atmel Studio</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de406559/">https://habr.com/ru/post/de406559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de406547/index.html">√úberpr√ºfung der Boards auf SoC ARM + FPGA. Teil Eins Xilinx World</a></li>
<li><a href="../de406549/index.html">Eine Anleitung zu elektrischen Materialien f√ºr alle. Teil 9</a></li>
<li><a href="../de406551/index.html">Monorad: zwei Jahreszeiten Erfahrung</a></li>
<li><a href="../de406553/index.html">Top 10 CNC-Desktop-Maschinen f√ºr zu Hause 2017</a></li>
<li><a href="../de406555/index.html">Du, ich und meine k√ºnstliche Intelligenz</a></li>
<li><a href="../de406561/index.html">Mikromaschinen bei der Behandlung von Magenerkrankungen</a></li>
<li><a href="../de406563/index.html">Warum dein Gehirn mehr Ruhe braucht</a></li>
<li><a href="../de406567/index.html">Unter dem Einfluss der Elemente: Das Kennedy Space Center bereitet sich auf den Hurrikan "Irma" vor.</a></li>
<li><a href="../de406569/index.html">XRONOS - Aggregator</a></li>
<li><a href="../de406571/index.html">Wie man das Altern besiegt - Aktionsplan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>