<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏼 🍓 👨‍🏭 Bermain dengan utas di Node.JS 10.5.0 👵 😔 💆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari yang baik 
  
 Di tempat kerja saya, perselisihan muncul antara saya dan afiliasi tentang utas di Node.JS versi baru dan kebutuhan untuk menyinkr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bermain dengan utas di Node.JS 10.5.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416015/"><h3>  Hari yang baik </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/3m/zt/sb/3mztsbwdikwbzsiwvboih0n979s.jpeg"></a> <br>  Di tempat kerja saya, perselisihan muncul antara saya dan afiliasi tentang utas di Node.JS versi baru dan kebutuhan untuk menyinkronkannya.  Untuk memulainya, kami memutuskan untuk memilih tugas menulis baris ke file secara paralel.  Topik dengan worker_threads panas, tolong, di bawah kucing. <br><a name="habracut"></a><br>  Sedikit tentang aliran itu sendiri.  Mereka adalah teknologi eksperimental di Node.JS 10.5.0, dan untuk memiliki akses ke modul "worker_threads", Anda perlu menjalankan aplikasi Node.JS kami dengan bendera "- pekerja eksperimen".  Saya mendaftarkan bendera ini di skrip awal di file package.json: <br><pre><code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"worker-test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"app.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node --max-old-space-size=4096 --experimental-worker app.js "</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span> }</code> </pre> <br>  Sekarang tentang logika itu sendiri.  Utas utama memunculkan utas pekerja, semuanya menulis ke file pada interval tertentu.  Tidak seperti semua contoh di mana stream utama dan anak mulai dari satu file, saya memisahkan stream menjadi yang terpisah, menurut saya lebih bersih dan elegan. <br><br>  Sebenarnya kodenya. <br><br>  File app.js utama adalah titik masuk. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Worker } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WORKERS_NUMBER = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello from main!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= WORKERS_NUMBER ; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> w = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(path.join(__dirname, <span class="hljs-string"><span class="hljs-string">'./writer-worker-app/app.js'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">workerData</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: i } }); }</code> </pre> <br>  Di sini kita cukup membuat stream anak menggunakan kelas Worker dan menentukan path ke file awal untuk stream './writer-worker-app/app.js'.  Saat membuat aliran, kami mentransfer pengenal yang ditulis sendiri sebagai data data pekerja. <br><br>  Mulai file untuk streaming ./writer-worker-app/app.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./logger'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = workerData.id; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Worker </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string"> initializad.`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { sendMessage(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">`Hello from worker number </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${workerData.id}</span></span></span><span class="hljs-string">\r\n`</span></span>); }</code> </pre><br><br>  Yah, kelas logger yang paling sederhana: ./writer-worker-app/logger.js <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fs.appendFileSync(<span class="hljs-string"><span class="hljs-string">'./my-file.txt'</span></span>, message); } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { log };</code> </pre><br>  Ketika memulai aplikasi ini, kami semua berharap bahwa pada akhirnya kami akan mendapatkan beberapa kekacauan dalam file dan para donor akan berteriak betapa diperlukannya kunci dengan semaphore dan kegembiraan lain dari eksekusi paralel.  Tapi tidak!  Dalam file, semua baris tanpa gangguan, kecuali dalam urutan acak: <br><br> <code>Hello from worker number 14 <br> Hello from worker number 3 <br> Hello from worker number 9 <br> Hello from worker number 15 <br> Hello from worker number 2 <br> Hello from worker number 4 <br> Hello from worker number 7 <br> Hello from worker number 6 <br> Hello from worker number 1 <br> Hello from worker number 11 <br></code> <br>  Eksperimen yang hebat, kemenangan kecil lain untuk Noda :-) Asumsi saya adalah bahwa semua sinkronisasi terjadi pada level I / O dari aliran Noda, tetapi saya akan senang mengetahui opsi yang benar dalam komentar.  Untuk jaga-jaga, kami memeriksa pekerjaan menggunakan bukan <b>fs.appendFileSync</b> , tetapi <b>fs.createWriteStream</b> dan metode <b>stream.write</b> . <br><br>  Hasilnya keluar sama. <br><br><h3>  Tapi kami tidak berhenti di situ. </h3><br>  Seorang kolega menyarankan tugas menyinkronkan utas.  Untuk contoh khusus kami, biarkan itu tugas menulis berurutan ke file dalam urutan pengidentifikasi.  Pertama menulis aliran pertama, lalu yang kedua, lalu yang ketiga dan seterusnya. <br><br>  Untuk melakukan ini, saya memperkenalkan Thread manajer lain.  Itu mungkin untuk bertahan dengan hal utama, tetapi saya sangat senang menciptakan pekerja yang terisolasi ini dan membangun komunikasi melalui pesan.  Sebelum Anda mulai menulis implementasi Stream-Manager, Anda perlu membuat saluran komunikasi antara dia dan pekerja penulis.  Kelas <b>MessageChannel</b> digunakan untuk ini.  Contoh kelas ini memiliki dua bidang: <b>port1</b> dan <b>port2</b> , masing-masing dapat mendengarkan dan mengirim pesan ke yang lain menggunakan metode <b>.on ('message')</b> dan <b>.postMessage ()</b> .  Kelas ini dibuat sebagai bagian dari modul “worker_threads” untuk komunikasi antar utas, karena biasanya ketika suatu objek ditransfer, ia hanya dikloning, dan dalam lingkungan eksekusi utas terisolasi itu tidak akan berguna. <br><br>  Untuk komunikasi antara 2 aliran, kita harus memberi semua orang port. <br><br>  <b>Fakta menarik</b> : pada 10.5.0 <u>tidak mungkin untuk melewati port melalui konstruktor pekerja</u> , Anda hanya perlu melakukan ini melalui pekerja.postMessage (), dan pastikan untuk menentukan port di parameter transferList! <br><br>  Pengelola utas sendiri akan mengirim perintah ke utas penulis dengan urutan naik dari pengidentifikasi mereka, dan itu akan mengirim perintah berikutnya hanya setelah menerima respons dari penulis tentang operasi yang berhasil. <br><br>  Diagram aplikasi UML: <br><img src="https://habrastorage.org/webt/os/rq/nl/osrqnlydmppapio9ubdba_0yrea.jpeg"><br><br>  File ./app.js bermutasi utama kami: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Worker, MessageChannel } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WORKERS_NUMBER = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Main app initialized and started.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workersMeta = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= WORKERS_NUMBER; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> channel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageChannel(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(path.join(__dirname, <span class="hljs-string"><span class="hljs-string">'./writer-worker-app/app.js'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">workerData</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: i } }); workersMeta.push({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: i, worker, channel }); } workersMeta.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ worker, channel }</span></span></span><span class="hljs-function">) =&gt;</span></span> { worker.postMessage({ <span class="hljs-attr"><span class="hljs-attr">orchestratorPort</span></span>: channel.port1 }, [channel.port1]); }) setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> orchestrator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(path.join(__dirname, <span class="hljs-string"><span class="hljs-string">'./orchestrator-worker-app/app.js'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> orchestratorData = workersMeta.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">meta</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: meta.id, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: meta.channel.port2 })); orchestrator.postMessage({ <span class="hljs-attr"><span class="hljs-attr">workerPorts</span></span>: orchestratorData }, orchestratorData.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w</span></span></span><span class="hljs-function"> =&gt;</span></span> w.port)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'All worker threads have been initialized'</span></span>); }, WORKERS_NUMBER * <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><br>  Di sini kita pertama-tama membuat pekerja, lalu kami mengirim setiap port port untuk komunikasi dengan manajer (dan hanya dengan cara ini, melalui konstruktor tidak mungkin untuk melakukan ini). <br><br>  Kemudian kami membuat manajer utas, kami mengirimkan daftar port untuk komunikasi dengan penulis mengalir. <br>  <b>Diperbarui</b> : secara empiris, saya mengetahui bahwa ketika bekerja dengan stream, lebih baik membiarkannya dibuat terlebih dahulu (diinisialisasi sesuai kebutuhan).  Demi kebaikan itu perlu untuk mendengarkan beberapa jawaban dari aliran dalam gaya "Aku siap!", Tapi aku memutuskan untuk pergi dengan cara yang lebih mudah. <br><br>  Kami juga akan mengubah perilaku utas penulis sehingga hanya mengirim pesan saat diperintahkan kepadanya, dan juga mengembalikan hasilnya saat operasi penulisan selesai: <br>  ./writer-worer-app/app.js <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./logger'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = workerData.id; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Worker </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string"> initializad.`</span></span>); parentPort.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, value =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> orchestratorPort = value.orchestratorPort; orchestratorPort.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, data =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.command == <span class="hljs-string"><span class="hljs-string">'write'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Worker </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string"> received write command`</span></span>); sendMessage(); sendResult(orchestratorPort); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Worker </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string"> started.`</span></span>); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ logger.log(<span class="hljs-string"><span class="hljs-string">`Hello from worker number </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${workerData.id}</span></span></span><span class="hljs-string">\r\n`</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">port</span></span></span><span class="hljs-function">) </span></span>{ port.postMessage({ id, <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-string"><span class="hljs-string">'completed'</span></span> }); }</code> </pre><br>  Kami diinisialisasi dengan benar dari pesan stream induk, mulai terjadi saluran manajer aliran, ketika kami menerima perintah, pertama-tama kami menulis ke file, kemudian kami mengirim hasilnya.  Perlu dicatat bahwa file tersebut ditulis secara sinkron, jadi sendResult () dipanggil segera setelah sendMessage (). <br><br>  Yang tersisa adalah menulis implementasi manajer cerdas kami <br>  ./orchestrator-worker-app/app.js: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Orchestrator initialized.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> workerPorts; parentPort.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, (value) =&gt; { workerPorts = value.workerPorts; workerPorts.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">wp</span></span></span><span class="hljs-function"> =&gt;</span></span> wp.port.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, handleResponse)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Orchestrator started.'</span></span>); sendCommand(workerPorts[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleResponse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">status</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseWorkerId = status.id; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nextWorker = workerPorts.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">wp</span></span></span><span class="hljs-function"> =&gt;</span></span> wp.id == responseWorkerId + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nextWorker) { nextWorker = workerPorts[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } sendCommand(nextWorker); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendCommand</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">worker</span></span></span><span class="hljs-function">) </span></span>{ worker.port.postMessage({ <span class="hljs-attr"><span class="hljs-attr">command</span></span>: <span class="hljs-string"><span class="hljs-string">'write'</span></span> }); }</code> </pre><br>  Kami mendapat daftar port, dipesan, untuk setiap port menetapkan panggilan balik ke respons, well, dan mengirim perintah ke yang pertama.  Dalam panggilan balik itu sendiri, kami mencari penulis berikutnya dan mengirim perintah kepadanya.  Agar tidak terlalu membebani sistem, interval antara tim ditetapkan. <br><br>  Itu saja, aplikasi manajemen thread multithreaded kami sudah siap.  Kami belajar tidak hanya untuk menghasilkan arus pekerja di Node.JS, tetapi juga untuk menciptakan cara komunikasi yang efektif di antara mereka.  Menurut pendapat pribadi saya, arsitektur utas terisolasi di Node.JS dengan menunggu dan mengirim pesan lebih dari nyaman dan menjanjikan.  Terima kasih atas perhatiannya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semua kode sumber dapat ditemukan di sini</a> . <br><br><h3>  PEMBARUAN </h3><br>  Agar tidak menyesatkan pembaca, dan juga untuk tidak memberikan alasan yang tidak perlu untuk menulis bahwa saya curang dengan waktu habis, saya memperbarui artikel dan repositori. <br>  Perubahan: <br>  1) interval dalam penulis asli dihapus, sekarang sementara (benar) berjalan di sepanjang hardcore <br>  2) menambahkan --max-old-space-size = 4096 flag, untuk berjaga-jaga, karena  implementasi stream saat ini tidak terlalu stabil dan saya harap ini bisa membantu. <br>  3) interval untuk mengirim pesan dari manajer utas telah dihapus.  Sekarang rekamannya non-stop. <br>  4) batas waktu ditambahkan ketika menginisialisasi manajer, mengapa - dijelaskan di atas. <br><br>  YANG HARUS DILAKUKAN: <br>  1) menambahkan pesan dengan panjang variabel atau menghitung panggilan logger - terima kasih FANAT1242 <br>  2) tambahkan patokan, bandingkan karya versi pertama dan kedua (berapa banyak baris akan ditulis dalam 10 detik, misalnya) <br><br><h3>  PEMBARUAN 2 </h3><br>  1) Kode logging telah diubah: sekarang setiap pesan memiliki panjang yang berbeda. <br>  2) Writer-worker-app / app.old.js telah diubah: setiap utas menulis 1000 kali, lalu berakhir. <br><br>  Ini dilakukan untuk menguji ide-ide pengguna FANAT1242.  Semua pesan yang sama tidak saling menulis ulang, baris dalam file persis 1000 * N utas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416015/">https://habr.com/ru/post/id416015/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416005/index.html">16 Alat Bereaksi untuk Pengembang Antarmuka</a></li>
<li><a href="../id416007/index.html">Hampir rumit. Awal dari penciptaan "rumah pintar" nirkabel. Berbasis pada teknologi Linux, perangkat lunak Z-Wave dan MajorDoMo</a></li>
<li><a href="../id416009/index.html">Coba kotoran kelinci, itu kuat, ia akan menangkap - ekstrak dalam farmakologi</a></li>
<li><a href="../id416011/index.html">Pola BIF: membersihkan kode front-end dan pekerjaan yang mudah dengan data server</a></li>
<li><a href="../id416013/index.html">Cara mulai berinvestasi dan menghemat uang: Pakar Dow Jones menyebutkan lima kesalahan utama pedagang pemula</a></li>
<li><a href="../id416017/index.html">Kami mengumpulkan analisis kohort / analisis arus pada contoh Excel</a></li>
<li><a href="../id416019/index.html">Seberapa baik ekosistem open-source R untuk memecahkan masalah bisnis?</a></li>
<li><a href="../id416021/index.html">Mengembangkan kerangka kerja Anda sendiri dan pertumbuhan profesional seorang programmer JS</a></li>
<li><a href="../id416023/index.html">Seperti julukan iOS, bot Telegram menulis, di Swift</a></li>
<li><a href="../id416025/index.html">Menerapkan Navigasi dalam Aplikasi Android Menggunakan Komponen Arsitektur Navigasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>