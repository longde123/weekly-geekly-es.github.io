<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📙 ♑️ 🤠 我们在Rust上编写一个操作系统。 页面的内存组织 🤵🏾 ⛵️ 💲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我们介绍pages ，这是一种非常常见的内存管理方案，我们也将其应用于操作系统。 本文介绍了为什么需要内存隔离， 分段如何工作，什么是虚拟内存以及页面如何解决分段问题。 我们还探讨了x86_64体系结构中的多级页表的方案。 

 该博客发布在GitHub上 。 如果您有任何疑问或问题，请在...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们在Rust上编写一个操作系统。 页面的内存组织</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436606/"> 在本文中，我们介绍<i>pages</i> ，这是一种非常常见的内存管理方案，我们也将其应用于操作系统。 本文介绍了为什么需要内存隔离， <i>分段</i>如何工作，什么是<i>虚拟内存</i>以及页面如何解决分段问题。 我们还探讨了x86_64体系结构中的多级页表的方案。 <br><br> 该博客发布在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a> 。 如果您有任何疑问或问题，请在此处打开相应的请求。 <br><a name="habracut"></a><br><h1> 记忆保护 </h1><br> 操作系统的主要任务之一是将程序彼此隔离。 例如，浏览器不应干扰文本编辑器。 有多种方法，具体取决于硬件和操作系统的实现。 <br><br> 例如，某些ARM Cortex-M处理器（在嵌入式系统中）具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>一个内存保护单元</i></a> （MPU），该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>保护单元</i></a>定义了少量（例如8个）具有不同访问权限（例如，无访问权限，只读，只读和只读）的内存区域。记录）。 每次访问内存时，MPU都会确保该地址位于具有正确权限的区域中，否则会引发异常。 通过更改范围和访问权限，操作系统确保每个进程只能访问其内存，以使进程彼此隔离。 <br><br> 在x86上，支持两种不同的保护内存的方法： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分段</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分页</a> 。 <br><br><h1> 细分 </h1><br> 分段于1978年实施，最初是为了增加可寻址内存的数量。 当时，CPU仅支持16位地址，这将可寻址内存量限制为64 KB。 为了增加容量，引入了附加的段寄存器，每个段寄存器都包含一个偏移地址。  CPU会在每次访问内存时自动添加此偏移量，从而寻址多达1 MB的内存。 <br><br>  CPU根据存储器访问的类型自动选择一个段寄存器： <code>CS</code>代码段寄存器用于接收指令，而<code>SS</code>堆栈段寄存器用于堆栈操作（推入/弹出）。 其他指令使用<code>DS</code>数据段寄存器或可选的<code>ES</code>段寄存器。 后来，添加了两个额外的段寄存器<code>FS</code>和<code>GS</code>供免费使用。 <br><br> 在分段的第一个版本中，寄存器直接包含偏移量，并且未执行访问控制。 随着<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">保护模式</a></i>的出现<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a></i>机制已经发生了变化。 当CPU在这种模式下运行时，段描述符将索引存储在本地或全局描述符表中，该表除偏移地址外还包含段大小和访问权限。 通过为每个进程加载单独的全局/本地描述符表，操作系统可以将进程彼此隔离。 <br><br> 通过在实际访问之前更改内存地址，分段实现了一种现在几乎在所有地方都使用的方法：它是<i>虚拟内存</i> 。 <br><br><h3> 虚拟记忆体 </h3><br> 虚拟内存的想法是从物理设备中提取内存地址。 代替直接访问存储设备，首先执行转换步骤。 在分段的情况下，活动段的偏移地址在转换阶段添加。 想象一个程序在一个偏移量为<code>0x1111000</code>的段中访问内存地址<code>0x1111000</code> ：实际上，该地址为<code>0x2345000</code> 。 <br><br> 为了区分两种类型的地址，转换前的地址称为<i>虚拟</i> ，转换后的地址称为<i>物理</i> 。 它们之间有一个重要的区别：物理地址是唯一的，并且始终引用内存中相同的唯一位置。 另一方面，虚拟地址取决于翻译功能。 两个不同的虚拟地址可能会引用相同的物理地址。 另外，相同的虚拟地址可以在转换后引用不同的物理地址。 <br><br> 有效使用此属性的一个示例是两次并行启动同一程序： <br><br><img src="https://habrastorage.org/webt/qm/zz/nz/qmzznz4rei5d-xxygzcabu2latw.png"><br><br> 在这里，同一程序运行两次，但转换功能不同。 第一个实例的段偏移量为100，因此其虚拟地址0-150转换为物理地址100-250。 第二个实例的偏移量为300，它将虚拟地址0-150转换为物理地址300-450。 这允许两个程序执行相同的代码并使用相同的虚拟地址，而不会互相干扰。 <br><br> 另一个优点是现在程序可以放在物理内存上的任意位置。 因此，OS使用了全部可用内存，而无需重新编译程序。 <br><br><h3> 碎片化 </h3><br> 虚拟地址和物理地址之间的差异是分段的真正成果。 但是有一个问题。 想象一下，我们想运行上面看到的程序的第三个副本： <br><br><img src="https://habrastorage.org/webt/rr/np/1m/rrnp1m95lefyki9vwhnwe4uocom.png"><br><br> 尽管物理内存中的空间已绰绰有余，但第三个副本无法容纳在任何地方。 问题在于他需要<i>连续</i>的内存片段，而我们不能使用单独的空闲部分。 <br><br> 解决碎片的一种方法是暂停程序执行，将内存的已使用部分彼此靠近，更新转换，然后恢复执行： <br><br><img src="https://habrastorage.org/webt/hd/rm/zo/hdrmzooae2xt4huangnbzebq3o0.png"><br><br> 现在有足够的空间启动第三个实例。 <br><br> 这种碎片整理的缺点是需要复制大量内存，从而降低了性能。 必须定期执行此过程，直到内存碎片过多。 性能变得不可预测，程序会随时停止并且可能会停止响应。 <br><br> 分段是大多数系统中未使用分段的原因之一。 实际上，即使在x86上的64位模式下也不再支持它。 代替分段，使用页面来完全消除分段问题。 <br><br><h1> 页面的内存组织 </h1><br> 这个想法是将虚拟和物理内存的空间分成固定大小的小块。 虚拟内存块称为页面，物理地址空间块称为帧。 每个页面分别映射到一个框架，这使您可以在不相邻的物理框架之间划分较大的内存区域。 <br><br> 如果您使用片段化的内存空间重复该示例，则优点变得显而易见，但是这次使用页面而不是分段： <br><br><img src="https://habrastorage.org/webt/29/rg/95/29rg95blzryjql4qjy_txkbx2uo.png"><br><br> 在此示例中，页面大小为50个字节，即，每个存储区域都分为三个页面。 每个页面都映射到单独的帧，因此虚拟内存的连续区域可以映射到隔离的物理帧。 这使您可以在不进行碎片整理的情况下运行程序的第三个实例。 <br><br><h3> 隐藏的碎片 </h3><br> 与分段相比，分页组织使用许多小的固定大小的内存区域，而不是几个大的可变大小的区域。 每个帧的大小相同，因此不可能由于帧太小而造成碎片。 <br><br> 但这只是一种<i>现象</i> 。 实际上，存在一种隐藏的碎片形式，即所谓的<i>内部碎片</i> ，这是因为并非每个内存区域都恰好是页面大小的倍数。 想象一下在上面的示例中，一个大小为101的程序：它仍将需要三个大小为50的页面，因此它将比您需要的多49个字节。 为了清楚起见，由于分段而导致的分段称为<i>外部分段</i> 。 <br><br> 内部碎片并没有什么好处，但是通常它比外部碎片要少。 仍然会消耗额外的内存，但是现在您不需要对其进行碎片整理，并且碎片量是可以预测的（平均每个内存区域半页）。 <br><br><h3> 页表 </h3><br> 我们看到，数百万个可能的页面中的每一个都分别映射到一个框架。 该地址转换信息需要存储在某处。 分段时，每个活动存储区都使用单独的分段寄存器，这在分页的情况下是不可能的，因为它们比寄存器多得多。 相反，它使用称为<i>页表</i>的结构。 <br><br> 对于上面的示例，表将如下所示： <br><br><img src="https://habrastorage.org/webt/ij/g0/93/ijg093nmmxzlvn8fkj3n2fxvujg.png"><br><br> 如您所见，程序的每个实例都有其自己的页表。 指向当前活动表的指针存储在CPU的特殊寄存器中。 在<code>x86</code>它称为<code>CR3</code> 。 在启动程序的每个实例之前，操作系统必须在此处加载指向正确页表的指针。 <br><br> 每次访问存储器时，CPU都会从寄存器中读取表指针，并在表中搜索相应的帧。 这是一个完全硬件功能，对于正在运行的程序完全透明地运行。 为了加快处理速度，许多处理器体系结构都有一个特殊的缓存，该缓存可以记住最新转换的结果。 <br><br> 根据体系结构，权限等属性也可以存储在页表的标志字段中。 在上面的示例中， <code>r/w</code>标志使页面可读可写。 <br><br><h3> 分层页表 </h3><br> 简单页表存在较大的地址空间问题：浪费内存。 例如，程序使用四个虚拟页面<code>1_000_050</code>和<code>1_000_100</code> （我们使用<code>_</code>作为数字分隔符）： <br><br><img src="https://habrastorage.org/webt/oh/hc/2d/ohhc2dbnzmw-3qfq1bjmjsksydg.png"><br><br> 仅需要四个物理框架，但是页表中有超过一百万条记录。 我们不能跳过空的条目，因为在转换过程中，CPU将无法直接转到正确的条目（例如，不再保证第四页使用第四条条目）。 <br><br> 为了减少内存丢失，您可以使用<b>两级组织</b> 。 这个想法是我们在不同的区域使用不同的表。 另一个表称为<i>第二级</i>页表，它在地址区域和第一级页表之间进行转换。 <br><br> 最好通过示例来解释。 我们定义每个1级页表负责一个大小为<code>10_000</code>的区域。 然后在上面的示例中，将存在以下表格： <br><br><img src="https://habrastorage.org/webt/7w/3s/qk/7w3sqkqe6zbpna2z4kcnsxqokco.png"><br><br> 页0属于<code>10_000</code>字节的第一个区域，因此它将使用第二级页表中的第一条记录。 该条目指向第一级T1页面表，该表确定页面0引用帧0。 <br><br> 页<code>1_000_000</code>和<code>1_000_100</code>属于<code>1_000_100</code>的第100个字节区域，因此它们使用第2级页表的第100条记录，该记录指向另一个第一级表T2，该表将三页转换为帧<code>10_000</code>和200。第一级的表中的页面地址不包含区域偏移，因此，例如，页面<code>1_000_050</code>的记录仅为<code>50</code> 。 <br><br> 我们在第二级表中仍然有100个空条目，但这比前一百万个少得多。 节省的原因是，您不需要为<code>10_000</code>到<code>1_000_000</code>之间<code>10_000</code>内存区域创建第一级页表。 <br><br> 两级表的原理可以扩展到三级，四级或更多级。 通常，这样的系统称为<i>多级</i>或<i>分层</i>页表。 <br><br> 了解了页面组织和多级表之后，您可以看到如何在x86_64体系结构中实现页面组织（我们假定处理器以64位模式工作）。 <br><br><h1>  x86_64上的页面组织 </h1><br>  x86_64体系结构使用页面大小为4 KB的四级表。 无论级别如何，每个页表都有512个元素。 每个记录的大小为8个字节，因此表的大小为512×8字节= 4 KB。 <br><br><img src="https://habrastorage.org/webt/tp/o9/x-/tpo9x-ibzvx7spvyvspck7_rtrq.png"><br><br> 如您所见，每个表索引包含9位，这很有意义，因为表具有2 ^ 9 = 512个条目。 最低的12位是4 KB页面偏移量（2 ^ 12字节= 4 KB）。 第48到64位被丢弃，因此x86_64实际上不是64位系统，而仅支持48位地址。 已经计划通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5级页表</a>将地址大小扩展到57位，但是尚未创建这种处理器。 <br><br> 尽管丢弃了位48至64，但不能将其设置为任意值。 该范围内的所有位都必须是位47的副本，以保留唯一的地址并允许将来扩展到例如5级页表。 这被称为符号扩展，因为它与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">附加代码中的符号扩展</a>非常相似。 如果地址扩展不正确，则CPU会引发异常。 <br><br><h3> 转换范例 </h3><br> 让我们看一个地址转换如何工作的示例： <br><br><img src="https://habrastorage.org/webt/zj/ox/fe/zjoxfeno1sahwas8h-ffyxechgm.png"><br><br> 级别4页面的当前活动页面表的物理地址（即该级别页面的页面根表）存储在<code>CR3</code> 。 然后，每个页表条目都指向下一级表的物理框架。 一级表条目指示显示的帧。 请注意，页表中的所有地址都是物理地址而不是虚拟地址，因为否则CPU将需要转换这些地址（这可能导致无限递归）。 <br><br> 上面的层次结构转换了两个页面（蓝色）。 从索引中，我们可以得出结论，这些页面的虚拟地址为<code>0x803fe7f000</code>和<code>0x803FE00000</code> 。 让我们看看当程序尝试读取地址<code>0x803FE7F5CE</code>内存时会发生什么。 首先，将地址转换为二进制并确定页表索引和地址的偏移量： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/d08/367/600d08367d49e110f1852796c23f9754.png"><br><br> 使用这些索引，我们现在可以遍历页表的层次结构并找到相应的框架： <br><br><ul><li> 从<code>CR3</code>读取第四级表的地址。 </li><li> 第四级的索引为1，因此我们在此表中查看索引为1的记录。 她说，第3级表存储为16 KB。 </li><li> 我们从该地址加载第三级表，并查看索引为0的记录，该索引指向24 KB的第二级表。 </li><li> 第二级的索引是511，因此我们正在寻找该页面上的最后一条记录，以找出第一级表的地址。 </li><li> 从第一级表中索引为127的记录中，我们最终发现该页面对应于一个12 KB帧或十六进制格式的0xc000。 </li><li> 最后一步是向帧地址添加偏移量以获得物理地址：0xc000 + 0x5ce = 0xc5ce。 </li></ul><br><img src="https://habrastorage.org/webt/mo/iq/-g/moiq-grelw6eyagqsuygebpugkm.png"><br><br> 对于第一级表中的页面，指定了<code>r</code>标志，即，仅允许读取。 如果我们尝试在硬件级别记录，则会在硬件级别引发异常。 较高级表的权限扩展到较低级，因此，如果我们在第三级上设置了只读标志，那么即使在该处指示了允许写入的标志，也不会写入任何后续的较低级页。 <br><br> 尽管此示例仅使用每个表的一个实例，但是通常在每个地址空间中每个级别都有多个实例。 最大值： <br><br><ul><li> 第四层一张桌子 </li><li> 第三级的512个表（由于第四级的表中有512条记录）， </li><li>  512 * 512个第二级表（因为每个第三级表都有512个条目），并且 </li><li> 第一级的512 * 512 * 512个表（第二级的每个表有512条记录）。 </li></ul><br><h3> 页表格式 </h3><br> 在x86_64体系结构中，页表本质上是512个条目的数组。 在Rust语法中： <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(align(4096))]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PageTable</span></span></span></span> { entries: [PageTableEntry; <span class="hljs-number"><span class="hljs-number">512</span></span>], }</code> </pre> <br> 如<code>repr</code>属性所示，表格应在页面上对齐，即4 KB边框。 此要求确保表格始终以最佳方式填充整个页面，从而使条目非常紧凑。 <br><br> 每条记录的大小为8字节（64位），格式如下： <br><br><table><thead><tr><th> 位 </th><th> 职称 </th><th> 价值 </th></tr></thead><tbody><tr><td>  0 </td><td> 现在 </td><td> 内存中的页面 </td></tr><tr><td>  1个 </td><td> 可写的 </td><td> 允许记录 </td></tr><tr><td>  2 </td><td> 用户可访问 </td><td> 如果未设置该位，则只有内核有权访问该页面 </td></tr><tr><td>  3 </td><td> 通过缓存写 </td><td> 直接写入内存 </td></tr><tr><td>  4 </td><td> 禁用缓存 </td><td> 禁用此页面的缓存 </td></tr><tr><td>  5 </td><td> 已访问 </td><td> 使用页面时，CPU将该位置位。 </td></tr><tr><td>  6 </td><td> 脏的 </td><td> 写入页面时，CPU将该位置位 </td></tr><tr><td>  7 </td><td> 大页面/ null </td><td>  P1和P4中的零位在P3中创建1 KB页面，在P2中创建2 MB页面 </td></tr><tr><td>  8 </td><td> 全球性 </td><td> 切换地址空间时，页面未从高速缓存中填充（必须将CR4寄存器的PGE位置1） </td></tr><tr><td>  9-11 </td><td> 可用的 </td><td> 操作系统可以自由使用它们 </td></tr><tr><td>  12-51 </td><td> 实际地址 </td><td> 页或下一页页的页面对齐的52位物理地址 </td></tr><tr><td>  52-62 </td><td> 可用的 </td><td> 操作系统可以自由使用它们 </td></tr><tr><td>  63 </td><td> 不执行 </td><td> 禁止在此页面上执行代码（必须在EFER寄存器中将NXE位置1） </td></tr></tbody></table><br> 我们看到只有位12-51用于存储帧的物理地址，其余位用作标志或可由操作系统自由使用。 这是可能的，因为我们总是指向一个4096字节对齐的地址，或者指向表格的对齐页，或者指向相应帧的开头。 这意味着位0-11始终为零，因此无法存储它们，只需在使用地址之前将它们复位为硬件级别即可。 由于x86_64体系结构仅支持52位物理地址（并且仅支持48位虚拟地址），因此对52-63位也是如此。 <br><br> 让我们仔细看看可用的标志： <br><br><ul><li>  <code>present</code>标志将显示的页面与未显示的页面区分开。 当主内存已满时，它可用于将页面临时保存到磁盘。 下次访问该页面时，将发生特殊的PageFault异常，操作系统通过从磁盘交换页面来响应该异常，该程序继续工作。 </li><li>  <code>writable</code>和<code>no execute</code>标志分别确定页面内容是可写还是包含可执行指令。 </li><li> 读取或写入页面时，处理器会自动设置<code>accessed</code>标志和<code>dirty</code>标志。 操作系统可以使用此信息，例如，它是否交换页面，或者在检查自上次泵入磁盘以来页面的内容是否已更改时。 </li><li> 直<code>write through caching</code>和<code>disable cache</code>标志使您可以分别管理每个页面的缓存。 </li><li>  <code>user accessible</code>标志使页面可从用户空间访问代码，否则它仅对内核可用。 此功能可用于加快<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">系统调用的</a>速度，同时在用户程序运行时维护内核的地址映射。 但是， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spectre</a>漏洞允许程序从用户空间读取这些页面。 </li><li>  <code>global</code>  ,                (.   TLB )     (address space switch).     user <code>accessible</code>        . </li><li>  <code>huge page</code>     ,      2  3     .      512 :     2  = 512 × 4 ,      1  = 512 × 2 .             . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86_64体系结构定义了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页表</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及其</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记录</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的格式</font><font style="vertical-align: inherit;">，因此我们不必自己创建这些结构。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 关联转换缓冲区（TLB） </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于有四个级别，每个地址转换都需要四个内存访问。出于性能原因，x86_64将最后的几个转换缓存在所谓的关联转换缓冲区（TLB）中。如果转换仍在高速缓存中，则可以跳过该转换。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与其他处理器缓存不同，TLB并非完全透明，在更改页表的内容时不会更新或删除转换。这意味着内核在修改页表时必须更新TLB本身。为此，有一条特殊的CPU指令</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>invlpg</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（无效页面），该</font><font style="vertical-align: inherit;">指令</font><font style="vertical-align: inherit;">从TLB中删除指定页面的转换，以便下次从页面表中再次加载该页面时使用。通过重新加载寄存器可以完全清除TLB</font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模拟地址空间切换。</font><font style="vertical-align: inherit;">这两个选项都可以</font><font style="vertical-align: inherit;">通过</font><font style="vertical-align: inherit;">Rust中</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tlb模块</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获得。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要的是不要忘记在每次更改页表之后都清理TLB，否则CPU将继续使用旧的转换，这将导致难以预测的错误，这些错误很难调试。</font></font><br><br><h1> 实作 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们没有提到一件事：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的核心已经支持页面组织</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。文章</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ Rust上的最小内核”中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的引导程序</font><font style="vertical-align: inherit;">已经建立了一个四级层次结构，该层次结构将内核的每个页面映射到一个物理框架，因为在x86_64上64位模式下需要页面组织。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这意味着在我们的核心中，所有内存地址都是虚拟的。在访问VGA缓冲器</font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能工作是因为加载器标识符</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">广播</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前页在存储器中，即对比虚拟页</font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到物理帧</font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多亏了页面组织，内核已经相对安全：超出允许内存的每次访问都会导致页面错误，并且不允许写入物理内存。</font><font style="vertical-align: inherit;">加载程序甚至为每个页面设置正确的访问权限：只有带有代码的页面才是可执行的，只有带有数据的页面才可以写入</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 页面错误（PageFault） </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们尝试通过访问内核外部的内存来调用PageFault。</font><font style="vertical-align: inherit;">首先，创建一个错误处理程序并将其注册到我们的IDT中，以查看特定的异常而不是</font><font style="vertical-align: inherit;">常规类型</font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双重错误</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/interrupts.rs lazy_static! { static ref IDT: InterruptDescriptorTable = { let mut idt = InterruptDescriptorTable::new(); […] idt.page_fault.set_handler_fn(page_fault_handler); // new idt }; } use x86_64::structures::idt::PageFaultErrorCode; extern "x86-interrupt" fn page_fault_handler( stack_frame: &amp;mut ExceptionStackFrame, _error_code: PageFaultErrorCode, ) { use crate::hlt_loop; use x86_64::registers::control::Cr2; println!("EXCEPTION: PAGE FAULT"); println!("Accessed Address: {:?}", Cr2::read()); println!("{:#?}", stack_frame); hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果页面失败，CPU将自动设置case </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>CR2</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它包含导致失败的页面的虚拟地址。要读取并显示此地址，请使用功能</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cr2::read</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。通常，该类型</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PageFaultErrorCode</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会提供有关导致错误的内存访问类型的更多信息，但是由于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误，将传输无效的错误代码，因此我们暂时将忽略此信息。在解决页面错误之前，无法继续执行程序，因此请在末尾插入</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hlt_loop</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以访问内核外部的内存了：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use blog_os::interrupts::PICS; println!("Hello World{}", "!"); // set up the IDT first, otherwise we would enter a boot loop instead of // invoking our page fault handler blog_os::gdt::init(); blog_os::interrupts::init_idt(); unsafe { PICS.lock().initialize() }; x86_64::instructions::interrupts::enable(); // new let ptr = 0xdeadbeaf as *mut u32; unsafe { *ptr = 42; } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动之后，我们看到页面错误处理程序被调用：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/81e/aad/666/81eaad666e7980ce90867ffe3fcb0be3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">寄存器</font></font><code>CR2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上包含了</font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们要访问</font><font style="vertical-align: inherit;">的地址</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前的指令指针是</font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此我们知道该地址指向代码页。</font><font style="vertical-align: inherit;">代码页由只读加载器显示，因此从该地址读取有效，并且写入将导致错误。</font><font style="vertical-align: inherit;">尝试将指针更改</font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Note: The actual address might be different for you. Use the address that // your page fault handler reports. let ptr = 0x20430a as *mut u32; // read from a code page -&gt; works unsafe { let x = *ptr; } // write to a code page -&gt; page fault unsafe { *ptr = 42; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果我们注释掉最后一行，则可以确保阅读有效，并且书写会导致PageFault错误。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 访问页表 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在看一下内核的页表： </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::registers::control::Cr3; let (level_4_page_table, _) = Cr3::read(); println!("Level 4 page table at: {:?}", level_4_page_table.start_address()); […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cr3::read</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from </font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">从</font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">寄存器返回</font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第四级页面</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">当前活动表。回到一对夫妇</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PhysFrame</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cr3Flags</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们只对第一个感兴趣。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动后，我们看到以下结果：</font></font><br><br> <code>Level 4 page table at: PhysAddr(0x1000)</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，目前，第四级页面的活动表存储在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储器中</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的type所指示</font><font style="vertical-align: inherit;">的地址处</font></font><code>PhysAddr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。现在的问题是：如何从内核访问该表？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过页面组织，不可能直接访问物理内存，否则程序将能够轻松绕过保护并获得对其他程序内存的访问权限。因此，获得访问权的唯一方法是通过某个虚拟页面，该页面在以下位置转换为物理帧：</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这是一个典型的问题，因为内核应定期访问页表，例如，在为新线程分配堆栈时。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一篇文章将详细描述该问题的解决方案。现在，让我们只说加载器使用一种称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">递归页表</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的方法</font><font style="vertical-align: inherit;">。虚拟地址空间的最后一页是</font></font><code>0xffff_ffff_ffff_f000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们用它来读取此表中的一些条目：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { let level_4_table_pointer = 0xffff_ffff_ffff_f000 as *const u64; for i in 0..10 { let entry = unsafe { *level_4_table_pointer.offset(i) }; println!("Entry {}: {:#x}", i, entry); } […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已将最后一个虚拟页面的地址减小为的指针</font></font><code>u64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如上一节所述，每个页表条目的大小为8个字节（64位），因此</font></font><code>u64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恰好表示一个条目。使用循环，</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们显示表的前10条记录。在循环内部，我们使用一个不安全的块直接从指针读取并</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code> offset</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算指针。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始后，我们看到以下结果：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/725/8b0/9cb/7258b09cb744af09041bb3a2ee05fd54.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据该格式，如上所述，值</font></font><code>0x2023</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有记录装置标志0 </font></font><code>present</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>writable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>accessed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并翻译成一帧</font></font><code>0x2000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。记录1在该帧中广播，</font></font><code>0x6e2000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且具有相同的标志，再加上</font></font><code>dirty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。条目2–9丢失，因此这些虚拟地址范围未映射到任何物理地址。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用以下类型</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>PageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来</font><font style="vertical-align: inherit;">代替直接使用不安全的指针</font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::structures::paging::PageTable; let level_4_table_ptr = 0xffff_ffff_ffff_f000 as *const PageTable; let level_4_table = unsafe {&amp;*level_4_table_ptr}; for i in 0..10 { println!("Entry {}: {:?}", i, level_4_table[i]); } […] }</span></span></code> </pre> <br>     <code>0xffff_ffff_ffff_f000</code>  ,       Rust.  - ,      ,      .        <code>&amp;PageTable</code> ,        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> . <br><br> <code>x86_64</code>       ,     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/70a/d89/73d/70ad8973d35a531c7ad5943ef5144ef8.png"><br><br>   —      0   1     3.       ,  <code>0x2000</code>  <code>0x6e5000</code>    ,         .       . <br><br><h1> 总结 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文介绍了两种保护内存的方法：分段和页面组织。第一种方法使用可变大小的内存区域并遭受外部碎片的困扰，第二种方法使用固定大小的页面并允许对访问权限进行更精细的控制。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页面组织将页面翻译信息存储在一个或多个级别的表中。 x86_64体系结构使用页面大小为4 KB的四级表。设备自动绕过页表，并将转换结果缓存在关联的转换缓冲区（TLB）中。更改页表时，应强制将其清除。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们了解到我们的核心已经支持页面组织，并且对内存的未授权访问会丢弃PageFault。</font><font style="vertical-align: inherit;">我们试图访问当前活动的页表，但由于页地址存储了物理地址，因此仅访问了第四级表，因此我们无法直接从内核访问它们。</font></font><br><br><h1> 接下来是什么？ </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一篇文章基于我们现在已经了解的基本基础。</font><font style="vertical-align: inherit;">为了从内核访问页表，一种称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">递归页表</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的高级技术</font><font style="vertical-align: inherit;">用于遍历表层次结构并实现程序化地址转换。</font><font style="vertical-align: inherit;">本文还介绍了如何在页表中创建新的翻译。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436606/">https://habr.com/ru/post/zh-CN436606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436594/index.html">再见雪佛兰伏特：充电式混合动力车的故事和传说</a></li>
<li><a href="../zh-CN436596/index.html">实际上，全栈开发人员只能停留在中级水平。 避免遭受痛苦-别走那条路</a></li>
<li><a href="../zh-CN436598/index.html">象棋机迈出的一大步</a></li>
<li><a href="../zh-CN436600/index.html">版权超越和编舞：Fortnite创作者因跳舞游戏角色而被起诉</a></li>
<li><a href="../zh-CN436602/index.html">黎明货运模块：在轨运行20年</a></li>
<li><a href="../zh-CN436608/index.html">[SAP]用于假人的SAPUI5：完整的分步练习</a></li>
<li><a href="../zh-CN436610/index.html">CSS特异性在浏览器中的工作方式</a></li>
<li><a href="../zh-CN436612/index.html">布莱恩·克雷布斯（Brian Krebs）：巨型泄漏帐户数据库，包含2-3年的亿万条记录</a></li>
<li><a href="../zh-CN436614/index.html">特斯拉将在全球范围内减少7％的固定员工</a></li>
<li><a href="../zh-CN436616/index.html">新加坡如何与创新合作：从政府法规到夜总会</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>