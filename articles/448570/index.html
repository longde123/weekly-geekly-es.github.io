<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∞ üöî ü¶Å Estimamos el rendimiento del canal MIMO (se incluye el algoritmo de vertido de agua) ‚¨úÔ∏è üóìÔ∏è üé¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√≥logo 


 En el verano de 2016, de un evento bien conocido, su humilde servidor, entre un grupo de otros estudiantes, pudo asistir a las conferencia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estimamos el rendimiento del canal MIMO (se incluye el algoritmo de vertido de agua)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448570/"><p><img src="https://habrastorage.org/getpro/habr/post_images/0d0/672/437/0d067243758eedce24dc51cb947b5581.jpg"></p><br><h1 id="predislovie">  Pr√≥logo </h1><br><p>  En el verano de 2016, de un evento bien conocido, su humilde servidor, entre un grupo de otros estudiantes, pudo asistir a las conferencias del profesor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Martin Haardt</a> sobre temas de <strong>MIMO</strong> , impartidos por √©l en el marco del programa internacional de maestr√≠a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">"Comunicaci√≥n y procesamiento de se√±ales"</a> .  Pero, desafortunadamente, una semana y media de cada dos me enferm√© bastante y, por lo tanto, varios temas quedaron fuera de mi alcance ... Sin embargo, despu√©s de un tiempo, analizar los conceptos b√°sicos de MIMO se convirti√≥ en mi hobby, no dejar el caso sin terminar. </p><br><p>  Poco a poco, todo esto se ha convertido en una serie de peque√±os <em>seminarios abstractos</em> , que, probablemente, ser√≠a un error no compartir.  Y hoy, en honor <strong>del D√≠a de la Comunicaci√≥n</strong> , me gustar√≠a discutir con ustedes el tema del ancho de banda del canal MIMO, un tema simple, pero que sigue causando ciertas dificultades a los estudiantes (y no solo a los estudiantes). </p><br><p>  Puede parecer a las personas no involucradas que un aumento en el n√∫mero de antenas de recepci√≥n y transmisi√≥n dentro del marco de la tecnolog√≠a mencionada aumenta el ancho de banda del sistema exactamente en la misma cantidad: por ejemplo, si coloca <strong>2</strong> antenas en el lado de recepci√≥n y <strong>2</strong> antenas en el lado de transmisi√≥n (MIMO 2x2), entonces el rendimiento definitivamente aumentar√° definitivamente <strong>2</strong> veces  ¬øPero es esto incluso cierto en teor√≠a?  ¬°Intentemos resolverlo! </p><a name="habracut"></a><br><blockquote>  Puede encontrar una versi√≥n m√°s formal en ingl√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">en el enlace</a> y en mi <a href="" rel="nofollow">repositorio de GitHub</a> . <br>  En este art√≠culo, no consideraremos los problemas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">correlaci√≥n</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">antena</a> y otros problemas de implementaci√≥n.  Nos limitamos a una teor√≠a destilada, para empezar. </blockquote><br><h1 id="model-prinyatogo-signala">  Modelo de se√±al recibida </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/308/f3d/94b/308f3d94b67d28b58f43b6c934fdefd7.png"></p><br><p>  Antes de comenzar a hablar sobre el ancho de banda, primero trataremos la descripci√≥n matem√°tica de <strong>la</strong> se√±al recibida.  Esta parte debe tomarse con mucho cuidado, ya que esta f√≥rmula aportar√° mucho.  Entonces la se√±al recibida se puede representar como: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/4ec/2f2/a114ec2f2cdbad23ee05bedbe4ca698f.svg" alt="\ mathbf {y} = \ sqrt {\ frac {P} {M_T}} \ mathbf {H} \ mathbf {s} + \ mathbf {n} \ qquad (1)"></div><br><p>  donde <img src="https://habrastorage.org/getpro/habr/post_images/d01/0b8/a41/d010b8a414d72f3ae43997a3a0c383db.svg" alt="P">  - potencia del transmisor, <img src="https://habrastorage.org/getpro/habr/post_images/790/f98/5f1/790f985f11719c2994f91faf218ad311.svg" alt="M_T">  - n√∫mero de antenas transmisoras, <img src="https://habrastorage.org/getpro/habr/post_images/704/f4d/c83/704f4dc83e43715dbca37e74095e21fd.svg" alt="\ mathbf {s}">  - caracteres transmitidos <img src="https://habrastorage.org/getpro/habr/post_images/0c8/028/7f3/0c80287f3b7d3378c2e2c69a374282d7.svg" alt="\ mathbf {n}">  - ruido aditivo, y <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  - matriz de coeficientes de transmisi√≥n del canal (de hecho, el proceso de desvanecimiento). </p><br><p>  La se√±al transmitida tambi√©n se puede pintar con un poco m√°s de detalle: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/0f5/eb0/3990f5eb08f290f19a1288c2c5772792.svg" alt="s_i = \ gamma_i d_i \ quad i = 1,2, .. M_T \ qquad (2)"></div><br><p>  donde <img src="https://habrastorage.org/getpro/habr/post_images/1bb/7b2/fbc/1bb7b2fbccba41b76c9d4173d75920a6.svg" alt="di">  - una de las se√±ales de informaci√≥n ( <img src="https://habrastorage.org/getpro/habr/post_images/3da/909/c1e/3da909c1e9bfc42a2d72c4cb9eaf46cd.svg" alt="E \ {\ mathbf {d} \ mathbf {d} ^ H \} = M_T">  ) y <img src="https://habrastorage.org/getpro/habr/post_images/c81/04b/c49/c8104bc49b2fd2a61cc8b9299bc02b3d.svg" alt="\ gamma_i">  - amplificaci√≥n de un cierto camino de propagaci√≥n de una onda EM (ganancia de camino). </p><br><p>  <u>Digamos cu√°l es el refuerzo del camino:</u> <br>  Fortalecer el camino de propagaci√≥n (o el peso de la antena) significa la distribuci√≥n de la potencia de salida proporcional a la "fuerza" de un camino particular.  En otras palabras, queremos asignar m√°s potencia para los buenos canales (rutas de propagaci√≥n) y menos energ√≠a para los malos canales. </p><br><p>  Los pesos de las antenas est√°n limitados por el n√∫mero de antenas de transmisi√≥n: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/3c5/de0/cbb3c5de0a1de4ab81447d7e251f85a4.svg" alt="\ sum ^ r_ {i = 1} \ gamma_i = M_T \ qquad (3)"></div><br><p>  donde <img src="https://habrastorage.org/getpro/habr/post_images/cd2/a49/a17/cd2a49a1779b4e360712e1013ed124a7.svg" alt="r">  Es el <strong>rango de la</strong> matriz del canal. </p><br><p>  Hablando de esto √∫ltimo. </p><br><p>  Dimensi√≥n de la matriz <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  hace las paces <img src="https://habrastorage.org/getpro/habr/post_images/043/a05/2ed/043a052edaf7736764222d480a9bdf44.svg" alt="M_R \ veces M_T">  donde <img src="https://habrastorage.org/getpro/habr/post_images/e8c/d2b/287/e8cd2b287c02798716d1728e3080ebeb.svg" alt="M_R">  - n√∫mero de antenas receptoras. <br>  Para varias mediciones de tiempo, el canal se ver√° as√≠: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6fb/9e2/0c2/6fb9e20c2a79856e2d952dd1897813ec.png"></p><br><blockquote>  <strong>Para referencia:</strong> <br>  Tal vez para c√°lculos y modelos m√°s complejos desee utilizar una de las herramientas m√°s populares para eso: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">MatLab</a> .  En este caso, vale la pena considerar que all√≠ se usa una estructura de datos ligeramente diferente: las filas son medidas de tiempo (instant√°neas), el n√∫mero de columnas corresponde al n√∫mero de antenas de transmisi√≥n <img src="https://habrastorage.org/getpro/habr/post_images/790/f98/5f1/790f985f11719c2994f91faf218ad311.svg" alt="M_T">  , la dimensi√≥n lateral corresponde a <img src="https://habrastorage.org/getpro/habr/post_images/e8c/d2b/287/e8cd2b287c02798716d1728e3080ebeb.svg" alt="M_R">  . </blockquote><p>  La f√≥rmula (1) se puede adaptar f√°cilmente para casos especiales de MIMO. </p><br><p>  <strong>MISO</strong> ( <strong>M√∫ltiple</strong> Entrada Entrada Salida - varias antenas de transmisi√≥n y una de recepci√≥n): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/faa/99b/800/faa99b80083c385e9efcec4c39e135b9.svg" alt="y = \ sqrt {\ frac {P} {M_T}} \ mathbf {h} \ mathbf {s} + n \ qquad (4)"></div><br><p>  donde <img src="https://habrastorage.org/getpro/habr/post_images/e0b/43a/394/e0b43a394e4da4c710d883c2040a101f.svg" alt="\ mathbf {h}">  Es un vector <img src="https://habrastorage.org/getpro/habr/post_images/198/8ce/bbb/1988cebbb6865548743db331b96b8691.svg" alt="1 \ veces M_T">  . </p><br><p>  <strong>SIMO</strong> (SINGLE Single <strong>M</strong> Ultiple <strong>O</strong> utput - varias antenas de recepci√≥n y una antena de transmisi√≥n): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/4ce/713/1d44ce713b6479b18db31b6eea465139.svg" alt="y = \ sqrt {P} \ mathbf {h} s + \ mathbf {n} \ qquad (5)"></div><br><p>  donde <img src="https://habrastorage.org/getpro/habr/post_images/e0b/43a/394/e0b43a394e4da4c710d883c2040a101f.svg" alt="\ mathbf {h}">  Es un vector <img src="https://habrastorage.org/getpro/habr/post_images/255/44a/e75/25544ae75110da1c6751c23ef7057e7d.svg" alt="M_R \ veces 1"></p><br><p>  <strong>SISO</strong> (SINGLE SINGLE SINGLE <strong>O</strong> utput - una antena en los lados de recepci√≥n y transmisi√≥n): </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dff/17e/6a9/dff17e6a9569811683f776e4e9b87b9a.svg" alt="y = \ sqrt {P} hs + n \ qquad (6)"></div><br><p>  Parece ser simple </p><br><p>  Toda consideraci√≥n adicional se puede dividir en <strong>dos</strong> grandes casos: la informaci√≥n de estado del canal (CSI - informaci√≥n de estado del canal) es <em>desconocida para el</em> transmisor ( <strong>CU</strong> - Canal desconocido) y la informaci√≥n del estado del canal es <em>conocida por el</em> transmisor ( <strong>CK</strong> - Canal conocido). </p><br><p>  Arriba, examinamos el caso cuando el canal es <strong>desconocido</strong> para el transmisor ( <strong>caso de bucle abierto</strong> , transmisi√≥n sin retroalimentaci√≥n).  En otras palabras, debido a la falta de informaci√≥n necesaria, no podemos elegir ninguna direcci√≥n efectiva y, por lo tanto, seguimos el camino m√°s simple: transmitimos la misma potencia a trav√©s de todas las antenas (caminos, caminos de propagaci√≥n).  Por lo tanto, la ganancia de cada ganancia de ruta es <strong>1</strong> : </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/f6d/75b/39ef6d75b2d7666174e1f1570c433b07.svg" alt="\ gamma_i = 1, \ quad i = 1,2, .. M_T \ qquad (7)"></div><br><p>  Sin embargo, repetimos: queremos asignar <strong>m√°s</strong> potencia para los <strong>buenos</strong> canales (rutas de propagaci√≥n) y <strong>menos</strong> energ√≠a para los <strong>malos</strong> canales. </p><br><p>  Surge la pregunta: <u>¬øc√≥mo distribuir efectivamente el poder?</u> </p><br><p>  Si <strong>se conoce</strong> el canal ( <strong>caso de bucle cerrado</strong> , con retroalimentaci√≥n), podemos usar escenarios de transmisi√≥n avanzados con algunos algoritmos de procesamiento de se√±al adicionales.  Por ejemplo, con enfoques lineales como <em>precodificaci√≥n</em> y <strong>postprocesamiento</strong> . </p><br><p>  Entenderemos lo que significan los dos √∫ltimos t√©rminos. </p><br><p>  Si tenemos <strong>CSI</strong> en el lado de transmisi√≥n, es decir  matriz <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  , podemos procesar matem√°ticamente esta misma matriz.  Por ejemplo, aplicando el algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">SVD</a> (Descomposici√≥n de valor singular). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6bb/95a/fd3/6bb95afd35a66bb0b6421818b985d561.png"></p><br><p>  Tenga en cuenta que la matriz <img src="https://habrastorage.org/getpro/habr/post_images/1da/072/a41/1da072a419fecc8ecc89c0fa5f6fcd6d.svg" alt="\ mathbf {\ Sigma}">  Es una matriz diagonal, y los elementos de su diagonal (valores singulares) son, en esencia, coeficientes de transmisi√≥n de rutas de propagaci√≥n √∫nicas.  En otras palabras, si logramos la multiplicaci√≥n de nuestra se√±al por una matriz de valores singulares <img src="https://habrastorage.org/getpro/habr/post_images/1da/072/a41/1da072a419fecc8ecc89c0fa5f6fcd6d.svg" alt="\ mathbf {\ Sigma}">  en lugar de canal completo <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  , entonces el canal <strong>MIMO</strong> se descompondr√° en una matriz de canales <strong>SISO</strong> paralelos. </p><br><p>  Entonces la matriz de precodificaci√≥n lineal (filtro) debe ser <img src="https://habrastorage.org/getpro/habr/post_images/0dc/438/f04/0dc438f04dcae00f8f6be6e90cc305d7.svg" alt="\ mathbf {F} = \ mathbf {V} _s">  , y la matriz de postprocesamiento lineal (demodulador) <img src="https://habrastorage.org/getpro/habr/post_images/7d4/715/f1a/7d4715f1a45bb371053c241af4f13904.svg" alt="\ mathbf {D} = \ mathbf {U} ^ H_s">  ( <em>H</em> significa conjugaci√≥n hermitiana). </p><br><blockquote>  Obviamente, para el caso con un canal desconocido <img src="https://habrastorage.org/getpro/habr/post_images/262/9d2/195/2629d21955e2a9cd73b9be24a5a947eb.svg" alt="\ mathbf {F}">  y <img src="https://habrastorage.org/getpro/habr/post_images/21b/7c1/06d/21b7c106daa35c36f96c5ae499233ec0.svg" alt="\ mathbf {D}">  matrices de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">identidad</a> igual. </blockquote><p>  Ahora, sabiendo todo lo anterior, redefinimos el modelo de la se√±al recibida: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38b/56d/23d/38b56d23d403a6a8910ad66923db4118.svg" alt="\ mathbf {Dy} = \ mathbf {D} \ left (\ sqrt {\ frac {P} {M_t}} \ mathbf {H} \ mathbf {F} \ mathbf {s} + \ mathbf {n} \ right) = \ mathbf {U} ^ H_s \ mathbf {y} = \ sqrt {\ frac {P} {M_t}} \ mathbf {U} ^ H_s \ mathbf {H} \ mathbf {V} _s \ mathbf {s} + \ mathbf {U} ^ H_s \ mathbf {n} = \ sqrt {\ frac {P} {M_t}} \ mathbf {\ Sigma} _s \ mathbf {s} + \ mathbf {\ hat {n}} = \ mathbf {\ hat {y}} \ qquad (8)"></div><br><p>  Tenga en cuenta que: </p><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/feb/dae/d36/febdaed369cb465bf821b996e5e5cb61.svg" alt="\ mathbf {\ hat {n}}">  tiene las mismas propiedades estad√≠sticas que <img src="https://habrastorage.org/getpro/habr/post_images/0c8/028/7f3/0c80287f3b7d3378c2e2c69a374282d7.svg" alt="\ mathbf {n}">  ; </li><li>  Valores propios <img src="https://habrastorage.org/getpro/habr/post_images/bff/f9f/d6d/bfff9fd6d698c1d0e8011e5f9a9c6585.svg" alt="\ mathbf {HH} ^ H">  son los cuadrados de los valores singulares de la matriz de canales <img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}">  ( <img src="https://habrastorage.org/getpro/habr/post_images/5d9/204/19e/5d920419e86666fa5a5de6669e965466.svg" alt="\ sigma_i = \ sqrt {\ lambda_i}">  ) </li></ul><br><p>  Esquem√°ticamente, esto se puede representar como: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/e66/ce5/f41/e66ce5f41bd4d57670aad51ad5409adc.png" alt="sch" width="500" height="600"><br><p>  <em>Fig.</em>  <em>1. El esquema de precodificaci√≥n y postprocesamiento [1, p.67].</em> </p><br><img src="https://habrastorage.org/getpro/habr/post_images/072/138/b29/072138b29e56f44939c260426c564153.png" alt="paralizar" width="500" height="600"><br><p>  <em>Fig.</em>  <em>2. Esquema de descomposici√≥n modal</em> <em><img src="https://habrastorage.org/getpro/habr/post_images/e79/cb6/ae8/e79cb6ae8d0e454f94b42ad408308b72.svg" alt="\ mathbf {H}"></em>  <em>cuando el canal es conocido por el transmisor y el receptor [1, p.67].</em> </p><br><p>  Los conceptos b√°sicos se desarman: ¬°podemos pasar directamente al <strong>ancho de banda</strong> ! </p><br><h1 id="propusknaya-sposobnost-capacity">  Capacidad </h1><br><p>  Creo que todos los que estudiaron la <strong>teor√≠a de la informaci√≥n</strong> recuerdan que el t√©rmino ancho de banda nos lleg√≥ de esta disciplina en particular.  Por lo general (en mi edad de estudiante), la consideraci√≥n se centr√≥ en el caso cl√°sico del canal AWGN, pero la f√≥rmula se puede derivar con relativa facilidad para el caso de un canal MIMO con desvanecimiento. </p><br><blockquote>  Para no volver a escribir los c√°lculos de los libros, trat√© de organizar todo m√°s o menos colorido y a mano, para dar f√≥rmulas de vida, por as√≠ decirlo.  Espero que este formato sea menos tedioso. </blockquote><p>  Entonces, una vez m√°s, escribimos el modelo de se√±al: </p><br><img src="https://habrastorage.org/webt/rh/x_/gc/rhx_gc1lr_rmqj6eaeewoewhvce.png"><br><p>  Ahora pasemos a determinar el rendimiento a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">la informaci√≥n mutua</a> . </p><br><img src="https://habrastorage.org/webt/40/rb/cf/40rbcfuupxwyyx0ztm58nhubpqc.png"><br><p>  Escribimos la matriz de autocovarianza de la se√±al recibida y sus componentes: </p><br><img src="https://habrastorage.org/webt/hd/ke/nz/hdkenzy3rhhgoysafzwopgnij7u.png"><br><p>  Y los usamos para determinar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">entrop√≠a diferencial</a> : </p><br><img src="https://habrastorage.org/webt/ev/cj/mm/evcjmmt0qlyjudk_7xqn2ldimec.png"><br><p>  Sustituya (4) y (5) en (2): </p><br><img src="https://habrastorage.org/webt/ww/ud/gd/wwudgdbvqd6orus-tfnp3azhly0.png"><br><p>  Y ahora sustituimos (6) en (1): </p><br><img src="https://habrastorage.org/webt/2i/3c/p4/2i3cp4tj0nf_4s-rnistbmcw0rm.png"><br><p>  Seguimos razonando.  Tome el primer caso: el canal es desconocido ( <strong>C</strong> hannel <strong>U</strong> desconocido).  Esto significa para nosotros que es imposible elegir la direcci√≥n de transmisi√≥n √≥ptima y, por lo tanto, las se√±ales transmitidas ser√°n independientes y tendr√°n la misma potencia (equi- alimentada).  Basado en la condici√≥n m√°xima ( <img src="https://habrastorage.org/getpro/habr/post_images/b55/710/37c/b5571037cdb68260d690fba1e74c122b.svg" alt="Tr \ {\ mathbf {R} _ {ss} \} = M_T">  ), podemos tomar la matriz de autocovarianza de los caracteres transmitidos igual a la matriz de identidad.  Entonces tenemos: </p><br><img src="https://habrastorage.org/webt/nn/bd/_p/nnbd_pjhgqezwomw944_71x0vw4.png"><br><p>  Utilizamos la siguiente propiedad de determinantes: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbb/866/f57/fbb866f57bd5076cb0d56869fe5ecde0.svg" alt="det \ left (\ mathbf {I} _m + \ mathbf {AB} \ right) = det \ left (\ mathbf {I} _n + \ mathbf {BA} \ right)"></div><br><p>  Este es nuestro caso, y podemos intercambiar las matrices para que <img src="https://habrastorage.org/getpro/habr/post_images/698/669/b9e/698669b9ea8fc3b7983608348382cc36.svg" alt="\ mathbf {Q} \ mathbf {Q} ^ H = \ mathbf {I}">  (de las propiedades EVD).  Permanecer√°: </p><br><img src="https://habrastorage.org/webt/pk/no/dq/pknodqpt0rpcbvfp0z9eisl7imq.png"><br><p>  Pasando de matrices a sumas, tenemos: </p><br><img src="https://habrastorage.org/webt/u_/gm/k9/u_gmk95fp05y8obm7odpf-wo2lq.png" width="600"><br><p>  Esta f√≥rmula nuevamente ilustra el enfoque de considerar MIMO como canales SISO paralelos. <br>  Para el caso con el canal conocido ( <strong>C</strong> hannel <strong>K</strong> nown), los pesos de la antena se agregar√°n a la f√≥rmula: </p><br><img src="https://habrastorage.org/webt/vr/ht/bl/vrhtblex4vq8soaxqoa1tokmmre.png"><br><p>  Tambi√©n escribimos f√≥rmulas para casos especiales: </p><br><img src="https://habrastorage.org/webt/y-/f5/7y/y-f57yb-4yc4-yeegeblpmr6-hy.png"><br><blockquote>  <strong>Nota</strong> : <br>  Para los casos de <strong>SIMO</strong> y <strong>MISO, no es</strong> en vano que los cuadrados de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">norma Frobenius</a> aparezcan en el registro <img src="https://habrastorage.org/getpro/habr/post_images/c16/a79/bd1/c16a79bd16d4f7febf57f4dc4cefd303.svg" alt="|| \ mathbf {h} || _F ^ 2">  - desde un punto de vista matem√°tico, son equivalentes a valores propios <img src="https://habrastorage.org/getpro/habr/post_images/f99/9f8/c65/f999f8c65e413f78334f6f3db0a438a6.svg" alt="\ mathbf {h} \ mathbf {h} ^ H">  .  Por lo tanto, si necesita calcular r√°pidamente algo a mano, aqu√≠ hay una manera. </blockquote><p>  Bueno, espero que mi letra y mi ingl√©s no interfieran mucho con la percepci√≥n de la informaci√≥n, pero a√∫n as√≠, hablemos del punto <strong>principal</strong> : </p><br><ul><li>  S√≠, el ancho de banda del canal <strong>MIMO</strong> puede considerarse como la <strong>suma del</strong> ancho de banda de los canales <strong>SISO</strong> . </li><li>  Sin embargo, esta cantidad est√° limitada por el <strong>rango del</strong> canal. </li></ul><br><h2 id="algoritm-water-pouring">  Algoritmo de vertido de agua </h2><br><p>  Como se puede ver en la f√≥rmula de ancho de banda conocida en el lado de transmisi√≥n del canal (CK - Canal conocido), la distribuci√≥n de energ√≠a sobre las antenas se puede optimizar.  Para hacer esto, utilizamos el algoritmo de vertido de agua ( <em>llenado con agua</em> ) [1, p. 68-69]: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> linalg <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> LA <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waterpouring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mt, SNR_dB, H_chan)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) r = LA.matrix_rank(H_chan) H_sq = np.dot(H_chan,np.matrix(H_chan, dtype=complex).H) lambdas = LA.eigvals(H_sq) lambdas = np.sort(lambdas)[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] p = <span class="hljs-number"><span class="hljs-number">1</span></span>; gammas = np.zeros((r,<span class="hljs-number"><span class="hljs-number">1</span></span>)) flag = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> flag == <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: lambdas_r_p_1 = lambdas[<span class="hljs-number"><span class="hljs-number">0</span></span>:(r-p+<span class="hljs-number"><span class="hljs-number">1</span></span>)] inv_lambdas_sum = np.sum(<span class="hljs-number"><span class="hljs-number">1</span></span>/lambdas_r_p_1) mu = ( Mt / (r - p + <span class="hljs-number"><span class="hljs-number">1</span></span>) ) * ( <span class="hljs-number"><span class="hljs-number">1</span></span> + (<span class="hljs-number"><span class="hljs-number">1</span></span>/SNR) * inv_lambdas_sum) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(lambdas_r_p_1): gammas[idx] = mu - (Mt/(SNR*item)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gammas[rp] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">#due to Python starts from 0 gammas[rp] = 0 #due to Python starts from 0 p = p + 1 else: flag = False res = [] for gamma in gammas: res.append(float(gamma)) return np.array(res)</span></span></code> </pre> <br><p>  Prueba: </p><br><pre> <code class="python hljs">Mt = <span class="hljs-number"><span class="hljs-number">3</span></span> SNR_db = <span class="hljs-number"><span class="hljs-number">10</span></span> H_chan = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>],[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]], dtype = float) gammas = waterpouring(Mt, SNR_db, H_chan) print(<span class="hljs-string"><span class="hljs-string">'Rank of the matrix: '</span></span>+str(LA.matrix_rank(H_chan))) print(<span class="hljs-string"><span class="hljs-string">'Gammas:\n'</span></span>+str(gammas)) &gt;&gt;&gt; Rank of the matrix: <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; Gammas: &gt;&gt;&gt; [<span class="hljs-number"><span class="hljs-number">1.545</span></span> <span class="hljs-number"><span class="hljs-number">1.455</span></span>]</code> </pre> <br><p>  Bueno, parece razonable: <br>  1) el n√∫mero de antenas de transmisi√≥n involucradas es igual al <strong>rango del</strong> canal; <br>  2) la suma de los <strong>pesos de las</strong> antenas es igual al n√∫mero de antenas de transmisi√≥n. </p><br><h2 id="dva-predelnyh-sluchaya">  Dos casos limitantes </h2><br><p>  Y ahora vamos a distraernos un poco y resolver los problemas de comprensi√≥n. </p><br><p>  Encontremos, por ejemplo, a qu√© ser√°n iguales los coeficientes <img src="https://habrastorage.org/getpro/habr/post_images/c81/04b/c49/c8104bc49b2fd2a61cc8b9299bc02b3d.svg" alt="\ gamma_i">  con SNR tendiendo a <img src="https://habrastorage.org/getpro/habr/post_images/279/496/46c/27949646c03ab2b1b12c79632ddc20bf.svg" alt="+ \ infty">  y <img src="https://habrastorage.org/getpro/habr/post_images/60b/863/8b2/60b8638b28b303b1718d37bee487ac72.svg" alt="- \ infty">  (en una escala logar√≠tmica, por supuesto, porque no hay poderes negativos). </p><br><p>  Recordamos la f√≥rmula de correspondencia entre decibelios y tiempos: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/109/e43/006/109e430066ec30bab3ea15fc12b24b5a.svg" alt="SNR_ {dB} = 10log_ {10} \ left (\ frac {S} {N} \ right)"></div><br><p>  donde <img src="https://habrastorage.org/getpro/habr/post_images/5bf/27c/73c/5bf27c73c71f303844ee4973cab18377.svg" alt="S">  - potencia de la se√±al transmitida (para nuestras tareas, es equivalente a la energ√≠a del s√≠mbolo <img src="https://habrastorage.org/getpro/habr/post_images/072/074/880/072074880bc38a00e1970f944ed4cf99.svg" alt="E_s">  ) y <img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N">  - potencia de ruido (en nuestro problema es igual a la densidad espectral del ruido <img src="https://habrastorage.org/getpro/habr/post_images/69a/ad3/04d/69aad304d9c25b25096b8e1cc83127e0.svg" alt="N_0">  ) </p><br><p>  Entonces en una escala lineal ser√°: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60d/387/38e/60d38738e895ea76af6cc9fcfb1dd0b6.svg" alt="\ frac {E_s} {N_0} \ equiv \ frac {S} {N} = 10 ^ {SNR_ {dB} / 10}"></div><br><p>  Observamos las f√≥rmulas b√°sicas del algoritmo: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/6ee/46c/62a6ee46c3a82d81a5b1bddd0f625ea8.svg" alt="\ mu = \ frac {M_T} {(r-p + 1)} \ left [1 + \ frac {N_0} {E_s} \ sum_ {i = 1} ^ {r-p + 1} \ frac {1} {\ lambda_i} \ right]"></div><br><p>  donde <img src="https://habrastorage.org/getpro/habr/post_images/d76/c4d/c2b/d76c4dc2b17f00a09c864bf2d24ab365.svg" alt="p">  Es un iterador que comienza con 1, <img src="https://habrastorage.org/getpro/habr/post_images/cd2/a49/a17/cd2a49a1779b4e360712e1013ed124a7.svg" alt="r">  Es el rango de la matriz del canal, <img src="https://habrastorage.org/getpro/habr/post_images/4a1/9e2/b6a/4a19e2b6a9b67e2a8e0682126d49684a.svg" alt="\ lambda_i">  - i-√©simo valor propio del "cuadrado" de la matriz del canal.  Los gammas se calculan de acuerdo con la siguiente f√≥rmula: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f5/2eb/aff/4f52ebaffbebeba87ac646dadd57d2cd.svg" alt="\ gamma_i = \ left (\ mu - \ frac {M_TN_0} {E_s \ lambda_i} \ right) \ quad i = 1,2, ..., r-p + 1"></div><br><p>  Comenzamos a razonar: </p><br><p>  Si <img src="https://habrastorage.org/getpro/habr/post_images/734/618/09c/73461809c5cedcf8d9c19312c41a4d7a.svg" alt="SNR_ {dB} \ a + \ infty">  entonces <img src="https://habrastorage.org/getpro/habr/post_images/4ae/0cd/4f4/4ae0cd4f42acfe2e7b83ea1781a19667.svg" alt="\ frac {E_s} {N_0} \ to + \ infty">  .  Por lo tanto <img src="https://habrastorage.org/getpro/habr/post_images/c58/ff3/050/c58ff30508740ab8078825a703e9e651.svg" alt="\ frac {N_0} {E_s} \ a 0">  .  Para la primera iteraci√≥n, permanece: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05a/3a2/84f/05a3a284fd68bd18f8bbcb5608edf314.svg" alt="\ mu = \ frac {M_T} {r}"></div><br><p>  Sustituir a gamma: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/e82/af3/47ee82af3923910da61acce90e57ccc3.svg" alt="\ gamma_i = \ mu = \ frac {M_T} {r} \ quad i = 1,2, ..., r"></div><br><p>  Resumimos: </p><br><p>  Con una energ√≠a de transmisi√≥n infinitamente grande o ruido infinitesimal, no es necesario pensar en nada especial, digamos as√≠: distribuimos uniformemente la potencia entre las antenas de transmisi√≥n (teniendo en cuenta el rango de la matriz del canal). </p><br><p>  Razonamos a√∫n m√°s: </p><br><p>  ¬øY a qu√© tiende el caso de SNR? <img src="https://habrastorage.org/getpro/habr/post_images/60b/863/8b2/60b8638b28b303b1718d37bee487ac72.svg" alt="- \ infty">  ?  Aqu√≠ ni siquiera entraremos en matem√°ticas, razonaremos l√≥gicamente: este caso corresponde a ruido infinitamente grande o potencia de transmisi√≥n cero.  Entonces, de una manera y otra, nuestro sistema, considere, no funciona.  Por lo tanto, la pregunta con gammas desaparece autom√°ticamente ... </p><br><p>  Estas son a veces preguntas que surgen en un examen con un profesor. </p><br><h1 id="schitaem-propusknuyu-sposobnost-nakonec-to">  Contando el rendimiento (¬°finalmente!) </h1><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">siso_capacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(H_chan, SNR_dB)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) c = np.log2(<span class="hljs-number"><span class="hljs-number">1</span></span> + SNR*(np.abs(H_chan)**<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openloop_capacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(H_chan, SNR_dB)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) Mt = np.shape(H_chan)[<span class="hljs-number"><span class="hljs-number">1</span></span>] H_sq = np.dot(H_chan,np.matrix(H_chan, dtype=complex).H) lambdas = LA.eigvals(H_sq) lambdas = np.sort(lambdas)[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] c = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> eig <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lambdas: c = c + np.log2(<span class="hljs-number"><span class="hljs-number">1</span></span> + SNR*eig/Mt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.real(c) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closedloop_capacity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(H_chan, SNR_dB)</span></span></span><span class="hljs-function">:</span></span> SNR = <span class="hljs-number"><span class="hljs-number">10</span></span>**(SNR_dB/<span class="hljs-number"><span class="hljs-number">10</span></span>) Mt = np.shape(H_chan)[<span class="hljs-number"><span class="hljs-number">1</span></span>] H_sq = np.dot(H_chan,np.matrix(H_chan, dtype=complex).H) lambdas = LA.eigvals(H_sq) lambdas = np.real(np.sort(lambdas))[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] c = <span class="hljs-number"><span class="hljs-number">0</span></span> gammas = waterpouring(Mt, SNR_dB, H_chan) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(lambdas): c = c + np.log2(<span class="hljs-number"><span class="hljs-number">1</span></span> + SNR*item*gammas[idx]/Mt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.real(c) Mr = <span class="hljs-number"><span class="hljs-number">4</span></span> Mt = <span class="hljs-number"><span class="hljs-number">4</span></span> H_chan = (np.random.randn(Mr,Mt) \ + <span class="hljs-number"><span class="hljs-number">1j</span></span>*np.random.randn(Mr, Mt))/np.sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">#Rayleigh flat fading c = openloop_capacity(H_chan, 10) print(c) c = closedloop_capacity(H_chan, 10) print(c) c = siso_capacity(H_chan[0,0], 10) print(c) &gt;&gt;&gt; 11.978909197556913 &gt;&gt;&gt; 12.342571770086721 &gt;&gt;&gt; 3.9058582578551193</span></span></code> </pre> <br><p>  Parece funcionar  Pasamos a evaluaciones m√°s sustantivas. </p><br><h2 id="ergodic-capacity">  Capacidad erg√≥dica </h2><br><p>  Como se puede ver en los ejemplos anteriores, trabajamos con procesos aleatorios.  Y, francamente, es un error sacar conclusiones sobre procesos aleatorios en una implementaci√≥n.  Incluso si el canal es <em>constante</em> en el sentido estad√≠stico, es necesario un promedio sobre un conjunto suficientemente grande. </p><br><p>  Aqu√≠ el concepto de <strong>capacidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">erg√≥dica</a></strong> nos <strong>es</strong> √∫til: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/664/e69/cc3664e69c54efa0d98127e7f65bf6ea.svg" alt="\ hat {C} = E \ left \ {C \ right \} \ qquad (9)"></div><br><p>  donde <img src="https://habrastorage.org/getpro/habr/post_images/a73/317/bad/a73317bad2bf7d6419c448e2051efdc9.svg" alt="E \ {* \}">  denota mat.  expectativa (valor esperado). </p><br><p>  Estamos modelando </p><br><pre> <code class="python hljs">Mr = <span class="hljs-number"><span class="hljs-number">4</span></span> Mt = <span class="hljs-number"><span class="hljs-number">4</span></span> counter = <span class="hljs-number"><span class="hljs-number">1000</span></span> SNR_dBs = [i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>)] C_MIMO_CU = np.empty((len(SNR_dBs), counter)) C_MIMO_CK = np.empty((len(SNR_dBs), counter)) C_SISO = np.empty((len(SNR_dBs), counter)) C_SIMO = np.empty((len(SNR_dBs), counter)) C_MISO_CU = np.empty((len(SNR_dBs), counter)) C_MISO_CK = np.empty((len(SNR_dBs), counter)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(counter): H_MIMO = (np.random.randn(Mr,Mt) + <span class="hljs-number"><span class="hljs-number">1j</span></span>*np.random.randn(Mr, Mt))/np.sqrt(<span class="hljs-number"><span class="hljs-number">2</span></span>) H_SISO = H_MIMO[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>] H_SIMO = H_MIMO[:,<span class="hljs-number"><span class="hljs-number">0</span></span>].reshape(Mr,<span class="hljs-number"><span class="hljs-number">1</span></span>) H_MISO = H_MIMO[<span class="hljs-number"><span class="hljs-number">0</span></span>,:].reshape(<span class="hljs-number"><span class="hljs-number">1</span></span>,Mt) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, SNR_dB <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(SNR_dBs): C_MIMO_CU[idx, c] = openloop_capacity(H_MIMO, SNR_dB) C_MIMO_CK[idx, c] = closedloop_capacity(H_MIMO, SNR_dB) C_SISO[idx, c] = siso_capacity(H_SISO, SNR_dB) C_SIMO[idx, c] = openloop_capacity(H_SIMO, SNR_dB) C_MISO_CU[idx, c] = openloop_capacity(H_MISO, SNR_dB) C_MISO_CK[idx, c] = closedloop_capacity(H_MISO, SNR_dB) C_MIMO_CU_erg = np.mean(C_MIMO_CU, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_MIMO_CK_erg = np.mean(C_MIMO_CK, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_SISO_erg = np.mean(C_SISO, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_SIMO_erg = np.mean(C_SIMO, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_MISO_CU_erg = np.mean(C_MISO_CU, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) C_MISO_CK_erg = np.mean(C_MISO_CK, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">600</span></span>) plt.plot(SNR_dBs, C_MIMO_CU_erg,<span class="hljs-string"><span class="hljs-string">'g-o'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=4$, $M_T=4$ (CU)'</span></span>) plt.plot(SNR_dBs, C_MIMO_CK_erg,<span class="hljs-string"><span class="hljs-string">'g-v'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=4$, $M_T=4$ (CK)'</span></span>) plt.plot(SNR_dBs, C_MISO_CU_erg, <span class="hljs-string"><span class="hljs-string">'m-o'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=1$, $M_T=4$ (CU)'</span></span>) plt.plot(SNR_dBs, C_MISO_CK_erg, <span class="hljs-string"><span class="hljs-string">'m-v'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=1$, $M_T=4$ (CK)'</span></span>) plt.plot(SNR_dBs, C_SISO_erg, <span class="hljs-string"><span class="hljs-string">'k-'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=1$, $M_T=1$'</span></span>) plt.plot(SNR_dBs, C_SIMO_erg, <span class="hljs-string"><span class="hljs-string">'c-'</span></span>, label=<span class="hljs-string"><span class="hljs-string">'$M_R=4$, $M_T=1$'</span></span>) plt.title(<span class="hljs-string"><span class="hljs-string">"Ergodic Capacity"</span></span>) plt.xlabel(<span class="hljs-string"><span class="hljs-string">'SNR (dB)'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Capacity (bps/Hz)'</span></span>) plt.legend() plt.minorticks_on() plt.grid(which=<span class="hljs-string"><span class="hljs-string">'major'</span></span>) plt.grid(which=<span class="hljs-string"><span class="hljs-string">'minor'</span></span>, linestyle=<span class="hljs-string"><span class="hljs-string">':'</span></span>) plt.show()</code> </pre> <br><p><img src="https://habrastorage.org/webt/5z/il/br/5zilbr1ijigrduhc3pqpzn7qsuc.png"><br>  <em>Fig.3.</em>  <em>Curvas de ancho de banda para diferentes esquemas de transmisi√≥n.</em>  <em>Comparar con [1, p.</em>  <em>74].</em> </p><br><p>  Entonces vemos que </p><br><ul><li>  Se espera que el caso <strong>MIMO</strong> sea ‚Äã‚Äãsuperior a los dem√°s, y con el aumento de la <strong>SNR, la</strong> necesidad de conocimiento de la matriz del canal disminuye (ver el ejemplo con infinitos). </li><li>  <strong>SIMO es</strong> superior a <strong>MISO</strong> si el transmisor no <em>conoce</em> el canal (la potencia en MISO se comparte en todas las antenas, pero no de manera √≥ptima) y coincide con <strong>MISO</strong> en el caso de un canal <em>conocido</em> . </li><li>  <strong>Se</strong> espera que <strong>SISO</strong> azote la cola. </li></ul><br><p>  Y Su Majestad reina sobre el <strong>rango de la matriz de canales</strong> , lo que no nos permite comparar inequ√≠vocamente el aumento en el n√∫mero de antenas con el aumento en la velocidad de transmisi√≥n. </p><br><p>  Tales cosas </p><br><h2 id="literatura">  Literatura </h2><br><p>  (aunque solo hay un libro, ¬°pero qu√© libro!) </p><br><ol><li>  Paulraj, Arogyaswami, Rohit Nabar y Dhananjay Gore. <br>  Introducci√≥n a las comunicaciones inal√°mbricas espacio-temporales.  Cambridge University Press, 2003. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448570/">https://habr.com/ru/post/448570/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448558/index.html">¬øEs posible renderizar im√°genes realistas sin n√∫meros de punto flotante?</a></li>
<li><a href="../448560/index.html">Plan de transformaci√≥n de IA: ¬øc√≥mo gestionar una empresa en la era de la IA?</a></li>
<li><a href="../448562/index.html">Google ayuda a la polic√≠a a localizar dispositivos cerca de escenas del crimen utilizando datos de ubicaci√≥n</a></li>
<li><a href="../448564/index.html">El primero en el grupo: el primero en caer: evaluaci√≥n de los riesgos de liderazgo en grupos de animales autoorganizados</a></li>
<li><a href="../448568/index.html">C√≥mo implementar ISO 27001: instrucciones de uso</a></li>
<li><a href="../448572/index.html">La comunicaci√≥n humana se est√° convirtiendo en un art√≠culo de lujo.</a></li>
<li><a href="../448574/index.html">Una tarea de la rutina SEO: soluci√≥n de 3 pasos</a></li>
<li><a href="../448580/index.html">CQ CQ CQ ¬°Felices fiestas, radioaficionado! #WorldAmateurRadioDay</a></li>
<li><a href="../448584/index.html">7 errores comunes al usar preposiciones en ingl√©s y c√≥mo evitarlos</a></li>
<li><a href="../448590/index.html">Extra√±os familiares o una vez m√°s sobre el uso de patrones de dise√±o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>