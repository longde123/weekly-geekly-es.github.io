<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏿 👨🏾‍🤝‍👨🏻 👨🏼‍🚀 Einführung in Sass-Module 👩🏻‍🎤 😎 🧕🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die Übersetzung des Artikels „Introducing Sass Modules“ von Miriam Suzanne. 

 Kürzlich wurde in Sass eine Funktion ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in Sass-Module</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471924/"> Hallo Habr!  Ich präsentiere Ihnen die Übersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Introducing Sass Modules“</a> von Miriam Suzanne. <br><br>  Kürzlich wurde in Sass eine Funktion veröffentlicht, die Ihnen in anderen Sprachen bekannt ist: ein <b>modulares System</b> .  Dies ist ein großer Fortschritt für <code>@import</code> , eine der am häufigsten verwendeten Funktionen in Sass.  Trotz der Tatsache, dass Sie mit der vorhandenen <code>@import</code> Direktive Pakete von Drittanbietern verbinden und Ihre Stile in unterstützte Elemente unterteilen können, gibt es immer noch einige Einschränkungen <a name="habracut"></a>  :: <br><br><ul><li>  <code>@import</code> auch in CSS vorhanden, und Unterschiede in ihrem Verhalten können verwirrend sein. </li><li>  Wenn Sie <code>@import</code> mehrmals für eine Datei <code>@import</code> , kann dies die Kompilierung verlangsamen, Neudefinitionskonflikte verursachen und Sie erhalten doppelten Code in der Ausgabe. </li><li>  Alles ist im globalen Bereich, einschließlich Paketen von Drittanbietern - so kann meine Farbfunktion Ihre vorhandene <code>color</code> überschreiben oder umgekehrt. </li><li>  Wenn Sie eine Funktion wie <code>color</code> , ist es unmöglich, genau zu wissen, wo sie definiert ist.  Welcher <code>@import</code> verbunden? </li></ul><br>  Die Autoren von Sass-Paketen (wie ich) haben versucht, Namespace-Probleme zu umgehen, indem sie Präfixe für Variablen und Funktionen manuell festgelegt haben - aber Sass-Module sind eine viel leistungsfähigere Lösung.  Kurz gesagt, <code>@import</code> wird durch explizitere <code>@use</code> und <code>@forward</code> .  In den nächsten Jahren wird <code>@import</code> in Sass nicht mehr unterstützt und dann entfernt.  Sie können weiterhin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>CSS Import</code></a> , diese werden jedoch nicht von Sass kompiliert.  Aber keine Sorge, es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Migrationstool</a> , mit dem Sie ein Upgrade durchführen können. <br><br><h2>  Importieren Sie Dateien mit <code>@use</code> </h2><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>;</code> </pre><br>  Die neue <code>@use</code> ähnelt <code>@import</code> , weist jedoch einige bemerkenswerte Unterschiede auf: <br><br><ul><li>  Die Datei wird einmal importiert, unabhängig davon, wie oft Sie <code>@use</code> im Projekt verwenden. </li><li>  Variablen, Mixins und Funktionen (die in Sass als "Mitglieder" bezeichnet werden), die mit einem Unterstrich ( <code>_</code> ) oder einem Bindestrich ( <code>-</code> ) beginnen, werden als privat betrachtet und nicht importiert. </li><li>  Mitglieder aus der über <code>@use</code> verbundenen <code>@use</code> (in unserem Fall <code>buttons.scss</code> ) sind nur lokal zugänglich und werden nicht zum nachfolgenden Import übertragen. </li><li>  Ebenso gilt <code>@extends</code> nur für Upstreams.  Das heißt, die Erweiterung gilt nur für importierte Stile und nicht für importierte Stile. </li><li>  Alle importierten Mitglieder haben standardmäßig einen eigenen <i>Namespace</i> . </li></ul><br>  Wenn wir die Datei über <code>@use</code> , generiert Sass automatisch einen Namespace basierend auf dem Dateinamen. <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    `buttons`*/</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    `forms`*/</span></span></code> </pre><br>  Jetzt haben wir Zugriff auf die Mitglieder sowohl der Datei <code>buttons.scss</code> als auch der Datei <code>forms.scss</code> , aber dieser Zugriff wird nicht zwischen Importen übertragen: <code>forms.scss</code> weiterhin keinen Zugriff auf die in <code>buttons.scss</code> definierten <code>buttons.scss</code> .  Da importierte Entitäten einen Namespace haben, müssen wir die neue durch Punkte getrennte Syntax verwenden, um auf sie zuzugreifen: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* : &lt;namespace&gt;.$variable */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">btn-color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">buttons</span></span>.$<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-border</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span>.$<span class="hljs-selector-tag"><span class="hljs-selector-tag">input-border</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* : &lt;namespace&gt;.function() */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">btn-background</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">buttons</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.background</span></span>(); $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-border</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.border</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/* : @include &lt;namespace&gt;.mixin() */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> buttons.submit(); @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> forms.input();</code> </pre><br>  Wir können den Standard-Namespace ändern oder entfernen, indem wir dem Import <code>as &lt;name&gt;</code> hinzufügen. <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> as *; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span> as <span class="hljs-string"><span class="hljs-string">'f'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">btn-color</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* buttons.$color    */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-border</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>.$<span class="hljs-selector-tag"><span class="hljs-selector-tag">input-border</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* forms.$input-border    */</span></span></code> </pre><br>  Wenn Sie <code>as *</code> das Modul dem Root-Namespace hinzugefügt, sodass das Präfix nicht benötigt wird, seine Mitglieder jedoch durch das aktuelle Dokument lokal begrenzt sind. <br><br><h2>  Importieren Sie eingebettete Sass-Module </h2><br>  Die internen Funktionen in Sass wurden ebenfalls in ein modulares System verschoben, sodass wir die volle Kontrolle über den globalen Namespace haben.  Es gibt mehrere integrierte Module - <code>math</code> , <code>color</code> , <code>string</code> , <code>list</code> , <code>map</code> , <code>selector</code> und <code>meta</code> -, die vor der Verwendung explizit in die Datei importiert werden müssen. <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:math'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">half</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">math</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.percentage</span></span>(1/2);</code> </pre><br>  Eingebettete Module können auch in den globalen Raum importiert werden: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:math'</span></span> as *; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">half</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">percentage</span></span>(1/2);</code> </pre><br>  Integrierte Funktionen, die bereits Präfixnamen haben, wie z. B. <code>map-get</code> oder <code>str-index</code> , können verwendet werden, ohne dieses Präfix zu duplizieren: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:map'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:string'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">map-get</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">map</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.get</span></span>(('<span class="hljs-selector-tag"><span class="hljs-selector-tag">key</span></span>': '<span class="hljs-selector-tag"><span class="hljs-selector-tag">value</span></span>'), '<span class="hljs-selector-tag"><span class="hljs-selector-tag">key</span></span>'); $<span class="hljs-selector-tag"><span class="hljs-selector-tag">str-index</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.index</span></span>('<span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span>', '<span class="hljs-selector-tag"><span class="hljs-selector-tag">i</span></span>');</code> </pre><br>  Eine vollständige Liste der integrierten Module, Funktionen und Namensänderungen finden Sie in <a href="">der Sass-Modulspezifikation</a> . <br><br><h2>  Neue und geänderte Kernfunktionen </h2><br>  Als zusätzlichen Vorteil bedeutet dies, dass Sass sicher neue interne Mixins und Funktionen hinzufügen kann, ohne Namenskonflikte zu verursachen.  Das erstaunlichste Beispiel ist das <code>load-css</code> <code>sass:meta</code> aus dem <code>sass:meta</code> Modul.  Es funktioniert ähnlich wie <code>@use</code> , gibt jedoch nur das generierte CSS zurück und funktioniert dynamisch an einer beliebigen Stelle in Ihrem Code: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:meta'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">theme-name</span></span>: '<span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>'; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-theme='#{$theme-name}']</span></span> { @include meta.load-css($theme-name); }</code> </pre><br>  Das erste Argument ist die Modul-URL (wie in <code>@use</code> ), sie kann jedoch mithilfe einer Variablen dynamisch geändert werden, auch durch Interpolation, z. B. <code>theme-#{$name}</code> .  Das zweite (optionale) Argument nimmt eine <code>map</code> mit der Konfiguration an: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*   $base-color  'theme/dark'   */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> meta.load-css( <span class="hljs-string"><span class="hljs-string">'theme/dark'</span></span>, $with: (<span class="hljs-string"><span class="hljs-string">'base-color'</span></span>: rebeccapurple) );</code> </pre><br>  <code>$with</code> Argument <code>$with</code> können Sie jede Variable im geladenen Modul mithilfe der <code>map</code> konfigurieren. Diese Variable muss die folgenden Bedingungen erfüllen: <br><br><ul><li>  Es ist keine private Variable, die mit <code>_</code> oder <code>-</code> beginnt </li><li>  Markiert mit der <code>!default</code> Default-Direktive </li></ul><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* theme/_dark.scss */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">base-color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span> !<span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> $_<span class="hljs-selector-tag"><span class="hljs-selector-tag">private</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span> !<span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    ,      !default */</span></span></code> </pre><br>  Beachten Sie, dass der Schlüssel <code>'base-color'</code> die Variable <code>$base-color</code> <code>'base-color'</code> festlegt. <br><br>  Es gibt noch ein paar neue Funktionen aus dem <code>sass:meta</code> Modul <code>sass:meta</code> : <code>module-variables()</code> und <code>module-functions()</code> .  Jeder von ihnen gibt eine <code>map</code> aus Namen und Werten eines bereits importierten Moduls zurück.  Sie nehmen ein Argument an, das dem Modul-Namespace entspricht: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-vars</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">module-variables</span></span>('<span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span>'); <span class="hljs-comment"><span class="hljs-comment">/* ( button-color: blue, input-border: thin, ) */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-functions</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">module-functions</span></span>('<span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span>'); <span class="hljs-comment"><span class="hljs-comment">/* ( background: get-function('background'), border: get-function('border'), ) */</span></span></code> </pre><br>  Einige andere Funktionen von <code>sass:meta</code> - <code>global-variable-exists()</code> , <code>function-exists()</code> , <code>mixin-exists()</code> und <code>get-function()</code> - erhalten zusätzliche <code>$module</code> , mit denen wir jeden Namespace explizit überprüfen können. <br><br><h3>  Passen Sie die Farben an und skalieren Sie sie </h3><br>  Das Modul <code>sass:color</code> hat auch einige interessante Vorbehalte gegen die Lösung einiger unserer alten Probleme.  Viele der älteren Funktionen wie <code>lighten()</code> oder <code>adjust-hue()</code> nicht mehr für die expliziten Funktionen <code>color.adjust()</code> und <code>color.scale()</code> : <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*  lighten(red, 20%) */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">light-red</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.adjust</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">lightness</span></span>: 20%); <span class="hljs-comment"><span class="hljs-comment">/*  adjust-hue(red, 180deg) */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">complement</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.adjust</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">hue</span></span>: 180<span class="hljs-selector-tag"><span class="hljs-selector-tag">deg</span></span>);</code> </pre><br><br>  Einige dieser veralteten Funktionen (z. B. <code>adjust-hue</code> ) sind redundant und unnötig.  Andere - wie <code>lighten</code> , <code>darken</code> , <code>saturate</code> usw.  - müssen erneut implementiert werden, um die interne Logik zu verbessern.  Die ursprünglichen Funktionen basierten auf <code>adjust()</code> , das lineare Mathematik verwendet: Hinzufügen von <code>20%</code> zur aktuellen Helligkeit von <code>red</code> in unserem obigen Beispiel.  In den meisten Fällen möchten wir die Farbe um einen bestimmten Prozentsatz gegenüber dem aktuellen Wert ändern ( <code>scale()</code> ): <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*        20,   0.2,     */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">light-red</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scale</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">lightness</span></span>: 20%);</code> </pre><br>  Nachdem diese Funktionen vollständig veraltet und entfernt wurden, werden sie schließlich in <code>sass:color</code> mit einem neuen Verhalten <code>color.scale()</code> das auf <code>color.scale()</code> und nicht auf <code>color.scale()</code> <code>color.adjust()</code> .  Dies geschieht schrittweise, um plötzliche Abwärtskompatibilitätsprobleme zu vermeiden.  In der Zwischenzeit empfehle ich, Ihren Code manuell zu überprüfen, um <code>color.scale()</code> wo <code>color.scale()</code> möglicherweise nützlicher ist. <br><br><h2>  Konfigurieren Sie importierte Bibliotheken </h2><br>  Bibliotheken von Drittanbietern oder wiederverwendbaren Bibliotheken enthalten häufig Variablen mit einigen Standardwerten, die Sie überschreiben können.  Wir haben dies mit Variablen vor dem Import gemacht: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* _buttons.scss */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">blue</span></span> !<span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* old.scss */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>;</code> </pre><br>  Da bei Verwendung von Modulen kein Zugriff mehr auf lokale Variablen besteht, benötigen wir eine neue Methode zum Festlegen von Werten.  Wir können dies tun, indem wir die Einstellungen per <code>map</code> an <code>@use</code> : <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> with ( $color: red, $style: <span class="hljs-string"><span class="hljs-string">'flat'</span></span>, );</code> </pre><br>  Dies ähnelt dem Argument <code>$with</code> in <code>load-css()</code> , aber anstatt Variablennamen als Schlüssel zu verwenden, verwenden wir die Variablen selbst mit dem Symbol <code>$</code> . <br><br>  Mir gefällt, wie explizit die Einstellung geworden ist, aber es gibt eine Regel, die mich mehrmals verblüfft hat: Ein <b>Modul kann bei der ersten Verwendung nur einmal konfiguriert werden</b> .  Die Verbindungsreihenfolge war für Sass auch bei <code>@import</code> immer wichtig, aber diese Probleme <code>@import</code> unbemerkt.  Jetzt erhalten wir einen klaren Fehler, der sowohl gut als auch ein wenig unerwartet ist.  <code>@use</code> Sie sicher, dass Sie die Bibliotheken über <code>@use</code> und in der Eintragsdatei (dem zentralen Dokument, das alle anderen Dateien importiert) konfigurieren, damit diese Einstellungen vor anderen Bibliotheksverbindungen über <code>@use</code> . <br><br>  Es ist (im Moment) nicht möglich, die Konfigurationen zusammenzubinden, damit sie bearbeitet werden können. Sie können das konfigurierte Modul jedoch umschließen und als neues Modul übertragen. <br><br><h2>  Übertragen von Dateien mit <code>@forward</code> </h2><br>  Wir müssen die Datei nicht immer verwenden und auf ihre Mitglieder verweisen.  Manchmal wollen wir es nur an nachfolgende Importe weitergeben.  Angenommen, wir haben mehrere Dateien mit Formularen verknüpft und möchten sie alle als einen Namespace miteinander verbinden.  Wir können dies mit <code>@forward</code> tun: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* forms/_index.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'input'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'textarea'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'select'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>;</code> </pre><br>  Mitglieder solcher weitergeleiteten Dateien sind im aktuellen Dokument nicht verfügbar und es wird kein Namespace erstellt. Diese Variablen, Funktionen und Mixins sind jedoch verfügbar, wenn eine andere Datei sie über <code>@use</code> oder <code>@use</code> gesamte Sammlung über <code>@forward</code> .  Wenn die übermittelten Einzeldateien tatsächlich CSS enthalten, wird es auch übertragen, ohne es direkt zu generieren, bis das Paket selbst verwendet wird.  In dieser Phase wird dies alles als ein Modul mit einem Namespace betrachtet: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* styles.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        `forms` */</span></span></code> </pre><br>  <b>Hinweis</b> : Wenn Sie Sass bitten, einen Ordner anzuhängen, sucht er nach dem <code>index</code> oder der <code>_index</code> Datei darin. <br><br>  Standardmäßig werden alle öffentlichen Mitglieder zusammen mit dem Modul weitergeleitet.  Wir können jedoch selektiver <code>hide</code> , indem wir die <code>show</code> und <code>hide</code> verwenden und bestimmte Mitglieder angeben, die wir hinzufügen oder ausschließen möchten. <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*    `border()`   `$border-color`   `input` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'input'</span></span> show border, $border-color; <span class="hljs-comment"><span class="hljs-comment">/*     `buttons`    `gradient()` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> hide gradient;</code> </pre><br>  <b>Hinweis</b> : Wenn Funktionen und Mixins einen gemeinsamen Namen haben, werden sie auch zusammen hinzugefügt und ausgeblendet. <br><br>  Um die Quellen zu klären oder Namenskonflikte von weitergeleiteten Modulen zu vermeiden, können wir den Mitgliedern der verbundenen Datei Präfixe hinzufügen, indem wir Folgendes verwenden: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* forms/_index.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* @forward "&lt;url&gt;" as &lt;prefix&gt;-*; */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ,      `background()` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'input'</span></span> as input-*; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> as btn-*; <span class="hljs-comment"><span class="hljs-comment">/* style.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> forms.input-background(); @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> forms.btn-background();</code> </pre><br>  Und wenn nötig, können wir immer über <code>@use</code> und dasselbe Modul über <code>@forward</code> , wobei <code>@forward</code> beide Regeln hinzufügen: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>;</code> </pre><br>  Dies ist besonders nützlich, wenn Sie die Bibliothek vorkonfigurieren oder zusätzliche Tools hinzufügen möchten, bevor Sie sie in andere Dateien übertragen.  Dies kann helfen, Verbindungspfade zu vereinfachen: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* _tools.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'accoutrement/sass/tools'</span></span> with ( $font-path: <span class="hljs-string"><span class="hljs-string">'../fonts/'</span></span>, ); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'accoutrement/sass/tools'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* -  ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* _anywhere-else.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'tools'</span></span>;</code> </pre><br>  Sowohl <code>@use</code> als auch <code>@forward</code> müssen im Stammverzeichnis des Dokuments (nicht verschachtelt) und am Anfang der Datei deklariert werden.  Vor Importanweisungen können nur <code>@charset</code> und einfache Variablendefinitionen <code>@charset</code> . <br><br><h2>  Übergang zu einem modularen System </h2><br>  Um die neue Syntax zu testen, habe ich eine neue Open-Source-Sass-Bibliothek ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cascading Color Systems</a> ) und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neue Site für meine Gruppe erstellt</a> - beide befinden sich noch in der Entwicklung.  Ich musste die Module aus Sicht des Autors der Bibliothek und aus Sicht des Site-Entwicklers verstehen.  Beginnen wir mit der Erfahrung des "Endbenutzers" beim Schreiben von Site-Stilen mithilfe der Modulsyntax ... <br><br><h3>  Support- und Schreibstile </h3><br>  Die Verwendung der Module auf der Website hat Spaß gemacht.  Die neue Syntax unterstützt die bereits verwendete Codearchitektur.  Alle meine Importe von globalen Einstellungen und Tools befinden sich im selben Verzeichnis (ich nenne es <code>config</code> ) mit einer Indexdatei, die alles überträgt, was ich brauche: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* config/_index.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'tools'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'fonts'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'scale'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'colors'</span></span>;</code> </pre><br>  Durch die Entwicklung anderer Teile der Site kann ich diese Tools und Konfigurationen überall dort importieren, wo ich sie benötige: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* layout/_banner.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'../config'</span></span>; <span class="hljs-selector-class"><span class="hljs-selector-class">.page-title</span></span> { @include config.font-family('header'); }</code> </pre><br>  Es funktioniert sogar mit meinen vorhandenen Bibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Accoutrement</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herman</a> , die immer noch die alte <code>@import</code> Syntax verwenden.  Da die <code>@import</code> Regel nicht überall auf einmal ersetzt wird, haben die Sass-Entwickler etwas Zeit für den Übergang <code>@import</code> .  Die Module sind ab sofort verfügbar, aber <code>@import</code> läuft noch ein oder zwei Jahre nicht ab - und wird erst ein Jahr später aus der Sprache entfernt.  Gleichzeitig arbeiten die beiden Systeme auf folgende Weise zusammen: <br><br><ul><li>  Wenn wir <code>@import</code> für eine Datei ausführen, die die neue <code>@use/@forward</code> Syntax enthält, werden nur öffentliche Mitglieder ohne Namespace importiert. </li><li>  Wenn wir <code>@use</code> oder <code>@forward</code> für eine Datei ausführen, die die alte <code>@import</code> Syntax enthält, erhalten wir Zugriff auf alle verschachtelten Importe als einen einzigen Namespace. </li></ul><br>  Dies bedeutet, dass Sie sofort mit der Verwendung der neuen Modulsyntax beginnen können, ohne auf die Veröffentlichung einer neuen Version Ihrer Lieblingsbibliotheken warten zu müssen: und ich kann einige Zeit damit verbringen, alle meine Bibliotheken zu aktualisieren! <br><br><h3>  Migrationstool </h3><br>  Das Upgrade dauert nicht lange, wenn wir das von Jennifer Thakar erstellte Migrationstool verwenden.  Es kann mit NPM, Chocolatey oder Homebrew installiert werden: <br><br><pre> <code class="bash hljs">npm install -g sass-migrator choco install sass-migrator brew install sass/sass/migrator</code> </pre><br>  Dies ist kein einmaliges Tool für die Migration zu Modulen.  Nachdem sich Sass wieder in der aktiven Entwicklung befindet (siehe unten), erhält das Migrationstool auch regelmäßige Updates, um die Portierung jeder neuen Funktion zu unterstützen.  Es ist eine gute Idee, dieses Tool global zu installieren und für die zukünftige Verwendung zu speichern. <br><br>  Der Migrator kann über die Befehlszeile gestartet werden und wird hoffentlich Anwendungen von Drittanbietern wie CodeKit und Scout hinzugefügt.  <code>style.scss</code> auf eine einzelne Sass-Datei, z. B. <code>style.scss</code> und teilen Sie ihm mit, welche Migrationen <code>style.scss</code> .  Derzeit gibt es nur eine Migration namens <code>module</code> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># sass-migrator &lt;migration&gt; &lt;entrypoint.scss...&gt; sass-migrator module style.scss</span></span></code> </pre><br>  Standardmäßig aktualisiert der <code>@import</code> nur eine Datei. In den meisten Fällen möchten wir jedoch die Hauptdatei und alle ihre Abhängigkeiten aktualisieren: alle Elemente, die über <code>@import</code> , <code>@forward</code> oder <code>@use</code> .  Wir können dies tun, indem wir jede Datei einzeln <code>--migrate-deps</code> oder einfach das <code>--migrate-deps</code> hinzufügen. <br><br><pre> <code class="bash hljs">sass-migrator --migrate-deps module style.scss</code> </pre><br>  Für einen Testlauf können wir <code>--dry-run --verbose</code> (oder in abgekürzter Form <code>-nv</code> ) <code>-nv</code> und die Ergebnisse <code>-nv</code> ohne die Quelldateien zu ändern.  Es gibt eine Reihe anderer Optionen, mit denen wir die Migration konfigurieren können - es gibt sogar eine, die speziell entwickelt wurde, um Bibliotheksautoren beim Löschen alter manuell erstellter Namespaces zu helfen -, aber ich werde hier nicht alle beschreiben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Migrationstool ist vollständig</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Sass-Website</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dokumentiert</a> . <br><br><h3>  Veröffentlichte Bibliotheken aktualisieren </h3><br>  Ich bin auf der Bibliotheksseite auf einige Probleme gestoßen, insbesondere als ich versuchte, Benutzerkonfigurationen für mehrere Dateien verfügbar zu machen und eine Lösung für fehlende "Ketten" -Konfigurationen zu finden.  Das Debuggen von auftragsbezogenen Fehlern kann schwierig sein, aber die Ergebnisse sind die Mühe wert, und ich denke, wir werden bald einige zusätzliche Korrekturen sehen.  Ich muss noch mit dem Migrationstool für komplexe Pakete experimentieren und möglicherweise einen zusätzlichen Artikel für Bibliotheksautoren schreiben. <br><br>  Das Wichtigste, was Sie jetzt wissen müssen, ist, dass Sass uns während des Übergangs Schutz gewährt hat.  Die alten Importe und Module können nicht nur zusammenarbeiten, <code>@import</code> wir können auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nur-Import-</a> Dateien erstellen, um Benutzern, die unsere Bibliotheken weiterhin über <code>@import</code> verbinden, eine bequemere Arbeit zu ermöglichen.  In den meisten Fällen handelt es sich um eine alternative Version der <code>&lt;name&gt;.scss</code> , und Sie möchten, dass sie sich in der Nähe befinden: <code>&lt;name&gt;.scss</code> für <code>&lt;name&gt;.scss</code> und <code>&lt;name&gt;.import.scss</code> für alte Benutzer.  Jedes Mal, wenn der Benutzer <code>@import &lt;name&gt;</code> , lädt er die <code>.import</code> Datei: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*  `_forms.scss` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  `_forms.import.scss` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>;</code> </pre><br><br>  Dies ist besonders nützlich, um Präfixe für Entwickler hinzuzufügen, die keine Module verwenden: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* _forms.import.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span> as forms-*;</code> </pre><br><br><h2>  Sass Update </h2><br>  Sie erinnern sich vielleicht, dass Sass vor einigen Jahren die Hinzufügung neuer Funktionen eingefroren hat, so dass seine verschiedenen Implementierungen (LibSass, Node Sass, Dart Sass) die ursprüngliche Ruby-Implementierung einholen, um sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollständig aufzugeben</a> .  Das Einfrieren endete letztes Jahr mit mehreren neuen Funktionen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktiven Diskussionen und Entwicklungen</a> auf GitHub - aber nicht so feierlich.  Wenn Sie diese Veröffentlichungen verpasst haben, können Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sass-Blog</a> lesen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSS-Importe und CSS-Kompatibilität</a> (Dart Sass v1.11) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parameter der Inhaltsanweisung und Farbfunktionen (Dart Sass v1.15)</a> </li></ul><br>  Derzeit ist Dart Sass eine kanonische Implementierung und führt normalerweise als erster neue Funktionen ein.  Ich empfehle, darauf zu wechseln, wenn Sie die neuesten Informationen erhalten möchten.  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dart Sass</a> mit NPM, Chocolatey oder Homebrew <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">installieren</a> .  Es funktioniert auch gut mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schluck-Sass</a> . <br><br>  Wie bei CSS (beginnend mit CSS3) gibt es für neue Versionen keine einzige Versionsnummer mehr.  Alle Sass-Implementierungen arbeiten mit derselben Spezifikation, aber jede von ihnen verfügt über einen eindeutigen Release-Zeitplan und eine eindeutige Nummerierung, die sich in den Support-Informationen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer schönen neuen Dokumentation</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jina</a> widerspiegeln. <br><br><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1400,f_auto,q_auto/v1570122240/sass-modules-01_gapdpb.png" alt="Bild"><br><br>  Sass-Module sind ab <b>dem 1. Oktober 2019</b> in <b>Dart Sass 1.23.0 verfügbar</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471924/">https://habr.com/ru/post/de471924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471906/index.html">Die Gefahren unsachgemäßer Optimierungen</a></li>
<li><a href="../de471908/index.html">Die unerwartete Schönheit von Primzahlen</a></li>
<li><a href="../de471912/index.html">Englisch lernen: 7 praktische Möglichkeiten, Ihren Wortschatz zu erweitern</a></li>
<li><a href="../de471914/index.html">Funktionsweise des Sega Mega Drive-Grafiksystems: Videoanzeigeprozessor</a></li>
<li><a href="../de471918/index.html">SwiftUI: Bekanntschaft</a></li>
<li><a href="../de471928/index.html">Stellen Sie die zuletzt gespeicherte Konfiguration in Mikrotik-Routern automatisch wieder her</a></li>
<li><a href="../de471930/index.html">Atomic Design Mitap - Buchstaben, Farben, Uniformen, Team und Geld</a></li>
<li><a href="../de471938/index.html">Layout-Hinweise: Nützliche Google Chrome-Erweiterungen im Jahr 2019</a></li>
<li><a href="../de471940/index.html">So reduzieren Sie das Risiko von Ausfällen bei aufgeschobenen Abrechnungen: Factoring für Unternehmen</a></li>
<li><a href="../de471942/index.html">Entsprechend Ihren Anforderungen: Professioneller Test von Kingston DC500R- und DC500M-SSDs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>