<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµ üïê üë¨ Adaptador USB-SATA reverso (hist√≥rico de um estagi√°rio) ‚ôÄÔ∏è üì∞ üëàüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antecedentes 


 Est√°gio √© o processo de obten√ß√£o de conhecimento e experi√™ncia. Nossa equipe de seguran√ßa da Raccoon acredita que √© imposs√≠vel melhor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Adaptador USB-SATA reverso (hist√≥rico de um estagi√°rio)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/485966/"><h1 id="predystoriya">  Antecedentes </h1><br><p>  Est√°gio √© o processo de obten√ß√£o de conhecimento e experi√™ncia.  Nossa equipe de seguran√ßa da Raccoon acredita que √© imposs√≠vel melhorar a seguran√ßa das informa√ß√µes de dispositivos e software ao nosso redor sem transmitir esse conhecimento e experi√™ncia para as gera√ß√µes futuras de especialistas.  √â por isso que organizamos est√°gios individuais para estudantes e graduados talentosos h√° muitos anos. </p><br><p>  Pesquisa de seguran√ßa √© uma habilidade que n√£o √© ensinada na universidade.  Voc√™ pode aprender com exemplos concretos e sob a orienta√ß√£o de mentores experientes.  A cada ano, nossos estagi√°rios resolvem problemas t√©cnicos complexos, alcan√ßam seus objetivos e seguem em frente, expandindo seus horizontes profissionais e tornando o mundo um pouco mais seguro.  Cada um deles tem sua pr√≥pria hist√≥ria de se tornar um especialista, e sob o corte - o come√ßo de um deles. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/dr/h-/eudrh-mevrjhfjo4jfjouffyyk4.png"></div><a name="habracut"></a><br><h1 id="vvedenie">  1. Introdu√ß√£o </h1><br><p>  Em outubro do ano passado, participei de um est√°gio t√©cnico na empresa NTC Vulkan.  Meu interesse foi direcionado para o campo da engenharia reversa.  Eu sabia o que era, j√° havia tentado pesquisar independentemente o crackme sob o x86, mas entendi que a coisa mais interessante est√° precisamente na jun√ß√£o de software e hardware.  Eu n√£o tinha experi√™ncia nessa √°rea, mas queria experimentar minha m√£o. </p><br><p> Eu n√£o tinha nenhuma expectativa espec√≠fica em rela√ß√£o a esse evento - amigos e conhecidos costumam falar sobre est√°gios t√©cnicos em v√°rias empresas conhecidas.  E quando me ofereceram a oportunidade de pesquisar um adaptador USB-SATA, fiquei satisfeito com a nova oportunidade de aprender algo.  A experi√™ncia adquirida e o resultado que obtive possibilitaram verificar a exatid√£o da escolha do local de est√°gio e futura profiss√£o. </p><br><p>  E o estudo come√ßou com a aquisi√ß√£o de um adaptador USB-SATA comum.  Aqui est√° o que eu fiz a seguir. </p><br><h1 id="vizualnyy-shemotehnicheskiy-analiz">  An√°lise visual de circuitos </h1><br><p>  Primeiro, voc√™ precisa inspecionar a placa adaptadora e determinar os elementos b√°sicos do dispositivo.  As figuras abaixo indicam os principais blocos de componentes que s√£o importantes para a opera√ß√£o do dispositivo.  Fotos tiradas ap√≥s pesquisa: </p><br><img src="https://habrastorage.org/webt/9x/1n/ej/9x1nejzyxjz-zpfnb_d_v9y9giy.jpeg"><br><p>  <em>Adaptador USB para SATA.</em>  <em>Vista superior</em> </p><br><img src="https://habrastorage.org/webt/tx/ra/je/txrajeoqdj1x7ytwn7huh0gdy6g.jpeg"><br><p>  <em>Adaptador USB para SATA.</em>  <em>Vista inferior</em> </p><br><p>  Depois de passar algum tempo no Google, descobri que havia dois conversores de voltagem na placa: um a 3,3 V e o outro a 1,2 V. Tamb√©m √© muito f√°cil determinar a mem√≥ria flash instalada na placa.  A ROM funciona na interface SPI e a capacidade da mem√≥ria √© 512 Kbps. </p><br><p>  Parece que o est√°gio de reconhecimento do circuito est√° quase completo, mas uma r√°pida pesquisa na Internet n√£o produziu nenhum resultado para a consulta "ASM1051".  N√£o foram encontrados documentos para o chip instalado no painel.  √â verdade, ainda conseguiu encontrar um software que permite atualiz√°-lo.  Al√©m disso, h√° uma pequena <a href="https://datasheetspdf.com/pdf-file/917641/ASMedia/ASM1053/1">folha</a> de <a href="https://datasheetspdf.com/pdf-file/917641/ASMedia/ASM1053/1">dados</a> para o modelo mais antigo <strong>ASM1053</strong> . </p><br><h1 id="usb">  USB </h1><br><p>  Quando conectado a um computador, o adaptador aparece como um dispositivo de armazenamento USB.  Decidi que um conhecimento mais profundo sobre <a href="https://ru.wikipedia.org/wiki/USB">USB</a> provavelmente seria √∫til para minha pesquisa, ent√£o, nas pr√≥ximas horas que passei estudando a interface. <br>  Em geral, os dispositivos USB podem ser de diferentes classes, dependendo de sua funcionalidade.  Por exemplo, as unidades flash s√£o o dispositivo de armazenamento em massa e os teclados e mouses s√£o o <a href="https://ru.wikipedia.org/wiki/USB_HID">dispositivo de interface humana (HID)</a> .  E como meu adaptador √© vis√≠vel no gerenciador de dispositivos como um dispositivo de armazenamento, significa que ele √© definido como Armazenamento em Massa e deve funcionar com comandos SCSI. </p><br><div class="spoiler">  <b class="spoiler_title">Literatura b√°sica sobre USB que foi √∫til</b> <div class="spoiler_text"><ul><li><p>  <a href="https://pierrelib.pagesperso-orange.fr/buses/USB_in_a_Nutshell.pdf">USB em um NutShell</a> </p><br></li><li><p>  <a href="https://usb.org/sites/default/files/usbmassbulk_10.pdf">Classe de armazenamento em massa de barramento serial universal</a> </p><br></li><li><p>  <a href="http://ww1.microchip.com/downloads/en/appnotes/01169a.pdf">Classe de armazenamento em massa USB em um dispositivo incorporado</a> </p><br></li><li><p>  <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">Manual de refer√™ncia de comandos SCSI</a> </p><br></li></ul></div></div><br><h1 id="chtenie-pamyati-iz-pzu">  Ler mem√≥ria da ROM </h1><br><p>  Como nada se sabe sobre o ASM1051 instalado na placa, a mem√≥ria da ROM foi considerada a a√ß√£o mais √≥bvia.  Eu me mudei para o laborat√≥rio.  Separe o chip de mem√≥ria flash com um secador de cabelo de solda e conecte-o ao programador USB ChipProg-48.  N√£o houve problemas para ler e eu tinha um arquivo bin√°rio em minhas m√£os.  Naquele momento, eu n√£o sabia dizer o que havia na unidade flash e comecei a analisar os dados. </p><br><h1 id="analiz-binarnogo-fayla">  An√°lise de arquivo bin√°rio </h1><br><p>  Antes de tudo, abri um despejo de mem√≥ria da ROM usando o WinHex, mas voc√™ pode usar qualquer editor HEX.  Come√ßou a olhar para os bytes: </p><br><img src="https://habrastorage.org/webt/fz/g8/v7/fzg8v7gjqsop97y-kgybcmudrqa.jpeg"><br><p>  <em>In√≠cio de um despejo de mem√≥ria lido na ROM</em> </p><br><p> A captura de tela acima √© uma captura de tela do editor.  A linha <code>ASMT1051</code> , que come√ßa com o endere√ßo 0x44, √© imediatamente evidente.  Voc√™ tamb√©m pode ver a linha <code>asmedia</code> no endere√ßo 0x18.  Para a an√°lise inicial dos dados, usei a ferramenta de an√°lise de frequ√™ncia, dispon√≠vel no WinHex. </p><br><img src="https://habrastorage.org/webt/ui/r9/ad/uir9adkobpc6gnl55k6vjnaf65i.jpeg"><br><p>  <em>Histograma de an√°lise de frequ√™ncia da mem√≥ria ROM</em> </p><br><p>  O histograma mostra os bytes que est√£o mais no arquivo.  Al√©m do heap 0x00 e 0xFF (as colunas extremas no histograma), os seguintes bytes s√£o frequentemente encontrados na mem√≥ria: </p><br><ul><li>  0x02; </li><li>  0x74; </li><li>  0x90; </li><li>  0xA3; </li><li>  0xE0; </li><li>  0xF0. </li></ul><br><p>  Seria poss√≠vel confirmar minha suposi√ß√£o de que h√° firmware na ROM.  Uma maneira f√°cil de fazer isso √© tentar comparar os <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8">opcodes de</a> diferentes arquiteturas adequadas para microcontroladores (daqui em diante - MC) com bytes que s√£o freq√ºentemente encontrados na mem√≥ria. </p><br><p>  Se estimado aproximadamente, muitas vezes em qualquer c√≥digo no assembler deve atender a comandos como: </p><br><ul><li>  mov; </li><li>  jmp; </li><li>  ligar; </li><li>  ret. </li></ul><br><p>  Obviamente, em diferentes arquiteturas, esses comandos podem ter varia√ß√µes diferentes, mas h√° um senso comum. </p><br><p>  Eu tive que passar por v√°rios conjuntos de instru√ß√µes para diferentes n√∫cleos antes de encontrar os corretos.  A compara√ß√£o com a arquitetura do <a href="https://ru.wikipedia.org/wiki/Intel_8051">Intel 8051</a> deu um resultado muito plaus√≠vel.  Os c√≥digos de opera√ß√£o de alguns <a href="http://www.keil.com/support/man/docs/is51/is51_opcodes.htm">comandos</a> coincidem com os bytes populares de um arquivo, por exemplo: </p><br><ul><li>  0x02 - LJMP addr16; </li><li>  0x74 - MOV A, #immed; </li><li>  0x90 - DPV MOV, #immed; </li><li>  0xA3 - INC DPTR; </li><li>  0xE0 - MOVX A, @DPTR; </li><li>  0xF0 - MOVX @DPTR, A. </li></ul><br><p>  Realmente parece que h√° firmware para MK na ROM.  Pode-se carregar imediatamente o bin√°rio no desmontador do <a href="https://www.hex-rays.com/products/ida/index.shtml">IDA Pro</a> , mas no almo√ßo um dos colegas perguntou: </p><br><blockquote>  <em>"Voc√™ tem certeza de que o c√≥digo na mem√≥ria come√ßa exatamente a partir do endere√ßo zero?"</em> </blockquote><p>  E realmente, voc√™ precisa levar em considera√ß√£o que alguns ‚Äúlixo‚Äù ou dados do endere√ßo 0x00 podem estar na mem√≥ria. </p><br><p>  Em geral, enfrentei a tarefa de determinar o endere√ßo inicial do c√≥digo.  Para atingir esse objetivo, era melhor usar o emulador <a href="https://www.eltan.com/products/spi-flash-tools/46-em100-emulator.html">EM100</a> SPI.  O emulador substitui o chip de mem√≥ria na placa, n√£o sendo necess√°rio soldar a ROM todas as vezes com firmware; al√©m disso, o EM100 pode gravar um log de acesso √† mem√≥ria.  Dado que o firmware da ROM j√° foi lido, agora voc√™ pode baix√°-lo para o emulador SPI.  Em seguida, voc√™ precisa soldar o emulador na placa adaptadora e registrar um log ao conectar o adaptador via USB a um PC. </p><br><img src="https://habrastorage.org/webt/8i/rp/f2/8irpf2mpqht4crvi8aqwcj3ot7s.jpeg"><br><p>  <em>O emulador SPI √© soldado √† placa adaptadora USB-SATA</em> </p><br><p>  Soldei a fia√ß√£o do emulador para os blocos da mem√≥ria flash e atualizei o emulador com alguns firmware.  Agora resta ver se o MK endere√ßa a mem√≥ria e, em caso afirmativo, em quais endere√ßos. </p><br><img src="https://habrastorage.org/webt/yc/v6/te/ycv6teqfm5n_7gzvwgss1d6ycwk.png"><br><p>  <em>ROM de acesso √† mem√≥ria ROM (obtida usando o software emulador SPI)</em> </p><br><p>  A figura acima mostra que, quando a energia est√° conectada ao adaptador, o controlador ASM1051 instalado na placa envia v√°rios comandos 0x03 (Read Data). </p><br><p>  Primeiro, o ASM1051 l√™ 0x80 bytes, come√ßando em 0x0000.  A seguir, est√£o dois bytes, come√ßando no endere√ßo 0x0080 e mais dois bytes do endere√ßo 0x8082.  Em seguida, ele l√™ a maior parte da mem√≥ria da ROM, iniciando no endere√ßo 0x0082. </p><br><p>  Podemos supor que um grande n√∫mero de bytes lidos da ROM pela √∫ltima vez, come√ßando com o endere√ßo 0x0082, seja provavelmente o c√≥digo.  O que e por que √© solicitado antes disso ainda n√£o est√° claro.  Sabe-se apenas que, em resposta √† primeira solicita√ß√£o, o ASM1051 receber√° linhas da mem√≥ria flash marcadas na figura acima.  Eles estavam localizados nos primeiros 0x80 bytes. </p><br><p>  √â hora de verificar que a mem√≥ria externa na placa cont√©m firmware para MK com o kernel 8051, e o pr√≥prio c√≥digo est√° localizado no endere√ßo 0x0082.  Abra o despejo de mem√≥ria no IDA Pro, especifique o tipo de processador Intel 8051 e fa√ßa o deslocamento para o c√≥digo 0x0082. </p><br><img src="https://habrastorage.org/webt/r8/fy/pl/r8fyplytapyh-i_lfgazwcsoxga.png"><br><p>  <em>Arquivo bin√°rio aberto no IDA Pro com deslocamento 0x82</em> </p><br><p>  N√£o houve problemas ao abrir o bin√°rio no desmontador. </p><br><p>  <strong><em>Conclus√µes:</em></strong> </p><br><ol><li>  O MK ASM1051 possui uma arquitetura 8051. </li><li>  Na ROM, existe um c√≥digo que come√ßa com o endere√ßo 0x82.  H√° algo mais al√©m do c√≥digo. </li><li>  Os primeiros 0x80 bytes atraem aten√ß√£o. </li></ol><br><h1 id="analiz-koda">  An√°lise de c√≥digo </h1><br><p>  Agora que eu verifiquei se o c√≥digo no IDA est√° carregado corretamente, voc√™ pode come√ßar a analis√°-lo e comentar em paralelo. </p><br><p>  Durante o estudo do c√≥digo, foram encontradas fun√ß√µes simples, como subtrair n√∫meros de 32 bits, v√°rios manipuladores, semelhantes ao <code>switch ()</code> em S. Melkali, e fun√ß√µes muito simples, como armazenar o valor do registro R7 na mem√≥ria em algum endere√ßo.  As descobertas mais significativas que descreverei abaixo. </p><br><h2 id="nahodka--1">  Encontre o n√∫mero 1 </h2><br><p>  Curiosamente, em resposta √† minha solicita√ß√£o INQUIRY ( <a href="https://en.wikipedia.org/wiki/SCSI_command">comando SCSI</a> ), recebi uma resposta contendo duas linhas que vimos no in√≠cio da mem√≥ria ROM.  Obviamente, mudei imediatamente essas linhas na mem√≥ria do emulador, aguardando uma solicita√ß√£o do INQUIRY para ver o que escrevi.  Um sonho t√£o ing√™nuo desmoronou rapidamente.  Agora, em resposta ao comando, vi outra linha, o ASM1051 n√£o solicitou a maior parte da mem√≥ria da ROM.  O MK leu apenas os primeiros 0x80 bytes e tudo.  Na arquitetura do 8051, o firmware da m√°scara (hardware) pode ser usado, aparentemente, o ASM1051 come√ßou a inicializ√°-lo. </p><br><p>  Ent√£o ficou claro que os primeiros bytes 0x80 s√£o realmente importantes, e alter√°-los simplesmente n√£o funcionar√°.  Decidi estudar com mais detalhes os pedidos que o MK faz no SPI antes de baixar o c√≥digo. </p><br><img src="https://habrastorage.org/webt/ep/cl/8i/epcl8it0d2d63f8oq1tctpmfvii.png"><br><p>  <em>Solicita√ß√£o de dados SPI na ROM</em> </p><br><p>  Dois pedidos de dois bytes pareciam interessantes.  As pesquisas no IDA 0x00, 0x80 e 0xEB produziram um grande n√∫mero de resultados que eu n√£o analisei, mas o byte 0x5A foi encontrado com menos frequ√™ncia. </p><br><img src="https://habrastorage.org/webt/sv/ym/kf/svymkfdb-0nsj764k8igczukjj0.png"><br><p>  <em>Compara√ß√£o com o byte 0x5A.</em>  <em>Contando a soma de verifica√ß√£o-8</em> </p><br><p>  Literalmente, o sexto clique me levou √† se√ß√£o de c√≥digo mostrada na figura acima.  Pode-se observar que o valor do registro com o endere√ßo 0x80 <strong>7E √©</strong> comparado com 0x5A.  A soma de verifica√ß√£o-8 √© lida para valores localizados do endere√ßo 0x80 <strong>04</strong> a 0x80 <strong>7E</strong> .  Em seguida, o valor em 0x80 <strong>7F √©</strong> comparado com o valor recebido anteriormente. </p><br><img src="https://habrastorage.org/webt/j4/ao/x2/j4aox2tkbow4wzw57rrbprixw9u.png"><br><p>  <em>O come√ßo da mem√≥ria na ROM</em> </p><br><p>  Essas compensa√ß√µes se assemelhavam ao in√≠cio de um despejo de mem√≥ria da ROM.  A figura acima mostra que o endere√ßo 0x7E cont√©m o byte 0x5A.  E se voc√™ contar a soma de verifica√ß√£o 8 para bytes da posi√ß√£o 0x04 a 0x7E, obteremos 0xA7, e esse valor estar√° no endere√ßo 0x7F. </p><br><p>  De maneira semelhante, conseguimos encontrar o c√°lculo da soma de verifica√ß√£o para bytes do endere√ßo 0x0082 a 0x807F (aparentemente esse √© o c√≥digo inteiro), que √© verificado com o byte no endere√ßo 0x8083.  E em 0x8082 novamente est√° o valor 0x5A. </p><br><p>  Sim, isso √© um pouco mais complicado do que apenas alterar as linhas na mem√≥ria.  Tamb√©m os mudei, mas tamb√©m calculei e escrevi as somas de verifica√ß√£o para o novo arquivo nos lugares certos.  Depois disso, em resposta ao comando SCSI INQUIRY, vi minhas linhas. </p><br><p>  <strong><em>Conclus√µes:</em></strong> </p><br><ol><li>  Durante a inicializa√ß√£o, o ASM1051 tenta baixar o c√≥digo da ROM. </li><li>  Primeiro, o ASM1051 compara o checksum-8 byte do endere√ßo 0x04 a 0x7E com o valor em 0x7F. </li><li>  Se a compara√ß√£o da soma de verifica√ß√£o do pre√¢mbulo for bem-sucedida, podemos consider√°-la como "c√≥digo" (endere√ßos de 0x0082 a 0x807F).  O ASM1051 compara esse valor com o valor no endere√ßo 0x8083 e verifica se o byte 0x5A est√° localizado no endere√ßo 0x8082. </li><li>  Se todas as verifica√ß√µes estiverem corretas, o ASM1051 ser√° carregado da ROM, caso contr√°rio, ele usar√° o firmware da m√°scara. </li></ol><br><h2 id="nahodka--2">  Encontre o n√∫mero 2 </h2><br><p>  Ao revisar e comentar as fun√ß√µes, descobri que muitas vezes a fun√ß√£o PRINTF √© usada no c√≥digo (eu a chamei assim).  O interessante √© que, antes de ser chamado, um caractere <strong>impresso</strong> √© gravado no registro R7. </p><br><img src="https://habrastorage.org/webt/fn/0a/9a/fn0a9aafvgus1v4emxuf6j9kbea.png"><br><p>  <em>Fun√ß√£o PRINTF no IDA Pro</em> </p><br><p>  A fun√ß√£o em si foi apresentada na figura acima.  Vamos lidar com ela.  Primeiro, voc√™ precisa mover o valor do registro com o endere√ßo 0x7F6 para a bateria.  Se houver zero, saia da fun√ß√£o.  A coisa mais interessante acontece se n√£o houver zero.  Em seguida, o valor do registro R7 √© movido para o registro com o endere√ßo 0xC001 e, como lembramos, antes de chamar esta fun√ß√£o, um caractere impresso √© gravado em R7.  Em seguida, verifique se o valor em R7 √© igual ao c√≥digo de caractere ‚Äú.‚Äù Ou ‚Äú-‚Äù, se n√£o, saia da fun√ß√£o.  Mas se a compara√ß√£o tiver sido bem-sucedida, a fun√ß√£o pega o valor do registrador com o endere√ßo 0x16A e o move para 0xC001, mas √© complicado.  Por exemplo, em vez do byte <strong>0x41</strong> (caractere "A" em ASCII), a fun√ß√£o passar√° para 0xC001 byte 0x34 (caractere <strong>"4"</strong> em ASCII) e, em seguida, 0x31 (caractere <strong>"1"</strong> em ASCII).  Saia da fun√ß√£o novamente. </p><br><p>  Eu descobri que a verifica√ß√£o no in√≠cio da fun√ß√£o n√£o pode ser aprovada, uma vez que o registro com o endere√ßo 0x7F6 √© inicializado em zero, ent√£o n√£o muda no c√≥digo.  Ou seja, essa fun√ß√£o √© desativada pelo programador, embora permane√ßa compilada.  O fato de os bytes serem gravados apenas no registro 0xC001 (e √†s vezes dois em uma linha) sugere que esse √© provavelmente um registro de hardware. </p><br><p>  Tudo isso se parece com o UART.  Para descobrir se √© assim, voc√™ deve fazer o seguinte: </p><br><ol><li>  Identifique as pernas no ASM1051 onde o UART √© emitido. </li><li>  Defina os par√¢metros UART (velocidade, paridade, n√∫mero de bits de parada). </li><li>  Seria bom habilitar o UART no c√≥digo (aparentemente, est√° desativado). </li></ol><br><p>  Tudo parece bem simples: voc√™ pode se revezar tocando as pernas com um analisador l√≥gico e procurar aquele em que o momento do envio do UART estar√° vis√≠vel.  Na presen√ßa de um sinal, a velocidade pode ser determinada pelo tempo dos pulsos.  Com o restante dos par√¢metros, tudo fica claro, basta ver o momento de enviar um byte no analisador. </p><br><p>  Para "ativar" esta fun√ß√£o, voc√™ pode escrever zeros em vez das tr√™s primeiras linhas, onde o valor √© verificado no registro com o endere√ßo 0x7F6.  Para fazer isso, abro novamente o firmware no WinHex. </p><br><img src="https://habrastorage.org/webt/rm/rw/mg/rmrwmgen5bw46g0r1a7uchsnkog.png"><br><p>  <em>Seis bytes a serem redefinidos s√£o alocados.</em> </p><br><p>  No editor, altero os seis bytes desejados para zeros.  Agora o firmware est√° pronto e pode ser baixado no emulador de ROM.  Se assumirmos que a fun√ß√£o de sa√≠da de bytes no UART est√° ativada e sua chamada est√° localizada com muita freq√º√™ncia em todo o c√≥digo, podemos esperar que os bytes "voem" do UART quando o adaptador estiver em execu√ß√£o.  Espero ver um rastreador que sinalize em bytes no UART quanto do c√≥digo est√° sendo executado. </p><br><p>  Como escrevi acima, para encontrar as pernas Rx e Tx necess√°rias, voc√™ pode examinar o analisador l√≥gico um a um.  No entanto, eu assumi que o Rx e o Tx no ASM1051 est√£o no mesmo local que o ASM1053 - pernas 40 e 41, respectivamente.  Coloquei a sonda do analisador no pino 41 (presumido Tx) e vejo algo semelhante ao sinal desejado: </p><br><img src="https://habrastorage.org/webt/qn/s7/rq/qns7rq-nxvqvqcgzlo4hwqb7spc.png"><br><p>  <em>Diagrama de tempo com a perna 41 - Tx</em> </p><br><p>  Para conectar o conversor USB-UART e observar os caracteres impressos recebidos no terminal, tive que soldar duas cablagens finas diretamente na placa adaptadora e fix√°-lo com cola quente. </p><br><img src="https://habrastorage.org/webt/jn/x2/-f/jnx2-fwuhcewoy4aodelx7ugqbk.jpeg"><br><p>  <em>Duas liga√ß√µes soldadas para RX e TX</em> </p><br><p>  Estudei o diagrama da figura ‚ÄúDiagrama de tempo da perna 41 - Tx‚Äù um pouco: o tempo de um pulso, aparentemente, √© de 1 ¬µs, e para seis bits - 6,3 ¬µs.  Depois de recalcular o valor em bauds, recebi cerca de 950.000 bauds, a velocidade UART padr√£o mais pr√≥xima √© 921600 baud.  Eu acho que essa discrep√¢ncia √© obtida devido ao erro de medi√ß√£o pelo analisador l√≥gico, eu n√£o peguei o dispositivo mais digno, mas o chin√™s "beb√™".  Depois de definir os par√¢metros na janela do programa Terminal 1.9b, pude observar os bytes recebidos do ASM1051 MK durante sua opera√ß√£o. </p><br><img src="https://habrastorage.org/webt/fa/de/pc/fadepckvko4t2dyacaqt93hidao.png"><br><p>  <em>Janela do programa do terminal 1.9b durante a opera√ß√£o do adaptador</em> </p><br><p>  <strong><em>Conclus√£o:</em></strong> </p><br><p>  O ASM1051 MK possui um m√≥dulo de hardware UART.  O registro para o envio de dados tem o endere√ßo 0xC001.  A taxa de dados √© 921600 baud.  H√° um bit de parada.  A perna 41 √© Tx e a perna 40 √© Rx (embora isso n√£o seja preciso). </p><br><h2 id="nahodka--3">  Encontre o n√∫mero 3 </h2><br><p>  Percorrendo o c√≥digo no desmontador, adicionando coment√°rios, voc√™ pode encontrar constru√ß√µes mais dif√≠ceis do que escrever um n√∫mero em um registro.  Ent√£o, me deparei com um manipulador interessante, parte do qual em C, parecia <code>switch ()</code> . </p><br><img src="https://habrastorage.org/webt/zq/ra/nr/zqranrtexseqh7xpj0ynpjav9su.png"><br><p>  <em>O manipulador de comando do registro com o endere√ßo 0x800F</em> </p><br><p>  Entendendo que em algum lugar em algum lugar <a href="https://en.wikipedia.org/wiki/SCSI_command">os comandos SCSI</a> devem ser processados, comecei a procurar entre eles bytes com os quais o conte√∫do do registro com o endere√ßo 0x800F √© comparado na figura acima.  Os quatro primeiros ramos verificaram os comandos Read (10), Write (10), Read (16), Write (16).  N√£o h√° d√∫vida de que este √© um manipulador de comandos SCSI.  Em seguida, observei uma fun√ß√£o que √© chamada se o comando que entrou n√£o for Read / Write (u_Switch).  Ele, dependendo do byte no registrador com o endere√ßo 0x16A (o valor √© retirado de 0x800F), l√™ o endere√ßo para o qual obteremos quando eles sa√≠rem dessa fun√ß√£o.  Isso √© semelhante ao <code>switch ()</code> . </p><br><img src="https://habrastorage.org/webt/8c/ni/xf/8cnixfxf9a1bcyzv0ttlsgpmcqo.png"><br><p>  <em>Comandos do switch SCSI</em> </p><br><p>  Como j√° determinei o byte com o qual comparo o comando SCSI que entrou no adaptador, organizei rapidamente a correspond√™ncia de endere√ßos por comandos.  Assim, por exemplo, na figura acima, pode ser visto que se o byte 0x1A estivesse no registrador com o endere√ßo 0x16A, depois de sair da fun√ß√£o u_Switch, ir√≠amos para o endere√ßo 0x1B85.  Curiosamente, nem todos os bytes comparados com o u_Switch s√£o definidos no padr√£o SCSI.  Ou seja, o adaptador pode processar os bytes 0xE6 ou 0xDF, mas eles n√£o s√£o corrigidos pelo padr√£o. </p><br><p>  Como voc√™ pode ver, o adaptador pode executar comandos customizados e existem fun√ß√µes de manipulador para eles. </p><br><img src="https://habrastorage.org/webt/4m/kn/bz/4mknbzam6xol2fhb750trvrxs_c.png"><br><p>  <em>P√°gina 13 da <a href="https://usb.org/sites/default/files/usbmassbulk_10.pdf">Classe de armazenamento em massa de barramento serial universal</a></em> </p><br><p>  Preste aten√ß√£o no deslocamento <strong>0x0F em</strong> rela√ß√£o ao endere√ßo 0x8000.  Antes do processador, √© do registro com o endere√ßo 0x800F que o comando SCSI √© lido.  Se voc√™ ler atentamente a tabela na figura acima, poder√° ver que no CBW (Command Block Wrapper), o campo CBWCB tamb√©m possui um deslocamento de <strong>0x0F</strong> .  Acontece que os endere√ßos da mem√≥ria RAM do ASM1051, come√ßando com 0x8000, podem ser um buffer USB, conforme mostrado na tabela abaixo. </p><br><div class="scrollable-table"><table><thead><tr><th>  Endere√ßo de mem√≥ria </th><th>  Descri√ß√£o do produto </th></tr></thead><tbody><tr><td>  0x8000-0x8003 </td><td>  dCBWSignature (USBC - no caso de receber um pacote) </td></tr><tr><td>  0x8004-0x8007 </td><td>  dCBWTag </td></tr><tr><td>  0x8008-0x800B </td><td>  dCBWDataTransferLength </td></tr><tr><td>  0x800C </td><td>  bmdCBWFlag </td></tr><tr><td>  0x800D </td><td>  bCBWLUN </td></tr><tr><td>  0x800E </td><td>  bCBWCBLength </td></tr><tr><td>  0x800F-0x801F </td><td>  CBWCB - Comando SCSI e seus par√¢metros </td></tr></tbody></table></div><br><p>  A figura abaixo mostra a se√ß√£o de c√≥digo em que ocorre a compara√ß√£o com a cadeia USBC (deve ser a assinatura do dCBWSignature) e a assinatura proposta est√° localizada no endere√ßo 0x8000.  Eu acho que isso √© suficiente para garantir que o buffer USB esteja localizado na mem√≥ria RAM a partir de 0x8000. </p><br><img src="https://habrastorage.org/webt/-t/et/eo/-teteok9i6rotmpp1w6wxy0bun4.png"><br><p>  <em>Verifique o campo dCBWSignature para corresponder √† string USBC</em> </p><br><p>  <strong><em>Conclus√µes:</em></strong> </p><br><ol><li>  O MK ASM1051 pode lidar n√£o apenas com comandos SCSI, descritos na norma. </li><li>  O endere√ßo inicial do buffer USB √© 0x8000.  O comando SCSI est√° localizado no registrador com o endere√ßo 0x800F, o que significa que haver√° mais dados / argumentos dos comandos. </li></ol><br><h2 id="nahodka--4">  Encontre o n√∫mero 4 </h2><br><p>  Sabendo que o MK pode processar equipes n√£o padronizadas, eu queria saber o que estavam fazendo.  A maioria deles rapidamente me obedeceu.  N√£o citarei o estudo do c√≥digo desses comandos, pois isso pode levar muito tempo e pode ser material para um artigo separado intitulado ‚ÄúAssembler is simple‚Äù. Descreverei os resultados na tabela abaixo. </p><br><div class="scrollable-table"><table><thead><tr><th>  Comando SCSI </th><th>  Descri√ß√£o da equipe </th></tr></thead><tbody><tr><td>  0xE0 </td><td>  Permite que voc√™ leia os primeiros 0x80 bytes da ROM.  No futuro, chamarei essa parte da mem√≥ria de <em>pre√¢mbulo</em> (sim, os mesmos 0x80 bytes nos quais existem linhas <code>asmedia</code> e <code>ASM1051</code> ) </td></tr><tr><td>  0xE1 </td><td>  Grava os primeiros 0x80 bytes na ROM </td></tr><tr><td>  0xE3 </td><td>  Grava na mem√≥ria ROM de 0x80 endere√ßos qualquer n√∫mero de bytes.  O argumento (como se viu) √© o tamanho do pacote </td></tr><tr><td>  0xE4 </td><td>  L√™ o bloco de bytes da RAM do ASM1051.  Como argumento, pega o endere√ßo inicial e o n√∫mero de bytes que lemos </td></tr><tr><td>  0xE5 </td><td>  Grava um byte na RAM em </td></tr><tr><td>  0xE7 </td><td>  L√™ o √∫ltimo pacote recebido no buffer ATA. </td></tr><tr><td>  0xE8 </td><td>  Reinicia o dispositivo </td></tr></tbody></table></div><br><p>  Admito que n√£o descobri todos os comandos lendo as fun√ß√µes na IDA.  Tendo esbarrado na parede durante a pesquisa, lembrei-me de ter visto <a href="https://www.usbdev.ru/files/asmedia/asm105mptool/">software e muitos firmware</a> para o ASM1051 quando estava procurando documenta√ß√£o sobre ele.  Usando o software encontrado, voc√™ pode atualizar o firmware e reiniciar o dispositivo.  Portanto, decidi que era hora de usar o <a href="https://www.syssoft.ru/HHD-Software/Device-Monitoring-Studio/">Device Monitoring Studio</a> e ver o que envia o PC ao adaptador durante a atualiza√ß√£o. </p><br><p>  Assim, foi poss√≠vel entender como ocorre o processo de atualiza√ß√£o do firmware: primeiro, o pre√¢mbulo √© enviado (com o comando 0xE1), depois o c√≥digo √© escrito com o comando 0xE3 e, em seguida, tudo isso √© polido pela reinicializa√ß√£o (o comando 0xE8).  Para uma atualiza√ß√£o r√°pida e conveniente, escrevi um script Python que insere as linhas necess√°rias no pre√¢mbulo, depois l√™ as somas de verifica√ß√£o e atualiza o dispositivo.  Agora n√£o preciso mais de um emulador, tive a oportunidade de fazer upload de firmware para o ASM1051 via USB, voc√™ pode devolver a ROM nativa √† placa. </p><br><p>  <strong><em>Conclus√µes</em></strong> </p><br><p>  Para atualizar o firmware, tr√™s comandos SCSI devem ser executados sequencialmente: 0xE1, 0xE3 e 0xE8. </p><br><h2 id="nahodka--5">  Encontre o n√∫mero 5 </h2><br><p>  Al√©m dos comandos n√£o documentados, era interessante observar os manipuladores dos comandos padr√£o. </p><br><img src="https://habrastorage.org/webt/be/9e/st/be9estiir9g45o0thkj4bacvsmm.png"><br><p>  <em>Movendo o terceiro bit do registro 0xC884 para o s√©timo bit do registro 0x8002</em> </p><br><p>  H√° um teste interessante no manipulador do comando MODE SENSE (10) SCSI.  A figura acima mostra parte do c√≥digo da fun√ß√£o.  Pode-se ver que o terceiro bit est√° sendo lido no registro <strong>0xC884</strong> .  Em seguida, o valor desse bit √© definido no registro em 0x8002. </p><br><p>  O interessante aqui √© que o registro <strong>0xC884</strong> n√£o foi inicializado em nenhum lugar do c√≥digo, o que significa que √© o hardware mais prov√°vel. </p><br><img src="https://habrastorage.org/webt/fc/mw/sh/fcmwsh6pa3zzkpbsfxxici-t4g4.jpeg"><br><p>  <em>Tabela 362 do <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">Manual de refer√™ncia de comandos SCSI</a></em> </p><br><p>  Al√©m disso, se voc√™ consultar a documenta√ß√£o <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">do comando SCSI</a> 0x5A (MODE SENSE), fica claro que o adaptador USB-SATA deve responder √† solicita√ß√£o MODE SENSE.  O terceiro byte da resposta cont√©m o s√©timo bit do WP (prote√ß√£o contra grava√ß√£o - prote√ß√£o contra grava√ß√£o).  A prop√≥sito, eu j√° vi o <strong>s√©timo</strong> bit em 0x8002, e o <strong>deslocamento</strong> desde o in√≠cio do buffer USB (0x8000) √© exatamente <strong>3 aqui</strong> . </p><br><p>  <strong><em>Conclus√£o:</em></strong> </p><br><p>  O adaptador USB-SATA testado l√™ o terceiro bit no registro de hardware em <strong>0xC884</strong> e o envia ao host USB como um bit WP. </p><br><h2 id="nahodka--6">  Encontre o n√∫mero 6 </h2><br><p>  O registro de hardware encontrado durante a investiga√ß√£o do manipulador de comando MODE SENSE SCSI √© muito semelhante ao GPIO.  Para confirmar isso, decidi tocar as pernas do ASM1051 com um resistor ativo e ler o valor do registro (comando SCSI 0xE4) com o endere√ßo <strong>0xC884</strong> .  Para fazer isso, escrevi um script Python usando comandos SCSI personalizados que monitoram o valor no registro <strong>0xC884</strong> e o exibem no PC. </p><br><div class="scrollable-table"><table><thead><tr><th>  Bits 0xC884 </th><th>  7 </th><th>  6 </th><th>  5 </th><th>  4 </th><th>  3 </th><th>  2 </th><th>  1 </th><th>  0 0 </th></tr></thead><tbody><tr><td>  Perna ASM1051 </td><td>  - </td><td>  - </td><td>  37. </td><td>  - </td><td>  9 </td><td>  10 </td><td>  45 </td><td>  44 </td></tr></tbody></table></div><br><p>  Ap√≥s realizar tal experimento, compilei uma tabela na qual exibi quais bits no registro <strong>0xC884 foram</strong> alterados quando o resistor ASM1051 tocou as pernas.  Acontece que o registro em estudo est√° intimamente conectado ao GPIO, mas a tentativa de grav√°-lo (com o comando SCSI 0xE5) n√£o teve √™xito - o valor n√£o foi alterado. </p><br><p>  Decidi que esse registro √© somente leitura ou que √© proibido escrever em algum lugar no n√≠vel do hardware.  Se, por exemplo, as pernas MK foram configuradas inicialmente apenas para leitura, provavelmente a grava√ß√£o no registro <strong>0xC884</strong> poderia estar indispon√≠vel. </p><br><p>  Em geral, para encontrar os registros associados ao GPIO, repassei o c√≥digo de inicializa√ß√£o MK.  <strong>Anotei</strong> todos os registros cujos endere√ßos est√£o pr√≥ximos de <strong>0xC884</strong> .  Eu tenho cerca de 10. Lembramos que a d√©cima perna do MK est√° conectada ao LED na placa, corresponde ao segundo bit no registro <strong>0xC884</strong> .          ‚Äì <strong>0880</strong> ,            (,    ).  ,   ,   <strong>0880</strong>      (/),   <strong>0884</strong>   ,  - . </p><br><p>         <strong>0880</strong>    ,    <strong>0884</strong>    .     <strong>0884</strong>  .           ASM1051. </p><br><p> <strong><em>:</em></strong> </p><br><p>    GPIO  ASM1051.    <strong>0880</strong>   /   I/O.  0884    I/O. </p><br><h2 id="nahodka--5-prodolzhenie">  ‚Ññ 5.  </h2><br><p>   GPIO-  ,  45-           <strong>0884</strong> .           <strong>WP</strong> ,    USB.       45-    ,    HDD,     ,  . </p><br><img src="https://habrastorage.org/webt/9m/yq/lv/9myqlvzd8guku1qfcllendjrtcc.png"><br><p> <em>     HDD,      45-  </em> </p><br><p>     .       GND 45-      ,      HDD.     . </p><br><p> <strong><em></em></strong> </p><br><p>   45-  ASM1051         HDD. </p><br><h1 id="razrabotka-sobstvennogo-ustroystva">    </h1><br><p>       USB-SATA-.           ASM1051.   ,  -  ,     .   ,     GPIO.    ‚Äì  ASM1051  ,         HDD. ,   ,     (¬´     ¬ª),     ,  ,         USB-SATA-   ASM1051. </p><br><p> ,           footprint  ASM1051,       datasheet  ASM1053.     ,        ASM1051   . </p><br><img src="https://habrastorage.org/webt/mf/9k/pi/mf9kpiav5oxxejflxjfndixzccy.jpeg"><br><p> <em>ASM1051     </em> </p><br><p>    ,       3D- ,    . </p><br><img src="https://habrastorage.org/webt/4n/vk/ea/4nvkearirndsx2wx6lzbv2--iu0.png"><br><p> <em>3D-      </em> </p><br><p>            <strong>WP</strong> .  GPIO ASM1051      ,   UART.  ,      SATA,     HDD.      USB 3.0 Micro-B     Type-C.  HDD      USB,   HDD 3.5"  +12 ,           12  21 .     . </p><br><img src="https://habrastorage.org/webt/zh/ji/wu/zhjiwuyqzibs09gswjbdlths-_g.jpeg"><br><p> <em>    </em> </p><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p>       ,       . </p><br><p>           -,    ,   .         ¬´ ¬´¬ª,          .        ,       . </p><br><p>   ,    (,   )   embedded-. ,  ,       .      ,    ,    , ,         . </p><br><p>       ,   datasheets,    ,   .       ,  <strong>   !</strong> </p><br><p> <a href="https://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p> <em>Raccoon Security ‚Äì     ¬´¬ª     , , ,       .</em> <br> <em>        ,         ,     .       <a href="https://raccoonsecurity.ru/internship/"></a> .</em> </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485966/">https://habr.com/ru/post/pt485966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485950/index.html">Epidemia e censura: as autoridades chinesas est√£o tentando restringir a dissemina√ß√£o de informa√ß√µes sobre o coronav√≠rus?</a></li>
<li><a href="../pt485952/index.html">Interface CLI para o Laravel Artisan</a></li>
<li><a href="../pt485954/index.html">Resumo do Java em 28 de janeiro</a></li>
<li><a href="../pt485958/index.html">[Resumo do administrador] E se o programa quiser direitos de administrador e voc√™ n√£o</a></li>
<li><a href="../pt485962/index.html">Pesquisa pessoal em 2019-nCoV</a></li>
<li><a href="../pt485968/index.html">E novamente ignorar bloqueios. RouterOS + BGP + OSPF</a></li>
<li><a href="../pt485970/index.html">Trinta principais entrevistas recentes: desenvolvimento, design, sciencepop e estilo de vida</a></li>
<li><a href="../pt485972/index.html">M√©todos de An√°lise de Regress√£o em Ci√™ncia de Dados</a></li>
<li><a href="../pt485974/index.html">Modem Raspberry Pi e SIM7600E 4G HAT</a></li>
<li><a href="../pt485986/index.html">As 5 principais tend√™ncias de localiza√ß√£o em 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>