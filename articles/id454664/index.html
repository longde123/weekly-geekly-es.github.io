<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏼 👏 📊 Mainkan Tetris in AR 🧐 ⚾️ 🗺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terpikir oleh saya suatu gagasan aneh bahwa rumah itu bisa menjadi platform yang baik untuk bermain Tetris. Tidak jauh dari saya hanya ada satu bangun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mainkan Tetris in AR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454664/">  Terpikir oleh saya suatu gagasan aneh bahwa rumah itu bisa menjadi platform yang baik untuk bermain Tetris.  Tidak jauh dari saya hanya ada satu bangunan yang cocok untuk ini.  Hasilnya bisa dilihat di video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/eGaokauVQ2o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Proyek ini dilaksanakan pada tingkat yang cukup rendah, tanpa menggunakan solusi yang sudah jadi. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber</a> <br><a name="habracut"></a><br>  Paling sering mereka menggunakan 2 opsi untuk mengimplementasikan augmented reality: <br><br><ul><li>  tanpa penanda, mis.  posisi kamera ditentukan oleh pergerakan titik-titik utama dari aliran videonya; </li><li>  gambar sebagai penanda relatif terhadap posisi kamera. </li></ul><br>  Implementasi ini tidak memerlukan persiapan khusus atau kondisi khusus. <br><br>  Ada opsi implementasi lain - untuk mengenali objek tertentu dan menggunakannya sebagai penanda.  Ini membutuhkan setidaknya kehadirannya, tetapi memungkinkan untuk mengontrolnya secara visual.  Salah satu metode pengenalan tersebut adalah deteksi objek dengan tepi.  Ini memiliki keterbatasan - objek penanda harus memiliki tepi yang jelas, mis.  objek kemungkinan besar harus padat. <br><br>  Atau ujung-ujungnya harus digambarkan dengan jelas, seperti penerangan gedung ini: <br><br><img src="https://habrastorage.org/webt/51/y8/nt/51y8ntbjtnm_hdy6iy5v2pmwgsu.jpeg"><br><br>  Dapat dilihat bahwa lampu latar dapat dengan mudah dipisahkan dalam gambar dan digunakan untuk deteksi. <br><br><h2>  Implementasi </h2><br>  Pada Qt.  Kerangka kerja ini memungkinkan Anda untuk bekerja pada platform yang berbeda dan pada saat yang sama dalam C ++.  Karena kinerja penting bagi kami, pro sepertinya pilihan yang jelas. <br><br>  Meskipun Qt tidak bekerja dengan baik dengan android (peluncuran panjang, debugging dinonaktifkan), tetapi ini semua diratakan oleh kemampuan untuk debug algoritma pada desktop. <br><br>  Grafik tiga dimensi divisualisasikan pada OpenGL mentah yang disematkan pada Qt. <br><br>  Bekerja dengan kamera dilakukan melalui Qt.  Video direkam untuk debugging, dan cukup nyaman untuk mengganti aliran video kamera dengan aliran video dari file. <br><br>  Output dilakukan melalui alat qml.  Untuk berteman qml dan OpenGL bukan tanpa masalah, tapi kami tidak akan memikirkan hal ini. <br><br>  Untuk pemrosesan gambar, pustaka OpenCV terhubung. <br><br><h4>  Algoritma Pelacakan </h4><br>  Sekarang mari kita beralih ke bagian yang paling menarik - algoritma untuk melacak objek di sepanjang tepinya. <br>  Dan mulailah dengan menyorot bagian tepi pada gambar.  Semua tepi dalam kasus kami memiliki bentuk garis lurus, jadi pikiran pertama yang terlintas dalam pikiran adalah menggunakan detektor garis.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transformasi Hough</a> dapat digunakan sebagai detektor garis.  Namun, cara ini menurut saya tidak terlalu benar, karena transformasi Hough cukup mahal, dan detektor ini sangat tidak dapat diandalkan (ini subjektif, mungkin semuanya tergantung pada tugas). <br>  Sebagai gantinya, mari kita pergi dengan cara yang berbeda, lebih umum.  Kami tidak akan mempertimbangkan bahwa garis kami lurus, tetapi kami akan bekerja hanya pada gambar biner.  Kehadiran tepi akan dikodekan ke dalam gambar biner.  Yaitu  piksel dengan nilai nol berarti ada tepi di tempat ini, nilai piksel lebih besar dari nol - tidak ada tepi.  Gambar seperti itu dapat diperoleh dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">detektor batas Canny</a> atau menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transformasi ambang batas</a> sederhana.  Algoritma ini dapat ditemukan di OpenCV. <br><br>  OpenCV juga memiliki fungsi lain yang berguna bagi kita sekarang - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">distanceTransform</a> , yang mengambil gambar biner pada input dan memberikan gambar pada output, dalam piksel yang jaraknya ke nol piksel terdekat dikodekan. <br><br>  Sekarang anggaplah kita sudah memiliki perkiraan baik pertama tentang di mana model kita seharusnya berada.  Selanjutnya, kami menggambarkan fungsi kesalahan, yang menggambarkan seberapa jauh tepi perkiraan kami tidak sesuai dengan tepi pada gambar yang dihasilkan.  Menggunakan gambar dari distanceTransform kita sudah dapat melakukan ini.  Dan kemudian kita menjalankan algoritma optimasi fungsi, hanya mengubah perkiraan posisi objek di ruang angkasa.  Akibatnya, perkiraan kami harus cukup akurat menggambarkan posisi sebenarnya dari objek. <br>  Hasilnya, algoritme dapat dibagi menjadi dua tahap: <br><br><ol><li>  Preprocessing gambar - binarisasi, pemfilteran, dan penggunaan fungsi distanceTransfrom. </li><li>  Pelacakan - optimalisasi fungsi kesalahan. </li></ol><br><h4>  Pra-pemrosesan gambar </h4><br>  Pada titik ini, Anda perlu menyorot tepi pada gambar.  Anda dapat menggunakan detektor batas Canny, tetapi dalam kasus kami, konversi ambang biasa atau versi adaptifnya bekerja lebih baik (di OpenCV, ini adalah fungsi ambang batas atau fungsi adaptif).  Jelas bahwa akan ada noise pada gambar seperti itu, sehingga penyaringan diperlukan.  Mari kita lakukan sebagai berikut - pilih kontur menggunakan fungsi OpenCV <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">findCountour</a> dan hapus segmen yang terlalu kecil atau tidak cukup seperti garis. <br><br>  Hasil pemrosesan dapat dilihat pada gambar: <br><br><img src="https://habrastorage.org/webt/ef/g9/ts/efg9tspnpbvzqb1gn2o0cricah8.jpeg"><br><br>  Secara konsisten: gambar asli -&gt; setelah transformasi ambang -&gt; setelah pemfilteran. <br><br>  Gambar ini sudah cukup jelas memberi tahu kita di mana ada tepi kanan dan di mana tidak.  Setelah itu, kami menggunakan fungsi distanceTransform, dan sebagai hasilnya, kami akan memiliki informasi tentang seberapa jauh setiap titik dari tepi.  Gambar yang dihasilkan dilambangkan sebagai <img src="https://habrastorage.org/webt/qt/cr/xz/qtcrxzl1ow1zbp0xoducghnxhms.png">  . <br><br>  Ini adalah tampilannya jika dinormalisasi dan divisualisasikan: <br><br><img src="https://habrastorage.org/webt/ho/ll/vm/hollvmy8tp4ozcc424szu5pjjuc.jpeg"><br><br>  Selanjutnya, kita akan membutuhkan beberapa alat matematika. <br><br><h5>  Algoritma Pengoptimalan Fungsi </h5><br>  Optimalisasi fungsi adalah tugas menemukan minimum suatu fungsi. <br><br>  Jika kita berurusan dengan sistem persamaan linear, maka menemukan minimum adalah cukup sederhana.  Bayangkan sistem persamaan dalam bentuk matriks: <img src="https://habrastorage.org/webt/8o/ib/1o/8oib1oj6a6trr7kkhjozgiy3day.png">  , maka solusi kami: <img src="https://habrastorage.org/webt/ly/rc/qu/lyrcqutfkhebqb6tqlrfix5d1ms.png">  .  Jika kita memiliki sistem persamaan yang terlalu ditentukan, maka kita dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode kuadrat terkecil</a> : <img src="https://habrastorage.org/webt/ll/4i/ok/ll4iok4um66gxr9zxre_lxlyylm.png">  . <br><br>  Jika fungsi kita non-linear, maka tugasnya menjadi lebih rumit.  Untuk menemukan minimum, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Gauss-Newton</a> .  Algoritma bekerja sebagai berikut: <br><br><ol><li>  Diasumsikan bahwa kita sudah memiliki beberapa perkiraan awal dari solusi <img src="https://habrastorage.org/webt/mg/yf/5k/mgyf5kyuniayj8w1_veck_sgciq.png">  yang kita akan memperbaiki berulang. </li><li>  Dengan menggunakan ekspansi Taylor, kita dapat memperkirakan fungsi nonlinear linear pada titik perkiraan saat ini.  Kami memecahkan sistem persamaan linear yang dihasilkan dengan metode kuadrat terkecil, memperoleh <img src="https://habrastorage.org/webt/_l/so/zd/_lsozdiipx0ny5krc_nvtsklixq.png">  .  Akibatnya, solusi yang dihasilkan tidak akan menjadi solusi, tetapi akan lebih dekat daripada perkiraan saat ini. </li><li>  Ganti perkiraan saat ini <img src="https://habrastorage.org/webt/mg/yf/5k/mgyf5kyuniayj8w1_veck_sgciq.png">  menerima keputusan <img src="https://habrastorage.org/webt/_l/so/zd/_lsozdiipx0ny5krc_nvtsklixq.png">  dan lanjutkan ke langkah 2. Jadi ulangi sampai selisihnya <img src="https://habrastorage.org/webt/n_/t0/bp/n_t0bpjlwogupz25g2toyse8w60.png">  dan <img src="https://habrastorage.org/webt/2u/gv/-3/2ugv-3nsnzjslkonizusvzbgbuo.png">  tidak akan kurang dari nilai tertentu. </li></ol><br>  Mari kita menganalisis algoritma lebih terinci. <br><br>  Biarkan <img src="https://habrastorage.org/webt/vc/j3/mp/vcj3mpo1jjwkew5a0enemocdyoq.png">  - fungsi kerja, <img src="https://habrastorage.org/webt/i5/uo/zz/i5uozzwwbb4_f-ivitxfs2qferi.png">  - vektor nilai fungsi yang sebelumnya diketahui.  Dengan solusi sempurna untuk persamaan <img src="https://habrastorage.org/webt/ht/2u/lo/ht2ulowooc32s10ajclpbeug1w4.png">  pernyataan berikut ini benar <img src="https://habrastorage.org/webt/m-/dk/pv/m-dkpv_tnys9clufhps155qfxkq.png">  .  Tapi kami hanya memiliki perkiraannya saja <img src="https://habrastorage.org/webt/mg/yf/5k/mgyf5kyuniayj8w1_veck_sgciq.png">  .  Kemudian vektor kesalahan dari pendekatan ini dilambangkan sebagai: <img src="https://habrastorage.org/webt/_v/d4/n1/_vd4n1yd6irh6smzqcnpswmmbjm.png">  .  Kesalahan umum dari fungsi ini adalah: <img src="https://habrastorage.org/webt/8d/lf/me/8dlfmeklxb1jvlffcyk8w0vb478.png">  .  Sekarang menemukan itu <img src="https://habrastorage.org/webt/n_/t0/bp/n_t0bpjlwogupz25g2toyse8w60.png">  dimana <img src="https://habrastorage.org/webt/xl/um/pw/xlumpww55az0itxqrtigh2qofqg.png">  akan mencapai minimum, kita akan mendapatkan perkiraan solusi yang lebih baik <img src="https://habrastorage.org/webt/ht/2u/lo/ht2ulowooc32s10ajclpbeug1w4.png">  . <br>  Mulai dari pendekatan <img src="https://habrastorage.org/webt/mg/yf/5k/mgyf5kyuniayj8w1_veck_sgciq.png">  kami akan memperkirakannya secara iteratif, mencapai setiap iterasi <img src="https://habrastorage.org/webt/n_/t0/bp/n_t0bpjlwogupz25g2toyse8w60.png">  .  Untuk melakukan ini, kita perlu setiap iterasi untuk menghitung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">matriks Jacobi</a> untuk fungsi <img src="https://habrastorage.org/webt/vc/j3/mp/vcj3mpo1jjwkew5a0enemocdyoq.png">  untuk perkiraan saat ini, terdiri dari turunan dari fungsi kami: <br><img src="https://habrastorage.org/webt/m1/g0/g-/m1g0g-jmv04dlsbyoivbvjbwpwi.png"><br>  Dan perkiraan berikut diberikan sebagai: <img src="https://habrastorage.org/webt/lm/xc/y4/lmxcy4rjlhtxgwz_lb8kpi1cpys.png">  . <br>  Seringkali tugas dibangun sedemikian rupa sehingga kita memiliki sejumlah besar data yang tidak saling tergantung (hanya dari nilai-nilai saja <img src="https://habrastorage.org/webt/ht/2u/lo/ht2ulowooc32s10ajclpbeug1w4.png">  )  Akibatnya, matriks Jacobi umum sangat jarang.  Ada cara untuk mengoptimalkan perhitungan. <br>  Misalkan fungsi umum dihitung dari seperangkat poin.  Dari titik <i>jth</i> kita dapatkan <img src="https://habrastorage.org/webt/29/lv/wk/29lvwk822xw4y0xlriuxrxx4gli.png">  .  Alih-alih menghitung matriks Jacobi <img src="https://habrastorage.org/webt/fu/vl/ui/fuvluirwbxatvxammyfzrbkxwug.png">  untuk keseluruhan fungsi, kami menghitung matriks Jacobi khusus untuk <img src="https://habrastorage.org/webt/29/lv/wk/29lvwk822xw4y0xlriuxrxx4gli.png">  dan menyatakannya sebagai: <img src="https://habrastorage.org/webt/zf/al/h0/zfalh0ntw3nupwu56dhc7u0fzn0.png">  .  Maka perkiraan berikut akan diberikan sebagai berikut: <img src="https://habrastorage.org/webt/hl/2k/d6/hl2kd6neuqqtrclxyf6efubd8by.png">  .  Selain itu, perubahan ini memungkinkan Anda untuk memparalelkan perhitungan. <br>  Mungkin saja terjadi nilai berikut <img src="https://habrastorage.org/webt/2u/gv/-3/2ugv-3nsnzjslkonizusvzbgbuo.png">  akan memberikan kesalahan lebih besar dari <img src="https://habrastorage.org/webt/n_/t0/bp/n_t0bpjlwogupz25g2toyse8w60.png">  .  Untuk mengatasi masalah ini, Anda dapat menggunakan modifikasi algoritma - algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Levenberg-Marquardt</a> .  Nilai tambah <img src="https://habrastorage.org/webt/zi/jx/hs/zijxhs_ibqcwfjnfdefeoh7fwqu.png">  ke dalam formula kami: <img src="https://habrastorage.org/webt/d-/jv/hi/d-jvhiklwzbaxqihirj97fnyvg4.png">  dimana <img src="https://habrastorage.org/webt/hp/qi/1y/hpqi1yohaku8yblniy_qjap0ghe.png">  Merupakan matriks satuan.  Nilai <img src="https://habrastorage.org/webt/zi/jx/hs/zijxhs_ibqcwfjnfdefeoh7fwqu.png">  dipilih sebagai berikut: <br><ul><li>  pertama, ia memiliki beberapa nilai yang agak kecil (sedemikian rupa sehingga konvergensi algoritma); </li><li>  lalu jika ada kesalahan untuk <img src="https://habrastorage.org/webt/2u/gv/-3/2ugv-3nsnzjslkonizusvzbgbuo.png">  lebih dari <img src="https://habrastorage.org/webt/n_/t0/bp/n_t0bpjlwogupz25g2toyse8w60.png">  , lalu tambah nilainya <img src="https://habrastorage.org/webt/zi/jx/hs/zijxhs_ibqcwfjnfdefeoh7fwqu.png">  dan coba hitung kesalahan untuk <img src="https://habrastorage.org/webt/2u/gv/-3/2ugv-3nsnzjslkonizusvzbgbuo.png">  lagi. </li></ul><br>  Semakin non-linear fungsinya <img src="https://habrastorage.org/webt/vc/j3/mp/vcj3mpo1jjwkew5a0enemocdyoq.png">  semakin besar nilainya <img src="https://habrastorage.org/webt/zi/jx/hs/zijxhs_ibqcwfjnfdefeoh7fwqu.png">  .  Namun semakin besar nilainya <img src="https://habrastorage.org/webt/zi/jx/hs/zijxhs_ibqcwfjnfdefeoh7fwqu.png">  , semakin lambat konvergensi algoritma. <br><br>  Kami menyelesaikan algoritme kapan <img src="https://habrastorage.org/webt/2u/gv/-3/2ugv-3nsnzjslkonizusvzbgbuo.png">  berbeda dari <img src="https://habrastorage.org/webt/n_/t0/bp/n_t0bpjlwogupz25g2toyse8w60.png">  cukup kecil dan ambil <img src="https://habrastorage.org/webt/2u/gv/-3/2ugv-3nsnzjslkonizusvzbgbuo.png">  sebagai solusi. <br><br>  Algoritma ini cukup universal dan dapat digunakan untuk berbagai tugas. <br><br><h5>  Model Pelacakan Matematika </h5><br>  Karena kita berhadapan dengan koordinat dalam ruang, jelas bahwa kita harus dapat memanipulasi koordinat ini.  Misalkan kita memiliki beberapa set poin <img src="https://habrastorage.org/webt/pi/mv/hb/pimvhb7w8_hegkijjpdddui99ts.png">  .  Dan kita perlu memutarnya di titik dengan nol koordinat.  Mungkin cara termudah adalah dengan menggunakan matriks rotasi <i>R</i> , yang menggambarkan rotasi yang diperlukan: <img src="https://habrastorage.org/webt/dn/qr/lf/dnqrlfvvkeyngvdbbqy8uwnbgyk.png">  .  Jika kita perlu menggeser titik, maka tambahkan saja vektor yang diinginkan <i>t</i> : <img src="https://habrastorage.org/webt/ds/qc/jc/dsqcjcik5lk13aheb3_q78x8x6s.png">  . <br>  Dengan demikian, Anda dapat mengubah posisi suatu objek dalam ruang secara sewenang-wenang.  Ternyata koordinat objek ditentukan oleh matriks tiga dimensi <i>R</i> dan vektor tiga dimensi <i>t</i> , mis.  12 parameter.  Selain itu, parameter-parameter ini tidak independen satu sama lain, komponen-komponen dari matriks rotasi saling berhubungan oleh kondisi tertentu.  Oleh karena itu, dari sudut pandang penggunaan fungsi-fungsi ini dalam optimasi, parameter ini bukan solusi terbaik.  Ada lebih banyak parameter daripada derajat kebebasan, ada hubungan di antara mereka.  Ada bentuk rotasi lain - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rumus rotasi Rodrigue</a> .  Rotasi ini ditentukan oleh tiga parameter, membentuk vektor tiga dimensi. <br><br>  Vektor yang dinormalisasi adalah sumbu rotasi, dan panjang vektor ini adalah sudut rotasi di sekitar sumbu ini. <br><br>  Kami mengatur fungsi rotasi vektor <i>v</i> : <img src="https://habrastorage.org/webt/kl/hc/cz/klhccza_fs2fv8gmvh3uovdnzvw.png">  menggunakan parameter <i>r</i> dari rumus Rodrigue.  Kami mendapatkan formula berikut dari ini: <img src="https://habrastorage.org/webt/_s/sg/p1/_ssgp1pn5q49yx32g-zkluqkn8u.png">  . <br>  Dan pada akhirnya, kita dapat mengatur koordinat posisi objek dengan vektor 6 dimensi: <img src="https://habrastorage.org/webt/mb/mo/dl/mbmodlujklivexjnp7zo0eyup_o.png"><br>  Kami mendapatkan formula berikut: <img src="https://habrastorage.org/webt/ih/ls/hx/ihlshxts9oar5kcqw4l0a0ilj1w.png">  . <br><br><h5>  Model kamera lubang jarum </h5><br>  Sekarang kami menggambarkan model matematika sederhana dari kamera yang digunakan dalam proyek: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;vec&amp;#xA0;{p}&amp;#xA0;=&amp;#xA0;\&amp;#xA0;begin&amp;#xA0;{pmatrix}&amp;#xA0;p_x&amp;#xA0;&amp;amp;&amp;#xA0;p_y&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{pmatrix}&amp;#xA0;^&amp;#xA0;T&amp;#xA0;=&amp;#xA0;cam&amp;#xA0;(\&amp;#xA0;vec&amp;#xA0;{v})&amp;#xA0;=&amp;#xA0;\&amp;#xA0;begin&amp;#xA0;{pmatrix}&amp;#xA0;f_x&amp;#xA0;\&amp;#xA0;frac&amp;#xA0;{v_x}&amp;#xA0;{v_z}&amp;#xA0;+&amp;#xA0;c_x&amp;#xA0;&amp;amp;&amp;#xA0;f_y&amp;#xA0;\&amp;#xA0;frac&amp;#xA0;{v_y}&amp;#xA0;{v_z}&amp;#xA0;+&amp;#xA0;c_y&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{pmatrix}&amp;#xA0;^&amp;#xA0;T</mtext></merror></math>" role="presentation"><span class="noError" style="display: inline-block;" aria-hidden="true">\&nbsp;vec&nbsp;{p}&nbsp;=&nbsp;\&nbsp;begin&nbsp;{pmatrix}&nbsp;p_x&nbsp;&amp;&nbsp;p_y&nbsp;\&nbsp;end&nbsp;{pmatrix}&nbsp;^&nbsp;T&nbsp;=&nbsp;cam&nbsp;(\&nbsp;vec&nbsp;{v})&nbsp;=&nbsp;\&nbsp;begin&nbsp;{pmatrix}&nbsp;f_x&nbsp;\&nbsp;frac&nbsp;{v_x}&nbsp;{v_z}&nbsp;+&nbsp;c_x&nbsp;&amp;&nbsp;f_y&nbsp;\&nbsp;frac&nbsp;{v_y}&nbsp;{v_z}&nbsp;+&nbsp;c_y&nbsp;\&nbsp;end&nbsp;{pmatrix}&nbsp;^&nbsp;T</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;vec&nbsp;{p}&nbsp;=&nbsp;\&nbsp;begin&nbsp;{pmatrix}&nbsp;p_x&nbsp;&amp;&nbsp;p_y&nbsp;\&nbsp;end&nbsp;{pmatrix}&nbsp;^&nbsp;T&nbsp;=&nbsp;cam&nbsp;(\&nbsp;vec&nbsp;{v})&nbsp;=&nbsp;\&nbsp;begin&nbsp;{pmatrix}&nbsp;f_x&nbsp;\&nbsp;frac&nbsp;{v_x}&nbsp;{v_z}&nbsp;+&nbsp;c_x&nbsp;&amp;&nbsp;f_y&nbsp;\&nbsp;frac&nbsp;{v_y}&nbsp;{v_z}&nbsp;+&nbsp;c_y&nbsp;\&nbsp;end&nbsp;{pmatrix}&nbsp;^&nbsp;T</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ vec {p} = \ begin {pmatrix} p_x & p_y \ end {pmatrix} ^ T = cam (\ vec {v}) = \ begin {pmatrix} f_x \ frac {v_x} {v_z} + c_x & f_y \ frac {v_y} {v_z} + c_y \ end {pmatrix} ^ T </script></p>  dimana <img src="https://habrastorage.org/webt/4y/1n/eo/4y1neonrkqigjzoumocsltdvi-e.png">  - jarak fokus dalam piksel; <img src="https://habrastorage.org/webt/en/zb/z6/enzbz61iibgzcsxm0jtasbuek28.png">  - Pusat optik juga dalam piksel.  Ini adalah parameter kamera individu, yang disebut parameter intrinsik kamera.  Biasanya, parameter ini diketahui sebelumnya.  Dalam proyek ini, parameter ini dipilih oleh mata. <br><br>  Model ini tidak memperhitungkan distorsi lensa kamera ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">distorsi</a> ).  Misalkan tidak. <br><br>  Dengan model ini, kami mendapatkan proyeksi pusat, semua titik yang cenderung mengarah ke pusat optik, semakin jauh dari kamera mereka.  Dengan demikian kami memperoleh efek dari kereta api penyempitan: <br><br><img src="https://habrastorage.org/webt/3c/a2/gn/3ca2gngkegajdjw25-gm6zgy3_u.jpeg"><br><br>  Di ruang angkasa, kamera sejajar dengan sumbu <i>z</i> , bidang gambar sejajar dengan bidang <i>xy</i> .  Kami melengkapi model kami dengan kemampuan untuk bergerak di ruang angkasa: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>p</mi></mrow><mi>j</mi></msub><mo>=</mo><mi>c</mi><mi>a</mi><mi>m</mi><mo stretchy=&quot;false&quot;>(</mo><mi>m</mi><mi>e</mi><mi>m</mi><mi>b</mi><mi>u</mi><mi>s</mi><mi>u</mi><mi>k</mi><mo stretchy=&quot;false&quot;>(</mo><mtext>&amp;#xA0;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>x</mi></mrow><mi>r</mi></msub><mo>,</mo><mtext>&amp;#xA0;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>v</mi></mrow><mi>j</mi></msub><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mtext>&amp;#xA0;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>x</mi></mrow><mi>t</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="49.761ex" height="3.021ex" viewBox="0 -832 21424.9 1300.8" role="img" focusable="false" style="vertical-align: -1.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-76" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-65" x="735" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-63" x="1202" y="0"></use><g transform="translate(1635,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-70" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-6A" x="712" y="-326"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMAIN-3D" x="2808" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-63" x="3864" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-61" x="4298" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-6D" x="4827" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMAIN-28" x="5706" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-6D" x="6095" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-65" x="6974" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-6D" x="7440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-62" x="8319" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-75" x="8748" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-73" x="9321" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-75" x="9790" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-6B" x="10363" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMAIN-28" x="10884" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-76" x="11524" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-65" x="12009" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-63" x="12476" y="0"></use><g transform="translate(12909,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-72" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMAIN-2C" x="13901" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-76" x="14596" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-65" x="15082" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-63" x="15548" y="0"></use><g transform="translate(15982,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-76" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-6A" x="686" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMAIN-29" x="16859" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMAIN-2B" x="17471" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-76" x="18721" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-65" x="19207" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-63" x="19673" y="0"></use><g transform="translate(20107,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMATHI-74" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/454664/&amp;usg=ALkJrhiCy-YgdilUn_3En5INPTke093PBA#MJMAIN-29" x="21035" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class="MJX-TeXAtom-ORD"><mi>p</mi></mrow><mi>j</mi></msub><mo>=</mo><mi>c</mi><mi>a</mi><mi>m</mi><mo stretchy="false">(</mo><mi>m</mi><mi>e</mi><mi>m</mi><mi>b</mi><mi>u</mi><mi>s</mi><mi>u</mi><mi>k</mi><mo stretchy="false">(</mo><mtext>&nbsp;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class="MJX-TeXAtom-ORD"><mi>x</mi></mrow><mi>r</mi></msub><mo>,</mo><mtext>&nbsp;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class="MJX-TeXAtom-ORD"><mi>v</mi></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mtext>&nbsp;</mtext><mi>v</mi><mi>e</mi><mi>c</mi><msub><mrow class="MJX-TeXAtom-ORD"><mi>x</mi></mrow><mi>t</mi></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ vec {p} _j = cam (membusuk (\ vec {x} _r, \ vec {v} _j) + \ vec {x} _t) </script></p><br>  Dengan demikian, kami memperoleh model yang kami dapat dalam bentuk aljabar mensimulasikan proyeksi titik-titik dari dunia luar ke gambar kamera (dari koordinat dunia ke layar).  Bagi kami, parameter posisi relatif kamera di ruang angkasa tetap tidak diketahui dalam model ini. <img src="https://habrastorage.org/webt/ln/ib/-f/lnib-foisc9iu_aqy0wernf1xgu.png">  .  Parameter ini disebut parameter ekstrinsik kamera. <br><br><h5>  Pelacakan </h5><br>  Sudah diterapkan tanpa alat OpenCV.  Pertama, kita perlu mendapatkan fungsi kesalahan untuk solusi perkiraan kami, yang telah dijelaskan di atas.  Dan kami akan menulis perhitungannya secara bertahap: <br><br><ol><li>  Kami memilih tepi model pelacakan yang terlihat berdasarkan parameter perkiraan saat ini. </li><li>  Kami mengubah kumpulan tepi yang dipilih menjadi kumpulan poin yang tetap, untuk menyederhanakan perhitungan.  Sebagai contoh, dimungkinkan untuk mengambil jumlah poin ke-n dari setiap sisi, atau (pilihan yang lebih tepat) untuk memilih kuantitas sedemikian sehingga ada jarak tetap dalam piksel di antara titik-titik tersebut.  Kami akan menyebutnya titik kontrol (dalam proyek: controlPoint - titik kontrol dan controlPixelDistance - jarak tetap yang sama dalam piksel). </li><li>  Kami memproyeksikan titik kontrol pada gambar.  Berkat <i>distanceImage,</i> kita bisa mendapatkan jarak proyeksi titik kontrol ke tepi pada gambar.  Dalam kasus yang ideal, semua titik kontrol harus benar-benar terletak di tepi gambar, mis.  jarak ke tulang rusuk harus nol.  Berdasarkan ini, kami mendapatkan kesalahan untuk titik kontrol tertentu: <img src="https://habrastorage.org/webt/aj/yl/of/ajylofx-nqzxqkzyaaxwcczmd6a.png">  . </li><li>  Kami mendapatkan fungsi kesalahan berikut: <img src="https://habrastorage.org/webt/o8/u-/8w/o8u-8wwvnt2jhgyulfun8kyzh6k.png"></li></ol><br>  Sekarang tinggal mencari minimum <i>E.</i>  Untuk melakukan ini, kami menggunakan algoritma Levenberg-Marquardt yang dijelaskan di atas.  Seperti yang telah kita ketahui, algoritme membutuhkan perhitungan matriks Jacobi, yaitu  fungsi turunan.  Anda dapat menggunakan temuan numerik turunan.  Anda juga dapat menggunakan beberapa solusi yang sudah jadi untuk algoritma ini.  Namun, dalam proyek ini semuanya ditulis secara manual, jadi saya akan menjelaskan kesimpulan lengkap dari seluruh solusi. <br><br>  Untuk setiap titik kontrol, kami memperoleh persamaan yang tidak bergantung pada titik lainnya.  Telah dijelaskan di atas bahwa dalam hal ini dimungkinkan untuk mempertimbangkan persamaan-persamaan ini secara independen satu sama lain, menghitung matriks Jacobi secara khusus untuk masing-masingnya.  Kami akan menganalisisnya secara berurutan, menggunakan aturan diferensiasi fungsi kompleks: <br><br><img src="https://habrastorage.org/webt/qf/lm/3t/qflm3tr6vrmyirsufolpiwmlte4.png"><br><br>  Kami menunjukkan <img src="https://habrastorage.org/webt/_b/_i/i1/_b_ii1eklzapugxeahtbl7wwuky.png">  lalu <img src="https://habrastorage.org/webt/tr/pz/a-/trpza-t1j_sr_otvetkquuvnac8.png"><br><br><img src="https://habrastorage.org/webt/en/k3/2q/enk32qx_j0zgvqzujalzydlfxyi.png"><br><br>  Dari sini: <br><br><img src="https://habrastorage.org/webt/ld/nh/s1/ldnhs1vypzpsx_mxlu6wjat4qtm.png"><br><br>  Selanjutnya kami tunjukkan <img src="https://habrastorage.org/webt/dl/2z/q0/dl2zq0jren9jpbmbpoaexelsrhw.png">  dan <img src="https://habrastorage.org/webt/gb/kc/ps/gbkcpsry9q7nmsdz2kqpq-6br6y.png">  lalu: <br><img src="https://habrastorage.org/webt/et/_j/ez/et_jez8fzupc2jtpk3bhteevl7y.png"><br><br>  Turunan dari <i>distanceImage</i> adalah angka.  Dan untuk menghitung vektor <img src="https://habrastorage.org/webt/iq/ur/_3/iqur_3xmxhxrdeia7bnkmonogxi.png">  dan <img src="https://habrastorage.org/webt/z-/fy/qz/z-fyqzcgc19axrhujj5y6v0lxcm.png">  Anda perlu menemukan turunannya sesuai dengan rumus rotasi Rodrigue.  Saya menemukan Jacobian dengan rumus ini di publikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Formula ringkas untuk turunan rotasi 3-D di</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">koordinat eksponensial »Guillermo Gallego, Anthony Yezzi</a> : <br><br><img src="https://habrastorage.org/webt/lb/rr/cr/lbrrcr3knmrvyjbessogjsvjyos.png">  , <br>  di mana <i>R</i> adalah matriks rotasi yang diperoleh dengan rumus Rodrigue dari vektor rotasi <img src="https://habrastorage.org/webt/qz/bd/pe/qzbdpe7zjfanzdyip7acfhwgwvo.png">  ; <img src="https://habrastorage.org/webt/bn/9c/-b/bn9c-blmg7tsys7l83pbu-2upny.png">  - titik kita berputar;  <i>Saya</i> adalah matriks identitas; <img src="https://habrastorage.org/webt/lq/im/g6/lqimg6wecrfth32alae6l435sxk.png">  .  Seperti yang kita lihat di sini, kita memiliki pembagian dengan panjang vektor rotasi, dan jika vektornya nol, maka rumusnya tidak lagi berfungsi.  Ini mungkin disebabkan oleh fakta bahwa pada vektor nol sumbu rotasi tidak ditentukan.  Jika vektor rotasi sangat dekat dengan nol, maka kami menggunakan rumus ini: <img src="https://habrastorage.org/webt/sm/hk/dc/smhkdchm-zr63paet8-nm_jftwo.png">  . <br>  Masih melukis <img src="https://habrastorage.org/webt/iq/ur/_3/iqur_3xmxhxrdeia7bnkmonogxi.png">  dan <img src="https://habrastorage.org/webt/z-/fy/qz/z-fyqzcgc19axrhujj5y6v0lxcm.png">  (di sini indeks <i>j</i> dihilangkan): <br><br><img src="https://habrastorage.org/webt/nt/xz/lf/ntxzlffpi42xgp1imuodytk2bqc.png"><img src="https://habrastorage.org/webt/hx/nz/pb/hxnzpbadbgyhlb2doqetg7f4iea.png"><br>  Dengan demikian, kami memperoleh matriks Jacobi untuk titik yang kami butuhkan dan dapat menggunakannya untuk algoritma optimasi yang dijelaskan di atas. <br><br>  Ada beberapa masalah dengan algoritma ini.  Pertama, akurasi.  Hasilnya, posisi global kamera sedikit melonjak dari bingkai ke bingkai.  Anda bisa memperbaikinya sedikit.  Kami memiliki informasi apriori bahwa posisi kamera tidak dapat berubah secara dramatis dari bingkai ke bingkai.  Dan kita bisa mengurangi jitter ini dengan menambahkan persamaan tambahan ke fungsi. <br><br>  Harus diingat bahwa vektor perpindahan <i>t</i> tidak dalam kasus kami mengoordinasikan posisi global kamera.  Posisi global adalah titik lokal dengan nol koordinat, sehingga dapat diturunkan sebagai berikut: <br><br><img src="https://habrastorage.org/webt/ly/zk/bk/lyzkbkk1zig1yfqu2shk9ziogbc.png"><br><br>  Kami ingat posisi frame sebelumnya di <i>prevGlobalPosition</i> .  Sekarang posisi sebelumnya harus mendekati nol, yaitu  panjang vektor <img src="https://habrastorage.org/webt/hv/lb/ww/hvlbwwdmw-wcymqnyxvaosx75mc.png">  harus cukup kecil.  Yaitu  selain nilai-nilai perbedaan lainnya, vektor <i>d</i> juga harus diminimalkan.  Untuk menentukan tingkat pengaruh modifikasi ini, kami memperkenalkan nilainya <img src="https://habrastorage.org/webt/25/ij/uy/25ijuyi5965hui7hbmywcsgfnuy.png">  dan kalikan vektor <i>d</i> dengan menambahkan dengan <img src="https://habrastorage.org/webt/25/ij/uy/25ijuyi5965hui7hbmywcsgfnuy.png">  : <img src="https://habrastorage.org/webt/pc/eo/6_/pceo6_067ezk979vii2pi4ex8k4.png">  .  Yaitu  dalam algoritme pengoptimalan, kami juga meminimalkan vektor <i>d '</i> .  Tentu saja, untuk ini akan perlu untuk menghitung matriks Jacobi untuknya, yang diturunkan dengan cara yang sama seperti yang telah kita peroleh di atas untuk fungsi kesalahan umum. <br><br>  Masalah kedua dari algoritma adalah bahwa ia bisa macet di minimum lokal.  Dalam karya lain, masalah ini diselesaikan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">filter partikel.</a>  Dalam kasus kami, opsi ini ternyata, pada prinsipnya, cukup. <br><br><h4>  Bonus dari pelacakan objek </h4><br>  Mengetahui posisi dan bentuk objek, Anda dapat memanipulasi mereka secara visual, yang saya coba tunjukkan di video.  Objek itu terdistorsi menggunakan shader OpenGL.  Dengan bantuan model kami, saya memproyeksikan titik objek ke gambar, dan dengan demikian menerima warna titik ini.  Kemudian Anda dapat memindahkan titik ini, mendapatkan efek yang menarik - misalnya, morphing.  Namun, kita harus ingat bahwa dengan menggeser titik, perlu ada sesuatu yang tetap di tempatnya, jika tidak, inkonsistensi akan menjadi nyata.  Selain itu, tergantung pada kualitas pelacakan kami dan bentuk objek, kami akan menerima berbagai efek yang tidak diinginkan karena akumulasi kesalahan, yang masih akan terjadi.  Itu hanya perlu diperhitungkan entah bagaimana.  Dalam video yang disajikan di atas, saya ingin menunjukkan bahwa augmented reality dapat digunakan sedikit lebih luas dari sekadar memaksakan objek virtual pada gambar. <br><br>  Ngomong-ngomong, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vuforia SDK</a> mengimplementasikan pelacakan suatu objek berdasarkan bentuknya, meskipun saya tidak berpikir bahwa mungkin untuk mengimplementasikan proyek ini dengannya, karena tidak mungkin untuk menggunakan tepi yang ditentukan secara ketat dan tidak dapat dikaitkan dengan penerangan bangunan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454664/">https://habr.com/ru/post/id454664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454646/index.html">@Pythonetc kompilasi, Mei 2019</a></li>
<li><a href="../id454648/index.html">Kiat dan trik dari saluran Telegram saya @pythonetc, Mei 2019</a></li>
<li><a href="../id454652/index.html">Mesin jet pada printer 3D rumahan</a></li>
<li><a href="../id454658/index.html">Gadget Kecantikan - Bisnis Serius</a></li>
<li><a href="../id454662/index.html">Hati-hati pindah ke Belanda bersama istri dan hipoteknya. Bagian 1: Pencarian Pekerjaan</a></li>
<li><a href="../id454666/index.html">Software Defined Radio - bagaimana cara kerjanya? Bagian 7</a></li>
<li><a href="../id454668/index.html">Buku Masakan Pengembang: Resep DDD (Bagian 5, Proses)</a></li>
<li><a href="../id454670/index.html">Serial "Chernobyl": menonton dan berpikir</a></li>
<li><a href="../id454672/index.html">Kunci untuk memulai: perangkat lunak dan perangkat keras terbaik untuk forensik komputer</a></li>
<li><a href="../id454674/index.html">Pemantauan orang miskin atau pemantauan server dari konsol</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>