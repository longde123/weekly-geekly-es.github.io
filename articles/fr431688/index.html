<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚙 🗳️ 🛁 Comment Clang compile une fonction 👌🏼 📇 🏢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai prévu d'écrire un article sur la façon dont LLVM optimise une fonction, mais vous devez d'abord écrire comment Clang traduit C ou C ++ en LLVM. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment Clang compile une fonction</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431688/">  J'ai prévu d'écrire un article sur la façon dont LLVM optimise une fonction, mais vous devez d'abord écrire comment Clang traduit C ou C ++ en LLVM. <br><br><img src="https://habrastorage.org/webt/df/9y/a9/df9ya9didizcjaetap9tjvfymzo.jpeg" alt="image"><br><a name="habracut"></a><br><br>  Considérez les aspects de haut niveau sans plonger dans les profondeurs de Clang.  Je veux faire attention à la façon dont la sortie Clang est liée à l'entrée, alors que nous ne considérerons pas les fonctionnalités non triviales de C ++.  Nous utilisons cette petite fonction, que j'ai empruntée à d'excellentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conférences sur les optimisations cycliques</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_sorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; a[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Étant donné que Clang ne fait aucune optimisation et que LLVM IR a été initialement conçu pour fonctionner avec C et C ++, la conversion est relativement facile.  J'utiliserai Clang 6.0.1 (ou une version proche, car celle-ci n'a pas encore été publiée) sur x86-64. <br><br>  La ligne de commande est la suivante: <br><br><pre> <code class="bash hljs">clang++ is_sorted.cpp -O0 -S -emit-llvm</code> </pre> <br>  En d'autres termes: nous compilons le fichier is_sorted.cpp en C ++ et indiquons ensuite à la chaîne d'outils LLVM ce qui suit: n'optimisez pas, affichez l'assembleur en tant que représentation textuelle de LLVM IR.  LLVM IR est volumineux et ne peut pas être affiché ou analysé rapidement; un format de code binaire binaire est toujours préférable si une personne n'a pas besoin de regarder ce code.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici</a> l'intégralité du LLVM IR, nous allons le revoir en partie. <br><br>  Commençons par le haut du fichier: <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'is_sorted.cpp'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"is_sorted.cpp"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span></code> </pre> <br>  Le texte entier entre le point-virgule et la fin de la ligne est un commentaire, ce qui signifie que la première ligne ne fait rien, mais, si vous êtes intéressé, dans LLVM un «module» est une unité de compilation, un conteneur pour le code et les données.  La deuxième ligne ne devrait pas non plus nous déranger.  La troisième ligne décrit certaines hypothèses émises par le compilateur, elles ne jouent aucun rôle dans cet article, mais vous pouvez en lire plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La cible trois</a> est l'héritage de gcc et n'a plus besoin de nous. <br><br>  La fonction LLVM possède des attributs facultatifs: <br><br><pre> <code class="cpp hljs">; Function Attrs: noinline nounwind optnone uwtable</code> </pre> <br>  Certains d'entre eux (comme ceux-ci) sont pris en charge par le front-end, d'autres sont ajoutés plus tard par des passes d'optimisation.  Ces attributs n'ont rien à voir avec la signification du code, je ne les discuterai pas ici, mais vous pouvez les lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> si vous êtes intéressé. <br><br>  Et enfin, notre fonction: <br><br><pre> <code class="bash hljs">define zeroext i1 @_Z9is_sortedPii(i32* %a, i32 %n) <span class="hljs-comment"><span class="hljs-comment">#0 {</span></span></code> </pre> <br>  «Zeroext» signifie que la valeur de retour de la fonction (i1, un entier sur un seul bit) doit être étendue avec des zéros dans le backend à la largeur requise par l'ABI.  Vient ensuite le nom de la fonction «mutilé», puis la liste des paramètres, essentiellement les mêmes que dans le code C ++, sauf que i32 définit une variable 32 bits.  # 0 connecte la fonction au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">groupe d'attributs</a> à la fin du fichier. <br><br>  Voici la première unité de base: <br><br><pre> <code class="cpp hljs">entry: %retval = alloca i1, align <span class="hljs-number"><span class="hljs-number">1</span></span> %a.addr = alloca i32*, align <span class="hljs-number"><span class="hljs-number">8</span></span> %n.addr = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> %i = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32* %a, i32** %a.addr, align <span class="hljs-number"><span class="hljs-number">8</span></span> store i32 %n, i32* %n.addr, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond</code> </pre> <br>  Chaque instruction LLVM doit être située à l'intérieur de l'unité de base: un ensemble d'instructions qui a une entrée au début et une sortie à la fin.  La dernière instruction de l'unité de base doit être une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instruction de terminaison</a> : "échouer" dans l'unité de base suivante est inacceptable.  Chaque fonction doit avoir un bloc d'entrée qui n'a pas de prédécesseurs qui effectuent la transition vers ce bloc.  Ces <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">propriétés</a> et d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres</a> sont vérifiées lors de l'analyse infrarouge, ces vérifications peuvent également être appelées plusieurs fois au cours du processus de compilation par le «vérificateur de module».  Le vérificateur est utile pour le débogage lorsqu'une passe génère un IR non valide. <br><br>  Les quatre premières instructions de ce bloc de base sont «alloca»: allocation de mémoire de pile.  Les trois premiers créent des variables implicitement créées lors de la compilation, le quatrième - une variable de boucle.  Les variables ainsi allouées ne sont accessibles que via les instructions de chargement et de stockage.  Les trois instructions suivantes initialisent les trois emplacements de pile, a.addr et n.addr sont initialisés à l'aide des valeurs transmises à la fonction en tant que paramètres et i est initialisé à zéro.  La valeur de retour n'a pas besoin d'être initialisée, tout code qui n'est pas indéfini en C et C ++ devra s'en occuper.  La dernière instruction est une transition inconditionnelle vers l'unité de base suivante (nous ne sommes pas encore inquiets à ce sujet, la plupart des transitions inutiles seront supprimées par le backend LLVM). <br><br>  Vous pouvez vous demander: pourquoi Clang alloue-t-il des emplacements de pile pour a et n?  Pourquoi n'utilise-t-il pas simplement ces valeurs directement?  Dans cette fonction, comme a et n ne changent pas, une telle stratégie fonctionnera, mais ce cas sera pris en compte par l'optimiseur, et est en dehors de la compétence de Calng.  Si a et n peuvent être modifiés, ils doivent être en mémoire et ne doivent pas être des valeurs SSA, qui, par définition, ne peuvent prendre de valeur qu’à un point du programme.  Les cellules de mémoire sont en dehors du monde SSA et peuvent être modifiées à tout moment.  Cela peut sembler étrange, mais une telle solution vous permet d'organiser le travail de toutes les parties du compilateur de manière naturelle et efficace. <br><br>  Je pense à Clang comme un générateur de code SSA dégénéré qui satisfait toutes les exigences de SSA, mais uniquement parce que l'échange d'informations entre les unités de base se fait par la mémoire.  La génération de code non dégénéré nécessite une certaine attention et une certaine analyse, et les développeurs de Clang ont refusé de le faire afin de séparer les responsabilités de génération et d'optimisation du code.  Je n'ai pas vu les résultats de mesure, mais à ma connaissance, de nombreuses opérations de mémoire sont générées, puis, presque immédiatement, la plupart d'entre elles sont supprimées par l'optimiseur, sans entraîner de gros frais généraux de temps de compilation, <br><br>  Considérez comment la boucle for se traduit.  En termes généraux, cela ressemble à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (initializer; condition; modifier) { body }</code> </pre> <br>  Cela se traduit par quelque chose comme ceci: <br><br><pre> <code class="cpp hljs"> initializer <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND COND: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> BODY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> EXIT BODY: body modifier <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND EXIT:</code> </pre> <br>  Bien sûr, une telle traduction n'est pas spécifique à Clang, tout compilateur C et C ++ fait de même. <br><br>  Dans notre exemple, l'initialiseur de boucle s'effondre dans le bloc de base d'entrée.  L'unité de base suivante est une vérification de l'état de la boucle: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond: ; preds = %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc, %entry %<span class="hljs-number"><span class="hljs-number">0</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">1</span></span> = load i32, i32* %n.addr, align <span class="hljs-number"><span class="hljs-number">4</span></span> %sub = sub nsw i32 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %cmp = icmp slt i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %sub br i1 %cmp, label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.body, label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.end</code> </pre> <br>  Clang fait également un commentaire utile que ce bloc de base peut être atteint à partir de for.inc ou du bloc de base d'entrée.  Ce bloc charge i et n à partir de la mémoire, réduit n (l'indicateur nsw reflète la propriété du langage C que le débordement de signe n'est pas défini; sans cet indicateur LLVM utilise la sémantique du code supplémentaire), compare la valeur réduite avec i en utilisant le slt (signé moins que, signe moins que), puis finalement branchez-vous dans le bloc de base for.body ou for.end. <br><br>  L'entrée dans le corps de la boucle n'est possible qu'à partir du bloc for.cond: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.body: %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32*, i32** %a.addr, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %idxprom = sext i32 %<span class="hljs-number"><span class="hljs-number">3</span></span> to i64 %arrayidx = getelementptr inbounds i32, i32* %<span class="hljs-number"><span class="hljs-number">2</span></span>, i64 %idxprom %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %arrayidx, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = load i32*, i32** %a.addr, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">6</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %add = add nsw i32 %<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %idxprom1 = sext i32 %add to i64 %arrayidx2 = getelementptr inbounds i32, i32* %<span class="hljs-number"><span class="hljs-number">5</span></span>, i64 %idxprom1 %<span class="hljs-number"><span class="hljs-number">7</span></span> = load i32, i32* %arrayidx2, align <span class="hljs-number"><span class="hljs-number">4</span></span> %cmp3 = icmp sgt i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>, %<span class="hljs-number"><span class="hljs-number">7</span></span> br i1 %cmp3, label %<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.then, label %<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.end</code> </pre> <br>  Les deux premières lignes chargent a et i dans les registres SSA;  i s'étend ensuite à 64 bits et peut participer au calcul de l'adresse.  La commande <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">getelementptr</a> (ou gep pour faire court) est la commande LLVM connue pour sa prétention; elle a même sa propre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">section d'aide</a> .  Contrairement au langage machine, LLVM ne traite pas les pointeurs comme des entiers.  Cela facilite l'analyse d'alias et d'autres optimisations de mémoire.  Ce code charge un [i] et un [i + 1], les compare et effectue des branchements en fonction du résultat. <br><br>  Le bloc if.then enregistre 0 dans l'emplacement de pile pour la valeur de retour de la fonction et saute inconditionnellement au bloc de sortie de la fonction: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.then: store i1 <span class="hljs-literal"><span class="hljs-literal">false</span></span>, i1* %retval, align <span class="hljs-number"><span class="hljs-number">1</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> <br>  Le bloc else est trivial: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.end: br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc</code> </pre> <br>  Et le bloc pour en ajouter un à la variable de boucle est également très simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc: %<span class="hljs-number"><span class="hljs-number">8</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %inc = add nsw i32 %<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> store i32 %inc, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond</code> </pre> <br>  Ce code revient en arrière pour vérifier les conditions de boucle. <br><br>  Si la boucle se termine normalement, nous retournons vrai: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.end: store i1 <span class="hljs-literal"><span class="hljs-literal">true</span></span>, i1* %retval, align <span class="hljs-number"><span class="hljs-number">1</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> <br>  Et enfin, ce que nous avons chargé dans l'emplacement de pile de la valeur de retour est chargé et retourné: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span>: %<span class="hljs-number"><span class="hljs-number">9</span></span> = load i1, i1* %retval, align <span class="hljs-number"><span class="hljs-number">1</span></span> ret i1 %<span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre> <br>  Il n'y a rien de spécial à la fin de la fonction.  Le message s'est avéré plus long que je ne le pensais, dans le prochain article, nous envisagerons d'optimiser le niveau IR pour cette fonction. <br><br>  (Merci à Xi Wang et Alex Rosenberg pour les corrections envoyées) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431688/">https://habr.com/ru/post/fr431688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431674/index.html">Toile Nanoleaf: bientôt sur tous les murs</a></li>
<li><a href="../fr431676/index.html">Robot tactique: peut écouter et ne pas interrompre</a></li>
<li><a href="../fr431678/index.html">Il y a un développeur mobile dans la forêt, voit - Kotlin est en feu. Il s'est assis à Kotlin et a brûlé</a></li>
<li><a href="../fr431682/index.html">Marriott a divulgué les données personnelles de 500 millions de clients</a></li>
<li><a href="../fr431686/index.html">Sauf IoT: le botnet Mirai lance une attaque sur les machines Linux</a></li>
<li><a href="../fr431690/index.html">Résoudre le crackme de Kaspersky Lab</a></li>
<li><a href="../fr431692/index.html">Progrès de l'immunothérapie dans le traitement de la sclérose en plaques</a></li>
<li><a href="../fr431694/index.html">Trier "Tour de Hanoi"</a></li>
<li><a href="../fr431696/index.html">Kodein. Les bases</a></li>
<li><a href="../fr431698/index.html">Analyse des questions sur le stand hh.ru sur # HolyJS18</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>