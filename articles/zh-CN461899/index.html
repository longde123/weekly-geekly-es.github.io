<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏻 👂🏿 🧘🏽 事件生成，CQRS和Laravel 🤢 🔱 🧝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文的翻译是为专业课程“ Framework Laravel”的学生准备的 
 



 引言 
 本文致力于以PHP语言和Laravel框架创建事件CQRS系统的基础知识。 假定您熟悉使用命令总线的开发方案并且对事件有所了解（尤其是针对一系列侦听器的事件发布）。 要刷新此知识，可以使用Laraca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>事件生成，CQRS和Laravel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/461899/">  <i>本文的翻译是为专业课程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Framework Laravel”的</a>学生准备的</i> <i><br></i> <br><img src="https://habrastorage.org/webt/h8/4u/y5/h84uy5i5spnt3rdmpaiw2aynd0s.png"><br><br><hr><br><h2> 引言 </h2><br> 本文致力于以PHP语言和Laravel框架创建事件CQRS系统的基础知识。 假定您熟悉使用命令总线的开发方案并且对事件有所了解（尤其是针对一系列侦听器的事件发布）。 要刷新此知识，可以使用Laracasts服务。 另外，假设您对CQRS原理有一定的了解。 如果没有，我强烈建议您听两个讲座： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mathias Verraes关于事件生成的研讨会</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Greg Young的CQRS和Event Generation</a> 。 <br><a name="habracut"></a><br> 不要在您的项目中使用此处给出的代码！ 这是一个了解CQRS背后思想的学习平台。 此代码不能被称为可靠的，未经测试，而且我很少编程接口，因此更改代码的各个部分将变得更加困难。 可以使用的CQRS软件包更好的例子是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Qandidate Lab开发的Broadway</a> 。 这是干净的，松散耦合的代码，但是，如果您从未遇到过事件系统，则有些抽象无法完全弄清。 <br><br> 最后一个-我的代码与事件和Laravel命令总线有关。 我想看看代码在Laravel中的外观（我通常将这个框架用于小型机构的项目），但是回想一下，我认为我应该创建自己的实现。 我希望即使对于那些不使用框架的人，我的代码也将是清晰的。 <br><br> 在github上，代码位于<a href="">https://github.com/scazz/cqrs-tutorial.git</a> ，在我们的指南中，我们将考虑其组件以增加逻辑。 <br><br> 我们将为冲浪学校创建一个初始注册系统。 在它的帮助下，学校客户可以注册课程。 对于记录过程，我们制定以下规则： <br><br><ul><li> 每节课必须至少有一个客户... </li><li>  ...但不超过三个。 </li></ul><br> 基于事件的CQRS系统最令人印象深刻的功能之一是针对系统所需的每个指标创建读取模型。 您将在ElasticSearch中找到阅读模型的投影示例，而Greg Young在其事件存储中实现了一种面向主题的语言，用于处理复杂事件。 但是，为简单起见，我们的读取投影将是与Eloquent一起使用的标准SQL数据库。 结果，我们将有一个表用于类，一个表用于客户。 <br><br> 事件生成的概念还允许您脱机处理事件。 但是在本文中，我将最大程度地坚持“传统”开发模型（再次简化），并且将事件存储在存储库中后，我们的阅读预测将实时更新。 <br><br><h2> 项目设置和首次测试 </h2><br><pre><code class="plaintext hljs">git clone https://github.com/scazz/cqrs-tutorial</code> </pre> <br> 创建一个新的Laravel 5项目 <br><br><pre> <code class="plaintext hljs">$&gt; laravel new cqrs-tutorial</code> </pre> <br> 对于初学者，我们需要测试。 我们将使用集成测试，这将确保客户的课程注册会导致在Eloquent模型中创建课程。 <br><br> 列出测试/ CQRSTest.php： <br><br><pre> <code class="plaintext hljs">use Illuminate\Foundation\Bus\DispatchesCommands; class CQRSTest extends TestCase { use DispatchesCommands;</code> </pre><br><pre> <code class="bash hljs">/** *  ,   BookLesson       * @<span class="hljs-built_in"><span class="hljs-built_in">return</span></span> void */ public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFiringEventUpdatesReadModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span> = <span class="hljs-string"><span class="hljs-string">'123e4567-e89b-12d3-a456-426655440000'</span></span>; <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>); <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertNotNull(Lesson::find(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>)); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals( Lesson::find(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>)-&gt;clientName, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> ); } }</code> </pre> <br> 我们将新活动预先分配给一个ID，创建一个团队来注册新活动，然后告诉Laravel发送它。 在课程表中，我们需要创建一条新记录，我们可以使用Eloquent模型读取该记录。 我们需要一个数据库，因此请正确填写您的.env文件。 <br><br> 在事件存储中记录的每个事件都附加到聚合的根，我们将其简称为实体（Entity）-用于教育目的的抽象只会增加混乱。  ID是通用唯一标识符（UUID）。 活动存储区并不关心活动是否适用于课程或客户。 他只知道它与ID相关联。 <br><br> 根据测试期间发现的错误，我们可以创建缺少的类。 首先，我们将创建LessonId类，然后创建BookLesson命令（现在不用担心处理程序方法，只需继续运行测试即可）。  Lesson类是Lesson名称空间之外的阅读模型。 独家阅读模型-主题区域的逻辑永远不会存储在这里。 总之，我们将需要为课程表创建迁移。 <br><br> 为了保持代码的清晰度，我将使用断言验证库。 可以使用以下命令添加它： <br><br><pre> <code class="plaintext hljs">$&gt; composer require beberlei/assert</code> </pre> <br> 考虑应该由该命令启动的过程： <br><br><ol><li> 验证：命令性命令可能会失败，并且事件已经发生，因此不应失败。 </li><li> 创建一个新的LessonWasBooked事件（注册一个课程）。 </li><li> 更新活动状态。  （记录模型必须知道模型的状态，以便它可以执行验证。） </li><li> 将此事件添加到活动记录模型中存储的未提交事件流中。 </li><li> 将未提交的事件流保存到存储库。 </li><li> 在全局范围内引发LessonWasBooked事件，以通知所有正在阅读的投影仪更新课程表。 </li></ol><br> 首先，您需要为该课程创建一个录音模型。 我们将使用静态工厂方法<code>Lesson::bookClientOntoNewLesson()</code> 。 它会生成一个新的<code>LessonWasOpened</code>事件（课程已打开），将其应用于自身（仅设置其ID），然后将新事件以<code>DomainEventMessage</code>的形式添加到未提交的事件列表中（事件以及一些保存到事件存储时使用的元数据）。 <br><br> 重复该过程以将客户端添加到事件中。 当应用<code>ClientWasBookedOntoLesson</code>事件（客户端已注册课程）时，记录模型不会跟踪客户端名称，而只会跟踪已注册客户端的数量。 记录模型不需要知道客户名称即可确保一致性。 <br><br> 现在， <code>applyLessonWasOpened</code>和<code>applyClientWasBookedOntoLesson</code>方法可能看起来有些奇怪。 当我们需要重现旧事件以形成记录模型的状态时，将在以后使用它们。 解释起来并不容易，因此，我将提供一个代码，以帮助您了解此过程。 稍后，我们将提取处理uncommittedEvents并生成域事件消息的代码。 <br><br><pre> <code class="bash hljs">app/School/Lesson/Lesson.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> openLesson( LessonId <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ) { /*      ,      ,       */ <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;apply( new LessonWasOpened( <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>) ); } protected <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyLessonWasOpened( LessonWasOpened <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId = <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;getLessonId(); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients = 0; } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> bookClient( <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients &gt;= 3) { throw new TooManyClientsAddedToLesson(); } <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;apply( new ClientBookedOntoLesson( <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>) ); } /** *       — *  ,       *      ,       , *      . */ protected <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyClientBookedOntoLesson( ClientBookedOntoLesson <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients++; }</code> </pre> <br> 我们可以从记录模型中提取CQRS组件-涉及处理未提交事件的类的片段。 我们还可以通过创建一个安全的<code>apply()</code>函数来清除事件生成的实体的API，该函数接受事件，调用相应的<code>applyEventName()</code>方法，并将新的<code>DomainEventMessage</code>事件添加到未提交的事件列表中。 提取的类是CQRS实现的详细信息，并且不包含域逻辑，因此我们可以创建一个新的命名空间：App \ CQRS： <br><br>  <i>注意代码<code>app/CQRS/EventSourcedEntity.php</code></i> <i><br></i>  <i>为了使代码正常工作，我们需要添加<code>DomainEventMessage</code>类，这是一个简单的<code>DomainEventMessage</code>可以在<code>app/CQRS/DomainEventMessage.php</code></i> <br><br> 因此，我们得到了一个系统，该系统为每次写尝试生成事件，并使用事件记录必要的更改以防止不变。 下一步是将这些事件保存在商店（EventStore）中。 首先，需要创建此事件存储库。 为简化起见，我们将使用Eloquent模型，它是一个带有以下字段的简单SQL表：* <code>UUID</code> （用于了解将事件应用到哪个实体）* <code>event_payload</code> （包含重新创建事件所需的所有内容的序列化消息）* <code>event_payload</code>用于了解事件发生时间的时间戳发生了 如果仔细查看代码，您将看到我创建了两个命令-创建和销毁事件存储表： <br><br><ul><li>  php artisan eloquenteventstore：创建（应用程序\ CQRS \ EloquentEventStore \ CreateEloquentEventStore） </li><li>  php artisan eloquenteventstore：删除（App \ CQRS \ EloquentEventStore \ DropEloquentEventStore）（别忘了将它们添加到App \ Console \ Kernel.php以便它们加载）。 </li></ul><br> 不使用SQL作为事件存储有两个很好的理由：它没有实现仅追加模型（仅添加数据，事件必须是不可变的），也因为SQL并不是时态数据库的理想查询语言。 我们对接口进行编程，以方便在后续出版物中替换事件存储。 <br><br> 要保存事件，请使用存储库。 每当为记录模型调用<code>save()</code> ，我们都会将uncommittedEvents列表保存在事件存储中。 为了存储事件，我们需要一种对其进行序列化和反序列化的机制。 为此创建一个序列化器。 我们将需要元数据，例如事件类（例如<code>App\School\Lesson\Events\LessonWasOpened</code> ）和事件有效负载（重建事件所需的数据）。 <br><br> 所有这些将以JSON格式编码，然后与实体UUID和时间戳一起写入我们的数据库。 我们想在捕获事件后更新阅读模型，因此存储库将在保存后触发每个事件。 序列化程序将负责编写事件类，而事件将负责序列化其有效负载。 完全序列化的事件如下所示： <br><br><pre> <code class="plaintext hljs"> { class: "App\\School\\Lesson\\Events\\", event: $event-&gt;serialize() }</code> </pre> <br> 由于所有事件都需要序列化和反序列化方法，因此我们可以创建一个<code>SerializableEvent</code>接口并添加期望值类型的指示。 更新我们的<code>LessonWasOpened</code>事件： <br><br><pre> <code class="bash hljs">app/School/Lesson/Events/LessonWasOpened.php class LessonWasOpened implements SerializableEvent { public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> array( <span class="hljs-string"><span class="hljs-string">'lessonId'</span></span>=&gt; (string) <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;getLessonId() ); } }</code> </pre> <br> 创建一个<code>LessonRepository</code>存储库。 我们稍后可以重构和提取核心CQRS组件。 <br><br> <code>app/School/Lesson/LessonRepository.php</code> <br> <pre> <code class="plaintext hljs">eventStoreRepository = new EloquentEventStoreRepository( new EventSerializer() ); } public function save(Lesson $lesson) { /** @var DomainEventMessage $domainEventMessage */ foreach( $lesson-&gt;getUncommittedDomainEvents() as $domainEventMessage ) { $this-&gt;eventStoreRepository-&gt;append( $domainEventMessage-&gt;getId(), $domainEventMessage-&gt;getEvent(), $domainEventMessage-&gt;getRecordedAt() ); Event::fire($domainEventMessage-&gt;getEvent()); } } }</code> </pre> <br> 如果再次运行集成测试，然后检查<code>domain_events</code> SQL表，则应该在数据库中看到两个事件。 <br><br> 成功通过测试的最后一步是收听广播事件并更新Lesson阅读模型的预测。  Lesson广播事件将由<code>LessonProjector</code>拦截，该事件将对<code>LessonProjection</code> （课程表的<code>LessonProjection</code>模型）进行必要的更改： <br><br><pre> <code class="bash hljs"> app/School/Lesson/Projections/LessonProjector.php class LessonProjector { public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyLessonWasOpened( LessonWasOpened <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span> = new LessonProjection(); <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span>-&gt;id = <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;getLessonId(); <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span>-&gt;save(); } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> subscribe(Dispatcher <span class="hljs-variable"><span class="hljs-variable">$events</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$fullClassName</span></span> = self::class; <span class="hljs-variable"><span class="hljs-variable">$events</span></span>-&gt;listen( LessonWasOpened::class, <span class="hljs-variable"><span class="hljs-variable">$fullClassName</span></span>.<span class="hljs-string"><span class="hljs-string">'@applyLessonWasOpened'</span></span>); } }  app/School/Lesson/Projections/LessonProjection.php class LessonProjection extends Model { public <span class="hljs-variable"><span class="hljs-variable">$timestamps</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; protected <span class="hljs-variable"><span class="hljs-variable">$table</span></span> = <span class="hljs-string"><span class="hljs-string">"lessons"</span></span>; }</code> </pre> <br> 如果运行测试，您将看到发生了SQL错误： <br><br><pre> <code class="plaintext hljs">Unknown column 'clientName' in 'field list'</code> </pre> <br> 一旦创建迁移以将<code>clientName</code>添加到课程表中，我们就将成功通过测试。 我们已经实现了CQRS的基本功能：团队创建用于生成阅读模型的事件。 <br><br><h2> 通过链接改善阅读模式 </h2><br> 我们已经达到了一个重要的里程碑，但这还不是全部！ 到目前为止，阅读模型仅支持一个客户端（我们在域规则中指定了三个）。 我们对阅读模型的更改非常简单：我们只创建一个Client投影模型和一个<code>ClientProjector</code>来捕获<code>ClientBookedOntoLesson</code>事件。 首先，我们更新测试以反映我们希望在阅读模型中看到的变化： <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFiringEventUpdatesReadModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals( <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;id, (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ); <span class="hljs-variable"><span class="hljs-variable">$client</span></span> = <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients()-&gt;first(); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals(<span class="hljs-variable"><span class="hljs-variable">$client</span></span>-&gt;name, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); }</code> </pre><br> 这清楚地说明了更改阅读模型有多么容易。 直到事件存储库的所有内容都保持不变。 另外，使用事件系统时，我们会获得用于基本测试的数据-更改阅读模型的投影仪时，我们会聆听系统中发生过的所有事件。 <br><br> 我们使用新的投影仪再现这些事件，检查异常情况，并将结果与​​以前的投影进行比较。 系统运行一段时间后，我们将有相当具代表性的事件选择来测试我们的投影机。 <br><br> 我们的记录模型当前不具备加载当前状态的能力。 如果要在课程中添加第二个客户端，我们可以简单地创建第二个ClientWa⚓ToLesson事件，但是我们不能提供针对不变性的保护。 为了更加清晰，我建议编写第二个测试来模拟每节课中两个客户端的录制。 <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLoadingWriteModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span> = <span class="hljs-string"><span class="hljs-string">"Fred"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertClientCollectionContains(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients, <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertClientCollectionContains(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients, <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span>); }</code> </pre> <br> 对于我们的记录模型，我们需要实现一种“加载”已在事件存储中对其应用了事件的实体的方法。 我们可以通过回放引用实体UUID的每个事件来实现此目的。 一般而言，该过程如下： <br><br><ol><li> 我们从事件存储接收所有相关的事件消息。 </li><li> 对于每条消息，我们都会重新创建相应的事件。 </li><li> 我们创建一个新的实体记录模型并播放每个事件。 </li></ol><br> 目前，我们的测试会引发异常，因此我们将从使用<code>BookLesson</code>命令作为模板创建必要的<code>BookClientOntoLesson</code> （为课程注册客户端）开始。 该处理程序方法将如下所示： <br><br><pre> <code class="bash hljs"> app/School/Lesson/Commands/BookClientOntoLesson.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> handle(LessonRepository <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>) { /** @var Lesson <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> */ <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>-&gt;load(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;bookClient(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;clientName); <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>-&gt;save(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>); }      : app/School/Lesson/LessonRepository.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> load(LessonId <span class="hljs-variable"><span class="hljs-variable">$id</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$events</span></span> = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;eventStoreRepository-&gt;load(<span class="hljs-variable"><span class="hljs-variable">$id</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = new Lesson(); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;initializeState(<span class="hljs-variable"><span class="hljs-variable">$events</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>; }</code> </pre> <br> 存储库加载功能返回一个重新创建的事件数组。 为此，她首先在存储库中找到有关事件的消息，然后将它们传递给<code>Serializer</code>以将每个消息转换为事件。  <code>Serializer</code>从事件创建消息，因此我们需要添加<code>deserialize()</code>方法以执行逆变换。 回想一下，将<code>Serializer</code>器传递给每个事件以序列化事件数据（例如，客户端名称）。 我们将执行相同的操作以执行逆变换，而我们的<code>SerializableEvent</code>接口必须使用<code>deserialize()</code>方法进行更新。 让我们看一下代码，以便一切都准备就绪。 首先是<code>EventStoreRepository</code>加载<code>EventStoreRepository</code> ： <br><br><pre> <code class="bash hljs">app/CQRS/EloquentEventStore/EloquentEventStoreRepository.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> load(<span class="hljs-variable"><span class="hljs-variable">$uuid</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$eventMessages</span></span> = EloquentEventStoreModel::<span class="hljs-built_in"><span class="hljs-built_in">where</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid'</span></span>, <span class="hljs-variable"><span class="hljs-variable">$uuid</span></span>)-&gt;get(); <span class="hljs-variable"><span class="hljs-variable">$events</span></span> = []; foreach(<span class="hljs-variable"><span class="hljs-variable">$eventMessages</span></span> as <span class="hljs-variable"><span class="hljs-variable">$eventMessage</span></span>) { /*       event_payload,        . */ <span class="hljs-variable"><span class="hljs-variable">$events</span></span>[] = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;eventSerializer-&gt;deserialize( json_decode(<span class="hljs-variable"><span class="hljs-variable">$eventMessage</span></span>-&gt;event_payload)); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$events</span></span>; }</code> </pre><br> 在<code>eventSerializer</code>使用适当的反序列化功能： <br><br><pre> <code class="bash hljs">app/CQRS/Serializer/EventSerializer.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> serialize( SerializableEvent <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> array( <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; get_class(<span class="hljs-variable"><span class="hljs-variable">$event</span></span>), <span class="hljs-string"><span class="hljs-string">'payload'</span></span> =&gt; <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;serialize() ); } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> deserialize( <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$eventClass</span></span> = <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span>-&gt;class; <span class="hljs-variable"><span class="hljs-variable">$eventPayload</span></span> = <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span>-&gt;payload; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$eventClass</span></span>::deserialize(<span class="hljs-variable"><span class="hljs-variable">$eventPayload</span></span>); }</code> </pre> <br> 总之，我们将在<code>LessonWasOpened</code>使用静态工厂方法<code>LessonWasOpened</code> （ <code>deserialize()</code> （我们需要将此方法添加到每个事件中） <br><br><pre> <code class="bash hljs">app/School/Lesson/Events/LessonWasOpened.php public static <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> deserialize(<span class="hljs-variable"><span class="hljs-variable">$data</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId(<span class="hljs-variable"><span class="hljs-variable">$data</span></span>-&gt;lessonId); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> new self(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>); }</code> </pre> <br> 现在，相对于我们的实体记录模型，我们有了一个刚刚再现的所有事件的数组，用于初始化<code>app/CQRS/EventSouredEntity.php</code>中的<code>initializeState</code>方法中的状态 <br><br> 现在运行我们的测试。 宾果！ <br> 实际上，目前我们还没有测试来验证是否符合我们的域规则，因此我们来编写它： <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMoreThan3ClientsCannotBeAddedToALesson</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"george"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"fred"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;setExpectedException( TooManyClientsAddedToLesson::class ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"emma"</span></span>) ); }</code> </pre> <br> 请注意，我们只需要<code>lessonId</code>此测试将在每个命令期间重新初始化课程的状态。 <br><br> 目前，我们仅传输手动创建的<code>UUID</code> ，而实际上我们希望自动生成它们。 我将使用<code>Ramsy\UUID</code>软件包，因此让我们与<code>composer</code>一起安装它： <br><br><pre> <code class="plaintext hljs">$&gt; composer require ramsey/uuid</code> </pre> <br> 现在更新测试以使用新软件包： <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEntityCreationWithUUIDGenerator</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertInstanceOf( Lesson::class, Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>) ); }</code> </pre><br> 现在，新项目开发人员可以查看代码，请参阅<code>App\School\ReadModels</code> ，其中包含一组<code>App\School\ReadModels</code>模型，并使用这些模型将更改写入课程表。 我们可以通过创建一个<code>ImmutableModel</code>类来防止这种情况，该类可以扩展Eloquent Model类并覆盖<code>app/CQRS/ReadModelImmutableModel.php</code>的save方法。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN461899/">https://habr.com/ru/post/zh-CN461899/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN461885/index.html">EDS是另一种欺诈</a></li>
<li><a href="../zh-CN461887/index.html">进入航空网第2集：无人机</a></li>
<li><a href="../zh-CN461891/index.html">我们如何使用ManageIQ在银行基础设施中结识朋友</a></li>
<li><a href="../zh-CN461895/index.html">边走边学-在第一届欧洲商业分析日我们如何开车</a></li>
<li><a href="../zh-CN461897/index.html">我们如何保持Lamoda应用程序的稳定性</a></li>
<li><a href="../zh-CN461901/index.html">三年的自动测试：如何提高速度，而不仅仅是</a></li>
<li><a href="../zh-CN461903/index.html">神秘对手：模糊借用</a></li>
<li><a href="../zh-CN461905/index.html">井字游戏，第7部分：pytest和Travis CI</a></li>
<li><a href="../zh-CN461907/index.html">全周期工作室中的产品分析</a></li>
<li><a href="../zh-CN461913/index.html">电子商务中的移动可用性：俄罗斯TOP-20在线商店的分析</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>