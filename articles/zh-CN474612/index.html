<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑 📖 💇🏾 EBA体系结构又称全反应性 🤾🏿 👨🏿‍🎨 💟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="几年前，我来到Tinkoff的一个新项目“ Customers and Projects” （ 客户和项目 ）刚刚开始。 
 现在，我不记得当时对我的新架构的感受了。 但是我可以肯定地记得：在通常的网络访问和基础访问之外，在其他地方使用Rx是不寻常的。 既然该体系结构已经通过了一些发展的演进路径，那...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EBA体系结构又称全反应性</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/474612/"><p> 几年前，我来到Tinkoff的一个新项目“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Customers and Projects”</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">客户和项目</a> ）刚刚开始。 <br> 现在，我不记得当时对我的新架构的感受了。 但是我可以肯定地记得：在通常的网络访问和基础访问之外，在其他地方使用Rx是不寻常的。 既然该体系结构已经通过了一些发展的演进路径，那么我想最后谈谈发生了什么以及发生了什么。 </p><br><p><img src="https://habrastorage.org/webt/gk/ru/ve/gkruveswoxzhqfxjfasm_vaf2qq.png"></p><br><p> 以我的观点，所有当前流行的体系结构-MVP，MVVM甚至MVI-长期以来一直处于舞台上，并不总是应有的。 他们没有缺陷吗？ 我看到很多。 我们在自己的位置决定足以承受它，并（重新）发明了一种新的异步架构。 </p><a name="habracut"></a><br><p> 我将简要描述我对当前体系结构不满意的地方。 有些观点可能会引起争议。 也许您从未遇到过这种情况，而是编写了完美的，通常来说是绝地的编程。 然后原谅我，一个罪人。 <br> 所以我的痛苦是： </p><br><ul><li> 巨大的Presenter / ViewModel。 </li><li>  MVI中有大量的开关盒。 </li><li> 无法重用Presenter / ViewModel的某些部分，因此，需要复制代码。 </li><li> 可以在任何地方修改的可变变量堆。 因此，这种代码难以维护和修改。 </li><li> 未分解的屏幕更新。 </li><li> 编写测试很难。 </li></ul><br><h2 id="problematika">  <strong>发行</strong> </h2><br><blockquote> 在每时每刻，应用程序都具有确定其行为和用户所见内容的特定状态。 此状态包括变量的所有值-从简单标志到单个对象。 这些变量中的每一个都有自己的生命，并由代码的不同部分控制。 您只能逐一检查所有应用程序，才能确定应用程序的当前状态。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于现代Kotlin MVI架构的文章</a> <br><cut></cut><br></blockquote><br><h2 id="glava-1-evolyuciya--nashe-vsyo">  <strong>第1章。进化就是我们的一切</strong> </h2><br><p> 最初，我们在MVP上进行了编写，但有些改动。 它是MVP和MVI的混合体。 来自MVP的实体具有演示者和View界面的形式： </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewTaskView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newTaskAction: Observable&lt;NewTaskAction&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> taskNameChangeAction: Observable&lt;String&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onChangeState: Consumer&lt;SomeViewState&gt; }</code> </pre> <br><p> 已经在这里您可以注意到要注意的问题：这里的视图距离MVP规范很远。 演示者中有一种方法： </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeView</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Disposable</code> </pre> <br><p> 在外部，传递了一个接口实现，该接口实现以响应方式订阅UI更改。 它已经充满了MVI！ </p><br><p> 更多就是更多。 在Presenter中，创建了不同的交互器并订阅了View更改，但是它们没有直接调用UI方法，而是返回了一些全局状态，其中存在所有可能的屏幕状态： </p><br><pre> <code class="kotlin hljs">compositeDisposable.add( Observable.merge(firstAction, secondAction) .observeOn(AndroidSchedulers.mainThread()) .subscribe(view.onChangeState)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> compositeDisposable</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewState</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> progress: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> error: Throwable? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorMessage: String? = error?.message, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result: TaskUi? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre><br><p> 活动是SomeViewStateMachine接口的后代： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewStateMachine</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toSuccess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(task: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeUiModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toProgress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeSomeButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buttonEnabled: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p> 当用户单击屏幕上的某些内容时，演示者进入一个事件，他创建了一个新模型，该模型由特殊类绘制： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewStateResolver</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stateMachine: SomeViewStateMachine) : Consumer&lt;SomeViewState&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stateUpdate: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeViewState</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.result != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { stateMachine.toSuccess(stateUpdate.result) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.error != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; stateUpdate.progress == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { stateMachine.toError(stateUpdate.errorMessage) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.progress == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { stateMachine.toProgress() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.someButtonEnabled != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { stateMachine.changeSomeButton(stateUpdate.someButtonEnabled) } } }</code> </pre> <br><p> 同意，有些奇怪的MVP，甚至离MVI还很远。 寻找灵感。 </p><br><h2 id="glava-2-redux">  <strong>第2章Redux</strong> </h2><br><p><img src="https://habrastorage.org/webt/sw/bm/pf/swbmpfddkyjohcxemag4a0zdatm.jpeg"></p><br><p> 在谈论他与其他开发人员的问题时，我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">领导</a> （当时还是现在）的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sergey Boishtyan</a>了解了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redux</a> 。 </p><br><p> 看了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dorfman关于所有架构的讨论</a>并与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redux</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一起玩</a>了之后，我们决定使用它来升级我们的架构。 <br> 但是首先，让我们仔细研究一下架构，并了解其优缺点。 </p><br><p>  <strong>动作片</strong> <br> 描述动作。 </p><br><p>  <strong>动作创造者</strong> <br> 他就像系统分析师一样：格式化并补充客户需求规范，以便程序员理解他。 <br> 当用户在屏幕上单击时，ActionsCreator会形成一个用于中间件的操作（某种业务逻辑）。 业务逻辑为我们提供了特定Reducer接收和提取的新数据。 </p><br><p> 如果再次查看图片，可能会注意到诸如存储之类的对象。 商店商店减速器。 也就是说，我们看到前端兄弟-不幸的兄弟-猜测可以将一个大对象锯成许多小对象，每个小对象都将负责自己的屏幕部分。 这只是一个很棒的想法！ </p><br><p> 简单的ActionCreators的示例代码（小心，JavaScript！）： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTodo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ADD_TODO, text } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toggleTodo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: TOGGLE_TODO, index } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setVisibilityFilter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: SET_VISIBILITY_FILTER, filter } }</code> </pre> <br><p>  <strong>减速器</strong> </p><br><blockquote> 动作描述了某些事情发生的事实，但是没有指示应用程序的状态应如何响应以进行更改，这对于Reducer来说是可行的。 </blockquote><p> 简而言之，Reducer知道如何分解/刷新屏幕。 </p><br><p> 优点： </p><br><ul><li> 分解的屏幕更新。 </li><li> 单向数据流。 </li></ul><br><p> 缺点： </p><br><ul><li> 最喜欢的切换。 <br><pre> <code class="kotlin hljs">function todoApp(state = initialState, action) { switch (action.type) { case SET_VISIBILITY_FILTER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.assign({}, state, { visibilityFilter: action.filter }) case ADD_TODO: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.assign({}, state, { todos: [ ...state.todos, { text: action.text, completed: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ] }) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state }</code> </pre> </li><li> 一堆状态对象。 </li><li> 将逻辑分离到ActionCreator和Reducer中。 </li></ul><br><p> 是的，在我们看来，ActionCreator和Reducer的分离并不是连接模型和屏幕的最佳选择，因为编写instanceof（is）是一种不好的方法。 在这里，我们发明了我们的架构！ </p><br><h2 id="glava-3-eba">  <strong>第3章EBA</strong> </h2><br><p><img src="https://habrastorage.org/webt/os/6w/7_/os6w7_sgmegw6nsh7lyebs_o9de.jpeg"></p><br><p> 在EBA中，什么是Action和ActionCreator： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Action = () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> ActionMapper&lt;T&gt; = (T) -&gt; Action <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActionCreator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"></span></span><span class="hljs-class"><span class="hljs-type"></span></span>(T) -&gt; (Observable&lt;Action&gt;)</code> </pre> <br><p> 是的，架构的一半是类型别名和接口。 简单等于优雅！ </p><br><p> 为了采取行动而不传送任何数据，需要采取行动。 由于ActionCreator返回一个Observable，因此我们不得不将Action包装在另一个lambda中以传输一些数据。 事实证明，ActionMapper是一种类型化的Action，通过它我们可以传递更新屏幕/视图所需的内容。 <br><br>  <strong>基本假设：</strong> <br></p><div class="spoiler">  <b class="spoiler_title">一个ActionCreator-屏幕的一部分</b> <div class="spoiler_text"><p> 在第一段中，所有内容都很清楚：为了避免难以理解的交叉更新，我们同意一个ActionCreator只能更新其屏幕部分。 如果是列表，则仅更新列表，如果仅按钮则更新。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">不需要匕首</b> <div class="spoiler_text"><p> 但是，一个奇怪的是，为什么匕首不能取悦我们？ 我告诉你 <br> 一个典型的故事是项目中有一个抽象的谢尔盖又名匕首大师（又称“这个抽象是做什么？”）。 </p><br><p> 事实证明，如果您尝试使用匕首，则必须每次都向每个新的（不仅是新的）开发人员进行解释。 也许您自己已经忘记了此注释的作用，而您去了google。 </p><br><p> 所有这些都极大地增加了创建特征的过程，而没有带来太多的便利。 因此，我们决定由我们自己动手创建所需的东西，因为没有代码生成，所以组装起来会更快。 是的，我们将花费额外的五分钟时间来手动编写所有依赖项，但是我们将节省大量的编译时间。 是的，我们并没有到处都抛弃匕首，它在全球范围内使用，它创建了一些通用的东西，但是我们用Java编写它们是为了更好的优化，以免吸引kapt。 </p></div></div><br><p>  <strong>建筑方案</strong> ： </p><br><p><img src="https://habrastorage.org/webt/1w/m6/1a/1wm61atrwg2dmy4hkzfherwsbqc.png"></p><br><p>  Component是Dagger中相同组件的类似物，只是没有Dagger。 他的任务是创建活页夹。 活页夹将ActionCreators连接在一起。 从View到Binder事件会发生什么，从Binder到View，将发送更新屏幕的操作。 </p><br><p>  <strong>动作创造者</strong> </p><br><p><img src="https://habrastorage.org/webt/8v/nw/3p/8vnw3p52mcfzyyhegcxtkexgokm.png"></p><br><p> 现在，让我们看看这是什么样的东西-ActionCreator。 在最简单的情况下，它只是单向地处理动作。 假设有这样一种情况：用户单击“创建任务”按钮。 应该打开另一个屏幕，我们将在此处描述它，而无需任何其他请求。 </p><br><p> 为此，我们只需使用我们心爱的Jake的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RxBinding</a>订阅按钮，然后等待用户单击它。 发生点击后，Binder会将事件发送到特定的ActionCreator，后者将调用我们的Action，这将为我们打开一个新屏幕。 请注意，没有开关。 接下来，我将在代码中显示为什么会这样。 <br> 如果我们突然需要访问网络或数据库，则可以在此处发出这些请求，但是要通过通过接口调用传递给ActionCreator构造函数的交互器进行调用： </p><br><blockquote> 免责声明：这里的代码格式不完全正确，我有本文的规则，因此代码易于阅读。 </blockquote><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoadItemsActionCreator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> getItems: () -&gt; Observable&lt;List&lt;ViewTyped&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> showLoadedItems: ActionMapper&lt;DiffResult&lt;ViewTyped&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> diffCalculator: DiffCalculator&lt;ViewTyped&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorItem: ErrorView, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> emptyItem: ViewTyped? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) : ActionOnEvent</code> </pre> <br><p>  “通过其调用的接口”一词的意思是确切地声明getItems的声明方式（此处ViewTyped是我们用于处理列表的接口）。 顺便说一下，我们已在应用程序的八个不同部分重用了该ActionCreator，因为它写的尽可能多。 </p><br><p> 由于事件具有响应性，因此我们可以在其中添加其他运算符来组装一条链，例如，startWith（showLoadingAction）用于显示加载，onErrorReturn（errorAction）用于显示带有错误的屏幕状态。 <br> 所有这一切都是反应性的！ </p><br><h2 id="primer-">  <strong>例子</strong> </h2><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CompositionFragment</span></span></span></span>(R.layout.fragment_about) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component = AboutComponent( setVersionName = { { appVersion.text = it } }, openPdfAction = { (url, name) -&gt; { openPdf(url, name) } }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events = AboutEventsImpl( bindEvent = bindEvent, openPolicyPrivacyEvent = confidentialityPolicy.clicks(), openProcessingPersDataEvent = personalDataProtection.clicks(), unbindEvent = unBindEvent) component.binder().bind(events) }</code> </pre> <br><p> 最后，我们以代码为例来看看该架构。 首先，我选择了最简单的屏幕之一-关于应用程序，因为它是静态屏幕。 <br> 考虑创建一个组件： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component = AboutComponent( setVersionName = { { appVersion.text = it } }, openPdfAction = { (url, name) -&gt; { openPdf(url, name) } } )</code> </pre> <br><p> 组件参数-Actions / ActionMappers-帮助将View与ActionCreators关联。 在ActionMapper'e setVersionName中，我们传递项目的版本，并将此值分配给屏幕上的文本。 在openPdfAction中，一对指向文档的链接和一个名称，以打开用户可以阅读此文档的下一个屏幕。 </p><br><p> 这是组件本身： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName: ActionMapper&lt;String&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPdfAction: ActionMapper&lt;Pair&lt;String, String&gt;&gt;) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: AboutEventsBinder { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy = OpenPdfActionCreator(openPdfAction, someUrlString) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData = OpenPdfActionCreator(openPdfAction, anotherUrlString) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName = setVersionName.toSimpleActionCreator( moreComponent::currentVersionName ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AboutEventsBinder(setVersionName, openPolicyPrivacy, openProcessingPersonalData) } }</code> </pre> <br><p> 让我提醒您： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Action = () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> ActionMapper&lt;T&gt; = (T) -&gt; Action</code> </pre> <br><p> 好的，让我们继续。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: AboutEventsBinder</code> </pre> <br><p> 让我们更详细地了解AboutEventsBinder。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutEventsBinder</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData: ActionOnEvent) : BaseEventsBinder&lt;AboutEvents&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AboutEvents</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.merge( setVersionName(events.bindEvent), openPolicyPrivacy(events.openPolicyPrivacyEvent), openProcessingPersonalData(events.openProcessingPersDataEvent)) } }</code> </pre> <br><p>  ActionOnEvent是另一个类型别名，以免每次都写。 </p><br><pre> <code class="kotlin hljs">ActionCreator&lt;Observable&lt;*&gt;&gt;</code> </pre> <br><p> 在AboutEventsBinder中，我们传递ActionCreator并调用它们，将其绑定到特定事件。 但是，要了解所有这些如何连接，让我们看一下基类-BaseEventsBinder。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEventsBinder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiScheduler: Scheduler = AndroidSchedulers.mainThread() ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bindInternal(events).observeOn(uiScheduler) .takeUntil(events.unbindEvent) .subscribe(Action::invoke) } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; }</code> </pre><br><p> 我们看到了熟悉的bindInternal方法，我们在后继方法中对其进行了重新定义。 现在考虑绑定方法。 所有的魔术都在这里。 我们接受BaseEvents接口的继承者，将其传递给bindInternal来连接事件和动作。 一旦我们说了什么，我们就在ui流上执行并订阅。 我们还看到了一个有趣的hack-takeUntil。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEvents</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unbindEvent: EventObservable }</code> </pre> <br><p> 在BaseEvents中定义了unbindEvent字段以控制退订后，我们必须在所有继承人中实现它。 这个奇妙的字段使您可以在活动结束后自动取消订阅。 太好了！ 现在，您不再关注，也不必担心生命周期并安然入睡。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy = OpenPdfActionCreator(openPdfAction, policyPrivacyUrl) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData = OpenPdfActionCreator(openPdfAction, personalDataUrl)</code> </pre> <br><p> 返回组件。 在这里您已经可以看到重用的方法。 我们编写了一个可以打开pdf查看屏幕的类，而对我们来说url无关紧要。 没有代码重复。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenPdfActionCreator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPdfAction: ActionMapper&lt;Pair&lt;String, String&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pdfUrl: String) : ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EventObservable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { openPdfAction(pdfUrl to pdfUrl.substringAfterLast(FILE_NAME_DELIMITER)) } } }</code> </pre> <br><p>  ActionCreator代码也尽可能简单，这里我们只执行一些字符串操作。 </p><br><p> 让我们回到该组件并考虑以下ActionCreator： </p><br><pre> <code class="kotlin hljs">setVersionName.toSimpleActionCreator(moreComponent::currentVersionName)</code> </pre> <br><p> 一旦我们变得太懒了，就无法编写相同且本质上简单的ActionCreators。 我们使用了Kotlin的力量并写了extension'y。 例如，在这种情况下，我们只需要将静态字符串传递给ActionMapper。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-function"> ActionMapper</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toSimpleActionCreator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( mapper: ()</span></span></span></span> -&gt; R): ActionCreator&lt;Observable&lt;*&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ActionCreator&lt;Observable&lt;*&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Observable</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;*&gt;)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@toSimpleActionCreator</span></span>(mapper()) } } } }</code> </pre> <br><p> 有时候，我们根本不需要传输任何东西，而只需要调用某些动作即可，例如，打开以下屏幕： </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Action.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toActionCreator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EventObservable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@toActionCreator</span></span> } } } }</code> </pre> <br><p> 因此，在组件结束后，返回片段： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events = AboutEventsImpl( bindEvent = bindEvent, openPolicyPrivacyEvent = confidentialityPolicy.throttleFirstClicks(), openProcessingPersDataEvent = personalDataProtection.throttleFirstClicks(), unbindEvent = unBindEvent)</code> </pre> <br><p> 在这里，我们看到了一个负责接收用户事件的类的创建。 取消绑定和绑定只是我们使用Trello的Navi库获取的屏幕生命周期事件。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;T&gt; NaviComponent.observe(event: Event&lt;T&gt;): Observable&lt;T&gt; = RxNavi.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this, event)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unBindEvent: Observable&lt;*&gt; = observe(Event.DESTROY_VIEW) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent: Observable&lt;*&gt; = Observable.just(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)  <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent = observe(Event.POST_CREATE)</code> </pre> <br><p> 事件接口描述了特定屏幕的事件，此外它还必须继承BaseEvents。 以下始终是接口的实现。 在这种情况下，事件与屏幕上的事件是一对一的，但是碰巧您需要将两个事件保持在一起。 </p><br><p> 例如，在发生错误的情况下，打开和重新加载时屏幕加载的事件应合并为一个事件-仅加载屏幕。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutEvents</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseEvents { val bindEvent: EventObservable val openPolicyPrivacyEvent: EventObservable val openProcessingPersDataEvent: EventObservable } class AboutEventsImpl</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacyEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersDataEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unbindEvent: EventObservable) : AboutEvents</code> </pre> <br><p> 我们回到片段，将所有内容组合在一起！ 我们要求组件创建绑定器并将绑定器返回给我们，然后在其上调用bind方法，在此我们传递监视屏幕事件的对象。 </p><br><pre> <code class="kotlin hljs">component.binder().bind(events)</code> </pre> <br><p> 我们已经在这个架构上写了一个项目大约两年了。 共享功能的速度对管理人员的快乐没有任何限制！ 他们没有时间提出新的建议，因为我们已经完成了旧的建议。 该体系结构非常灵活，允许您重用大量代码。 <br> 这种体系结构的缺点可以称为状态不守恒。 我们没有像MVI中那样描述屏幕状态的完整模型，但是我们可以处理它。 喜欢-见下文。 </p><br><h2 id="glava-4-bonus">  <strong>第4章奖金</strong> </h2><br><p> 我认为每个人都知道分析的问题：没有人喜欢编写它，因为它遍历所有层级并消除了挑战。 前一段时间，我们不得不面对它。 但是由于我们的体系结构，获得了非常漂亮的实现。 </p><br><p> 因此，我的想法是：分析通常是为了响应用户操作而留下的。 我们只有一个可以累积用户操作的类。 好的，让我们开始吧。 </p><br><p>  <strong>第一步</strong> 我们通过将事件包装在trackAnalytics中来稍微更改BaseEventsBinder基类： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEventsBinder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> trackAnalytics: TrackAnalytics&lt;EVENTS&gt; = EmptyAnalyticsTracker(), <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiScheduler: Scheduler = AndroidSchedulers.mainThread()) { <span class="hljs-meta"><span class="hljs-meta">@SuppressLint(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CheckResult"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bindInternal(trackAnalytics(events)).observeOn(uiScheduler) .takeUntil(events.unbindEvent) .subscribe(Action::invoke) } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; }</code> </pre><br><p>  <strong>第二步</strong> 我们创建trackAnalytics变量的稳定实现，以保持向后兼容性，并且不会破坏尚不需要分析的继承人： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: EVENTS } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyAnalyticsTracker</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: EVENTS = events }</code> </pre> <br><p>  <strong>第三步</strong> 我们为所需的屏幕（例如，项目列表屏幕）编写TrackAnalytics接口的实现： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrackProjectsEvents</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ProjectsEvents</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ProjectsEvents</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ProjectsEvents { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ProjectsEvents <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> events { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boardClickEvent = events.boardClickEvent.trackTypedEvent { allProjectsProjectClick(it.title) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openBoardCreationEvent = events.openBoardCreationEvent.trackEvent { allProjectsAddProjectClick() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openCardsSearchEvent = events.openCardsSearchEvent.trackEvent { allProjectsSearchBarClick() } } } }</code> </pre> <br><p> 在这里，我们再次以代表的形式使用Kotlin的力量。 我们已经有一个由我们创建的接口继承程序-在这种情况下为ProjectsEvents。 但是对于某些事件，您需要重新定义事件的进行方式，并通过发送分析在事件周围添加绑定。 实际上，trackEvent只是doOnNext： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Observable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsSpec</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Observable&lt;T&gt; = doOnNext { event(analyticsSpec) } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Observable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackTypedEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsSpec</span></span></span></span><span class="hljs-function"><span class="hljs-params">.(</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Observable&lt;T&gt; = doOnNext { event(analyticsSpec, it) }</code> </pre> <br><p>  <strong>第4步</strong> 剩下的要转移到活页夹。 由于我们将其构造在组件中，因此如果您突然需要，我们将有机会向构造函数添加其他依赖项。 现在，ProjectsEventsBinder构造函数将如下所示： </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProjectsEventsBinder</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> loadItems: LoadItemsActionCreator, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshBoards: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openBoard: ActionCreator&lt;Observable&lt;BoardId&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openScreen: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openCardSearch: ActionOnEvent, trackAnalytics: TrackAnalytics&lt;ProjectsEvents&gt;) : BaseEventsBinder&lt;ProjectsEvents&gt;(trackAnalytics)</code> </pre> <br><p> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>GitHub上</strong></a>查看其他示例。 </p><br><h2 id="voprosy-i-otvety">  <strong>问与答</strong> </h2><br><div class="spoiler">  <b class="spoiler_title">您如何保持屏幕状态？</b> <div class="spoiler_text"><p> 没办法 我们阻止方向。 但是我们也使用参数/ intent并将OPENED_FROM_BACKSTACK变量保存在那里。 在设计活页夹时，我们会加以考虑。 如果为假-从网络加载数据。 如果为true-从缓存。 这使您可以快速重新创建屏幕。 </p><br><p> 对于反对定向阻止的每个人：尝试测试和存储有关用户翻转手机的频率以及有多少用户处于不同定向的分析。 结果可能令人惊讶。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">我不想编写组件，如何用匕首交朋友？</b> <div class="spoiler_text"><p> 我不建议这样做，但是如果您不介意编译时间，也可以通过匕首创建Component。 但是我们没有尝试。 </p></div></div><br><div class="spoiler">  <b class="spoiler_title">我不是用kotlin编写的，用Java实现有哪些困难？</b> <div class="spoiler_text"><p> 相同的都可以用Java编写，只是看起来不会那么漂亮。 </p></div></div><br><p> 如果您喜欢这篇文章，那么下一部分将是关于如何在这种架构上编写测试的（这将清楚为什么会有这么多的接口）。  Spoiler-编写很容易，您可以在除组件之外的所有层上进行编写，但是您无需测试它，只需创建一个绑定对象。 </p><br><p> 感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tinkoff Business</a>移动开发团队的同事为本文撰写所提供的帮助。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN474612/">https://habr.com/ru/post/zh-CN474612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN474596/index.html">在TSD上的应用以及通过HTTP服务与1C：Enterprise 8.3的通信。 第5部分（菜单，伴随对象）</a></li>
<li><a href="../zh-CN474598/index.html">没有工作经验的QA工程师面试方法</a></li>
<li><a href="../zh-CN474602/index.html">求解简单线性回归方程</a></li>
<li><a href="../zh-CN474606/index.html">Blogspam如何工作</a></li>
<li><a href="../zh-CN474610/index.html">基于NUC的媒体系统-家庭体验</a></li>
<li><a href="../zh-CN474618/index.html">为WooCommerce制作3D配置器</a></li>
<li><a href="../zh-CN474620/index.html">数据中心信息安全</a></li>
<li><a href="../zh-CN474622/index.html">34个开源Python库（2019）</a></li>
<li><a href="../zh-CN474626/index.html">Google Analytics（分析）和Yandex.Metrica术语：如何不混淆所有这些数据</a></li>
<li><a href="../zh-CN474628/index.html">引入新的Microsoft Edge和Bing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>