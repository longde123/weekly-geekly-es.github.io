<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏼 🤵🏼 👨🏻‍🎤 Rust 1.32 Release 😇 ☁️ 📓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Rust-Entwicklungsteam freut sich, die Veröffentlichung einer neuen Version von Rust, 1.32.0, bekannt zu geben. Rust ist eine Programmiersprache, m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 1.32 Release</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436854/"><p>  Das Rust-Entwicklungsteam freut sich, die Veröffentlichung einer neuen Version von Rust, 1.32.0, bekannt zu geben.  Rust ist eine Programmiersprache, mit der jeder zuverlässige und effiziente Software erstellen kann. </p><br><p> Wenn Sie eine frühere Version von Rust mit <code>rustup</code> installiert <code>rustup</code> , müssen Sie nur Folgendes tun, um Rust auf Version 1.32.0 zu aktualisieren: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Wenn Sie <code>rustup</code> noch nicht installiert <code>rustup</code> , können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es</a> von der entsprechenden Seite unserer Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">installieren</a> .  <a href="">Detaillierte Versionshinweise für Rust 1.32.0</a> sind auf GitHub verfügbar. </p><br><blockquote>  Ein <code>rustup</code> Hinweis: <code>rustup</code> wurden mehrere neue <code>rustup</code> Releases <code>rustup</code> !  Um <code>rustup</code> selbst zu aktualisieren, führen Sie <code>rustup self update</code> . </blockquote><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1320">  Was ist in der stabilen Version 1.32.0 enthalten </h2><br><p>  Rust 1.32.0 hat mehrere lebensverbessernde Verbesserungen erhalten, den Standardspeicher-Allokator geändert und mehr Funktionen konstant gemacht.  Lesen Sie weiter unten über diese Änderungen oder lesen Sie mehr <a href="">in den Versionshinweisen</a> . </p><a name="habracut"></a><br><h4 id="makros-dbg">  Dbg-Makro </h4><br><p>  Beginnen wir mit einer lebensverbessernden Verbesserung.  Verwenden Sie Print-Debugging?  Wenn dies der Fall ist und Sie während der Arbeit am Code einen Wert drucken möchten, müssen Sie Folgendes tun: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{:?}"</span></span>, x); <span class="hljs-comment"><span class="hljs-comment">//    println!("{:#?}", x);</span></span></code> </pre> <br><p>  Dies ist nicht <em>das größte</em> Hindernis, das die Entwicklung verlangsamt, aber es erfordert zu viel Aufwand, um einfach die Ausgabe des <code>x</code> Werts zu debuggen.  Außerdem wird der Kontext hier nicht berücksichtigt.  Wenn Sie mehrere solcher <code>println!</code>  s wird es schwierig zu bestimmen, worauf sich die Ausgabe bezieht, bis Sie selbst jedem Aufruf Kontextinformationen hinzufügen, was noch mehr Arbeit erfordert. </p><br><p>  Zu diesem Zweck haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir</a> in Rust 1.32.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein neues Makro dbg hinzugefügt!</a>  :: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; dbg!(x); }</code> </pre> <br><p>  Nach dem Starten dieses Programms sehen Sie: </p><br><pre> <code class="plaintext hljs">[src/main.rs:4] x = 5</code> </pre> <br><p>  Zusammen mit dem Variablennamen und seinem Wert werden der Dateiname und die <code>dbg!</code> angezeigt, unter der der <code>dbg!</code> Aufruf durchgeführt wurde <code>dbg!</code>  . </p><br><p>  Darüber hinaus <code>println!</code>  druckt auf Standardausgabe, daher ist es besser, <code>eprintln!</code>  zum Drucken in den Standardfehlerstrom.  Makro <code>dbg!</code>  gibt zu Recht an <code>stderr</code> . </p><br><p>  Dies funktioniert auch in schwierigen Fällen.  Betrachten Sie ein Beispiel für eine faktorielle Implementierung: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { n } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><p>  Um es zu debuggen, können wir <code>eprintln!</code>  :: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { eprintln!(<span class="hljs-string"><span class="hljs-string">"n: {}"</span></span>, n); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { eprintln!(<span class="hljs-string"><span class="hljs-string">"n &lt;= 1"</span></span>); n } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); eprintln!(<span class="hljs-string"><span class="hljs-string">"n: {}"</span></span>, n); n } }</code> </pre> <br><p>  Wir wollen bei jeder Iteration <code>n</code> ausgeben und den Kontext jedes Zweigs sehen.  Für <code>factorial(4)</code> wird Folgendes ausgegeben: </p><br><pre> <code class="plaintext hljs">n: 4 n: 3 n: 2 n: 1 n &lt;= 1 n: 2 n: 6 n: 24</code> </pre> <br><p>  Dies ist akzeptabel, aber nicht besonders gut.  Vielleicht könnten wir daran arbeiten, die Ausgabe von Kontextinformationen zu verbessern, um die Schlussfolgerung klarer zu machen.  Aber anstatt unseren Code zu debuggen, werden wir den Debugging-Code verbessern. </p><br><p>  Betrachten Sie das gleiche Beispiel mit <code>dbg!</code>  :: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dbg!(n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { dbg!(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dbg!(n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>)) } }</code> </pre> <br><p>  Wir haben einfach ein Makro mit jedem der Ausdrücke umbrochen, die wir ausgeben möchten.  Als Ergebnis erhalten wir: </p><br><pre> <code class="plaintext hljs">[src/main.rs:3] n &lt;= 1 = false [src/main.rs:3] n &lt;= 1 = false [src/main.rs:3] n &lt;= 1 = false [src/main.rs:3] n &lt;= 1 = true [src/main.rs:4] 1 = 1 [src/main.rs:5] n * factorial(n - 1) = 2 [src/main.rs:5] n * factorial(n - 1) = 6 [src/main.rs:5] n * factorial(n - 1) = 24 [src/main.rs:11] factorial(4) = 24</code> </pre> <br><p>  Da das Makro <code>dbg!</code>  gibt im Gegensatz zu <code>eprintln!</code> den Debug-Wert selbst <code>eprintln!</code>  Wenn <code>()</code> , müssen wir <em>keine</em> Änderungen an der Struktur unseres Codes vornehmen.  Zusätzlich erhalten wir eine <em>viel</em> nützlichere Schlussfolgerung. </p><br><p>  Wir haben einem so kleinen Makro viel Aufmerksamkeit geschenkt, da wir hoffen, dass es Ihren Debugging-Prozess vereinfacht.  Natürlich arbeiten wir auch weiterhin an der Unterstützung von <code>gdb</code> und Co. </p><br><h4 id="po-umolchaniyu-ubran-jemalloc">  <code>jemalloc</code> wird <code>jemalloc</code> </h4><br><p>  Es war einmal, Rust hatte eine große Laufzeit ähnlich wie Erlang.  Für ihn wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jemalloc</a> anstelle des Systemzuweisers gewählt, weil es oft produktiver war.  Allmählich wurden wir die Laufzeit immer mehr los und am Ende wurde fast alles gelöscht, aber jemalloc blieb.  Wir hatten keine Möglichkeit, einen benutzerdefinierten Allokator auszuwählen, und konnten daher jemalloc nicht vollständig entfernen, um denjenigen, die ihn benötigten, keinen Schaden zuzufügen. </p><br><p>  Darüber hinaus bezog sich die Behauptung, dass <code>jemalloc</code> immer der Standardzuweiser war, hauptsächlich auf die UNIX-Welt, da dies standardmäßig nur auf <em>einigen</em> Plattformen der <code>jemalloc</code> war.  Insbesondere das Ziel von MSVC unter Windows ist seit langem die Verwendung eines Systemzuordners. </p><br><p>  Obwohl jemalloc <em>normalerweise</em> eine gute Leistung aufweist, ist dies nicht immer der Fall.  Darüber hinaus werden jeder ausführbaren Datei etwa 300 Kilobyte hinzugefügt.  Wir haben auch viele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere Probleme</a> mit jemalloc angehäuft.  Im Allgemeinen ist es seltsam, dass die Systemsprache standardmäßig nicht den Systemzuordner verwendet. </p><br><p>  Aus diesen Gründen planten wir, sobald <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust 1.28 die Möglichkeit zur Auswahl eines globalen</a> <code>jemalloc</code> , auf den Standardsystem- <code>jemalloc</code> und <code>jemalloc</code> als externe Bibliothek bereitzustellen.  In Rust 1.32 haben wir diese Arbeit endlich abgeschlossen, und jetzt verwendet Ihr Programm standardmäßig den Systemzuweiser. </p><br><p>  Wenn Sie jemalloc weiterhin verwenden möchten, verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die jemallocator-Bibliothek</a> .  <code>Cargo.toml</code> in <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">jemallocator = "0.1.8"</code> </pre> <br><p>  Und in der Stammdatei Ihres Projekts: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[global_allocator]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;</code> </pre> <br><p>  Das ist alles!  Wenn Sie jemalloc nicht benötigen, müssen Sie es nicht mehr verwenden. Wenn Sie es jedoch benötigen, wird das Problem mit wenigen Codezeilen gelöst. </p><br><h4 id="zaklyuchitelnye-uluchsheniya-sistemy-moduley">  Letzte Verbesserungen des Modulsystems </h4><br><p>  In den letzten beiden Versionen haben wir über verschiedene Verbesserungen des Modulsystems gesprochen.  In 1.32.0 und der Ausgabe 2018 haben wir die neueste Änderung hinzugefügt.  Es wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"einheitliche Pfade" bezeichnet</a> und ermöglicht es Ihnen, mit Importpfaden auf die gleiche Weise wie mit anderen Pfaden zu arbeiten, die zuvor falsch funktionierten.  Zum Beispiel: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue } <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Color::*;</code> </pre> <br><p>  Dieser Code <em>wurde zuvor</em> noch nicht kompiliert, da die verwendeten Pfade mit <code>super</code> , <code>self</code> oder <code>crate</code> .  Dank des Compilers, der konsistente Pfade unterstützt, funktioniert dieser Code jetzt und macht das, was Sie erwarten: Importieren von Varianten der oben definierten Farbaufzählung. </p><br><p>  Diese Änderung vervollständigt unsere Überarbeitung des Modulsystems.  Wir wünschen Ihnen viel Spaß mit dem vereinfachten System! </p><br><h4 id="uluchsheniya-makrosov">  Makroverbesserungen </h4><br><p>  Rust 1.32.0 hat mehrere Makroverbesserungen veröffentlicht.  Zunächst wurde ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neuer Literalfragmentspezifizierer</a> hinzugefügt: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> m { ($lt:literal) =&gt; {}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { m!(<span class="hljs-string"><span class="hljs-string">"some string literal"</span></span>); }</code> </pre> <br><p>  Das <code>literal</code> wird Literalen eines beliebigen Typs zugeordnet: Zeichenfolge, Zahl und Zeichen. </p><br><p>  <code>macro_rules</code> Sie in der <code>macro_rules</code> 2018 auch <code>macro_rules</code> <strong><code>?</code></strong>  :: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> bar { ($(a)?) =&gt; {} }</code> </pre> <br><p>  Fragment mit <strong><code>?</code></strong>  Ein Vorkommen von Null oder Eins wird abgeglichen, genauso wie ein Fragment mit <code>*</code> bereits mit Vorkommen von "Null oder Mehr" und mit <strong><code>+</code></strong> - einem oder mehreren Vorkommen übereinstimmt. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Stabilisierung der Standardbibliothek </h3><br><p>  Makro <code>dbg!</code>  , die wir oben bereits beschrieben haben, ist zu einer wichtigen Ergänzung der Standardbibliothek geworden.  Zusätzlich wurden 19 Funktionen konstant gemacht und alle numerischen primitiven Typen erhielten Konvertierungsfunktionen in ein Bytearray und umgekehrt mit der angegebenen Bytereihenfolge.  Es gibt sechs Funktionen mit den Namen <code>to_&lt;endian&gt;_bytes</code> und <code>from_&lt;endian&gt;_bytes</code> , wobei <code>&lt;endian&gt;</code> lautet: </p><br><ul><li>  <code>ne</code> - native Ordnung (native Endianness) </li><li>  <code>le</code> - order von junior bis senior (little endian) </li><li>  <code>be</code> - order vom ältesten zum jüngsten (big endian) </li></ul><br><p>  Weitere <a href="">Informationen finden Sie in den</a> Versionshinweisen. </p><br><h3 id="uluchsheniya-v-cargo">  Frachtverbesserungen </h3><br><p>  Cargo hat den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alias <strong>Cargo c</strong> für den <strong>Cargo Check-</strong> Befehl erhalten</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ermöglicht</a> nun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Verwendung von Benutzernamen in den Repository-URLs</a> . </p><br><p>  Weitere <a href="">Informationen finden Sie in den</a> Versionshinweisen. </p><br><h2 id="razrabotchiki-1320">  Entwickler 1.32.0 </h2><br><p>  Viele Leute haben zusammen Rust 1.32.0 erstellt.  Ohne jeden von Ihnen hätten wir die Arbeit nicht abschließen können.  <a href="">Vielen Dank!</a> </p><br><p>  <em>Von einem Übersetzer: Ich bedanke mich ganz besonders bei den Mitgliedern der Rustycrate-Community und persönlich bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@dashadee</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ozkriff</a> für ihre Hilfe bei der Übersetzung und beim Korrekturlesen.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436854/">https://habr.com/ru/post/de436854/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436842/index.html">Veeam-Lösung zur Sicherung und Wiederherstellung virtueller Maschinen auf der Nutanix AHV-Plattform. Teil 2</a></li>
<li><a href="../de436846/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 348 (14. - 20. Januar 2019)</a></li>
<li><a href="../de436848/index.html">Die NSA kündigt die Veröffentlichung eines internen Tools für das Reverse Engineering an</a></li>
<li><a href="../de436850/index.html">Häufige Fehler beim Schreiben von Komponententests. Yandex Vortrag</a></li>
<li><a href="../de436852/index.html">Verlangsamung, um die Entwicklung voranzutreiben</a></li>
<li><a href="../de436856/index.html">IT-Entwicklungsplan nach Angaben des Kommunikationsministeriums: digitale Souveränität, Blockchain im Wohnungsbau und kommunale Dienstleistungen, Software für „veränderte Realität“</a></li>
<li><a href="../de436858/index.html">Esperanto, Elven und Klingon</a></li>
<li><a href="../de436860/index.html">Dell und Alienware auf der CES 2019: Ein Leitfaden für alle wichtigen Innovationen</a></li>
<li><a href="../de436862/index.html">AMD Ryzen Matisse der 3. Generation: Octa-Core Zen 2 mit PCIe 4.0 für Desktop</a></li>
<li><a href="../de436864/index.html">So testen Sie Ihre eigene Betriebssystemverteilung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>