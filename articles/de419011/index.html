<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏾 👈🏽 🚁 Jinja2 in der C ++ - Welt, Teil zwei. Rendern 🏮 🧛🏾 🔎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Teil der Geschichte über die Portierung der Jinja2-Template-Engine nach C ++. Sie können die erste hier lesen: Vorlagen dritter Or...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jinja2 in der C ++ - Welt, Teil zwei. Rendern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419011/"><p><img src="https://habrastorage.org/getpro/habr/post_images/c81/fe0/548/c81fe0548837b911b9569cdf49d90ca2.jpg" alt="Jinja2 Logo" align="left">  Dies ist der zweite Teil der Geschichte über die Portierung der Jinja2-Template-Engine nach C ++.  Sie können die erste hier lesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlagen dritter Ordnung oder wie ich Jinja2 nach C ++ portiert habe</a> .  Es wird sich auf den Prozess des Renderns von Vorlagen konzentrieren.  Oder mit anderen Worten, einen Dolmetscher einer Python-ähnlichen Sprache von Grund auf neu zu schreiben. </p><a name="habracut"></a><br><h2 id="rendering-kak-takovoy">  Rendern als solches </h2><br><p> Nach dem Parsen wird die Vorlage zu einem Baum, der Knoten von drei Typen enthält: <strong>Nur-Text</strong> , <strong>berechnete Ausdrücke</strong> und <strong>Kontrollstrukturen</strong> .  Dementsprechend sollte während des Rendervorgangs einfacher Text ohne Änderungen im Ausgabestream platziert werden, Ausdrücke sollten berechnet, in Text konvertiert, der in den Stream eingefügt wird, und Kontrollstrukturen müssen ausgeführt werden.  Auf den ersten Blick war die Implementierung des Renderprozesses nicht kompliziert: Sie müssen nur alle Knoten des Baums umgehen, alles berechnen, alles ausführen und Text generieren.  Alles ist einfach.  Genau solange zwei Bedingungen erfüllt sind: a) Alle Arbeiten werden mit Zeichenfolgen nur eines Typs (Zeichenfolge oder Zeichenfolge) ausgeführt.  b) Es werden nur sehr einfache und grundlegende Ausdrücke verwendet.  Tatsächlich werden inja und Jinja2CppLight mit solchen Einschränkungen implementiert.  Bei meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jinja2Cpp funktionieren</a> beide Bedingungen nicht.  Zunächst habe ich für beide Saitentypen eine transparente Unterstützung festgelegt.  Zweitens wurde die gesamte Entwicklung nur gestartet, um die Jinja2-Spezifikation fast vollständig zu unterstützen, und dies ist im Wesentlichen eine vollwertige Skriptsprache.  Daher musste ich beim Rendern tiefer graben als beim Parsen. </p><br><h3 id="vychislenie-vyrazheniy">  Expressionsbewertung </h3><br><p><img src="https://habrastorage.org/webt/46/i0/0y/46i00yfhkcaiybpae4famsictho.png" align="right">  Eine Vorlage wäre keine Vorlage, wenn sie nicht parametrisiert werden könnte.  Im Prinzip erlaubt Jinja2 die Option, Vorlagen "an sich" zu erstellen - alle erforderlichen Variablen können in der Vorlage selbst festgelegt und dann gerendert werden.  Das Arbeiten in einer Vorlage mit Parametern, die "außerhalb" erhalten wurden, bleibt jedoch der Hauptfall.  Das Ergebnis der Auswertung eines Ausdrucks hängt also davon ab, welche Variablen (Parameter) mit welchen Werten an den Berechnungspunkten sichtbar sind.  Und der Haken ist, dass es in Jinja2 nicht nur Bereiche gibt (die verschachtelt werden können), sondern auch komplizierte Regeln der "Transparenz".  Hier ist zum Beispiel eine Vorlage: </p><br><pre><code class="hljs django"><span class="xml"></span><span class="hljs-template-tag"><span class="xml"></span><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name">set</span></span></span><span class="hljs-template-tag"> param1=10 %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ param1 }}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  Als Ergebnis seiner Wiedergabe wird Text <code>10</code> empfangen <br>  Die Option ist etwas komplizierter: </p><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-tag"><span class="xml"></span><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name">set</span></span></span><span class="hljs-template-tag"> param1=10 %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ param1 }}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">for</span></span></span></span></span><span class="hljs-template-tag"> param1 </span><span class="hljs-keyword"><span class="hljs-template-tag"><span class="hljs-keyword">in</span></span></span><span class="hljs-template-tag"> range(10) %}</span></span><span class="xml"><span class="xml">-</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ param1 }}</span></span><span class="xml"><span class="xml">-</span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">endfor</span></span></span></span></span><span class="hljs-template-tag"> %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ param1 }}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  <code>10-0--1--2--3--4--5--6--7--8--9-10</code> bereits am <code>10-0--1--2--3--4--5--6--7--8--9-10</code> <br>  Der Zyklus generiert einen neuen Bereich, in dem Sie Ihre eigenen Variablenparameter definieren können. Diese Parameter sind außerhalb des Bereichs nicht sichtbar, ebenso wie sie nicht die Werte derselben Parameter im externen Bereich schleifen.  Noch schwieriger mit Erweiterungs- / Blockkonstrukten, aber es ist besser, dies in der Jinja2-Dokumentation zu lesen. </p><br><p>  Somit erscheint der Kontext der Berechnungen.  Oder besser gesagt, Rendering im Allgemeinen: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RenderContext</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: RenderContext(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InternalValueMap&amp; extValues, IRendererCallback* rendererCallback); <span class="hljs-function"><span class="hljs-function">InternalValueMap&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExitScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; found)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = m_scopes.rbegin(); p != m_scopes.rend(); ++ p) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> valP = p-&gt;find(val); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valP != p-&gt;end()) { found = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> valP; } } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> valP = m_externalScope-&gt;find(val); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valP != m_externalScope-&gt;end()) { found = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> valP; } found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_externalScope-&gt;end(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCurrentScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCurrentScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetGlobalScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRendererCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">RenderContext </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> includeCurrentContext)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: InternalValueMap* m_currentScope; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InternalValueMap* m_externalScope; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;InternalValueMap&gt; m_scopes; IRendererCallback* m_rendererCallback; };</code> </pre> <br><p>  <a href="">Von hier aus</a> . </p><br><p>  Der Kontext enthält einen Zeiger auf eine Sammlung von Werten, die beim Aufrufen der Renderfunktion erhalten wurden, eine Liste (Stapel) von Bereichen, den aktuell aktiven Bereich und einen Zeiger auf eine Rückrufschnittstelle mit verschiedenen Funktionen, die zum Rendern nützlich sind.  Aber etwas später über ihn.  Die Parametersuchfunktion führt die Liste der Kontexte nacheinander bis zur externen durch, bis der erforderliche Parameter gefunden wird. </p><br><p>  Nun ein wenig zu den Parametern selbst.  Aus Sicht der externen Schnittstelle (und ihrer Benutzer) unterstützt Jinja2 die folgende Liste gültiger Typen: </p><br><ul><li>  Zahlen (int, double) </li><li>  Saiten (schmal, breit) </li><li>  Bool </li><li>  Arrays (eher dimensionslose Tupel) </li><li>  Wörterbücher </li><li>  Reflektierte C ++ - Strukturen </li></ul><br><p>  All dies wird durch einen speziellen Datentyp beschrieben, der auf Basis von boost :: variante erstellt wurde: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ValueData = boost::variant&lt;EmptyValue, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wstring, <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, boost::recursive_wrapper&lt;ValuesList&gt;, boost::recursive_wrapper&lt;ValuesMap&gt;, GenericList, GenericMap&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Value() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; Value(T&amp;&amp; val, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_if&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;, Value&gt;::value&gt;::type* = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) : m_data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;T&gt;(val)) { } Value(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* val) : m_data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(val)) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; Value(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (&amp;val)[N]) : m_data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(val)) { } Value(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_data(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>&gt;(val)) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> ValueData&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data;} <span class="hljs-function"><span class="hljs-function">ValueData&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data;} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ValueData m_data; };</code> </pre> <br><p>  <a href="">Von hier aus</a> . </p><br><p>  Natürlich können Elemente von Arrays und Wörterbüchern beliebige Typen sein.  Das Problem ist jedoch, dass dieser Satz von Typen für den internen Gebrauch zu eng ist.  Um die Implementierung zu vereinfachen, wurden die folgenden zusätzlichen Typen unterstützt: </p><br><ul><li>  Zeichenfolge im Zielformat.  Es kann schmal oder breit sein, je nachdem, welche Art von Vorlage gerendert wird. </li><li>  aufrufbarer Typ </li><li>  AST-Baumassemblierung </li><li>  Schlüssel-Wert-Paar </li></ul><br><p>  Durch diese Erweiterung wurde es möglich, Servicedaten über den Rendering-Kontext zu übertragen, der sonst in öffentlichen Headern "glänzen" müsste, und einige Algorithmen, die mit Arrays und Wörterbüchern arbeiten, erfolgreicher zu verallgemeinern. </p><br><p>  Boost :: Variante wurde nicht zufällig ausgewählt.  Seine umfangreichen Funktionen werden verwendet, um mit Parametern bestimmter Typen zu arbeiten.  Jinja2CppLight verwendet polymorphe Klassen für denselben Zweck, während inja das Bibliothekstypsystem nlohmann json verwendet.  Diese beiden Alternativen passten leider nicht zu mir.  Grund: die Möglichkeit des n-ary Dispatchings für boost :: variante (und jetzt - std :: variante).  Für einen Variantentyp können Sie einen statischen Besucher erstellen, der zwei bestimmte gespeicherte Typen akzeptiert, und ihn gegen ein Wertepaar setzen.  Und alles wird so funktionieren, wie es sollte!  Im Fall von polymorphen Klassen oder einfachen Gewerkschaften funktioniert diese Bequemlichkeit nicht: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringJoiner</span></span></span><span class="hljs-class"> :</span></span> BaseVisitor&lt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BaseVisitor::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> (); <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EmptyValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; str)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; right)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left + right; } };</code> </pre> <br><p>  <a href="">Von hier aus</a> . </p><br><p>  Ein solcher Besucher heißt ganz einfach: </p><br><pre> <code class="hljs php">InternalValue delimiter = m_args[<span class="hljs-string"><span class="hljs-string">"d"</span></span>]-&gt;Evaluate(context); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InternalValue&amp; val : values) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFirst) isFirst = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result = Apply2&lt;visitors::StringJoiner&gt;(result, delimiter); result = Apply2&lt;visitors::StringJoiner&gt;(result, val); }</code> </pre> <br><p>  <code>Apply2</code> hier ein Wrapper über <code>boost::apply_visitor</code> , der den Besucher des durch den Template-Parameter angegebenen Typs auf ein Paar von Variantenwerten anwendet und zuvor bei Bedarf einige Konvertierungen <code>boost::apply_visitor</code> .  Wenn der Designer des Besuchers Parameter benötigt, werden diese nach den Objekten übergeben, für die der Besucher gilt: </p><br><pre> <code class="hljs vbscript">comparator = [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> KeyValuePair&amp; <span class="hljs-built_in"><span class="hljs-built_in">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> KeyValuePair&amp; <span class="hljs-built_in"><span class="hljs-built_in">right</span></span>) { return ConvertToBool(Apply2&lt;visitors::BinaryMathOperation&gt;(<span class="hljs-built_in"><span class="hljs-built_in">left</span></span>.value, <span class="hljs-built_in"><span class="hljs-built_in">right</span></span>.value, BinaryExpression::LogicalLt, BinaryExpression::CaseSensitive)); };</code> </pre> <br><p><img src="https://habrastorage.org/webt/ql/6e/qd/ql6eqdbjul3yrvjblr0nwjgqet8.png" align="left" width="60%" height="60%">  Die Logik von Operationen mit Parametern lautet daher wie folgt: Variante (n) -&gt; Auspacken mit Besucher -&gt; Ausführen der gewünschten Aktion für bestimmte Werte bestimmter Typen -&gt; Zurückpacken des Ergebnisses in die Variante.  Und ein Minimum an Magie Undercover.  Es wäre in jedem Fall möglich, alles wie in js zu implementieren: Operationen ausführen (z. B. Ergänzungen), ein bestimmtes System zum Konvertieren von Zeichenfolgen in Zahlen, Zahlen in Zeichenfolgen, Zeichenfolgen in Listen usw. auswählen und seltsame und unerwartete Ergebnisse erzielen.  Ich habe einen einfacheren und vorhersehbareren Weg gewählt: Wenn eine Operation an einem Wert (oder einem Wertepaar) unmöglich oder unlogisch ist, wird ein leeres Ergebnis zurückgegeben.  Wenn Sie einer Zeichenfolge eine Zahl hinzufügen, können Sie daher nur dann eine Zeichenfolge erhalten, wenn die Verkettungsoperation ('~') verwendet wird.  Andernfalls ist das Ergebnis ein leerer Wert.  Die Priorität von Operationen wird durch die Grammatik bestimmt, daher sind während der AST-Verarbeitung keine zusätzlichen Überprüfungen erforderlich. </p><br><h3 id="filtry-i-testy">  Filter und Tests </h3><br><p><img src="https://habrastorage.org/webt/iy/zr/pp/iyzrppwjtrqdunkvflnjf1bv5ak.png" align="right" width="50%" height="50%">  Was andere Sprachen in Jinja2 als "Standardbibliothek" bezeichnen, nennt man "Filter".  Im Wesentlichen ist ein Filter eine Art komplexe Operation für einen Wert links vom Zeichen '|', dessen Ergebnis ein neuer Wert ist.  Filter können durch Organisieren einer Pipeline in einer Kette angeordnet werden: <br> <code>{{ menuItems | selectattr('visible') | map(attribute='title') | map('upper') | join(' -&gt; ') }}</code> <br>  Hier werden nur die Elemente mit dem sichtbaren Attribut true auf das Array menuItems ausgewählt. Anschließend wird das title-Attribut aus diesen Elementen in Großbuchstaben konvertiert und die resultierende Liste der Zeilen mit dem Trennzeichen '-&gt;' in eine Zeile eingefügt.  Oder sagen wir als Beispiel aus dem Leben: </p><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-tag"><span class="xml"></span><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name">macro</span></span></span><span class="hljs-template-tag"> MethodsDecl(class, access) %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">for</span></span></span></span></span><span class="hljs-template-tag"> method </span><span class="hljs-keyword"><span class="hljs-template-tag"><span class="hljs-keyword">in</span></span></span><span class="hljs-template-tag"> class.methods | rejectattr('isImplicit') | selectattr('accessType', '</span><span class="hljs-keyword"><span class="hljs-template-tag"><span class="hljs-keyword">in</span></span></span><span class="hljs-template-tag">', access) %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ method.fullPrototype }}</span></span><span class="xml"><span class="xml">; </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">endfor</span></span></span></span></span><span class="hljs-template-tag"> %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name">endmacro</span></span></span><span class="hljs-template-tag"> %}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  <a href="">Von hier aus</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Alternative Option</b> <div class="spoiler_text"><pre> <code class="hljs mel">{% macro MethodsDecl(class, access) %} {{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> method <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> class.methods | rejectattr(<span class="hljs-string"><span class="hljs-string">'isImplicit'</span></span>) | selectattr(<span class="hljs-string"><span class="hljs-string">'accessType'</span></span>, <span class="hljs-string"><span class="hljs-string">'in'</span></span>, access) | map(attribute=<span class="hljs-string"><span class="hljs-string">'fullPrototype'</span></span>) | join(<span class="hljs-string"><span class="hljs-string">';\n'</span></span>) }}; {% endmacro %}</code> </pre> </div></div><br><p>  Dieses Makro durchläuft alle Methoden der angegebenen Klasse, verwirft diejenigen, für die das isImplicit-Attribut auf true festgelegt ist, wählt die verbleibenden Methoden aus, für die der Wert des accessType-Attributs mit einem der angegebenen übereinstimmt, und zeigt deren Prototypen an.  Relativ klar.  Und es ist alles einfacher als dreistöckige Zyklen und wenn es um Zäune geht.  Übrigens kann etwas Ähnliches in C ++ innerhalb der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereich v.3-</a> Spezifikation durchgeführt werden. </p><br><p>  Tatsächlich war der Hauptfehler in der Zeit mit der Implementierung von ungefähr vierzig Filtern verbunden, die ich in den Basissatz aufgenommen habe.  Aus irgendeinem Grund nahm ich an, dass ich in ein oder zwei Wochen damit fertig werden könnte.  Es war zu optimistisch.  Und obwohl die typische Implementierung des Filters recht einfach ist: Nehmen Sie einen Wert und wenden Sie einen Funktor darauf an, es gab zu viele davon, und ich musste basteln. <br>  Eine separate interessante Aufgabe im Implementierungsprozess war die Logik der Argumentverarbeitung.  In Jinja2 können wie in Python an den Aufruf übergebene Argumente entweder benannt oder positionell sein.  Die Parameter in der Filterdeklaration können entweder obligatorisch oder optional sein (mit Standardwerten).  Darüber hinaus können sich optionale Parameter im Gegensatz zu C ++ an einer beliebigen Stelle in der Anzeige befinden.  Es war notwendig, einen Algorithmus zum Kombinieren dieser beiden Listen unter Berücksichtigung unterschiedlicher Fälle zu entwickeln.  Nehmen wir an, es gibt eine Bereichsfunktion: <code>range([start, ]stop[, step])</code> .  Es kann auf folgende Arten aufgerufen werden: </p><br><pre> <code class="hljs lisp">range(<span class="hljs-number"><span class="hljs-number">10</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">1</span></span>) range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">1</span></span>) range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">3</span></span>) range(<span class="hljs-name"><span class="hljs-name">step=2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">2</span></span>) range(<span class="hljs-number"><span class="hljs-number">2</span></span>, step=2, <span class="hljs-number"><span class="hljs-number">10</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Usw.  Und ich würde es sehr begrüßen, wenn im Code zur Implementierung der Filterfunktion nicht alle diese Fälle berücksichtigt werden müssten.  Infolgedessen entschied er sich für die Tatsache, dass im Filtercode, Tester oder Funktionscode die Parameter ausschließlich namentlich angegeben werden.  Eine separate Funktion vergleicht die tatsächliche Liste der Argumente mit der erwarteten Liste der Parameter auf dem Weg, indem überprüft wird, ob alle erforderlichen Parameter auf die eine oder andere Weise angegeben sind: </p><br><div class="spoiler">  <b class="spoiler_title">Großes Stück Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ParsedArguments </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseCallParams</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">initializer_list</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;ArgumentInfo&gt;&amp; args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CallParams&amp; params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; isSucceeded)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArgInfo</span></span></span><span class="hljs-class"> {</span></span> ArgState state = NotFound; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prevNotFound = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextNotFound = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ArgumentInfo* info = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }; boost::container::small_vector&lt;ArgInfo, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt; argsInfo(args.size()); boost::container::small_vector&lt;ParamState, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt; posParamsInfo(params.posParams.size()); isSucceeded = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ParsedArguments result; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstMandatoryIdx = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prevNotFound = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundKwArgs = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Find all provided keyword args for (auto&amp; argInfo : args) { argsInfo[argIdx].info = &amp;argInfo; auto p = params.kwParams.find(argInfo.name); if (p != params.kwParams.end()) { result.args[argInfo.name] = p-&gt;second; argsInfo[argIdx].state = Keyword; ++ foundKwArgs; } else { if (argInfo.mandatory) { argsInfo[argIdx].state = NotFoundMandatory; if (firstMandatoryIdx == -1) firstMandatoryIdx = argIdx; } else { argsInfo[argIdx].state = NotFound; } if (prevNotFound != -1) argsInfo[prevNotFound].nextNotFound = argIdx; argsInfo[argIdx].prevNotFound = prevNotFound; prevNotFound = argIdx; } ++ argIdx; } int startPosArg = firstMandatoryIdx == -1 ? 0 : firstMandatoryIdx; int curPosArg = startPosArg; int eatenPosArgs = 0; // Determine the range for positional arguments scanning bool isFirstTime = true; for (; eatenPosArgs &lt; posParamsInfo.size(); ++ eatenPosArgs) { if (isFirstTime) { for (; startPosArg &lt; args.size() &amp;&amp; (argsInfo[startPosArg].state == Keyword || argsInfo[startPosArg].state == Positional); ++ startPosArg) ; isFirstTime = false; continue; } int prevNotFound = argsInfo[startPosArg].prevNotFound; if (prevNotFound != -1) { startPosArg = prevNotFound; } else if (curPosArg == args.size()) { break; } else { int nextPosArg = argsInfo[curPosArg].nextNotFound; if (nextPosArg == -1) break; curPosArg = nextPosArg; } } // Map positional params to the desired arguments int curArg = startPosArg; for (int idx = 0; idx &lt; eatenPosArgs &amp;&amp; curArg != -1; ++ idx, curArg = argsInfo[curArg].nextNotFound) { result.args[argsInfo[curArg].info-&gt;name] = params.posParams[idx]; argsInfo[curArg].state = Positional; } // Fill default arguments (if missing) and check for mandatory for (int idx = 0; idx &lt; argsInfo.size(); ++ idx) { auto&amp; argInfo = argsInfo[idx]; switch (argInfo.state) { case Positional: case Keyword: continue; case NotFound: { if (!IsEmpty(argInfo.info-&gt;defaultVal)) result.args[argInfo.info-&gt;name] = std::make_shared&lt;ConstantExpression&gt;(argInfo.info-&gt;defaultVal); break; } case NotFoundMandatory: isSucceeded = false; break; } } // Fill the extra positional and kw-args for (auto&amp; kw : params.kwParams) { if (result.args.find(kw.first) != result.args.end()) continue; result.extraKwArgs[kw.first] = kw.second; } for (auto idx = eatenPosArgs; idx &lt; params.posParams.size(); ++ idx) result.extraPosArgs.push_back(params.posParams[idx]); return result; }</span></span></code> </pre> <br><p>  <a href="">Von hier aus</a> . </p></div></div><br><p>  Es wird so genannt (zum Beispiel für <code>range</code> ): </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isArgsParsed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> args = helpers::ParseCallParams({{<span class="hljs-string"><span class="hljs-string">"start"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"stop"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"step"</span></span>}}, m_params, isArgsParsed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isArgsParsed) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InternalValue();</code> </pre> <br><p>  und gibt die folgende Struktur zurück: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParsedArguments</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, ExpressionEvaluatorPtr&lt;&gt;&gt; args; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, ExpressionEvaluatorPtr&lt;&gt;&gt; extraKwArgs; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ExpressionEvaluatorPtr&lt;&gt;&gt; extraPosArgs; ExpressionEvaluatorPtr&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = args.find(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == args.end()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p-&gt;second; } };</code> </pre> <br><p>  das notwendige Argument, von dem es einfach durch seinen Namen genommen wird: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">auto</span></span> startExpr = args[<span class="hljs-string"><span class="hljs-string">"start"</span></span>]; <span class="hljs-attribute"><span class="hljs-attribute">auto</span></span> stopExpr = args[<span class="hljs-string"><span class="hljs-string">"stop"</span></span>]; <span class="hljs-attribute"><span class="hljs-attribute">auto</span></span> stepExpr = args[<span class="hljs-string"><span class="hljs-string">"step"</span></span>]; <span class="hljs-attribute"><span class="hljs-attribute">InternalValue</span></span> startVal = startExpr ? startExpr-&gt;Evaluate(values) : InternalValue(); <span class="hljs-attribute"><span class="hljs-attribute">InternalValue</span></span> stopVal = stopExpr ? stopExpr-&gt;Evaluate(values) : InternalValue(); <span class="hljs-attribute"><span class="hljs-attribute">InternalValue</span></span> stepVal = stepExpr ? stepExpr-&gt;Evaluate(values) : InternalValue();</code> </pre> <br><p>  Ein ähnlicher Mechanismus wird bei der Arbeit mit Makros und Testern verwendet.  Und obwohl es anscheinend nicht kompliziert ist, die Argumente der einzelnen Filter und Tests zu beschreiben, gibt es keine (wie man sie implementiert), aber selbst die „Grundmenge“, die etwa fünfzig von diesen und anderen umfasste, erwies sich als ziemlich umfangreich für die Implementierung.  Und dies vorausgesetzt, dass es nicht alle möglichen kniffligen Dinge enthielt, wie das Formatieren von Zeichenfolgen für HTML (oder C ++), das Ausgeben von Werten in Formaten wie XML oder JSON und dergleichen. </p><br><p>  Im nächsten Teil konzentrieren wir uns auf die Implementierung der Arbeit mit mehreren Vorlagen (Export, Include, Makros) sowie auf faszinierende Abenteuer mit der Implementierung der Fehlerbehandlung und die Arbeit mit Zeichenfolgen unterschiedlicher Breite. </p><br><p>  Traditionell Links: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jinja2-Spezifikation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jinja2Cpp Implementierung</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419011/">https://habr.com/ru/post/de419011/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419001/index.html">5 „Super Skills“, die für die Arbeit der Zukunft notwendig sind</a></li>
<li><a href="../de419003/index.html">Blockchain News Digest</a></li>
<li><a href="../de419005/index.html">Ausflug zum Umspannwerk 220/110/20</a></li>
<li><a href="../de419007/index.html">Texturen für 64k Intro: wie es heute gemacht wird</a></li>
<li><a href="../de419009/index.html">Clang und IDE: Eine Geschichte über Freundschaft und Freundschaft</a></li>
<li><a href="../de419013/index.html">Trichterbasierte Zuordnung für SaaS-B2B-Unternehmen - da wir den Wert aller Marketingbemühungen berücksichtigt haben</a></li>
<li><a href="../de419017/index.html">Was ist neu in ConstraintLayout 1.1?</a></li>
<li><a href="../de419019/index.html">AlterEgo: Ein Gerät, das (einige) Gedanken lesen kann</a></li>
<li><a href="../de419021/index.html">Die wichtigsten Druckarten und ihre Funktionen</a></li>
<li><a href="../de419023/index.html">Wie wir Nginx skaliert und die Welt gerettet haben 54 Jahre jeden Tag warten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>