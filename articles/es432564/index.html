<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëãüèª üë©üèΩ‚Äçü§ù‚Äçüë©üèº üçÆ Rust 2018 sali√≥ ... pero ¬øqu√© es? üå† ‚ôéÔ∏è ü§∏üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo fue escrito por Lin Clarke en colaboraci√≥n con el equipo de desarrollo de Rust ("nosotros" en el texto). Tambi√©n puedes leer la publicac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 2018 sali√≥ ... pero ¬øqu√© es?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432564/"> Este art√≠culo fue escrito por Lin Clarke en colaboraci√≥n con el equipo de desarrollo de Rust ("nosotros" en el texto).  Tambi√©n puedes leer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n</a> en el blog oficial de Rust. <br><br>  La primera versi√≥n de Rust 2018 se lanz√≥ el 6 de diciembre de 2018. En esta versi√≥n, nos centramos en la productividad para que los desarrolladores de Rust comenzaran a trabajar de la manera m√°s eficiente posible. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6de/ed2/a70/6deed2a70423878dfc8d33f655e7a2b1.png"></a> <br>  <i><font color="gray">La l√≠nea de tiempo muestra la transici√≥n de beta a Rust 2018 y Rust 2015. Est√° rodeada de iconos para herramientas y cuatro √°reas: WebAssembly, embebido, redes y CLI.</font></i>  <i><font color="gray">El c√≠rculo rojo (productividad del desarrollador) rodea todo excepto Rust 2015</font></i> <br><br>  Pero, en general, no es f√°cil explicar qu√© es Rust 2018. <br><br>  Algunos lo presentan como una nueva versi√≥n del lenguaje ... algo as√≠, pero en realidad no.  Digo "no realmente", porque aqu√≠ la "nueva versi√≥n" no significa las nuevas versiones de otros idiomas. <br><a name="habracut"></a><br>  En la mayor√≠a de los otros idiomas, todas las funciones nuevas agregan una nueva versi√≥n.  La versi√≥n anterior no est√° actualizada. <br><br>  El sistema Rust funciona de manera diferente.  Esto se debe a c√≥mo se desarrolla el lenguaje.  Casi todas las nuevas caracter√≠sticas son 100% compatibles con Rust.  No requieren ning√∫n cambio.  Esto significa que no hay raz√≥n para limitarlos al c√≥digo Rust 2018. Las versiones m√°s nuevas del compilador continuar√°n admitiendo el "modo Rust 2015" de forma predeterminada. <br><br>  Pero a veces el desarrollo de un lenguaje requiere innovaci√≥n, por ejemplo, una nueva sintaxis.  Y esta nueva sintaxis puede romper las bases de c√≥digo existentes. <br><br>  Por ejemplo, la funci√≥n <code>async/await</code> .  Inicialmente, no exist√≠an tales conceptos en Rust.  Pero result√≥ que estas primitivas son realmente √∫tiles, simplifican la escritura de c√≥digo asincr√≥nico. <br><br>  Para esta funci√≥n, se deben agregar las palabras clave <code>async</code> y <code>await</code> .  Pero debe tener cuidado de no romper el c√≥digo anterior donde <code>async</code> o en <code>await</code> podr√≠an usarse como nombres de variables. <br><br>  Por lo tanto, agregamos palabras clave en Rust 2018. Aunque la funci√≥n a√∫n no se ha lanzado, las palabras clave ahora est√°n reservadas.  Todos los cambios incompatibles para los pr√≥ximos tres a√±os de desarrollo (por ejemplo, agregar nuevas palabras clave) se realizan a la vez en Rust 1.31. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3e5/668/f56/3e5668f562d297179b8d4068b7c9be9b.png"></a> <br><br>  Aunque hay cambios incompatibles en Rust 2018, esto no significa que su c√≥digo se romper√°.  Incluso con variables <code>async</code> y en <code>await</code> , el c√≥digo se compilar√°.  Por defecto, el compilador funciona como antes. <br><br>  Pero si desea usar una de las nuevas funciones, puede elegir el nuevo modo de compilaci√≥n de Rust 2018. El comando de <code>cargo fix</code> le dir√° si necesita actualizar el c√≥digo para usar las nuevas funciones y automatizar el proceso de hacer cambios.  Luego, puede agregar <code>edition=2018</code> a su Cargo.toml si acepta el uso de nuevas funciones. <br><br>  Este especificador de versi√≥n en Cargo.toml no se aplica a todo el proyecto y no se aplica a sus dependencias.  Est√° limitado a un estante espec√≠fico.  Es decir, puede usar las cajas Rust 2015 y Rust 2018 al mismo tiempo. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1bf/3d5/2ee/1bf3d52ee511feea588c85160bd85cf3.png"></a> <br><br>  Por lo tanto, incluso cuando se usa Rust 2018, todo se ve casi igual a Rust 2015. La mayor√≠a de los cambios se implementan simult√°neamente en Rust 2018 y Rust 2015. Solo unas pocas funciones requieren cambios incompatibles. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7fe/b6e/f3e/7feb6ef3ece5c67c5b2aec3810ae6d74.png"></a> <br><br>  Rust 2018 no es solo cambios en el idioma principal.  Lejos no solo ellos. <br><br>  Rust 2018 es, en primer lugar, un impulso para mejorar la productividad de los desarrolladores de Rust, en gran parte debido a las herramientas que est√°n fuera del lenguaje, as√≠ como a trav√©s del desarrollo de aplicaciones espec√≠ficas y la comprensi√≥n de c√≥mo hacer que Rust sea el lenguaje de programaci√≥n m√°s efectivo para estos casos. <br><br>  Por lo tanto, puede representar a Rust 2018 como un especificador en Cargo.toml, que se utiliza para incluir varias funciones que requieren cambios incompatibles ... <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b68/747/e52/b68747e52d57489b7f194e245b40a17a.png"></a> <br><br>  O puede imaginarlo en un momento en que Rust se convierte en uno de los lenguajes m√°s eficientes para muchas aplicaciones, cuando necesita rendimiento, uso eficiente de los recursos o alta confiabilidad. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ca0/1d3/29c/ca01d329c8350531ee936706fa95828f.png"></a> <br><br>  Preferimos la segunda versi√≥n de la definici√≥n.  Entonces, echemos un vistazo a todas las mejoras realizadas fuera del idioma, y ‚Äã‚Äãluego sum√©rjase en el lenguaje en s√≠. <br><br><h1>  √ìxido para aplicaciones espec√≠ficas. </h1><br>  Un lenguaje de programaci√≥n no puede ser efectivo en s√≠ mismo, de manera abstracta.  Es efectivo en una aplicaci√≥n particular.  Por lo tanto, entendimos que no solo era necesario mejorar Rust como lenguaje o herramienta.  Tambi√©n es necesario simplificar el uso de Rust en ciertas √°reas. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/16f/bde/bbf/16fbdebbf44451fdb8f6c75b78794a2a.png"></a> <br><br>  En algunos casos, esto significaba crear un conjunto completamente nuevo de herramientas para un ecosistema completamente nuevo.  En otros casos, pulir las funciones existentes y una buena documentaci√≥n para facilitar la tarea de generar y ejecutar un sistema de trabajo. <br><br>  El equipo de desarrollo de Rust ha formado grupos de trabajo en cuatro √°reas: <br><br><ul><li>  Montaje web </li><li>  Aplicaciones Embebidas </li><li>  Tareas de red </li><li>  Herramientas de l√≠nea de comando </li></ul><br><h2>  Montaje web </h2><br>  WebAssembly tuvo que crear un conjunto completamente nuevo de herramientas. <br><br>  Solo el a√±o pasado WebAssembly hizo posible compilar lenguajes como Rust para que se ejecuten en Internet.  Desde entonces, Rust se ha convertido r√°pidamente en el mejor lenguaje para integrarse con las aplicaciones web existentes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22c/92f/083/22c92f0837c668948edbf0dccc193428.png"><br><br>  Rust es muy adecuado para el desarrollo web por dos razones: <br><br><ol><li>  El ecosistema Cargo Crash funciona de la manera en que la mayor√≠a de los desarrolladores de aplicaciones web est√°n acostumbrados.  Combina un mont√≥n de peque√±os m√≥dulos para formar una aplicaci√≥n m√°s grande.  Esto significa que Rust es f√°cil de usar exactamente donde lo necesita. </li><li>  El √≥xido es bajo en recursos y no requiere tiempo de ejecuci√≥n.  No necesitas mucho c√≥digo.  Si tiene un peque√±o m√≥dulo que hace mucho trabajo inform√°tico, implemente algunas l√≠neas Rust para acelerarlo. </li></ol><br>  Usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">web-sys y js-sys</a> del c√≥digo Rust, es f√°cil llamar a API web como <code>fetch</code> o <code>appendChild</code> .  Y <code>wasm-bindgen</code> facilita el soporte de tipos de datos de nivel superior que WebAssembly no admite de forma nativa. <br><br>  Despu√©s de escribir el m√≥dulo Rust WebAssembly, hay herramientas para conectarlo f√°cilmente al resto de la aplicaci√≥n web.  Puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wasm-pack</a> para iniciar autom√°ticamente estas herramientas y ejecutar el m√≥dulo en npm si lo desea. <br><br>  Consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libro Rust and WebAssembly para obtener m√°s informaci√≥n</a> . <br><br><h4>  Que sigue </h4><br>  Despu√©s del lanzamiento de Rust 2018, los desarrolladores planean discutir con la comunidad en qu√© direcciones trabajar m√°s. <br><br><h2>  Aplicaciones Embebidas </h2><br>  Para el desarrollo integrado, era necesario aumentar la estabilidad de la funcionalidad existente. <br><br>  Te√≥ricamente, Rust siempre ha sido un buen lenguaje para aplicaciones integradas.  Este es un kit de herramientas moderno, que era muy escaso para los desarrolladores, y funciones de lenguaje de alto nivel muy convenientes.  Todo esto sin carga innecesaria en la CPU y la memoria.  Por lo tanto, Rust es ideal para incrustar. <br><br>  Pero en la pr√°ctica result√≥ diferente.  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canal estable</a> carec√≠a de las funciones necesarias.  Adem√°s, para su uso en dispositivos integrados, era necesario cambiar la biblioteca est√°ndar.  Esto significa que las personas tuvieron que compilar su propia versi√≥n de la caja principal de Rust (la caja que se usa en cada aplicaci√≥n de Rust para proporcionar los bloques de construcci√≥n b√°sicos de Rust: funciones integradas y primitivas). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/162/8b8/701/1628b8701eeffba2db1c7abe75f5a018.png"></a> <br><br>  Como resultado, los desarrolladores depend√≠an de la versi√≥n experimental de Rust.  Y en ausencia de pruebas autom√°ticas, el ensamblaje experimental a menudo no funcionaba en microcontroladores. <br><br>  Para solucionar esto, los desarrolladores intentaron transferir todas las funciones necesarias a un canal estable, agregar pruebas al sistema CI para microcontroladores.  Esto significa que cambiar un componente de escritorio no interrumpir√° la versi√≥n integrada. <br><br>  Con tales cambios, el desarrollo de sistemas embebidos en Rust se est√° moviendo del campo de los experimentos avanzados al campo de la eficiencia normal. <br><br>  Para obtener m√°s informaci√≥n, consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libro Rust for Embedded Systems</a> . <br><br><h4>  Que sigue </h4><br>  Este a√±o, Rust obtuvo un muy buen apoyo para la popular familia ARM Cortex-M.  Sin embargo, muchas arquitecturas a√∫n no est√°n bien soportadas.  Rust necesita expandirse para proporcionar soporte similar para otras arquitecturas. <br><br><h2>  Tareas de red </h2><br>  Para trabajar en la red, era necesario integrar una abstracci√≥n clave en el lenguaje: <code>async/await</code> .  Por lo tanto, los desarrolladores pueden usar modismos est√°ndar de Rust incluso en c√≥digo asincr√≥nico. <br><br>  En las tareas de red, a menudo tiene que esperar.  Por ejemplo, una respuesta a una solicitud.  Si el c√≥digo es s√≠ncrono, el trabajo se detendr√°: el n√∫cleo del procesador en el que se ejecuta el c√≥digo no puede hacer nada hasta que llegue una solicitud.  Pero en el c√≥digo as√≠ncrono, dicha funci√≥n se puede poner en modo de espera, mientras que el n√∫cleo de la CPU har√° el resto. <br><br>  La programaci√≥n asincr√≥nica tambi√©n es posible en Rust 2015, y esto tiene muchas ventajas.  En aplicaciones de alto rendimiento, la aplicaci√≥n del servidor manejar√° muchas m√°s conexiones a cada servidor.  Las aplicaciones integradas en peque√±as CPU de un solo subproceso optimizan el uso de un solo subproceso. <br><br>  Pero estas ventajas van acompa√±adas de un gran inconveniente: para dicho c√≥digo, la verificaci√≥n de pr√©stamo no funciona y debe usar modismos de √≥xido no est√°ndar (y ligeramente confusos).  Este es el beneficio de <code>async/await</code> .  Esto le da al compilador la informaci√≥n necesaria para probar los pr√©stamos de llamadas a funciones as√≠ncronas. <br><br>  Las palabras clave para <code>async/await</code> implementan en la versi√≥n 1.31, aunque actualmente no son compatibles con la implementaci√≥n.  La mayor parte del trabajo est√° hecho, y la funci√≥n deber√≠a estar disponible en la pr√≥xima versi√≥n. <br><br><h4>  Que sigue </h4><br>  Adem√°s del desarrollo efectivo de bajo nivel, Rust puede proporcionar un desarrollo m√°s eficiente de aplicaciones de red en un nivel superior. <br><br>  Muchos servidores realizan tareas rutinarias: analizar URL o trabajar con HTTP.  Si los convierte en componentes, abstracciones comunes que se comparten como cajas, entonces ser√° f√°cil conectarlos entre s√≠, formando todo tipo de configuraciones de servidor y marco. <br><br>  Se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ha</a> creado un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">marco</a> experimental de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tide</a> para desarrollar y probar componentes. <br><br><h2>  Herramientas de l√≠nea de comando </h2><br>  Para las herramientas de l√≠nea de comandos, era necesario combinar peque√±as bibliotecas de bajo nivel en abstracciones de alto nivel y pulir algunas herramientas existentes. <br><br>  Para algunos scripts, bash es ideal.  Por ejemplo, simplemente invocar otras herramientas de shell y pasar datos entre ellas. <br><br>  Pero Rust es una gran opci√≥n para muchas otras herramientas.  Por ejemplo, si crea una herramienta compleja como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ripgrep</a> o una herramienta CLI adem√°s de la funcionalidad de una biblioteca existente. <br><br>  Rust no requiere tiempo de ejecuci√≥n y se compila en un solo binario est√°tico, lo que simplifica la distribuci√≥n del programa.  Y obtienes abstracciones de alto nivel que no est√°n en otros lenguajes, como C y C ++. <br><br>  ¬øQu√© m√°s puede mejorar el √≥xido?  Por supuesto, abstracciones de un nivel a√∫n m√°s alto. <br><br>  Con abstracciones de nivel superior, un CLI listo para usar se ensambla r√°pida y f√°cilmente. <br><br>  Un ejemplo de tal abstracci√≥n es la biblioteca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">p√°nico humano</a> .  En ausencia de dicha biblioteca, en caso de falla, el c√≥digo CLI probablemente devolver√° todo el retroceso.  Pero no es muy interesante para los usuarios.  Puede agregar un manejo de errores personalizado, pero es dif√≠cil. <br><br>  Con la biblioteca de p√°nico humano, la salida ir√° autom√°ticamente al archivo de volcado de error.  El usuario ver√° un mensaje informativo que ofrece informar un problema y descargar el archivo de volcado. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecb/f4a/908/ecbf4a90823e7b1d83ce1688b5d7383a.png"><br><br>  Comenzar a desarrollar herramientas de CLI tambi√©n se ha vuelto m√°s f√°cil.  Por ejemplo, la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">confy</a> automatiza su configuraci√≥n.  √âl solo pregunta dos cosas: <br><br><ul><li>  ¬øCu√°l es el nombre de la aplicaci√≥n? </li><li>  ¬øQu√© par√°metros de configuraci√≥n desea proporcionar (que define como una estructura que se puede serializar y deserializar)? </li></ul><br>  Confy determinar√° todo lo dem√°s por s√≠ solo. <br><br><h4>  Que sigue </h4><br>  Extrajimos muchas tareas para la CLI.  Pero hay algo m√°s que abstraer.  Vamos a lanzar m√°s bibliotecas de alto nivel. <br><br><h1>  Herramientas de √≥xido </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/e6e/2cf/090/e6e2cf09085886f3c044fcec3ce86ed7.png"><br><br>  Cuando escribe en cualquier idioma, trabaja con sus herramientas: comenzando con el editor y continuando con otras herramientas en todas las etapas de desarrollo y soporte. <br><br>  Esto significa que un lenguaje efectivo depende de herramientas efectivas. <br><br>  Aqu√≠ hay algunas herramientas nuevas (y mejoras a las existentes) en Rust 2018. <br><br><h2>  Soporte IDE </h2><br>  Por supuesto, el rendimiento depende de la transferencia r√°pida y sin problemas del c√≥digo de la mente del desarrollador a la pantalla de la computadora.  Aqu√≠ es donde el soporte IDE es crucial.  Para hacer esto, necesitamos herramientas que puedan "explicar" el IDE al significado del c√≥digo Rust: por ejemplo, sugerir opciones significativas para el autocompletado de cadenas. <br><br>  En Rust 2018, la comunidad se centr√≥ en las caracter√≠sticas requeridas por el IDE.  Con el advenimiento de Rust Language Server e IntelliJ Rust, muchos IDE ahora son totalmente compatibles con Rust. <br><br><h2>  Compilaci√≥n m√°s r√°pida </h2><br>  Mejorar el rendimiento del compilador significa acelerarlo.  Esto es lo que hicimos. <br><br>  Anteriormente, cuando compilaba la caja Rust, el compilador volv√≠a a compilar todos los archivos de la caja.  La compilaci√≥n incremental ahora se implementa: compila solo aquellas partes que han cambiado.  Junto con otras optimizaciones, esto hizo que el compilador Rust fuera mucho m√°s r√°pido. <br><br><h2>  rustfmt </h2><br>  La eficiencia tambi√©n requiere que nunca discutamos sobre las reglas de formato de c√≥digo o que arreglemos manualmente los estilos de otras personas. <br><br>  La herramienta rustfmt ayuda con esto: reformatear√° autom√°ticamente el c√≥digo de acuerdo con el estilo predeterminado (por el cual la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad ha alcanzado un consenso</a> ).  Rustfmt garantiza que todo el c√≥digo Rust coincida con el mismo estilo, como el formato clang para C ++ o Prettier para JavaScript. <br><br><h2>  Clippy </h2><br>  A veces es bueno tener un consultor experimentado cerca que le brinde consejos sobre las mejores pr√°cticas para escribir c√≥digo.  Esto es lo que hace Clippy: comprueba el c√≥digo mientras lo ve y sugiere modismos est√°ndar. <br><br><h2>  rustfix </h2><br>  Pero si tiene una base de c√≥digo antigua con modismos obsoletos, entonces verificar y corregir independientemente el c√≥digo puede ser agotador.  Solo quiere que alguien haga correcciones a toda la base de c√≥digo. <br><br>  En estos casos, rustfix automatiza el proceso.  Aplica simult√°neamente reglas de herramientas como Clippy y actualiza el c√≥digo antiguo de acuerdo con los modismos de Rust 2018. <br><br><h1>  Cambios al √≥xido mismo </h1><br>  Los cambios en el ecosistema han aumentado significativamente la eficiencia de la programaci√≥n.  Pero algunos problemas solo pueden resolverse mediante cambios en el lenguaje mismo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/ec4/993/e54ec49930ed33cb1eac85814f10e7b5.png"><br><br>  Como dijimos en la introducci√≥n, la mayor√≠a de los cambios de idioma son totalmente compatibles con el c√≥digo Rust existente.  Todos estos cambios son parte de Rust 2018. Pero como no rompen nada, funcionan en cualquier c√≥digo Rust ... incluso en el antiguo. <br><br>  Veamos las caracter√≠sticas importantes que se agregan a todas las versiones.  Luego mira una breve lista de caracter√≠sticas de Rust 2018. <br><br><h2>  Nuevas funciones para todas las versiones. </h2><br>  Aqu√≠ hay un peque√±o ejemplo de las nuevas caracter√≠sticas que est√°n (o estar√°n) en todas las versiones del lenguaje. <br><br><h4>  Verificaci√≥n de pr√©stamos m√°s precisa </h4><br>  Una gran ventaja de Rust es su verificaci√≥n de pr√©stamo.  Asegura que el c√≥digo sea seguro para la memoria.  Pero esta tambi√©n es una caracter√≠stica bastante complicada para los novatos en Rust. <br><br>  Parte de la dificultad radica en aprender nuevos conceptos.  Pero hay otra parte ... La prueba de pr√©stamos a veces rechaza el c√≥digo que parece funcionar desde el punto de vista de un programador que comprende completamente el concepto de seguridad de la memoria. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d5c/84e/629/d5c84e629b289c9fa88ef9316a4c59a3.png"></a> <br>  <i><font color="gray">No puede pedir prestada una variable porque ya est√° prestada</font></i> <br><br>  Esto sucede porque se supon√≠a que la vida √∫til del pr√©stamo se extend√≠a hasta el final de su campo, por ejemplo, hasta el final de la funci√≥n en la que se encuentra la variable. <br><br>  Esto significaba que incluso si la variable terminaba de funcionar con el valor y ya no intentaba acceder, a otras variables a√∫n se les niega el acceso a este valor hasta el final de la funci√≥n. <br><br>  Para corregir la situaci√≥n, hicimos el cheque m√°s inteligente.  Ahora ve cu√°ndo la variable <i>realmente</i> ha terminado de usar el valor.  Despu√©s de eso, no bloquea el uso de datos. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0cb/a0c/805/0cba0c80529d7132ffea917007f9e08b.png"></a> <br><br>  Si bien esto est√° disponible solo en Rust 2018, pero en un futuro cercano, la funci√≥n se agregar√° a todas las dem√°s versiones.  Pronto escribiremos m√°s sobre este tema. <br><br><h4>  Macros procesales en √≥xido estable </h4><br>  Rust ten√≠a macros antes de Rust 1.0.  Pero en Rust 2018, se realizaron serias mejoras, por ejemplo, aparecieron macros de procedimiento.  Le permiten agregar su propia sintaxis a Rust. <br><br>  Rust 2018 ofrece dos tipos de macros de procedimiento: <br><br><h4>  Macros de funciones </h4><br>  Las macros similares a funciones le permiten crear objetos que parecen llamadas a funciones normales, pero que en realidad se ejecutan en tiempo de compilaci√≥n.  Toman un c√≥digo y dan otro, que el compilador luego inserta en el binario. <br><br>  Existieron antes, pero con limitaciones.  Una macro solo puede ejecutar la declaraci√≥n de coincidencia.  No ten√≠a acceso para ver todos los tokens en el c√≥digo entrante. <br><br>  Pero con las macros de procedimiento, obtienes la misma entrada que el analizador: la misma secuencia de tokens.  Esto significa que puede crear macros mucho m√°s potentes como funciones. <br><br><h4>  Macros tipo atributo </h4><br>  Si est√° familiarizado con decoradores en lenguajes como JavaScript, las macros de atributos son muy similares.  Le permiten anotar fragmentos de c√≥digo Rust que deben procesarse previamente y convertirse en otra cosa. <br><br>  La macro <code>derive</code> hace exactamente eso.  Cuando lo coloca sobre una estructura, el compilador toma esa estructura (despu√©s de analizarla como una lista de tokens) y la procesa.  En particular, agrega una implementaci√≥n b√°sica de funciones desde el rasgo. <br><br><h4>  M√°s pr√©stamos ergon√≥micos en las comparaciones </h4><br>  Hay un cambio simple. <br><br>  Anteriormente, si quer√≠a pedir prestado algo e intentaba hacer coincidir, ten√≠a que agregar una sintaxis extra√±a: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/91c/a80/cc5/91ca80cc5221b9bfd18473567eac6d87.png"></a> <br><br>  Ahora, en lugar de <code>&amp;Some(ref s)</code> simplemente escribimos <code>Some(s)</code> . <br><br><h1>  Nuevas caracter√≠sticas de Rust 2018 </h1><br>  La parte m√°s peque√±a de Rust 2018 es caracter√≠sticas espec√≠ficas de esta versi√≥n.  Aqu√≠ hay un peque√±o conjunto de cambios en Rust 2018. <br><br><h3>  Palabras clave </h3><br>  Rust 2018 agreg√≥ algunas palabras clave: <br><br><ul><li> <code>try</code> </li> <li> <code>async/await</code> </li> </ul><br>  Estas caracter√≠sticas a√∫n no est√°n completamente implementadas, pero las palabras clave se agregan en Rust 1.31.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por lo tanto, en el futuro no tendremos que introducir nuevas palabras clave (lo que se convertir√≠a en un cambio incompatible) cuando implementemos estas funciones. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sistema modular </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un gran dolor para los novatos en Rust es el sistema modular. </font><font style="vertical-align: inherit;">Y est√° claro por qu√©. </font><font style="vertical-align: inherit;">Era dif√≠cil entender por qu√© Rust elige un m√≥dulo en particular. </font><font style="vertical-align: inherit;">Para solucionar esto, hicimos algunos cambios en el mecanismo de ruta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, si import√≥ un bastidor, puede usarlo en la ruta en el nivel superior. </font><font style="vertical-align: inherit;">Pero si mueve cualquier c√≥digo a un subm√≥dulo, ya no funcionar√°.</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// top level module extern crate serde; // this works fine at the top level impl serde::Serialize for MyType { ... } mod foo { // but it does *not* work in a sub-module impl serde::Serialize for OtherType { ... } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro ejemplo es el prefijo </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que se usa tanto para la ra√≠z de la caja como para la caja externa. </font><font style="vertical-align: inherit;">Es dif√≠cil entender lo que est√° ante nosotros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo hicimos m√°s expl√≠cito. </font><font style="vertical-align: inherit;">Ahora, si desea hacer referencia a la caja ra√≠z, utilice el prefijo </font></font><code>crate::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta es solo una de las mejoras para la claridad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si desea que el c√≥digo actual use las capacidades de Rust 2018, lo m√°s probable es que necesite actualizar el c√≥digo para tener en cuenta las nuevas rutas. </font><font style="vertical-align: inherit;">Pero no es necesario hacer esto manualmente. </font><font style="vertical-align: inherit;">Antes de agregar el especificador de versi√≥n a Cargo.toml, simplemente ejec√∫telo </font></font><code>cargo fix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>rustfix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realice los cambios necesarios.</font></font><br><br><h1>  Informaci√≥n adicional </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toda la informaci√≥n sobre la nueva versi√≥n del idioma est√° contenida </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la Gu√≠a Rust 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432564/">https://habr.com/ru/post/es432564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432554/index.html">Douglas Engelbart: Fortalecimiento de la sociedad del "coeficiente intelectual colectivo"</a></li>
<li><a href="../es432556/index.html">Tecnolog√≠a patentada de Tesla para posicionar veh√≠culos</a></li>
<li><a href="../es432558/index.html">Patr√≥n arquitect√≥nico "Visitante" en los universos "iOS" y "Swift"</a></li>
<li><a href="../es432560/index.html">Tipograf√≠a en la web. Conferencia de Yandex en FrontTalks 2018</a></li>
<li><a href="../es432562/index.html">Techday Make IT Real - 17 de diciembre, Mosc√∫</a></li>
<li><a href="../es432566/index.html">Dos mundos o "ingenieros tienen algo que decir". Sobre los diversos tipos de tareas complejas y los procesos asociados con ellas</a></li>
<li><a href="../es432568/index.html">"Cuando eres el editor jefe de Rusbase": un nuevo podcast sobre c√≥mo trabajar con contenido y una carrera en medios tecnol√≥gicos</a></li>
<li><a href="../es432572/index.html">El transistor metal-aire ampliar√° la Ley de Moore: c√≥mo funciona la tecnolog√≠a</a></li>
<li><a href="../es432574/index.html">Dise√±o sofisticado de dispositivos simples.</a></li>
<li><a href="../es432576/index.html">Bajo el cap√≥ de un JobIntentService</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>