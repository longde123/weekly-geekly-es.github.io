<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👦 🤛🏾 🤴🏽 So funktioniert JS: Benutzerdefinierte Elemente 🎧 🖊️ 😫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Lesen empfehlen] Die anderen 19 Teile des Zyklus  Teil 1: Überblick über die Engine, Laufzeitmechanismen, Aufrufstapel 
 Teil 2: Informationen zu V8-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So funktioniert JS: Benutzerdefinierte Elemente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/419831/"><div class="spoiler">  <b class="spoiler_title">[Lesen empfehlen] Die anderen 19 Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überblick über die Engine, Laufzeitmechanismen, Aufrufstapel</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu V8-Interna und Codeoptimierung</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten des Speichers, vier Arten von Speicherlecks und Umgang mit ihnen</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Async und fünf Möglichkeiten zur Verbesserung Ihres Codes mit Async / Warten</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebSocket und HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was soll ich wählen?</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen und Umfang von WebAssembly</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web Worker und fünf Nutzungsszenarien</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Servicemitarbeiter</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web-Push-Benachrichtigungen</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verfolgen Sie Änderungen im DOM mit MutationObserver</a> <br>  Teil 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering-Engines für Webseiten und Tipps zur Optimierung ihrer Leistung</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Animation mit CSS und JavaScript</a> <br>  Teil 14: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Abstrakte Syntaxbäume, Analyse und deren Optimierung</a> <br>  Teil 15: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Klassen und Vererbung, Transpilation in Babel und TypeScript</a> <br>  Teil 16: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Speicher</a> <br>  Teil 17: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Shadow DOM-Technologie und Webkomponenten</a> <br>  Teil 18: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: WebRTC- und P2P-Kommunikationsmechanismen</a> <br>  Teil 19: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Benutzerdefinierte Elemente</a> </div></div><br>  Wir präsentieren Ihnen eine Übersetzung von 19 Artikeln aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SessionStack-</a> Materialreihe zu den Merkmalen verschiedener Mechanismen des JavaScript-Ökosystems.  Heute werden wir über den Standard für benutzerdefinierte Elemente sprechen - die sogenannten "benutzerdefinierten Elemente".  Wir werden darüber sprechen, welche Aufgaben sie lösen dürfen und wie sie erstellt und verwendet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/188/85f/00e18885fa38229e7bc5cc7c4489147c.png" alt="Bild"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Rückblick</font> </h2><br>  In einem der vorherigen Artikel dieser Reihe haben wir über das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shadow DOM</a> und einige andere Technologien gesprochen, die Teil eines größeren Phänomens sind - Webkomponenten.  Webkomponenten sollen Entwicklern ermöglichen, die Standardfunktionen von HTML zu erweitern, indem sie kompakte, modulare und wiederverwendbare Elemente erstellen.  Dies ist der relativ neue W3C-Standard, den Hersteller aller führenden Browser bereits bemerkt haben.  Er ist in der Produktion zu finden, obwohl seine Arbeit natürlich von Polyphilen stammt (wir werden später darüber sprechen). <br><br>  Wie Sie vielleicht bereits wissen, bieten uns Browser einige wichtige Tools für die Entwicklung von Websites und Webanwendungen.  Es geht um HTML, CSS und JavaScript.  HTML wird verwendet, um Webseiten zu strukturieren. Dank CSS erhalten sie ein schönes Aussehen, und JavaScript ist für die interaktiven Funktionen verantwortlich.  Vor dem Erscheinen von Webkomponenten war es jedoch nicht so einfach, von JavaScript implementierte Aktionen einer HTML-Struktur zuzuordnen. <br><br>  In der Tat werden wir hier die Basis von Webkomponenten betrachten - benutzerdefinierte Elemente.  Kurz gesagt, die API, die für die Zusammenarbeit mit ihnen entwickelt wurde, ermöglicht es dem Programmierer, eigene HTML-Elemente mit integrierter JavaScript-Logik und von CSS beschriebenen Stilen zu erstellen.  Viele verwechseln benutzerdefinierte Elemente mit der Shadow DOM-Technologie.  Dies sind jedoch zwei völlig unterschiedliche Dinge, die sich zwar ergänzen, aber nicht austauschbar sind. <br><br>  Einige Frameworks (wie Angular oder React) versuchen, dasselbe Problem zu lösen, das benutzerdefinierte Elemente lösen, indem sie ihre eigenen Konzepte einführen.  Benutzerdefinierte Elemente können mit Angular-Direktiven oder mit React-Komponenten verglichen werden.  Benutzerdefinierte Elemente sind jedoch eine Standardfunktion des Browsers. Sie müssen nur gewöhnliches JavaScript, HTML und CSS verwenden, um mit ihnen zu arbeiten.  Dies erlaubt uns natürlich nicht zu sagen, dass sie ein Ersatz für gewöhnliche JS-Frameworks sind.  Moderne Frameworks bieten uns viel mehr als nur die Möglichkeit, das Verhalten benutzerdefinierter Elemente zu simulieren.  Infolgedessen können wir sagen, dass sowohl Frameworks als auch Benutzerelemente Technologien sind, die zusammen zur Lösung von Webentwicklungsaufgaben verwendet werden können. <br><br><h2>  <font color="#3AC1EF">API</font> </h2><br>  Bevor wir fortfahren, wollen wir uns ansehen, welche Möglichkeiten uns die API bietet, mit benutzerdefinierten Elementen zu arbeiten.  Es handelt sich nämlich um ein globales <code>customElements</code> Objekt mit mehreren Methoden: <br><br><ul><li>  Mit der Methode <code>define(tagName, constructor, options)</code> können Sie ein neues Benutzerelement definieren (erstellen, registrieren).  Es werden drei Argumente benötigt - der Tag-Name für das Benutzerelement, der den Namensregeln für solche Elemente entspricht, eine Klassendeklaration und ein Objekt mit Parametern.  Derzeit wird nur ein Parameter unterstützt - <code>extends</code> . Hierbei handelt es sich um eine Zeichenfolge, die den Namen des zu erweiternden Inline-Elements angibt.  Mit dieser Funktion werden spezielle Versionen von Standardelementen erstellt. </li><li>  Die Methode <code>get(tagName)</code> gibt den Konstruktor des Benutzerelements zurück, sofern dieses Element bereits definiert ist, andernfalls wird <code>undefined</code> .  Es braucht ein Argument - das Namensschild des Benutzerelements. </li><li>  Die <code>whenDefined(tagName)</code> -Methode gibt das Versprechen zurück, das nach dem <code>whenDefined(tagName)</code> des Benutzerelements aufgelöst wird.  Wenn ein Element bereits definiert ist, wird dieses Versprechen sofort gelöst.  Ein Versprechen wird abgelehnt, wenn der übergebene Tag-Name kein gültiger Tag-Name für das Benutzerelement ist.  Diese Methode akzeptiert den Tag-Namen des Benutzerelements. </li></ul><br><h2>  <font color="#3AC1EF">Erstellen Sie benutzerdefinierte Elemente</font> </h2><br>  Das Erstellen benutzerdefinierter Elemente ist sehr einfach.  Dazu müssen zwei Dinge getan werden: Erstellen Sie eine Klassendeklaration für das Element, das die <code>HTMLElement</code> Klasse erweitern soll, und registrieren Sie dieses Element unter dem ausgewählten Namen.  So sieht es aus: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// … } // … } customElements.define('my-custom-element', MyCustomElement);</span></span></code> </pre> <br>  Wenn Sie den aktuellen Bereich nicht verschmutzen möchten, können Sie eine anonyme Klasse verwenden: <br><br><pre> <code class="hljs scala">customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// … } // … });</span></span></code> </pre> <br>  Wie Sie den Beispielen <code>customElements.define(...)</code> können, wird das Benutzerelement mit der <code>customElements.define(...)</code> bereits bekannten Methode <code>customElements.define(...)</code> registriert. <br><br><h2>  <font color="#3AC1EF">Probleme, die benutzerdefinierte Elemente lösen</font> </h2><br>  Lassen Sie uns über die Probleme sprechen, mit denen wir benutzerdefinierte Elemente lösen können.  Eine davon besteht darin, die Struktur des Codes zu verbessern und die sogenannte Div-Tag-Suppe (Div-Suppe) zu eliminieren.  Dieses Phänomen ist eine sehr häufige Codestruktur in modernen Webanwendungen, in denen viele <code>div</code> Elemente ineinander eingebettet sind.  So könnte es aussehen: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"top-container"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"middle-container"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-container"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-inside-container"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"are-we-really-doing-this"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"mariana-trench"</span></span>&gt;           …         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br>  Ein solcher HTML-Code wird aus berechtigten Gründen verwendet - er beschreibt das Layout der Seite und stellt die korrekte Anzeige auf dem Bildschirm sicher.  Dies beeinträchtigt jedoch die Lesbarkeit des HTML-Codes und erschwert dessen Wartung. <br><br>  Angenommen, wir haben eine Komponente, die wie in der folgenden Abbildung aussieht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85a/949/ef6/85a949ef606dd68521cd83fd845d09ba.png"></div><br>  <i><font color="#999999">Erscheinungsbild der Komponenten</font></i> <br><br>  Unter Verwendung des traditionellen Ansatzes zur Beschreibung solcher Dinge entspricht der folgende Code dieser Komponente: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"primary-toolbar toolbar"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-undo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-redo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-print"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-toggle-button toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-paint-format"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br>  Stellen Sie sich nun vor, wir könnten anstelle dieses Codes diese Beschreibung der Komponente verwenden: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-undo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-redo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-print"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-paint-format"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Ich bin sicher, jeder wird zustimmen, dass das zweite Codefragment viel besser aussieht.  Dieser Code ist leichter zu lesen, leichter zu warten und sowohl für den Entwickler als auch für den Browser verständlich.  Es kommt alles auf die Tatsache an, dass es einfacher ist als das, in dem es viele verschachtelte <code>div</code> Tags gibt. <br><br>  Das nächste Problem, das mit benutzerdefinierten Elementen gelöst werden kann, ist die Wiederverwendung von Code.  Der Code, den Entwickler schreiben, sollte nicht nur funktionieren, sondern auch unterstützt werden.  Die Wiederverwendung von Code im Gegensatz zum ständigen Schreiben derselben Konstrukte verbessert die Projektunterstützungsfunktionen. <br>  Hier ist ein einfaches Beispiel, das Ihnen hilft, diese Idee besser zu verstehen.  Angenommen, wir haben das folgende Element: <br><br><pre> <code class="hljs scala">&lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt; &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt;</code> </pre> <br>  Wenn Sie es ständig brauchen, müssen wir mit dem üblichen Ansatz immer wieder denselben HTML-Code schreiben.  Stellen Sie sich nun vor, Sie müssen eine Änderung an diesem Code vornehmen, die überall dort angezeigt werden soll, wo sie verwendet wird.  Dies bedeutet, dass wir alle Stellen finden müssen, an denen dieses Fragment verwendet wird, und dann überall dieselben Änderungen vornehmen müssen.  Es ist lang, hart und voller Fehler. <br><br>  Es wäre viel besser, wenn wir könnten, wo dieses Element benötigt wird, schreiben Sie einfach Folgendes: <br><br><pre> <code class="hljs powershell">&lt;my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;&lt;/my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;</code> </pre> <br>  Moderne Webanwendungen sind jedoch viel mehr als statisches HTML.  Sie sind interaktiv.  Die Quelle ihrer Interaktivität ist JavaScript.  Um solche Funktionen bereitzustellen, werden normalerweise einige Elemente erstellt und anschließend Ereignis-Listener mit ihnen verbunden, sodass sie auf Benutzereinflüsse reagieren können.  Sie können beispielsweise auf Klicks reagieren, auf das „Bewegen“ des Mauszeigers über sie, auf das Ziehen über den Bildschirm usw.  So verbinden Sie einen Ereignis-Listener mit einem Element, das auftritt, wenn Sie mit der Maus darauf klicken: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myDiv = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.my-custom-element'</span></span>); myDiv.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, _ =&gt; { myDiv.innerHTML = <span class="hljs-string"><span class="hljs-string">'&lt;b&gt; I have been clicked &lt;/b&gt;'</span></span>; });</code> </pre> <br>  Und hier ist der HTML-Code für dieses Element: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; I have not been clicked yet. &lt;/div&gt;</code> </pre> <br>  Durch die Verwendung der API für die Arbeit mit benutzerdefinierten Elementen kann all diese Logik in das Element selbst aufgenommen werden.  Zum Vergleich - unten finden Sie den Code zum Deklarieren eines benutzerdefinierten Elements, das einen Ereignishandler enthält: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;   self.addEventListener(<span class="hljs-symbol"><span class="hljs-symbol">'clic</span></span>k', _ =&gt; {     self.innerHTML = '&lt;b&gt; <span class="hljs-type"><span class="hljs-type">I</span></span> have been clicked &lt;/b&gt;';   }); } } customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-type"><span class="hljs-type">MyCustomElement</span></span>);</code> </pre> <br>  Und so sieht es im HTML-Code der Seite aus: <br><br><pre> <code class="hljs powershell">&lt;my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt; I have not been clicked yet &lt;/my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;</code> </pre> <br>  Auf den ersten Blick scheint es, dass mehr Zeilen JS-Code erforderlich sind, um ein benutzerdefiniertes Element zu erstellen.  In realen Anwendungen kommt es jedoch selten vor, dass solche Elemente nur zur einmaligen Verwendung erstellt werden.  Ein weiteres typisches Phänomen in modernen Webanwendungen besteht darin, dass die meisten Elemente in ihnen dynamisch erstellt werden.  Dies führt dazu, dass zwei verschiedene Szenarien für die Arbeit mit Elementen unterstützt werden müssen - Situationen, in denen sie mithilfe von JavaScript dynamisch zur Seite hinzugefügt werden, und Situationen, in denen sie in der ursprünglichen HTML-Struktur der Seite beschrieben werden.  Dank der Verwendung benutzerdefinierter Elemente wird die Arbeit in diesen beiden Situationen vereinfacht. <br><br>  Wenn wir die Ergebnisse dieses Abschnitts zusammenfassen, können wir daher sagen, dass Benutzerelemente den Code klarer machen, seine Unterstützung vereinfachen und ihn in kleine Module aufteilen, die alle erforderlichen Funktionen enthalten und für die Wiederverwendung geeignet sind. <br><br>  Nachdem wir die allgemeinen Probleme beim Arbeiten mit benutzerdefinierten Elementen besprochen haben, wollen wir uns mit deren Funktionen befassen. <br><br><h2>  <font color="#3AC1EF">Anforderungen</font> </h2><br>  Bevor Sie mit der Entwicklung eigener benutzerdefinierter Elemente beginnen, sollten Sie einige der Regeln kennen, die Sie beim Erstellen befolgen müssen.  Hier sind sie: <br><br><ul><li>  Der Komponentenname muss einen Bindestrich ( <code>-</code> Symbol) enthalten.  Dank dessen kann der HTML-Parser zwischen eingebetteten und Benutzerelementen unterscheiden.  Darüber hinaus stellt dieser Ansatz sicher, dass keine Kollisionen von Namen mit integrierten Elementen auftreten (sowohl mit denen, die jetzt sind, als auch mit denen, die in Zukunft erscheinen werden).  Der tatsächliche Name des benutzerdefinierten Elements lautet beispielsweise <code>&gt;my-custom-element&lt;</code> , und die Namen <code>&gt;myCustomElement&lt;</code> und <code>&lt;my_custom_element&gt;</code> sind nicht geeignet. </li><li>  Es ist verboten, dasselbe Tag mehrmals zu registrieren.  Wenn Sie dies versuchen, gibt der Browser <code>DOMException</code> Fehler aus.  Benutzerdefinierte Elemente können nicht neu definiert werden. </li><li>  Benutzerdefinierte Tags können sich nicht selbst schließen.  Der HTML-Parser unterstützt nur eine begrenzte Anzahl von selbstschließenden Standard-Tags (z. B. <code>&lt;img&gt;</code> , <code>&lt;link&gt;</code> , <code>&lt;br&gt;</code> ). </li></ul><br><h2>  <font color="#3AC1EF">Die Möglichkeiten</font> </h2><br>  Lassen Sie uns darüber sprechen, was Sie mit benutzerdefinierten Elementen tun können.  Wenn Sie diese Frage auf den Punkt bringen, stellt sich heraus, dass Sie mit ihnen viele interessante Dinge tun können. <br><br>  Eine der bemerkenswertesten Eigenschaften von benutzerdefinierten Elementen ist, dass sich die Deklaration einer Elementklasse auf das DOM-Element selbst bezieht.  Dies bedeutet, dass Sie das Schlüsselwort this in einer Anzeige verwenden können, um Ereignis-Listener zu verbinden, auf Eigenschaften zuzugreifen, untergeordnete Knoten zu erstellen usw. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   this.addEventListener('mouseover', _ =&gt; {     console.log('I have been hovered');   }); } // ... }</span></span></code> </pre> <br>  Dies ermöglicht es natürlich, neue Daten in die untergeordneten Knoten des Elements zu schreiben.  Dies wird jedoch nicht empfohlen, da dies zu unerwartetem Verhalten der Elemente führen kann.  Wenn Sie sich vorstellen, dass Sie Elemente verwenden, die von einer anderen Person entworfen wurden, werden Sie wahrscheinlich überrascht sein, wenn Ihr eigenes Markup im Element durch etwas anderes ersetzt wird. <br><br>  Es gibt verschiedene Methoden, mit denen Sie Code an bestimmten Punkten im Lebenszyklus eines Elements ausführen können. <br><br><ul><li>  Die <code>constructor</code> wird einmal aufgerufen, wenn das Element erstellt oder "aktualisiert" wird (wir werden weiter unten darauf eingehen).  Am häufigsten wird es verwendet, um den Status eines Elements zu initialisieren, Ereignis-Listener zu verbinden, ein Schatten-DOM zu erstellen usw.  Vergessen Sie nicht, dass Sie im Konstruktor immer <code>super()</code> aufrufen müssen. </li><li>  Die <code>connectedCallback</code> Methode wird jedes Mal aufgerufen, wenn ein Element zum DOM hinzugefügt wird.  Es kann verwendet werden (und genau so wird es empfohlen), um die Ausführung von Aktionen auf den Moment zu verschieben, in dem das Element auf der Seite angezeigt wird (auf diese Weise können Sie beispielsweise das Laden einiger Daten verzögern). </li><li>  Die Methode " <code>disconnectedCallback</code> "wird aufgerufen, wenn ein Element aus dem DOM entfernt wird.  Es wird normalerweise verwendet, um Ressourcen freizugeben.  Beachten Sie, dass diese Methode nicht aufgerufen wird, wenn der Benutzer die Browser-Registerkarte mit der Seite schließt.  Verlassen Sie sich daher nicht auf ihn, wenn dies erforderlich ist, um einige besonders wichtige Aktionen auszuführen. </li><li>  Die <code>attributeChangedCallback</code> Methode wird aufgerufen, wenn ein Elementattribut hinzugefügt, entfernt, aktualisiert oder ersetzt wird.  Außerdem wird es aufgerufen, wenn das Element vom Parser erstellt wird.  Beachten Sie jedoch, dass diese Methode nur für Attribute gilt, die in der Eigenschaft ObservedAttributes aufgeführt sind. </li><li>  Die <code>adoptedCallback</code> Methode <code>adoptedCallback</code> aufgerufen, wenn die <code>document.adoptNode(...)</code> -Methode verwendet wird, mit der der Knoten in ein anderes Dokument verschoben wird. </li></ul><br>  Bitte beachten Sie, dass alle oben genannten Methoden synchron sind.  Beispielsweise wird die Methode linkedCallback unmittelbar nach dem Hinzufügen des Elements zum DOM aufgerufen, und der Rest des Programms wartet auf den Abschluss dieser Methode. <br><br><h2>  <font color="#3AC1EF">Eigenschaftsreflexion</font> </h2><br>  Eingebettete HTML-Elemente haben eine sehr praktische Funktion: die Eigenschaftsreflexion.  Dank dieses Mechanismus werden die Werte einiger Eigenschaften direkt als Attribute im DOM wiedergegeben.  Angenommen, dies ist charakteristisch für die <code>id</code> Eigenschaft.  Zum Beispiel führen wir die folgende Operation aus: <br><br><pre> <code class="hljs cs">myDiv.id = <span class="hljs-string"><span class="hljs-string">'new-id'</span></span>;</code> </pre> <br>  Relevante Änderungen wirken sich auf das DOM aus: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"new-id"</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dieser Mechanismus arbeitet in die entgegengesetzte Richtung.  Dies ist sehr nützlich, da Sie damit Elemente deklarativ konfigurieren können. <br><br>  Benutzerdefinierte Elemente verfügen nicht über diese integrierte Funktion, Sie können sie jedoch selbst implementieren.  Damit sich einige Eigenschaften von Benutzerelementen ähnlich verhalten, können Sie deren Getter und Setter konfigurieren. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... get myProperty() {   return this.hasAttribute('my-property'); } set myProperty(newValue) {   if (newValue) {     this.setAttribute('my-property', newValue);   } else {     this.removeAttribute('my-property');   } } // ... }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Vorhandene Elemente erweitern</font> </h2><br>  Mit der API für benutzerdefinierte Elemente können Sie nicht nur neue HTML-Elemente erstellen, sondern auch vorhandene erweitern.  Darüber hinaus sprechen wir sowohl über Standardelemente als auch über benutzerdefinierte.  Dies erfolgt mithilfe des <code>extends</code> wenn eine Klasse deklariert wird: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAwesomeButton</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyButton</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } customElements.define('my-awesome-button', MyAwesomeButton);&lt;/cosourcede&gt;      ,  , ,    &lt;code&gt;customElements.define(...)&lt;/code&gt;,    &lt;code&gt;extends&lt;/code&gt;   ,      .     ,        ,        DOM-.   ,          ,      ,       . &lt;source&gt;class MyButton extends HTMLButtonElement { // ... } customElements.define('my-button', MyButton, {extends: 'button'});</span></span></code> </pre> <br>  Erweiterte Standardelemente werden auch als "benutzerdefinierte integrierte Elemente" bezeichnet. <br><br>  Es wird empfohlen, es zur Regel zu machen, vorhandene Elemente immer zu erweitern und schrittweise durchzuführen.  Auf diese Weise können Sie in neuen Elementen die Funktionen speichern, die in zuvor erstellten Elementen implementiert wurden (dh Eigenschaften, Attribute, Funktionen). <br><br>  Bitte beachten Sie, dass benutzerdefinierte integrierte Elemente jetzt nur in Chrome 67+ unterstützt werden.  Dies wird in anderen Browsern angezeigt. Es ist jedoch bekannt, dass Safari-Entwickler beschlossen haben, diese Möglichkeit nicht zu implementieren. <br><br><h2>  <font color="#3AC1EF">Elemente aktualisieren</font> </h2><br>  Wie bereits erwähnt, werden mit der Methode <code>customElements.define(...)</code> benutzerdefinierte Elemente registriert.  Die Registrierung kann jedoch nicht als die Aktion bezeichnet werden, die zuerst ausgeführt werden muss.  Die Registrierung von Benutzerelementen kann für eine Weile verschoben werden. Darüber hinaus kann diese Zeit auch dann eintreten, wenn das Element bereits zum DOM hinzugefügt wurde.  Dieser Vorgang wird als Upgrade bezeichnet.  Um herauszufinden, wann ein Element registriert wird, stellt der Browser die Methode <code>customElements.whenDefined(...)</code> .  Er erhält den Namen des Element-Tags und gibt das Versprechen zurück, das nach der Registrierung des Elements aufgelöst wurde. <br><br><pre> <code class="hljs javascript">customElements.whenDefined(<span class="hljs-string"><span class="hljs-string">'my-custom-element'</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'My custom element is defined'</span></span>); });</code> </pre> <br>  Beispielsweise müssen Sie möglicherweise die Registrierung eines Elements verzögern, bis seine untergeordneten Elemente deklariert sind.  Eine solche Verhaltensweise kann äußerst nützlich sein, wenn das Projekt verschachtelte Benutzerelemente enthält.  Manchmal kann sich ein Elternteil auf die Implementierung untergeordneter Elemente verlassen.  In diesem Fall müssen Sie sicherstellen, dass Kinder vor dem Elternteil registriert sind. <br><br><h2>  <font color="#3AC1EF">Shadow dom</font> </h2><br>  Wie bereits erwähnt, sind benutzerdefinierte Elemente und das Shadow DOM komplementäre Technologien.  Mit der ersten können Sie die JS-Logik in Benutzerelementen kapseln, und mit der zweiten können Sie isolierte Umgebungen für DOM-Fragmente erstellen, die nicht von dem betroffen sind, was sich außerhalb von ihnen befindet.  Wenn Sie der Meinung sind, dass Sie das Shadow DOM-Konzept besser verstehen müssen, werfen Sie einen Blick auf eine unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Veröffentlichungen</a> . <br><br>  So verwenden Sie das Schatten-DOM für ein benutzerdefiniertes Element: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   let elementContent = document.createElement('div');   shadowRoot.appendChild(elementContent); } // ... });</span></span></code> </pre> <br>  Wie Sie sehen, spielt der Aufruf von <code>this.attachShadow</code> eine Schlüsselrolle. <br><br><h2>  <font color="#3AC1EF">Muster</font> </h2><br>  In einem unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen</a> Artikel haben wir ein wenig über Vorlagen gesprochen, obwohl sie tatsächlich eines separaten Artikels würdig sind.  Hier sehen wir uns ein einfaches Beispiel für das Einbetten von Vorlagen in benutzerdefinierte Elemente an, wenn diese erstellt werden.  Mit dem <code>&lt;template&gt;</code> können Sie also das DOM-Fragment beschreiben, das vom Parser verarbeitet, aber nicht auf der Seite angezeigt wird: <br><br><pre> <code class="hljs scala">&lt;template id=<span class="hljs-string"><span class="hljs-string">"my-custom-element-template"</span></span>&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt;   &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt;   &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;</code> </pre> <br>  So wenden Sie eine Vorlage in einem benutzerdefinierten Element an: <br><br><pre> <code class="hljs scala">let myCustomElementTemplate = document.querySelector('#my-custom-element-template'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   shadowRoot.appendChild(myCustomElementTemplate.content.cloneNode(true)); } // ... });</span></span></code> </pre> <br>  Wie Sie sehen können, gibt es eine Kombination aus einem benutzerdefinierten Element, einem Schatten-DOM und Vorlagen.  Dadurch konnten wir ein Element erstellen, das in seinem eigenen Raum isoliert ist und in dem die HTML-Struktur von der JS-Logik getrennt ist. <br><br><h2>  <font color="#3AC1EF">Stilisierung</font> </h2><br>  Bisher haben wir nur über JavaScript und HTML gesprochen und CSS ignoriert.  Deshalb gehen wir jetzt auf das Thema Stile ein.  Natürlich brauchen wir eine Möglichkeit, benutzerdefinierte Elemente zu formatieren.  Stile können im Shadow DOM hinzugefügt werden, aber dann stellt sich die Frage, wie solche Elemente beispielsweise von außen formatiert werden können - wenn sie nicht von der Person verwendet werden, die sie erstellt hat.  Die Antwort auf diese Frage ist recht einfach: Benutzerdefinierte Elemente werden genauso wie integrierte Elemente gestaltet. <br><br><pre> <code class="hljs mel">my-custom-element { border-radius: <span class="hljs-number"><span class="hljs-number">5</span></span>px; width: <span class="hljs-number"><span class="hljs-number">30</span></span>%; height: <span class="hljs-number"><span class="hljs-number">50</span></span>%; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Beachten Sie, dass externe Stile Vorrang vor in einem Element deklarierten Stilen haben und diese überschreiben. <br><br>  Möglicherweise haben Sie gesehen, wie Sie, wenn eine Seite auf dem Bildschirm angezeigt wird, irgendwann nicht stilisierten Inhalt darauf beobachten können (dies wird als FOUC - Flash Of Unstyled Content bezeichnet).  Sie können dieses Phänomen vermeiden, indem Sie Stile für nicht registrierte Komponenten festlegen und beim Registrieren einige visuelle Effekte verwenden.  Dazu können Sie den Selektor <code>:defined</code> .  Sie können dies beispielsweise folgendermaßen tun: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">my-button</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:not(</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:defined)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">50px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h2>  <font color="#3AC1EF">Unbekannte Elemente und undefinierte Benutzerelemente</font> </h2><br>  Die HTML-Spezifikation ist sehr flexibel und ermöglicht es Ihnen, alle Tags zu deklarieren, die Sie für den Entwickler benötigen.  Wenn das Tag vom Browser nicht erkannt wird, wird es vom Parser als <code>HTMLUnknownElement</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'thisElementIsUnknown'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLUnknownElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is unknown'</span></span>); }</code> </pre> <br>  Bei der Arbeit mit benutzerdefinierten Elementen gilt ein solches Schema jedoch nicht. ,       ?     ,    ,      <code>HTMLElement</code>        . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'this-element-is-undefined'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is undefined but not unknown'</span></span>); }</code> </pre> <br>   <code>HTMLElement</code>  <code>HTMLUnknownElement</code>    ,    ,  ,  ,    -   .  ,  ,     ,    .          <code>div</code> .             . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>         Chrome 36+.     API Custom Components v0,    , ,     ,    .    API,  ,  —   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . API Custom Elements v1   Chrome 54+   Safari 10.1+ (   ).  Mozilla      v50,     ,     . ,   Microsoft Edge      API.  ,        ,   webkit. ,    ,  ,         —   IE 11. <br><br><h2> <font color="#3AC1EF">     </font> </h2><br>  ,  ,       ,        <code>customElements</code> <br>   <code>window</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> supportsCustomElements = <span class="hljs-string"><span class="hljs-string">'customElements'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportsCustomElements) { <span class="hljs-comment"><span class="hljs-comment">// API Custom Elements   }</span></span></code> </pre> <br>      : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> script = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'script'</span></span>);   script.src = src;   script.onload = resolve;   script.onerror = reject;   <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.head.appendChild(script); }); } <span class="hljs-comment"><span class="hljs-comment">//    -    . if (supportsCustomElements) { //    ,    . } else { loadScript('path/to/custom-elements.min.js').then(_ =&gt; {   //   ,     . }); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>        ,     : <br><br><ul><li>     HTML- JavaScript-,   ,      CSS-. </li><li>      HTML- ( ,   ). </li><li>           . ,   —   JavaScript, HTML, CSS, ,      ,  . </li><li>             - (Shadow DOM, , ,   ). </li><li>         ,     . </li><li>       ,     . </li></ul><br>  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  Custom Elements v1      , ,    , ,   ,      . <br><br>  <b>Liebe Leser!</b>         ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419831/">https://habr.com/ru/post/de419831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419817/index.html">Starten des RabbitMQ-Clusters in Kubernetes</a></li>
<li><a href="../de419819/index.html">Biomarker des Alterns. Panel Gebrechlichkeit. Teil 2</a></li>
<li><a href="../de419823/index.html">Ungewöhnliche Duett - Passphrasen und Gedächtnisbilder</a></li>
<li><a href="../de419825/index.html">Testen der Leistung verschiedener Laufwerkstypen in einer virtuellen Umgebung</a></li>
<li><a href="../de419829/index.html">Die Standardschlüsselverschlüsselung von OpenSSH ist schlechter als keine</a></li>
<li><a href="../de419833/index.html">Fernarbeit, wie es funktioniert</a></li>
<li><a href="../de419835/index.html">Wie man Autoren motiviert, mit Experten verhandelt und im Allgemeinen gute Artikel schreibt</a></li>
<li><a href="../de419837/index.html">Ich, RoboLoyer, oder wie man in Dokumenten nach Anomalien sucht</a></li>
<li><a href="../de419839/index.html">Low Level NCR ATM Hacking</a></li>
<li><a href="../de419843/index.html">GeekUniversity eröffnet Einschreibung an der Fakultät für Künstliche Intelligenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>