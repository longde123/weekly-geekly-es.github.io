<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë¶ ü§õüèæ ü§¥üèΩ So funktioniert JS: Benutzerdefinierte Elemente üéß üñäÔ∏è üò´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Lesen empfehlen] Die anderen 19 Teile des Zyklus  Teil 1: √úberblick √ºber die Engine, Laufzeitmechanismen, Aufrufstapel 
 Teil 2: Informationen zu V8-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So funktioniert JS: Benutzerdefinierte Elemente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/419831/"><div class="spoiler">  <b class="spoiler_title">[Lesen empfehlen] Die anderen 19 Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberblick √ºber die Engine, Laufzeitmechanismen, Aufrufstapel</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu V8-Interna und Codeoptimierung</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten des Speichers, vier Arten von Speicherlecks und Umgang mit ihnen</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Async und f√ºnf M√∂glichkeiten zur Verbesserung Ihres Codes mit Async / Warten</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebSocket und HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was soll ich w√§hlen?</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen und Umfang von WebAssembly</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web Worker und f√ºnf Nutzungsszenarien</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Servicemitarbeiter</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web-Push-Benachrichtigungen</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verfolgen Sie √Ñnderungen im DOM mit MutationObserver</a> <br>  Teil 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering-Engines f√ºr Webseiten und Tipps zur Optimierung ihrer Leistung</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Animation mit CSS und JavaScript</a> <br>  Teil 14: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Abstrakte Syntaxb√§ume, Analyse und deren Optimierung</a> <br>  Teil 15: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Klassen und Vererbung, Transpilation in Babel und TypeScript</a> <br>  Teil 16: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Speicher</a> <br>  Teil 17: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Shadow DOM-Technologie und Webkomponenten</a> <br>  Teil 18: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: WebRTC- und P2P-Kommunikationsmechanismen</a> <br>  Teil 19: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Benutzerdefinierte Elemente</a> </div></div><br>  Wir pr√§sentieren Ihnen eine √úbersetzung von 19 Artikeln aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SessionStack-</a> Materialreihe zu den Merkmalen verschiedener Mechanismen des JavaScript-√ñkosystems.  Heute werden wir √ºber den Standard f√ºr benutzerdefinierte Elemente sprechen - die sogenannten "benutzerdefinierten Elemente".  Wir werden dar√ºber sprechen, welche Aufgaben sie l√∂sen d√ºrfen und wie sie erstellt und verwendet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/188/85f/00e18885fa38229e7bc5cc7c4489147c.png" alt="Bild"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">R√ºckblick</font> </h2><br>  In einem der vorherigen Artikel dieser Reihe haben wir √ºber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shadow DOM</a> und einige andere Technologien gesprochen, die Teil eines gr√∂√üeren Ph√§nomens sind - Webkomponenten.  Webkomponenten sollen Entwicklern erm√∂glichen, die Standardfunktionen von HTML zu erweitern, indem sie kompakte, modulare und wiederverwendbare Elemente erstellen.  Dies ist der relativ neue W3C-Standard, den Hersteller aller f√ºhrenden Browser bereits bemerkt haben.  Er ist in der Produktion zu finden, obwohl seine Arbeit nat√ºrlich von Polyphilen stammt (wir werden sp√§ter dar√ºber sprechen). <br><br>  Wie Sie vielleicht bereits wissen, bieten uns Browser einige wichtige Tools f√ºr die Entwicklung von Websites und Webanwendungen.  Es geht um HTML, CSS und JavaScript.  HTML wird verwendet, um Webseiten zu strukturieren. Dank CSS erhalten sie ein sch√∂nes Aussehen, und JavaScript ist f√ºr die interaktiven Funktionen verantwortlich.  Vor dem Erscheinen von Webkomponenten war es jedoch nicht so einfach, von JavaScript implementierte Aktionen einer HTML-Struktur zuzuordnen. <br><br>  In der Tat werden wir hier die Basis von Webkomponenten betrachten - benutzerdefinierte Elemente.  Kurz gesagt, die API, die f√ºr die Zusammenarbeit mit ihnen entwickelt wurde, erm√∂glicht es dem Programmierer, eigene HTML-Elemente mit integrierter JavaScript-Logik und von CSS beschriebenen Stilen zu erstellen.  Viele verwechseln benutzerdefinierte Elemente mit der Shadow DOM-Technologie.  Dies sind jedoch zwei v√∂llig unterschiedliche Dinge, die sich zwar erg√§nzen, aber nicht austauschbar sind. <br><br>  Einige Frameworks (wie Angular oder React) versuchen, dasselbe Problem zu l√∂sen, das benutzerdefinierte Elemente l√∂sen, indem sie ihre eigenen Konzepte einf√ºhren.  Benutzerdefinierte Elemente k√∂nnen mit Angular-Direktiven oder mit React-Komponenten verglichen werden.  Benutzerdefinierte Elemente sind jedoch eine Standardfunktion des Browsers. Sie m√ºssen nur gew√∂hnliches JavaScript, HTML und CSS verwenden, um mit ihnen zu arbeiten.  Dies erlaubt uns nat√ºrlich nicht zu sagen, dass sie ein Ersatz f√ºr gew√∂hnliche JS-Frameworks sind.  Moderne Frameworks bieten uns viel mehr als nur die M√∂glichkeit, das Verhalten benutzerdefinierter Elemente zu simulieren.  Infolgedessen k√∂nnen wir sagen, dass sowohl Frameworks als auch Benutzerelemente Technologien sind, die zusammen zur L√∂sung von Webentwicklungsaufgaben verwendet werden k√∂nnen. <br><br><h2>  <font color="#3AC1EF">API</font> </h2><br>  Bevor wir fortfahren, wollen wir uns ansehen, welche M√∂glichkeiten uns die API bietet, mit benutzerdefinierten Elementen zu arbeiten.  Es handelt sich n√§mlich um ein globales <code>customElements</code> Objekt mit mehreren Methoden: <br><br><ul><li>  Mit der Methode <code>define(tagName, constructor, options)</code> k√∂nnen Sie ein neues Benutzerelement definieren (erstellen, registrieren).  Es werden drei Argumente ben√∂tigt - der Tag-Name f√ºr das Benutzerelement, der den Namensregeln f√ºr solche Elemente entspricht, eine Klassendeklaration und ein Objekt mit Parametern.  Derzeit wird nur ein Parameter unterst√ºtzt - <code>extends</code> . Hierbei handelt es sich um eine Zeichenfolge, die den Namen des zu erweiternden Inline-Elements angibt.  Mit dieser Funktion werden spezielle Versionen von Standardelementen erstellt. </li><li>  Die Methode <code>get(tagName)</code> gibt den Konstruktor des Benutzerelements zur√ºck, sofern dieses Element bereits definiert ist, andernfalls wird <code>undefined</code> .  Es braucht ein Argument - das Namensschild des Benutzerelements. </li><li>  Die <code>whenDefined(tagName)</code> -Methode gibt das Versprechen zur√ºck, das nach dem <code>whenDefined(tagName)</code> des Benutzerelements aufgel√∂st wird.  Wenn ein Element bereits definiert ist, wird dieses Versprechen sofort gel√∂st.  Ein Versprechen wird abgelehnt, wenn der √ºbergebene Tag-Name kein g√ºltiger Tag-Name f√ºr das Benutzerelement ist.  Diese Methode akzeptiert den Tag-Namen des Benutzerelements. </li></ul><br><h2>  <font color="#3AC1EF">Erstellen Sie benutzerdefinierte Elemente</font> </h2><br>  Das Erstellen benutzerdefinierter Elemente ist sehr einfach.  Dazu m√ºssen zwei Dinge getan werden: Erstellen Sie eine Klassendeklaration f√ºr das Element, das die <code>HTMLElement</code> Klasse erweitern soll, und registrieren Sie dieses Element unter dem ausgew√§hlten Namen.  So sieht es aus: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ } // ‚Ä¶ } customElements.define('my-custom-element', MyCustomElement);</span></span></code> </pre> <br>  Wenn Sie den aktuellen Bereich nicht verschmutzen m√∂chten, k√∂nnen Sie eine anonyme Klasse verwenden: <br><br><pre> <code class="hljs scala">customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ } // ‚Ä¶ });</span></span></code> </pre> <br>  Wie Sie den Beispielen <code>customElements.define(...)</code> k√∂nnen, wird das Benutzerelement mit der <code>customElements.define(...)</code> bereits bekannten Methode <code>customElements.define(...)</code> registriert. <br><br><h2>  <font color="#3AC1EF">Probleme, die benutzerdefinierte Elemente l√∂sen</font> </h2><br>  Lassen Sie uns √ºber die Probleme sprechen, mit denen wir benutzerdefinierte Elemente l√∂sen k√∂nnen.  Eine davon besteht darin, die Struktur des Codes zu verbessern und die sogenannte Div-Tag-Suppe (Div-Suppe) zu eliminieren.  Dieses Ph√§nomen ist eine sehr h√§ufige Codestruktur in modernen Webanwendungen, in denen viele <code>div</code> Elemente ineinander eingebettet sind.  So k√∂nnte es aussehen: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"top-container"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"middle-container"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-container"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-inside-container"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"are-we-really-doing-this"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"mariana-trench"</span></span>&gt;           ‚Ä¶         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br>  Ein solcher HTML-Code wird aus berechtigten Gr√ºnden verwendet - er beschreibt das Layout der Seite und stellt die korrekte Anzeige auf dem Bildschirm sicher.  Dies beeintr√§chtigt jedoch die Lesbarkeit des HTML-Codes und erschwert dessen Wartung. <br><br>  Angenommen, wir haben eine Komponente, die wie in der folgenden Abbildung aussieht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85a/949/ef6/85a949ef606dd68521cd83fd845d09ba.png"></div><br>  <i><font color="#999999">Erscheinungsbild der Komponenten</font></i> <br><br>  Unter Verwendung des traditionellen Ansatzes zur Beschreibung solcher Dinge entspricht der folgende Code dieser Komponente: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"primary-toolbar toolbar"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-undo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-redo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-print"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-toggle-button toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-paint-format"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br>  Stellen Sie sich nun vor, wir k√∂nnten anstelle dieses Codes diese Beschreibung der Komponente verwenden: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-undo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-redo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-print"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-paint-format"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Ich bin sicher, jeder wird zustimmen, dass das zweite Codefragment viel besser aussieht.  Dieser Code ist leichter zu lesen, leichter zu warten und sowohl f√ºr den Entwickler als auch f√ºr den Browser verst√§ndlich.  Es kommt alles auf die Tatsache an, dass es einfacher ist als das, in dem es viele verschachtelte <code>div</code> Tags gibt. <br><br>  Das n√§chste Problem, das mit benutzerdefinierten Elementen gel√∂st werden kann, ist die Wiederverwendung von Code.  Der Code, den Entwickler schreiben, sollte nicht nur funktionieren, sondern auch unterst√ºtzt werden.  Die Wiederverwendung von Code im Gegensatz zum st√§ndigen Schreiben derselben Konstrukte verbessert die Projektunterst√ºtzungsfunktionen. <br>  Hier ist ein einfaches Beispiel, das Ihnen hilft, diese Idee besser zu verstehen.  Angenommen, wir haben das folgende Element: <br><br><pre> <code class="hljs scala">&lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt; &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt;</code> </pre> <br>  Wenn Sie es st√§ndig brauchen, m√ºssen wir mit dem √ºblichen Ansatz immer wieder denselben HTML-Code schreiben.  Stellen Sie sich nun vor, Sie m√ºssen eine √Ñnderung an diesem Code vornehmen, die √ºberall dort angezeigt werden soll, wo sie verwendet wird.  Dies bedeutet, dass wir alle Stellen finden m√ºssen, an denen dieses Fragment verwendet wird, und dann √ºberall dieselben √Ñnderungen vornehmen m√ºssen.  Es ist lang, hart und voller Fehler. <br><br>  Es w√§re viel besser, wenn wir k√∂nnten, wo dieses Element ben√∂tigt wird, schreiben Sie einfach Folgendes: <br><br><pre> <code class="hljs powershell">&lt;my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;&lt;/my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;</code> </pre> <br>  Moderne Webanwendungen sind jedoch viel mehr als statisches HTML.  Sie sind interaktiv.  Die Quelle ihrer Interaktivit√§t ist JavaScript.  Um solche Funktionen bereitzustellen, werden normalerweise einige Elemente erstellt und anschlie√üend Ereignis-Listener mit ihnen verbunden, sodass sie auf Benutzereinfl√ºsse reagieren k√∂nnen.  Sie k√∂nnen beispielsweise auf Klicks reagieren, auf das ‚ÄûBewegen‚Äú des Mauszeigers √ºber sie, auf das Ziehen √ºber den Bildschirm usw.  So verbinden Sie einen Ereignis-Listener mit einem Element, das auftritt, wenn Sie mit der Maus darauf klicken: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myDiv = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.my-custom-element'</span></span>); myDiv.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, _ =&gt; { myDiv.innerHTML = <span class="hljs-string"><span class="hljs-string">'&lt;b&gt; I have been clicked &lt;/b&gt;'</span></span>; });</code> </pre> <br>  Und hier ist der HTML-Code f√ºr dieses Element: <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; I have not been clicked yet. &lt;/div&gt;</code> </pre> <br>  Durch die Verwendung der API f√ºr die Arbeit mit benutzerdefinierten Elementen kann all diese Logik in das Element selbst aufgenommen werden.  Zum Vergleich - unten finden Sie den Code zum Deklarieren eines benutzerdefinierten Elements, das einen Ereignishandler enth√§lt: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;   self.addEventListener(<span class="hljs-symbol"><span class="hljs-symbol">'clic</span></span>k', _ =&gt; {     self.innerHTML = '&lt;b&gt; <span class="hljs-type"><span class="hljs-type">I</span></span> have been clicked &lt;/b&gt;';   }); } } customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-type"><span class="hljs-type">MyCustomElement</span></span>);</code> </pre> <br>  Und so sieht es im HTML-Code der Seite aus: <br><br><pre> <code class="hljs powershell">&lt;my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt; I have not been clicked yet &lt;/my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;</code> </pre> <br>  Auf den ersten Blick scheint es, dass mehr Zeilen JS-Code erforderlich sind, um ein benutzerdefiniertes Element zu erstellen.  In realen Anwendungen kommt es jedoch selten vor, dass solche Elemente nur zur einmaligen Verwendung erstellt werden.  Ein weiteres typisches Ph√§nomen in modernen Webanwendungen besteht darin, dass die meisten Elemente in ihnen dynamisch erstellt werden.  Dies f√ºhrt dazu, dass zwei verschiedene Szenarien f√ºr die Arbeit mit Elementen unterst√ºtzt werden m√ºssen - Situationen, in denen sie mithilfe von JavaScript dynamisch zur Seite hinzugef√ºgt werden, und Situationen, in denen sie in der urspr√ºnglichen HTML-Struktur der Seite beschrieben werden.  Dank der Verwendung benutzerdefinierter Elemente wird die Arbeit in diesen beiden Situationen vereinfacht. <br><br>  Wenn wir die Ergebnisse dieses Abschnitts zusammenfassen, k√∂nnen wir daher sagen, dass Benutzerelemente den Code klarer machen, seine Unterst√ºtzung vereinfachen und ihn in kleine Module aufteilen, die alle erforderlichen Funktionen enthalten und f√ºr die Wiederverwendung geeignet sind. <br><br>  Nachdem wir die allgemeinen Probleme beim Arbeiten mit benutzerdefinierten Elementen besprochen haben, wollen wir uns mit deren Funktionen befassen. <br><br><h2>  <font color="#3AC1EF">Anforderungen</font> </h2><br>  Bevor Sie mit der Entwicklung eigener benutzerdefinierter Elemente beginnen, sollten Sie einige der Regeln kennen, die Sie beim Erstellen befolgen m√ºssen.  Hier sind sie: <br><br><ul><li>  Der Komponentenname muss einen Bindestrich ( <code>-</code> Symbol) enthalten.  Dank dessen kann der HTML-Parser zwischen eingebetteten und Benutzerelementen unterscheiden.  Dar√ºber hinaus stellt dieser Ansatz sicher, dass keine Kollisionen von Namen mit integrierten Elementen auftreten (sowohl mit denen, die jetzt sind, als auch mit denen, die in Zukunft erscheinen werden).  Der tats√§chliche Name des benutzerdefinierten Elements lautet beispielsweise <code>&gt;my-custom-element&lt;</code> , und die Namen <code>&gt;myCustomElement&lt;</code> und <code>&lt;my_custom_element&gt;</code> sind nicht geeignet. </li><li>  Es ist verboten, dasselbe Tag mehrmals zu registrieren.  Wenn Sie dies versuchen, gibt der Browser <code>DOMException</code> Fehler aus.  Benutzerdefinierte Elemente k√∂nnen nicht neu definiert werden. </li><li>  Benutzerdefinierte Tags k√∂nnen sich nicht selbst schlie√üen.  Der HTML-Parser unterst√ºtzt nur eine begrenzte Anzahl von selbstschlie√üenden Standard-Tags (z. B. <code>&lt;img&gt;</code> , <code>&lt;link&gt;</code> , <code>&lt;br&gt;</code> ). </li></ul><br><h2>  <font color="#3AC1EF">Die M√∂glichkeiten</font> </h2><br>  Lassen Sie uns dar√ºber sprechen, was Sie mit benutzerdefinierten Elementen tun k√∂nnen.  Wenn Sie diese Frage auf den Punkt bringen, stellt sich heraus, dass Sie mit ihnen viele interessante Dinge tun k√∂nnen. <br><br>  Eine der bemerkenswertesten Eigenschaften von benutzerdefinierten Elementen ist, dass sich die Deklaration einer Elementklasse auf das DOM-Element selbst bezieht.  Dies bedeutet, dass Sie das Schl√ºsselwort this in einer Anzeige verwenden k√∂nnen, um Ereignis-Listener zu verbinden, auf Eigenschaften zuzugreifen, untergeordnete Knoten zu erstellen usw. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   this.addEventListener('mouseover', _ =&gt; {     console.log('I have been hovered');   }); } // ... }</span></span></code> </pre> <br>  Dies erm√∂glicht es nat√ºrlich, neue Daten in die untergeordneten Knoten des Elements zu schreiben.  Dies wird jedoch nicht empfohlen, da dies zu unerwartetem Verhalten der Elemente f√ºhren kann.  Wenn Sie sich vorstellen, dass Sie Elemente verwenden, die von einer anderen Person entworfen wurden, werden Sie wahrscheinlich √ºberrascht sein, wenn Ihr eigenes Markup im Element durch etwas anderes ersetzt wird. <br><br>  Es gibt verschiedene Methoden, mit denen Sie Code an bestimmten Punkten im Lebenszyklus eines Elements ausf√ºhren k√∂nnen. <br><br><ul><li>  Die <code>constructor</code> wird einmal aufgerufen, wenn das Element erstellt oder "aktualisiert" wird (wir werden weiter unten darauf eingehen).  Am h√§ufigsten wird es verwendet, um den Status eines Elements zu initialisieren, Ereignis-Listener zu verbinden, ein Schatten-DOM zu erstellen usw.  Vergessen Sie nicht, dass Sie im Konstruktor immer <code>super()</code> aufrufen m√ºssen. </li><li>  Die <code>connectedCallback</code> Methode wird jedes Mal aufgerufen, wenn ein Element zum DOM hinzugef√ºgt wird.  Es kann verwendet werden (und genau so wird es empfohlen), um die Ausf√ºhrung von Aktionen auf den Moment zu verschieben, in dem das Element auf der Seite angezeigt wird (auf diese Weise k√∂nnen Sie beispielsweise das Laden einiger Daten verz√∂gern). </li><li>  Die Methode " <code>disconnectedCallback</code> "wird aufgerufen, wenn ein Element aus dem DOM entfernt wird.  Es wird normalerweise verwendet, um Ressourcen freizugeben.  Beachten Sie, dass diese Methode nicht aufgerufen wird, wenn der Benutzer die Browser-Registerkarte mit der Seite schlie√üt.  Verlassen Sie sich daher nicht auf ihn, wenn dies erforderlich ist, um einige besonders wichtige Aktionen auszuf√ºhren. </li><li>  Die <code>attributeChangedCallback</code> Methode wird aufgerufen, wenn ein Elementattribut hinzugef√ºgt, entfernt, aktualisiert oder ersetzt wird.  Au√üerdem wird es aufgerufen, wenn das Element vom Parser erstellt wird.  Beachten Sie jedoch, dass diese Methode nur f√ºr Attribute gilt, die in der Eigenschaft ObservedAttributes aufgef√ºhrt sind. </li><li>  Die <code>adoptedCallback</code> Methode <code>adoptedCallback</code> aufgerufen, wenn die <code>document.adoptNode(...)</code> -Methode verwendet wird, mit der der Knoten in ein anderes Dokument verschoben wird. </li></ul><br>  Bitte beachten Sie, dass alle oben genannten Methoden synchron sind.  Beispielsweise wird die Methode linkedCallback unmittelbar nach dem Hinzuf√ºgen des Elements zum DOM aufgerufen, und der Rest des Programms wartet auf den Abschluss dieser Methode. <br><br><h2>  <font color="#3AC1EF">Eigenschaftsreflexion</font> </h2><br>  Eingebettete HTML-Elemente haben eine sehr praktische Funktion: die Eigenschaftsreflexion.  Dank dieses Mechanismus werden die Werte einiger Eigenschaften direkt als Attribute im DOM wiedergegeben.  Angenommen, dies ist charakteristisch f√ºr die <code>id</code> Eigenschaft.  Zum Beispiel f√ºhren wir die folgende Operation aus: <br><br><pre> <code class="hljs cs">myDiv.id = <span class="hljs-string"><span class="hljs-string">'new-id'</span></span>;</code> </pre> <br>  Relevante √Ñnderungen wirken sich auf das DOM aus: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"new-id"</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dieser Mechanismus arbeitet in die entgegengesetzte Richtung.  Dies ist sehr n√ºtzlich, da Sie damit Elemente deklarativ konfigurieren k√∂nnen. <br><br>  Benutzerdefinierte Elemente verf√ºgen nicht √ºber diese integrierte Funktion, Sie k√∂nnen sie jedoch selbst implementieren.  Damit sich einige Eigenschaften von Benutzerelementen √§hnlich verhalten, k√∂nnen Sie deren Getter und Setter konfigurieren. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... get myProperty() {   return this.hasAttribute('my-property'); } set myProperty(newValue) {   if (newValue) {     this.setAttribute('my-property', newValue);   } else {     this.removeAttribute('my-property');   } } // ... }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Vorhandene Elemente erweitern</font> </h2><br>  Mit der API f√ºr benutzerdefinierte Elemente k√∂nnen Sie nicht nur neue HTML-Elemente erstellen, sondern auch vorhandene erweitern.  Dar√ºber hinaus sprechen wir sowohl √ºber Standardelemente als auch √ºber benutzerdefinierte.  Dies erfolgt mithilfe des <code>extends</code> wenn eine Klasse deklariert wird: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAwesomeButton</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyButton</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } customElements.define('my-awesome-button', MyAwesomeButton);&lt;/cosourcede&gt;      ,  , ,    &lt;code&gt;customElements.define(...)&lt;/code&gt;,    &lt;code&gt;extends&lt;/code&gt;   ,      .     ,        ,        DOM-.   ,          ,      ,       . &lt;source&gt;class MyButton extends HTMLButtonElement { // ... } customElements.define('my-button', MyButton, {extends: 'button'});</span></span></code> </pre> <br>  Erweiterte Standardelemente werden auch als "benutzerdefinierte integrierte Elemente" bezeichnet. <br><br>  Es wird empfohlen, es zur Regel zu machen, vorhandene Elemente immer zu erweitern und schrittweise durchzuf√ºhren.  Auf diese Weise k√∂nnen Sie in neuen Elementen die Funktionen speichern, die in zuvor erstellten Elementen implementiert wurden (dh Eigenschaften, Attribute, Funktionen). <br><br>  Bitte beachten Sie, dass benutzerdefinierte integrierte Elemente jetzt nur in Chrome 67+ unterst√ºtzt werden.  Dies wird in anderen Browsern angezeigt. Es ist jedoch bekannt, dass Safari-Entwickler beschlossen haben, diese M√∂glichkeit nicht zu implementieren. <br><br><h2>  <font color="#3AC1EF">Elemente aktualisieren</font> </h2><br>  Wie bereits erw√§hnt, werden mit der Methode <code>customElements.define(...)</code> benutzerdefinierte Elemente registriert.  Die Registrierung kann jedoch nicht als die Aktion bezeichnet werden, die zuerst ausgef√ºhrt werden muss.  Die Registrierung von Benutzerelementen kann f√ºr eine Weile verschoben werden. Dar√ºber hinaus kann diese Zeit auch dann eintreten, wenn das Element bereits zum DOM hinzugef√ºgt wurde.  Dieser Vorgang wird als Upgrade bezeichnet.  Um herauszufinden, wann ein Element registriert wird, stellt der Browser die Methode <code>customElements.whenDefined(...)</code> .  Er erh√§lt den Namen des Element-Tags und gibt das Versprechen zur√ºck, das nach der Registrierung des Elements aufgel√∂st wurde. <br><br><pre> <code class="hljs javascript">customElements.whenDefined(<span class="hljs-string"><span class="hljs-string">'my-custom-element'</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'My custom element is defined'</span></span>); });</code> </pre> <br>  Beispielsweise m√ºssen Sie m√∂glicherweise die Registrierung eines Elements verz√∂gern, bis seine untergeordneten Elemente deklariert sind.  Eine solche Verhaltensweise kann √§u√üerst n√ºtzlich sein, wenn das Projekt verschachtelte Benutzerelemente enth√§lt.  Manchmal kann sich ein Elternteil auf die Implementierung untergeordneter Elemente verlassen.  In diesem Fall m√ºssen Sie sicherstellen, dass Kinder vor dem Elternteil registriert sind. <br><br><h2>  <font color="#3AC1EF">Shadow dom</font> </h2><br>  Wie bereits erw√§hnt, sind benutzerdefinierte Elemente und das Shadow DOM komplement√§re Technologien.  Mit der ersten k√∂nnen Sie die JS-Logik in Benutzerelementen kapseln, und mit der zweiten k√∂nnen Sie isolierte Umgebungen f√ºr DOM-Fragmente erstellen, die nicht von dem betroffen sind, was sich au√üerhalb von ihnen befindet.  Wenn Sie der Meinung sind, dass Sie das Shadow DOM-Konzept besser verstehen m√ºssen, werfen Sie einen Blick auf eine unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Ver√∂ffentlichungen</a> . <br><br>  So verwenden Sie das Schatten-DOM f√ºr ein benutzerdefiniertes Element: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   let elementContent = document.createElement('div');   shadowRoot.appendChild(elementContent); } // ... });</span></span></code> </pre> <br>  Wie Sie sehen, spielt der Aufruf von <code>this.attachShadow</code> eine Schl√ºsselrolle. <br><br><h2>  <font color="#3AC1EF">Muster</font> </h2><br>  In einem unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen</a> Artikel haben wir ein wenig √ºber Vorlagen gesprochen, obwohl sie tats√§chlich eines separaten Artikels w√ºrdig sind.  Hier sehen wir uns ein einfaches Beispiel f√ºr das Einbetten von Vorlagen in benutzerdefinierte Elemente an, wenn diese erstellt werden.  Mit dem <code>&lt;template&gt;</code> k√∂nnen Sie also das DOM-Fragment beschreiben, das vom Parser verarbeitet, aber nicht auf der Seite angezeigt wird: <br><br><pre> <code class="hljs scala">&lt;template id=<span class="hljs-string"><span class="hljs-string">"my-custom-element-template"</span></span>&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt;   &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt;   &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;</code> </pre> <br>  So wenden Sie eine Vorlage in einem benutzerdefinierten Element an: <br><br><pre> <code class="hljs scala">let myCustomElementTemplate = document.querySelector('#my-custom-element-template'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   shadowRoot.appendChild(myCustomElementTemplate.content.cloneNode(true)); } // ... });</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, gibt es eine Kombination aus einem benutzerdefinierten Element, einem Schatten-DOM und Vorlagen.  Dadurch konnten wir ein Element erstellen, das in seinem eigenen Raum isoliert ist und in dem die HTML-Struktur von der JS-Logik getrennt ist. <br><br><h2>  <font color="#3AC1EF">Stilisierung</font> </h2><br>  Bisher haben wir nur √ºber JavaScript und HTML gesprochen und CSS ignoriert.  Deshalb gehen wir jetzt auf das Thema Stile ein.  Nat√ºrlich brauchen wir eine M√∂glichkeit, benutzerdefinierte Elemente zu formatieren.  Stile k√∂nnen im Shadow DOM hinzugef√ºgt werden, aber dann stellt sich die Frage, wie solche Elemente beispielsweise von au√üen formatiert werden k√∂nnen - wenn sie nicht von der Person verwendet werden, die sie erstellt hat.  Die Antwort auf diese Frage ist recht einfach: Benutzerdefinierte Elemente werden genauso wie integrierte Elemente gestaltet. <br><br><pre> <code class="hljs mel">my-custom-element { border-radius: <span class="hljs-number"><span class="hljs-number">5</span></span>px; width: <span class="hljs-number"><span class="hljs-number">30</span></span>%; height: <span class="hljs-number"><span class="hljs-number">50</span></span>%; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Beachten Sie, dass externe Stile Vorrang vor in einem Element deklarierten Stilen haben und diese √ºberschreiben. <br><br>  M√∂glicherweise haben Sie gesehen, wie Sie, wenn eine Seite auf dem Bildschirm angezeigt wird, irgendwann nicht stilisierten Inhalt darauf beobachten k√∂nnen (dies wird als FOUC - Flash Of Unstyled Content bezeichnet).  Sie k√∂nnen dieses Ph√§nomen vermeiden, indem Sie Stile f√ºr nicht registrierte Komponenten festlegen und beim Registrieren einige visuelle Effekte verwenden.  Dazu k√∂nnen Sie den Selektor <code>:defined</code> .  Sie k√∂nnen dies beispielsweise folgenderma√üen tun: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">my-button</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:not(</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:defined)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">50px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h2>  <font color="#3AC1EF">Unbekannte Elemente und undefinierte Benutzerelemente</font> </h2><br>  Die HTML-Spezifikation ist sehr flexibel und erm√∂glicht es Ihnen, alle Tags zu deklarieren, die Sie f√ºr den Entwickler ben√∂tigen.  Wenn das Tag vom Browser nicht erkannt wird, wird es vom Parser als <code>HTMLUnknownElement</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'thisElementIsUnknown'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLUnknownElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is unknown'</span></span>); }</code> </pre> <br>  Bei der Arbeit mit benutzerdefinierten Elementen gilt ein solches Schema jedoch nicht. ,       ?     ,    ,      <code>HTMLElement</code>        . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'this-element-is-undefined'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is undefined but not unknown'</span></span>); }</code> </pre> <br>   <code>HTMLElement</code>  <code>HTMLUnknownElement</code>    ,    ,  ,  ,    -   .  ,  ,     ,    .          <code>div</code> .             . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>         Chrome 36+.     API Custom Components v0,    , ,     ,    .    API,  ,  ‚Äî   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . API Custom Elements v1   Chrome 54+   Safari 10.1+ (   ).  Mozilla      v50,     ,     . ,   Microsoft Edge      API.  ,        ,   webkit. ,    ,  ,         ‚Äî   IE 11. <br><br><h2> <font color="#3AC1EF">     </font> </h2><br>  ,  ,       ,        <code>customElements</code> <br>   <code>window</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> supportsCustomElements = <span class="hljs-string"><span class="hljs-string">'customElements'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportsCustomElements) { <span class="hljs-comment"><span class="hljs-comment">// API Custom Elements   }</span></span></code> </pre> <br>      : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> script = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'script'</span></span>);   script.src = src;   script.onload = resolve;   script.onerror = reject;   <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.head.appendChild(script); }); } <span class="hljs-comment"><span class="hljs-comment">//    -    . if (supportsCustomElements) { //    ,    . } else { loadScript('path/to/custom-elements.min.js').then(_ =&gt; {   //   ,     . }); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>        ,     : <br><br><ul><li>     HTML- JavaScript-,   ,      CSS-. </li><li>      HTML- ( ,   ). </li><li>           . ,   ‚Äî   JavaScript, HTML, CSS, ,      ,  . </li><li>             - (Shadow DOM, , ,   ). </li><li>         ,     . </li><li>       ,     . </li></ul><br>  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  Custom Elements v1      , ,    , ,   ,      . <br><br>  <b>Liebe Leser!</b>         ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419831/">https://habr.com/ru/post/de419831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419817/index.html">Starten des RabbitMQ-Clusters in Kubernetes</a></li>
<li><a href="../de419819/index.html">Biomarker des Alterns. Panel Gebrechlichkeit. Teil 2</a></li>
<li><a href="../de419823/index.html">Ungew√∂hnliche Duett - Passphrasen und Ged√§chtnisbilder</a></li>
<li><a href="../de419825/index.html">Testen der Leistung verschiedener Laufwerkstypen in einer virtuellen Umgebung</a></li>
<li><a href="../de419829/index.html">Die Standardschl√ºsselverschl√ºsselung von OpenSSH ist schlechter als keine</a></li>
<li><a href="../de419833/index.html">Fernarbeit, wie es funktioniert</a></li>
<li><a href="../de419835/index.html">Wie man Autoren motiviert, mit Experten verhandelt und im Allgemeinen gute Artikel schreibt</a></li>
<li><a href="../de419837/index.html">Ich, RoboLoyer, oder wie man in Dokumenten nach Anomalien sucht</a></li>
<li><a href="../de419839/index.html">Low Level NCR ATM Hacking</a></li>
<li><a href="../de419843/index.html">GeekUniversity er√∂ffnet Einschreibung an der Fakult√§t f√ºr K√ºnstliche Intelligenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>