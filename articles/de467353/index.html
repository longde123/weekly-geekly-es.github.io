<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèº üç≠ üë©üèª‚Äçüî¨ Codeoptimierungsmethoden f√ºr Redd. Teil 1: Cache-Effekt üê≥ üë®‚Äç‚öïÔ∏è ‚õÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Artikel der Reihe habe ich aktiv f√ºr die Idee geworben, dass die Codeentwicklung f√ºr Redd zweitrangig und das Hauptprojekt prim√§r ist. Redd ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Codeoptimierungsmethoden f√ºr Redd. Teil 1: Cache-Effekt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467353/"> Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel der</a> Reihe habe ich aktiv f√ºr die Idee geworben, dass die Codeentwicklung f√ºr Redd zweitrangig und das Hauptprojekt prim√§r ist.  Redd ist ein Hilfsprogramm, daher ist es falsch, viel Zeit damit zu verbringen.  Das hei√üt, die Entwicklung daf√ºr sollte schnell gehen.  Dies bedeutet jedoch keineswegs, dass die resultierenden Programme nicht optimal sein sollten.  Wenn sie √ºberhaupt nicht optimiert sind, reicht die Leistung des Ger√§ts nicht aus, um das gew√ºnschte Testsystem zu implementieren.  Daher sollte der Prozess, wie gesagt, schnell und einfach sein, aber der Entwickler sollte immer einige Optimierungsprinzipien ber√ºcksichtigen. <br><br><img src="https://habrastorage.org/webt/ky/gv/ge/kygvge7bilfbzntymcu3qzlk4mq.jpeg"><br><br>  Es wurden dicke B√ºcher √ºber Optimierung ver√∂ffentlicht.  Einige dieser B√ºcher sind n√ºtzlich, andere sind bereits veraltet, da die darin beschriebenen Prinzipien beim Erstellen von Code lange Zeit in die Phase der automatischen Optimierung √ºbergegangen sind. Es gibt jedoch einige Dinge, die bei der Entwicklung gew√∂hnlicher Programme f√ºr gew√∂hnliche Prozessoren keinen Wert haben, sodass typische B√ºcher normalerweise nicht beschrieben werden .  Wir werden jetzt anfangen, sie zu betrachten. <br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  Bisher habe ich nach dem Prinzip "Ein Problem - ein Artikel" geschrieben.  Und die Artikel wurden im Format von Vorlesungen erhalten, die mehrere Themen gleichzeitig betrafen und durch ein gemeinsames Problem verbunden waren.  Einige Leser sagten jedoch, dass solche Artikel nicht auf einmal gelesen werden k√∂nnten.  Daher werden wir jetzt versuchen, in einem Artikel nur √ºber ein Thema zu sprechen.  Es f√§llt mir auch leichter, so zu schreiben.  Mal sehen, es wird pl√∂tzlich bequemer f√ºr alle. <br><br>  Genie√üen Sie auch die mysteri√∂sen Minuspunkte.  Wenn ein Artikel am Morgen ver√∂ffentlicht wird, kommt das erste Minus daf√ºr nach einer Zeitspanne an, in der es unm√∂glich ist, den gesamten Text zu lesen.  Jemand tut dies rein prinzipiell und spart nur Themen √ºber UDB und Balalaika.  Wenn die Ver√∂ffentlichung nicht am Morgen, sondern am Nachmittag erfolgte, wirft er mit Verz√∂gerung ein Minus.  Das zweite Minus kommt tags√ºber (und dieser Freund hat √ºbrigens auch Themen √ºber UDB und Balalaika verschont).  Es wird mehr Artikel im neuen Format geben, was bedeutet, dass es f√ºr dieses Paar angenehmere Momente geben wird (obwohl es f√ºr mich als Autor pers√∂nlich traurig und beleidigend wird, wenn sie handeln). <br><br>  Fr√ºhere Artikel in der Reihe: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung der einfachsten ‚ÄûFirmware‚Äú f√ºr in Redd installierte FPGAs und Debugging am Beispiel des Speichertests.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung der einfachsten ‚ÄûFirmware‚Äú f√ºr in Redd installierte FPGAs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Programmcode.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung eines eigenen Kerns zur Einbettung in ein FPGA-basiertes Prozessorsystem.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung von Programmen f√ºr den Zentralprozessor Redd am Beispiel des Zugriffs auf das FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ersten Experimente am Streaming-Protokoll am Beispiel der Verbindung von CPU und Prozessor im FPGA des Redd-Komplexes.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merry Quartusel oder wie der Prozessor zu einem solchen Leben gekommen ist.</a> </li></ol><br><h2>  Geheimnisvolles Verhalten eines typischen Systems </h2><br>  Lassen Sie uns das einfachste Prozessorsystem ausf√ºhren, indem wir einen Takt, einen Nios II / f-Prozessor, einen SDRAM-Controller und einen Ausgangsport einschlie√üen.  So spartanisch sieht dieses System in Platform Designer aus <br><br><img src="https://habrastorage.org/webt/mr/qt/hm/mrqthmfrz5vespqetdjwcguvclu.png"><br><br>  Der Programmcode daf√ºr enth√§lt nur eine Funktion, deren Hauptteil etwas seltsam aussieht, da er viele sich wiederholende Zeilen enth√§lt, aber dies wird f√ºr uns n√ºtzlich sein. <br><br><div class="spoiler">  <b class="spoiler_title">Der Code ist ausgeblendet, weil er zu eng ist.</b> <div class="spoiler_text"><pre><code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;io.h&gt; } void MagicFunction() { while (1) { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } } int main() { MagicFunction(); /* Event loop never exits. */ while (1); return 0; }</code> </pre> <br></div></div><br>  Setzen Sie einen Haltepunkt in die letzte Zeile: <br><br><pre> <code class="plaintext hljs">IOWR (PIO_0_BASE,0,0);</code> </pre> <br>  in der <b>MagicFunction</b> und f√ºhren Sie das Programm aus.  Was haben wir am Ausgang des Hafens bekommen?  Sehr zerlumpte Impulse: <br><br><img src="https://habrastorage.org/webt/n7/qt/qj/n7qtqjkwhcioypjv02_7ir7k3es.png"><br><br>  Das Grauen  Na ja.  Klicken Sie jedoch erneut auf "Start", um eine weitere Iteration der Schleife abzuschlie√üen.  Und jetzt sehen wir am Ausgang einen sch√∂nen glatten M√§ander: <br><br><img src="https://habrastorage.org/webt/ez/nz/4k/eznz4kkvo8smagbksijd0tt4bso.png"><br><br>  Eine weitere Iteration.  Und noch einer ... Stabiler M√§ander.  Wir entfernen den Haltepunkt und beobachten die Arbeit in der Dynamik - es gibt keine solchen Unterbrechungen mehr.  Es gibt endlose Impulsausbr√ºche. <br><br>  Warum haben wir beim ersten Durchgang Impulse gerissen?  Ein Unfall?  Nein.  Wir beenden das Debuggen und starten es erneut.  Und wieder bekommen wir zerrissene Impulse.  L√ºcken entstehen immer am Eingang des Programms. <br><br><h2>  Der Hinweis liegt im Cache </h2><br>  Tats√§chlich liegt die L√∂sung f√ºr dieses Verhalten im Cache.  Unser Programm ist im SDRAM gespeichert.  Das Abrufen von Code aus dem SDRAM ist nicht schnell.  Es ist notwendig, einen Lesebefehl zu geben, es ist notwendig, eine Adresse zu geben, und die Adresse besteht aus zwei Teilen.  Du musst ein bisschen warten.  Nur dann gibt die Mikroschaltung die Daten aus.  Um solche Verz√∂gerungen jedes Mal zu vermeiden, kann die Mikroschaltung nicht ein, sondern mehrere aufeinanderfolgende W√∂rter ausgeben.  Wir werden Zeitdiagramme heute nicht ber√ºcksichtigen, wir werden sie f√ºr die folgenden Artikel verschieben. <br><br>  Auf der Seite des Prozessorkerns wurde standardm√§√üig ein Cache erstellt.  Hier sind seine Einstellungen: <br><br><img src="https://habrastorage.org/webt/n3/3b/cx/n33bcxjyhe2v_lvaiuqafjzvdoc.png"><br><br>  Tats√§chlich treten Verz√∂gerungen in dem Moment auf, in dem das Batch-Laden von Anweisungen vom SDRAM in den Cache ausgef√ºhrt wird.  Bei den n√§chsten Iterationen befindet sich der Code bereits im Cache, sodass das Laden nicht mehr erforderlich ist. <br><br>  Das Oszillogramm zeigt durchschnittlich 8 Eintr√§ge pro Port (eine Einheit wird viermal und null viermal geschrieben) pro Ladevorgang.  Ein Datensatz - ein Assembler-Befehl, den Sie √ºber den Men√ºpunkt Fenster-&gt; Ansicht anzeigen-&gt; Andere ausw√§hlen k√∂nnen: <br><br><img src="https://habrastorage.org/webt/p-/xp/nh/p-xpnhdsqsklxoqa_ityjp2u-hu.png"><br><br>  und dann Debug-&gt; Disassembly: <br><br><img src="https://habrastorage.org/webt/2n/7c/in/2n7cinmvmt04ov-_ibduzwcv9zo.png"><br><br>  Hier sind unsere Zeichenfolgen und der entsprechende Assembler-Code: <br><br><img src="https://habrastorage.org/webt/_q/ox/wz/_qoxwz5u9qkgsn4gd5t0yuy4djw.png"><br><br>  8 Teams mit jeweils 4 Bytes.  Wir erhalten 32 Bytes pro Cache-Zeile ... Wir sehen uns unsere bevorzugte Hilfedatei C: \ Work \ CachePlay \ software \ CachePlay_bsp \ system.h an und sehen: <br><br><pre> <code class="plaintext hljs">#define ALT_CPU_ICACHE_LINE_SIZE 32 #define ALT_CPU_ICACHE_LINE_SIZE_LOG2 5</code> </pre><br>  Die praktisch berechneten Daten stimmten mit der Theorie √ºberein.  Dar√ºber hinaus folgt aus der Dokumentation, dass die Gr√∂√üe der Zeichenfolge nicht ge√§ndert werden kann.  Es ist immer gleich zweiunddrei√üig Bytes. <br><br><h2>  Ein etwas komplizierteres Experiment </h2><br>  Versuchen wir, einen Cache zu provozieren, der w√§hrend der festgelegten Arbeit neu gestartet werden soll.  Lassen Sie uns das Testprogramm ein wenig √§ndern.  Wir machen zwei Funktionen und rufen sie von der <b>main () -</b> Funktion aus auf und platzieren eine Schleife darin.  Ich werde keinen Haltepunkt setzen.  √úbrigens, wenn Sie die Funktionen vollst√§ndig identisch machen, wird der Optimierer dies bemerken und eine davon entfernen, also mindestens eine Zeile, und sie sollten sich unterscheiden ... Dies ist, was ich am Anfang geschrieben habe: Optimierer sind jetzt sehr klug. <br><br><div class="spoiler">  <b class="spoiler_title">Ge√§nderter Testprogrammcode.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;io.h&gt; } void MagicFunction1() { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } void MagicFunction2() { IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); } int main() { while (1) { MagicFunction1(); MagicFunction2(); } /* Event loop never exits. */ while (1); return 0; }</code> </pre><br></div></div><br>  Wir erhalten ein ziemlich sch√∂nes Ergebnis, das bereits im etablierten Programmmodus aufgenommen wurde. <br><br><img src="https://habrastorage.org/webt/6q/ww/xa/6qwwxao-phas4ippal7a1hrhlik.png"><br><br>  Und jetzt werden wir eine neue Funktion zwischen dieses Funktionspaar einf√ºgen, und wir werden es nicht aufrufen, es wird nur zwischen ihnen im Speicher abgelegt.  Jetzt werde ich versuchen, mehr Speicherplatz in Anspruch zu nehmen ... Der Cache hat eine Gr√∂√üe von 4 Kilobyte, sodass er vier Kilobyte entspricht. F√ºgen Sie einfach 1024 NOPs ein, von denen jede 4 Byte gro√ü ist.  Ich werde das Ende der ersten Funktion, die neue Funktion und den Anfang der zweiten zeigen, damit klar ist, wie sich das Programm √§ndert: <br><br><pre> <code class="plaintext hljs">... IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } #define Nops4 __asm__ volatile ("nop");__asm__ volatile ("nop");__asm__ volatile ("nop");__asm__ volatile ("nop"); #define Nops16 Nops4 Nops4 Nops4 Nops4 #define Nops64 Nops16 Nops16 Nops16 Nops16 #define Nops256 Nops64 Nops64 Nops64 Nops64 #define Nops1024 Nops256 Nops256 Nops256 Nops256 volatile void FuncBetween() { Nops1024 } void MagicFunction2() { IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); ...</code> </pre><br>  Die Logik des Programms hat sich nicht ge√§ndert, aber wenn es jetzt ausgef√ºhrt wird, erhalten wir zerrissene Impulse <br><br><img src="https://habrastorage.org/webt/20/on/rq/20onrqyrzqtcdeiqjiulcaa0yuw.png"><br><br>  Ich werde eine naive Frage stellen: Wir sind aus dem Cache geflogen, und jetzt, wenn sich die L√ºcke vergr√∂√üert, wird immer geladen?  √úberhaupt nicht!  √Ñndern Sie die Gr√∂√üe der "schlechten" Funktion so, dass sie beispielsweise f√ºnf Kilobyte entspricht.  F√ºnf mehr als vier, fliegen wir noch raus?  Oder nicht?  Ersetzen Sie den Einsatz durch: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops1024 Nops256 }</code> </pre><br>  Und wieder bekommen wir die Sch√∂nheit: <br><br><img src="https://habrastorage.org/webt/cz/hh/up/czhhupgwhqdrrddlaeyg8kv50yg.png"><br><br>  Was bestimmt also die Notwendigkeit, Code in den Cache zu laden?  K√∂nnen wir etwas vorhersagen oder jedes Mal m√ºssen wir uns die Tatsache ansehen?  Lassen Sie uns in die Theorie eintauchen, bei der uns das <b>Nios II Processor Reference Guide</b> hilft. <br><br><h2>  Ein bisschen Theorie </h2><br>  So teilt sich das Adressfeld im Prozessor auf: <br><br><img src="https://habrastorage.org/webt/ba/kw/5_/bakw5_bz0uipk2kzstdfcjuiuvy.png"><br><br>  Wie Sie sehen k√∂nnen, ist die Adresse in drei Teile unterteilt.  Tag, Linie und Offset.  Die Dimension des Versatzfeldes ist f√ºr den Nios II-Prozessor konstant und betr√§gt immer f√ºnf Bits, dh es k√∂nnen 32 Bytes adressiert werden.  Die Dimension des Felds "Zeile" h√§ngt von der Gr√∂√üe des Caches ab, der bei der Konfiguration des Prozessors angegeben wurde.  In der obigen Abbildung ist es ziemlich gro√ü.  Ich wei√ü nicht, warum das Dokument eine so gro√üe Dimension hat.  Wir haben eine Cache-Gr√∂√üe von 4 Kilobyte, was bedeutet, dass die Gesamtbittiefe und der Offset 12 Bit betragen.  5 Bits nehmen einen Offset, f√ºr eine Zeile bleiben 12-5 = 7 Bits. <br><br>  Wir erhalten eine bestimmte Tabelle mit 128 Zeilen, die jeweils 32 Byte lang sind.  Ich werde zum Beispiel die ersten 6 Zeilen geben: <br><div class="scrollable-table"><table><tbody><tr><th>  Tag-Feld </th><th>  Feld "Zeichenfolge" </th><th>  LSBs </th><th>  Wo zu bekommen </th></tr><tr><td>  Nicht wichtig </td><td>  0x00 </td><td>  0x000 bis 0x01F </td><td>  Zeile 0 des Caches </td></tr><tr><td>  Nicht wichtig </td><td>  0x01 </td><td>  0x020 bis 0x03F </td><td>  Zeile 1 Cache </td></tr><tr><td>  Nicht wichtig </td><td>  0x02 </td><td>  0x040 bis 0x05F </td><td>  Zeile 2 Cache </td></tr><tr><td>  Nicht wichtig </td><td>  0x03 </td><td>  0x060 bis 0x07F </td><td>  Zeile 3 Cache </td></tr><tr><td>  Nicht wichtig </td><td>  0x04 </td><td>  0x080 bis 0x09F </td><td>  Zeile 4 Cache </td></tr><tr><td>  Nicht wichtig </td><td>  0x05 </td><td>  0x0A0 bis 0x0BF </td><td>  Zeile 5 Cache </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  Nicht wichtig </td><td>  0x7F </td><td>  0xFE0 bis 0xFFF </td><td>  in Zeile 127 des Caches </td></tr></tbody></table></div><br>  Und so wandten wir uns an die Adresse 0x123 <b>004</b> .  Wenn Sie den Teil "nicht wichtig" verwerfen, ist das Paar "Linie + Versatz" 0x004.  Dies ist der Nullzeilenbereich.  Daten werden in diese Zeile geladen.  Weitere Arbeiten mit Daten im Bereich von 0x123 <b>000</b> bis 0x123 <b>01F</b> werden √ºber den Cache durchgef√ºhrt.  Unter welchen Bedingungen wird der String √ºberlastet?  Beim Zugriff auf eine andere Adresse, die im Bereich von 0x000 bis 0x01F endet.  Wenn wir uns also an die Adresse 0xABC <b>204</b> wenden, bleibt alles an Ort und Stelle, da sich der Bereich der niedrigeren Adressen nicht mit unserem √ºberschneidet.  Und 0xABC <b>804</b> wird nichts ruinieren.  Wenn der Code jedoch von der Adresse 0xABC <b>004 ausgef√ºhrt wird,</b> werden neue Inhalte in die Cache-Zeile geladen.  Und schon der √úbergang zur Adresse 0x123 <b>004</b> f√ºhrt wieder zu einer √úberlastung.  Wenn Sie st√§ndig zwischen 0xABC <b>004</b> und 0x123 <b>004</b> wechseln, tritt kontinuierlich eine √úberlastung auf. <br><br>  Versuchen wir, dies in Form eines Bildes darzustellen.  Angenommen, wir haben nur 8 Zeilen im Cache. Es ist bequemer, sie in verschiedenen Farben einzuf√§rben.  Wenn ich die Zeilengr√∂√üe auf 0 x 10 stelle, ist es bequemer, die Adressen im Bild zu malen (denken Sie daran, dass in echten Nios II die Zeilengr√∂√üe immer 0 x 20 Byte betr√§gt).  Der Speicher schl√§gt auf bedingten Seiten, die dieselbe Gr√∂√üe wie Cache-Zeilen haben.  Die rote Seite des Speichers wird immer in die rote Zeile des Caches verschoben, die orange in die orange und so weiter.  Dementsprechend wird der alte Inhalt entladen. <br><br><img src="https://habrastorage.org/webt/r0/he/sl/r0heslzwbiuxwjprhq4tnf-xela.png"><br><br>  Nun, tats√§chlich ist das Verhalten des Programms w√§hrend des Experiments jetzt klar.  Wenn die Funktionen streng durch 4 Kilobyte getrennt waren, trafen sie Seiten mit √§hnlichen Farben.  Daher der Code <br><br><pre> <code class="plaintext hljs"> while (1) { MagicFunction1(); MagicFunction2(); }</code> </pre><br>  f√ºhrte zum Laden des Caches f√ºr eine, dann f√ºr eine andere Funktion.  Und wenn der Abstand nicht 4, sondern 5 Kilobyte betrug, wurden die Funktionen in Bl√∂cke unterschiedlicher Farben unterteilt.  Es gab keinen Konflikt, alles funktionierte ohne Verz√∂gerung. <br><br><h2>  Schlussfolgerungen </h2><br>  Als ich vor vielen Jahren las, dass es Linien von Cortex A-, Cortex R- und Cortex M-Kernen gibt, die f√ºr produktive Dinge, f√ºr die Arbeit in Echtzeit bzw. f√ºr die Arbeit in billigen Systemen ausgelegt sind, habe ich zun√§chst nicht verstanden, aber was ist tats√§chlich der Unterschied? .  Nein, billige Systeme sind verst√§ndlich, aber was sind die ersten beiden Unterschiede?  Nachdem ich jedoch den im Cyclone V SoC FPGA verf√ºgbaren Cortex A9-Kern gespielt hatte, sp√ºrte ich alle Nachteile des Caches bei der Arbeit mit Eisen.  Es gibt viele Caches im Kern von Cortex A ... und die Vorhersagbarkeit des Systemverhaltens ist nahezu Null.  Der Cache verbessert jedoch die Leistung.  Manchmal ist es besser, wenn alles nicht vorhersehbar genau im Takt arbeitet, sondern schnell als vorhersehbar langsam.  Dies gilt insbesondere f√ºr das Rechnen oder Anzeigen von Grafiken. <br><br>  Das Hauptproblem besteht jedoch nicht darin, dass die im Artikel beschriebenen Dinge auftreten, sondern dass sich das Verhalten des Systems von Baugruppe zu Baugruppe √§ndert, da niemand wei√ü, welche Adressen die Funktion nach dem Hinzuf√ºgen oder Entfernen von Code verlieren wird.  Vor 15 Jahren mussten wir im Projekt des Sega-Spielekonsolen-Emulators f√ºr einen Kabelfernsehdecoder einen ganzen Pr√§prozessor herstellen, der nach jeder Bearbeitung Funktionen, die Motorola-Assembler-Befehle auf dem SPARC-8-Kern emulierten, so verschob, dass ihre Ausf√ºhrungszeit immer gleich war (dort) aufgrund des Caches schwamm sonst alles viel). <br><br>  Aber wann brauchen wir Vorhersehbarkeit?  Nat√ºrlich w√§hrend der programmgesteuerten Erstellung von Zeitdiagrammen (denken Sie daran, dass es in FPGAs im Allgemeinen m√∂glich ist, dies auch den Ger√§ten anzuvertrauen, aber es gibt einige Details mit schneller Entwicklung).  Bei der Arbeit mit Rechenalgorithmen ist dies jedoch nicht so wichtig.  Sofern der Algorithmus nicht komplex ist, m√ºssen Sie sicherstellen, dass kritische Abschnitte keine konstante Cache-√úberlastung verursachen.  In den meisten F√§llen verursacht der Cache keine Probleme und die Produktivit√§t steigt. <br><br>  Im n√§chsten Artikel werden wir uns ansehen, wie kritische Funktionen in nicht zwischenspeicherbaren Speichern vorhergesagt werden k√∂nnen, die immer mit maximaler Geschwindigkeit ausgef√ºhrt werden, und die impliziten Vorteile von FPGAs gegen√ºber Standardsystemen diskutieren, die sich aus den in diesem Prozess verwendeten Technologien ergeben. <br><br><h2>  F√ºr die aufmerksamsten </h2><br>  Ein √§tzender Leser k√∂nnte fragen: "Warum wurde das Oszillogramm beim Einf√ºgen von vier Kilobyte Code nicht ausreichend zerrissen?"  Alles ist einfach.  Wenn Sie genau 4 Kilobyte einf√ºgen, erhalten wir die folgenden Adressen zum Platzieren von Funktionen im Speicher: <br><br><pre> <code class="plaintext hljs"> MagicFunction1(): 0200006c: movhi r2,1024 02000070: movi r4,1 02000074: addi r2,r2,4096 02000078: stwio r4,0(r2) 92 IOWR (PIO_0_BASE,0,0); 0200007c: mov r3,zero 02000080: stwio r3,0(r2) 93 IOWR (PIO_0_BASE,0,1); ... 120 IOWR (PIO_0_BASE,0,0); 020000f0: stwio r3,0(r2) 020000f4: ret 131 Nops1024 FuncBetween(): 020000f8: nop 020000fc: nop 02000100: nop 02000104: nop ... 020010ec: nop 020010f0: nop 020010f4: nop 020010f8: ret 135 IOWR (PIO_0_BASE,0,0); MagicFunction2(): 020010fc: movhi r2,1024 02001100: mov r4,zero 02001104: addi r2,r2,4096</code> </pre><br>  F√ºr eine vollkommen schlechte Wellenform m√ºssen Sie NOPs einf√ºgen, sodass 4 Kilobyte ihr Volumen zusammen mit der L√§nge der <b>MagicFunction1 ()</b> -Funktion sind.  Egal was Sie f√ºr ein sch√∂nes Bild gehen!  √Ñndern Sie den Einsatz in diesen: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops256 Nops256 Nops256 Nops64 Nops64 Nops64 Nops16 Nops16 }</code> </pre><br>  Immer wieder achte ich darauf, dass der Einsatz keine Kontrolle erh√§lt.  Es √§ndert einfach die Position der Funktionen im Speicher relativ zueinander.  Mit dieser Beilage bekommen wir den gew√ºnschten schrecklichen Horror: <br><br><img src="https://habrastorage.org/webt/7d/by/om/7dbyomefuy0kgtjxmnysanc_lxm.png"><br><br>  Es schien mir, dass solche Details, die in den Haupttext eingef√ºgt wurden, jeden vom Haupttext ablenken w√ºrden, also habe ich sie in ein Postskriptum eingef√ºgt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467353/">https://habr.com/ru/post/de467353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467339/index.html">Und wieder der 256. Tag des Jahres</a></li>
<li><a href="../de467343/index.html">Warum ich freiberuflich k√ºndige: Eindr√ºcke des Backend-Entwicklers nach 2 Jahren ‚ÄûFreiheit‚Äú</a></li>
<li><a href="../de467345/index.html">Hit IT-Blogs und 4 Trainingsebenen: ein Interview mit Sergei Abdulmanov aus Mosigra</a></li>
<li><a href="../de467347/index.html">Buch ‚ÄûErstellen solider Smart-Vertr√§ge f√ºr die Ethereum-Blockchain. Praktischer Leitfaden</a></li>
<li><a href="../de467349/index.html">Umzug eines Programmierers nach Estland: Arbeit, Geld und Lebenshaltungskosten</a></li>
<li><a href="../de467355/index.html">Interview mit Marktforschern und Softwareentwicklungstrends in Mittel- und Osteuropa, Eugene Schwab-Chesaru</a></li>
<li><a href="../de467357/index.html">PVS-Studio in den Clouds: Azure DevOps</a></li>
<li><a href="../de467359/index.html">PVS-Studio geht in die Cloud: Azure DevOps</a></li>
<li><a href="../de467361/index.html">Wir haben die Delegierung in JavaScript vergessen. Ereignisdelegation reagieren</a></li>
<li><a href="../de467363/index.html">Verwenden benutzerdefinierter Verlustfunktionen und Lernen von Qualit√§tsmetriken in Keras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>