<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌄 👨🏿‍✈️ 💼 Interne DSL- und Ausdrucksbäume - Dynamische Erstellung von Funktionen zum Serialisieren, Kopieren, Klonen und Gleichstellen (Teil I) 🌝 👏🏼 👱🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel konzentriert sich auf die doppelte Verwendung der Expression Trees- API - zum Parsen von Ausdrücken und zum Generieren von Code. Die An...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interne DSL- und Ausdrucksbäume - Dynamische Erstellung von Funktionen zum Serialisieren, Kopieren, Klonen und Gleichstellen (Teil I)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419759/"><p><img src="https://habrastorage.org/webt/_c/m3/gr/_cm3grewmg9yewpcch1nqkl2ho8.png"></p><br><p>  Dieser Artikel konzentriert sich auf die doppelte Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Expression Trees-</a> API - zum Parsen von Ausdrücken und zum Generieren von Code.  Die Analyse von Ausdrücken hilft beim Aufbau von Präsentationsstrukturen (sie sind auch Präsentationsstrukturen der problemorientierten Sprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Internal DSL</a> ), und die Codegenerierung ermöglicht es Ihnen, effektiv effektive Funktionen zu erstellen - Befehlssätze, die durch Präsentationsstrukturen festgelegt werden. </p><br><p> Ich werde die dynamische Erstellung von <strong>Eigenschaftsiteratoren</strong> demonstrieren <strong>: serialisieren, kopieren, klonen, gleich</strong> .  Am Beispiel der Serialisierung zeige ich Ihnen, wie Sie die Serialisierung (im Vergleich zu Stream-Serialisierern) in der klassischen Situation optimieren können, in der "vorläufiges" Wissen zur Verbesserung der Leistung verwendet wird.  Die Idee ist, dass beim Aufrufen des Streaming-Serializers immer die Funktion "Nicht-Streaming" verloren geht und genau bekannt ist, welche Baumknoten umgangen werden müssen.  Gleichzeitig wird ein solcher Serializer "nicht von Hand", sondern dynamisch, sondern nach vordefinierten Bypass-Regeln erstellt.  <strong>Das vorgeschlagene Inernal DSL löst das Problem einer kompakten Beschreibung der Regeln zum Durchlaufen von Baumstrukturen von Objekten anhand ihrer Eigenschaften / Eigenschaften (und im allgemeinen Fall: Durchlaufen des Berechnungsbaums mit dem Namen von Knoten)</strong> .  Der Serializer-Benchmark ist bescheiden, aber es ist wichtig, dass er dem Ansatz, der auf der Verwendung eines bestimmten internen <strong>DSL-Includes</strong> (einem Dialekt von Include / ThenInclude von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EF Core</a> ) und der Verwendung von internem DSL als Ganzes basiert, die notwendige Überzeugungskraft verleiht. </p><a name="habracut"></a><br><h2 id="vvedenie">  Einführung </h2><br><p>  Vergleichen Sie: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(){X=<span class="hljs-number"><span class="hljs-number">-1</span></span>,Y=<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var json2 = $"{{\"X\":{pX}, \"Y\":{pY}}}";</span></span></code> </pre> <br><p>  Die zweite Methode ist offensichtlich schneller (die Knoten sind bekannt und „in Code eingepfercht“), während die Methode natürlich komplizierter ist.  Wenn Sie diesen Code jedoch als Funktion erhalten (dynamisch generiert und kompiliert), wird die Komplexität ausgeblendet (selbst was unklar wird, wird ausgeblendet <br>  Wo ist die Reflexion und wo ist die Laufzeit der Codegenerierung? </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(){X=<span class="hljs-number"><span class="hljs-number">-1</span></span>,Y=<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var formatter = JsonManager.ComposeFormatter&lt;Point&gt;(); var json2 = formatter(p);</span></span></code> </pre> <br><p>  Hier ist <code>JsonManager.ComposeFormatter</code> das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eigentliche Werkzeug</a> .  Die Regel, nach der die Strukturumgehung während der Serialisierung generiert wird, ist nicht offensichtlich, klingt jedoch so: "Mit den Standardparametern werden für benutzerdefinierte Werttypen alle Felder der ersten Ebene umgangen."  Wenn Sie es explizit festlegen: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    var formatter2 = JsonManager.ComposeFormatter&lt;Point&gt;( chain=&gt;chain .Include(e=&gt;eX) .Include(e=&gt;eY) // DSL Includes )</span></span></code> </pre> <br><p>  Dies ist die Beschreibung von Metadaten über DSL Includes.  DSL hat die Analyse der Vor- und Nachteile der Beschreibung von Metadaten aufgeklärt. Da ich jedoch die Form der Aufzeichnung von Metadaten ignoriere, betone ich, dass C # die Möglichkeit bietet, den "idealen Serializer" mithilfe von Ausdrucksbäumen zu kompilieren und zu kompilieren. </p><br><div class="spoiler">  <b class="spoiler_title">Wie er es macht - viel Code und Anleitung zur Codegenerierung von Expression Trees ...</b> <div class="spoiler_text"><p>  Übergang vom <code>formatter</code> zum <code>serilizer</code> (bisher ohne Ausdrucksbäume): </p><br><pre> <code class="cs hljs"> Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer = ... <span class="hljs-comment"><span class="hljs-comment">// later string formatter(Point p) { var stringBuilder = new StringBuilder(); serializer(stringBuilder, p); return stringBuilder.ToString(); }</span></span></code> </pre> <br><p>  Der <code>serializer</code> ist wiederum wie folgt aufgebaut (wenn er mit statischem Code festgelegt ist): </p><br><pre> <code class="cs hljs">Expression&lt;Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; serializerExpression = SerializeAssociativeArray(sb, p, (sb1, t1) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString) ); Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer = serializerExpression.Compile();</code> </pre> <br><p>  Warum ist es so "funktional", warum können Sie nicht zwei Felder durch ein Semikolon serialisieren?  Kurz gesagt: weil dieser Ausdruck einer Variablen vom Typ <code>Expression&lt;Func&lt;StringBuilder, Box, bool&gt;&gt;</code> zugewiesen werden kann, ein Semikolon jedoch nicht zulässig ist. <br>  Warum konnte ich <code>Func&lt;StringBuilder, Point, bool&gt; serializer = (sb,p)=&gt;SerializeAssociativeArray(sb,p,...</code> nicht direkt schreiben? Es ist möglich, aber ich demonstriere nicht das Erstellen eines Delegaten, sondern einer Assembly (in diesem Fall statischer Code). Ausdrucksbaum, mit einer Kompilierung für den Delegaten in der Zukunft, in der Praxis wird <code>serializerExpression</code> auf eine völlig andere Weise festgelegt - dynamisch (unten). </p><br><p>  Was jedoch in der Lösung selbst wichtig ist: <code>SerializeAssociativeArray</code> akzeptiert ein Array von <code>params Func&lt;..&gt; propertySerializers</code> entsprechend der Anzahl der zu <code>params Func&lt;..&gt; propertySerializers</code> Knoten.  Das Umgehen einiger von ihnen kann durch SerializeValueProperty-Serialisierer von Blättern (Akzeptieren des <code>SerializeValueToString</code> Formatierers) und andere wiederum durch <code>SerializeAssociativeArray</code> ( <code>SerializeAssociativeArray</code> Zweige) festgelegt werden, und somit wird ein Iterator (Baum) des Durchlaufs erstellt. </p><br><p>  Wenn Point die NextPoint-Eigenschaft enthielt: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> = SerializeAssociativeArray(sb, p, (sb1, t1) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"NextPoint"</span></span>, o =&gt; o.NextPoint, (sb4, t4) =&gt;SerializeAssociativeArray(sb1, p1, (sb1, t1) =&gt; SerializeValueProperty(sb2, t2, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb2, t2, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString) ) ) );</code> </pre> <br><p>  Das Gerät der drei Funktionen <code>SerializeAssociativeArray</code> , <code>SerializeValueProperty</code> , <code>SerializeValueToString</code> nicht kompliziert: </p><br><div class="spoiler">  <b class="spoiler_title">Serialisieren ...</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeAssociativeArray&lt;T&gt;(StringBuilder stringBuilder, T t, <span class="hljs-keyword"><span class="hljs-keyword">params</span></span> Func&lt;StringBuilder, T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;[] propertySerializers) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'{'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertySerializer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> propertySerializers) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notEmpty = propertySerializer(stringBuilder, t); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notEmpty) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!@<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">','</span></span>); } }; stringBuilder.Length--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (@<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'}'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeValueProperty&lt;T, TProp&gt;(StringBuilder stringBuilder, T t, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName, Func&lt;T, TProp&gt; getter, Func&lt;StringBuilder, TProp, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TProp : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'"'</span></span>).Append(propertyName).Append(<span class="hljs-string"><span class="hljs-string">'"'</span></span>).Append(<span class="hljs-string"><span class="hljs-string">':'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = getter(t); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notEmpty = serializer(stringBuilder, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!notEmpty) stringBuilder.Length -= (propertyName.Length + <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> notEmpty; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeValueToString&lt;T&gt;(StringBuilder stringBuilder, T t) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stringBuilder.Append(t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> </div></div><br><p>  Viele Details werden hier nicht angegeben (Listenunterstützung, Referenztyp und nullbar).  Und doch ist es klar, dass ich wirklich <em>json</em> in der Ausgabe bekomme und alles andere noch mehr von den Standardfunktionen <code>SerializeArray</code> , <code>SerializeNullable</code> , <code>SerializeRef</code> . </p><br><p>  Es war ein statischer Ausdrucksbaum, nicht dynamisch, nicht <em>in C # ausgewertet</em> . </p><br><p>  Sie können sehen, wie der Ausdrucksbaum in zwei Schritten dynamisch erstellt wird: </p><br><h4 id="shag-1---decompilerom-posmotret-na-kod-prisvoennyy-expressiont">  Schritt 1 - Der Dekompiler überprüft den durch <code>Expression&lt;T&gt;</code> zugewiesenen Code </h4><br><p><img src="https://habrastorage.org/webt/ox/p3/g2/oxp3g2newr9bhr3oba5bajcrkco.png"></p><br><p>  Dies wird Sie natürlich beim ersten Mal überraschen.  Nichts ist klar, aber Sie können sehen, wie die ersten vier Zeilen so etwas zusammensetzen: </p><br><pre> <code class="cs hljs">(<span class="hljs-string"><span class="hljs-string">"sb"</span></span>,<span class="hljs-string"><span class="hljs-string">"t"</span></span>) .. SerializeAssociativeArray..</code> </pre> <br><p>  Dann wird die Verbindung mit dem Quellcode erfasst.  Und es sollte klar werden, dass Sie, wenn Sie einen solchen Datensatz beherrschen (indem Sie 'Expression.Const', 'Expression.Parameter', 'Expression.Call', 'Expression.Lambda' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">usw.</a> kombinieren), wirklich dynamisch verknüpfen können - jede Umgehung von Knoten (basierend auf Metadaten).  Dies ist <em>in C # eval</em> . </p><br><h4 id="shag-2----shodit-po-etoy-ssylkehttpsgithubcomdashboardcoderoutinesblobmastertestsconsoleappsclrmdautomationprogramcsl99-l194">  Schritt 2 - folgen Sie <a href="">diesem Link</a> , </h4><br><p>  Der gleiche Dekompiler-Code, aber vom Menschen kompiliert. </p><br><p>  Nur der Autor des Dolmetschers muss sich mit dieser Perlenstickerei befassen.  Alle diese Künste verbleiben in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Serialisierungsbibliothek</a> .  Es ist wichtig zu lernen, dass Sie Bibliotheken bereitstellen können, die dynamisch kompilierte effiziente Funktionen in C # (und .NET Standard) generieren. </p></div></div><br><p>  Ein Streaming-Serializer überholt jedoch eine dynamisch generierte Funktion, wenn Sie die Kompilierung jedes Mal vor der Serialisierung aufrufen (das Kompilieren im <code>ComposeFormatter</code> ist eine kostspielige Operation). Sie können den Link jedoch speichern und wiederverwenden: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Func&lt;Point, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; formatter = JsonManager.ComposeFormatter&lt;Point&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Point p</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var json2 = formatter(p); return json2; }</span></span></code> </pre> <br><p>  Wenn Sie einen Serializer vom anonymen Typ zur Wiederverwendung erstellen und speichern müssen, benötigen Sie zusätzliche Infrastruktur: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Point&gt; list</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// there json formatter will be build only for first call // and assigned to cachedFormatter.Formatter // in all next calls cachedFormatter.Formatter will be used. // since building of formatter is determenistic it is lock free var json3 = list.Select(e=&gt; {X:eX, Sum:e.X+EY}) .ToJson(cachedFormatter, e=&gt;e.Sum); return json3; }</span></span></code> </pre> <br><p>  Danach berücksichtigen wir zuversichtlich die erste Mikrooptimierung für uns selbst und akkumulieren, akkumulieren, akkumulieren ... Wer ist der Witz, wer nicht, aber bevor ich zu der Frage übergehe, dass der neue Serializer neu ist, behebe ich den offensichtlichen Vorteil - er wird schneller sein. </p><br><h2 id="chto-vzamen">  Was dafür? </h2><br><p>  Das DSL enthält Interpreter in Serilize (und auf die gleiche Weise, wie es in Iteratoren gleich ist, kopieren, klonen - und das wird auch ungefähr sein), erforderte die folgenden Kosten: </p><br><p>  <strong>1</strong> - Kosten der Infrastruktur zum Speichern von Links zu kompiliertem Code. </p><br><p>  Diese Kosten sind im Allgemeinen nicht erforderlich, ebenso wie die Verwendung von Ausdrucksbäumen bei der Kompilierung. Der Interpreter kann einen Serialisierer für Reflexe erstellen und ihn sogar so weit lecken, dass er sich der Geschwindigkeit in Bezug auf Stream-Serialisierer (übrigens Kopieren, Klonen und) nähert Gleichheit wird weder durch Ausdrucksbäume gesammelt noch geleckt, es gibt keine solche Aufgabe, im Gegensatz zum Überholen von ServiceStack und Json.NET im Rahmen der wohlverstandenen Aufgabe der Optimierung der Serialisierung in json - eine notwendige Voraussetzung für die Präsentation einer neuen Lösung). </p><br><p>  <strong>2</strong> - Sie müssen Abstraktionslecks sowie ein ähnliches Problem berücksichtigen: Änderungen in der Semantik im Vergleich zu vorhandenen Lösungen. </p><br><p>  Zum Beispiel benötigen Point und IEnumerable zwei verschiedene Serializer zum Serialisieren. <br></p><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter1 = JsonManager.ComposeFormatter&lt;Point&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter2 = JsonManager.ComposeEnumerableFormatter&lt;Point&gt;(); <span class="hljs-comment"><span class="hljs-comment">// but not // var formatter2 = JsonManager.ComposeEnumerableFormatter&lt;List&lt;Point&gt;&gt;();</span></span></code> </pre> <br><p>  Oder: "Funktioniert die Schließung?".  Es funktioniert, nur der Knoten muss einen Namen (eindeutig) festlegen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> DATEFORMAT= <span class="hljs-string"><span class="hljs-string">"YYYY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter3 = JsonManager.ComposeFormatter&lt;Record&gt;( chain =&gt; chain .Include(i =&gt; i.RecordId) .Include(i =&gt; i.CreatedAt.ToString(DATEFORMAT) , <span class="hljs-string"><span class="hljs-string">"CreatedAt"</span></span>); );</code> </pre> <br><p>  Dieses Verhalten wird <code>ComposeFormatter</code> vom internen Gerät des <code>ComposeFormatter</code> Interpreters <code>ComposeFormatter</code> . </p><br><p>  Kosten dieser Art sind unvermeidlich böse.  Darüber hinaus wird festgestellt, dass durch die Erweiterung der Funktionalität und den Umfang des internen DSL auch Abstraktionslecks zunehmen.  Es wird sicherlich den Entwickler von internem DSL unterdrücken, hier müssen Sie sich mit einer philosophischen Stimmung eindecken. </p><br><p>  Für den Benutzer werden Abstraktionslecks durch die Kenntnis der technischen Details von internem DSL ( <em>was ist zu erwarten?</em> ) Und des Funktionsumfangs eines bestimmten DSL und seiner Interpreter ( <em>was im Gegenzug?</em> ) <em>Überwunden</em> .  Daher die Antwort auf die Frage: "Lohnt es sich, internes DSL zu erstellen und zu verwenden?" Es kann nur eine Geschichte über die Funktionalität eines bestimmten DSL geben - über all seine Details und Annehmlichkeiten und seine möglichen Anwendungen (Dolmetscher), d. H.  eine Geschichte über die Überwindung von Kosten. </p><br><p>  In diesem Sinne kehre ich zur Effektivität eines bestimmten DSL-Includes zurück. </p><br><p>  Eine signifikant höhere Effizienz wird erreicht, wenn das Ziel darin besteht, das Tripel (DTO, Transformation in DTO, Serialisierung von DTO) durch eine lokal detaillierte und generierte Serialisierungsfunktion zu ersetzen.  Am Ende des Dualismus-Funktionsobjekts können Sie "DTO ist eine solche Funktion" sagen und ein Ziel festlegen: lernen, wie eine DTO-Funktion festgelegt wird. </p><br><p>  Die Serialisierung muss konfiguriert sein: </p><br><ol><li>  Bypass-Baum (um die Knoten zu beschreiben, über die die Serialisierung stattfinden wird, um das Problem der kreisförmigen Verknüpfungen zu lösen), weisen Sie im Fall von Blättern einen Formatierer (nach Typ) zu. </li><li>  Die Regel für das Einschließen von Blättern (falls nicht angegeben) - Eigenschaft gegen Felder?  schreibgeschützt? </li><li>  Um sowohl einen Zweig (einen Knoten mit Navigation) als auch ein Blatt angeben zu können, muss nicht nur MemberExpression ( <code>e=&gt;e.Name</code> ), sondern im Allgemeinen eine beliebige Funktion (`e =&gt; e.Name.ToUpper ()," MyMemberName ") den Formatierer auf einen bestimmten Wert festlegen Knoten. </li></ol><br><p>  Weitere Möglichkeiten zur Erhöhung der Flexibilität: </p><br><ol><li>  Serialisieren Sie ein Blatt, das eine JSON-Zeichenfolge "as is" enthält (spezieller Zeichenfolgenformatierer). </li><li>  setze Formatierer auf Gruppen, d.h.  ganze Zweige, in diesem Zweig wie diesem - auf eine andere Weise anders (zum Beispiel hier mit der Zeit und in diesem ohne Zeit). </li></ol><br><p>  Überall können Konstruktionen wie Bypass-Baum, Zweig, Blatt und all dies mit DSL Includes geschrieben werden. </p><br><h2 id="dsl-includes">  DSL beinhaltet </h2><br><p>  Da jeder mit EF Core vertraut ist, sollte die Bedeutung der folgenden Ausdrücke sofort erfasst werden (dies ist eine Teilmenge von xpath). </p><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// DSL Includes Include&lt;User&gt; include1 = chain=&gt; chain .IncludeAll(e =&gt; e.Groups) .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) // EF Core syntax // https://docs.microsoft.com/en-us/ef/core/querying/related-data var users = context.Users .Include(blog =&gt; blog.Groups) .Include(blog =&gt; blog.Roles) .ThenInclude(blog =&gt; blog.Privileges);</span></span></code> </pre> <br><p>  Hier sind die Knoten "mit Navigation" - "Zweige". <br>  Die Antwort auf die Frage, welche Knoten "Blätter" (Felder / Eigenschaften) in dem so definierten Baum enthalten sind - keine.  Um Blätter einzuschließen, müssen Sie sie entweder explizit auflisten: </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include2 = chain=&gt; chain .Include(e =&gt; e.UserName) <span class="hljs-comment"><span class="hljs-comment">// leaf member .IncludeAll(e =&gt; e.Groups) .ThenInclude(e =&gt; e.GroupName) // leaf member .IncludeAll(e =&gt; e.Roles) .ThenInclude(e =&gt; e.RoleName) // leaf member .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) .ThenInclude(e =&gt; e.PrivilegeName) // leaf member</span></span></code> </pre><br><p>  Oder fügen Sie dynamisch nach der Regel über einen spezialisierten Interpreter hinzu: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Func&lt;ChainNode, MemberInfo&gt; rule = ... var include2 = IncludeExtensions.AppendLeafs(include1, rule);</span></span></code> </pre> <br><p>  Hier ist die Regel eine Regel, die von ChainNode.Type ausgewählt werden kann, d.h.  nach Art des vom Knoten zurückgegebenen Ausdrucks (ChainNode - interne Darstellung von DSL Includes, auf die später noch eingegangen wird) Eigenschaften (MemberInfo) für die Teilnahme an der Serialisierung, z.  Nur eine Eigenschaft oder nur eine Lese- / Schreibeigenschaft oder nur diejenigen, für die es einen Formatierer gibt, können Sie aus einer Liste von Typen auswählen, und sogar der Include-Ausdruck selbst kann eine Regel festlegen (wenn er Blattknoten auflistet - d. h. die Form der Baumverknüpfung). . </p><br><p>  Oder ... überlassen Sie es dem Benutzerinterpreter, der entscheidet, was mit den Knoten geschehen soll.  DSL Includes ist nur ein Metadatensatz. Wie dieser Datensatz interpretiert wird, hängt vom Interpreter ab.  Er kann die Metadaten so interpretieren, wie er möchte, bis er sie ignoriert.  Einige Interpreter führen die Aktion selbst aus, während andere eine Funktion erstellen, die bereit ist, sie auszuführen (über Expression Tree oder sogar Reflection.Emit).  Ein gutes internes DSL ist für den universellen Gebrauch und die Existenz vieler Dolmetscher konzipiert, von denen jeder seine eigenen Besonderheiten und Abstraktionslecks aufweist. <br>  Code, der internes DSL verwendet, kann sich stark von dem unterscheiden, was er zuvor war. </p><br><h4 id="out-of-the-box">  Out of the Box </h4><br><p>  Integration mit EF Core. <br>  Die laufende Aufgabe besteht darin, "zyklische Links abzubrechen", um nur das zu starten, was im Include-Ausdruck angegeben ist: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetJson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbContext = GetEfCoreContext()) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> json = EfCoreExtensions.ToJsonEf&lt;User&gt;(cachedFormatter1, dbContext, chain=&gt;chain .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges)); } }</code> </pre> <br><p>  <code>ToJsonEf</code> akzeptiert die Navigationssequenz, verwendet sie beim Serialisieren (wählt Blätter nach der Regel "Standard für EF Core" aus, dh öffentliche Lese- / Schreibeigenschaft), interessiert sich für das Modell - wobei string / json Feldformatierer verwendet, um sie unverändert einzufügen Standardmäßig (Byte [] pro Zeichenfolge, Datum / Uhrzeit in ISO usw.).  Daher muss er IQuaryable unter sich ausführen. </p><br><p>  In dem Fall, in dem das Ergebnis transformiert wird, ändern sich die Regeln - es ist nicht erforderlich, DSL Includes zu verwenden, um die Navigation anzugeben (wenn die Regel nicht wiederverwendet wird), ein anderer Interpreter wird verwendet und die Konfiguration erfolgt lokal: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetJson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbContext = GetEfCoreContext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> json = dbContext.ParentRecords <span class="hljs-comment"><span class="hljs-comment">// back to EF core includes // but .Include(include1) also possible .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) .Select(e =&gt; new { FieldA: e.FieldA, FieldJson:"[1,2,3]", Role: e.Roles().First() }) .ToJson(cachedFormatter1, chain =&gt; chain.Include(e =&gt; e.Role), LeafRuleManager.DefaultEfCore, config: rules =&gt; rules .AddRule&lt;string[]&gt;(GetStringArrayFormatter) .SubTree( chain =&gt; chain.Include(e =&gt; e.FieldJson), stringAsJsonLiteral: true) // json as is .SubTree( chain =&gt; chain.Include(e =&gt; e.Role), subRules =&gt; subRules .AddRule&lt;DateTime&gt;( dateTimeFormat: "YYYMMDD", floatingPointFormat: "N2" ) ), ), useToString: false, // no default ToString for unknown leaf type (throw exception) dateTimeFormat: "YYMMDD", floatingPointFormat: "N2" } }</span></span></code> </pre> <br><p>  Es ist klar, dass all diese Details, all dies ist „standardmäßig“, nur dann berücksichtigt werden können, wenn Sie sie wirklich brauchen und / oder wenn dies Ihr eigener Dolmetscher ist.  Auf der anderen Seite kehren wir noch einmal zu den Pluspunkten zurück: DTO wird nicht durch Code verschmiert, wird durch eine bestimmte Funktion spezifiziert, Interpreter sind universell.  Der Code wird kleiner - das ist gut. </p><br><p>  <strong>Es ist zu warnen</strong> : Obwohl es den Anschein hat, dass vorläufiges Wissen in ASP immer verfügbar ist und ein Streaming-Serializer in der Welt des Webs, in der sogar Datenbanken Daten in JSON übertragen, nicht unbedingt erforderlich ist, ist die Verwendung von DSL Includes in ASP MVC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht die einfachste Geschichte</a> .  Wie man funktionale Programmierung mit ASP MVC kombiniert, verdient eine separate Studie. </p><br><p>  In diesem Artikel beschränke ich mich auf die Feinheiten von DSL Includes. Ich werde sowohl neue Funktionen als auch das Durchsickern von Abstraktionen zeigen, um zu zeigen, dass das Problem der Analyse von "Kosten und Akquisitionen" tatsächlich erschöpfbar ist. </p><br><h2 id="esche-bolshe-dsl-includes">  Mehr DSL beinhaltet </h2><br><pre> <code class="cs hljs">Include&lt;Point&gt; include = chain =&gt; chain.Include(e=&gt;eX).Include(e=&gt;eY);</code> </pre> <br><p>  Dies unterscheidet sich von EF Core Includes, die auf statischen Funktionen basieren, die nicht Variablen zugewiesen und als Parameter übergeben werden können.  DSL Includes selbst entstand aus der Notwendigkeit heraus, "include" in meine Implementierung der Repository-Vorlage zu übergeben, ohne die Typinformationen zu verschlechtern, die bei der Standardisierung in Zeichenfolgen aufgetreten wären. </p><br><p>  Der dramatischste Unterschied besteht immer noch in der Ernennung.  EF Core Includes - Einbeziehung von Navigationseigenschaften (Knoten von Zweigen), DSL Includes - Aufzeichnung der Durchquerung eines Berechnungsbaums, wobei dem Ergebnis jeder Berechnung ein Name (Pfad) zugewiesen wird. </p><br><p>  Die interne Darstellung von EF Core Includes ist eine Liste von Zeichenfolgen, die von MemberExpression.Member empfangen wurden (Der durch <code>e=&gt;User.Name</code> angegebene <code>e=&gt;User.Name</code> kann nur [MemberExpression] sein ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://msdn.microsoft.com/en-us/library/system.linq.expressions). Mitgliedsausdruck (v = vs. 110) .aspx</a> und in internen Ansichten wird nur die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Namenszeile</a> gespeichert). </p><br><p>  In DSL Includes besteht die interne Darstellung aus den Klassen <a href="">ChainNode und ChainMemberNode</a> , <a href="">die den gesamten</a> Ausdruck (z. B. <code>e=&gt;User.Name</code> ) <code>e=&gt;User.Name</code> , der so wie er ist in den Ausdrucksbaum integriert ist.  Genau aus diesem Grund unterstützt DSL Includes sowohl Felder als auch Benutzerwerttypen und Funktionsaufrufe: </p><br><p>  Ausführung von Funktionen: </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .Include(i =&gt; i.Email.ToUpper(),<span class="hljs-string"><span class="hljs-string">"EAddress"</span></span>);</code> </pre> <br><p>  Was damit zu tun ist, hängt vom Dolmetscher ab.  CreateFormatter- gibt {"UserName": "John", "EAddress": "JOHN@MAIL.COM"} zurück </p><br><p>  Die Ausführung kann auch nützlich sein, um das Durchlaufen von nullbaren Strukturen festzulegen. </p><br><pre> <code class="cs hljs">Include&lt;StrangePointF&gt; include = chain =&gt; chain .Include(e =&gt; e.NextPoint) <span class="hljs-comment"><span class="hljs-comment">// NextPoint is nullable struct .ThenIncluding(e =&gt; e.Value.X) .ThenInclude(e =&gt; e.Value.Y); // but not this way (abstraction leak) // Include&lt;StrangePointF&gt; include // = chain =&gt; chain // now this can throw an exception // .Include(e =&gt; e.NextPoint.Value) // .ThenIncluding(e =&gt; eX) // .ThenInclude(e =&gt; eY);</span></span></code> </pre> <br><p>  DSL Includes enthält auch einen kurzen Eintrag für die mehrstufige ThenIncluding-Problemumgehung. </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .IncludeAll(i =&gt; i.Groups) <span class="hljs-comment"><span class="hljs-comment">// ING-form - doesn't change current node .ThenIncluding(e =&gt; e.GroupName) // leaf .ThenIncluding(e =&gt; e.GroupDescription) // leaf .ThenInclude(e =&gt; e.AdGroup); // leaf</span></span></code> </pre> <br><p>  vergleiche mit </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.GroupName) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.GroupDescription) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.AdGroup);</code> </pre> <br><p>  Und auch hier gibt es ein Abstraktionsleck.  Wenn ich die Navigation in dieser Form notiert habe, sollte ich wissen, wie ein Interpreter funktioniert, der QuaryableExtensions aufruft.  Und er übersetzt die Aufrufe in Include und ThenInclude in Include "string".  Was kann wichtig sein (Sie müssen bedenken). </p><br><p>  <strong>Algebra Include-Ausdrücke</strong> . </p><br><p>  Einschlussausdrücke können sein: </p><br><div class="spoiler">  <b class="spoiler_title">Vergleichen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b1 = InlcudeExtensions.IsEqualTo(include1, include2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b2 = InlcudeExtensions.IsSubTreeOf(include1, include2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b3 = InlcudeExtensions.IsSuperTreeOf(include1, include2);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Klon</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> include2 = InlcudeExtensions.Clone(include1);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Zusammenführen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> include3 = InlcudeExtensions.Merge(include1, include2);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">In XPath-Listen konvertieren - Alle Pfade zu Blättern</b> <div class="spoiler_text"><pre> <code class="cs hljs">IReadOnlyCollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; paths1 = InlcudeExtensions.ListLeafXPaths(include); <span class="hljs-comment"><span class="hljs-comment">// as xpaths IReadOnlyCollection&lt;string[]&gt; paths2 = InlcudeExtensions.ListLeafKeyPaths(include); // as string[]</span></span></code> </pre> </div></div><br><p>  usw. </p><br><p>  Die gute Nachricht ist: Es gibt keine Abstraktionslecks, hier wird die Ebene der reinen Abstraktion erreicht.  Es gibt Metadaten und arbeiten mit Metadaten. </p><br><h2 id="dialektika">  Dialektik </h2><br><p>  Mit DSL Includes können Sie eine neue Abstraktionsebene erreichen. Zum Zeitpunkt des Erreichens besteht jedoch die Notwendigkeit, zur nächsten Ebene zu gelangen: Include-Ausdrücke selbst generieren. </p><br><p>  In diesem Fall ist es nicht erforderlich, DSL als fließende Kette zu generieren. Sie müssen lediglich interne Repräsentationsstrukturen erstellen. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChainNode(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Point)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> child = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChainPropertyNode( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), expression: <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Point).CreatePropertyLambda(<span class="hljs-string"><span class="hljs-string">"X"</span></span>), memberName:<span class="hljs-string"><span class="hljs-string">"X"</span></span>, isEnumerable:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, parent:root ); root.Children.Add(<span class="hljs-string"><span class="hljs-string">"X"</span></span>, child); <span class="hljs-comment"><span class="hljs-comment">// or there is number of extension methods eg: var child = root.AddChild("X"); Include&lt;Point&gt; include = ChainNodeExtensions.ComposeInclude&lt;Point&gt;(root);</span></span></code> </pre> <br><p>  Sie können Präsentationsstrukturen auch an Dolmetscher übergeben.  Warum enthält die fließende DSL-Aufzeichnung dann überhaupt?  Dies ist eine rein spekulative Frage, deren Antwort darin besteht, dass es in der Praxis nur möglich ist, die interne Repräsentation (und auch die Entwicklung) zusammen mit der Entwicklung von DSL zu entwickeln (d. H. Eine kurze Ausdrucksaufzeichnung, die für statischen Code geeignet ist).  Dies wird noch einmal näher an der Schlussfolgerung gesagt. </p><br><h2 id="copy-clone-equals">  Kopieren, Klonen, Gleich </h2><br><p>  All dies gilt für Interpreter-Ausdrucksinterpreter, die <strong>Copy</strong> , <strong>Clone</strong> und Iteratoren implementieren. </p><br><div class="spoiler">  <b class="spoiler_title">Gleich</b> <div class="spoiler_text"><p>  Vergleich nur auf Blättern aus dem Include-Ausdruck. <br>  Verstecktes semantisches Problem: Auswerten oder nicht in der Liste sortieren </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.Include(e=&gt;e.UserId).IncludeAll(e=&gt;e.Groups).ThenInclude(e=&gt;e.GroupId) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b1 = ObjectExtensions.Equals(user1, user2, include); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b2 = ObjectExtensions.EqualsAll(userList1, userList2, include);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Klon</b> <div class="spoiler_text"><p>  Übergeben Sie Ausdrucksknoten.  Eigenschaften, die der Regel entsprechen, werden kopiert. </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.Include(e=&gt;e.UserId).IncludeAll(e=&gt;e.Groups).ThenInclude(e=&gt;e.GroupId) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newUser = ObjectExtensions.Clone(user1, include, leafRule1); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newUserList = ObjectExtensions.CloneAll(userList1, leafRule1);</code> </pre> <br><p>  Möglicherweise gibt es einen Dolmetscher, der Blatt aus Includes auswählt.  Warum wird es gemacht - durch eine separate Regel?  Was war ähnlich der Semantik von ObjectExtensions.Copy </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Kopieren</b> <div class="spoiler_text"><p>  Durch Knoten gehen - ein Ausdruckszweig und die Identifizierung durch Blattknoten.  Eigenschaften, die der Regel entsprechen, werden kopiert (ähnlich wie beim Klonen). </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.IncludeAll(e=&gt;e.Groups); ObjectExtensions.Copy(user1, user2, include, supportedLeafsRule); ObjectExtensions.CopyAll(userList1, userList2, include, supportedLeafsRule);</code> </pre> <br><p>  Möglicherweise gibt es einen Interpreter, der Blatt aus Includes auswählt.  Warum wird es gemacht - durch eine separate Regel?      ObjectExtensions.Copy (   —  include   ,  supportedLeafsRule —   ). </p></div></div><br><p>  copy / clone   : </p><br><ol><li>   readonly ,     Tuple&lt;,&gt;  Anonymous Type.    ,     . </li><li>   (. IEnumerable   ) —  public   . </li><li>  expression  include-,       —  . </li><li> "  "    . </li></ol><br><p>  DSL                   , ..               . ,     <code>Tuple&lt;,&gt;</code> , ..  c readonly ,   <code>ValueTuple&lt;,&gt;</code> c writabale      (      ). </p><br><p>  ,         (    Expression Trees) Includes  —  .     Include DSL  . </p><br><p>    Detach, FindDifferences  .. </p><br><h2 id="pochemu-run-time-a-ne-cs-sgenerirovannyy-do-nachala-kompilyacii">  run-time,   .cs    ? </h2><br><p>    .cs  ,   ,   <em>run-time</em>   : </p><br><ol><li>       ( ,  , source control). </li><li>     , ,  ,   —     . </li><li>         . </li><li>   "  ".  dev time   ,     : ""      ""   ,  ""    , ,  ""   . </li></ol><br><p>   Roslyn',          .    Typescript  (  DTO  , ..   ) —   DSL Includes  Roslyn' ( ) —      typescript ( ).  " "    " "  .cs (   Expression Trees). </p><br><p> :   run time —   ,  .             (        Expression Trees). </p><br><h2 id="problemy-s-effektivnostyu-skompilirovannyh-funkciy-expression-trees">      Expression Trees </h2><br><p>   Internal DSL   Expression Tree    : </p><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>LambdaExpression.Compile</code></a>    <em>Lambda</em> .     ,  .    ,   "" expression tree,   CallExpression    —  LambdaExpression,   (.  LambdaExpression)    ConstantExpression.    ,  " /" —      ,    Expression Trees. </p><br></li><li><p>       <em>ssmbly</em> ,     ( 10    )    ( assembly  ,    —  ). , ,  ,      —  . </p><br></li></ol><br><p>     ,        (  ),     ,       .    :       .   —  —   .cs     . </p><br><h2 id="benchmark-serializacii">   </h2><br><p>  —     600   15   .  JSON.NET, ServiceStack    reflection' GetProperties(). </p><br><p> dslComposeFormatter — ComposeFormatter   ,   <a href=""></a> . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BenchmarkDotNet</a> =v0.10.14, OS=Windows 10.0.17134 <br> Intel Core i5-2500K CPU 3.30GHz (Sandy Bridge), 1 CPU, 4 logical and 4 physical cores <br> .NET Core SDK=2.1.300 </p><br><table><thead><tr><th> Method </th><th> Mean </th><th>  Fehler </th><th> StdDev </th><th> Min </th><th> Max </th><th> Median </th><th> Allocated </th></tr></thead><tbody><tr><td> dslComposeFormatter </td><td> 2.208 ms </td><td> 0.0093 ms </td><td> 0.0078 ms </td><td> 2.193 ms </td><td> 2.220 ms </td><td> 2.211 ms </td><td> 849.47 KB </td></tr><tr><td> JsonNet_Default </td><td> 2.902 ms </td><td> 0.0160 ms </td><td> 0.0150 ms </td><td> 2.883 ms </td><td> 2.934 ms </td><td> 2.899 ms </td><td> 658.63 KB </td></tr><tr><td> JsonNet_NullIgnore </td><td> 2.944 ms </td><td> 0.0089 ms </td><td> 0.0079 ms </td><td> 2.932 ms </td><td> 2.960 ms </td><td> 2.942 ms </td><td> 564.97 KB </td></tr><tr><td> JsonNet_DateFormatFF </td><td> 3.480 ms </td><td> 0.0121 ms </td><td> 0.0113 ms </td><td> 3.458 ms </td><td> 3.497 ms </td><td> 3.479 ms </td><td> 757.41 KB </td></tr><tr><td> JsonNet_DateFormatSS </td><td> 3.880 ms </td><td> 0.0139 ms </td><td> 0.0130 ms </td><td> 3.854 ms </td><td> 3.899 ms </td><td> 3.877 ms </td><td> 785.53 KB </td></tr><tr><td> ServiceStack_SerializeToString </td><td> 4.225 ms </td><td> 0.0120 ms </td><td> 0.0106 ms </td><td> 4.201 ms </td><td> 4.243 ms </td><td> 4.226 ms </td><td> 805.13 KB </td></tr><tr><td> fake_expressionManuallyConstruted </td><td> 54.396 ms </td><td> 0.1758 ms </td><td> 0.1644 ms </td><td> 54.104 ms </td><td> 54.629 ms </td><td> 54.383 ms </td><td> 7401.58 KB </td></tr></tbody></table><br><p> fake_expressionManuallyConstruted — expression      ( ). </p><br><h2 id="formalizaciya">  </h2><br><p>   DSL   : <strong>   DSL      ;    Internal DSL   run-time</strong> . </p><br><p> Expression Tree         <em></em>   .NET Standard . </p><br><p>     Expression Trees  <em> </em>     Internal DSL    Fluent API.      #      . </p><br><p>         fluent   (   Expression Trees),      Internal DSL  #     fluent,      ""   Expression Trees. </p><br><p> <strong>Expression Trees</strong>  <strong>DSL Includes</strong>      (  ,      ),      /  run-time —  (run-time ). </p><br><p>  <strong>Internal DSL</strong>       :   -  <strong>serialize</strong> , <strong>copy</strong> , <strong>clone</strong> , <strong>equals</strong>        <strong>       ""</strong> .   ,      " ",      .    :  includes    (   ) ,       (       ,  ). </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>   DSL Includes    DTO           —   ( json).        ,    ,    ,   " ",        .   =   . </p><br><p>       Internal DSL       ,   DSL,      Internal DSL (    Expression)         (     Expression Tree). </p><br><p>  DSL Includes  json  ComposeFormatter    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DashboardCodes.Routines</a>   nuget  GitHub. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419759/">https://habr.com/ru/post/de419759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419735/index.html">Untersuchen des I / Q-Signals mit SDR mithilfe von Adobe Audition</a></li>
<li><a href="../de419743/index.html">Was ist falsch an populären Artikeln, die besagen, dass foo schneller als bar ist?</a></li>
<li><a href="../de419745/index.html">Klassisches KI-Genre: ML sucht sich in der Poesie</a></li>
<li><a href="../de419747/index.html">DJI Ronin S - Erster Start und Hauptmerkmale</a></li>
<li><a href="../de419757/index.html">Übersetzung von Andrew Un's Buch, Leidenschaft für maschinelles Lernen, Kapitel 1 - 14</a></li>
<li><a href="../de419761/index.html">Erstellen Sie ein 2D-Spiel in Python mit der Arcade-Bibliothek</a></li>
<li><a href="../de419763/index.html">Beispiele für die Berechnung des "Verfügbarkeitsfaktors" für Netzwerkgeräte</a></li>
<li><a href="../de419765/index.html">Der Kurs "Web-Programmiersprachen" (basierend auf Ruby) von MSTU. N. E. Bauman auf dem Technostream-Kanal</a></li>
<li><a href="../de419767/index.html">Der Wikipedia-Ersteller beantwortet Fragen: Programmieren, Schlafen, Bücher, Tipps fürs Leben</a></li>
<li><a href="../de419769/index.html">WireGuard wird zum Linux-Kernel "kommen" - warum?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>