<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÑ üë®üèø‚Äç‚úàÔ∏è üíº Interne DSL- und Ausdrucksb√§ume - Dynamische Erstellung von Funktionen zum Serialisieren, Kopieren, Klonen und Gleichstellen (Teil I) üåù üëèüèº üë±üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel konzentriert sich auf die doppelte Verwendung der Expression Trees- API - zum Parsen von Ausdr√ºcken und zum Generieren von Code. Die An...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interne DSL- und Ausdrucksb√§ume - Dynamische Erstellung von Funktionen zum Serialisieren, Kopieren, Klonen und Gleichstellen (Teil I)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419759/"><p><img src="https://habrastorage.org/webt/_c/m3/gr/_cm3grewmg9yewpcch1nqkl2ho8.png"></p><br><p>  Dieser Artikel konzentriert sich auf die doppelte Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Expression Trees-</a> API - zum Parsen von Ausdr√ºcken und zum Generieren von Code.  Die Analyse von Ausdr√ºcken hilft beim Aufbau von Pr√§sentationsstrukturen (sie sind auch Pr√§sentationsstrukturen der problemorientierten Sprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Internal DSL</a> ), und die Codegenerierung erm√∂glicht es Ihnen, effektiv effektive Funktionen zu erstellen - Befehlss√§tze, die durch Pr√§sentationsstrukturen festgelegt werden. </p><br><p> Ich werde die dynamische Erstellung von <strong>Eigenschaftsiteratoren</strong> demonstrieren <strong>: serialisieren, kopieren, klonen, gleich</strong> .  Am Beispiel der Serialisierung zeige ich Ihnen, wie Sie die Serialisierung (im Vergleich zu Stream-Serialisierern) in der klassischen Situation optimieren k√∂nnen, in der "vorl√§ufiges" Wissen zur Verbesserung der Leistung verwendet wird.  Die Idee ist, dass beim Aufrufen des Streaming-Serializers immer die Funktion "Nicht-Streaming" verloren geht und genau bekannt ist, welche Baumknoten umgangen werden m√ºssen.  Gleichzeitig wird ein solcher Serializer "nicht von Hand", sondern dynamisch, sondern nach vordefinierten Bypass-Regeln erstellt.  <strong>Das vorgeschlagene Inernal DSL l√∂st das Problem einer kompakten Beschreibung der Regeln zum Durchlaufen von Baumstrukturen von Objekten anhand ihrer Eigenschaften / Eigenschaften (und im allgemeinen Fall: Durchlaufen des Berechnungsbaums mit dem Namen von Knoten)</strong> .  Der Serializer-Benchmark ist bescheiden, aber es ist wichtig, dass er dem Ansatz, der auf der Verwendung eines bestimmten internen <strong>DSL-Includes</strong> (einem Dialekt von Include / ThenInclude von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EF Core</a> ) und der Verwendung von internem DSL als Ganzes basiert, die notwendige √úberzeugungskraft verleiht. </p><a name="habracut"></a><br><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Vergleichen Sie: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(){X=<span class="hljs-number"><span class="hljs-number">-1</span></span>,Y=<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var json2 = $"{{\"X\":{pX}, \"Y\":{pY}}}";</span></span></code> </pre> <br><p>  Die zweite Methode ist offensichtlich schneller (die Knoten sind bekannt und ‚Äûin Code eingepfercht‚Äú), w√§hrend die Methode nat√ºrlich komplizierter ist.  Wenn Sie diesen Code jedoch als Funktion erhalten (dynamisch generiert und kompiliert), wird die Komplexit√§t ausgeblendet (selbst was unklar wird, wird ausgeblendet <br>  Wo ist die Reflexion und wo ist die Laufzeit der Codegenerierung? </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(){X=<span class="hljs-number"><span class="hljs-number">-1</span></span>,Y=<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var formatter = JsonManager.ComposeFormatter&lt;Point&gt;(); var json2 = formatter(p);</span></span></code> </pre> <br><p>  Hier ist <code>JsonManager.ComposeFormatter</code> das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eigentliche Werkzeug</a> .  Die Regel, nach der die Strukturumgehung w√§hrend der Serialisierung generiert wird, ist nicht offensichtlich, klingt jedoch so: "Mit den Standardparametern werden f√ºr benutzerdefinierte Werttypen alle Felder der ersten Ebene umgangen."  Wenn Sie es explizit festlegen: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    var formatter2 = JsonManager.ComposeFormatter&lt;Point&gt;( chain=&gt;chain .Include(e=&gt;eX) .Include(e=&gt;eY) // DSL Includes )</span></span></code> </pre> <br><p>  Dies ist die Beschreibung von Metadaten √ºber DSL Includes.  DSL hat die Analyse der Vor- und Nachteile der Beschreibung von Metadaten aufgekl√§rt. Da ich jedoch die Form der Aufzeichnung von Metadaten ignoriere, betone ich, dass C # die M√∂glichkeit bietet, den "idealen Serializer" mithilfe von Ausdrucksb√§umen zu kompilieren und zu kompilieren. </p><br><div class="spoiler">  <b class="spoiler_title">Wie er es macht - viel Code und Anleitung zur Codegenerierung von Expression Trees ...</b> <div class="spoiler_text"><p>  √úbergang vom <code>formatter</code> zum <code>serilizer</code> (bisher ohne Ausdrucksb√§ume): </p><br><pre> <code class="cs hljs"> Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer = ... <span class="hljs-comment"><span class="hljs-comment">// later string formatter(Point p) { var stringBuilder = new StringBuilder(); serializer(stringBuilder, p); return stringBuilder.ToString(); }</span></span></code> </pre> <br><p>  Der <code>serializer</code> ist wiederum wie folgt aufgebaut (wenn er mit statischem Code festgelegt ist): </p><br><pre> <code class="cs hljs">Expression&lt;Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; serializerExpression = SerializeAssociativeArray(sb, p, (sb1, t1) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString) ); Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer = serializerExpression.Compile();</code> </pre> <br><p>  Warum ist es so "funktional", warum k√∂nnen Sie nicht zwei Felder durch ein Semikolon serialisieren?  Kurz gesagt: weil dieser Ausdruck einer Variablen vom Typ <code>Expression&lt;Func&lt;StringBuilder, Box, bool&gt;&gt;</code> zugewiesen werden kann, ein Semikolon jedoch nicht zul√§ssig ist. <br>  Warum konnte ich <code>Func&lt;StringBuilder, Point, bool&gt; serializer = (sb,p)=&gt;SerializeAssociativeArray(sb,p,...</code> nicht direkt schreiben? Es ist m√∂glich, aber ich demonstriere nicht das Erstellen eines Delegaten, sondern einer Assembly (in diesem Fall statischer Code). Ausdrucksbaum, mit einer Kompilierung f√ºr den Delegaten in der Zukunft, in der Praxis wird <code>serializerExpression</code> auf eine v√∂llig andere Weise festgelegt - dynamisch (unten). </p><br><p>  Was jedoch in der L√∂sung selbst wichtig ist: <code>SerializeAssociativeArray</code> akzeptiert ein Array von <code>params Func&lt;..&gt; propertySerializers</code> entsprechend der Anzahl der zu <code>params Func&lt;..&gt; propertySerializers</code> Knoten.  Das Umgehen einiger von ihnen kann durch SerializeValueProperty-Serialisierer von Bl√§ttern (Akzeptieren des <code>SerializeValueToString</code> Formatierers) und andere wiederum durch <code>SerializeAssociativeArray</code> ( <code>SerializeAssociativeArray</code> Zweige) festgelegt werden, und somit wird ein Iterator (Baum) des Durchlaufs erstellt. </p><br><p>  Wenn Point die NextPoint-Eigenschaft enthielt: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> = SerializeAssociativeArray(sb, p, (sb1, t1) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"NextPoint"</span></span>, o =&gt; o.NextPoint, (sb4, t4) =&gt;SerializeAssociativeArray(sb1, p1, (sb1, t1) =&gt; SerializeValueProperty(sb2, t2, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb2, t2, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString) ) ) );</code> </pre> <br><p>  Das Ger√§t der drei Funktionen <code>SerializeAssociativeArray</code> , <code>SerializeValueProperty</code> , <code>SerializeValueToString</code> nicht kompliziert: </p><br><div class="spoiler">  <b class="spoiler_title">Serialisieren ...</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeAssociativeArray&lt;T&gt;(StringBuilder stringBuilder, T t, <span class="hljs-keyword"><span class="hljs-keyword">params</span></span> Func&lt;StringBuilder, T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;[] propertySerializers) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'{'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertySerializer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> propertySerializers) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notEmpty = propertySerializer(stringBuilder, t); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notEmpty) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!@<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">','</span></span>); } }; stringBuilder.Length--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (@<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'}'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeValueProperty&lt;T, TProp&gt;(StringBuilder stringBuilder, T t, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName, Func&lt;T, TProp&gt; getter, Func&lt;StringBuilder, TProp, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TProp : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'"'</span></span>).Append(propertyName).Append(<span class="hljs-string"><span class="hljs-string">'"'</span></span>).Append(<span class="hljs-string"><span class="hljs-string">':'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = getter(t); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notEmpty = serializer(stringBuilder, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!notEmpty) stringBuilder.Length -= (propertyName.Length + <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> notEmpty; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeValueToString&lt;T&gt;(StringBuilder stringBuilder, T t) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stringBuilder.Append(t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> </div></div><br><p>  Viele Details werden hier nicht angegeben (Listenunterst√ºtzung, Referenztyp und nullbar).  Und doch ist es klar, dass ich wirklich <em>json</em> in der Ausgabe bekomme und alles andere noch mehr von den Standardfunktionen <code>SerializeArray</code> , <code>SerializeNullable</code> , <code>SerializeRef</code> . </p><br><p>  Es war ein statischer Ausdrucksbaum, nicht dynamisch, nicht <em>in C # ausgewertet</em> . </p><br><p>  Sie k√∂nnen sehen, wie der Ausdrucksbaum in zwei Schritten dynamisch erstellt wird: </p><br><h4 id="shag-1---decompilerom-posmotret-na-kod-prisvoennyy-expressiont">  Schritt 1 - Der Dekompiler √ºberpr√ºft den durch <code>Expression&lt;T&gt;</code> zugewiesenen Code </h4><br><p><img src="https://habrastorage.org/webt/ox/p3/g2/oxp3g2newr9bhr3oba5bajcrkco.png"></p><br><p>  Dies wird Sie nat√ºrlich beim ersten Mal √ºberraschen.  Nichts ist klar, aber Sie k√∂nnen sehen, wie die ersten vier Zeilen so etwas zusammensetzen: </p><br><pre> <code class="cs hljs">(<span class="hljs-string"><span class="hljs-string">"sb"</span></span>,<span class="hljs-string"><span class="hljs-string">"t"</span></span>) .. SerializeAssociativeArray..</code> </pre> <br><p>  Dann wird die Verbindung mit dem Quellcode erfasst.  Und es sollte klar werden, dass Sie, wenn Sie einen solchen Datensatz beherrschen (indem Sie 'Expression.Const', 'Expression.Parameter', 'Expression.Call', 'Expression.Lambda' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">usw.</a> kombinieren), wirklich dynamisch verkn√ºpfen k√∂nnen - jede Umgehung von Knoten (basierend auf Metadaten).  Dies ist <em>in C # eval</em> . </p><br><h4 id="shag-2----shodit-po-etoy-ssylkehttpsgithubcomdashboardcoderoutinesblobmastertestsconsoleappsclrmdautomationprogramcsl99-l194">  Schritt 2 - folgen Sie <a href="">diesem Link</a> , </h4><br><p>  Der gleiche Dekompiler-Code, aber vom Menschen kompiliert. </p><br><p>  Nur der Autor des Dolmetschers muss sich mit dieser Perlenstickerei befassen.  Alle diese K√ºnste verbleiben in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Serialisierungsbibliothek</a> .  Es ist wichtig zu lernen, dass Sie Bibliotheken bereitstellen k√∂nnen, die dynamisch kompilierte effiziente Funktionen in C # (und .NET Standard) generieren. </p></div></div><br><p>  Ein Streaming-Serializer √ºberholt jedoch eine dynamisch generierte Funktion, wenn Sie die Kompilierung jedes Mal vor der Serialisierung aufrufen (das Kompilieren im <code>ComposeFormatter</code> ist eine kostspielige Operation). Sie k√∂nnen den Link jedoch speichern und wiederverwenden: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Func&lt;Point, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; formatter = JsonManager.ComposeFormatter&lt;Point&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Point p</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var json2 = formatter(p); return json2; }</span></span></code> </pre> <br><p>  Wenn Sie einen Serializer vom anonymen Typ zur Wiederverwendung erstellen und speichern m√ºssen, ben√∂tigen Sie zus√§tzliche Infrastruktur: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Point&gt; list</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// there json formatter will be build only for first call // and assigned to cachedFormatter.Formatter // in all next calls cachedFormatter.Formatter will be used. // since building of formatter is determenistic it is lock free var json3 = list.Select(e=&gt; {X:eX, Sum:e.X+EY}) .ToJson(cachedFormatter, e=&gt;e.Sum); return json3; }</span></span></code> </pre> <br><p>  Danach ber√ºcksichtigen wir zuversichtlich die erste Mikrooptimierung f√ºr uns selbst und akkumulieren, akkumulieren, akkumulieren ... Wer ist der Witz, wer nicht, aber bevor ich zu der Frage √ºbergehe, dass der neue Serializer neu ist, behebe ich den offensichtlichen Vorteil - er wird schneller sein. </p><br><h2 id="chto-vzamen">  Was daf√ºr? </h2><br><p>  Das DSL enth√§lt Interpreter in Serilize (und auf die gleiche Weise, wie es in Iteratoren gleich ist, kopieren, klonen - und das wird auch ungef√§hr sein), erforderte die folgenden Kosten: </p><br><p>  <strong>1</strong> - Kosten der Infrastruktur zum Speichern von Links zu kompiliertem Code. </p><br><p>  Diese Kosten sind im Allgemeinen nicht erforderlich, ebenso wie die Verwendung von Ausdrucksb√§umen bei der Kompilierung. Der Interpreter kann einen Serialisierer f√ºr Reflexe erstellen und ihn sogar so weit lecken, dass er sich der Geschwindigkeit in Bezug auf Stream-Serialisierer (√ºbrigens Kopieren, Klonen und) n√§hert Gleichheit wird weder durch Ausdrucksb√§ume gesammelt noch geleckt, es gibt keine solche Aufgabe, im Gegensatz zum √úberholen von ServiceStack und Json.NET im Rahmen der wohlverstandenen Aufgabe der Optimierung der Serialisierung in json - eine notwendige Voraussetzung f√ºr die Pr√§sentation einer neuen L√∂sung). </p><br><p>  <strong>2</strong> - Sie m√ºssen Abstraktionslecks sowie ein √§hnliches Problem ber√ºcksichtigen: √Ñnderungen in der Semantik im Vergleich zu vorhandenen L√∂sungen. </p><br><p>  Zum Beispiel ben√∂tigen Point und IEnumerable zwei verschiedene Serializer zum Serialisieren. <br></p><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter1 = JsonManager.ComposeFormatter&lt;Point&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter2 = JsonManager.ComposeEnumerableFormatter&lt;Point&gt;(); <span class="hljs-comment"><span class="hljs-comment">// but not // var formatter2 = JsonManager.ComposeEnumerableFormatter&lt;List&lt;Point&gt;&gt;();</span></span></code> </pre> <br><p>  Oder: "Funktioniert die Schlie√üung?".  Es funktioniert, nur der Knoten muss einen Namen (eindeutig) festlegen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> DATEFORMAT= <span class="hljs-string"><span class="hljs-string">"YYYY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter3 = JsonManager.ComposeFormatter&lt;Record&gt;( chain =&gt; chain .Include(i =&gt; i.RecordId) .Include(i =&gt; i.CreatedAt.ToString(DATEFORMAT) , <span class="hljs-string"><span class="hljs-string">"CreatedAt"</span></span>); );</code> </pre> <br><p>  Dieses Verhalten wird <code>ComposeFormatter</code> vom internen Ger√§t des <code>ComposeFormatter</code> Interpreters <code>ComposeFormatter</code> . </p><br><p>  Kosten dieser Art sind unvermeidlich b√∂se.  Dar√ºber hinaus wird festgestellt, dass durch die Erweiterung der Funktionalit√§t und den Umfang des internen DSL auch Abstraktionslecks zunehmen.  Es wird sicherlich den Entwickler von internem DSL unterdr√ºcken, hier m√ºssen Sie sich mit einer philosophischen Stimmung eindecken. </p><br><p>  F√ºr den Benutzer werden Abstraktionslecks durch die Kenntnis der technischen Details von internem DSL ( <em>was ist zu erwarten?</em> ) Und des Funktionsumfangs eines bestimmten DSL und seiner Interpreter ( <em>was im Gegenzug?</em> ) <em>√úberwunden</em> .  Daher die Antwort auf die Frage: "Lohnt es sich, internes DSL zu erstellen und zu verwenden?" Es kann nur eine Geschichte √ºber die Funktionalit√§t eines bestimmten DSL geben - √ºber all seine Details und Annehmlichkeiten und seine m√∂glichen Anwendungen (Dolmetscher), d. H.  eine Geschichte √ºber die √úberwindung von Kosten. </p><br><p>  In diesem Sinne kehre ich zur Effektivit√§t eines bestimmten DSL-Includes zur√ºck. </p><br><p>  Eine signifikant h√∂here Effizienz wird erreicht, wenn das Ziel darin besteht, das Tripel (DTO, Transformation in DTO, Serialisierung von DTO) durch eine lokal detaillierte und generierte Serialisierungsfunktion zu ersetzen.  Am Ende des Dualismus-Funktionsobjekts k√∂nnen Sie "DTO ist eine solche Funktion" sagen und ein Ziel festlegen: lernen, wie eine DTO-Funktion festgelegt wird. </p><br><p>  Die Serialisierung muss konfiguriert sein: </p><br><ol><li>  Bypass-Baum (um die Knoten zu beschreiben, √ºber die die Serialisierung stattfinden wird, um das Problem der kreisf√∂rmigen Verkn√ºpfungen zu l√∂sen), weisen Sie im Fall von Bl√§ttern einen Formatierer (nach Typ) zu. </li><li>  Die Regel f√ºr das Einschlie√üen von Bl√§ttern (falls nicht angegeben) - Eigenschaft gegen Felder?  schreibgesch√ºtzt? </li><li>  Um sowohl einen Zweig (einen Knoten mit Navigation) als auch ein Blatt angeben zu k√∂nnen, muss nicht nur MemberExpression ( <code>e=&gt;e.Name</code> ), sondern im Allgemeinen eine beliebige Funktion (`e =&gt; e.Name.ToUpper ()," MyMemberName ") den Formatierer auf einen bestimmten Wert festlegen Knoten. </li></ol><br><p>  Weitere M√∂glichkeiten zur Erh√∂hung der Flexibilit√§t: </p><br><ol><li>  Serialisieren Sie ein Blatt, das eine JSON-Zeichenfolge "as is" enth√§lt (spezieller Zeichenfolgenformatierer). </li><li>  setze Formatierer auf Gruppen, d.h.  ganze Zweige, in diesem Zweig wie diesem - auf eine andere Weise anders (zum Beispiel hier mit der Zeit und in diesem ohne Zeit). </li></ol><br><p>  √úberall k√∂nnen Konstruktionen wie Bypass-Baum, Zweig, Blatt und all dies mit DSL Includes geschrieben werden. </p><br><h2 id="dsl-includes">  DSL beinhaltet </h2><br><p>  Da jeder mit EF Core vertraut ist, sollte die Bedeutung der folgenden Ausdr√ºcke sofort erfasst werden (dies ist eine Teilmenge von xpath). </p><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// DSL Includes Include&lt;User&gt; include1 = chain=&gt; chain .IncludeAll(e =&gt; e.Groups) .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) // EF Core syntax // https://docs.microsoft.com/en-us/ef/core/querying/related-data var users = context.Users .Include(blog =&gt; blog.Groups) .Include(blog =&gt; blog.Roles) .ThenInclude(blog =&gt; blog.Privileges);</span></span></code> </pre> <br><p>  Hier sind die Knoten "mit Navigation" - "Zweige". <br>  Die Antwort auf die Frage, welche Knoten "Bl√§tter" (Felder / Eigenschaften) in dem so definierten Baum enthalten sind - keine.  Um Bl√§tter einzuschlie√üen, m√ºssen Sie sie entweder explizit auflisten: </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include2 = chain=&gt; chain .Include(e =&gt; e.UserName) <span class="hljs-comment"><span class="hljs-comment">// leaf member .IncludeAll(e =&gt; e.Groups) .ThenInclude(e =&gt; e.GroupName) // leaf member .IncludeAll(e =&gt; e.Roles) .ThenInclude(e =&gt; e.RoleName) // leaf member .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) .ThenInclude(e =&gt; e.PrivilegeName) // leaf member</span></span></code> </pre><br><p>  Oder f√ºgen Sie dynamisch nach der Regel √ºber einen spezialisierten Interpreter hinzu: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Func&lt;ChainNode, MemberInfo&gt; rule = ... var include2 = IncludeExtensions.AppendLeafs(include1, rule);</span></span></code> </pre> <br><p>  Hier ist die Regel eine Regel, die von ChainNode.Type ausgew√§hlt werden kann, d.h.  nach Art des vom Knoten zur√ºckgegebenen Ausdrucks (ChainNode - interne Darstellung von DSL Includes, auf die sp√§ter noch eingegangen wird) Eigenschaften (MemberInfo) f√ºr die Teilnahme an der Serialisierung, z.  Nur eine Eigenschaft oder nur eine Lese- / Schreibeigenschaft oder nur diejenigen, f√ºr die es einen Formatierer gibt, k√∂nnen Sie aus einer Liste von Typen ausw√§hlen, und sogar der Include-Ausdruck selbst kann eine Regel festlegen (wenn er Blattknoten auflistet - d. h. die Form der Baumverkn√ºpfung). . </p><br><p>  Oder ... √ºberlassen Sie es dem Benutzerinterpreter, der entscheidet, was mit den Knoten geschehen soll.  DSL Includes ist nur ein Metadatensatz. Wie dieser Datensatz interpretiert wird, h√§ngt vom Interpreter ab.  Er kann die Metadaten so interpretieren, wie er m√∂chte, bis er sie ignoriert.  Einige Interpreter f√ºhren die Aktion selbst aus, w√§hrend andere eine Funktion erstellen, die bereit ist, sie auszuf√ºhren (√ºber Expression Tree oder sogar Reflection.Emit).  Ein gutes internes DSL ist f√ºr den universellen Gebrauch und die Existenz vieler Dolmetscher konzipiert, von denen jeder seine eigenen Besonderheiten und Abstraktionslecks aufweist. <br>  Code, der internes DSL verwendet, kann sich stark von dem unterscheiden, was er zuvor war. </p><br><h4 id="out-of-the-box">  Out of the Box </h4><br><p>  Integration mit EF Core. <br>  Die laufende Aufgabe besteht darin, "zyklische Links abzubrechen", um nur das zu starten, was im Include-Ausdruck angegeben ist: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetJson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbContext = GetEfCoreContext()) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> json = EfCoreExtensions.ToJsonEf&lt;User&gt;(cachedFormatter1, dbContext, chain=&gt;chain .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges)); } }</code> </pre> <br><p>  <code>ToJsonEf</code> akzeptiert die Navigationssequenz, verwendet sie beim Serialisieren (w√§hlt Bl√§tter nach der Regel "Standard f√ºr EF Core" aus, dh √∂ffentliche Lese- / Schreibeigenschaft), interessiert sich f√ºr das Modell - wobei string / json Feldformatierer verwendet, um sie unver√§ndert einzuf√ºgen Standardm√§√üig (Byte [] pro Zeichenfolge, Datum / Uhrzeit in ISO usw.).  Daher muss er IQuaryable unter sich ausf√ºhren. </p><br><p>  In dem Fall, in dem das Ergebnis transformiert wird, √§ndern sich die Regeln - es ist nicht erforderlich, DSL Includes zu verwenden, um die Navigation anzugeben (wenn die Regel nicht wiederverwendet wird), ein anderer Interpreter wird verwendet und die Konfiguration erfolgt lokal: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetJson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbContext = GetEfCoreContext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> json = dbContext.ParentRecords <span class="hljs-comment"><span class="hljs-comment">// back to EF core includes // but .Include(include1) also possible .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) .Select(e =&gt; new { FieldA: e.FieldA, FieldJson:"[1,2,3]", Role: e.Roles().First() }) .ToJson(cachedFormatter1, chain =&gt; chain.Include(e =&gt; e.Role), LeafRuleManager.DefaultEfCore, config: rules =&gt; rules .AddRule&lt;string[]&gt;(GetStringArrayFormatter) .SubTree( chain =&gt; chain.Include(e =&gt; e.FieldJson), stringAsJsonLiteral: true) // json as is .SubTree( chain =&gt; chain.Include(e =&gt; e.Role), subRules =&gt; subRules .AddRule&lt;DateTime&gt;( dateTimeFormat: "YYYMMDD", floatingPointFormat: "N2" ) ), ), useToString: false, // no default ToString for unknown leaf type (throw exception) dateTimeFormat: "YYMMDD", floatingPointFormat: "N2" } }</span></span></code> </pre> <br><p>  Es ist klar, dass all diese Details, all dies ist ‚Äûstandardm√§√üig‚Äú, nur dann ber√ºcksichtigt werden k√∂nnen, wenn Sie sie wirklich brauchen und / oder wenn dies Ihr eigener Dolmetscher ist.  Auf der anderen Seite kehren wir noch einmal zu den Pluspunkten zur√ºck: DTO wird nicht durch Code verschmiert, wird durch eine bestimmte Funktion spezifiziert, Interpreter sind universell.  Der Code wird kleiner - das ist gut. </p><br><p>  <strong>Es ist zu warnen</strong> : Obwohl es den Anschein hat, dass vorl√§ufiges Wissen in ASP immer verf√ºgbar ist und ein Streaming-Serializer in der Welt des Webs, in der sogar Datenbanken Daten in JSON √ºbertragen, nicht unbedingt erforderlich ist, ist die Verwendung von DSL Includes in ASP MVC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht die einfachste Geschichte</a> .  Wie man funktionale Programmierung mit ASP MVC kombiniert, verdient eine separate Studie. </p><br><p>  In diesem Artikel beschr√§nke ich mich auf die Feinheiten von DSL Includes. Ich werde sowohl neue Funktionen als auch das Durchsickern von Abstraktionen zeigen, um zu zeigen, dass das Problem der Analyse von "Kosten und Akquisitionen" tats√§chlich ersch√∂pfbar ist. </p><br><h2 id="esche-bolshe-dsl-includes">  Mehr DSL beinhaltet </h2><br><pre> <code class="cs hljs">Include&lt;Point&gt; include = chain =&gt; chain.Include(e=&gt;eX).Include(e=&gt;eY);</code> </pre> <br><p>  Dies unterscheidet sich von EF Core Includes, die auf statischen Funktionen basieren, die nicht Variablen zugewiesen und als Parameter √ºbergeben werden k√∂nnen.  DSL Includes selbst entstand aus der Notwendigkeit heraus, "include" in meine Implementierung der Repository-Vorlage zu √ºbergeben, ohne die Typinformationen zu verschlechtern, die bei der Standardisierung in Zeichenfolgen aufgetreten w√§ren. </p><br><p>  Der dramatischste Unterschied besteht immer noch in der Ernennung.  EF Core Includes - Einbeziehung von Navigationseigenschaften (Knoten von Zweigen), DSL Includes - Aufzeichnung der Durchquerung eines Berechnungsbaums, wobei dem Ergebnis jeder Berechnung ein Name (Pfad) zugewiesen wird. </p><br><p>  Die interne Darstellung von EF Core Includes ist eine Liste von Zeichenfolgen, die von MemberExpression.Member empfangen wurden (Der durch <code>e=&gt;User.Name</code> angegebene <code>e=&gt;User.Name</code> kann nur [MemberExpression] sein ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://msdn.microsoft.com/en-us/library/system.linq.expressions). Mitgliedsausdruck (v = vs. 110) .aspx</a> und in internen Ansichten wird nur die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Namenszeile</a> gespeichert). </p><br><p>  In DSL Includes besteht die interne Darstellung aus den Klassen <a href="">ChainNode und ChainMemberNode</a> , <a href="">die den gesamten</a> Ausdruck (z. B. <code>e=&gt;User.Name</code> ) <code>e=&gt;User.Name</code> , der so wie er ist in den Ausdrucksbaum integriert ist.  Genau aus diesem Grund unterst√ºtzt DSL Includes sowohl Felder als auch Benutzerwerttypen und Funktionsaufrufe: </p><br><p>  Ausf√ºhrung von Funktionen: </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .Include(i =&gt; i.Email.ToUpper(),<span class="hljs-string"><span class="hljs-string">"EAddress"</span></span>);</code> </pre> <br><p>  Was damit zu tun ist, h√§ngt vom Dolmetscher ab.  CreateFormatter- gibt {"UserName": "John", "EAddress": "JOHN@MAIL.COM"} zur√ºck </p><br><p>  Die Ausf√ºhrung kann auch n√ºtzlich sein, um das Durchlaufen von nullbaren Strukturen festzulegen. </p><br><pre> <code class="cs hljs">Include&lt;StrangePointF&gt; include = chain =&gt; chain .Include(e =&gt; e.NextPoint) <span class="hljs-comment"><span class="hljs-comment">// NextPoint is nullable struct .ThenIncluding(e =&gt; e.Value.X) .ThenInclude(e =&gt; e.Value.Y); // but not this way (abstraction leak) // Include&lt;StrangePointF&gt; include // = chain =&gt; chain // now this can throw an exception // .Include(e =&gt; e.NextPoint.Value) // .ThenIncluding(e =&gt; eX) // .ThenInclude(e =&gt; eY);</span></span></code> </pre> <br><p>  DSL Includes enth√§lt auch einen kurzen Eintrag f√ºr die mehrstufige ThenIncluding-Problemumgehung. </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .IncludeAll(i =&gt; i.Groups) <span class="hljs-comment"><span class="hljs-comment">// ING-form - doesn't change current node .ThenIncluding(e =&gt; e.GroupName) // leaf .ThenIncluding(e =&gt; e.GroupDescription) // leaf .ThenInclude(e =&gt; e.AdGroup); // leaf</span></span></code> </pre> <br><p>  vergleiche mit </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.GroupName) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.GroupDescription) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.AdGroup);</code> </pre> <br><p>  Und auch hier gibt es ein Abstraktionsleck.  Wenn ich die Navigation in dieser Form notiert habe, sollte ich wissen, wie ein Interpreter funktioniert, der QuaryableExtensions aufruft.  Und er √ºbersetzt die Aufrufe in Include und ThenInclude in Include "string".  Was kann wichtig sein (Sie m√ºssen bedenken). </p><br><p>  <strong>Algebra Include-Ausdr√ºcke</strong> . </p><br><p>  Einschlussausdr√ºcke k√∂nnen sein: </p><br><div class="spoiler">  <b class="spoiler_title">Vergleichen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b1 = InlcudeExtensions.IsEqualTo(include1, include2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b2 = InlcudeExtensions.IsSubTreeOf(include1, include2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b3 = InlcudeExtensions.IsSuperTreeOf(include1, include2);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Klon</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> include2 = InlcudeExtensions.Clone(include1);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Zusammenf√ºhren</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> include3 = InlcudeExtensions.Merge(include1, include2);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">In XPath-Listen konvertieren - Alle Pfade zu Bl√§ttern</b> <div class="spoiler_text"><pre> <code class="cs hljs">IReadOnlyCollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; paths1 = InlcudeExtensions.ListLeafXPaths(include); <span class="hljs-comment"><span class="hljs-comment">// as xpaths IReadOnlyCollection&lt;string[]&gt; paths2 = InlcudeExtensions.ListLeafKeyPaths(include); // as string[]</span></span></code> </pre> </div></div><br><p>  usw. </p><br><p>  Die gute Nachricht ist: Es gibt keine Abstraktionslecks, hier wird die Ebene der reinen Abstraktion erreicht.  Es gibt Metadaten und arbeiten mit Metadaten. </p><br><h2 id="dialektika">  Dialektik </h2><br><p>  Mit DSL Includes k√∂nnen Sie eine neue Abstraktionsebene erreichen. Zum Zeitpunkt des Erreichens besteht jedoch die Notwendigkeit, zur n√§chsten Ebene zu gelangen: Include-Ausdr√ºcke selbst generieren. </p><br><p>  In diesem Fall ist es nicht erforderlich, DSL als flie√üende Kette zu generieren. Sie m√ºssen lediglich interne Repr√§sentationsstrukturen erstellen. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChainNode(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Point)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> child = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChainPropertyNode( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), expression: <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Point).CreatePropertyLambda(<span class="hljs-string"><span class="hljs-string">"X"</span></span>), memberName:<span class="hljs-string"><span class="hljs-string">"X"</span></span>, isEnumerable:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, parent:root ); root.Children.Add(<span class="hljs-string"><span class="hljs-string">"X"</span></span>, child); <span class="hljs-comment"><span class="hljs-comment">// or there is number of extension methods eg: var child = root.AddChild("X"); Include&lt;Point&gt; include = ChainNodeExtensions.ComposeInclude&lt;Point&gt;(root);</span></span></code> </pre> <br><p>  Sie k√∂nnen Pr√§sentationsstrukturen auch an Dolmetscher √ºbergeben.  Warum enth√§lt die flie√üende DSL-Aufzeichnung dann √ºberhaupt?  Dies ist eine rein spekulative Frage, deren Antwort darin besteht, dass es in der Praxis nur m√∂glich ist, die interne Repr√§sentation (und auch die Entwicklung) zusammen mit der Entwicklung von DSL zu entwickeln (d. H. Eine kurze Ausdrucksaufzeichnung, die f√ºr statischen Code geeignet ist).  Dies wird noch einmal n√§her an der Schlussfolgerung gesagt. </p><br><h2 id="copy-clone-equals">  Kopieren, Klonen, Gleich </h2><br><p>  All dies gilt f√ºr Interpreter-Ausdrucksinterpreter, die <strong>Copy</strong> , <strong>Clone</strong> und Iteratoren implementieren. </p><br><div class="spoiler">  <b class="spoiler_title">Gleich</b> <div class="spoiler_text"><p>  Vergleich nur auf Bl√§ttern aus dem Include-Ausdruck. <br>  Verstecktes semantisches Problem: Auswerten oder nicht in der Liste sortieren </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.Include(e=&gt;e.UserId).IncludeAll(e=&gt;e.Groups).ThenInclude(e=&gt;e.GroupId) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b1 = ObjectExtensions.Equals(user1, user2, include); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b2 = ObjectExtensions.EqualsAll(userList1, userList2, include);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Klon</b> <div class="spoiler_text"><p>  √úbergeben Sie Ausdrucksknoten.  Eigenschaften, die der Regel entsprechen, werden kopiert. </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.Include(e=&gt;e.UserId).IncludeAll(e=&gt;e.Groups).ThenInclude(e=&gt;e.GroupId) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newUser = ObjectExtensions.Clone(user1, include, leafRule1); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newUserList = ObjectExtensions.CloneAll(userList1, leafRule1);</code> </pre> <br><p>  M√∂glicherweise gibt es einen Dolmetscher, der Blatt aus Includes ausw√§hlt.  Warum wird es gemacht - durch eine separate Regel?  Was war √§hnlich der Semantik von ObjectExtensions.Copy </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Kopieren</b> <div class="spoiler_text"><p>  Durch Knoten gehen - ein Ausdruckszweig und die Identifizierung durch Blattknoten.  Eigenschaften, die der Regel entsprechen, werden kopiert (√§hnlich wie beim Klonen). </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.IncludeAll(e=&gt;e.Groups); ObjectExtensions.Copy(user1, user2, include, supportedLeafsRule); ObjectExtensions.CopyAll(userList1, userList2, include, supportedLeafsRule);</code> </pre> <br><p>  M√∂glicherweise gibt es einen Interpreter, der Blatt aus Includes ausw√§hlt.  Warum wird es gemacht - durch eine separate Regel?      ObjectExtensions.Copy (   ‚Äî  include   ,  supportedLeafsRule ‚Äî   ). </p></div></div><br><p>  copy / clone   : </p><br><ol><li>   readonly ,     Tuple&lt;,&gt;  Anonymous Type.    ,     . </li><li>   (. IEnumerable   ) ‚Äî  public   . </li><li>  expression  include-,       ‚Äî  . </li><li> "  "    . </li></ol><br><p>  DSL                   , ..               . ,     <code>Tuple&lt;,&gt;</code> , ..  c readonly ,   <code>ValueTuple&lt;,&gt;</code> c writabale      (      ). </p><br><p>  ,         (    Expression Trees) Includes  ‚Äî  .     Include DSL  . </p><br><p>    Detach, FindDifferences  .. </p><br><h2 id="pochemu-run-time-a-ne-cs-sgenerirovannyy-do-nachala-kompilyacii">  run-time,   .cs    ? </h2><br><p>    .cs  ,   ,   <em>run-time</em>   : </p><br><ol><li>       ( ,  , source control). </li><li>     , ,  ,   ‚Äî     . </li><li>         . </li><li>   "  ".  dev time   ,     : ""      ""   ,  ""    , ,  ""   . </li></ol><br><p>   Roslyn',          .    Typescript  (  DTO  , ..   ) ‚Äî   DSL Includes  Roslyn' ( ) ‚Äî      typescript ( ).  " "    " "  .cs (   Expression Trees). </p><br><p> :   run time ‚Äî   ,  .             (        Expression Trees). </p><br><h2 id="problemy-s-effektivnostyu-skompilirovannyh-funkciy-expression-trees">      Expression Trees </h2><br><p>   Internal DSL   Expression Tree    : </p><br><ol><li><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>LambdaExpression.Compile</code></a>    <em>Lambda</em> .     ,  .    ,   "" expression tree,   CallExpression    ‚Äî  LambdaExpression,   (.  LambdaExpression)    ConstantExpression.    ,  " /" ‚Äî      ,    Expression Trees. </p><br></li><li><p>       <em>ssmbly</em> ,     ( 10    )    ( assembly  ,    ‚Äî  ). , ,  ,      ‚Äî  . </p><br></li></ol><br><p>     ,        (  ),     ,       .    :       .   ‚Äî  ‚Äî   .cs     . </p><br><h2 id="benchmark-serializacii">   </h2><br><p>  ‚Äî     600   15   .  JSON.NET, ServiceStack    reflection' GetProperties(). </p><br><p> dslComposeFormatter ‚Äî ComposeFormatter   ,   <a href=""></a> . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BenchmarkDotNet</a> =v0.10.14, OS=Windows 10.0.17134 <br> Intel Core i5-2500K CPU 3.30GHz (Sandy Bridge), 1 CPU, 4 logical and 4 physical cores <br> .NET Core SDK=2.1.300 </p><br><table><thead><tr><th> Method </th><th> Mean </th><th>  Fehler </th><th> StdDev </th><th> Min </th><th> Max </th><th> Median </th><th> Allocated </th></tr></thead><tbody><tr><td> dslComposeFormatter </td><td> 2.208 ms </td><td> 0.0093 ms </td><td> 0.0078 ms </td><td> 2.193 ms </td><td> 2.220 ms </td><td> 2.211 ms </td><td> 849.47 KB </td></tr><tr><td> JsonNet_Default </td><td> 2.902 ms </td><td> 0.0160 ms </td><td> 0.0150 ms </td><td> 2.883 ms </td><td> 2.934 ms </td><td> 2.899 ms </td><td> 658.63 KB </td></tr><tr><td> JsonNet_NullIgnore </td><td> 2.944 ms </td><td> 0.0089 ms </td><td> 0.0079 ms </td><td> 2.932 ms </td><td> 2.960 ms </td><td> 2.942 ms </td><td> 564.97 KB </td></tr><tr><td> JsonNet_DateFormatFF </td><td> 3.480 ms </td><td> 0.0121 ms </td><td> 0.0113 ms </td><td> 3.458 ms </td><td> 3.497 ms </td><td> 3.479 ms </td><td> 757.41 KB </td></tr><tr><td> JsonNet_DateFormatSS </td><td> 3.880 ms </td><td> 0.0139 ms </td><td> 0.0130 ms </td><td> 3.854 ms </td><td> 3.899 ms </td><td> 3.877 ms </td><td> 785.53 KB </td></tr><tr><td> ServiceStack_SerializeToString </td><td> 4.225 ms </td><td> 0.0120 ms </td><td> 0.0106 ms </td><td> 4.201 ms </td><td> 4.243 ms </td><td> 4.226 ms </td><td> 805.13 KB </td></tr><tr><td> fake_expressionManuallyConstruted </td><td> 54.396 ms </td><td> 0.1758 ms </td><td> 0.1644 ms </td><td> 54.104 ms </td><td> 54.629 ms </td><td> 54.383 ms </td><td> 7401.58 KB </td></tr></tbody></table><br><p> fake_expressionManuallyConstruted ‚Äî expression      ( ). </p><br><h2 id="formalizaciya">  </h2><br><p>   DSL   : <strong>   DSL      ;    Internal DSL   run-time</strong> . </p><br><p> Expression Tree         <em></em>   .NET Standard . </p><br><p>     Expression Trees  <em> </em>     Internal DSL    Fluent API.      #      . </p><br><p>         fluent   (   Expression Trees),      Internal DSL  #     fluent,      ""   Expression Trees. </p><br><p> <strong>Expression Trees</strong>  <strong>DSL Includes</strong>      (  ,      ),      /  run-time ‚Äî  (run-time ). </p><br><p>  <strong>Internal DSL</strong>       :   -  <strong>serialize</strong> , <strong>copy</strong> , <strong>clone</strong> , <strong>equals</strong>        <strong>       ""</strong> .   ,      " ",      .    :  includes    (   ) ,       (       ,  ). </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>   DSL Includes    DTO           ‚Äî   ( json).        ,    ,    ,   " ",        .   =   . </p><br><p>       Internal DSL       ,   DSL,      Internal DSL (    Expression)         (     Expression Tree). </p><br><p>  DSL Includes  json  ComposeFormatter    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DashboardCodes.Routines</a>   nuget  GitHub. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419759/">https://habr.com/ru/post/de419759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419735/index.html">Untersuchen des I / Q-Signals mit SDR mithilfe von Adobe Audition</a></li>
<li><a href="../de419743/index.html">Was ist falsch an popul√§ren Artikeln, die besagen, dass foo schneller als bar ist?</a></li>
<li><a href="../de419745/index.html">Klassisches KI-Genre: ML sucht sich in der Poesie</a></li>
<li><a href="../de419747/index.html">DJI Ronin S - Erster Start und Hauptmerkmale</a></li>
<li><a href="../de419757/index.html">√úbersetzung von Andrew Un's Buch, Leidenschaft f√ºr maschinelles Lernen, Kapitel 1 - 14</a></li>
<li><a href="../de419761/index.html">Erstellen Sie ein 2D-Spiel in Python mit der Arcade-Bibliothek</a></li>
<li><a href="../de419763/index.html">Beispiele f√ºr die Berechnung des "Verf√ºgbarkeitsfaktors" f√ºr Netzwerkger√§te</a></li>
<li><a href="../de419765/index.html">Der Kurs "Web-Programmiersprachen" (basierend auf Ruby) von MSTU. N. E. Bauman auf dem Technostream-Kanal</a></li>
<li><a href="../de419767/index.html">Der Wikipedia-Ersteller beantwortet Fragen: Programmieren, Schlafen, B√ºcher, Tipps f√ºrs Leben</a></li>
<li><a href="../de419769/index.html">WireGuard wird zum Linux-Kernel "kommen" - warum?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>