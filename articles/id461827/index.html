<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›ƒ ğŸœï¸ ğŸ‘©â€ğŸ‘©â€ğŸ‘§ Pengembangan Aplikasi PHP / Go Hibrid Menggunakan RoadRunner ğŸ¤´ğŸ½ ğŸ¦„ ğŸ§ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aplikasi PHP klasik adalah single-threaded, pemuatan yang berat (kecuali tentu saja Anda menulis di mikroframe) dan kematian proses yang tak terhindar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan Aplikasi PHP / Go Hibrid Menggunakan RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461827/"> Aplikasi PHP klasik adalah single-threaded, pemuatan yang berat (kecuali tentu saja Anda menulis di mikroframe) dan kematian proses yang tak terhindarkan setelah setiap permintaan ... Aplikasi semacam itu berat dan lambat, tetapi kami dapat memberikannya kehidupan kedua melalui hibridisasi.  Untuk mempercepat - menjelekkan dan mengoptimalkan kebocoran memori untuk mencapai kinerja yang lebih baik - kami akan memperkenalkan server aplikasi PHP Golang RoadRunner kami sendiri untuk menambah fleksibilitas - kami menyederhanakan kode PHP, memperluas tumpukan dan berbagi tanggung jawab antara server dan aplikasi.  Intinya, kita akan membuat aplikasi kita berfungsi seolah-olah kita sedang menulisnya di Jawa atau bahasa lain. <br><br>  Berkat hibridisasi, aplikasi yang sebelumnya lambat berhenti menderita dari 502 kesalahan di bawah beban, waktu respons rata-rata untuk permintaan menurun, produktivitas meningkat, dan penyebaran dan perakitan menjadi lebih mudah karena penyatuan aplikasi dan menyingkirkan ikatan yang tidak perlu dalam bentuk nginx + php-fpm. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RUm94xCaXMo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Anton Titov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Lachezis</a> ) adalah CTO dan salah satu pendiri SpiralScout LLC dengan 12 tahun pengalaman pengembangan komersial aktif di PHP.  Selama beberapa tahun terakhir, ia telah secara aktif menerapkan Golang pada tumpukan pengembangan perusahaan.  Anton berbicara tentang satu contoh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHP Russia 2019</a> . <br><a name="habracut"></a><br><h2>  Siklus Hidup Aplikasi PHP </h2><br>  Secara skematis, perangkat aplikasi abstrak dengan kerangka kerja tertentu terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/mm/va/0d/mmva0djqxjc5l733ikzi738ydry.jpeg"><br><br>  Ketika kami mengirim permintaan ke suatu proses, itu terjadi: <br><br><ul><li>  inisialisasi proyek; </li><li>  memuat pustaka, kerangka kerja, dan ORM yang dibagikan; </li><li>  memuat perpustakaan yang diperlukan untuk proyek tertentu; </li><li>  perutean; </li><li>  permintaan routing ke pengontrol tertentu; </li><li>  generasi respons. </li></ul><br>  Ini adalah prinsip pengoperasian <strong>aplikasi single-threaded</strong> klasik dengan titik masuk tunggal, yang setelah setiap eksekusi benar-benar hancur atau menghapus statusnya.  Semua kode diturunkan dari memori, pekerja dibersihkan atau hanya mengatur ulang statusnya. <br><br><h3>  Memuat malas </h3><br>  Cara standar dan mudah untuk mempercepatnya adalah penerapan <strong>sistem pemuatan malas</strong> atau perpustakaan pemuatan sesuai permintaan. <br><br><img src="https://habrastorage.org/webt/vj/eb/gp/vjebgpv7_a4fuvu64x4g8eqmbke.jpeg"><br><br><blockquote>  Dengan memuat Malas, kami hanya meminta kode yang diperlukan. </blockquote><br>  Saat mengakses controller tertentu, hanya perpustakaan yang diperlukan yang akan dimuat ke dalam memori, diproses, dan kemudian dibongkar.  Ini memungkinkan Anda untuk <strong>mengurangi waktu respons rata-rata proyek</strong> dan sangat memudahkan proses bekerja di server.  Dalam semua kerangka kerja yang kami gunakan saat ini, prinsip lazy loading diimplementasikan. <br><br><h3>  Cache perhitungan sering </h3><br>  Metode ini lebih rumit dan aktif digunakan, misalnya, dalam kerangka kerja Symfony, mesin templat, skema ORM, dan perutean.  Ini bukan caching seperti memcached atau Redis untuk data pengguna.  Sistem ini <strong>menghangatkan bagian kode terlebih dahulu</strong> .  Pada permintaan pertama, sistem menghasilkan kode atau file cache, dan pada permintaan berikutnya, perhitungan ini, yang diperlukan, misalnya, untuk mengkompilasi template, tidak akan lagi dilakukan. <br><br><img src="https://habrastorage.org/webt/nb/44/f6/nb44f6isfvs6vouultxridabeps.jpeg"><br><br>  Caching secara signifikan <strong>mempercepat aplikasi</strong> , tetapi pada saat yang sama <strong>mempersulitnya</strong> .  Misalnya, ada masalah dengan membatalkan cache dan memperbarui aplikasi.  Jangan bingung cache pengguna dengan cache aplikasi - dalam satu, data berubah dari waktu ke waktu, yang lain hanya ketika kode diperbarui. <br><br><h3>  Meminta pemrosesan </h3><br>  Ketika permintaan diterima dari server PHP-FPM eksternal, titik masuk permintaan dan inisialisasi akan cocok. <br><br><blockquote>  Ternyata permintaan klien adalah keadaan proses kami. </blockquote><br>  Satu-satunya cara untuk mengubah keadaan ini adalah dengan sepenuhnya menghancurkan pekerja dan memulai kembali dengan permintaan baru. <br><br><img src="https://habrastorage.org/webt/jc/cr/rb/jccrrb-szkhb6_nfn2zthotuctk.jpeg"><br><br>  Ini adalah model klasik single-threaded dengan kelebihannya. <br><br><ul><li>  Semua pekerja di akhir permintaan mati. </li><li>  Kebocoran memori, kondisi balapan, kebuntuan tidak melekat dalam PHP.  Anda tidak bisa khawatir tentang itu. </li><li>  Kode sederhana: kita menulis, memproses permintaan, mati, dan melanjutkan. </li></ul><br>  Di sisi lain, untuk setiap permintaan, kami memuat kerangka sepenuhnya, semua pustaka, melakukan beberapa perhitungan, mengkompilasi ulang templat.  Dengan setiap permintaan dalam lingkaran kami menghasilkan banyak manipulasi dan pekerjaan yang tidak perlu. <br><br><h3>  Cara kerjanya di server </h3><br>  Kemungkinan besar, sekelompok nginx dan PHP akan berfungsi.  Nginx akan berfungsi sebagai proksi terbalik: memberikan pengguna bagian dari statika, dan mendelegasikan sebagian dari permintaan kepada manajer proses PHP, PHP-FPM di bawah ini.  Sudah manajer mengangkat pekerja terpisah untuk permintaan dan memprosesnya.  Setelah itu, pekerja dihancurkan atau dibersihkan.  Selanjutnya, seorang pekerja baru diciptakan untuk permintaan berikutnya. <br><br><img src="https://habrastorage.org/webt/8f/lc/fp/8flcfpz6zxemgxlas6avx5aguqa.jpeg"><br><br>  Model seperti itu bekerja dengan stabil - aplikasi ini hampir tidak mungkin untuk dimatikan.  Tetapi di bawah beban berat, jumlah pekerjaan untuk menginisialisasi dan menghancurkan pekerja mempengaruhi kinerja sistem, karena bahkan untuk permintaan GET yang sederhana, kita sering harus menarik banyak dependensi dan meningkatkan kembali koneksi basis data. <br><br><h2>  Mempercepat aplikasi </h2><br>  Bagaimana cara mempercepat aplikasi klasik setelah memperkenalkan cache dan pemuatan Malas?  Opsi apa lagi yang ada? <br><br>  <strong>Beralih ke bahasa itu sendiri</strong> . <br><br><ul><li>  <strong>Gunakan OPCache.</strong>  Saya pikir tidak ada yang menjalankan PHP pada produksi tanpa OPCache diaktifkan? </li><li>  Tunggu <strong>RFC: Preloading</strong> .  Ini memungkinkan Anda untuk melakukan preload serangkaian file ke dalam mesin virtual. </li><li>  <strong>JIT</strong> - secara serius mempercepat aplikasi pada tugas yang terikat CPU.  Sayangnya, dengan tugas-tugas yang terkait dengan database, itu tidak akan banyak membantu. </li></ul><br>  <strong>Gunakan alternatif</strong> .  Misalnya, mesin virtual HHVM dari Facebook.  Ini mengeksekusi kode dalam lingkungan yang lebih optimal.  Sayangnya, HHVM tidak sepenuhnya kompatibel dengan sintaks PHP.  Sebagai alternatif, kompiler kPHP dari VK atau PeachPie, yang sepenuhnya mengubah kode menjadi .NET C #, adalah sebuah alternatif. <br><br>  <strong>Sepenuhnya menulis ulang ke bahasa lain.</strong>  Ini adalah opsi radikal - singkirkan sepenuhnya pemuatan kode di antara permintaan. <br><br>  Anda dapat sepenuhnya <b>menyimpan status aplikasi dalam memori</b> , secara aktif menggunakan memori ini untuk bekerja, dan melupakan konsep pekerja yang sekarat dan sepenuhnya menghapus aplikasi di antara permintaan. <br><br>  Untuk mencapai hal ini, kami memindahkan titik masuk, yang digunakan bersama dengan titik inisialisasi, jauh ke dalam aplikasi. <br><br><h3>  Mentransfer titik masuk - demonisasi </h3><br>  Ini membuat loop tak terbatas dalam aplikasi: permintaan masuk - jalankan melalui kerangka kerja - menghasilkan respons kepada pengguna.  Ini adalah penghematan serius - semua bootstrap, semua inisialisasi kerangka kerja dilakukan hanya sekali, dan kemudian beberapa permintaan diproses oleh aplikasi. <br><br><img src="https://habrastorage.org/webt/ce/7k/3l/ce7k3lov0kzcyxc3zyjq008taiy.jpeg"><br><br><h3>  Kami mengadaptasi aplikasi </h3><br>  Menariknya, kita dapat fokus hanya pada pengoptimalan bagian aplikasi yang akan berjalan <strong>di runtime</strong> : controllers, business logic.  Dalam hal ini, Anda dapat meninggalkan model pemuatan Malas.  Kami akan mengambil bagian dari proyek bootstrap ke awal - pada saat inisialisasi.  Perhitungan awal: perutean, templat, pengaturan, skema ORM akan meningkatkan inisialisasi, tetapi di masa depan mereka akan menghemat waktu pemrosesan untuk satu permintaan spesifik. <br><br><img src="https://habrastorage.org/webt/fz/kj/ft/fzkjftdkc41niwqyrmml-ijjkwy.jpeg"><br><br>  Saya tidak merekomendasikan kompilasi template saat mengunduh pekerja, tetapi mengunduh, misalnya, semua konfigurasi berguna. <br><br><h3>  Bandingkan Model </h3><br>  Bandingkan model iblis (kiri) dan klasik. <br><br><img src="https://habrastorage.org/webt/zo/en/6r/zoen6rl8zyj6tpn7bghp_ozv61m.jpeg"><br><br>  Model yang di-demonized sejak saat proses dibuat hingga saat respons dikembalikan ke pengguna membutuhkan waktu lebih lama.  Aplikasi klasik dioptimalkan untuk pembuatan, pemrosesan, dan penghancuran yang cepat. <br><br>  Namun, semua permintaan berikutnya setelah melakukan pemanasan kode jauh lebih cepat.  Kerangka kerja, aplikasi, wadah sudah ada dalam memori dan siap menerima permintaan dan merespons dengan cepat. <br><br><h3>  Masalah model berumur panjang </h3><br>  Terlepas dari kelebihannya, model ini memiliki sejumlah keterbatasan. <br><br>  <strong>Memori bocor.</strong>  Aplikasi ini terletak di memori untuk waktu yang sangat lama, dan jika Anda menggunakan "kurva" perpustakaan, dependensi yang salah atau keadaan global - memori akan mulai bocor.  Pada titik tertentu, kesalahan fatal akan muncul yang akan merusak permintaan pengguna. <br><br>  Masalahnya diselesaikan dengan dua cara. <br><br><ul><li>  Tulis kode yang akurat, gunakan perpustakaan yang terbukti. </li><li>  Secara aktif memonitor pekerja.  Jika Anda mencurigai bahwa memori bocor di dalam proses, secara proaktif ubahlah ke analog dengan batas bawah, yaitu, hanya ke salinan baru yang belum berhasil mengakumulasi memori yang tidak bersih. </li></ul><br>  <strong>Kebocoran data</strong> .  Misalnya, jika selama permintaan masuk kami menyimpan pengguna sistem saat ini dalam beberapa variabel global dan lupa untuk mengatur ulang variabel ini setelah permintaan, maka ada kemungkinan bahwa pengguna sistem berikutnya secara tidak sengaja akan mendapatkan akses ke data yang seharusnya tidak ia lihat. <br><br>  Masalahnya diselesaikan pada tingkat arsitektur aplikasi. <br><br><ul><li>  Jangan menyimpan pengguna aktif dalam konteks global.  Semua data yang khusus untuk konteks permintaan dibuang dan dihapus sebelum permintaan berikutnya. </li><li>  Tangani data sesi dengan cermat.  Sesi dalam PHP - dengan pendekatan klasik, ini adalah objek global.  Bungkus dengan benar sehingga pada permintaan berikutnya diatur ulang. </li></ul><br>  <strong>Manajemen sumber daya</strong> . <br><br><ul><li>  Pantau koneksi ke basis data.  Jika aplikasi hang dalam memori selama satu atau dua bulan, maka koneksi terbuka kemungkinan besar akan ditutup dalam waktu ini: database akan diinstal ulang, reboot, atau firewall akan mengatur ulang koneksi.  Pada tingkat kode, pertimbangkan untuk menyambung kembali, atau setelah setiap permintaan, setel ulang koneksi dan naikkan kembali pada permintaan berikutnya. </li><li>  Hindari kunci file berumur panjang.  Jika pekerja Anda menulis beberapa informasi ke file, tidak ada masalah.  Tetapi jika file ini terbuka dan memiliki kunci di dalamnya, maka tidak ada proses lain di sistem Anda yang akan memiliki akses ke sana sampai kunci dilepaskan. </li></ul><br><br><h2>  Jelajahi model yang berumur panjang </h2><br>  Pertimbangkan model pekerja yang berumur panjang - menjelekkan aplikasi - dan mencari cara untuk mengimplementasikannya. <br><br><h3>  Pendekatan non-blocking </h3><br>  Kami menggunakan PHP asinkron - kami memuat aplikasi satu kali ke dalam memori dan memproses permintaan HTTP yang masuk di dalam aplikasi.  Sekarang <strong>aplikasi dan server adalah satu proses</strong> .  Ketika permintaan datang, kami membuat coroutine terpisah atau dalam lingkaran acara kami memberikan janji, memprosesnya dan memberikannya kepada pengguna. <br><br><img src="https://habrastorage.org/webt/v6/js/od/v6jsodvtlxjfy1udzwvl0wa2njk.jpeg"><br><br>  Keuntungan yang tidak dapat disangkal dari pendekatan ini adalah kinerja maksimum.  Dimungkinkan juga untuk menggunakan alat yang menarik, misalnya, <strong>mengkonfigurasi WebSocket langsung pada aplikasi Anda</strong> . <br><br>  Namun, pendekatan ini secara signifikan <strong>meningkatkan kompleksitas pembangunan</strong> .  Penting untuk menginstal ELDO, ingatlah bahwa tidak semua driver basis data akan didukung, dan pustaka PDO dikecualikan. <br><br>  Untuk memecahkan masalah dalam hal demonisasi dengan pendekatan non-blocking, Anda dapat menggunakan alat yang terkenal: <strong>ReactPHP</strong> , <strong>amphp</strong> dan <strong>Swoole</strong> - pengembangan yang menarik dalam bentuk ekstensi-C.  Alat-alat ini bekerja dengan cepat, mereka memiliki komunitas yang bagus dan dokumentasi yang baik. <br><br><h3>  Pendekatan pemblokiran </h3><br>  Kami tidak memunculkan coroutine di dalam aplikasi, tetapi melakukannya dari luar. <br><br><img src="https://habrastorage.org/webt/ad/ul/eq/adulequ1msa3sb6ae6saah3bu-c.jpeg"><br><br>  Kami hanya <strong>mengambil beberapa proses aplikasi</strong> , seperti yang dilakukan oleh PHP-FPM.  Alih-alih mengirimkan permintaan ini dalam bentuk kondisi proses, kami mengirimkannya dari luar dalam bentuk protokol atau pesan. <br><br>  Kami menulis <strong>kode single-threaded yang</strong> sama yang kami tahu, kami menggunakan semua perpustakaan yang sama dan PDO yang sama.  Semua kerja keras bekerja dengan soket, HTTP, dan alat-alat lain dilakukan di <strong>luar aplikasi PHP</strong> . <br><br>  Dari minus: kita harus <strong>memantau memori</strong> dan ingat bahwa <strong>komunikasi antara dua proses yang berbeda tidak gratis</strong> , tetapi kita perlu mentransfer data.  Ini akan membuat sedikit overhead. <br><br>  Untuk mengatasi masalah tersebut, sudah ada alat <strong>PHP-RM</strong> yang ditulis dalam PHP.  Di perpustakaan ReactPHP, ia memiliki <strong>integrasi dengan beberapa kerangka kerja</strong> .  Namun, PHP-PM sangat <strong>lambat, itu kebocoran memori di tingkat server</strong> dan di bawah beban itu tidak menunjukkan pertumbuhan sebanyak PHP-FRM. <br><br><h2>  Kami menulis server aplikasi kami </h2><br>  Kami menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">server aplikasi kami</a> , yang mirip dengan PHP-RM, tetapi ada lebih banyak fungsi.  Apa yang kita inginkan dari server? <br><br>  <strong>Gabungkan dengan kerangka kerja yang ada.</strong>  Kami ingin memiliki integrasi yang fleksibel dengan hampir semua kerangka kerja di pasar.  Saya tidak merasa ingin menulis alat yang hanya berfungsi dalam kasus tertentu. <br><br>  <strong>Berbagai proses untuk server dan aplikasi</strong> .  Kemungkinan reboot panas, sehingga ketika berkembang secara lokal, tekan F5 dan lihat kode baru yang diperbarui, serta dapat mengembangkannya secara individual. <br><br>  <strong>Kecepatan dan stabilitas tinggi</strong> .  Namun, kami sedang menulis server HTTP. <br><br>  <strong>Mudah diperpanjang</strong> .  Kami ingin menggunakan server tidak hanya sebagai HTTP-Server, tetapi juga untuk skenario individual seperti server antrian atau server gRPC. <br><br>  <strong>Berfungsi di luar kotak</strong> sedapat mungkin: Windows, Linux, ARM CPU. <br><br>  Kemampuan untuk menulis <strong>ekstensi multi-utas yang</strong> sangat <strong>cepat</strong> khusus untuk aplikasi kita. <br><br>  Seperti yang sudah Anda pahami, kami akan menulis di Golang. <br><br><h2>  RoadRunner Server </h2><br>  Untuk membuat server PHP, Anda harus menyelesaikan 4 masalah utama: <br><br><ul><li>  Membangun komunikasi antara Golang dan proses PHP. </li><li>  Manajemen proses: penciptaan, penghancuran, pemantauan pekerja. </li><li>  Menyeimbangkan tugas - distribusi tugas yang efisien kepada pekerja.  Karena kami menerapkan sistem yang memblokir pekerja individu untuk tugas masuk khusus tertentu, penting untuk membuat sistem yang akan dengan cepat mengatakan bahwa proses telah selesai bekerja dan siap untuk menerima tugas berikutnya. </li><li>  Tumpukan HTTP - mengirim data permintaan HTTP ke pekerja.  Ini adalah tugas sederhana untuk menulis titik masuk di mana pengguna mengirim permintaan, yang diteruskan ke PHP dan dikembalikan. </li></ul><br><h3>  Varian interaksi antar proses </h3><br>  Pertama, mari kita selesaikan masalah komunikasi antara proses Golang dan PHP.  Kami punya beberapa cara. <br><br>  <strong>Embedding: menanamkan penerjemah PHP langsung di Golang.</strong>  Ini dimungkinkan, tetapi membutuhkan perakitan PHP khusus, konfigurasi yang rumit, dan proses umum untuk server dan PHP.  Seperti di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-php</a> , misalnya, di mana penerjemah PHP terintegrasi ke Golang. <br><br>  <strong>Memori Bersama - Penggunaan ruang memori bersama,</strong> <strong>tempat proses berbagi ruang ini</strong> .  Butuh kerja keras.  Saat bertukar data, Anda harus menyinkronkan keadaan secara manual dan jumlah kesalahan yang mungkin terjadi cukup besar.  Memori Bersama juga tergantung pada OS. <br><br><h3>  Menulis protokol transport Anda - Goridge </h3><br>  Kami melewati jalur sederhana yang digunakan di hampir semua solusi pada sistem Linux - kami menggunakan protokol transport.  Ini <strong>ditulis di atas PIPA standar dan SOCKET UNIX / TCP</strong> . <br><br>  Ini memiliki kemampuan untuk mentransfer data di kedua arah, mendeteksi kesalahan, dan juga menandai permintaan dan menempatkan header pada mereka.  Nuansa penting bagi kami adalah kemampuan untuk mengimplementasikan protokol tanpa ketergantungan baik di sisi PHP dan Golang - tanpa ekstensi-C dalam bahasa murni. <br><br>  Seperti halnya protokol apa pun, yayasan adalah paket data.  Dalam kasus kami, paket memiliki header tetap sebesar 17 byte. <br><br><img src="https://habrastorage.org/webt/wb/_h/g_/wb_hg_qtkmoxe74sthy12rhtzms.jpeg"><br><br>  Byte pertama dialokasikan untuk menentukan jenis paket.  Ini bisa berupa aliran atau bendera yang menunjukkan jenis serialisasi data.  Kemudian dua kali kami mengemas ukuran data ke Little Endian dan Big Endian.  Kami menggunakan warisan ini untuk mendeteksi kesalahan transmisi.  Jika kita melihat bahwa ukuran data yang dikemas dalam dua pesanan yang berbeda tidak cocok, kemungkinan besar kesalahan transfer data telah terjadi.  Kemudian data ditransmisikan. <br><br><img src="https://habrastorage.org/webt/bt/rb/dr/btrbdre8cwionih8m6e7yze2crw.jpeg"><br><br>  Dalam versi ketiga paket, kami akan menghilangkan warisan seperti itu, memperkenalkan pendekatan yang lebih klasik dengan checksum, dan juga menambahkan kemampuan untuk menggunakan protokol ini dengan proses PHP asinkron. <br><br>  Untuk mengimplementasikan protokol di Golang dan PHP, kami menggunakan alat standar. <br><br>  <strong>Pada Golang:</strong> pengkodean / perpustakaan biner dan perpustakaan io dan bersih untuk bekerja dengan pipa standar dan soket UNIX / TCP. <br><br>  <strong>Dalam PHP:</strong> fungsi yang biasa digunakan untuk bekerja dengan paket data biner / membongkar dan ekstensi stream dan soket untuk pipa dan soket. <br><br>  <strong>Efek samping yang</strong> menarik muncul selama implementasi.  Kami mengintegrasikannya dengan pustaka Golang net / rpc standar, yang memungkinkan kami untuk memanggil kode layanan dari Golang langsung di aplikasi. <br><br>  Kami menulis layanan: <br><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  sample type  struct{} // Hi returns greeting message. func (a *App) Hi(name string, r *string) error { *r = fmt.Sprintf("ll, %s!", name) return nil }</span></span></code> </pre> <br>  Dengan sejumlah kecil kode, kami menyebutnya dari aplikasi: <br><br><pre> <code class="go hljs">&lt;?php use Spiral\Goridge; require <span class="hljs-string"><span class="hljs-string">"vendor/autoload.php"</span></span>; $rpc = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Goridge\RPC( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Goridge\SocketRelay(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">6001</span></span>) ); echo $rpc-&gt;call(<span class="hljs-string"><span class="hljs-string">"App.Hi"</span></span>, <span class="hljs-string"><span class="hljs-string">"Antony"</span></span>);</code> </pre> <br><h3>  Manajer Proses PHP </h3><br>  Bagian selanjutnya dari server adalah manajemen pekerja PHP. <br><img src="https://habrastorage.org/webt/vt/jy/tk/vtjytk9effas7jkgjgadvbek_zw.jpeg"><br><br>  Pekerja adalah proses PHP yang selalu kami amati dari Golang.  Kami mengumpulkan log kesalahannya dalam file STDERR, berkomunikasi dengan pekerja melalui protokol transport Goridge, dan mengumpulkan statistik tentang konsumsi memori, pelaksanaan tugas, dan pemblokiran. <br><br>  Implementasinya sederhana - ini adalah fungsi standar os / exec, runtime, sync, atomic.  Untuk menciptakan pekerja kami menggunakan <strong>Worker Factory</strong> . <br><img src="https://habrastorage.org/webt/wq/kr/tt/wqkrtt0n0xxvhdnxuvx_4f2deiy.jpeg"><br><br>  Mengapa Pabrik Pekerja?  Karena kami ingin berkomunikasi baik pada pipa standar maupun pada soket.  Dalam hal ini, proses inisialisasi sedikit berbeda.  Saat membuat pekerja yang berkomunikasi melalui pipa, kita dapat membuatnya segera dan mengirim data secara langsung.  Dalam hal soket, Anda perlu membuat pekerja, tunggu sampai mencapai sistem, buat jabat tangan PID, dan baru kemudian terus bekerja. <br><br><h3>  Penyeimbang tugas </h3><br>  Bagian ketiga dari server adalah yang paling penting untuk kinerja. <br><br>  Untuk implementasi, kami menggunakan fungsionalitas Golang standar - <strong>saluran buffered</strong> .  Secara khusus, kami membuat beberapa pekerja dan menempatkan mereka di saluran ini sebagai tumpukan LIFO. <br><img src="https://habrastorage.org/webt/bm/po/f4/bmpof4s5-owl810px69ectqiw_i.jpeg"><br>  Setelah menerima tugas dari pengguna, kami mengirim permintaan ke tumpukan LIFO dan meminta pekerja gratis pertama yang dikeluarkan.  Jika pekerja tidak dapat dialokasikan untuk waktu tertentu, maka pengguna menerima kesalahan dari jenis "Kesalahan Timeout".  Jika pekerja dialokasikan - itu didapat dari tumpukan, diblokir, setelah itu menerima tugas dari pengguna. <br><img src="https://habrastorage.org/webt/cm/2o/cq/cm2ocqak94ubao7tk8vxnglfyyo.jpeg"><br>  Setelah tugas diproses, respons dikembalikan ke pengguna, dan pekerja berdiri di ujung tumpukan.  Dia siap untuk melakukan tugas berikutnya lagi. <br><img src="https://habrastorage.org/webt/oj/f_/l4/ojf_l4ipil8fcslpyherhsg02la.jpeg"><br>  Jika kesalahan terjadi, maka pengguna akan menerima kesalahan, karena pekerja akan dimusnahkan.  Kami meminta Worker Pool dan Worker Factory untuk membuat proses yang identik dan menggantinya di tumpukan.  Ini memungkinkan sistem untuk bekerja bahkan jika terjadi kesalahan fatal dengan hanya menciptakan kembali pekerja dengan analogi dengan PHP-FPM. <br><img src="https://habrastorage.org/webt/qs/li/dq/qslidqche8glb-q5pucwfwnpogw.jpeg"><br><br>  Akibatnya, ternyata menerapkan sistem kecil yang bekerja sangat cepat - <strong>200 ns untuk alokasi pekerja</strong> .  Itu dapat bekerja bahkan jika terjadi kesalahan fatal.  Setiap pekerja pada satu titik dalam proses waktu hanya satu tugas, yang memungkinkan kita untuk menggunakan <strong>pendekatan pemblokiran klasik</strong> . <br><br><h3>  Pemantauan proaktif </h3><br>  Bagian terpisah dari manajer proses dan penyeimbang tugas adalah sistem pemantauan proaktif. <br><img src="https://habrastorage.org/webt/83/zq/ep/83zqepdmerd6ozakntcmv33hnus.jpeg"><br><br>  Ini adalah sistem yang pernah melakukan jajak pendapat pekerja dan memonitor indikator: yang terlihat pada berapa banyak memori yang mereka konsumsi, berapa banyak mereka, apakah IDLE.  Selain pelacakan, sistem memonitor kebocoran memori.  Jika pekerja melebihi batas tertentu, kita akan melihatnya dan dengan hati-hati melepaskannya dari sistem sebelum terjadi kebocoran fatal. <br><br><h3>  Tumpukan HTTP </h3><br>  Bagian terakhir dan sederhana. <br><img src="https://habrastorage.org/webt/hl/cc/7e/hlcc7ehfob5vhc_zjse_em8e0eg.jpeg"><br>  <strong>Bagaimana penerapannya:</strong> <br><br><ul><li>  memunculkan titik HTTP di sisi Golang; </li><li>  kami menerima permintaan; </li><li>  dikonversi ke format PSR-7; </li><li>  kirim permintaan ke pekerja bebas pertama; </li><li>  Buka paket permintaan ke objek PSR-7; </li><li>  kami memproses; </li><li>  kami menghasilkan jawabannya. </li></ul><br>  Untuk implementasi, kami menggunakan <strong>perpustakaan</strong> standar <strong>Golang NET / HTTP</strong> .  Ini adalah perpustakaan terkenal dengan banyak ekstensi.  Mampu bekerja baik melalui HTTPS dan melalui protokol HTTP / 2. <br><br>  Di sisi PHP, kami menggunakan standar PSR-7 <strong>.</strong>  Ini adalah <strong>kerangka kerja independen</strong> dengan banyak ekstensi dan Middlewares.  PSR-7 tidak <strong>dapat diubah dalam desain</strong> , yang sangat cocok dengan konsep aplikasi yang berumur panjang dan menghindari kesalahan permintaan global. <br><br>  Kedua struktur di Golang dan PSR-7 sama, yang secara signifikan menghemat waktu untuk memetakan permintaan dari satu bahasa ke bahasa lain. <br><br>  Untuk memulai server membutuhkan <strong>ikatan minimum</strong> : <br><br><pre> <code class="go hljs">http: address: <span class="hljs-number"><span class="hljs-number">0.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> workers: command: <span class="hljs-string"><span class="hljs-string">"php psr-worker.php"</span></span> pool: numWorkers: <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Selain itu, dari versi 1.3.0 bagian terakhir dari konfigurasi dapat dihilangkan. <br><br>  Unduh file biner server, letakkan di wadah Docker atau di folder proyek.  Atau, secara global kita menulis file konfigurasi kecil yang menjelaskan pod mana yang akan kita dengarkan, pekerja mana yang merupakan titik masuk, dan berapa banyak yang dibutuhkan. <br><br>  Di sisi PHP, kami menulis loop utama yang menerima permintaan PSR-7, memprosesnya, dan mengembalikan respons atau kesalahan kembali ke server. <br><br><pre> <code class="go hljs">while ($req = $psr7-&gt;acceptRequest()) { try { $resp = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> \Zend\Diactoros\Response(); $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>); $psr7-&gt;respond($resp); } catch (\Throwable $e) { $psr7-&gt;getWorker()-&gt;error((<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)$e); } }</code> </pre> <br>  <strong>Majelis</strong>  Untuk mengimplementasikan server, kami memilih arsitektur dengan pendekatan komponen.  Ini memungkinkan untuk merakit server untuk kebutuhan proyek, menambah atau menghapus setiap bagian tergantung pada persyaratan aplikasi. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { rr.Container.Register(env.ID, &amp;env.Service{}) rr.Container.Register(rpc.ID, &amp;rpc.Service{}) rr.Container.Register(http.ID, &amp;http.Service{}) rr.Container.Register(static.ID, &amp;static.Service{}) rr.Container.Register(limit.ID, &amp;limit.Service{} <span class="hljs-comment"><span class="hljs-comment">// you can register additional commands using cmd.CLI rr.Execute() }</span></span></code> </pre> <br><h2>  Gunakan kasing </h2><br>  Pertimbangkan opsi untuk menggunakan server dan memodifikasi struktur.  Untuk memulai, pertimbangkan jalur pipa klasik - server berfungsi dengan permintaan. <br><br><h3>  Modularitas </h3><br>  Server menerima permintaan ke titik HTTP dan meneruskannya melalui seperangkat Middleware, yang ditulis dalam Golang.  Permintaan yang masuk dikonversi ke tugas yang dimengerti pekerja.  Server memberikan tugas kepada pekerja dan mengembalikannya. <br><br><img src="https://habrastorage.org/webt/zz/v5/ak/zzv5akvapzklanxdlzunxdq-xpu.jpeg"><br><br>  Pada saat yang sama, pekerja, menggunakan protokol Goridge, berkomunikasi dengan server, memonitor statusnya dan mentransfer data ke sana. <br><br><h3>  Middleware on Golang: Otorisasi </h3><br>  Ini adalah hal pertama yang harus dilakukan.  Dalam aplikasi kami, kami menulis Middleware untuk <strong>memberi otorisasi kepada pengguna dengan token JWT</strong> .  Middleware ditulis dengan cara yang sama untuk semua jenis otorisasi lainnya.  Implementasi yang sangat dangkal dan sederhana adalah menulis Rate-Limiter atau Circuit-Breaker. <br><br><img src="https://habrastorage.org/webt/on/zg/ro/onzgroqwxc7umuy-y2xfv9s7dqe.jpeg"><br><br>  <strong>Otorisasi cepat</strong> .  Jika permintaan tidak valid - jangan kirimkan ke aplikasi PHP dan jangan buang sumber daya untuk memproses tugas yang tidak berguna. <br><br><h3>  Pemantauan </h3><br>  Kasus penggunaan kedua.  Kami dapat mengintegrasikan sistem pemantauan langsung ke Golang Middleware.  Misalnya, Prometheus, untuk mengumpulkan statistik tentang kecepatan poin respons, jumlah kesalahan. <br><br><img src="https://habrastorage.org/webt/rz/_o/hz/rz_ohzkiz6bwjoebzqu2qt4e6dc.jpeg"><br><br>  Anda juga dapat <strong>menggabungkan pemantauan dengan metrik khusus aplikasi</strong> (tersedia sebagai standar dengan 1.4.5).  Misalnya, kami dapat mengirim jumlah permintaan ke database atau jumlah permintaan spesifik yang diproses ke server Golang, dan kemudian ke Prometheus. <br><br><h3>  Pelacakan dan Logging Terdistribusi </h3><br>  Kami menulis Middleware dengan manajer proses.  Secara khusus, kita dapat terhubung ke sistem realtime untuk memantau log dan <strong>mengumpulkan semua log dalam satu database pusat</strong> , yang berguna saat menulis aplikasi terdistribusi. <br><br><img src="https://habrastorage.org/webt/lf/ir/cd/lfircdprhx6nqetmadblqftvbu4.jpeg"><br><br>  Kami juga dapat <strong>menandai permintaan</strong> , memberikannya ID khusus dan meneruskan ID ini ke semua layanan hilir atau sistem komunikasi di antara mereka.  Sebagai hasilnya, kita dapat membuat <strong>jejak terdistribusi</strong> dan melihat bagaimana log aplikasi berjalan. <br><br><h3>  Rekam riwayat kueri Anda </h3><br>  Ini adalah modul kecil yang mencatat semua permintaan yang masuk dan menyimpannya dalam database eksternal.  Modul ini memungkinkan Anda untuk membuat permintaan replay di proyek dan menerapkan sistem pengujian otomatis, sistem pengujian beban, atau hanya memeriksa operasi API. <br><br><img src="https://habrastorage.org/webt/ex/q3/kg/exq3kgpym1uf6tjcfwysjk1so00.jpeg"><br><br>  Bagaimana kami mengimplementasikan modul? <br><br>  <strong>Kami memproses sebagian permintaan untuk Golang</strong> .  Kami menulis Middleware di Golang dan kami dapat mengirim sebagian permintaan ke Handler, yang juga ditulis dalam Golang.  Jika beberapa titik dalam aplikasi mengkhawatirkan dalam hal kinerja, kami menulis ulang ke Golang dan menyeret tumpukan dari satu bahasa ke bahasa lain. <br><br><img src="https://habrastorage.org/webt/q0/zf/qn/q0zfqnzddo_mn7h-d779cg9ganm.jpeg"><br><br>  <strong>Kami sedang menulis server WebSocket</strong> .  Menerapkan server WebSocket atau server push notification menjadi tugas yang sepele. <br><br><ul><li>  Layanan golang di tingkat server. </li><li>  Untuk komunikasi, kami menggunakan Goridge. </li><li>  Lapisan layanan tipis dalam PHP. </li><li>  Kami menerapkan server pemberitahuan. </li></ul><br>  Kami menerima permintaan dan meningkatkan koneksi WebSocket.  Jika aplikasi perlu mengirim semacam pemberitahuan kepada pengguna, itu meluncurkan pesan ini melalui protokol RPC ke server WebSocket. <br><br><img src="https://habrastorage.org/webt/go/ta/fv/gotafvsepr8u8_r_lvfdjpff2rg.jpeg"><br><br>  <strong>Kelola lingkungan PHP Anda.</strong>  Saat membuat Worker Pool, RoadRunner memiliki kontrol penuh atas keadaan variabel lingkungan dan memungkinkan Anda untuk mengubahnya sesuka Anda.  Jika kita menulis aplikasi terdistribusi besar, kita dapat menggunakan satu sumber data konfigurasi dan menghubungkannya sebagai sistem untuk mengonfigurasi lingkungan.  Jika kami meningkatkan satu set layanan, semua layanan ini akan mengetuk satu sistem tunggal, mengkonfigurasi dan kemudian bekerja.  Ini dapat sangat menyederhanakan penyebaran, serta menyingkirkan file .env. <br><br><img src="https://habrastorage.org/webt/iv/m5/03/ivm503pht02yug6do6-od3pyt6i.jpeg"><br><br>  Menariknya, variabel env yang tersedia di dalam pekerja tidak bersifat global dalam sistem.  Ini sedikit meningkatkan keamanan wadah. <br><br><h3>  Integrasi perpustakaan Golang dalam PHP </h3><br>  Kami menggunakan opsi ini di situs resmi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RoadRunner</a> .  Ini adalah integrasi dari database yang hampir lengkap <strong>dengan pencarian teks lengkap BleveSearch</strong> di dalam server. <br><br><img src="https://habrastorage.org/webt/5a/ba/uc/5abaucml3dmvxqpns_h7bug_ldi.jpeg"><br><br>  Kami mengindeks halaman dokumentasi: kami menempatkannya di Bolt DB, setelah itu kami melakukan pencarian teks lengkap tanpa database nyata seperti MySQL, dan tanpa cluster pencarian seperti Elasticsearch.  Hasilnya adalah proyek kecil di mana beberapa fungsi dalam PHP, tetapi pencarian di Golang. <br><br><h3>  Menerapkan Fungsi Lambda </h3><br>  Anda dapat melangkah lebih jauh dan <strong>sepenuhnya menghilangkan lapisan HTTP.</strong>  Dalam hal ini, mengimplementasikan, misalnya, fungsi Lambda adalah tugas yang sederhana. <br><br><img src="https://habrastorage.org/webt/ty/ie/dy/tyiedyrsetx2l5wljnllkbju0xg.jpeg"><br><br>  Untuk implementasi, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">runtime</a> standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AWS</a> untuk fungsi Lambda.  Kami menulis penjilidan kecil, sepenuhnya memotong server HTTP dan mengirim data dalam format biner ke para pekerja.  Kami juga memiliki akses ke pengaturan lingkungan, yang memungkinkan kami untuk menulis fungsi yang dikonfigurasikan langsung dari panel admin Amazon. <br><br>  Pekerja berada dalam memori selama seluruh proses, dan fungsi Lambda setelah permintaan awal tetap tersimpan dalam memori selama 15 menit.  Pada saat ini, kode tidak memuat dan merespons dengan cepat.  Dalam pengujian sintetik, kami menerima hingga <strong>0,5 ms per satu permintaan masuk</strong> . <br><br><h3>  gRPC untuk PHP </h3><br>  Opsi yang lebih sulit adalah mengganti lapisan HTTP dengan lapisan gRPC.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paket ini tersedia di GitHub</a> . <br><img src="https://habrastorage.org/webt/jh/u5/cg/jhu5cgv7-cdj6wf4ifukhqxnd0u.jpeg"><br><br>  Kami dapat sepenuhnya mem-proksi semua permintaan Protobuf yang masuk ke aplikasi PHP bawahan, di sana permintaan itu dapat dibuka, diproses, dan dijawab kembali.  Kita dapat menulis kode baik dalam PHP maupun di Golang, menggabungkan dan mentransfer fungsionalitas dari satu tumpukan ke tumpukan lainnya.  Layanan ini mendukung Middleware.  Baik aplikasi mandiri dan bersama dengan HTTP dapat bekerja. <br><br><h3>  Server antrian </h3><br>  Opsi terakhir dan paling menarik adalah penerapan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">server antrian</a> . <br><img src="https://habrastorage.org/webt/rn/ch/1i/rnch1i0ieekunszmsv_ppegtwbu.jpeg"><br><br>  Di sisi PHP, semua yang kita lakukan adalah mendapatkan muatan biner, membukanya, melakukan pekerjaannya, dan memberi tahu server tentang keberhasilannya.  Di sisi Golang, kami sepenuhnya terlibat dalam mengelola koneksi dengan broker.  Itu bisa RabbitMQ, Amazon SQS atau Beanstalk. <br><br>  Di sisi Golang, kami menerapkan " <strong>shutdown anggun"</strong> pekerja.  Kita dapat dengan indah menunggu implementasi "koneksi tahan lama" - jika koneksi dengan broker terputus, server menunggu sebentar menggunakan "strategi back-off", itu mengangkat koneksi dan aplikasi bahkan tidak menyadarinya. <br><br>  Kami dapat memproses permintaan ini dalam PHP dan Golang, dan mengantri di kedua sisi: <br><br><ul><li>  dari PHP melalui protokol Goridge Goridge RPC; </li><li>  dari Golang - berkomunikasi dengan perpustakaan SDK. </li></ul><br>  Jika payload jatuh, maka tidak seluruh Konsumen jatuh, tetapi hanya satu proses terpisah.  Sistem segera mengangkatnya, tugas dikirim ke pekerja berikutnya.  Ini memungkinkan Anda untuk melakukan tugas tanpa henti. <br><br>  Kami mengimplementasikan salah satu broker secara langsung di memori server dan menggunakan fungsi Golang.  Ini memungkinkan kita untuk menulis aplikasi menggunakan antrian sebelum memilih tumpukan akhir.  Kami mengangkat aplikasi secara lokal, memulainya, dan kami memiliki antrian yang berfungsi di memori dan berperilaku seperti mereka akan berperilaku pada RabbitMQ, Amazon SQS atau Beanstalk. <br><br>  Saat menggunakan dua bahasa dalam bundel hibrid semacam itu, perlu diingat bagaimana memisahkannya. <br><br><h3>  Pisahkan domain domain </h3><br><blockquote>  Golang adalah bahasa multi-utas dan cepat yang cocok untuk menulis logika infrastruktur dan pemantauan pengguna dan logika otorisasi. </blockquote><br>  Ini juga berguna untuk <strong>mengimplementasikan driver khusus</strong> untuk mengakses sumber data - ini adalah antrian, misalnya, Kafka, Cassandra. <br><br><blockquote>  PHP adalah bahasa yang bagus untuk menulis logika bisnis. </blockquote><br>  Ini adalah sistem yang baik untuk rendering HTML, ORM dan bekerja dengan database. <br><br><h2>  Perbandingan alat </h2><br>  Beberapa bulan yang lalu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di HabrÃ© membandingkan</a> PHP-FPM, PHP-PM, React-PHP, Roadrunner dan alat-alat lainnya.  Benchmark diadakan pada proyek dengan Symfony 4 nyata. <br><br>  RoadRunner di bawah beban menunjukkan hasil yang baik dan unggul dari semua server.  Dibandingkan dengan PHP-FPM, kinerjanya 6-8 kali lebih tinggi. <br><img src="https://habrastorage.org/webt/ny/tx/yl/nytxylmddyrmglxjoe8hos7tnka.jpeg"><br><br>  Dalam tolok ukur yang sama, RoadRunner tidak kehilangan satu permintaan, semuanya 100% berhasil.  Sayangnya, React-PHP kehilangan 8-9 permintaan karena banyak - ini tidak dapat diterima.  Kami ingin server tidak crash dan berfungsi secara stabil. <br><img src="https://habrastorage.org/webt/7b/fl/gq/7bflgqhrq1f-y0jixnud_k1ckdg.jpeg"><br><br>  Sejak publikasi RoadRunner dalam akses publik di GitHub, kami telah menerima lebih dari 30.000 instalasi.  Komunitas telah membantu kami menulis serangkaian ekstensi, perbaikan, dan yakin bahwa solusi tersebut memiliki hak untuk hidup. <br><br>  RoadRunner bagus jika Anda ingin <strong>mempercepat aplikasi secara signifikan, tetapi belum siap untuk beralih ke PHP asinkron</strong> .  Ini adalah kompromi yang akan membutuhkan sejumlah upaya, tetapi tidak sepenting menulis ulang dasar kode secara lengkap. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ambil RoadRunner</a> jika Anda ingin <strong>lebih mengontrol siklus hidup PHP</strong> , <strong>jika tidak ada cukup kemampuan PHP,</strong> misalnya, untuk sistem antrian atau Kafka, dan ketika pustaka Golang populer Anda memecahkan masalah Anda, yang tidak ada dalam PHP, dan menulis membutuhkan waktu, yang Anda tidak punya keduanya. <br><br><h2>  Ringkasan </h2><br>  Apa yang kami dapatkan dengan menulis server ini dan menggunakannya dalam infrastruktur produksi kami. <br><br><ul><li>  <strong>Mereka meningkatkan kecepatan reaksi poin aplikasi sebanyak 4 kali</strong> dibandingkan dengan PHP-FPM. </li><li>  <strong>Benar-benar menyingkirkan 502 kesalahan di bawah pemuatan</strong> .  Pada beban puncak, server hanya menunggu sedikit lebih lama dan merespons seolah-olah tidak ada beban. </li><li>  Setelah mengoptimalkan kebocoran memori, pekerja <strong>bertahan dalam memori hingga 2 bulan</strong> .  Ini membantu saat menulis aplikasi terdistribusi, karena semua permintaan antar layanan sudah di-cache di tingkat soket. </li><li>  <strong>Kami menggunakan Keep-Alive.</strong>  Ini secara signifikan mempercepat komunikasi antara sistem terdistribusi. </li><li>  Di dalam infrastruktur nyata, <strong>kami meletakkan semuanya di Docker Alpine di Kubernetes</strong> .  Sistem penyebaran dan pembangunan proyek sekarang lebih mudah.  Yang diperlukan hanyalah membangun RoadRunner custom untuk proyek tersebut, memasukkannya ke dalam proyek Docker, mengisi gambar Docker, dan kemudian dengan tenang mengunggah pod kami ke Kubernetes. </li><li>  Menurut waktu aktual dari salah satu proyek ke titik-titik individual yang tidak memiliki akses ke database, <strong>waktu respons rata</strong> - <strong>rata adalah 0,33 ms</strong> . </li></ul><br><blockquote>  Konferensi profesional berikutnya untuk pengembang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHP, PHP Russia,</a> hanya tahun depan.  Untuk saat ini, kami menawarkan yang berikut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perhatikan GolangConf</a> jika Anda tertarik pada bagian Go dan ingin tahu lebih detail atau dengar argumen yang mendukung pengalihan ke bahasa ini.  Jika Anda siap untuk membagikan pengalaman Anda, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">silakan kirim abstrak</a> . </li><li>  Ambil bagian dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++</a> di Moskow, jika semuanya penting bagi Anda yang terkait dengan kinerja tinggi, kirim laporan sebelum 7 September, atau pesan tiket. </li><li>  Berlangganan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buletin</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran telegram</a> untuk menerima undangan ke PHP Russia 2020 lebih awal dari yang lain. </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461827/">https://habr.com/ru/post/id461827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461815/index.html">Sebuah revolusi dalam desain pasokan daya komputer setengah abad yang lalu</a></li>
<li><a href="../id461817/index.html">CMake dan C ++ - saudara selamanya</a></li>
<li><a href="../id461819/index.html">Mengapa desain situs web sederhana lebih baik secara ilmiah</a></li>
<li><a href="../id461821/index.html">Imunoterapi baru menghilangkan semua tumor pada wanita dengan kanker payudara metastatik</a></li>
<li><a href="../id461823/index.html">Enhanced Four Rules untuk Desain Perangkat Lunak</a></li>
<li><a href="../id461829/index.html">TCP vs UDP atau masa depan protokol jaringan</a></li>
<li><a href="../id461831/index.html">StealthWatch: Penempatan dan Kustomisasi. Bagian 2</a></li>
<li><a href="../id461833/index.html">Jangan tersesat dalam tiga pinus: representasi lingkungan yang egosentris</a></li>
<li><a href="../id461835/index.html">Bagaimana Gantt Charts Menyederhanakan dan Memberdayakan Manajemen Proyek</a></li>
<li><a href="../id461841/index.html">PVS-Studio Melihat ke dalam Mesin Peluru Red Dead Redemption</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>