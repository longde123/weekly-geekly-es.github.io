<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèΩ üèÜ ‚ö∞Ô∏è Kubernetes Storage Volume Plugins: Flexvolume zu CSI üë©üèæ‚Äçü§ù‚Äçüë®üèΩ üêò üçã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den Tagen, als Kubernetes noch v1.0.0 war, gab es Volume-Plugins. Sie wurden ben√∂tigt, um eine Verbindung zu Kubernetes-Systemen herzustellen und p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes Storage Volume Plugins: Flexvolume zu CSI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/465417/"><img src="https://habrastorage.org/webt/sj/ie/we/sjieweu7inrj2_yn3mxvtxe8vrw.png"><br><br>  In den Tagen, als Kubernetes noch v1.0.0 war, gab es Volume-Plugins.  Sie wurden ben√∂tigt, um eine Verbindung zu Kubernetes-Systemen herzustellen und persistente (permanente) Containerdaten zu speichern.  Ihre Anzahl war gering, und unter den ersten gab es Speicheranbieter wie GCE PD, Ceph, AWS EBS und andere. <br><br>  Plug-Ins wurden zusammen mit Kubernetes geliefert, f√ºr die sie ihren Namen erhielten - in-tree.  Viele der vorhandenen Plug-Ins reichten jedoch nicht aus.  Die Handwerker f√ºgten mithilfe von Patches einfache Plugins zum Kern von Kubernetes hinzu. Danach bauten sie ihre eigenen Kubernetes und stellten sie auf ihre Server.  Im Laufe der Zeit stellten die Entwickler von Kubernetes jedoch fest, dass der <i>Fisch</i> nicht gel√∂st werden konnte.  Die Leute brauchen eine <i>Angelrute</i> .  Und in Kubernetes v1.2.0 erschien es ... <a name="habracut"></a><br><br><h2>  Flexvolume Plugin: minimale Angelrute </h2><br>  Die Entwickler von Kubernetes haben das FlexVolume-Plugin erstellt, eine logische Bindung von Variablen und Methoden f√ºr die Arbeit mit Flexvolume-Treibern von Drittanbietern. <br><br>  Lassen Sie uns einen Blick auf den FlexVolume-Treiber werfen.  Dies ist eine bestimmte <b>ausf√ºhrbare Datei</b> (Bin√§rdatei, Python-Skript, Bash-Skript usw.), die bei ihrer Ausf√ºhrung Befehlszeilenargumente verwendet und eine Nachricht mit zuvor bekannten Feldern im JSON-Format zur√ºckgibt.  Konventionell ist das erste Befehlszeilenargument immer die Methode, und die restlichen Argumente sind ihre Parameter. <br><br><img src="https://habrastorage.org/webt/ed/rp/2_/edrp2_n7i75s5meu4bgj5wmiydm.png"><br>  <i>CIFS teilt das Verbindungsschema in OpenShift.</i>  <i>Flexvolume-Treiber - direkt in der Mitte</i> <br><br>  <b>Die Mindestanzahl von Methoden</b> sieht folgenderma√üen aus: <br><br><pre><code class="cs hljs">flexvolume_driver mount <span class="hljs-meta"><span class="hljs-meta">#      pod' #   : { "status": "Success"/"Failure"/"Not supported", "message": "       ", } flexvolume_driver unmount #      pod' #   : { "status": "Success"/"Failure"/"Not supported", "message": "       ", } flexvolume_driver init #     #   : { "status": "Success"/"Failure"/"Not supported", "message": "       ", // ,     attach/deatach "capabilities":{"attach": True/False} }</span></span></code> </pre> <br>  Die Verwendung der Methoden zum <code>attach</code> und Trennen bestimmt das Szenario, nach dem Kubelet in Zukunft beim Aufruf des Treibers agieren wird.  Es gibt auch spezielle <code>expandvolume</code> und <code>expandfs</code> , die f√ºr die dynamische Gr√∂√üen√§nderung eines Volumes verantwortlich sind. <br><br>  Als Beispiel f√ºr die √Ñnderungen, die die <code>expandvolume</code> Methode <code>expandvolume</code> , und damit die M√∂glichkeit, die Gr√∂√üen√§nderung von Volumes in Echtzeit durchzuf√ºhren, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unsere Pull-Anforderung</a> im Rook Ceph-Operator √ºberpr√ºfen. <br><br>  Hier ist eine Beispielimplementierung des Flexvolume-Treibers f√ºr die Arbeit mit NFS: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span></span>() { err <span class="hljs-string"><span class="hljs-string">"Invalid usage. Usage: "</span></span> err <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> init"</span></span> err <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> mount &lt;mount dir&gt; &lt;json params&gt;"</span></span> err <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> unmount &lt;mount dir&gt;"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">err</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -ne $* 1&gt;&amp;2 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -ne $* &gt;&amp;1 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ismounted</span></span></span></span>() { MOUNT=`findmnt -n <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> 2&gt;/dev/null | cut -d<span class="hljs-string"><span class="hljs-string">' '</span></span> -f1` <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MOUNT}</span></span></span><span class="hljs-string">"</span></span> == <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MNTPATH}</span></span></span><span class="hljs-string">"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">domount</span></span></span></span>() { MNTPATH=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> NFS_SERVER=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$2</span></span> | jq -r <span class="hljs-string"><span class="hljs-string">'.server'</span></span>) SHARE=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$2</span></span> | jq -r <span class="hljs-string"><span class="hljs-string">'.share'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $(ismounted) -eq 1 ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> mkdir -p <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> &amp;&gt; /dev/null mount -t nfs <span class="hljs-variable"><span class="hljs-variable">${NFS_SERVER}</span></span>:/<span class="hljs-variable"><span class="hljs-variable">${SHARE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> &amp;&gt; /dev/null <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $? -ne 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> err <span class="hljs-string"><span class="hljs-string">"{ \"status\": \"Failure\", \"message\": \"Failed to mount </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${NFS_SERVER}</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${SHARE}</span></span></span><span class="hljs-string"> at </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MNTPATH}</span></span></span><span class="hljs-string">\"}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unmount</span></span></span></span>() { MNTPATH=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $(ismounted) -eq 0 ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> umount <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> &amp;&gt; /dev/null <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $? -ne 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> err <span class="hljs-string"><span class="hljs-string">"{ \"status\": \"Failed\", \"message\": \"Failed to unmount volume at </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MNTPATH}</span></span></span><span class="hljs-string">\"}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 } op=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$op</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">"init"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success", "capabilities": {"attach": false}}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">$#</span></span> -lt 2 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> usage <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">shift</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$op</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mount) domount $* ;; unmount) unmount $* ;; *) <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Not supported"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">esac</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1</code> </pre> <br>  Nachdem Sie die eigentliche ausf√ºhrbare Datei vorbereitet haben, m√ºssen Sie <b>den Treiber im Kubernetes-Cluster auslegen</b> .  Der Treiber muss sich auf jedem Knoten des Clusters gem√§√ü einem vordefinierten Pfad befinden.  Standardm√§√üig wurde ausgew√§hlt: <br><br> <code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/__~_/</code> <br> <br>  ... aber bei Verwendung verschiedener Kubernetes-Distributionen (OpenShift, Rancher ...) kann der Pfad unterschiedlich sein. <br><br><h2>  Flexvolume-Probleme: Wie wirft man eine Angelrute? </h2><br>  Das Platzieren des Flexvolume-Treibers auf den Clusterknoten erwies sich als nicht triviale Aufgabe.  Nachdem der Vorgang einmal manuell ausgef√ºhrt wurde, kann es leicht zu einer Situation kommen, in der neue Knoten im Cluster angezeigt werden: durch Hinzuf√ºgen eines neuen Knotens, automatische horizontale Skalierung oder, schlimmer noch, Ersetzen des Knotens aufgrund einer Fehlfunktion.  In diesem Fall ist es <b>unm√∂glich,</b> mit dem Speicher auf diesen Knoten zu arbeiten, bis Sie ihnen den Flexvolume-Treiber auf dieselbe Weise manuell hinzuf√ºgen. <br><br>  Die L√∂sung f√ºr dieses Problem war eines der <code>DaemonSet</code> von Kubernetes - <code>DaemonSet</code> .  Wenn ein neuer Knoten im Cluster angezeigt wird, erh√§lt er automatisch einen Pod von unserem DaemonSet, an den ein lokales Volume angeh√§ngt ist, um Flexvolume-Treiber zu finden.  Nach erfolgreicher Erstellung kopiert pod die erforderlichen Dateien, damit der Treiber auf der Festplatte arbeiten kann. <br><br>  Hier ist ein Beispiel f√ºr ein solches DaemonSet zum Layout des Flexvolume-Plugins: <br><br><pre> <code class="1c hljs">apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: flex-set spec: template: metadata: name: flex-deploy labels: app: flex-deploy spec: containers: - image: &lt;deployment_image&gt; name: flex-deploy securityContext: privileged: true volumeMounts: - mountPath: /flexmnt name: flexvolume-mount volumes: - name: flexvolume-mount hostPath: path: &lt;host_driver_directory&gt;</code> </pre> <br>  ... und ein Beispiel f√ºr ein Bash-Skript zum Erstellen eines Flexvolume-Treibers: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh set -o errexit set -o pipefail VENDOR=k8s.io DRIVER=nfs driver_dir=$VENDOR${VENDOR:+"~"}${DRIVER} if [ ! -d "/flexmnt/$driver_dir" ]; then mkdir "/flexmnt/$driver_dir" fi cp "/$DRIVER" "/flexmnt/$driver_dir/.$DRIVER" mv -f "/flexmnt/$driver_dir/.$DRIVER" "/flexmnt/$driver_dir/$DRIVER" while : ; do sleep 3600 done</span></span></code> </pre> <br>  Es ist wichtig, nicht zu vergessen, dass der Kopiervorgang <b>nicht atomar ist</b> .  Es ist sehr wahrscheinlich, dass Kubelet den Treiber verwendet, bevor der Vorbereitungsprozess abgeschlossen ist, was zu einem Fehler im System f√ºhrt.  Der richtige Ansatz w√§re, zuerst die Treiberdateien unter einem anderen Namen zu kopieren und dann die atomare Umbenennungsoperation zu verwenden. <br><br><img src="https://habrastorage.org/webt/3k/zv/vd/3kzvvdbejy8mi47vpezfpjnqlus.png"><br>  <i>Schema der Arbeit mit Ceph in der Rook-Anweisung: Der Flexvolume-Treiber im Diagramm befindet sich im Rook-Agenten</i> <br><br>  Das n√§chste Problem bei der Verwendung von Flexvolume-Treibern besteht darin, dass f√ºr die meisten Speicher <b>die daf√ºr erforderliche Software</b> auf dem Clusterknoten <b>installiert werden sollte</b> (z. B. das ceph-common-Paket f√ºr Ceph).  Urspr√ºnglich war das Flexvolume-Plugin nicht f√ºr die Implementierung derart komplexer Systeme konzipiert. <br><br>  Eine originelle L√∂sung f√ºr dieses Problem ist die Implementierung des Flexvolume-Treibers des Rook-Operators: <br><br>  Der Treiber selbst ist als RPC-Client konzipiert.  Der IPC-Socket f√ºr die Kommunikation befindet sich im selben Verzeichnis wie der Treiber.  Wir erinnern uns, dass es zum Kopieren von Treiberdateien gut w√§re, DaemonSet zu verwenden, das ein Verzeichnis mit dem Treiber als Volume verbindet.  Nach dem Kopieren der erforderlichen Rook-Treiberdateien stirbt dieser Pod nicht ab, sondern stellt √ºber das angeschlossene Volume eine Verbindung zum IPC-Socket als vollwertiger RPC-Server her.  Das ceph-common-Paket ist bereits im Pod-Container installiert.  Der IPC-Socket gibt die Sicherheit, dass kubelet mit dem bestimmten Pod auf demselben Knoten kommuniziert.  Alles Geniale ist einfach! .. <br><br><h2>  Auf Wiedersehen, unsere liebevollen ... In-Tree-Plugins! </h2><br>  Kubernetes-Entwickler haben festgestellt, dass die Anzahl der Speicher-Plugins im Kernel zwanzig betr√§gt.  Und die √Ñnderung in jedem von ihnen durchl√§uft irgendwie den gesamten Kubernetes-Ver√∂ffentlichungszyklus. <br><br>  Es stellt sich heraus, dass <b>Sie den gesamten Cluster aktualisieren m√ºssen,</b> um die neue Version des Plugins f√ºr die Speicherung <b>zu verwenden</b> .  Dar√ºber hinaus werden Sie √ºberrascht sein, dass die neue Version von Kubernetes pl√∂tzlich nicht mehr mit dem verwendeten Linux-Kernel kompatibel ist. Daher wischen Sie die Tr√§nen weg und bei√üen die Z√§hne zusammen und koordinieren mit den Beh√∂rden und Benutzern die Zeit f√ºr die Aktualisierung des Linux-Kernels und des Kubernetes-Clusters.  Mit m√∂glichen Ausfallzeiten bei der Erbringung von Dienstleistungen. <br><br>  Die Situation ist mehr als komisch, oder?  Der gesamten Community wurde klar, dass der Ansatz nicht funktioniert hat.  Mit einer willensstarken Entscheidung k√ºndigen Kubernetes-Entwickler an, dass neue Speicher-Plugins nicht mehr in den Kernel aufgenommen werden.  Wie wir bereits wissen, wurden bei der Implementierung des Flexvolume-Plugins eine Reihe von M√§ngeln aufgedeckt ... <br><br>  Ein f√ºr alle Mal wurde das zuletzt hinzugef√ºgte Plugin f√ºr Volumes in Kubernetes, CSI, aufgefordert, das Problem mit persistenten Data Warehouses zu schlie√üen.  Die Alpha-Version, die allgemein als Out-of-Tree-CSI-Volume-Plugins bezeichnet wird, wurde in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.9</a> angek√ºndigt. <br><br><h2>  Container Storage Interface oder CSI 3000 drehen! </h2><br>  Zun√§chst m√∂chte ich darauf hinweisen, dass CSI nicht nur ein Volume-Plugin ist, sondern ein echter <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard</a> f√ºr die Erstellung benutzerdefinierter Komponenten f√ºr die Arbeit mit Data Warehouses</b> .  Es wurde angenommen, dass Container-Orchestrierungssysteme wie Kubernetes und Mesos ‚Äûlernen‚Äú sollten, wie man mit Komponenten arbeitet, die gem√§√ü diesem Standard implementiert sind.  Und jetzt hat Kubernetes schon gelernt. <br><br>  Was ist das Ger√§t des CSI-Plugins in Kubernetes?  Das CSI-Plugin funktioniert mit speziellen Treibern ( <b>CSI-Treibern</b> ), die von <b>Drittentwicklern</b> geschrieben wurden.  Der CSI-Treiber in Kubernetes sollte mindestens aus zwei Komponenten (Pods) bestehen: <br><br><ul><li>  <b>Controller</b> - verwaltet externen persistenten Speicher.  Es ist als gRPC-Server implementiert, f√ºr den das <code>StatefulSet</code> Grundelement verwendet wird. </li><li>  <b>Knoten</b> - ist f√ºr das Mounten persistenter Speicher auf Clusterknoten verantwortlich.  Es ist auch als gRPC-Server implementiert, aber das <code>DaemonSet</code> wird daf√ºr verwendet. </li></ul><br><img src="https://habrastorage.org/webt/4h/vs/af/4hvsafmhi2tmja8fvc_qtzkqtfc.png"><br>  <i>Kubernetes CSI Plugin Workflow</i> <br><br>  Weitere Einzelheiten zu CSI finden Sie beispielsweise im Artikel ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zum CSI</a> ‚Äú, dessen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> wir vor einem Jahr ver√∂ffentlicht haben. <br><br><h3>  Die Vorteile einer solchen Implementierung </h3><br><ul><li>  F√ºr grundlegende Dinge - zum Beispiel um einen Treiber f√ºr einen Knoten zu registrieren - haben Kubernetes-Entwickler eine Reihe von Containern implementiert.  Sie m√ºssen keine JSON-Antwort mit Funktionen mehr selbst erstellen, wie dies f√ºr das Flexvolume-Plugin getan wurde. </li><li>  Anstatt die Knoten ausf√ºhrbarer Dateien zu ‚Äûverschieben‚Äú, legen wir jetzt Pods im Cluster an.  Dies haben wir urspr√ºnglich von Kubernetes erwartet: Alle Prozesse finden in Containern statt, die mit Kubernetes-Grundelementen bereitgestellt werden. </li><li>  Um komplexe Treiber zu implementieren, m√ºssen Sie keinen RPC-Server und keinen RPC-Client mehr entwickeln.  Der Client f√ºr uns wurde von Kubernetes-Entwicklern implementiert. </li><li>  Das √úbergeben von Argumenten f√ºr die Arbeit mit dem gRPC-Protokoll ist viel bequemer, flexibler und zuverl√§ssiger als das √úbergeben von Argumenten √ºber Befehlszeilenargumente.  Um zu verstehen, wie Sie CSI durch Hinzuf√ºgen einer standardisierten gRPC-Methode Unterst√ºtzung f√ºr Volume-Nutzungsmetriken hinzuf√ºgen k√∂nnen, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unsere Pull-Anfrage</a> f√ºr den vsphere-csi-Treiber. </li><li>  Die Kommunikation erfolgt √ºber IPC-Sockets, um nicht zu verwirren, ob der Kubelet-Pod eine Anfrage gesendet hat oder nicht. </li></ul><br>  Erinnert Sie diese Liste an irgendetwas?  Die Vorteile von CSI sind die <b>L√∂sung</b> genau <b>der Probleme</b> , die bei der Entwicklung des Flexvolume-Plugins nicht ber√ºcksichtigt wurden. <br><br><h2>  Schlussfolgerungen </h2><br>  CSI als Standard f√ºr die Implementierung benutzerdefinierter Plugins f√ºr die Interaktion mit Data Warehouses wurde von der Community sehr gut angenommen.  Aufgrund seiner Vorteile und Vielseitigkeit werden CSI-Treiber auch f√ºr Repositorys wie Ceph oder AWS EBS erstellt, Plugins f√ºr die Arbeit, die in der allerersten Version von Kubernetes hinzugef√ºgt wurden. <br><br>  Anfang 2019 waren In-Tree-Plugins <a href="">veraltet</a> .  Es ist geplant, das Flexvolume-Plugin weiterhin zu unterst√ºtzen, es werden jedoch keine neuen Funktionen daf√ºr entwickelt. <br><br>  Wir selbst haben bereits Erfahrung mit ceph-csi, vsphere-csi und sind bereit, diese Liste zu erg√§nzen!  Bisher bew√§ltigt CSI die ihm zugewiesenen Aufgaben mit einem Knall, und dort warten wir ab. <br><br>  Vergessen Sie nicht, dass alles Neue gut √ºberdacht ist! <br><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  ‚ÄûWir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verstehen die Container Storage Interface (nicht nur in Kubernetes)</a> ‚Äú; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Turm oder nicht Turm - das ist die Frage</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lernen Sie die Alpha-Version von Volume-Snapshots in Kubernetes kennen</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465417/">https://habr.com/ru/post/de465417/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465401/index.html">5 Aktivit√§ten zur Beschleunigung der Probleml√∂sung in einem beliebigen IT-Team</a></li>
<li><a href="../de465403/index.html">Achtung! Neue Kameras unterwegs oder aktuelle Informationen zu Radarger√§ten und Radarwarnern</a></li>
<li><a href="../de465407/index.html">1. √úbersicht √ºber Extreme Enterprise Layer Switches</a></li>
<li><a href="../de465409/index.html">Vue.js Best Practices f√ºr die Webentwicklung</a></li>
<li><a href="../de465415/index.html">Wir sprechen √ºber DevOps in einer verst√§ndlichen Sprache</a></li>
<li><a href="../de465419/index.html">Morgen an der ITMO University: Bildungsprozess, Wettbewerbe und Bildung im Ausland - eine Auswahl anstehender Veranstaltungen</a></li>
<li><a href="../de465423/index.html">Smart Manufacturing and Industry 4.0: Drei technologische Haupttrends</a></li>
<li><a href="../de465425/index.html">Vepp - das neue Server- und Website-Kontrollfeld von ISPsystem</a></li>
<li><a href="../de465427/index.html">Analyse des Apache Dubbo RPC Frameworks mit dem PVS-Studio Static Code Analyzer</a></li>
<li><a href="../de465429/index.html">Dennoch ist C eine einfache Sprache</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>