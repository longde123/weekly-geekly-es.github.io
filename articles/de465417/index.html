<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏽 🏆 ⚰️ Kubernetes Storage Volume Plugins: Flexvolume zu CSI 👩🏾‍🤝‍👨🏽 🐘 🍋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den Tagen, als Kubernetes noch v1.0.0 war, gab es Volume-Plugins. Sie wurden benötigt, um eine Verbindung zu Kubernetes-Systemen herzustellen und p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes Storage Volume Plugins: Flexvolume zu CSI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/465417/"><img src="https://habrastorage.org/webt/sj/ie/we/sjieweu7inrj2_yn3mxvtxe8vrw.png"><br><br>  In den Tagen, als Kubernetes noch v1.0.0 war, gab es Volume-Plugins.  Sie wurden benötigt, um eine Verbindung zu Kubernetes-Systemen herzustellen und persistente (permanente) Containerdaten zu speichern.  Ihre Anzahl war gering, und unter den ersten gab es Speicheranbieter wie GCE PD, Ceph, AWS EBS und andere. <br><br>  Plug-Ins wurden zusammen mit Kubernetes geliefert, für die sie ihren Namen erhielten - in-tree.  Viele der vorhandenen Plug-Ins reichten jedoch nicht aus.  Die Handwerker fügten mithilfe von Patches einfache Plugins zum Kern von Kubernetes hinzu. Danach bauten sie ihre eigenen Kubernetes und stellten sie auf ihre Server.  Im Laufe der Zeit stellten die Entwickler von Kubernetes jedoch fest, dass der <i>Fisch</i> nicht gelöst werden konnte.  Die Leute brauchen eine <i>Angelrute</i> .  Und in Kubernetes v1.2.0 erschien es ... <a name="habracut"></a><br><br><h2>  Flexvolume Plugin: minimale Angelrute </h2><br>  Die Entwickler von Kubernetes haben das FlexVolume-Plugin erstellt, eine logische Bindung von Variablen und Methoden für die Arbeit mit Flexvolume-Treibern von Drittanbietern. <br><br>  Lassen Sie uns einen Blick auf den FlexVolume-Treiber werfen.  Dies ist eine bestimmte <b>ausführbare Datei</b> (Binärdatei, Python-Skript, Bash-Skript usw.), die bei ihrer Ausführung Befehlszeilenargumente verwendet und eine Nachricht mit zuvor bekannten Feldern im JSON-Format zurückgibt.  Konventionell ist das erste Befehlszeilenargument immer die Methode, und die restlichen Argumente sind ihre Parameter. <br><br><img src="https://habrastorage.org/webt/ed/rp/2_/edrp2_n7i75s5meu4bgj5wmiydm.png"><br>  <i>CIFS teilt das Verbindungsschema in OpenShift.</i>  <i>Flexvolume-Treiber - direkt in der Mitte</i> <br><br>  <b>Die Mindestanzahl von Methoden</b> sieht folgendermaßen aus: <br><br><pre><code class="cs hljs">flexvolume_driver mount <span class="hljs-meta"><span class="hljs-meta">#      pod' #   : { "status": "Success"/"Failure"/"Not supported", "message": "       ", } flexvolume_driver unmount #      pod' #   : { "status": "Success"/"Failure"/"Not supported", "message": "       ", } flexvolume_driver init #     #   : { "status": "Success"/"Failure"/"Not supported", "message": "       ", // ,     attach/deatach "capabilities":{"attach": True/False} }</span></span></code> </pre> <br>  Die Verwendung der Methoden zum <code>attach</code> und Trennen bestimmt das Szenario, nach dem Kubelet in Zukunft beim Aufruf des Treibers agieren wird.  Es gibt auch spezielle <code>expandvolume</code> und <code>expandfs</code> , die für die dynamische Größenänderung eines Volumes verantwortlich sind. <br><br>  Als Beispiel für die Änderungen, die die <code>expandvolume</code> Methode <code>expandvolume</code> , und damit die Möglichkeit, die Größenänderung von Volumes in Echtzeit durchzuführen, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unsere Pull-Anforderung</a> im Rook Ceph-Operator überprüfen. <br><br>  Hier ist eine Beispielimplementierung des Flexvolume-Treibers für die Arbeit mit NFS: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span></span>() { err <span class="hljs-string"><span class="hljs-string">"Invalid usage. Usage: "</span></span> err <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> init"</span></span> err <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> mount &lt;mount dir&gt; &lt;json params&gt;"</span></span> err <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> unmount &lt;mount dir&gt;"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">err</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -ne $* 1&gt;&amp;2 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -ne $* &gt;&amp;1 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ismounted</span></span></span></span>() { MOUNT=`findmnt -n <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> 2&gt;/dev/null | cut -d<span class="hljs-string"><span class="hljs-string">' '</span></span> -f1` <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MOUNT}</span></span></span><span class="hljs-string">"</span></span> == <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MNTPATH}</span></span></span><span class="hljs-string">"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">domount</span></span></span></span>() { MNTPATH=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> NFS_SERVER=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$2</span></span> | jq -r <span class="hljs-string"><span class="hljs-string">'.server'</span></span>) SHARE=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$2</span></span> | jq -r <span class="hljs-string"><span class="hljs-string">'.share'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $(ismounted) -eq 1 ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> mkdir -p <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> &amp;&gt; /dev/null mount -t nfs <span class="hljs-variable"><span class="hljs-variable">${NFS_SERVER}</span></span>:/<span class="hljs-variable"><span class="hljs-variable">${SHARE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> &amp;&gt; /dev/null <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $? -ne 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> err <span class="hljs-string"><span class="hljs-string">"{ \"status\": \"Failure\", \"message\": \"Failed to mount </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${NFS_SERVER}</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${SHARE}</span></span></span><span class="hljs-string"> at </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MNTPATH}</span></span></span><span class="hljs-string">\"}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 } <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unmount</span></span></span></span>() { MNTPATH=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $(ismounted) -eq 0 ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> umount <span class="hljs-variable"><span class="hljs-variable">${MNTPATH}</span></span> &amp;&gt; /dev/null <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ $? -ne 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> err <span class="hljs-string"><span class="hljs-string">"{ \"status\": \"Failed\", \"message\": \"Failed to unmount volume at </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${MNTPATH}</span></span></span><span class="hljs-string">\"}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 } op=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$op</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">"init"</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Success", "capabilities": {"attach": false}}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">$#</span></span> -lt 2 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> usage <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">shift</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$op</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mount) domount $* ;; unmount) unmount $* ;; *) <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-string"><span class="hljs-string">'{"status": "Not supported"}'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0 <span class="hljs-keyword"><span class="hljs-keyword">esac</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 1</code> </pre> <br>  Nachdem Sie die eigentliche ausführbare Datei vorbereitet haben, müssen Sie <b>den Treiber im Kubernetes-Cluster auslegen</b> .  Der Treiber muss sich auf jedem Knoten des Clusters gemäß einem vordefinierten Pfad befinden.  Standardmäßig wurde ausgewählt: <br><br> <code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/__~_/</code> <br> <br>  ... aber bei Verwendung verschiedener Kubernetes-Distributionen (OpenShift, Rancher ...) kann der Pfad unterschiedlich sein. <br><br><h2>  Flexvolume-Probleme: Wie wirft man eine Angelrute? </h2><br>  Das Platzieren des Flexvolume-Treibers auf den Clusterknoten erwies sich als nicht triviale Aufgabe.  Nachdem der Vorgang einmal manuell ausgeführt wurde, kann es leicht zu einer Situation kommen, in der neue Knoten im Cluster angezeigt werden: durch Hinzufügen eines neuen Knotens, automatische horizontale Skalierung oder, schlimmer noch, Ersetzen des Knotens aufgrund einer Fehlfunktion.  In diesem Fall ist es <b>unmöglich,</b> mit dem Speicher auf diesen Knoten zu arbeiten, bis Sie ihnen den Flexvolume-Treiber auf dieselbe Weise manuell hinzufügen. <br><br>  Die Lösung für dieses Problem war eines der <code>DaemonSet</code> von Kubernetes - <code>DaemonSet</code> .  Wenn ein neuer Knoten im Cluster angezeigt wird, erhält er automatisch einen Pod von unserem DaemonSet, an den ein lokales Volume angehängt ist, um Flexvolume-Treiber zu finden.  Nach erfolgreicher Erstellung kopiert pod die erforderlichen Dateien, damit der Treiber auf der Festplatte arbeiten kann. <br><br>  Hier ist ein Beispiel für ein solches DaemonSet zum Layout des Flexvolume-Plugins: <br><br><pre> <code class="1c hljs">apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: flex-set spec: template: metadata: name: flex-deploy labels: app: flex-deploy spec: containers: - image: &lt;deployment_image&gt; name: flex-deploy securityContext: privileged: true volumeMounts: - mountPath: /flexmnt name: flexvolume-mount volumes: - name: flexvolume-mount hostPath: path: &lt;host_driver_directory&gt;</code> </pre> <br>  ... und ein Beispiel für ein Bash-Skript zum Erstellen eines Flexvolume-Treibers: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh set -o errexit set -o pipefail VENDOR=k8s.io DRIVER=nfs driver_dir=$VENDOR${VENDOR:+"~"}${DRIVER} if [ ! -d "/flexmnt/$driver_dir" ]; then mkdir "/flexmnt/$driver_dir" fi cp "/$DRIVER" "/flexmnt/$driver_dir/.$DRIVER" mv -f "/flexmnt/$driver_dir/.$DRIVER" "/flexmnt/$driver_dir/$DRIVER" while : ; do sleep 3600 done</span></span></code> </pre> <br>  Es ist wichtig, nicht zu vergessen, dass der Kopiervorgang <b>nicht atomar ist</b> .  Es ist sehr wahrscheinlich, dass Kubelet den Treiber verwendet, bevor der Vorbereitungsprozess abgeschlossen ist, was zu einem Fehler im System führt.  Der richtige Ansatz wäre, zuerst die Treiberdateien unter einem anderen Namen zu kopieren und dann die atomare Umbenennungsoperation zu verwenden. <br><br><img src="https://habrastorage.org/webt/3k/zv/vd/3kzvvdbejy8mi47vpezfpjnqlus.png"><br>  <i>Schema der Arbeit mit Ceph in der Rook-Anweisung: Der Flexvolume-Treiber im Diagramm befindet sich im Rook-Agenten</i> <br><br>  Das nächste Problem bei der Verwendung von Flexvolume-Treibern besteht darin, dass für die meisten Speicher <b>die dafür erforderliche Software</b> auf dem Clusterknoten <b>installiert werden sollte</b> (z. B. das ceph-common-Paket für Ceph).  Ursprünglich war das Flexvolume-Plugin nicht für die Implementierung derart komplexer Systeme konzipiert. <br><br>  Eine originelle Lösung für dieses Problem ist die Implementierung des Flexvolume-Treibers des Rook-Operators: <br><br>  Der Treiber selbst ist als RPC-Client konzipiert.  Der IPC-Socket für die Kommunikation befindet sich im selben Verzeichnis wie der Treiber.  Wir erinnern uns, dass es zum Kopieren von Treiberdateien gut wäre, DaemonSet zu verwenden, das ein Verzeichnis mit dem Treiber als Volume verbindet.  Nach dem Kopieren der erforderlichen Rook-Treiberdateien stirbt dieser Pod nicht ab, sondern stellt über das angeschlossene Volume eine Verbindung zum IPC-Socket als vollwertiger RPC-Server her.  Das ceph-common-Paket ist bereits im Pod-Container installiert.  Der IPC-Socket gibt die Sicherheit, dass kubelet mit dem bestimmten Pod auf demselben Knoten kommuniziert.  Alles Geniale ist einfach! .. <br><br><h2>  Auf Wiedersehen, unsere liebevollen ... In-Tree-Plugins! </h2><br>  Kubernetes-Entwickler haben festgestellt, dass die Anzahl der Speicher-Plugins im Kernel zwanzig beträgt.  Und die Änderung in jedem von ihnen durchläuft irgendwie den gesamten Kubernetes-Veröffentlichungszyklus. <br><br>  Es stellt sich heraus, dass <b>Sie den gesamten Cluster aktualisieren müssen,</b> um die neue Version des Plugins für die Speicherung <b>zu verwenden</b> .  Darüber hinaus werden Sie überrascht sein, dass die neue Version von Kubernetes plötzlich nicht mehr mit dem verwendeten Linux-Kernel kompatibel ist. Daher wischen Sie die Tränen weg und beißen die Zähne zusammen und koordinieren mit den Behörden und Benutzern die Zeit für die Aktualisierung des Linux-Kernels und des Kubernetes-Clusters.  Mit möglichen Ausfallzeiten bei der Erbringung von Dienstleistungen. <br><br>  Die Situation ist mehr als komisch, oder?  Der gesamten Community wurde klar, dass der Ansatz nicht funktioniert hat.  Mit einer willensstarken Entscheidung kündigen Kubernetes-Entwickler an, dass neue Speicher-Plugins nicht mehr in den Kernel aufgenommen werden.  Wie wir bereits wissen, wurden bei der Implementierung des Flexvolume-Plugins eine Reihe von Mängeln aufgedeckt ... <br><br>  Ein für alle Mal wurde das zuletzt hinzugefügte Plugin für Volumes in Kubernetes, CSI, aufgefordert, das Problem mit persistenten Data Warehouses zu schließen.  Die Alpha-Version, die allgemein als Out-of-Tree-CSI-Volume-Plugins bezeichnet wird, wurde in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.9</a> angekündigt. <br><br><h2>  Container Storage Interface oder CSI 3000 drehen! </h2><br>  Zunächst möchte ich darauf hinweisen, dass CSI nicht nur ein Volume-Plugin ist, sondern ein echter <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard</a> für die Erstellung benutzerdefinierter Komponenten für die Arbeit mit Data Warehouses</b> .  Es wurde angenommen, dass Container-Orchestrierungssysteme wie Kubernetes und Mesos „lernen“ sollten, wie man mit Komponenten arbeitet, die gemäß diesem Standard implementiert sind.  Und jetzt hat Kubernetes schon gelernt. <br><br>  Was ist das Gerät des CSI-Plugins in Kubernetes?  Das CSI-Plugin funktioniert mit speziellen Treibern ( <b>CSI-Treibern</b> ), die von <b>Drittentwicklern</b> geschrieben wurden.  Der CSI-Treiber in Kubernetes sollte mindestens aus zwei Komponenten (Pods) bestehen: <br><br><ul><li>  <b>Controller</b> - verwaltet externen persistenten Speicher.  Es ist als gRPC-Server implementiert, für den das <code>StatefulSet</code> Grundelement verwendet wird. </li><li>  <b>Knoten</b> - ist für das Mounten persistenter Speicher auf Clusterknoten verantwortlich.  Es ist auch als gRPC-Server implementiert, aber das <code>DaemonSet</code> wird dafür verwendet. </li></ul><br><img src="https://habrastorage.org/webt/4h/vs/af/4hvsafmhi2tmja8fvc_qtzkqtfc.png"><br>  <i>Kubernetes CSI Plugin Workflow</i> <br><br>  Weitere Einzelheiten zu CSI finden Sie beispielsweise im Artikel „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zum CSI</a> “, dessen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> wir vor einem Jahr veröffentlicht haben. <br><br><h3>  Die Vorteile einer solchen Implementierung </h3><br><ul><li>  Für grundlegende Dinge - zum Beispiel um einen Treiber für einen Knoten zu registrieren - haben Kubernetes-Entwickler eine Reihe von Containern implementiert.  Sie müssen keine JSON-Antwort mit Funktionen mehr selbst erstellen, wie dies für das Flexvolume-Plugin getan wurde. </li><li>  Anstatt die Knoten ausführbarer Dateien zu „verschieben“, legen wir jetzt Pods im Cluster an.  Dies haben wir ursprünglich von Kubernetes erwartet: Alle Prozesse finden in Containern statt, die mit Kubernetes-Grundelementen bereitgestellt werden. </li><li>  Um komplexe Treiber zu implementieren, müssen Sie keinen RPC-Server und keinen RPC-Client mehr entwickeln.  Der Client für uns wurde von Kubernetes-Entwicklern implementiert. </li><li>  Das Übergeben von Argumenten für die Arbeit mit dem gRPC-Protokoll ist viel bequemer, flexibler und zuverlässiger als das Übergeben von Argumenten über Befehlszeilenargumente.  Um zu verstehen, wie Sie CSI durch Hinzufügen einer standardisierten gRPC-Methode Unterstützung für Volume-Nutzungsmetriken hinzufügen können, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unsere Pull-Anfrage</a> für den vsphere-csi-Treiber. </li><li>  Die Kommunikation erfolgt über IPC-Sockets, um nicht zu verwirren, ob der Kubelet-Pod eine Anfrage gesendet hat oder nicht. </li></ul><br>  Erinnert Sie diese Liste an irgendetwas?  Die Vorteile von CSI sind die <b>Lösung</b> genau <b>der Probleme</b> , die bei der Entwicklung des Flexvolume-Plugins nicht berücksichtigt wurden. <br><br><h2>  Schlussfolgerungen </h2><br>  CSI als Standard für die Implementierung benutzerdefinierter Plugins für die Interaktion mit Data Warehouses wurde von der Community sehr gut angenommen.  Aufgrund seiner Vorteile und Vielseitigkeit werden CSI-Treiber auch für Repositorys wie Ceph oder AWS EBS erstellt, Plugins für die Arbeit, die in der allerersten Version von Kubernetes hinzugefügt wurden. <br><br>  Anfang 2019 waren In-Tree-Plugins <a href="">veraltet</a> .  Es ist geplant, das Flexvolume-Plugin weiterhin zu unterstützen, es werden jedoch keine neuen Funktionen dafür entwickelt. <br><br>  Wir selbst haben bereits Erfahrung mit ceph-csi, vsphere-csi und sind bereit, diese Liste zu ergänzen!  Bisher bewältigt CSI die ihm zugewiesenen Aufgaben mit einem Knall, und dort warten wir ab. <br><br>  Vergessen Sie nicht, dass alles Neue gut überdacht ist! <br><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  „Wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verstehen die Container Storage Interface (nicht nur in Kubernetes)</a> “; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Turm oder nicht Turm - das ist die Frage</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lernen Sie die Alpha-Version von Volume-Snapshots in Kubernetes kennen</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465417/">https://habr.com/ru/post/de465417/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465401/index.html">5 Aktivitäten zur Beschleunigung der Problemlösung in einem beliebigen IT-Team</a></li>
<li><a href="../de465403/index.html">Achtung! Neue Kameras unterwegs oder aktuelle Informationen zu Radargeräten und Radarwarnern</a></li>
<li><a href="../de465407/index.html">1. Übersicht über Extreme Enterprise Layer Switches</a></li>
<li><a href="../de465409/index.html">Vue.js Best Practices für die Webentwicklung</a></li>
<li><a href="../de465415/index.html">Wir sprechen über DevOps in einer verständlichen Sprache</a></li>
<li><a href="../de465419/index.html">Morgen an der ITMO University: Bildungsprozess, Wettbewerbe und Bildung im Ausland - eine Auswahl anstehender Veranstaltungen</a></li>
<li><a href="../de465423/index.html">Smart Manufacturing and Industry 4.0: Drei technologische Haupttrends</a></li>
<li><a href="../de465425/index.html">Vepp - das neue Server- und Website-Kontrollfeld von ISPsystem</a></li>
<li><a href="../de465427/index.html">Analyse des Apache Dubbo RPC Frameworks mit dem PVS-Studio Static Code Analyzer</a></li>
<li><a href="../de465429/index.html">Dennoch ist C eine einfache Sprache</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>