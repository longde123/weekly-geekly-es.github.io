<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéπ üë®üèª‚Äçüè´ üë∏üèΩ Pruebas autom√°ticas de la interfaz de usuario: c√≥mo hacerlo no vale la pena üíáüèº ‚òîÔ∏è ‚õÖÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr Mi nombre es Vitaliy Kotov, trabajo en el departamento de pruebas de Badoo. Escribo muchas pruebas autom√°ticas de UI, pero trabajo a√∫n m√°s c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas autom√°ticas de la interfaz de usuario: c√≥mo hacerlo no vale la pena</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/419419/">  Hola Habr  Mi nombre es Vitaliy Kotov, trabajo en el departamento de pruebas de Badoo.  Escribo muchas pruebas autom√°ticas de UI, pero trabajo a√∫n m√°s con aquellos que han estado haciendo esto no hace mucho tiempo y a√∫n no han logrado pisar todos los rastrillos. <br><br>  Entonces, despu√©s de agregar mi propia experiencia y observaciones de otros tipos, decid√≠ preparar una colecci√≥n de "c√≥mo escribir pruebas no vale la pena".  Apoy√© cada ejemplo con una descripci√≥n detallada, ejemplos de c√≥digo y capturas de pantalla. <br><br>  El art√≠culo ser√° interesante para los autores principiantes de pruebas de IU, pero los veteranos en este tema probablemente aprender√°n algo nuevo, o simplemente sonreir√°n, record√°ndose a s√≠ mismos "en su juventud".  :) <br><br>  Vamos! <br><br><img width="651" src="https://habrastorage.org/webt/gn/un/vn/gnunvna-dpyr8dzj9gwsh-xinlm.jpeg"><br><br><a name="habracut"></a><br><h2>  Contenido </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Localizadores sin atributos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Verifique si hay elementos faltantes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Verificar un art√≠culo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Datos aleatorios</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Atomicidad de las pruebas (parte 1)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Atomicidad de las pruebas (parte 2)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Error al hacer clic en un elemento existente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Texto de error</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Resumen</a> </li></ul><a name="locators"></a><br><h2>  Localizadores sin atributos </h2><br>  Comencemos con un ejemplo simple.  Como estamos hablando de pruebas de IU, los localizadores juegan un papel importante en ellas.  Un localizador es una l√≠nea compuesta de acuerdo con una determinada regla y que describe uno o m√°s elementos XML (en particular HTML). <br><br>  Existen varios tipos de localizadores.  Por ejemplo, los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">localizadores CSS</a> se utilizan para las hojas de estilo en cascada.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los localizadores XPath</a> se utilizan para trabajar con documentos XML.  Y as√≠ sucesivamente. <br><br>  Puede encontrar una lista completa de los tipos de localizadores utilizados por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Selenium</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seleniumhq.github.io</a> . <br><br>  En las pruebas de IU, los localizadores se usan para describir los elementos con los que el controlador debe interactuar. <br><br>  En casi cualquier inspector de navegador, es posible seleccionar el elemento que nos interesa y copiar su XPath.  Se parece a esto: <br><br><img width="650" src="https://habrastorage.org/webt/mw/oi/fz/mwoifzz6ukpjltmexvq6sasxw2c.png"><br><br>  Resulta tal localizador: <br><br> <code>/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a <br></code> <br>  Parece que no hay nada de malo con tal localizador.  Despu√©s de todo, podemos guardarlo en alguna constante o campo de la clase, que por su nombre transmitir√° la esencia del elemento: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FindBy</span></span>(xpath = <span class="hljs-string"><span class="hljs-string">"/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WebElement createAccountButton;</code> </pre><br>  Y ajuste el texto de error correspondiente en caso de que no se encuentre el elemento: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForCreateAccountButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ By by = By.xpath(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAccountButton); WebDriverWait wait = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebDriverWait(driver, timeoutInSeconds); wait .withMessage(‚ÄúCannot find Create Account button.‚Äù) .until( ExpectedConditions.presenceOfElementLocated(by) ); }</code> </pre><br>  Este enfoque tiene una ventaja: no hay necesidad de aprender XPath. <br><br>  Sin embargo, hay una serie de desventajas.  En primer lugar, al cambiar el dise√±o no hay garant√≠a de que el elemento en dicho localizador siga siendo el mismo.  Es posible que otro tome su lugar, lo que conducir√° a circunstancias imprevistas.  En segundo lugar, la tarea de las pruebas autom√°ticas es buscar errores y no monitorear los cambios de dise√±o.  Por lo tanto, la adici√≥n de alg√∫n contenedor u otros elementos m√°s altos en el √°rbol no deber√≠a afectar nuestras pruebas.  De lo contrario, nos llevar√° bastante tiempo actualizar los localizadores. <br><br>  Conclusi√≥n: debe crear localizadores que describan correctamente el elemento y sean resistentes a los cambios de dise√±o fuera de la parte probada de nuestra aplicaci√≥n.  Por ejemplo, puede enlazar a uno o m√°s atributos de un elemento: <br><br> <code>//a[@rel=‚ÄùcreateAccount‚Äù] <br></code> <br>  Tal localizador es m√°s f√°cil de percibir en el c√≥digo, y se romper√° solo si desaparece "rel". <br><br>  Otra ventaja de dicho localizador es la capacidad de buscar en el repositorio de plantillas con el atributo especificado.  ¬øPero qu√© buscar si el localizador se ve en el ejemplo original?  :) <br><br>  Si inicialmente en la aplicaci√≥n los elementos no tienen ning√∫n atributo o se configuran autom√°ticamente (por ejemplo, debido a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ofuscaci√≥n de</a> clases), vale la pena discutirlo con los desarrolladores.  No deber√≠an estar menos interesados ‚Äã‚Äãen automatizar las pruebas de productos y seguramente lo conocer√°n y le ofrecer√°n una soluci√≥n. <br><a name="no_element"></a><br><h2>  Verifique si hay elementos faltantes </h2><br>  Cada usuario de Badoo tiene su propio perfil.  Contiene informaci√≥n sobre el usuario: (nombre, edad, fotos) e informaci√≥n sobre con qui√©n quiere chatear el usuario.  Adem√°s, es posible indicar sus intereses. <br><br>  Supongamos que alguna vez tuvimos un error (aunque, por supuesto, esto no es as√≠ :)).  El usuario en su perfil eligi√≥ intereses.  Al no encontrar un inter√©s adecuado en la lista, decidi√≥ hacer clic en "M√°s" para actualizar la lista. <br><br>  Comportamiento esperado: los viejos intereses deber√≠an desaparecer, deber√≠an aparecer otros nuevos.  Pero en su lugar apareci√≥ un "error inesperado": <br><br><img width="550" src="https://habrastorage.org/webt/tz/fp/lt/tzfpltsr9rkjpk-qtmoj4ustqjc.png"><br><br>  Result√≥ que hab√≠a un problema en el lado del servidor, la respuesta no era la misma y el cliente proces√≥ este asunto mostrando una notificaci√≥n. <br><br>  Nuestra tarea es escribir una prueba autom√°tica que verifique este caso. <br><br>  Escribimos aproximadamente el siguiente script: <br><br><ul><li>  Abrir perfil </li><li>  Abrir lista de intereses </li><li>  Haga clic en el bot√≥n "M√°s" </li><li>  Aseg√∫rese de que el error no apareci√≥ (por ejemplo, no hay ning√∫n elemento div.error) </li></ul><br>  Realizamos tal prueba.  Sin embargo, sucede lo siguiente: despu√©s de unos d√≠as / meses / a√±os, el error vuelve a aparecer, aunque la prueba no detecta nada.  Por qu√© <br><br>  Todo es bastante simple: durante la aprobaci√≥n exitosa de la prueba, el localizador del elemento por el que buscamos el texto de error ha cambiado.  Hubo una refactorizaci√≥n de las plantillas y en lugar de la clase "error" obtuvimos la clase "error_new". <br><br>  Durante la refactorizaci√≥n, la prueba continu√≥ funcionando como se esperaba.  El elemento div.error no apareci√≥; no hab√≠a raz√≥n para la ca√≠da.  Pero ahora el elemento "div.error" no existe en absoluto, por lo tanto, la prueba nunca fallar√°, pase lo que pase en la aplicaci√≥n. <br><br>  Conclusi√≥n: es mejor probar la operabilidad de la interfaz con verificaciones positivas.  En nuestro ejemplo, debemos esperar que la lista de intereses haya cambiado. <br><br>  Hay situaciones en las que una prueba negativa no se puede reemplazar por una positiva.  Por ejemplo, cuando interact√∫a con alg√∫n elemento, no sucede nada en una situaci√≥n "buena" y aparece un error en una situaci√≥n "mala".  En este caso, debe encontrar una manera de simular un escenario "malo" y escribir una prueba autom√°tica tambi√©n.  Por lo tanto, verificamos que el elemento de error aparece en el caso negativo y, por lo tanto, monitoreamos la relevancia del localizador. <br><a name="element_exists"></a><br><h2>  Verificar un art√≠culo </h2><br>  ¬øC√≥mo asegurarse de que la interacci√≥n de prueba con la interfaz fue exitosa y que todo funciona?  Esto se ve con mayor frecuencia en los cambios que se han producido en esta interfaz. <br><br>  Considera un ejemplo.  Debes asegurarte de que al enviar un mensaje aparezca en el chat: <br><br><img width="350" src="https://habrastorage.org/webt/ac/uy/ww/acuywwe6rttek93vzdcf0n66th4.png"><br><br>  El gui√≥n se parece a esto: <br><br><ul><li>  Abrir perfil de usuario </li><li>  Abrir chat con √©l </li><li>  Escribir un mensaje </li><li>  Enviar </li><li>  Espera a que aparezca el mensaje. </li></ul><br>  Describimos tal escenario en nuestra prueba.  Supongamos que un mensaje de chat coincide con un localizador: <br><br> <code>p.message_text <br></code> <br>  As√≠ es como verificamos que aparece el elemento: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">'p.message_text'</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find sent message."</span></span>);</code> </pre><br>  Si nuestra espera funciona, entonces todo est√° en orden: se dibujan mensajes de chat. <br><br>  Como habr√°s adivinado, despu√©s de un tiempo, el env√≠o de mensajes de chat se interrumpe, pero nuestra prueba contin√∫a funcionando sin interrupciones.  Vamos a hacerlo bien. <br><br>  Resulta que el d√≠a antes de que apareciera un nuevo elemento en el chat: un texto que le pide al usuario que resalte el mensaje si de repente pasa desapercibido: <br><br><img width="550" src="https://habrastorage.org/webt/ie/yc/82/ieyc82alpp-8kcoblkwyvup60my.png"><br><br>  Y, lo m√°s divertido, tambi√©n cae bajo nuestro localizador.  Solo tiene una clase adicional que lo distingue de los mensajes enviados: <br><br> <code>p.message_text.highlight <br></code> <br>  Nuestra prueba no se rompi√≥ cuando apareci√≥ este bloque, pero la marca "esperar a que aparezca el mensaje" dej√≥ de ser relevante.  El elemento que fue un indicador de un evento exitoso ahora siempre est√° ah√≠. <br><br>  Conclusi√≥n: si la l√≥gica de la prueba se basa en verificar la apariencia de alg√∫n elemento, es necesario verificar que no exista dicho elemento antes de nuestra interacci√≥n con la interfaz de usuario. <br><br><ul><li>  Abrir perfil de usuario </li><li>  Abrir chat con √©l </li><li>  <b>Aseg√∫rese de que no haya mensajes enviados</b> </li><li>  Escribir un mensaje </li><li>  Enviar </li><li>  Espera a que aparezca el mensaje. </li></ul><br><a name="random_data"></a><h2>  Datos aleatorios </h2><br>  Muy a menudo, las pruebas de IU funcionan con formularios en los que ingresan datos.  Por ejemplo, tenemos un formulario de registro: <br><br><img width="550" src="https://habrastorage.org/webt/dd/gv/z2/ddgvz2ss4i8juyv7c5jrgqahd84.png"><br><br>  Los datos para tales pruebas se pueden almacenar en configuraciones o codificar en una prueba.  Pero a veces se me ocurre la idea: ¬øpor qu√© no aleatorizar los datos?  ¬°Esto es bueno, cubriremos m√°s casos! <br><br>  Mi consejo: no lo hagas.  Y ahora te dir√© por qu√©. <br><br>  Supongamos que nuestra prueba est√° registrada en Badoo.  Decidimos que elegiremos el g√©nero del usuario al azar.  Al momento de escribir la prueba, el flujo de registro para la ni√±a y el ni√±o no es diferente, por lo que nuestra prueba se aprueba con √©xito. <br><br>  Ahora imagine que despu√©s de un tiempo el flujo de registro se vuelve diferente.  Por ejemplo, le damos a la ni√±a bonos gratis inmediatamente despu√©s del registro, sobre lo cual le notificamos con una superposici√≥n especial. <br><br>  En la prueba, no hay l√≥gica para cerrar la superposici√≥n, pero, a su vez, interfiere con cualquier otra acci√≥n prescrita en la prueba.  Obtenemos una prueba que cae en el 50% de los casos.  Cualquier herramienta de automatizaci√≥n confirmar√° que las pruebas de IU no son inherentemente estables por naturaleza.  Y esto es normal, uno tiene que vivir con √©l, atacando constantemente entre la l√≥gica redundante "para todas las ocasiones" (que estropea notablemente la legibilidad del c√≥digo y complica su soporte) y esta inestabilidad en s√≠ misma. <br><br>  La pr√≥xima vez, cuando caiga la prueba, es posible que no tengamos tiempo para enfrentarla.  Simplemente lo reiniciamos y vemos que ha pasado.  Decidimos que en nuestra aplicaci√≥n todo funciona como deber√≠a y es una prueba inestable.  Y c√°lmate. <br><br>  Ahora sigamos adelante.  ¬øQu√© pasa si esta superposici√≥n se rompe?  La prueba continuar√° pasando en el 50% de los casos, lo que retrasa significativamente la b√∫squeda del problema. <br><br>  Y es bueno cuando, debido a la aleatorizaci√≥n de datos, creamos una situaci√≥n de "50 por 50".  Pero sucede de manera diferente.  Por ejemplo, antes de registrarse, una contrase√±a se consideraba aceptable con al menos tres caracteres de longitud.  Escribimos c√≥digo que aparece con una contrase√±a aleatoria no menor a tres caracteres (a veces tres caracteres y otras veces m√°s).  Y luego la regla cambia, y la contrase√±a ya debe contener al menos cuatro caracteres.  ¬øCu√°l es la probabilidad de una ca√≠da en este caso?  Y, si nuestra prueba detecta un error real, ¬øqu√© tan r√°pido lo resolveremos? <br><br>  Es especialmente dif√≠cil trabajar con pruebas en las que se ingresan muchos datos aleatorios: nombre, g√©nero, contrase√±a, etc. En este caso, tambi√©n hay muchas combinaciones diferentes, y si se produce un error en alguna de ellas, generalmente es dif√≠cil notarlo. <br><br>  Conclusi√≥n  Como escrib√≠ anteriormente, aleatorizar datos es malo.  Es mejor cubrir m√°s casos a expensas de los proveedores de datos, sin olvidar las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clases de equivalencia</a> , por supuesto.  Pasar las pruebas llevar√° m√°s tiempo, pero puedes combatirlo.  Pero nos aseguraremos de que si hay un problema, se detectar√°. <br><a name="atom_tests_1"></a><br><h2>  Atomicidad de las pruebas (parte 1) </h2><br>  Veamos el siguiente ejemplo.  Estamos escribiendo una prueba que verifica el contador de usuarios en el pie de p√°gina. <br><br><img width="651" src="https://habrastorage.org/webt/9j/n4/ws/9jn4wsd3jlh_wdnoiwrkjdfho9s.png"><br><br>  El escenario es simple: <br><br><ul><li>  Aplicaci√≥n abierta </li><li>  Encontrar contador de pie de p√°gina </li><li>  Aseg√∫rate de que sea visible </li></ul><br>  Llamamos a tal prueba testFooterCounter y la ejecutamos.  Luego se hace necesario verificar que el contador no muestre cero.  Agregamos esta prueba a una prueba existente, ¬øpor qu√© no? <br><br>  Pero luego se hace necesario verificar que en el pie de p√°gina haya un enlace a la descripci√≥n del proyecto (el enlace "Acerca de nosotros").  ¬øEscribir una nueva prueba o agregar a una existente?  En el caso de una nueva prueba, tendremos que volver a subir la aplicaci√≥n, preparar al usuario (si revisamos el pie de p√°gina en la p√°gina autorizada), iniciar sesi√≥n, en general, pasar un tiempo precioso.  En tal situaci√≥n, cambiar el nombre de la prueba a testFooterCounterAndLinks parece una buena idea. <br><br>  Por un lado, este enfoque tiene ventajas: ahorrar tiempo, almacenar todos los controles de alguna parte de nuestra aplicaci√≥n (en este caso, pie de p√°gina) en un solo lugar. <br><br>  Pero hay un notable menos.  Si la prueba falla en la primera prueba, no verificaremos el resto del componente.  Suponga que una prueba falla en alguna rama, no por inestabilidad, sino por un error.  Que hacer  ¬øDevuelve una tarea que describe solo este problema?  Luego corremos el riesgo de obtener una tarea con una soluci√≥n de solo este error, ejecutamos una prueba y descubrimos que el componente tambi√©n se rompe a√∫n m√°s, en otro lugar.  Y puede haber muchas iteraciones de este tipo.  Patear un boleto de ida y vuelta en este caso tomar√° mucho tiempo y ser√° ineficaz. <br><br>  Conclusi√≥n: si es posible, atomice los cheques.  En este caso, incluso teniendo un problema en un caso, verificaremos todos los dem√°s.  Y, si tiene que devolver el boleto, podemos describir inmediatamente todas las √°reas problem√°ticas. <br><a name="atom_tests_2"></a><br><h2>  Atomicidad de las pruebas (parte 2) </h2><br>  Considere otro ejemplo.  Estamos escribiendo una prueba de chat que verifica la siguiente l√≥gica.  Si los usuarios tienen simpat√≠a mutua, el siguiente bloque de promoci√≥n aparece en el chat: <br><br><img width="550" src="https://habrastorage.org/webt/2o/v8/kp/2ov8kp9mojel1g_txzatwy91nig.png"><br><br>  El escenario es el siguiente: <br><br><ul><li>  Vote por el usuario A para el usuario B </li><li>  Vote por el usuario B para el usuario A </li><li>  El usuario A abre el chat con el usuario B </li><li>  Confirme que la unidad est√© en su lugar </li></ul><br>  Durante alg√∫n tiempo, la prueba funciona con √©xito, pero luego sucede lo siguiente ... No, esta vez la prueba no pierde ning√∫n error.  :) <br><br>  Despu√©s de un tiempo, descubrimos que hay otro error no relacionado con nuestra prueba: si abre un chat, ci√©rrelo inmediatamente y vuelva a abrirlo, el bloqueo desaparece.  No es el caso m√°s obvio, y en la prueba, por supuesto, no lo previmos.  Pero decidimos que necesitamos cubrirlo tambi√©n. <br><br>  Surge la misma pregunta: ¬øescribir otra prueba o insertar una prueba en una existente?  Escribir uno nuevo parece inapropiado, porque el 99% del tiempo har√° lo mismo que el existente.  Y decidimos agregar la prueba a la prueba que ya est√° all√≠: <br><br><ul><li>  Vote por el usuario A para el usuario B </li><li>  Vote por el usuario B para el usuario A </li><li>  El usuario A abre el chat con el usuario B </li><li>  Confirme que la unidad est√© en su lugar </li><li>  <b>Cerrar chat</b> </li><li>  <b>Chat abierto</b> </li><li>  Confirme que la unidad est√© en su lugar </li></ul><br>  Puede surgir un problema cuando, por ejemplo, refactorizamos una prueba despu√©s de mucho tiempo.  Por ejemplo, se realizar√° un redise√±o en un proyecto, y tendr√° que reescribir muchas pruebas. <br><br>  Abriremos la prueba e intentaremos recordar lo que verifica.  Por ejemplo, una prueba se llama testPromoAfterMutualAttraction.  ¬øEntendemos por qu√© la apertura y el cierre del chat se escriben al final?  Lo m√°s probable es que no.  Especialmente si esta prueba no fue escrita por nosotros.  ¬øDejaremos esta pieza?  Quiz√°s s√≠, pero si hay alg√∫n problema con √©l, es probable que simplemente lo borremos.  Y la verificaci√≥n se perder√° simplemente porque su significado no ser√° obvio. <br><br>  Veo dos soluciones aqu√≠.  Primero: a√∫n haga la segunda prueba y ll√°mela testCheckBlockPresentAfterOpenAndCloseChat.  Con tal nombre, quedar√° claro que no solo estamos haciendo un cierto conjunto de acciones, sino que estamos haciendo un control muy consciente, porque hubo una experiencia negativa.  La segunda soluci√≥n es escribir un comentario detallado en el c√≥digo sobre por qu√© estamos haciendo esta prueba en esta prueba en particular.  Tambi√©n es recomendable indicar el n√∫mero de error en el comentario. <br><a name="click_error"></a><br><h2>  Error al hacer clic en un elemento existente </h2><br>  ¬°El siguiente ejemplo me arroj√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">bbidox</a> , por lo que es una gran ventaja en el karma! <br><br>  Hay una situaci√≥n muy interesante cuando el c√≥digo de prueba ya se convierte en ... un marco.  Supongamos que tenemos un m√©todo como este: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clickSomeButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WebElement button_element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForButtonToAppear(); button_element.click(); }</code> </pre><br>  En alg√∫n momento, algo extra√±o comienza a suceder con este m√©todo: la prueba se bloquea cuando intentas hacer clic en un bot√≥n.  Abrimos la captura de pantalla tomada en el momento en que se bloque√≥ la prueba, y vemos que hay un bot√≥n en la captura de pantalla y el m√©todo waitForButtonToAppear funcion√≥ con √©xito.  Pregunta: ¬øqu√© hay de malo con el clic? <br><br>  La parte m√°s dif√≠cil en esta situaci√≥n es que la prueba a veces puede tener √©xito.  :) <br><br>  Vamos a hacerlo bien.  Supongamos que el bot√≥n considerado en el ejemplo se encuentra en una superposici√≥n de este tipo: <br><br><img width="550" src="https://habrastorage.org/webt/pe/77/bd/pe77bddhspi2hdw1eagnzk8iydm.png"><br><br>  Esta es una superposici√≥n especial a trav√©s de la cual un usuario en nuestro sitio web puede completar informaci√≥n sobre s√≠ mismo.  Cuando hace clic en el bot√≥n de superposici√≥n resaltado, el siguiente bloque parece llenarse. <br><br>  Por diversi√≥n, agreguemos una clase OLOLO adicional para este bot√≥n: <br><br><img width="550" src="https://habrastorage.org/webt/ul/qv/fj/ulqvfjphig982sp-ntzfcmwdc0q.png"><br><br>  Despu√©s de lo cual hacemos clic en este bot√≥n.  Visualmente, nada ha cambiado, pero el bot√≥n en s√≠ se ha mantenido en su lugar: <br><br><img width="550" src="https://habrastorage.org/webt/86/os/3x/86os3xs2ycobeqm75psth6xuidk.png"><br><br>  Que paso  De hecho, cuando JS volvi√≥ a dibujar el bloque para nosotros, tambi√©n volvi√≥ a dibujar el bot√≥n.  Todav√≠a est√° disponible en el mismo localizador, pero este es otro bot√≥n.  Esto se evidencia por la falta de la clase OLOLO que agregamos. <br><br>  En el c√≥digo anterior, almacenamos el elemento en la variable $ element.  Si un elemento se regenera durante este tiempo, puede que no sea visible visualmente, pero ya no puede hacer clic en √©l; el m√©todo click () fallar√°. <br><br>  Hay varias soluciones: <br><br><ul><li>  Haga clic de ajuste en el bloque de prueba y en el elemento de reconstrucci√≥n de captura </li><li>  Agregue un bot√≥n a un atributo para indicar que ha cambiado </li></ul><br><a name="error_message"></a><h2>  Texto de error </h2><br>  Finalmente, un punto simple, pero no menos importante. <br><br>  Este ejemplo se aplica no solo a las pruebas de IU, sino que tambi√©n ocurre con mucha frecuencia en ellas.  Por lo general, cuando escribe una prueba, se encuentra en el contexto de lo que est√° sucediendo: describe la verificaci√≥n despu√©s de la verificaci√≥n y comprende su significado.  Y escribes textos de error en el mismo contexto: <br><br><pre> <code class="java hljs">WebElement element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">"a.link"</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find button"</span></span>);</code> </pre><br>  ¬øQu√© podr√≠a ser incomprensible en este c√≥digo?  La prueba espera la aparici√≥n de un bot√≥n y, si no est√° all√≠, cae naturalmente. <br><br>  Ahora imagine que el autor de la prueba est√° de baja por enfermedad, y su colega se ocupa de las pruebas.  Y luego deja caer la prueba testQuestionsOnProfile y escribe este mensaje: "No se puede encontrar el bot√≥n".  Un colega debe comprender lo que est√° sucediendo lo m√°s r√°pido posible, porque el lanzamiento llegar√° pronto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/pe/dv/bapedvs1g2gplrhebyipl0p7cl0.gif"></div><br><br>  ¬øQu√© tendr√° que hacer √©l? <br><br>  No tiene sentido abrir la p√°gina en la que se realiz√≥ la prueba y verificar el localizador "a.link": no hay ning√∫n elemento.  Por lo tanto, debe estudiar cuidadosamente la prueba y descubrir qu√© verifica. <br><br>  Ser√≠a mucho m√°s simple con un texto de error m√°s detallado: "No se puede encontrar el bot√≥n de env√≠o en la superposici√≥n de preguntas".  Con tal error, puede abrir inmediatamente la superposici√≥n y ver d√≥nde fue el bot√≥n. <br><br>  Salida dos.  En primer lugar, vale la pena pasar el texto de error a cualquier m√©todo de su marco de prueba, y es un par√°metro obligatorio para que no haya tentaci√≥n de olvidarlo.  En segundo lugar, el texto del error debe hacerse detallado.  Esto no siempre significa que debe ser largo, es suficiente para dejar en claro qu√© sali√≥ mal en la prueba. <br><br>  ¬øC√≥mo entender que el texto del error est√° bien escrito?  Muy simple  Imagine que su aplicaci√≥n se ha roto y necesita ir a los desarrolladores y explicar qu√© y d√≥nde se rompi√≥.  Si solo les dice lo que est√° escrito en el texto del error, ¬ølo entender√°n? <br><a name="summary"></a><br><h2>  Resumen </h2><br>  Escribir un gui√≥n de prueba es a menudo una actividad interesante.  Al mismo tiempo, perseguimos muchos objetivos.  Nuestras pruebas deber√≠an: <br><br><ul><li>  cubrir tantos casos como sea posible </li><li>  trabajar lo m√°s r√°pido posible </li><li>  para ser entendido </li><li>  solo expande </li><li>  f√°cil de mantener </li><li>  pedir pizza </li><li>  y as√≠ sucesivamente ... </li></ul><br>  Es especialmente interesante trabajar con pruebas en un proyecto en constante evoluci√≥n y cambio, en el que deben actualizarse constantemente: agregar algo y cortar algo.  Es por eso que vale la pena pensar en algunos puntos de antemano y no siempre apresurarse con las decisiones.  :) <br><br>  Espero que mis consejos lo ayuden a evitar algunos problemas y lo hagan reflexivo en los estudios de casos.  Si al p√∫blico le gusta el art√≠culo, intentar√© recopilar algunos ejemplos m√°s aburridos.  Mientras tanto, ¬°chao! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419419/">https://habr.com/ru/post/es419419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419409/index.html">Nuevos NUC Intel basados ‚Äã‚Äãen procesadores Coffee Lake</a></li>
<li><a href="../es419411/index.html">Sobre el incendio en un rascacielos. Cine y realidad</a></li>
<li><a href="../es419413/index.html">Cincel - (no del todo) un nuevo enfoque para el desarrollo de la l√≥gica digital</a></li>
<li><a href="../es419415/index.html">Mattermost y Powershell: gran potencia o peque√±a automatizaci√≥n en el hogar</a></li>
<li><a href="../es419417/index.html">GDPR: mapeo de datos o c√≥mo los clientes encuentran computadoras port√°tiles olvidadas hace mucho tiempo</a></li>
<li><a href="../es419423/index.html">Se nos promete un video en tiempo real sin frisos y contracciones</a></li>
<li><a href="../es419425/index.html">Semana de seguridad 29. Hackear Reddit, una billetera para criptomonedas y enrutadores MikroTik</a></li>
<li><a href="../es419427/index.html">Epson invita a todos al picnic para geeks 2018</a></li>
<li><a href="../es419429/index.html">Tengo 57 a√±os y soy un maestro scrum</a></li>
<li><a href="../es419433/index.html">Informes DSW - Generador de informes DeepSeeWeb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>