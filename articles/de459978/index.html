<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑üèº üë¶üèº ü§∞üèæ Node.js Entwicklertools. Remoteprozeduraufruf an Web-Sockets üë®üèø‚Äçü§ù‚Äçüë®üèΩ üíÉüèæ üì∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Horrorgeschichten erz√§hlen oft von der Websocket-Technologie, zum Beispiel, dass sie von Webbrowsern nicht unterst√ºtzt wird oder dass Anbieter / Admin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js Entwicklertools. Remoteprozeduraufruf an Web-Sockets</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459978/"> Horrorgeschichten erz√§hlen oft von der Websocket-Technologie, zum Beispiel, dass sie von Webbrowsern nicht unterst√ºtzt wird oder dass Anbieter / Administratoren den Websocket-Verkehr unterdr√ºcken - daher kann sie nicht in Anwendungen verwendet werden.  Andererseits sehen Entwickler nicht immer die Fallstricke voraus, die die Websocket-Technologie wie jede andere Technologie hat.  Zu den angeblichen Einschr√§nkungen m√∂chte ich sofort sagen, dass 96,8% der Webbrowser heute die Websocket-Technologie unterst√ºtzen.  Man kann sagen, dass 3,2%, die √ºber Bord bleiben, viel sind, das sind Millionen von Benutzern.  Ich stimme dir vollkommen zu.  Im Vergleich ist nur alles bekannt.  Dieselbe XmlHttpRequest, die seit vielen Jahren in Ajax verwendet wird, unterst√ºtzt 97,17% der Webbrowser (nicht viel mehr, oder?) Und ruft im Allgemeinen 93,08% der Webbrowser ab.  Im Gegensatz zu Websocket hat ein solcher Prozentsatz (und fr√ºher war er sogar noch niedriger) niemanden lange Zeit daran gehindert, die Ajax-Technologie zu verwenden.  Daher macht die Verwendung von Fallback bei langen Abfragen derzeit keinen Sinn.  Wenn nur, weil Webbrowser, die Websocket nicht unterst√ºtzen, dieselben Webbrowser sind, die XmlHttpRequest nicht unterst√ºtzen, und in Wirklichkeit kein Fallback auftritt. <br><br>  Die zweite Horrorgeschichte, die das Verbot von Websockets von Anbietern oder Administratoren von Unternehmensnetzwerken vorsieht, ist ebenfalls unvern√ºnftig, da jetzt jeder das https-Protokoll verwendet und es unm√∂glich ist zu verstehen, dass die Websocket-Verbindung offen ist (ohne https zu unterbrechen). <br><br>  In diesem Beitrag werde ich am Beispiel der Entwicklung des Webadministrationsbereichs der Anwendung die tats√§chlichen Einschr√§nkungen und M√∂glichkeiten zur √úberwindung dieser Einschr√§nkungen erl√§utern. <br><a name="habracut"></a><br>  Das WebSocket-Objekt im Webbrowser verf√ºgt also offen gesagt √ºber eine sehr pr√§zise Reihe von Methoden: send () und close () sowie die vom EventTarget-Objekt geerbten Methoden addEventListener (), removeEventListener () und dispatchEvent ().  Daher muss der Entwickler Bibliotheken (normalerweise) oder unabh√§ngig (fast unm√∂glich) verwenden, um mehrere Probleme zu l√∂sen. <br><br>  Beginnen wir mit der verst√§ndlichsten Aufgabe.  Die Verbindung zum Server wird regelm√§√üig unterbrochen.  Das Wiederverbinden ist einfach genug.  Wenn Sie sich jedoch daran erinnern, dass Nachrichten sowohl vom Client als auch vom Server zu diesem Zeitpunkt weiterhin gesendet werden, wird alles sofort und viel komplizierter.  Im Allgemeinen kann eine Nachricht verloren gehen, wenn kein Best√§tigungsmechanismus f√ºr die empfangene Nachricht bereitgestellt wird, oder erneut zugestellt werden (sogar mehrmals), wenn ein Best√§tigungsmechanismus bereitgestellt wird. Der Fehler trat jedoch erst im Moment nach dem Empfang und vor der Best√§tigung der Nachricht auf. <br><br>  Wenn Sie eine garantierte Nachrichten√ºbermittlung und / oder Nachrichten√ºbermittlung ohne Duplikate ben√∂tigen, gibt es spezielle Protokolle f√ºr die Implementierung, z. B. AMQP und MQTT, die auch mit dem Websocket-Transport funktionieren.  Aber heute werden wir sie nicht ber√ºcksichtigen. <br><br>  Die meisten Bibliotheken f√ºr die Arbeit mit Websocket unterst√ºtzen transparent f√ºr den Programmierer, der sich wieder mit dem Server verbindet.  Die Verwendung einer solchen Bibliothek ist immer zuverl√§ssiger als die Entwicklung Ihrer Implementierung. <br><br>  Als N√§chstes m√ºssen Sie die Infrastruktur zum Senden und Empfangen von asynchronen Nachrichten implementieren.  Verwenden Sie dazu den "nackten" onmessage-Ereignishandler ohne zus√§tzliche Bindung, eine undankbare Aufgabe.  Eine solche Infrastruktur kann beispielsweise ein Remote Procedure Call (RPC) sein.  Die ID-ID wurde in die json-rpc-Spezifikation aufgenommen, speziell f√ºr die Arbeit mit dem Websocket-Transport, mit dem Sie den Remoteprozeduraufruf des Clients der Antwortnachricht vom Webserver zuordnen k√∂nnen.  Ich w√ºrde dieses Protokoll allen anderen M√∂glichkeiten vorziehen, aber bisher habe ich keine erfolgreiche Implementierung dieses Protokolls f√ºr den Serverteil auf node.js gefunden. <br><br>  Und schlie√ülich m√ºssen Sie die Skalierung implementieren.  Denken Sie daran, dass die Verbindung zwischen dem Client und dem Server regelm√§√üig hergestellt wird.  Wenn uns die Leistung eines Servers nicht ausreicht, k√∂nnen wir mehrere weitere Server erh√∂hen.  In diesem Fall kann nach dem Trennen der Verbindung die Verbindung zu demselben Server nicht garantiert werden.  In der Regel wird ein Redis-Server oder ein Cluster von Redis-Servern verwendet, um mehrere Websocket-Server zu koordinieren. <br><br>  Und leider werden wir fr√ºher oder sp√§ter ohnehin auf die Systemleistung sto√üen, da die F√§higkeiten von node.js in Bezug auf die Anzahl der gleichzeitig ge√∂ffneten Websocket-Verbindungen (verwechseln Sie dies nicht mit der Leistung) erheblich geringer sind als bei spezialisierten Servern wie Nachrichtenwarteschlangen und Brokern.  Und die Notwendigkeit eines gegenseitigen Austauschs zwischen allen Instanzen von Websocket-Servern √ºber einen Redis-Server-Cluster wird nach einem kritischen Punkt die Anzahl offener Verbindungen nicht wesentlich erh√∂hen.  Die L√∂sung dieses Problems besteht darin, spezialisierte Server wie AMQP und MQTT zu verwenden, die auch beim Websocket-Transport funktionieren.  Aber heute werden wir sie nicht ber√ºcksichtigen. <br><br>  Wie Sie der Liste der aufgelisteten Aufgaben entnehmen k√∂nnen, ist das Radfahren w√§hrend der Arbeit mit Websocket √§u√üerst zeitaufw√§ndig und sogar unm√∂glich, wenn Sie die L√∂sung auf mehrere Websocket-Server skalieren m√ºssen. <br><br>  Daher schlage ich vor, mehrere beliebte Bibliotheken in Betracht zu ziehen, die die Arbeit mit Websocket implementieren. <br><br>  Ich werde diejenigen Bibliotheken, die ausschlie√ülich auf veraltete Verkehrstr√§ger zur√ºckgreifen, sofort von der Pr√ºfung ausschlie√üen, da diese Funktionalit√§t heute nicht relevant ist, und Bibliotheken, die in der Regel eine breitere Funktionalit√§t implementieren, auch auf veraltete Verkehrstr√§ger zur√ºckgreifen. <br><br>  Ich beginne mit der beliebtesten Bibliothek - socket.io.  Jetzt k√∂nnen Sie die wahrscheinlich faire Meinung h√∂ren, dass diese Bibliothek in Bezug auf Ressourcen langsam und teuer ist.  H√∂chstwahrscheinlich ist es so und es funktioniert langsamer als ein nativer Websocket.  Heute ist es jedoch die am weitesten entwickelte Bibliothek.  Bei der Arbeit mit Websocket ist der Hauptbegrenzungsfaktor nicht die Geschwindigkeit, sondern die Anzahl der gleichzeitig offenen Verbindungen mit eindeutigen Clients.  Und diese Frage l√§sst sich am besten bereits l√∂sen, indem Verbindungen mit Clients zu spezialisierten Servern hergestellt werden. <br><br>  So implementiert soket.io eine zuverl√§ssige Wiederherstellung, wenn die Verbindung zum Server getrennt und die Skalierung mithilfe eines Servers oder eines Clusters von Redis-Servern durchgef√ºhrt wird.  In der Tat implementiert socket.io ein eigenes individuelles Messaging-Protokoll, mit dem Sie Messaging zwischen Client und Server implementieren k√∂nnen, ohne an eine bestimmte Programmiersprache gebunden zu sein. <br><br>  Eine interessante Funktion von socket.io ist die Best√§tigung der Ereignisverarbeitung, bei der ein beliebiges Objekt vom Server an den Client zur√ºckgegeben werden kann, wodurch Remoteprozeduraufrufe m√∂glich sind (obwohl es nicht dem json-rpc-Standard entspricht). <br><br>  Au√üerdem habe ich vorl√§ufig zwei weitere interessante Bibliotheken untersucht, auf die ich im Folgenden kurz eingehen werde. <br><br>  Faye Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">faye.jcoglan.com</a> .  Es implementiert das Bayeux-Protokoll, das im CometD-Projekt entwickelt wurde, und implementiert das Abonnieren / Verteilen von Nachrichten an Nachrichtenkan√§le.  Dieses Projekt unterst√ºtzt auch die Skalierung mithilfe eines Servers oder eines Clusters von Redis-Servern.  Ein Versuch, einen Weg zur Implementierung von RPC zu finden, war erfolglos, da er nicht in das Bayeux-Protokollschema passte. <br><br>  Im Projekt socketcluster <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">socketcluster.io</a> liegt der Schwerpunkt auf der Skalierung des Websocket-Servers.  Gleichzeitig wird der Websocket-Server-Cluster nicht wie in den beiden erstgenannten Bibliotheken auf Basis des Redis-Servers erstellt, sondern auf Basis von node.js.  In dieser Hinsicht war es bei der Bereitstellung des Clusters erforderlich, eine recht komplexe Infrastruktur von Maklern und Arbeitnehmern einzurichten. <br><br>  Fahren wir nun mit der Implementierung von RPC auf socket.io fort.  Wie oben erw√§hnt, hat diese Bibliothek bereits die M√∂glichkeit implementiert, Objekte zwischen Client und Server auszutauschen: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'socket.io-client'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> socket = io({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-string"><span class="hljs-string">'websocket'</span></span>] }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remoteCall = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { socket.emit(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, data, (response) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) { reject(response); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { resolve(response); } }); });</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>).createServer(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> io = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'socket.io'</span></span>)(server, { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span> }); io.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, (socket) =&gt; { socket.on(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (data, callback) =&gt; { handleRemoteCall(socket, data, callback); }); }); server.listen(<span class="hljs-number"><span class="hljs-number">5000</span></span>, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'dashboard backend listening on *:5000'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleRemoteCall = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">socket, data, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response =... callback(response) }</code> </pre><br>  Dies ist das allgemeine Schema.  Nun werden wir jeden der Teile in Bezug auf eine bestimmte Anwendung betrachten.  Um das Admin-Panel zu erstellen, habe ich die React-Admin-Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/marmelab/react-admin verwendet</a> .  Der Datenaustausch mit dem Server in dieser Bibliothek wird mithilfe eines Datenanbieters implementiert, der ein sehr praktisches Schema aufweist, fast eine Art Standard.  Um beispielsweise eine Liste zu erhalten, wird die Methode aufgerufen: <br><br><pre> <code class="javascript hljs">dataProvider( <span class="hljs-string"><span class="hljs-string">'GET_LIST'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, { <span class="hljs-attr"><span class="hljs-attr">pagination</span></span>: { <span class="hljs-attr"><span class="hljs-attr">page</span></span>: {int}, <span class="hljs-attr"><span class="hljs-attr">perPage</span></span>: {int} }, <span class="hljs-attr"><span class="hljs-attr">sort</span></span>: { <span class="hljs-attr"><span class="hljs-attr">field</span></span>: {string}, <span class="hljs-attr"><span class="hljs-attr">order</span></span>: {string} }, <span class="hljs-attr"><span class="hljs-attr">filter</span></span>: { <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span> } }</code> </pre><br>  Diese Methode in einer asynchronen Antwort gibt ein Objekt zur√ºck: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: [  ], <span class="hljs-attr"><span class="hljs-attr">total</span></span>:      }</code> </pre><br>  Derzeit gibt es eine beeindruckende Anzahl von Implementierungen von React-Admin-Datenanbietern f√ºr verschiedene Server und Frameworks (z. B. Firebase, Spring Boot, Graphql usw.).  Im Fall von RPC erwies sich die Implementierung als die pr√§gnanteste, da das Objekt in seiner urspr√ºnglichen Form an den Funktionsaufruf emit √ºbertragen wird: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'socket.io-client'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> socket = io({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-string"><span class="hljs-string">'websocket'</span></span>] }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (action, collection, payload = {}) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { socket.emit(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, {action, collection, payload}, (response) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) { reject(response); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { resolve(response); } }); });</code> </pre><br>  Leider musste auf der Serverseite etwas mehr Arbeit geleistet werden.  Um die Zuordnung von Funktionen zu organisieren, die den Remote-Aufruf verarbeiten, wurde ein Router √§hnlich wie express.js entwickelt.  Nur anstelle der Middleware-Signatur (req, res, next) st√ºtzt sich die Implementierung auf die Signatur (Socket, Payload, Callback).  Als Ergebnis haben wir alle den √ºblichen Code erhalten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Router = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./router'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = Router(); router.use(<span class="hljs-string"><span class="hljs-string">'GET_LIST'</span></span>, (socket, payload, callback) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> limit = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(payload.pagination.perPage); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">(payload.pagination.page</span></span></span><span class="hljs-function">) - 1) * </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">limit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{data: users.slice(offset, offset + limit </span></span></span><span class="hljs-function">), </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">}); }); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">router</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">use</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'GET_ONE'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (socket, payload, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: users[payload.id]}); }); router.use(<span class="hljs-string"><span class="hljs-string">'UPDATE'</span></span>, (socket, payload, callback) =&gt; { users[payload.id] = payload.data <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: users[payload.id] }); }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; i++) { users.push({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: i, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`name of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i}</span></span></span><span class="hljs-string">`</span></span>}); }</code> </pre><br>  Details zur Implementierung des Routers finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Projekt-Repository.</a> <br><br>  Sie m√ºssen lediglich einen Anbieter f√ºr die Admin-Komponente zuweisen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Admin, Resource, EditGuesser } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-admin'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UserList <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./UserList'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataProvider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./wsProvider'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;Admin dataProvider={dataProvider}&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Resource</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"users"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">list</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{UserList}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">edit</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{EditGuesser}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Admin</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> App;</code> </pre><br><br>  N√ºtzliche Links <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. www.infoq.com/articles/Web-Sockets-Proxy-Servers</a> <br><br>  apapacy@gmail.com <br>  14. Juli 2019 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459978/">https://habr.com/ru/post/de459978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459964/index.html">8 einfache UI-Tricks, um ein Prototyp-Design dynamisch zu gestalten, ohne auf Animation zur√ºckgreifen zu m√ºssen</a></li>
<li><a href="../de459968/index.html">Was wirklich mit der verschwundenen malaysischen Boeing passiert ist (Teil 3/3)</a></li>
<li><a href="../de459970/index.html">Promise.allSettled</a></li>
<li><a href="../de459972/index.html">Entwicklung f√ºr Docker. Lokale Umgebung. Teil 1</a></li>
<li><a href="../de459976/index.html">Neuer Nemesida WAF Free Build f√ºr NGINX</a></li>
<li><a href="../de459980/index.html">High-Tech nigerianische Briefe</a></li>
<li><a href="../de459982/index.html">Roslyn-Analysatoren. So schreiben Sie schnell und genau Code</a></li>
<li><a href="../de459984/index.html">Aufbau einer Infrastruktur als Code mit GitLab und Ansible</a></li>
<li><a href="../de459988/index.html">Der Hund a√ü in neuronalen Netzen</a></li>
<li><a href="../de459990/index.html">Immersion in Move - Facebooks Programmiersprache Libra Blockchain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>