<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏼 👦🏼 🤰🏾 Node.js Entwicklertools. Remoteprozeduraufruf an Web-Sockets 👨🏿‍🤝‍👨🏽 💃🏾 📸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Horrorgeschichten erzählen oft von der Websocket-Technologie, zum Beispiel, dass sie von Webbrowsern nicht unterstützt wird oder dass Anbieter / Admin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js Entwicklertools. Remoteprozeduraufruf an Web-Sockets</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459978/"> Horrorgeschichten erzählen oft von der Websocket-Technologie, zum Beispiel, dass sie von Webbrowsern nicht unterstützt wird oder dass Anbieter / Administratoren den Websocket-Verkehr unterdrücken - daher kann sie nicht in Anwendungen verwendet werden.  Andererseits sehen Entwickler nicht immer die Fallstricke voraus, die die Websocket-Technologie wie jede andere Technologie hat.  Zu den angeblichen Einschränkungen möchte ich sofort sagen, dass 96,8% der Webbrowser heute die Websocket-Technologie unterstützen.  Man kann sagen, dass 3,2%, die über Bord bleiben, viel sind, das sind Millionen von Benutzern.  Ich stimme dir vollkommen zu.  Im Vergleich ist nur alles bekannt.  Dieselbe XmlHttpRequest, die seit vielen Jahren in Ajax verwendet wird, unterstützt 97,17% der Webbrowser (nicht viel mehr, oder?) Und ruft im Allgemeinen 93,08% der Webbrowser ab.  Im Gegensatz zu Websocket hat ein solcher Prozentsatz (und früher war er sogar noch niedriger) niemanden lange Zeit daran gehindert, die Ajax-Technologie zu verwenden.  Daher macht die Verwendung von Fallback bei langen Abfragen derzeit keinen Sinn.  Wenn nur, weil Webbrowser, die Websocket nicht unterstützen, dieselben Webbrowser sind, die XmlHttpRequest nicht unterstützen, und in Wirklichkeit kein Fallback auftritt. <br><br>  Die zweite Horrorgeschichte, die das Verbot von Websockets von Anbietern oder Administratoren von Unternehmensnetzwerken vorsieht, ist ebenfalls unvernünftig, da jetzt jeder das https-Protokoll verwendet und es unmöglich ist zu verstehen, dass die Websocket-Verbindung offen ist (ohne https zu unterbrechen). <br><br>  In diesem Beitrag werde ich am Beispiel der Entwicklung des Webadministrationsbereichs der Anwendung die tatsächlichen Einschränkungen und Möglichkeiten zur Überwindung dieser Einschränkungen erläutern. <br><a name="habracut"></a><br>  Das WebSocket-Objekt im Webbrowser verfügt also offen gesagt über eine sehr präzise Reihe von Methoden: send () und close () sowie die vom EventTarget-Objekt geerbten Methoden addEventListener (), removeEventListener () und dispatchEvent ().  Daher muss der Entwickler Bibliotheken (normalerweise) oder unabhängig (fast unmöglich) verwenden, um mehrere Probleme zu lösen. <br><br>  Beginnen wir mit der verständlichsten Aufgabe.  Die Verbindung zum Server wird regelmäßig unterbrochen.  Das Wiederverbinden ist einfach genug.  Wenn Sie sich jedoch daran erinnern, dass Nachrichten sowohl vom Client als auch vom Server zu diesem Zeitpunkt weiterhin gesendet werden, wird alles sofort und viel komplizierter.  Im Allgemeinen kann eine Nachricht verloren gehen, wenn kein Bestätigungsmechanismus für die empfangene Nachricht bereitgestellt wird, oder erneut zugestellt werden (sogar mehrmals), wenn ein Bestätigungsmechanismus bereitgestellt wird. Der Fehler trat jedoch erst im Moment nach dem Empfang und vor der Bestätigung der Nachricht auf. <br><br>  Wenn Sie eine garantierte Nachrichtenübermittlung und / oder Nachrichtenübermittlung ohne Duplikate benötigen, gibt es spezielle Protokolle für die Implementierung, z. B. AMQP und MQTT, die auch mit dem Websocket-Transport funktionieren.  Aber heute werden wir sie nicht berücksichtigen. <br><br>  Die meisten Bibliotheken für die Arbeit mit Websocket unterstützen transparent für den Programmierer, der sich wieder mit dem Server verbindet.  Die Verwendung einer solchen Bibliothek ist immer zuverlässiger als die Entwicklung Ihrer Implementierung. <br><br>  Als Nächstes müssen Sie die Infrastruktur zum Senden und Empfangen von asynchronen Nachrichten implementieren.  Verwenden Sie dazu den "nackten" onmessage-Ereignishandler ohne zusätzliche Bindung, eine undankbare Aufgabe.  Eine solche Infrastruktur kann beispielsweise ein Remote Procedure Call (RPC) sein.  Die ID-ID wurde in die json-rpc-Spezifikation aufgenommen, speziell für die Arbeit mit dem Websocket-Transport, mit dem Sie den Remoteprozeduraufruf des Clients der Antwortnachricht vom Webserver zuordnen können.  Ich würde dieses Protokoll allen anderen Möglichkeiten vorziehen, aber bisher habe ich keine erfolgreiche Implementierung dieses Protokolls für den Serverteil auf node.js gefunden. <br><br>  Und schließlich müssen Sie die Skalierung implementieren.  Denken Sie daran, dass die Verbindung zwischen dem Client und dem Server regelmäßig hergestellt wird.  Wenn uns die Leistung eines Servers nicht ausreicht, können wir mehrere weitere Server erhöhen.  In diesem Fall kann nach dem Trennen der Verbindung die Verbindung zu demselben Server nicht garantiert werden.  In der Regel wird ein Redis-Server oder ein Cluster von Redis-Servern verwendet, um mehrere Websocket-Server zu koordinieren. <br><br>  Und leider werden wir früher oder später ohnehin auf die Systemleistung stoßen, da die Fähigkeiten von node.js in Bezug auf die Anzahl der gleichzeitig geöffneten Websocket-Verbindungen (verwechseln Sie dies nicht mit der Leistung) erheblich geringer sind als bei spezialisierten Servern wie Nachrichtenwarteschlangen und Brokern.  Und die Notwendigkeit eines gegenseitigen Austauschs zwischen allen Instanzen von Websocket-Servern über einen Redis-Server-Cluster wird nach einem kritischen Punkt die Anzahl offener Verbindungen nicht wesentlich erhöhen.  Die Lösung dieses Problems besteht darin, spezialisierte Server wie AMQP und MQTT zu verwenden, die auch beim Websocket-Transport funktionieren.  Aber heute werden wir sie nicht berücksichtigen. <br><br>  Wie Sie der Liste der aufgelisteten Aufgaben entnehmen können, ist das Radfahren während der Arbeit mit Websocket äußerst zeitaufwändig und sogar unmöglich, wenn Sie die Lösung auf mehrere Websocket-Server skalieren müssen. <br><br>  Daher schlage ich vor, mehrere beliebte Bibliotheken in Betracht zu ziehen, die die Arbeit mit Websocket implementieren. <br><br>  Ich werde diejenigen Bibliotheken, die ausschließlich auf veraltete Verkehrsträger zurückgreifen, sofort von der Prüfung ausschließen, da diese Funktionalität heute nicht relevant ist, und Bibliotheken, die in der Regel eine breitere Funktionalität implementieren, auch auf veraltete Verkehrsträger zurückgreifen. <br><br>  Ich beginne mit der beliebtesten Bibliothek - socket.io.  Jetzt können Sie die wahrscheinlich faire Meinung hören, dass diese Bibliothek in Bezug auf Ressourcen langsam und teuer ist.  Höchstwahrscheinlich ist es so und es funktioniert langsamer als ein nativer Websocket.  Heute ist es jedoch die am weitesten entwickelte Bibliothek.  Bei der Arbeit mit Websocket ist der Hauptbegrenzungsfaktor nicht die Geschwindigkeit, sondern die Anzahl der gleichzeitig offenen Verbindungen mit eindeutigen Clients.  Und diese Frage lässt sich am besten bereits lösen, indem Verbindungen mit Clients zu spezialisierten Servern hergestellt werden. <br><br>  So implementiert soket.io eine zuverlässige Wiederherstellung, wenn die Verbindung zum Server getrennt und die Skalierung mithilfe eines Servers oder eines Clusters von Redis-Servern durchgeführt wird.  In der Tat implementiert socket.io ein eigenes individuelles Messaging-Protokoll, mit dem Sie Messaging zwischen Client und Server implementieren können, ohne an eine bestimmte Programmiersprache gebunden zu sein. <br><br>  Eine interessante Funktion von socket.io ist die Bestätigung der Ereignisverarbeitung, bei der ein beliebiges Objekt vom Server an den Client zurückgegeben werden kann, wodurch Remoteprozeduraufrufe möglich sind (obwohl es nicht dem json-rpc-Standard entspricht). <br><br>  Außerdem habe ich vorläufig zwei weitere interessante Bibliotheken untersucht, auf die ich im Folgenden kurz eingehen werde. <br><br>  Faye Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">faye.jcoglan.com</a> .  Es implementiert das Bayeux-Protokoll, das im CometD-Projekt entwickelt wurde, und implementiert das Abonnieren / Verteilen von Nachrichten an Nachrichtenkanäle.  Dieses Projekt unterstützt auch die Skalierung mithilfe eines Servers oder eines Clusters von Redis-Servern.  Ein Versuch, einen Weg zur Implementierung von RPC zu finden, war erfolglos, da er nicht in das Bayeux-Protokollschema passte. <br><br>  Im Projekt socketcluster <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">socketcluster.io</a> liegt der Schwerpunkt auf der Skalierung des Websocket-Servers.  Gleichzeitig wird der Websocket-Server-Cluster nicht wie in den beiden erstgenannten Bibliotheken auf Basis des Redis-Servers erstellt, sondern auf Basis von node.js.  In dieser Hinsicht war es bei der Bereitstellung des Clusters erforderlich, eine recht komplexe Infrastruktur von Maklern und Arbeitnehmern einzurichten. <br><br>  Fahren wir nun mit der Implementierung von RPC auf socket.io fort.  Wie oben erwähnt, hat diese Bibliothek bereits die Möglichkeit implementiert, Objekte zwischen Client und Server auszutauschen: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'socket.io-client'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> socket = io({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-string"><span class="hljs-string">'websocket'</span></span>] }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remoteCall = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { socket.emit(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, data, (response) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) { reject(response); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { resolve(response); } }); });</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>).createServer(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> io = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'socket.io'</span></span>)(server, { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span> }); io.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, (socket) =&gt; { socket.on(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (data, callback) =&gt; { handleRemoteCall(socket, data, callback); }); }); server.listen(<span class="hljs-number"><span class="hljs-number">5000</span></span>, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'dashboard backend listening on *:5000'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleRemoteCall = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">socket, data, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response =... callback(response) }</code> </pre><br>  Dies ist das allgemeine Schema.  Nun werden wir jeden der Teile in Bezug auf eine bestimmte Anwendung betrachten.  Um das Admin-Panel zu erstellen, habe ich die React-Admin-Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/marmelab/react-admin verwendet</a> .  Der Datenaustausch mit dem Server in dieser Bibliothek wird mithilfe eines Datenanbieters implementiert, der ein sehr praktisches Schema aufweist, fast eine Art Standard.  Um beispielsweise eine Liste zu erhalten, wird die Methode aufgerufen: <br><br><pre> <code class="javascript hljs">dataProvider( <span class="hljs-string"><span class="hljs-string">'GET_LIST'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, { <span class="hljs-attr"><span class="hljs-attr">pagination</span></span>: { <span class="hljs-attr"><span class="hljs-attr">page</span></span>: {int}, <span class="hljs-attr"><span class="hljs-attr">perPage</span></span>: {int} }, <span class="hljs-attr"><span class="hljs-attr">sort</span></span>: { <span class="hljs-attr"><span class="hljs-attr">field</span></span>: {string}, <span class="hljs-attr"><span class="hljs-attr">order</span></span>: {string} }, <span class="hljs-attr"><span class="hljs-attr">filter</span></span>: { <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span> } }</code> </pre><br>  Diese Methode in einer asynchronen Antwort gibt ein Objekt zurück: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: [  ], <span class="hljs-attr"><span class="hljs-attr">total</span></span>:      }</code> </pre><br>  Derzeit gibt es eine beeindruckende Anzahl von Implementierungen von React-Admin-Datenanbietern für verschiedene Server und Frameworks (z. B. Firebase, Spring Boot, Graphql usw.).  Im Fall von RPC erwies sich die Implementierung als die prägnanteste, da das Objekt in seiner ursprünglichen Form an den Funktionsaufruf emit übertragen wird: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'socket.io-client'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> socket = io({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-string"><span class="hljs-string">'websocket'</span></span>] }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (action, collection, payload = {}) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { socket.emit(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, {action, collection, payload}, (response) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) { reject(response); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { resolve(response); } }); });</code> </pre><br>  Leider musste auf der Serverseite etwas mehr Arbeit geleistet werden.  Um die Zuordnung von Funktionen zu organisieren, die den Remote-Aufruf verarbeiten, wurde ein Router ähnlich wie express.js entwickelt.  Nur anstelle der Middleware-Signatur (req, res, next) stützt sich die Implementierung auf die Signatur (Socket, Payload, Callback).  Als Ergebnis haben wir alle den üblichen Code erhalten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Router = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./router'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = Router(); router.use(<span class="hljs-string"><span class="hljs-string">'GET_LIST'</span></span>, (socket, payload, callback) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> limit = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(payload.pagination.perPage); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">(payload.pagination.page</span></span></span><span class="hljs-function">) - 1) * </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">limit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{data: users.slice(offset, offset + limit </span></span></span><span class="hljs-function">), </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">}); }); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">router</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">use</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'GET_ONE'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (socket, payload, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: users[payload.id]}); }); router.use(<span class="hljs-string"><span class="hljs-string">'UPDATE'</span></span>, (socket, payload, callback) =&gt; { users[payload.id] = payload.data <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: users[payload.id] }); }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; i++) { users.push({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: i, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`name of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i}</span></span></span><span class="hljs-string">`</span></span>}); }</code> </pre><br>  Details zur Implementierung des Routers finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Projekt-Repository.</a> <br><br>  Sie müssen lediglich einen Anbieter für die Admin-Komponente zuweisen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Admin, Resource, EditGuesser } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-admin'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UserList <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./UserList'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataProvider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./wsProvider'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;Admin dataProvider={dataProvider}&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Resource</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"users"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">list</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{UserList}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">edit</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{EditGuesser}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Admin</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> App;</code> </pre><br><br>  Nützliche Links <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. www.infoq.com/articles/Web-Sockets-Proxy-Servers</a> <br><br>  apapacy@gmail.com <br>  14. Juli 2019 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459978/">https://habr.com/ru/post/de459978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459964/index.html">8 einfache UI-Tricks, um ein Prototyp-Design dynamisch zu gestalten, ohne auf Animation zurückgreifen zu müssen</a></li>
<li><a href="../de459968/index.html">Was wirklich mit der verschwundenen malaysischen Boeing passiert ist (Teil 3/3)</a></li>
<li><a href="../de459970/index.html">Promise.allSettled</a></li>
<li><a href="../de459972/index.html">Entwicklung für Docker. Lokale Umgebung. Teil 1</a></li>
<li><a href="../de459976/index.html">Neuer Nemesida WAF Free Build für NGINX</a></li>
<li><a href="../de459980/index.html">High-Tech nigerianische Briefe</a></li>
<li><a href="../de459982/index.html">Roslyn-Analysatoren. So schreiben Sie schnell und genau Code</a></li>
<li><a href="../de459984/index.html">Aufbau einer Infrastruktur als Code mit GitLab und Ansible</a></li>
<li><a href="../de459988/index.html">Der Hund aß in neuronalen Netzen</a></li>
<li><a href="../de459990/index.html">Immersion in Move - Facebooks Programmiersprache Libra Blockchain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>