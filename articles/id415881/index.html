<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏽 👤 🥄 Bagaimana JS Bekerja: Shadow DOM Technology dan Komponen Web 👩🏾‍🤝‍👨🏿 👃🏿 👊🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Nasihat membaca] 19 bagian siklus lainnya  Bagian 1: Tinjauan umum mesin, mekanisme runtime, panggilan stack 
 Bagian 2: Tentang V8 internal dan opti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana JS Bekerja: Shadow DOM Technology dan Komponen Web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415881/"><div class="spoiler">  <b class="spoiler_title">[Nasihat membaca] 19 bagian siklus lainnya</b> <div class="spoiler_text">  Bagian 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tinjauan umum mesin, mekanisme runtime, panggilan stack</a> <br>  Bagian 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tentang V8 internal dan optimasi kode</a> <br>  Bagian 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengelola memori, empat jenis memori bocor dan berurusan dengannya</a> <br>  Bagian 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Event Loop, Async, dan Five Ways untuk Meningkatkan Kode Anda dengan async / menunggu</a> <br>  Bagian 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebSocket dan HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang harus dipilih?</a> <br>  Bagian 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fitur dan ruang lingkup WebAssembly</a> <br>  Bagian 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja Web dan Lima Skenario Penggunaan</a> <br>  Bagian 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja Layanan</a> <br>  Bagian 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemberitahuan push web</a> <br>  Bagian 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lacak perubahan di DOM dengan MutationObserver</a> <br>  Bagian 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin rendering halaman web dan tip untuk mengoptimalkan kinerja mereka</a> <br>  Bagian 12: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subsistem jaringan browser, mengoptimalkan kinerja dan keamanannya</a> <br>  Bagian 12: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subsistem jaringan browser, mengoptimalkan kinerja dan keamanannya</a> <br>  Bagian 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Animasi dengan CSS dan JavaScript</a> <br>  Bagian 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Pohon Sintaks Abstrak, Parsing dan Optimalisasi nya</a> <br>  Bagian 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara kerja JS: kelas dan warisan, transpilasi dalam Babel dan TypeScript</a> <br>  Bagian 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Penyimpanan</a> <br>  Bagian 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Shadow DOM Technology dan Komponen Web</a> <br>  Bagian 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Mekanisme Komunikasi WebRTC dan P2P</a> <br>  Bagian 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Elemen Kustom</a> </div></div><br>  Hari ini, dalam terjemahan 17 bagian materi yang dikhususkan untuk fitur segala sesuatu yang terhubung dengan JavaScript, kita akan berbicara tentang komponen web dan berbagai standar yang ditujukan untuk bekerja dengannya.  Perhatian khusus akan diberikan pada teknologi Shadow DOM. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/8k/li/z5/8kliz5q5jcynt6ggr2rqa-fancc.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ulasan</font> </h2><br>  Komponen web adalah keluarga API yang dirancang untuk menjelaskan elemen DOM baru yang cocok untuk digunakan kembali.  Fungsionalitas elemen-elemen tersebut dipisahkan dari sisa kode, mereka dapat digunakan dalam aplikasi web dari desain kita sendiri. <br><br>  Ada empat teknologi yang terkait dengan komponen web: <br><br><ul><li>  Shadow DOM (Shadow DOM) </li><li>  Template HTML (Template HTML) </li><li>  Elemen Khusus </li><li>  Impor HTML (Impor HTML) </li></ul><br>  Pada artikel ini, kita akan berbicara tentang teknologi Shadow DOM, yang dirancang untuk membuat aplikasi berbasis komponen.  Ini menawarkan cara untuk memecahkan masalah pengembangan web umum yang mungkin pernah Anda temui: <br><br><ul><li> DOM isolasi: komponen memiliki pohon DOM yang terisolasi (ini berarti bahwa perintah <code>document.querySelector()</code> tidak akan mengizinkan akses ke node dalam bayangan DOM komponen).  Selain itu, ini menyederhanakan sistem pemilih CSS dalam aplikasi web, karena komponen DOM terisolasi, yang memungkinkan pengembang untuk menggunakan pengidentifikasi universal dan nama kelas yang sama dalam komponen yang berbeda tanpa khawatir tentang kemungkinan konflik nama. </li><li>  Isolasi CSS: Aturan CSS yang dijelaskan di dalam shadow DOM terbatas padanya.  Gaya-gaya ini tidak meninggalkan elemen, mereka tidak bercampur dengan gaya halaman lainnya. </li><li>  Komposisi: Mengembangkan API deklaratif untuk komponen berbasis markup. </li></ul><br><h2>  <font color="#3AC1EF">Teknologi Shadow DOM</font> </h2><br>  Diasumsikan bahwa Anda sudah terbiasa dengan konsep DOM dan API terkait.  Jika tidak, Anda dapat membaca materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br>  Shadow DOM pada dasarnya sama dengan DOM biasa, tetapi dengan dua perbedaan: <br><br><ul><li>  Yang pertama adalah bagaimana Shadow DOM dibuat dan digunakan, khususnya, ini tentang hubungan Shadow DOM dengan sisa halaman. </li><li>  Yang kedua adalah perilaku Shadow DOM dalam kaitannya dengan halaman. </li></ul><br>  Saat bekerja dengan DOM, node DOM dibuat yang bergabung, sebagai anak-anak, ke elemen halaman lainnya.  Dalam kasus teknologi Shadow DOM, pohon DOM terisolasi dibuat yang bergabung dengan elemen, tetapi dipisahkan dari elemen anak normal. <br><br>  Subtree yang terisolasi ini disebut pohon bayangan.  Elemen yang melekat pada pohon tersebut disebut sebagai host bayangan.  Segala sesuatu yang ditambahkan ke subtree bayangan DOM ternyata lokal ke elemen yang dilampirkan, termasuk gaya yang dijelaskan menggunakan <code>&lt;style&gt;</code> .  Ini adalah bagaimana isolasi CSS disediakan melalui teknologi Shadow DOM. <br><br><h2>  <font color="#3AC1EF">Membuat Shadow DOM</font> </h2><br>  Root shadow adalah bagian dari dokumen yang menempel pada elemen host.  Suatu elemen memperoleh DOM bayangan ketika elemen root shadow terpasang padanya.  Untuk membuat bayangan DOM untuk elemen tertentu, Anda perlu menggunakan perintah dari form <code>element.attachShadow()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> header = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'header'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shadowRoot = header.attachShadow({<span class="hljs-attr"><span class="hljs-attr">mode</span></span>: <span class="hljs-string"><span class="hljs-string">'open'</span></span>}); shadowRoot.appendChild(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'&lt;p&gt; Shadow DOM &lt;/p&gt;'</span></span>);</code> </pre> <br>  Perlu dicatat bahwa dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi</a> Shadow DOM terdapat daftar elemen yang tidak dapat dihubungkan oleh sub-layer shadow DOM. <br><br><h2>  <font color="#3AC1EF">Komposisi dalam Shadow DOM</font> </h2><br>  Komposisi adalah salah satu fitur terpenting dari Shadow DOM, itu adalah cara untuk membuat aplikasi web, yang digunakan dalam proses penulisan kode HTML.  Selama proses ini, programmer menggabungkan berbagai blok penyusun (elemen) yang membentuk halaman, bersarang, jika perlu, satu sama lain.  Misalnya, ini adalah elemen seperti <code>&lt;div&gt;</code> , <code>&lt;header&gt;</code> , <code>&lt;form&gt;</code> , dan lainnya yang digunakan untuk membuat antarmuka aplikasi web, termasuk yang bertindak sebagai wadah untuk elemen lain. <br><br>  Komposisi menentukan kemampuan elemen, seperti <code>&lt;select&gt;</code> , <code>&lt;form&gt;</code> , <code>&lt;video&gt;</code> , untuk memasukkan elemen HTML lain sebagai anak-anak, dan kemampuan untuk mengatur perilaku khusus dari struktur tersebut yang terdiri dari elemen yang berbeda. <br><br>  Misalnya, elemen <code>&lt;select&gt;</code> memiliki sarana untuk merender elemen <code>&lt;option&gt;</code> dalam bentuk daftar drop-down dengan konten yang telah ditentukan sebelumnya dari elemen-elemen dari daftar tersebut. <br><br>  Pertimbangkan beberapa fitur Shadow DOM yang digunakan dalam menyusun elemen. <br><br><h2>  <font color="#3AC1EF">Dom cahaya</font> </h2><br>  Light DOM adalah markup yang dibuat oleh pengguna komponen Anda.  DOM ini berada di luar bayangan DOM komponen dan merupakan anak dari komponen.  Bayangkan Anda membuat komponen khusus yang disebut <code>&lt;better-button&gt;</code> yang memperluas kemampuan elemen <code>&lt;button&gt;</code> HTML standar, dan pengguna perlu menambahkan gambar dan beberapa teks ke elemen baru ini.  Begini tampilannya: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  img  span -  Light DOM  extended-button --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"boot.png"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>Launch<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Elemen <code>&lt;extended-button&gt;</code> adalah komponen khusus yang dijelaskan sendiri oleh programmer, dan kode HTML di dalam komponen ini adalah Light DOM - yang ditambahkan oleh pengguna komponen ini. <br><br>  Bayangan DOM dalam contoh ini adalah komponen <code>&lt;extended-button&gt;</code> .  Ini adalah model objek lokal dari komponen yang menggambarkan struktur internalnya, terisolasi dari dunia luar CSS, dan merangkum detail implementasi komponen. <br><br><h2>  <font color="#3AC1EF">Dom rata</font> </h2><br>  Pohon DOM rata mewakili bagaimana browser menampilkan komponen pada layar, menggabungkan Light DOM dan Shadow DOM.  Ini adalah pohon DOM yang dapat dilihat di alat pengembang, dan itu yang ditampilkan pada halaman.  Mungkin terlihat seperti ini: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span> #shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined">…</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"boot.png"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>Launch<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Pola</font> </h2><br>  Jika Anda harus terus-menerus menggunakan struktur yang sama dalam markup HTML halaman web, akan berguna untuk menggunakan template tertentu alih-alih menulis kode yang sama berulang kali.  Ini mungkin sebelumnya, tetapi sekarang semuanya telah sangat disederhanakan berkat penampilan <code>&lt;template&gt;</code> HTML, yang menikmati dukungan luar biasa untuk peramban modern.  Elemen ini dan isinya tidak ditampilkan di DOM, tetapi Anda dapat menggunakannya dari JavaScript.  Pertimbangkan contoh sederhana: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> Paragraph content. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Jika Anda memasukkan desain ini dalam markup HTML halaman, konten tag <code>&lt;p&gt;</code> dijelaskan olehnya tidak akan muncul di layar hingga secara eksplisit dilampirkan ke DOM dokumen.  Misalnya, mungkin terlihat seperti ini: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> template = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'my-paragraph'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> templateContent = template.content; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(templateContent);</code> </pre> <br>  Ada cara lain untuk mencapai efek yang sama, tetapi, sebagaimana telah disebutkan, template adalah alat standar yang sangat nyaman yang menikmati dukungan browser yang baik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5dc/501/54c/5dc50154ca3bc462d1e9285334fe462e.png"></div><br>  <i><font color="#999999">Dukungan browser HTML untuk browser modern</font></i> <br><br>  Template bermanfaat dalam dan dari dirinya sendiri, tetapi kemampuannya diungkapkan sepenuhnya saat digunakan dengan elemen kustom.  Elemen khusus adalah topik untuk bahan yang terpisah, dan sekarang, untuk memahami apa yang terjadi, cukup untuk mempertimbangkan bahwa <code>customElement</code> browser <code>customElement</code> memungkinkan pemrogram untuk menggambarkan tag HTML mereka sendiri dan menentukan bagaimana elemen yang dibuat dengan tag ini akan terlihat di layar. <br><br>  Tetapkan komponen web yang menggunakan templat kami sebagai konten untuk DOM bayangannya.  Sebut elemen baru ini <code>&lt;my-paragraph&gt;</code> : <br><br><pre> <code class="hljs scala">customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-paragraph', <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{  constructor() {    <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();    let template = document.getElementById(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-paragraph');    let templateContent = template.content;    const shadowRoot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.attachShadow({mode: <span class="hljs-symbol"><span class="hljs-symbol">'ope</span></span>n'}).appendChild(templateContent.cloneNode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } });</code> </pre> <br>  Hal yang paling penting untuk diperhatikan adalah bahwa kami melampirkan klon dari konten template yang dibuat menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Node.cloneNode ()</a> ke root shadow. <br><br>  Karena kami melampirkan konten template ke DOM bayangan, kami dapat menyertakan beberapa informasi gaya dalam template di elemen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">&lt;style&gt;</a> , yang kemudian akan dienkapsulasi dalam elemen pengguna.  Keseluruhan skema ini tidak akan berfungsi seperti yang diharapkan jika Anda bekerja dengan DOM reguler, bukan Shadow DOM. <br><br>  Misalnya, templat dapat dimodifikasi sebagai berikut dengan memasukkan informasi gaya di dalamnya: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css">   </span><span class="hljs-selector-tag"><span class="css"><span class="hljs-selector-tag">p</span></span></span><span class="css"> {     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">color</span></span></span><span class="css">: white;     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background-color</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">#666</span></span></span><span class="css">;     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">padding</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">5px</span></span></span><span class="css">;   } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Paragraph content. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Sekarang elemen pengguna yang kami jelaskan dapat digunakan pada halaman web biasa sebagai berikut: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Slot</font> </h2><br>  Template HTML memiliki beberapa kelemahan, yang utama adalah bahwa template tersebut berisi markup statis, yang tidak memungkinkan, misalnya, menampilkan konten variabel tertentu dengan bantuan mereka agar dapat bekerja dengan mereka dengan cara yang sama seperti mereka bekerja dengan HTML standar pola.  Di sinilah tag <code>&lt;slot&gt;</code> masuk. <br><br>  Slot dapat dianggap sebagai placeholder yang memungkinkan Anda untuk memasukkan kode HTML Anda sendiri dalam templat.  Ini memungkinkan Anda untuk membuat templat HTML universal dan kemudian membuatnya dapat disesuaikan dengan menambahkan slot ke dalamnya. <br><br>  Lihatlah bagaimana template di atas akan terlihat menggunakan <code>&lt;slot&gt;</code> : <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Default text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Jika konten slot tidak ditentukan saat elemen dimasukkan dalam markup, atau jika browser tidak mendukung bekerja dengan slot, elemen <code>&lt;my-paragraph&gt;</code> hanya akan memasukkan konten standar dari <code>Default text</code> . <br><br>  Untuk mengatur isi slot, Anda harus memasukkan kode HTML dengan atribut <code>slot</code> di elemen <code>&lt;my-paragraph&gt;</code> , yang nilainya setara dengan nama slot tempat Anda ingin menempatkan kode ini. <br><br>  Seperti sebelumnya, bisa ada apa saja.  Sebagai contoh: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Let's have some different text!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Elemen yang dapat ditempatkan dalam slot disebut elemen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Slotable</a> . <br><br>  Harap perhatikan bahwa pada contoh sebelumnya kami menambahkan elemen <code>&lt;span&gt;</code> ke slot, itu yang disebut elemen slotted.  Ini memiliki atribut <code>slot</code> yang diberikan nilai <code>my-text</code> , yaitu nilai yang sama yang digunakan dalam atribut <code>name</code> slot yang dijelaskan dalam templat. <br><br>  Setelah memproses markup di atas, browser akan membuat pohon DOM rata: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> #shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Let's have some different text!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Perhatikan elemen <code>#shadow-root</code> .  Ini hanya indikator keberadaan DOM Shadow. <br><br><h2>  <font color="#3AC1EF">Stilisasi</font> </h2><br>  Komponen yang menggunakan teknologi Shadow DOM dapat ditata secara umum, mereka dapat menentukan gaya mereka sendiri, atau memberikan kait dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">properti CSS kustom</a> yang memungkinkan pengguna komponen untuk menimpa gaya default. <br><br><h3>  <font color="#3AC1EF">▍ Gaya yang dijelaskan dalam komponen</font> </h3><br>  Isolasi CSS adalah salah satu fitur paling luar biasa dari teknologi Shadow DOM.  Yaitu, kita berbicara tentang hal berikut: <br><br><ul><li>  Selektor CSS dari halaman tempat komponen terkait tidak mempengaruhi apa yang ada di dalamnya. </li><li>  Gaya yang dijelaskan dalam komponen tidak mempengaruhi halaman.  Mereka terisolasi dalam elemen host. </li></ul><br>  Selektor CSS yang digunakan di dalam bayangan DOM berlaku secara lokal untuk konten komponen.  Dalam praktiknya, ini berarti kemampuan untuk menggunakan kembali pengidentifikasi dan nama kelas yang sama dalam komponen yang berbeda dan tidak perlu khawatir tentang konflik nama.  Penyeleksi CSS sederhana juga berarti kinerja yang lebih baik untuk solusi di mana mereka digunakan. <br><br>  Lihatlah elemen <code>#shadow-root</code> , yang mendefinisikan beberapa gaya: <br><br><pre> <code class="hljs xml">#shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#container</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background</span></span></span><span class="css">: white; } </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#container-items</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">display</span></span></span><span class="css">: inline-flex; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container-items"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Semua gaya di atas adalah lokal untuk <code>#shadow-root</code> . <br><br>  Selain itu, Anda dapat menggunakan tag <code>&lt;link&gt;</code> untuk menyertakan style sheet eksternal di <code>#shadow-root</code> .  Gaya seperti itu juga akan bersifat lokal. <br><br><h3>  <font color="#3AC1EF">▍Pseudoclass: host</font> </h3><br>  The <code>:host</code> pseudo- <code>:host</code> memungkinkan Anda untuk mengakses elemen yang mengandung pohon DOM bayangan dan gaya elemen ini: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">display</span></span></span><span class="css">: block; </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*       display: inline */</span></span></span><span class="css"> } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Menggunakan <code>:host</code> pseudo- <code>:host</code> , ingat bahwa aturan halaman induk memiliki prioritas lebih tinggi daripada yang ditentukan dalam elemen menggunakan kelas pseudo ini.  Ini memungkinkan pengguna untuk mengganti gaya komponen host yang ditentukan di dalamnya dari luar.  Selain itu,: <code>:host</code> pseudo- <code>:host</code> hanya berfungsi dalam konteks elemen root shadow, Anda tidak dapat menggunakannya di luar pohon shadow DOM. <br><br>  Bentuk fungsional pseudo-class ,: <code>:host(&lt;selector&gt;)</code> , memungkinkan Anda untuk mengakses elemen host jika cocok dengan elemen <code>&lt;selector&gt;</code> ditentukan.  Ini adalah cara yang bagus untuk memungkinkan komponen merangkum perilaku yang merespons tindakan pengguna atau perubahan dalam keadaan komponen, dan memungkinkan Anda untuk mendesain node internal berdasarkan pada komponen host: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0.4</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(</span></span></span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:hover)</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">1</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(</span></span></span><span class="hljs-selector-attr"><span class="css"><span class="hljs-selector-attr">[disabled]</span></span></span><span class="css">) { </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*      -  disabled. */</span></span></span><span class="css">   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background</span></span></span><span class="css">: grey;   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">pointer-events</span></span></span><span class="css">: none;   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0.4</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(.pink)</span></span></span><span class="css"> &gt; </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#tabs</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">color</span></span></span><span class="css">: pink; </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*     #tabs   -  class="pink". */</span></span></span><span class="css"> } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Topik dan elemen dengan pseudo-class: host-context (&lt;selector&gt;)</font> </h3><br>  The <code>:host-context(&lt;selector&gt;)</code> pseudo <code>:host-context(&lt;selector&gt;)</code> cocok dengan elemen host jika elemen tersebut atau leluhurnya cocok dengan elemen <code>&lt;selector&gt;</code> ditentukan. <br><br>  Kasing yang umum digunakan untuk fitur ini adalah menata elemen dengan tema.  Misalnya, tema sering digunakan dengan menetapkan kelas yang sesuai ke <code>&lt;html&gt;</code> atau <code>&lt;body&gt;</code> : <br><br><pre> <code class="hljs javascript">&lt;body <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"lightheme"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> … </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  The <code>:host-context(.lightheme)</code> pseudo <code>:host-context(.lightheme)</code> akan diterapkan ke <code>&lt;fancy-tabs&gt;</code> jika elemen ini adalah turunan dari <code>.lightteme</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host-context(.lightheme)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: white; }</code> </pre> <br>  Konstruk <code>:host-context()</code> mungkin berguna untuk menerapkan tema, tetapi untuk tujuan ini lebih baik menggunakan kait menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">properti CSS khusus</a> . <br><br><h3>  <font color="#3AC1EF">▍ Menata elemen host komponen dari luar</font> </h3><br>  Elemen host komponen dapat ditata secara eksternal menggunakan nama tag-nya sebagai pemilih: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">custom-container</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre> <br>  Gaya eksternal lebih diutamakan daripada gaya yang ditentukan dalam bayangan DOM. <br>  Misalkan pengguna membuat pemilih berikut: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">custom-container</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">500px</span></span>; }</code> </pre> <br>  Itu akan menimpa aturan yang didefinisikan dalam komponen itu sendiri: <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">300px</span></span>; }</code> </pre> <br>  Dengan menggunakan pendekatan ini, Anda hanya dapat menyesuaikan dgn mode komponen itu sendiri.  Bagaimana menyesuaikan dgn mode struktur internal komponen?  Properti CSS khusus digunakan untuk tujuan ini. <br><br><h3>  <font color="#3AC1EF">▍Membuat kait gaya menggunakan properti CSS khusus</font> </h3><br>  Pengguna dapat menyesuaikan gaya struktur internal komponen jika pembuat komponen memberi mereka gaya kait menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">properti CSS kustom</a> . <br><br>  Pendekatan ini didasarkan pada mekanisme yang mirip dengan yang digunakan saat bekerja dengan <code>&lt;slot&gt;</code> , tetapi, dalam hal ini, berlaku untuk gaya. <br><br>  Pertimbangkan sebuah contoh: <br><br><pre> <code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- main page --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> custom-container {   margin-bottom: 60px;    - custom-container-bg: black; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">background</span></span></span><span class="hljs-tag">&gt;</span></span>…<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Inilah yang ada di dalam pohon DOM bayangan: <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host(</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[background]</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">var</span></span>( - custom-container-bg, #CECECE); <span class="hljs-attribute"><span class="hljs-attribute">border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; }</code> </pre> <br>  Dalam hal ini, komponen menggunakan hitam sebagai warna latar belakang, karena itu adalah pengguna yang menentukannya.  Jika tidak, warna latar belakang akan menjadi <code>#CECECE</code> . <br><br>  Sebagai pembuat komponen, Anda bertanggung jawab untuk memberi tahu penggunanya properti CSS spesifik apa yang dapat mereka gunakan.  Pertimbangkan ini bagian dari antarmuka terbuka komponen Anda. <br><br><h2>  <font color="#3AC1EF">JavaScript API untuk bekerja dengan slot</font> </h2><br>  API Shadow DOM menyediakan kemampuan untuk bekerja dengan slot. <br><br><h3>  <font color="#3AC1EF">▍Event slotchange</font> </h3><br>  Acara <code>slotchange</code> dinaikkan ketika node yang ditempatkan di slot berubah.  Misalnya, jika pengguna menambahkan atau menghapus node anak di Light DOM: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shadowRoot.querySelector(<span class="hljs-string"><span class="hljs-string">'#some_slot'</span></span>); slot.addEventListener(<span class="hljs-string"><span class="hljs-string">'slotchange'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Light DOM change'</span></span>); });</code> </pre> <br>  Untuk melacak jenis perubahan lainnya di Light DOM, Anda dapat menggunakan <code>MutationObserver</code> di konstruktor elemen.  Baca lebih lanjut tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  <font color="#3AC1EF">▍ Metode yang ditugaskanNode ()</font> </h3><br>  Metode yang <code>assignedNodes()</code> dapat berguna jika Anda perlu tahu elemen mana yang dikaitkan dengan slot.  Memanggil metode <code>slot.assignedNodes()</code> memungkinkan Anda untuk mengetahui elemen mana saja yang ditampilkan oleh slot.  Menggunakan opsi <code>{flatten: true}</code> memungkinkan Anda untuk mendapatkan konten standar slot (ditampilkan jika tidak ada node yang terpasang padanya). <br><br>  Pertimbangkan sebuah contoh: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'slot1'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Default content<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Bayangkan slot ini terletak di komponen <code>&lt;my-container&gt;</code> . <br><br>  Mari kita lihat berbagai kegunaan untuk komponen ini, dan apa yang akan dikembalikan ketika metode <code>assignedNodes()</code> dipanggil. <br><br>  Dalam kasus pertama, kami menambahkan konten kami sendiri ke slot: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"slot1"</span></span></span><span class="hljs-tag">&gt;</span></span> container text <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dalam hal ini, panggilan yang <code>assignedNodes()</code> akan mengembalikan <code>[ container text ]</code> .  Perhatikan bahwa nilai ini adalah array node. <br><br>  Dalam kasus kedua, kami tidak mengisi slot dengan konten kami sendiri: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Panggilan yang <code>assignedNodes()</code> akan mengembalikan array kosong - <code>[]</code> . <br><br>  Namun, jika Anda melewatkan parameter <code>{flatten: true}</code> ke metode ini, maka memanggilnya untuk elemen yang sama akan mengembalikan konten default-nya: <code>[ Default content ]</code> <p> <code>[ Default content ]</code> </p>  <code>[ Default content ]</code> <br><br>  Selain itu, untuk mengakses elemen di dalam slot, Anda dapat memanggil <code>assignedNodes()</code> untuk memberi tahu Anda slot komponen mana yang ditugaskan untuk elemen Anda. <br><br><h2>  <font color="#3AC1EF">Model acara</font> </h2><br>  Mari kita bicara tentang apa yang terjadi ketika suatu peristiwa yang muncul di pohon bayangan DOM muncul.  Tujuan acara diatur dengan mempertimbangkan enkapsulasi yang didukung oleh teknologi Shadow DOM.  Ketika suatu acara dialihkan, itu tampak seolah-olah berasal dari komponen itu sendiri, dan bukan dari elemen internal, yang terletak di pohon bayangan DOM dan merupakan bagian dari komponen ini. <br><br>  Berikut adalah daftar peristiwa yang dilewatkan dari pohon bayangan DOM (perilaku ini bukan karakteristik dari beberapa peristiwa): <br><br><ul><li>  Acara Fokus: <code>blur</code> , <code>focus</code> , <code>focus</code> , <code>focus</code> . </li><li>  Acara Mouse s: <code>click</code> , <code>dblclick</code> , <code>mousedown</code> , <code>mouseenter</code> , <code>mousemove</code> , dan lainnya. </li><li>  Acara Roda: <code>wheel</code> . </li><li>  Input Events: <code>beforeinput</code> <code>input</code> , <code>input</code> . </li><li>  Acara Keyboard: <code>keydown</code> , <code>keyup</code> . </li><li>  Acara Komposisi: <code>compositionstart</code> , <code>compositionupdate</code> , <code>compositionend</code> . </li><li>  Seret Peristiwa: <code>drag</code> <code>dragstart</code> , <code>drag</code> , <code>dragend</code> , <code>drop</code> , dan sebagainya. </li></ul><br><h2>  <font color="#3AC1EF">Acara khusus</font> </h2><br>  Peristiwa pengguna secara default tidak meninggalkan pohon bayangan DOM.  Jika Anda ingin memicu suatu acara, dan Anda ingin meninggalkan Shadow DOM, Anda harus memberikannya dengan <code>bubbles: true</code> parameter <code>bubbles: true</code> dan <code>composed: true</code> .  Ini adalah bagaimana panggilan acara seperti itu terlihat: <br><br><pre> <code class="hljs axapta">var <span class="hljs-keyword"><span class="hljs-keyword">container</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shadowRoot.querySelector(<span class="hljs-string"><span class="hljs-string">'#container'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">container</span></span>.dispatchEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">'containerchanged'</span></span>, {bubbles: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, composed: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>}));</code> </pre> <br><h2>  <font color="#3AC1EF">Dukungan untuk browser Shadow DOM</font> </h2><br>  Untuk mengetahui apakah browser mendukung teknologi Shadow DOM, Anda dapat memeriksa keberadaan <code>attachShadow</code> : <br><br><pre> <code class="hljs erlang-repl">const supportsShadowDOMV1 = !!HTMLElement.prototype.attachShadow;</code> </pre> <br>  Berikut adalah informasi tentang bagaimana berbagai browser mendukung teknologi ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/d78/c47/bead78c47c464b5059576df077613803.png"></div><br>  <i><font color="#999999">Dukungan untuk teknologi Shadow DOM di browser</font></i> <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pohon DOM bayangan tidak berperilaku seperti pohon DOM biasa.  Secara khusus, menurut penulis bahan ini, di perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SessionStack</a> ini dinyatakan dalam kerumitan prosedur untuk melacak perubahan DOM, informasi tentang yang diperlukan untuk mereproduksi apa yang terjadi dengan halaman.  Yaitu, <code>MutationObserver</code> digunakan untuk melacak perubahan.  Dalam kasus ini, pohon bayangan DOM tidak meningkatkan peristiwa <code>MutationObserver</code> dalam lingkup global, yang mengarah pada kebutuhan untuk menggunakan pendekatan khusus untuk bekerja dengan komponen yang menggunakan Shadow DOM. <br><br>  ,     -  Shadow DOM,     ,   , ,     . <br><br>  <b>Pembaca yang budiman!</b>    -,     Shadow DOM? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415881/">https://habr.com/ru/post/id415881/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415865/index.html">Basis pengetahuan penurunan harga (atau blog, atau dokumentasi proyek)</a></li>
<li><a href="../id415867/index.html">Y Combinator Investor School: Ron Conway</a></li>
<li><a href="../id415871/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 321 (25 Juni - 1 Juli 2018)</a></li>
<li><a href="../id415875/index.html">Sepatah kata untuk ahli bahasa: bagaimana jika komputer berbicara lebih baik</a></li>
<li><a href="../id415879/index.html">Acara digital di Moskow 2-8 Juli</a></li>
<li><a href="../id415887/index.html">Robot laba-laba macam apa yang terbang di atas stadion dan menembak bola. Wawancara dengan pencipta Robycam</a></li>
<li><a href="../id415891/index.html">Apa saja game sekuel yang keren?</a></li>
<li><a href="../id415893/index.html">Cara membuat proses Java berjalan di Linux / Docker sederhana dan mudah</a></li>
<li><a href="../id415895/index.html">Pola paling penting dalam pemrograman</a></li>
<li><a href="../id415897/index.html">Fungsi untuk mendokumentasikan database PostgreSQL. Bagian dua</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>