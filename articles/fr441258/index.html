<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äç‚öïÔ∏è üßöüèº üçô Tra√ßage dynamique complet sous Linux √† l'aide d'eBPF et de bpftrace ‚õìÔ∏è üôä üåÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬´En mode trace, le programmeur voit la s√©quence d'ex√©cution des commandes et les valeurs des variables √† cette √©tape de l'ex√©cution du programme, ce q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tra√ßage dynamique complet sous Linux √† l'aide d'eBPF et de bpftrace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/441258/"><img src="https://habrastorage.org/webt/gd/t6/e_/gdt6e_wwaanx1prvqkhdhj5ptss.jpeg"><br><br>  ¬´En mode trace, le programmeur voit la s√©quence d'ex√©cution des commandes et les valeurs des variables √† cette √©tape de l'ex√©cution du programme, ce qui facilite la d√©tection des erreurs¬ª, nous dit Wikipedia.  En tant que fans de Linux, nous nous posons r√©guli√®rement la question de savoir quels outils sp√©cifiques sont les meilleurs pour l'impl√©menter.  Et nous voulons partager la traduction d'un article du programmeur Hongley Lai qui recommande bpftrace.  Pour l'avenir, je dirai que l'article se termine succinctement: "bpftrace est le futur".  Alors pourquoi a-t-il tant impressionn√© le coll√®gue de Lai?  Une r√©ponse d√©taill√©e sous la coupe. <br><a name="habracut"></a><br>  Il existe deux principaux outils de trace sous Linux: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">strace</a> vous permet de voir quels appels syst√®me sont effectu√©s; <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ltrace</a> vous permet de voir quelles biblioth√®ques dynamiques sont appel√©es. <br><br>  Malgr√© leur utilit√©, ces outils sont limit√©s.  Et si vous avez besoin de savoir ce qui se passe dans un appel syst√®me ou biblioth√®que?  Et si vous devez non seulement compiler une liste d'appels, mais aussi, par exemple, collecter des statistiques sur certains comportements?  Et si vous avez besoin de suivre plusieurs processus et de comparer les donn√©es de plusieurs sources? <br><br>  En 2019, nous avons enfin obtenu une r√©ponse d√©cente √† ces questions sur Linux: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bpftrace</a> bas√© sur la technologie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">eBPF</a> .  Bpftrace vous permet d'√©crire de petits programmes qui s'ex√©cutent chaque fois qu'un √©v√©nement se produit. <br><br>  Dans cet article, je d√©crirai comment installer bpftrace et enseigner son application de base.  Je vais √©galement donner un aper√ßu de ce √† quoi ressemble l'√©cosyst√®me de trace (par exemple, "qu'est-ce que l'eBPF?") Et comment il a √©volu√© pour devenir ce que nous avons aujourd'hui. <br><br><img src="https://habrastorage.org/webt/v9/vp/di/v9vpdivpv8a6roolw_kiz7wtnfs.png"><br><br><h3>  Qu'est-ce qu'une trace? </h3><br>  Comme mentionn√© pr√©c√©demment, bpftrace vous permet d'√©crire de petits programmes qui s'ex√©cutent chaque fois qu'un √©v√©nement se produit. <br><br>  Qu'est-ce qu'un √©v√©nement?  Il peut s'agir d'un appel syst√®me, d'un appel de fonction ou m√™me de quelque chose qui se passe dans de telles requ√™tes.  Il peut √©galement s'agir d'un temporisateur ou d'un √©v√©nement mat√©riel, par exemple, "50 ms se sont √©coul√©es depuis le dernier des m√™mes √©v√©nements", "une d√©faillance de page s'est produite", "un changement de contexte s'est produit" ou "un cashe-miss processor s'est produit". <br><br>  Que peut-on faire en r√©ponse √† un √©v√©nement?  Vous pouvez promettre quelque chose, collecter des statistiques et ex√©cuter des commandes shell arbitraires.  Vous aurez acc√®s √† diverses informations contextuelles, telles que le PID actuel, la trace de la pile, l'heure, les arguments d'appel, les valeurs de retour, etc. <br><br>  Quand l'utiliser?  Dans beaucoup.  Vous pouvez d√©couvrir pourquoi l'application est lente en compilant une liste des appels les plus lents.  Vous pouvez d√©terminer s'il y a des fuites de m√©moire dans l'application et, le cas √©ch√©ant, o√π.  Je l'utilise pour comprendre pourquoi Ruby utilise autant de m√©moire. <br><br>  Le gros avantage de bpftrace est que vous n'avez pas besoin de recompiler l'application.  Il n'est pas n√©cessaire d'√©crire manuellement des appels d'impression ou tout autre code de d√©bogage dans le code source de l'application √† l'√©tude.  Il n'est m√™me pas n√©cessaire de red√©marrer les applications.  Et tout cela avec des frais g√©n√©raux tr√®s faibles.  Cela rend bpftrace particuli√®rement utile pour le d√©bogage de syst√®mes directement sur le prod ou dans une autre situation o√π il y a des probl√®mes de recompilation. <br><br><h3>  DTrace: p√®re de trace </h3><br>  Pendant longtemps, le meilleur outil de tra√ßage √©tait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DTrace</a> , un framework de tra√ßage dynamique complet d√©velopp√© √† l'origine par Sun Microsystems (les cr√©ateurs de Java).  Comme bpftrace, DTrace vous permet d'√©crire de petits programmes qui s'ex√©cutent en r√©ponse √† des √©v√©nements.  En fait, bon nombre des √©l√©ments cl√©s de l'√©cosyst√®me sont largement d√©velopp√©s par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Brendan Gregg</a> , un expert DTrace renomm√© qui travaille actuellement chez Netflix.  Ce qui explique les similitudes entre DTrace et bpftrace. <br><br><img src="https://habrastorage.org/webt/2p/wc/4w/2pwc4wawnfzibvlwt7ia0xibodc.jpeg"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction √† Solaris DTrace (2009)</a> par S. Tripathi, Sun Microsystems</i> <br><br>  √Ä un moment donn√©, Sun a ouvert la source de DTrace.  Aujourd'hui, DTrace est disponible sur Solaris, FreeBSD et macOS (bien que la version macOS soit g√©n√©ralement inutilisable car la protection de l'int√©grit√© du syst√®me, SIP, a enfreint de nombreux principes sur lesquels DTrace s'ex√©cute). <br><br>  Oui, vous l'avez bien remarqu√© ... Linux n'est pas dans cette liste.  Ce n'est pas un probl√®me d'ing√©nierie, c'est un probl√®me de licence.  DTrace a √©t√© ouvert sous le CDDL au lieu de la GPL.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le port Linux DTrace est</a> disponible depuis 2011, mais il n'a jamais √©t√© pris en charge par les principaux d√©veloppeurs Linux.  D√©but 2018, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Oracle a rouvert DTrace sous GPL</a> , mais il √©tait d√©j√† trop tard. <br><br><h3>  √âcosyst√®me de tra√ßage Linux </h3><br>  Le tra√ßage est sans aucun doute tr√®s utile, et la communaut√© Linux a cherch√© √† d√©velopper ses propres solutions √† ce sujet.  Mais, contrairement √† Solaris, Linux n'est pas r√©glement√© par un fournisseur sp√©cifique, et il n'y a donc pas eu d'effort d√©lib√©r√© pour d√©velopper un remplacement enti√®rement fonctionnel de DTrace.  L'√©cosyst√®me de trace Linux a √©volu√© lentement et naturellement, r√©solvant les probl√®mes √† mesure qu'ils surviennent.  Et ce n'est que r√©cemment que cet √©cosyst√®me s'est suffisamment d√©velopp√© pour rivaliser s√©rieusement avec DTrace. <br><br>  En raison de la croissance naturelle, cet √©cosyst√®me peut sembler un peu chaotique, compos√© de nombreuses composantes diff√©rentes.  Heureusement, Julia Evans a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©crit une revue de cet √©cosyst√®me</a> (attention, date de publication - 2017, avant l'av√®nement de bpftrace). <br><br><img src="https://habrastorage.org/webt/io/km/zq/iokmzq2fmqyechm1boqeks-w2za.png"><br>  <i>√âcosyst√®me de traces Linux d√©crit par Julia Evans</i> <br><br>  Tous les √©l√©ments ne sont pas √©galement importants.  Permettez-moi de r√©sumer bri√®vement les √©l√©ments que je consid√®re les plus importants. <br><br>  <b>Sources d'√©v√©nements</b> <br><br>  Les donn√©es d'√©v√©nement peuvent provenir du noyau ou de l'espace utilisateur (applications et biblioth√®ques).  Certains d'entre eux sont disponibles automatiquement, sans efforts de d√©veloppement suppl√©mentaires, tandis que d'autres n√©cessitent une annonce manuelle. <br><br><img src="https://habrastorage.org/webt/2t/xm/mm/2txmmm6rz5xfcwcglsxy8zopr6q.jpeg"><br>  <i>Vue d'ensemble des sources les plus importantes d'√©v√©nements trac√©s sous Linux</i> <br><br>  Du c√¥t√© du noyau, il y a des kprobes ( <i>de ¬´kernel probes¬ª, ¬´kernel sensor¬ª, environ Per.</i> ) - un m√©canisme qui vous permet de tracer tout appel de fonction √† l'int√©rieur du noyau.  Avec lui, vous pouvez tracer non seulement les appels syst√®me eux-m√™mes, mais aussi ce qui se passe √† l'int√©rieur d'eux (car les points d'entr√©e des appels syst√®me appellent d'autres fonctions internes).  Vous pouvez √©galement utiliser kprobes pour tracer les √©v√©nements du noyau qui ne sont pas des appels syst√®me, par exemple, "des donn√©es tamponn√©es sont √©crites sur le disque", "un paquet TCP est envoy√© sur le r√©seau" ou "un changement de contexte est en cours". <br><br>  Les points de trace du noyau permettent de suivre les √©v√©nements non standard d√©finis par les d√©veloppeurs du noyau.  Ces √©v√©nements ne sont pas au niveau des appels de fonction.  Pour cr√©er de tels points, les d√©veloppeurs du noyau placent manuellement la macro TRACE_EVENT dans le code du noyau. <br><br>  Les deux sources ont des avantages et des inconv√©nients.  Kprobes fonctionne "automatiquement" car  ne n√©cessite pas que les d√©veloppeurs du noyau codent manuellement le code.  Mais les √©v√©nements kprobe peuvent changer arbitrairement d'une version du noyau √† une autre, car les fonctions changent constamment - elles sont ajout√©es, supprim√©es, renomm√©es. <br><br>  Les points de trace du noyau sont g√©n√©ralement plus stables dans le temps et peuvent fournir des informations contextuelles utiles qui pourraient ne pas √™tre disponibles si kprobes est utilis√©.  √Ä l'aide de kprobes, vous pouvez acc√©der aux arguments d'appel de fonction.  Mais √† l'aide de points de trace, vous pouvez obtenir toutes les informations que le d√©veloppeur du noyau d√©cide de d√©crire manuellement. <br><br>  Dans l'espace utilisateur, il existe un analogue de kprobes - uprobes.  Il est con√ßu pour tracer les appels de fonction dans l'espace utilisateur. <br><br>  Les capteurs USDT (¬´Traces de l'espace utilisateur d√©finis statiquement¬ª) sont un analogue des points de trace du noyau dans l'espace utilisateur.  Les d√©veloppeurs d'applications doivent ajouter manuellement des capteurs USDT √† leur code. <br><br>  Fait int√©ressant: DTrace fournit depuis longtemps l'API C pour d√©finir son propre analogue de capteurs USDT (en utilisant la macro DTRACE_PROBE).  Les d√©veloppeurs de l'√©cosyst√®me Trace sur Linux ont d√©cid√© de laisser le code source compatible avec cette API, donc toutes les macros DTRACE_PROBE sont automatiquement converties en capteurs USDT! <br><br>  Par cons√©quent, en th√©orie, strace peut √™tre impl√©ment√© √† l'aide de kprobes et ltrace peut √™tre impl√©ment√© √† l'aide d'uprobes.  Je ne sais pas si cela est d√©j√† pratiqu√© ou non. <br><br>  <b>Interfaces</b> <br><br>  Les interfaces sont des applications qui permettent aux utilisateurs d'utiliser facilement des sources d'√©v√©nements. <br><br>  Voyons comment fonctionnent les sources d'√©v√©nements.  Le workflow est le suivant: <br><br><ol><li>  Le noyau repr√©sente un m√©canisme - g√©n√©ralement un fichier / proc ou / sys ouvert en √©criture - qui enregistre √† la fois l'intention de suivre l'√©v√©nement et ce qui doit suivre l'√©v√©nement. </li><li>  Apr√®s l'enregistrement, le noyau localise en m√©moire le noyau / la fonction dans l'espace utilisateur / les points de trace / les capteurs USDT et modifie leur code pour que quelque chose d'autre se produise. </li><li>  Le r√©sultat de cette ¬´autre chose¬ª peut √™tre collect√© ult√©rieurement en utilisant un m√©canisme. </li></ol><br>  Je ne voudrais pas faire tout √ßa manuellement!  Les interfaces viennent donc √† la rescousse: elles font tout cela pour vous. <br><br>  Il existe des interfaces pour tous les go√ªts et toutes les couleurs.  Dans le domaine des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interfaces bas√©es</a> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">eBPF,</a> il existe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interfaces de</a> bas niveau qui n√©cessitent une compr√©hension approfondie de la fa√ßon d'interagir avec les sources d'√©v√©nements et du fonctionnement du bytecode eBPF.  Et ils sont de haut niveau et faciles √† utiliser, bien que durant leur existence ils n'aient pas fait preuve d'une grande flexibilit√©. <br><br>  C'est pourquoi bpftrace - la derni√®re interface - est mon pr√©f√©r√©.  Il est convivial et flexible comme DTrace.  Mais il est assez r√©cent et n√©cessite un polissage. <br><br><h3>  eBPF </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">eBPF</a> est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nouvelle √©toile de trace Linux</a> sur laquelle bpftrace est bas√©.  Lorsque vous tracez un √©v√©nement, vous voulez que quelque chose se passe dans le noyau.  Quelle mani√®re flexible de d√©terminer ce qu'est ce ¬´quelque chose¬ª?  Bien s√ªr, en utilisant un langage de programmation (ou en utilisant un code machine). <br><br>  eBPF (version am√©lior√©e du Berkeley Packet Filter).  Il s'agit d'une machine virtuelle hautes performances qui s'ex√©cute dans le noyau et pr√©sente les propri√©t√©s / limitations suivantes: <br><br><ul><li>  Toutes les interactions dans l'espace utilisateur se produisent via des ¬´cartes¬ª eBPF, qui sont un stockage de donn√©es de valeur cl√©. </li><li>  Il n'y a pas de cycles pour que chaque programme eBPF se termine √† un moment pr√©cis. </li><li>  Attendez, nous avons dit Batch Filter?  Vous avez raison: ils ont √©t√© initialement con√ßus pour filtrer les paquets r√©seau.  C'est une t√¢che similaire: lors du transfert de paquets (l'occurrence d'un √©v√©nement), vous devez effectuer une action administrative (accepter, supprimer, journaliser ou rediriger un paquet, etc.) Une machine virtuelle a √©t√© invent√©e pour acc√©l√©rer ces actions (avec capacit√© JIT) compilation).  Une version ¬´√©tendue¬ª est envisag√©e du fait que, par rapport √† la version d'origine du Berkeley Packet Filter, eBPF peut √™tre utilis√© en dehors du contexte r√©seau. </li></ul><br>  Voil√†.  Avec bpftrace, vous pouvez d√©terminer les √©v√©nements √† suivre et ce qui doit se produire en r√©ponse.  Bpftrace compile votre programme bpftrace de haut niveau en bytecode eBPF, suit les √©v√©nements et charge le bytecode dans le noyau. <br><br><h3>  Jours sombres avant eBPF </h3><br>  Avant eBPF, les options de solution √©taient, pour le moins, maladroites.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SystemTap</a> est un peu le pr√©d√©cesseur ¬´le plus s√©rieux¬ª de bpftrace dans la famille Linux.  Les scripts SystemTap sont traduits en langage C et charg√©s dans le noyau en tant que modules.  Le module de noyau r√©sultant est alors charg√©. <br><br>  Cette approche √©tait tr√®s fragile et mal prise en charge en dehors de Red Hat Enterprise Linux.  Pour moi, cela n'a jamais bien fonctionn√© sur Ubuntu, ce qui avait tendance √† casser SystemTap √† chaque mise √† jour du noyau en raison d'un changement dans la structure des donn√©es du noyau.  On dit √©galement que dans les premiers jours de son existence, SystemTap a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">facilement conduit √† la panique du noyau</a> . <br><br><h3>  Installation de Bpftrace </h3><br>  Il est temps de retrousser vos manches!  Dans ce guide, nous verrons comment installer bpftrace sur Ubuntu 18.04.  Les versions plus r√©centes de la distribution ne sont pas souhaitables, car  lors de l'installation, nous aurons besoin de packages qui ne sont pas encore compil√©s pour eux. <br><br>  <b>Installation de d√©pendance</b> <br><br>  Tout d'abord, installez Clang 5.0, lbclang 5.0 et LLVM 5.0, y compris tous les fichiers d'en-t√™te.  Nous utiliserons les packages fournis par llvm.org, car ceux des r√©f√©rentiels Ubuntu sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√©matiques</a> . <br><br><pre><code class="plaintext hljs">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add - cat &lt;&lt;EOF | sudo tee -a /etc/apt/sources.list deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main EOF sudo apt update sudo apt install clang-5.0 libclang-5.0-dev llvm-5.0 llvm-5.0-dev</code> </pre> <br>  Suivant: <br><br><pre> <code class="plaintext hljs">sudo apt install bison cmake flex g++ git libelf-dev zlib1g-dev libfl-dev</code> </pre> <br>  Et enfin, installez libbfcc-dev depuis l'amont, pas depuis le r√©f√©rentiel Ubuntu.  Il n'y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas de fichiers d'</a> en- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t√™te</a> dans le package qui se trouve dans Ubuntu.  Et ce probl√®me n'a pas √©t√© r√©solu m√™me √† 18h10. <br><br><pre> <code class="plaintext hljs">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD echo "deb https://repo.iovisor.org/apt/$(lsb_release -cs) $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/iovisor.list sudo apt update sudo apt install bcc-tools libbcc-examples linux-headers-$(uname -r)</code> </pre> <br>  <b>Installation principale de Bpftrace</b> <br><br>  Il est temps d'installer bpftrace lui-m√™me depuis la source!  Clonons-le, assemblons-le et installons-le dans / usr / local: <br><br><pre> <code class="plaintext hljs">git clone https://github.com/iovisor/bpftrace cd bpftrace mkdir build &amp;&amp; cd build cmake -DCMAKE_BUILD_TYPE=DEBUG .. make -j4 sudo make install</code> </pre> <br>  Et vous avez termin√©!  L'ex√©cutable sera install√© dans / usr / local / bin / bpftrace.  Vous pouvez modifier la destination √† l'aide de l'argument cmake, qui ressemble √† ceci par d√©faut: <br><br><pre> <code class="plaintext hljs">DCMAKE_INSTALL_PREFIX=/usr/local.</code> </pre> <br>  <b>Exemples d'une ligne</b> <br><br>  Ex√©cutons quelques lignes simples bpftrace pour comprendre nos capacit√©s.  Je les ai extraites du <a href="">guide</a> de <a href="">Brendan Gregg</a> , qui contient une description d√©taill√©e de chacun d'eux. <br><br>  # 1. Affichez une liste de capteurs <br><br><pre> <code class="plaintext hljs">bpftrace -l 'tracepoint:syscalls:sys_enter_*'</code> </pre> <br>  # 2. Salutations <br><br><pre> <code class="plaintext hljs">bpftrace -e 'BEGIN { printf("hello world\n"); }'</code> </pre> <br>  # 3. Ouverture d'un fichier <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf("%s %s\n", comm, str(args-&gt;filename)); }'</code> </pre> <br>  # 4. Le nombre d'appels syst√®me par processus <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'</code> </pre> <br>  # 5. R√©partition des appels read () par nombre d'octets <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_exit_read /pid == 18644/ { @bytes = hist(args-&gt;retval); }'</code> </pre> <br>  # 6. Tra√ßage dynamique du contenu read () <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kretprobe:vfs_read { @bytes = lhist(retval, 0, 2000, 200); }'</code> </pre> <br>  # 7. Temps pass√© sur les appels read () <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }'</code> </pre> <br>  # 8. Comptage des √©v√©nements au niveau du processus <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched* { @[name] = count(); } interval:s:5 { exit(); }'</code> </pre> <br>  # 9. Profilage des piles de travail du noyau <br><br><pre> <code class="plaintext hljs">bpftrace -e 'profile:hz:99 { @[stack] = count(); }'</code> </pre> <br>  # 10. Planificateur de traces <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched_switch { @[stack] = count(); }'</code> </pre> <br>  # 11. E / S de blocage de trace <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:block:block_rq_complete { @ = hist(args-&gt;nr_sector * 512); }'</code> </pre> <br>  Consultez le site Web de Brendan Gregg pour savoir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quel type de sortie les √©quipes ci-dessus peuvent g√©n√©rer</a> . <br><br>  <b>Syntaxe de script et exemple de synchronisation d'E / S</b> <br><br>  La cha√Æne pass√©e par le commutateur '-e' est le contenu du script bpftrace.  La syntaxe dans ce cas est, conditionnellement, un ensemble de constructions: <br><br><pre> <code class="plaintext hljs">&lt;event source&gt; /&lt;optional filter&gt;/ { &lt;program body&gt; }</code> </pre> <br>  Examinons le septi√®me exemple, sur le timing des op√©rations de lecture du syst√®me de fichiers: <br><br><pre> <code class="plaintext hljs">kprobe:vfs_read { @start[tid] = nsecs; } &lt;- 1 -&gt;&lt;-- 2 -&gt; &lt;---------- 3 ---------&gt;</code> </pre> <br>  Nous <i>suivons</i> l'√©v√©nement √† partir du m√©canisme <i>kprobe</i> , c'est-√†-dire que nous <i>suivons</i> le d√©but de la fonction du noyau. <br>  La fonction du noyau pour le tra√ßage est <i>vfs_read</i> , cette fonction est appel√©e lorsque le noyau effectue une op√©ration de lecture √† partir du syst√®me de fichiers (VFS de "Virtual FileSystem", abstraction du syst√®me de fichiers √† l'int√©rieur du noyau). <br><br>  Lorsque <i>vfs_read</i> commence √† <i>s'ex√©cuter</i> (c'est-√†-dire avant que la fonction n'ait effectu√© un travail utile), le programme bpftrace d√©marre.  Il enregistre l'horodatage actuel (en nanosecondes) dans un tableau associatif global appel√© <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">st</a> art</i> .  La cl√© est <i>tid</i> , une r√©f√©rence √† l'ID de thread actuel. <br><br><pre> <code class="plaintext hljs">kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); } &lt;-- 1 --&gt; &lt;-- 2 -&gt; &lt;---- 3 ----&gt; &lt;----------------------------- 4 -----------------------------&gt;</code> </pre> <br>  1. Nous <i>suivons</i> l'√©v√©nement √† partir du m√©canisme <i>kretprobe</i> , qui est similaire √† <i>kprobe</i> , sauf qu'il est appel√© lorsque la fonction renvoie le r√©sultat de son ex√©cution. <br><br>  2. La fonction du noyau pour le tra√ßage est <i>vfs_read</i> . <br><br>  3. Il s'agit d'un filtre facultatif.  Il v√©rifie si l'heure de d√©but a d√©j√† √©t√© enregistr√©e.  Sans ce filtre, le programme peut √™tre d√©marr√© pendant la lecture et n'attraper que la fin, ce qui donne une heure <i>estim√©e</i> de <i>d√©marrage nsecs - 0</i> , au lieu de <i>nsecs -</i> . <br><br>  4. Le corps du programme. <br><br>  <i>nsecs - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">st</a> art [tid]</i> calcule le temps √©coul√© depuis le d√©but de la fonction vfs_read. <br>  <i>@ns [comm] = hist (...)</i> ajoute les donn√©es sp√©cifi√©es √† l'histogramme bidimensionnel stock√© dans <i>@ns</i> .  La cl√© de <i>communication</i> fait r√©f√©rence au nom de l'application en cours.  Nous aurons donc un histogramme commande par commande. <br><br>  <i>delete (...)</i> supprime l'heure de d√©but du tableau associatif, car nous n'en avons plus besoin. <br><br>  Telle est la conclusion finale.  Veuillez noter que tous les histogrammes sont affich√©s automatiquement.  L'utilisation explicite de la commande d'impression d'histogramme n'est pas requise.  <i>@ns</i> n'est pas une variable sp√©ciale, donc l'histogramme n'est pas affich√© √† cause de cela. <br><br><pre> <code class="plaintext hljs">@ns[snmp-pass]: [0, 1] 0 | | [2, 4) 0 | | [4, 8) 0 | | [8, 16) 0 | | [16, 32) 0 | | [32, 64) 0 | | [64, 128) 0 | | [128, 256) 0 | | [256, 512) 27 |@@@@@@@@@ | [512, 1k) 125 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ | [1k, 2k) 22 |@@@@@@@ | [2k, 4k) 1 | | [4k, 8k) 10 |@@@ | [8k, 16k) 1 | | [16k, 32k) 3 |@ | [32k, 64k) 144 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@| [64k, 128k) 7 |@@ | [128k, 256k) 28 |@@@@@@@@@@ | [256k, 512k) 2 | | [512k, 1M) 3 |@ | [1M, 2M) 1 | |</code> </pre> <br><br>  <b>Exemple de capteur USDT</b> <br><br>  Prenons ce code C et enregistrons-le dans le fichier <i>tracetest.c</i> : <br><br><pre> <code class="plaintext hljs">#include &lt;sys/sdt.h&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; static long myclock() { struct timeval tv; gettimeofday(&amp;tv, NULL); DTRACE_PROBE1(tracetest, testprobe, tv.tv_sec); return tv.tv_sec; } int main(int argc, char **argv) { while (1) { myclock(); sleep(1); } return 0; }</code> </pre> <br>  Ce programme s'ex√©cute sans fin en appelant <i>myclock ()</i> une fois par seconde.  <i>myclock ()</i> interroge l'heure actuelle et renvoie le nombre de secondes depuis le d√©but de l'√®re. <br><br>  L'appel √† <i>DTRACE_PROBE1</i> d√©finit ici un point de trace USDT statique. <br><br><ul><li>  La macro <i>DTRACE_PROBE1</i> est tir√©e de <i>sys / sdt.h.</i>  La macro officielle USDT, qui fait de m√™me, s'appelle <i>STAP_PROBE1</i> (STAP de SystemTap, qui √©tait le premier m√©canisme Linux pris en charge par USDT).  Mais comme USDT est compatible avec les capteurs d'espace utilisateur DTrace, <i>DTRACE_PROBE1</i> n'est qu'une r√©f√©rence √† <i>STAP_PROBE1</i> . </li><li>  Le premier param√®tre est le nom du fournisseur.  Je crois que c'est un vestige de DTrace, car bpftrace ne semble pas faire quoi que ce soit d'utile avec.  Cependant, il y a une nuance ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">que j'ai d√©couverte lors du d√©bogage du probl√®me √† l'application 328</a> ): le nom du fournisseur doit √™tre identique au nom de fichier binaire de l'application, sinon bpftrace ne pourra pas trouver le point de trace. </li><li>  Le deuxi√®me param√®tre est le nom du point de trace. </li><li>  Tout param√®tre suppl√©mentaire est le contexte fourni par les d√©veloppeurs.  Le nombre <i>1</i> dans <i>DTRACE_PROBE1</i> signifie que nous voulons passer un param√®tre suppl√©mentaire. </li></ul><br>  Assurons-nous que sys / sdt.h est disponible pour nous, et montons le programme: <br><br><pre> <code class="plaintext hljs">sudo apt install systemtap-sdt-dev gcc tracetest.c -o tracetest -Wall -g</code> </pre> <br>  Nous demandons √† bpftrace de sortir le PID et "time is [number]" chaque fois que <i>testprobe est</i> atteint: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/full-path-to/tracetest:testprobe { printf("%d: time is %d\n", pid, arg0); }'</code> </pre> <br>  Bpftrace continue de fonctionner pendant que nous appuyons sur Ctrl-C.  Par cons√©quent, ouvrez un nouveau terminal et ex√©cutez <i>-</i> y <i>tracetest</i> : <br><br>  # Dans le nouveau terminal <br>  ./tracetest <br><br>  Revenez au premier terminal avec bpftrace, l√† vous devriez voir quelque chose comme: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... 30909: time is 1549023215 30909: time is 1549023216 30909: time is 1549023217 ... ^C</code> </pre> <br>  <b>Exemple d'allocation de m√©moire √† l'aide de glibc ptmalloc</b> <br><br>  J'utilise bpftrace pour comprendre pourquoi Ruby utilise autant de m√©moire.  Et dans le cadre de mes recherches, j'ai besoin de comprendre comment l'allocateur de m√©moire de glibc utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les r√©gions de m√©moire</a> . <br><br>  Afin d'optimiser les performances multic≈ìurs, l'allocateur de m√©moire glibc alloue plusieurs ¬´zones¬ª √† partir du syst√®me d'exploitation.  Lorsque l'application demande l'allocation de m√©moire, l'allocateur s√©lectionne une zone qui n'est pas utilis√©e et marque une partie de cette zone comme ¬´utilis√©e¬ª.  √âtant donn√© que les threads utilisent diff√©rentes zones, le nombre de verrous est r√©duit, ce qui am√©liore les performances multithread. <br><br>  Mais cette approche g√©n√®re beaucoup de d√©chets, et il semble qu'une telle consommation de m√©moire √©lev√©e dans Ruby soit pr√©cis√©ment √† cause de cela.  Afin de mieux comprendre la nature de ces d√©chets, je me suis demand√©: qu'est-ce que cela signifie de ¬´choisir une zone qui n'est pas utilis√©e¬ª?  Cela peut signifier l'un des √©l√©ments suivants: <br><br><ul><li>  Chaque fois que <i>malloc () est</i> appel√©, l'allocateur parcourt toutes les zones et trouve celle qui n'est pas actuellement verrouill√©e.  Et seulement s'ils sont tous bloqu√©s, il essaiera d'en cr√©er un nouveau. </li><li>  La premi√®re fois que <i>malloc () est</i> appel√© sur un thread sp√©cifique (ou lorsque le thread d√©marre), l'allocateur s√©lectionne celui qui n'est pas actuellement bloqu√©.  Et s'ils sont tous bloqu√©s, il essaiera d'en cr√©er un nouveau. </li><li>  La premi√®re fois que <i>malloc () est</i> appel√© sur un thread sp√©cifique (ou lorsque le thread d√©marre), l'allocateur essaiera de cr√©er une nouvelle r√©gion, qu'il y ait ou non des r√©gions d√©verrouill√©es.  Seulement si une nouvelle zone ne peut pas √™tre cr√©√©e (par exemple, lorsque la limite est √©puis√©e), elle r√©utilisera la zone existante. </li><li>  Il y a probablement plus d'options que je n'ai pas envisag√©es. </li></ul><br>  Il n'y a pas de r√©ponse sp√©cifique dans la documentation, laquelle de ces fonctionnalit√©s vous permet de s√©lectionner une zone qui n'est pas utilis√©e.  J'ai √©tudi√© le code source de la glibc, qui a sugg√©r√© que l'option 3 pourrait le faire.  Mais je voulais v√©rifier exp√©rimentalement que j'avais interpr√©t√© le code source correctement, sans avoir besoin de d√©boguer le code dans la glibc. <br><br>  Voici la fonction d'allocation de m√©moire glibc qui cr√©e une nouvelle zone.  Mais vous ne pouvez l'appeler qu'apr√®s avoir v√©rifi√© la limite. <br><br><pre> <code class="plaintext hljs">static mstate _int_new_arena(size_t size) { mstate arena; size = calculate_how_much_memory_to_ask_from_os(size); arena = do_some_stuff_to_allocate_memory_from_os(); LIBC_PROBE(memory_arena_new, 2, arena, size); do_more_stuff(); return arena; }</code> </pre> <br>  Puis-je utiliser des <i>uprobes</i> pour tracer la fonction <i>_int_new_arena</i> ?  Malheureusement non.  Pour une raison quelconque, ce symbole n'est pas disponible dans la glibc Ubuntu 18.04.  M√™me apr√®s l'installation des symboles de d√©bogage. <br><br>  Heureusement, il existe un capteur USDT dans cette fonction.  <i>LIBC_PROBE</i> est un alias de macro pour <i>STAP_PROBE</i> . <br>  Le nom du fournisseur est libc. <br>  Le nom du capteur est memory_arena_new. <br>  Le nombre 2 signifie qu'il y a 2 arguments suppl√©mentaires sp√©cifi√©s par le d√©veloppeur. <br>  arena est l'adresse de la zone qui a √©t√© extraite du syst√®me d'exploitation, et la taille est sa taille. <br><br>  Avant de pouvoir utiliser ce capteur, nous devons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contourner le probl√®me 328</a> .  Nous devons cr√©er un lien symbolique avec glibc quelque part avec le nom <i>libc</i> , car bpftrace s'attend √† ce que le nom de la biblioth√®que (qui serait autrement <i>libc-2.27.so</i> ) soit identique au nom du fournisseur <i>(libc)</i> . <br><br><pre> <code class="plaintext hljs">ln -s /lib/x86_64-linux-gnu/libc-2.27.so /tmp/libc</code> </pre> <br>  Nous demandons maintenant √† bpftrace de se connecter au capteur USD_ memory_arena_new, dont le nom du fournisseur est <i>libc</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/tmp/libc:memory_arena_new { printf("PID %d: created new arena at %p, size %d\n", pid, arg0, arg1); }'</code> </pre> <br>  Dans un autre terminal, nous ex√©cuterons Ruby, qui cr√©era trois threads qui ne font rien et se terminent en une seconde.  En raison du blocage global de l'interpr√©teur, Ruby <i>malloc ()</i> ne doit pas √™tre appel√© en parall√®le par diff√©rents threads. <br><br><pre> <code class="plaintext hljs">ruby -e '3.times { Thread.new { } }; sleep 1'</code> </pre> <br>  De retour au terminal avec bpftrace, nous verrons: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... PID 431: created new arena at 0x7f40e8000020, size 576 PID 431: created new arena at 0x7f40e0000020, size 576 PID 431: created new arena at 0x7f40e4000020, size 576</code> </pre> <br>  Voici la r√©ponse √† notre question!  Chaque fois que vous cr√©ez un nouveau fil dans Ruby, la glibc met en √©vidence un nouveau domaine ind√©pendamment de la comp√©titivit√©. <br><br>  <b>Quels sont les points de trace disponibles?</b>  <b>Que dois-je tracer?</b> <br><br>  Vous pouvez r√©pertorier tous les points de trace mat√©riels, temporisateurs, kprobe et du noyau statique en ex√©cutant la commande: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l</code> </pre> <br>  Vous pouvez r√©pertorier tous les points de trace de la sonde (caract√®res de fonction) d'une application ou d'une biblioth√®que en proc√©dant comme suit: <br><br><pre> <code class="plaintext hljs">nm /path-to-binary</code> </pre> <br>  Vous pouvez r√©pertorier tous les points de trace de l'application ou de la biblioth√®que USDT en ex√©cutant la commande suivante: <br><br><pre> <code class="plaintext hljs">/usr/share/bcc/tools/tplist -l /path-to/binary</code> </pre> <br>  En ce qui concerne les points de trace √† utiliser: cela ne ferait pas de mal de comprendre le code source de ce que vous allez tracer.  Je vous recommande d'√©tudier le code source. <br><br>  <b>Astuce: un format structurel pour les points de trace dans le noyau</b> <br><br>  Voici une astuce utile sur les points de trace du noyau.  Vous pouvez v√©rifier quels champs d'argument sont disponibles en lisant le fichier / sys / kernel / debug / tracing / events! <br><br>  Par exemple, supposons que vous souhaitiez tracer les appels √† <i>madvise (..., MADV_DONTNEED)</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l | grep madvise</code> </pre> <br>  - nous dira que nous pouvons utiliser tracepoint: syscalls: sys_enter_madvise. <br><br><pre> <code class="plaintext hljs">sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_madvise/format</code> </pre> <br>  - nous fournira les informations suivantes: <br><br><pre> <code class="plaintext hljs">name: sys_enter_madvise ID: 569 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:unsigned long start; offset:16; size:8; signed:0; field:size_t len_in; offset:24; size:8; signed:0; field:int behavior; offset:32; size:8; signed:0; print fmt: "start: 0x%08lx, len_in: 0x%08lx, behavior: 0x%08lx", ((unsigned long)(REC-&gt;start)), ((unsigned long)(REC-&gt;len_in)), ((unsigned long)(REC-&gt;behavior))</code> </pre> <br>  Signature Madvise selon le manuel: <i>(void * addr, size_t length, int advice)</i> .  Les trois derniers champs de cette structure correspondent √† ces param√®tres! <br><br>  Quelle est la signification de MADV_DONTNEED?  A en juger par grep MADV_DONTNEED / usr / include, cela √©quivaut √† 4: <br><br><pre> <code class="plaintext hljs">/usr/include/x86_64-linux-gnu/bits/mman-linux.h:80:# define MADV_DONTNEED 4 /* Don't need these pages. */</code> </pre> <br>  Notre √©quipe bpftrace devient donc: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'tracepoint:syscalls:sys_enter_madvise /args-&gt;behavior == 4/ { printf("madvise DONTNEED called\n"); }'</code> </pre> <br><h3>  Conclusion </h3><br>  Bpftrace est merveilleux!  Bpftrace est l'avenir! <br><br>  Si vous voulez en savoir plus sur lui, je vous recommande de vous familiariser avec <a href="">son leadership</a> , ainsi que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier post de 2019</a> sur le blog de Brendan Gregg. <br><br>  Bon d√©bogage! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441258/">https://habr.com/ru/post/fr441258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441244/index.html">La vuln√©rabilit√© WinRar, non ferm√©e depuis 19 ans, vous permet de placer le fichier d√©compress√© √† n'importe quel endroit</a></li>
<li><a href="../fr441248/index.html">La Russie a pris la 9e place dans le classement SSL mondial, devant la Chine, le Danemark et la Suisse</a></li>
<li><a href="../fr441250/index.html">D√©marrage rapide: Go + Apache Kafka + Redis</a></li>
<li><a href="../fr441252/index.html">"Article de fellation": des scientifiques ont trait√© 109 heures de sexe oral pour d√©velopper une IA qui suce un membre</a></li>
<li><a href="../fr441254/index.html">S√©minaire ¬´Pourquoi nous sommes entr√©s en contact avec Kubernetes et ce que nous en retirons¬ª, 28 f√©vrier, Moscou</a></li>
<li><a href="../fr441260/index.html">Comment les graphiques de r√©seaux neuronaux ont aid√©</a></li>
<li><a href="../fr441262/index.html">Les t√¢ches simples et longues √©liminent mieux les candidats que les t√¢ches courtes et complexes</a></li>
<li><a href="../fr441264/index.html">Guide de l'utilisateur Kibana. Visualisation. 2e partie</a></li>
<li><a href="../fr441266/index.html">Fonctionnement du framework tiOPF pour delphi / lazarus. Mod√®le de visiteur</a></li>
<li><a href="../fr441268/index.html">Ceedling + Eclipse ou tests unitaires pour microcontr√¥leurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>