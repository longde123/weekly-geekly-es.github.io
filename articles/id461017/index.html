<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’†ğŸ½ ğŸŒ ğŸ‘¸ğŸ¼ Algoritma Pelacakan GPU Baru: Wavefront Path Tracing ğŸ¡ ğŸŒŸ ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini, kami mengeksplorasi konsep penting yang digunakan dalam platform Mercusuar yang baru dirilis 2. Jalur lintasan gelombang , seperti ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritma Pelacakan GPU Baru: Wavefront Path Tracing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461017/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_x/t8/rw/_xt8rwehj6jymumaisqg5ehgkro.png"></div><br>  Dalam artikel ini, kami mengeksplorasi konsep penting yang digunakan dalam platform Mercusuar yang baru dirilis 2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jalur lintasan gelombang</a> , seperti yang disebut Lane, Karras dan Aila dari NVIDIA, atau streaming jalur lacak, seperti yang awalnya disebut dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tesis master</a> Van Antwerp, memainkan peran penting dalam pengembangan pelacak jalur efisien pada GPU, dan berpotensi pelacak jalur pada CPU.  Namun, itu sangat berlawanan dengan intuisi, oleh karena itu, untuk memahaminya, perlu untuk memikirkan kembali algoritma penelusuran sinar. <br><a name="habracut"></a><br><h2>  Hunian </h2><br>  Algoritma path tracing sangat sederhana dan dapat dijelaskan hanya dalam beberapa baris pseudocode: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( vec3 O, vec3 D )</span></span></span><span class="hljs-function"> IntersectionData i </span></span>= Scene::Intersect( O, D ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == NoHit) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec3( <span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// ray left the scene if (i == Light) return i.material.color // lights do not reflect vec3 R, pdf = RandomDirectionOnHemisphere( i.normal ), 1 / 2PI return Trace( i.position, R ) * i.BRDF * dot( i.normal, R ) / pdf</span></span></code> </pre> <br>  Input adalah <em>sinar primer yang</em> lewat dari kamera melalui piksel layar.  Untuk balok ini, kami menentukan persimpangan terdekat dengan adegan primitif.  Jika tidak ada persimpangan, maka balok menghilang ke dalam kekosongan.  Jika tidak, jika sinar mencapai sumber cahaya, maka kami telah menemukan jalur cahaya antara sumber dan kamera.  Jika kita menemukan sesuatu yang lain, maka kita melakukan refleksi dan rekursi, berharap sinar yang dipantulkan masih akan menemukan sumber penerangan.  Perhatikan bahwa proses ini menyerupai jalur (kembali) dari foton yang memantulkan permukaan pemandangan. <br><br>  GPU dirancang untuk melakukan tugas ini dalam mode multi-threaded.  Pada awalnya mungkin tampak bahwa penelusuran sinar sangat ideal untuk ini.  Jadi, kami menggunakan OpenCL atau CUDA untuk membuat aliran untuk piksel, setiap aliran melakukan algoritme yang benar-benar berfungsi sebagaimana mestinya, dan cukup cepat: lihat saja beberapa contoh dengan ShaderToy untuk memahami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seberapa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cepat</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penelusuran sinar</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dilakukan.</a> pada GPU.  Tapi betapapun mungkin, pertanyaannya berbeda: apakah pelacak sinar ini benar <em>-</em> benar <em>secepat mungkin</em> ? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/61d/07d/ce561d07daa3437927ab8ad5a6744ec9.jpg"></div><br>  Algoritma ini memiliki masalah.  Sinar primer dapat menemukan sumber cahaya segera, atau setelah satu refleksi acak, atau setelah lima puluh refleksi.  Programer untuk CPU akan melihat stack overflow potensial di sini;  programmer GPU harus melihat <em>masalah hunian</em> .  Masalahnya disebabkan oleh rekursi ekor bersyarat: jalur mungkin berakhir di sumber cahaya atau berlanjut.  Mari kita transfer ini ke banyak utas: sebagian utas akan berhenti, dan bagian lainnya akan terus bekerja.  Setelah beberapa refleksi, kami akan memiliki beberapa utas yang perlu melanjutkan komputasi, dan sebagian utas akan menunggu utas terakhir selesai bekerja.  <em>Pekerjaan</em> adalah ukuran porsi utas GPU yang melakukan pekerjaan yang bermanfaat. <br><br>  Masalah ketenagakerjaan berlaku untuk model eksekusi perangkat SIMT GPU.  Streaming diatur ke dalam grup, misalnya, dalam GPU Pascal (NVidia equipment class 10xx) 32 utas digabungkan menjadi <em>warp</em> .  Utas dalam warp memiliki penghitung program umum: mereka dieksekusi dengan langkah tetap, sehingga setiap instruksi program dijalankan oleh 32 utas secara bersamaan.  SIMT adalah kependekan dari <em>instruksi tunggal</em> , yang menjelaskan konsep dengan baik.  Untuk prosesor SIMT, kode dengan kondisi rumit.  Ini jelas ditunjukkan dalam dokumentasi resmi Volta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/1c0/cb0/9bb1c0cb0c4916e8a7989edeb466d3dd.jpg"></div><br>  <i>Eksekusi kode dengan ketentuan dalam SIMT.</i> <br><br>  Ketika kondisi tertentu berlaku untuk beberapa utas di warp, cabang-cabang <em>pernyataan if adalah</em> serial.  Alternatif untuk pendekatan "semua utas melakukan hal yang sama" adalah "beberapa utas dinonaktifkan."  Dalam blok if-then-else, rata-rata pekerjaan warp adalah 50%, kecuali semua thread memiliki konsistensi mengenai kondisi tersebut. <br><br>  Sayangnya, kode dengan kondisi dalam pelacak ray tidak begitu langka.  Sinar bayangan dipancarkan hanya jika sumber cahaya tidak berada di belakang titik naungan, jalur yang berbeda dapat bertabrakan dengan bahan yang berbeda, integrasi dengan metode roulette Rusia dapat menghancurkan atau membiarkan jalan hidup, dan seterusnya.  Ternyata hunian menjadi sumber utama ketidakefisienan, dan tidak mudah untuk mencegahnya tanpa tindakan darurat. <br><br><h2>  Streaming Jalur Menelusuri </h2><br>  Algoritma penelusuran jalur streaming dirancang untuk mengatasi akar penyebab masalah yang sibuk.  Streaming path tracing membagi algoritma path tracing menjadi empat langkah: <br><br><ol><li>  <strong>Hasilkan</strong> </li><li>  <strong>Perpanjang</strong> </li><li>  <strong>Naungan</strong> </li><li>  <strong>Terhubung</strong> </li></ol><br>  Setiap tahap diimplementasikan sebagai program terpisah.  Karena itu, alih-alih mengeksekusi pelacak jalur penuh sebagai program GPU tunggal ("kernel", kernel), kita harus bekerja dengan <em>empat</em> core.  Selain itu, seperti yang akan segera kita lihat, mereka dieksekusi dalam satu lingkaran. <br><br>  <b>Tahap 1 ("Hasilkan")</b> bertanggung jawab untuk menghasilkan sinar primer.  Ini adalah inti sederhana yang menciptakan titik awal dan arah sinar dalam jumlah yang sama dengan jumlah piksel.  Output dari tahap ini adalah buffer sinar besar dan penghitung menginformasikan tahap selanjutnya dari jumlah sinar yang perlu diproses.  Untuk sinar primer, nilai ini sama dengan <em>lebar layar</em> dikalikan <em>ketinggian layar</em> . <br><br>  <strong>Tahap 2 ("Pembaruan")</strong> adalah inti kedua.  Ini dijalankan hanya setelah tahap 1 selesai untuk semua piksel.  Kernel membaca buffer yang dihasilkan pada langkah 1 dan memotong setiap sinar dengan adegan.  Output dari tahap ini adalah hasil persimpangan untuk setiap sinar yang disimpan dalam buffer. <br><br>  <strong>Tahap 3 ("Bayangan")</strong> dilakukan setelah penyelesaian tahap 2. Ini menerima hasil persimpangan dari tahap 2 dan menghitung model bayangan untuk setiap jalur.  Operasi ini mungkin atau mungkin tidak menghasilkan sinar baru, tergantung pada apakah jalur telah selesai.  Jalur yang menghasilkan sinar baru (jalur "memanjang") menulis sinar baru ("segmen jalan") ke buffer.  Jalur yang secara langsung mengambil sampel sumber cahaya ("pencahayaan sampel secara eksplisit" atau "menghitung kejadian berikutnya") menulis berkas bayangan ke buffer kedua. <br><br>  <strong>Tahap 4 ("Sambungkan")</strong> melacak sinar bayangan yang dihasilkan pada tahap 3. Ini mirip dengan tahap 2, tetapi dengan perbedaan penting: sinar bayangan perlu menemukan persimpangan, sedangkan sinar yang diperluas perlu menemukan persimpangan terdekat.  Oleh karena itu, inti yang terpisah telah dibuat untuk ini. <br><br>  Setelah menyelesaikan langkah 4, kami mendapatkan buffer yang berisi sinar yang memperpanjang jalur.  Setelah mengambil sinar ini, kami melanjutkan ke tahap 2. Kami terus melakukan ini sampai tidak ada sinar ekstensi atau sampai kami mencapai jumlah iterasi maksimum. <br><br><h2>  Sumber Ketidakefisienan </h2><br>  Seorang programmer yang peduli dengan kinerja akan melihat banyak momen berbahaya dalam skema algoritma penelusuran jalur streaming: <br><br><ul><li>  Alih-alih satu panggilan kernel, kami sekarang memiliki <em>tiga panggilan per iterasi</em> , ditambah satu generasi kernel.  Core yang menantang berarti peningkatan beban tertentu, jadi ini buruk. </li><li>  Setiap inti membaca buffer besar dan menulis buffer besar. </li><li>  CPU perlu tahu berapa banyak utas yang dihasilkan untuk setiap inti, sehingga GPU harus memberi tahu CPU berapa banyak sinar yang dihasilkan pada langkah 3. Memindahkan informasi dari GPU ke CPU adalah ide yang buruk, dan perlu dilakukan setidaknya sekali per iterasi. </li><li>  Bagaimana tahap 3 menulis sinar ke buffer tanpa membuat spasi di mana-mana?  Dia tidak menggunakan penghitung atom untuk ini? </li><li>  Jumlah jalur aktif masih berkurang, jadi bagaimana skema ini bisa membantu sama sekali? </li></ul><br>  Mari kita mulai dengan pertanyaan terakhir: jika kita mentransfer sejuta tugas ke GPU, itu tidak akan menghasilkan sejuta utas.  Jumlah sebenarnya dari thread yang dijalankan secara bersamaan tergantung pada peralatan, tetapi dalam kasus umum, puluhan ribu thread dieksekusi.  Hanya ketika bebannya turun di bawah angka ini kita akan melihat masalah ketenagakerjaan yang disebabkan oleh sejumlah kecil tugas. <br><br>  Kekhawatiran lain adalah I / O buffer dalam skala besar.  Ini memang kesulitan, tetapi tidak seserius yang Anda duga: akses ke data sangat mudah diprediksi, terutama saat menulis ke buffer, sehingga penundaan tidak menyebabkan masalah.  Faktanya, GPU terutama dikembangkan untuk jenis pemrosesan data ini. <br><br>  Aspek lain yang ditangani GPU dengan sangat baik adalah penghitung atom, yang sangat tidak terduga bagi programmer yang bekerja di dunia CPU.  Z-buffer memerlukan akses cepat, dan karenanya penerapan penghitung atom dalam GPU modern sangat efektif.  Dalam praktiknya, operasi penulisan atom sama mahalnya dengan menulis yang tidak di-cache ke memori global.  Dalam banyak kasus, penundaan akan tertutupi oleh eksekusi paralel skala besar di GPU. <br><br>  Masih ada dua pertanyaan: panggilan kernel dan transfer data dua arah untuk penghitung.  Yang terakhir ini sebenarnya masalah, jadi kita perlu perubahan arsitektur lain: <em>utas yang persisten</em> . <br><br><h2>  Konsekuensinya </h2><br>  Sebelum mempelajari detailnya, kita akan melihat implikasi dari penggunaan algoritma penelusuran jalur gelombang.  Pertama, katakanlah tentang buffer.  Kami membutuhkan buffer untuk menampilkan data tahap 1, yaitu  sinar primer.  Untuk setiap balok kita membutuhkan: <br><br><ul><li>  Asal berkas: tiga nilai float, mis. 12 byte </li><li>  Arah ray: tiga nilai float, mis. 12 byte </li></ul><br>  Dalam praktiknya, lebih baik menambah ukuran buffer.  Jika Anda menyimpan 16 byte untuk awal dan arah berkas, GPU akan dapat membacanya dalam satu operasi baca 128-bit.  Alternatifnya adalah operasi membaca 64-bit diikuti oleh operasi 32-bit untuk mendapatkan float3, yang hampir dua kali lebih lambat.  Yaitu, untuk layar 1920 Ã— 1080 kita mendapatkan: 1920x1080x32 = ~ 64 MB.  Kami juga membutuhkan buffer untuk hasil persimpangan yang dibuat oleh Extend kernel.  Ini adalah 128 bit per elemen, yaitu 32 MB.  Lebih lanjut, kernel "Shadow" dapat membuat ekstensi path 1920x1080 (batas atas), dan kami tidak dapat menulisnya ke buffer dari mana kita membaca.  Itu adalah 64 MB.  Dan akhirnya, jika pelacak jalur kami memancarkan sinar bayangan, maka ini adalah buffer 64 MB lainnya.  Setelah merangkum semuanya, kami mendapatkan 224 MB data, dan ini hanya untuk algoritme wavefront.  Atau sekitar 1 GB dalam resolusi 4K. <br><br>  Di sini kita perlu terbiasa dengan fitur lain: kita memiliki banyak memori.  Tampaknya.  1 GB itu banyak, dan ada cara untuk mengurangi angka ini, tetapi jika Anda mendekati ini secara realistis, maka pada saat kita benar-benar perlu melacak jalur di 4K, menggunakan 1 GB pada GPU dengan 8 GB akan lebih sedikit dari masalah kita. <br><br>  Lebih serius daripada persyaratan memori, konsekuensinya adalah algoritma rendering.  Sejauh ini saya telah menyarankan bahwa kita perlu menghasilkan satu sinar ekstensi dan, mungkin, satu bayangan bayangan untuk setiap thread di inti Shadow.  Tetapi bagaimana jika kita ingin melakukan Ambient Occlusion menggunakan 16 sinar per pixel?  16 sinar AO perlu disimpan dalam buffer, tetapi, lebih buruk lagi, mereka hanya akan muncul di iterasi berikutnya.  Masalah serupa muncul ketika menelusuri sinar dalam gaya Witted: memancarkan sinar bayangan untuk beberapa sumber cahaya atau membelah balok dalam tabrakan dengan kaca hampir mustahil untuk diwujudkan. <br><br>  Di sisi lain, penelusuran jalur gelombang menyelesaikan masalah yang telah kami daftarkan di bagian Hunian: <br><br><ul><li>  Pada tahap 1, semua aliran tanpa kondisi membuat sinar primer dan menuliskannya ke buffer. </li><li>  Pada tahap 2, semua aliran tanpa kondisi memotong sinar dengan adegan dan menulis hasil persimpangan ke buffer. </li><li>  Pada langkah 3, kami mulai menghitung hasil persimpangan dengan hunian 100%. </li><li>  Pada langkah 4, kami memproses daftar sinar bayangan terus menerus tanpa spasi. </li></ul><br>  Pada saat kita kembali ke tahap 2 dengan sinar yang masih hidup dengan panjang 2 segmen, kita kembali mendapatkan buffer ray kompak, yang menjamin pekerjaan penuh ketika kernel dimulai. <br><br>  Selain itu, ada keuntungan tambahan yang tidak boleh diremehkan.  Kode ini diisolasi dalam empat langkah terpisah.  Setiap inti dapat menggunakan semua sumber daya GPU yang tersedia (cache, memori bersama, register) tanpa memperhitungkan inti lainnya.  Ini memungkinkan GPU untuk mengeksekusi kode persimpangan dengan adegan di lebih banyak utas, karena kode ini tidak memerlukan register sebanyak kode shader.  Semakin banyak utas, semakin baik Anda bisa menyembunyikan penundaan. <br><br>  Full-time, penyempurnaan penundaan tunda, rekaman streaming: semua manfaat ini terkait langsung dengan kemunculan dan sifat platform GPU.  Untuk GPU, algoritma penelusuran jalur gelombang sangat alami. <br><br><h2>  Apakah itu sepadan? </h2><br>  Tentu saja, kami memiliki pertanyaan: apakah pekerjaan yang dioptimalkan membenarkan I / O dari buffer dan biaya untuk meminta core tambahan? <br><br>  Jawabannya adalah ya, tetapi membuktikan ini tidak mudah. <br><br>  Jika kita kembali ke pelacak trek dengan ShaderToy sebentar, kita akan melihat bahwa sebagian besar dari mereka menggunakan adegan sederhana dan kode keras.  Menggantinya dengan adegan full-blown bukanlah tugas yang sepele: bagi jutaan primitif, memotong balok dan adegan menjadi masalah yang kompleks, solusinya sering diserahkan kepada NVidia ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Optix</a> ), AMD ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Radeon-Rays</a> ) atau Intel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Embree</a> ).  Tak satu pun dari opsi ini dapat dengan mudah menggantikan adegan hard-coded dalam pelacak ray buatan CUDA.  Dalam CUDA, analog terdekat (Optix) membutuhkan kontrol atas eksekusi program.  Embree dalam CPU memungkinkan Anda untuk melacak balok individu dari kode Anda sendiri, tetapi biaya ini adalah overhead kinerja yang signifikan: ia lebih suka melacak kelompok balok besar daripada balok individu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb4/2a2/409/fb42a240924ba04871abb70421d16cdf.png"></div><br>  <i>Layar dari It's About Time diberikan bersama Brigade 1.</i> <br><br>  Akankah pelacakan jalur gelombang lebih cepat daripada alternatifnya (megakernel, seperti yang Lane dan rekannya sebutkan) tergantung pada waktu yang dihabiskan di inti (adegan besar dan shaders yang mahal mengurangi biaya relatif yang dibanjiri oleh algoritma muka gelombang), pada panjang jalur maksimum , pekerjaan mega-core dan perbedaan beban pada register dalam empat tahap.  Dalam versi awal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Brigade Path Tracer asli,</a> kami menemukan bahwa bahkan adegan sederhana dengan campuran permukaan reflektif dan Lambert yang berjalan pada GTX480 diuntungkan dengan menggunakan muka gelombang. <br><br><h2>  Streaming Path Tracing di Mercusuar 2 </h2><br>  Platform Lighthouse 2 memiliki dua jalur pelacak jejak gelombang.  Yang pertama menggunakan Optix Prime untuk implementasi tahap 2 dan 4 (tahap persimpangan sinar dan adegan);  yang kedua, Optix digunakan langsung untuk mengimplementasikan fungsi itu. <br><br>  Optix Prime adalah versi sederhana dari Optix yang hanya berurusan dengan persimpangan satu set balok dengan adegan yang terdiri dari segitiga.  Tidak seperti perpustakaan Optix lengkap, itu tidak mendukung kode persimpangan khusus, dan hanya memotong segitiga.  Namun, ini adalah persis apa yang diperlukan untuk pelacak jalur gelombang. <br><br>  Optix Prime berbasis pelacak jalur gelombang diimplementasikan dalam <code>rendercore.cpp</code> proyek <code>rendercore.cpp</code> .  Inisialisasi Optix Prime dimulai pada fungsi <code>Init</code> dan menggunakan <code>rtpContextCreate</code> .  Adegan dibuat menggunakan <code>rtpModelCreate</code> .  Berbagai buffer ray dibuat dalam fungsi <code>rtpBufferDescCreate</code> menggunakan <code>rtpBufferDescCreate</code> .  Perhatikan bahwa untuk buffer ini kami menyediakan pointer perangkat yang biasa: ini berarti bahwa mereka dapat digunakan baik di Optix dan di core CUDA biasa. <br><br>  Render dimulai dalam metode <code>Render</code> .  Untuk mengisi buffer ray primer, sebuah inti CUDA yang disebut <code>generateEyeRays</code> .  Setelah mengisi buffer, Optix Prime disebut menggunakan <code>rtpQueryExecute</code> .  Dengan itu, hasil persimpangan ditulis ke <code>extensionHitBuffer</code> .  Perhatikan bahwa semua buffer tetap berada dalam GPU: dengan pengecualian panggilan kernel, tidak ada lalu lintas antara CPU dan GPU.  Tahap "Bayangan" diimplementasikan dalam inti <code>shade</code> CUDA biasa.  Implementasinya ada di <code>pathtracer.cu</code> . <br><br>  Beberapa detail implementasi untuk <code>optixprime_b</code> layak disebutkan.  Pertama, bayangan bayangan dilacak di luar siklus muka gelombang.  Ini benar: sinar bayangan memengaruhi piksel hanya jika tidak diblokir, tetapi dalam semua kasus hasilnya tidak diperlukan di tempat lain.  Artinya, bayangan balok <em>sekali pakai</em> , dapat ditelusuri kapan saja dan dalam urutan apa pun.  Dalam kasus kami, kami menggunakan ini dengan mengelompokkan sinar bayangan sehingga bets akhirnya ditelusuri sebesar mungkin.  Ini memiliki satu konsekuensi yang tidak menyenangkan: dengan iterasi <em>N</em> dari algoritma muka gelombang dan <em>sinar</em> primer X, batas atas jumlah sinar bayangan sama dengan <em>XN</em> . <br><br>  Detail lainnya adalah pemrosesan berbagai counter.  Tahap "Memperbarui" dan "Bayangan" harus tahu berapa banyak jalur yang aktif.  Penghitung untuk ini diperbarui dalam GPU (secara atomis), yang berarti mereka digunakan dalam GPU, bahkan tanpa kembali ke CPU.  Sayangnya, dalam salah satu kasus ini tidak mungkin: perpustakaan Optix Prime perlu mengetahui jumlah sinar yang dilacak.  Untuk melakukan ini, kita perlu mengembalikan informasi dari penghitung sekali iterasi. <br><br><h2>  Kesimpulan </h2><br>  Artikel ini menjelaskan apa yang dimaksud dengan penelusuran jalur gelombang dan mengapa perlu untuk melakukan pelacakan jalur secara efektif pada GPU.  Implementasi praktisnya disajikan dalam platform Lighthouse 2, yang bersifat open source dan <a href="">tersedia di Github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461017/">https://habr.com/ru/post/id461017/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461005/index.html">Pengujian untuk perusahaan: mengajukan pertanyaan yang tepat saat wawancara</a></li>
<li><a href="../id461007/index.html">Memulai dengan Analyzer Statis PVS-Studio untuk Visual C ++</a></li>
<li><a href="../id461009/index.html">Cara membuat standar dalam 10 hari. Bagian Dua Membosankan</a></li>
<li><a href="../id461013/index.html">Pemesanan koneksi internet</a></li>
<li><a href="../id461015/index.html">Hidup dan belajar. Bagian 2. Universitas: 5 tahun atau 5 koridor?</a></li>
<li><a href="../id461019/index.html">Bagaimana kehidupan para pengembang di Iran</a></li>
<li><a href="../id461027/index.html">Java REPL Anda tidak menggunakan ScriptEngine</a></li>
<li><a href="../id461029/index.html">Danau data pemasaran - dari tabel mengerikan hingga laporan dan visualisasi</a></li>
<li><a href="../id461031/index.html">Kami menghubungkan peta online ke navigator di smartphone. Bagian 1 - peta raster standar</a></li>
<li><a href="../id461033/index.html">Dari mana konfigurasi ini berasal? [Debian / Ubuntu]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>