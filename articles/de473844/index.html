<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå¶Ô∏è üö∏ üôÖüèø Warum brauchen wir Bereiche von C ++ 20 in einem einfachen Brecher? üë®üèΩ‚Äçüîß üë©üèΩ‚Äçüåæ üå¨Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In letzter Zeit wurden die Bereiche, die in den C ++ 20-Standard aufgenommen werden sollten, viel diskutiert, einschlie√ülich Habr√© ( ein Beispiel, in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum brauchen wir Bereiche von C ++ 20 in einem einfachen Brecher?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473844/"><p>  In letzter Zeit wurden <em>die</em> Bereiche, die in den C ++ 20-Standard aufgenommen werden sollten, viel diskutiert, einschlie√ülich Habr√© ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel, in dem es viele Beispiele gibt</a> ).  Es gibt genug Kritiker von Intervallen, das sagen sie </p><br><ul><li>  Sie sind zu abstrakt und werden nur f√ºr sehr abstrakten Code ben√∂tigt </li><li>  Die Lesbarkeit des Codes mit ihnen verschlechtert sich nur </li><li>  Intervalle verlangsamen den Code </li></ul><br><p>  Mal sehen, ganz <del>  Arbeiter-Bauer </del>  praktische Aufgabe, um zu verstehen, ob diese Kritik g√ºltig ist <del>  und ist es wahr, dass Eric Nibler von Bartosz Milewski gebissen wurde und Range-v3 nur bei Vollmond schreibt </del>  . </p><br><p><img src="https://habrastorage.org/webt/pb/dt/ih/pbdtihbl4gn8qiqwr5uk_j8qi0a.png" alt="kdpv"></p><br><p>  Wir werden die folgende Funktion mit der Trapezmethode integrieren: <math> </math> $ inline $ f (t) = 3 t ^ 2 \ sin t ^ 3 $ inline $   im Bereich von Null bis <math> </math> $ inline $ \ tau $ inline $   .  Wenn <math> </math> $ inline $ \ tau ^ 3 / \ pi $ inline $   gleich einer ungeraden Zahl, dann ist das Integral 2. </p><a name="habracut"></a><br><p> Das Problem: Wir schreiben einen Prototyp einer Funktion, die das Integral <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nach der Trapezmethode berechnet</a> .  Auf den ersten Blick scheint es, dass hier keine Abstraktionen ben√∂tigt werden, aber Geschwindigkeit ist wichtig.  In der Tat ist dies nicht ganz richtig.  F√ºr die Arbeit muss ich oft "Zahlenbrecher" schreiben, deren Hauptnutzer ich selbst bin.  Also muss ich auch ihre Fehler unterst√ºtzen und damit umgehen (leider meine Kollegen - nicht immer nur ich).  Und es kommt auch vor, dass Code nicht verwendet wird, beispielsweise ein Jahr, und dann ... Im Allgemeinen m√ºssen auch Dokumentation und Tests geschrieben werden. </p><br><p>  Welche Argumente sollte eine Integratorfunktion haben?  Integrierbare Funktion und Gitter (Punktmenge <math> </math> $ inline $ t_1, t_2, t_3 ... $ inline $  zur Berechnung des Integrals verwendet).  Und wenn mit der integrierten Funktion alles klar ist ( <code>std::function</code> ist hier genau richtig), in welcher Form soll dann das Netz √ºbertragen werden?  Mal sehen. </p><br><h2 id="varianty">  Optionen </h2><br><p>  Zun√§chst schreiben wir - damit es etwas gibt, mit dem man die Leistung vergleichen kann - eine einfache <code>for</code> Schleife mit einem konstanten Zeitschritt: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// trapezoidal rule of integration with fixed time step; // dt_fixed is the timestep; n_fixed is the number of steps double integrate() { double acc = 0; for(long long i = 1; i &lt; n_fixed - 1; ++i) { double t = dt_fixed * static_cast&lt;double&gt;(i); acc += dt_fixed * f(t); } acc += 0.5 * dt_fixed * f(0); acc += 0.5 * dt_fixed * f(tau); return acc; }</span></span></code> </pre> <br><p>  Wenn Sie diesen Zyklus verwenden, k√∂nnen Sie den Beginn und das Ende des Integrationsintervalls sowie die Anzahl der Punkte f√ºr diese Integration selbst als Argumente an die Funktion √ºbergeben.  Stop - die Trapezmethode findet auch mit einem variablen Schritt statt, und unsere integrierbare Funktion fordert einfach die Verwendung eines variablen Schritts an!  Lassen Sie uns noch einen Parameter haben ( <math> </math> $ inline $ b $ inline $   ) um die "Nichtlinearit√§t" zu kontrollieren und unsere Schritte zum Beispiel wie folgt aussehen zu lassen: <math> </math> $ inline $ \ Delta t (t) = \ Delta t_0 + bt $ inline $   .  Dieser Ansatz (Einf√ºhrung eines zus√§tzlichen numerischen Parameters) wird wahrscheinlich an einer Million Stellen verwendet, obwohl sein Fehler anscheinend f√ºr alle offensichtlich sein sollte.  Und wenn wir eine andere Funktion haben?  Und wenn wir irgendwo in der Mitte unseres numerischen Intervalls einen kleinen Schritt brauchen?  Was aber, wenn eine integrierbare Funktion mehrere Funktionen aufweist?  Im Allgemeinen m√ºssen wir in der Lage sein, <em>jedes</em> Gitter zu vermitteln.  (Trotzdem werden wir in den Beispielen bis zum Ende die reale Trapezmethode ‚Äûvergessen‚Äú und der Einfachheit halber ihre Version mit einem konstanten Schritt betrachten, wobei zu ber√ºcksichtigen ist, dass das Gitter beliebig sein kann). </p><br><p>  Da das Raster beliebig sein kann, √ºbergeben wir seine Werte <math> </math> $ inline $ t_1, t_2, ... $ inline $   eingewickelt in <code>std::vector</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// trapezoidal rule of integration with fixed time step double integrate(vector&lt;double&gt; t_nodes) { double acc = 0; for(auto t: t_nodes) { acc += dt_fixed * f(t); } acc -= 0.5 * dt_fixed * f(0); acc -= 0.5 * dt_fixed * f(tau); return acc; }</span></span></code> </pre> <br><p>  Es gibt mehr als genug Communities in diesem Ansatz, aber was ist mit der Leistung?  Mit Speicherverbrauch?  Wenn fr√ºher alles auf dem Prozessor zusammengefasst wurde, m√ºssen wir jetzt zuerst den Speicherbereich ausf√ºllen und dann daraus lesen.  Und die Kommunikation mit dem Ged√§chtnis ist ziemlich langsam.  Und die Erinnerung ist immer noch nicht Gummi ( <del>  und Silikon </del>  ) </p><br><p>  Schauen wir uns die Wurzel des Problems an.  Was braucht ein Mensch, um gl√ºcklich zu sein?  Was braucht unser Zyklus (bereichsbasiert f√ºr Schleife)?  Jeder Container mit Iteratoren <code>begin()</code> und <code>end()</code> sowie <code>++</code> , <code>*</code> und <code>!=</code> Operatoren f√ºr Iteratoren.  Also werden wir schreiben. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    ,      template &lt;typename T&gt; double integrate(T t_nodes) { double acc = 0; for(auto t: t_nodes) { acc += dt_fixed * f(t); } acc -= 0.5 * dt_fixed * f(0); acc -= 0.5 * dt_fixed * f(tau); return acc; } // ... //      class lazy_container { public: long long int n_nodes; lazy_container() { n_nodes = n_fixed; } ~lazy_container() {} class iterator { public: long long int i; // index of the current node iterator() { i = 0; } ~iterator() {} iterator&amp; operator++() { i+= 1; return *this; } // ! bool operator!=(const iterator&amp; rhs) const { return i != rhs.i; } double operator* () const { return dt_fixed * static_cast&lt;double&gt;(i); } }; iterator begin() { return iterator(); } iterator end() { iterator it; it.i = n_nodes; return it; } }; // ... //      lazy_container t_nodes; double res = integrate(t_nodes);</span></span></code> </pre> <br><p>  Wir berechnen hier einen neuen Wert. <math> </math> $ inline $ t_i $ inline $   auf Anfrage, genau wie wir es in einer einfachen <code>for</code> Schleife getan haben.  Es gibt keine Speicherzugriffe und es besteht die Hoffnung, dass moderne Compiler den Code sehr effizient vereinfachen.  Gleichzeitig hat sich der Code der Integrationsfunktion nicht wesentlich ge√§ndert und kann <code>std::vector</code> . </p><br><p>  Wo ist die Flexibilit√§t?  Tats√§chlich k√∂nnen wir jetzt jede Funktion in den <code>++</code> Operator schreiben.  Das hei√üt, dieser Ansatz erm√∂glicht es tats√§chlich, eine Funktion anstelle eines einzelnen numerischen Parameters zu √ºbertragen.  Das im laufenden Betrieb erzeugte Raster kann beliebig sein, und wir verlieren (wahrscheinlich) auch nicht an Leistung.  Es f√ºhlt sich jedoch √ºberhaupt nicht <code>lazy_container</code> jedes Mal einen neuen <code>lazy_container</code> zu schreiben, um das Raster auf eine neue Weise zu verzerren (es sind die gleichen 27 Zeilen!).  Nat√ºrlich k√∂nnen Sie die Funktion, die f√ºr die Erzeugung des Rasters verantwortlich ist, zu einem Parameter unserer Integrationsfunktion machen und <code>lazy_container</code> , <code>lazy_container</code> entschuldigen Sie, kapseln Sie ihn. </p><br><p>  Sie fragen - dann wird wieder etwas falsch sein?  Ja!  Zun√§chst muss die Anzahl der zu integrierenden Punkte separat √ºbertragen werden, was zu einem Fehler f√ºhren kann.  Zweitens muss das erstellte nicht standardm√§√üige Fahrrad von jemandem unterst√ºtzt und m√∂glicherweise entwickelt werden.  K√∂nnen Sie sich zum Beispiel sofort vorstellen, wie Sie mit diesem Ansatz einen Kombinator f√ºr Funktionen im <code>++</code> Operator <code>++</code> k√∂nnen? </p><br><p>  C ++ seit √ºber 30 Jahren.  Viele in diesem Alter haben bereits Kinder, und C ++ hat nicht einmal Standard-Lazy-Container / Iteratoren.  Ein Albtraum!  Aber alles (im Sinne von Iteratoren, nicht von Kindern) wird sich bereits im n√§chsten Jahr √§ndern - der Standard (m√∂glicherweise teilweise) wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Range-v3-</a> Bibliothek enthalten, die von Eric Nibler seit mehreren Jahren entwickelt wurde.  Wir werden die Werke seiner Fr√ºchte verwenden.  Der Code sagt alles f√ºr sich: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;range/v3/view/iota.hpp&gt; #include &lt;range/v3/view/transform.hpp&gt; //... auto t_nodes = ranges::v3::iota_view(0, n_fixed) | ranges::v3::views::transform( [](long long i){ return dt_fixed * static_cast&lt;double&gt;(i); } ); double res = integrate(t_nodes);</span></span></span></span></code> </pre> <br><p>  Die Integrationsfunktion bleibt gleich.  Das hei√üt, nur 3 Zeilen, um unser Problem zu l√∂sen!  Hier erzeugt <code>iota_view(0, n)</code> ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verz√∂gertes</a> <em>Intervall</em> (Bereich, ein Objekt, das den verallgemeinerten Anfang und das verallgemeinerte Ende kapselt; ein verz√∂gerter Bereich ist eine Ansicht), das bei Iteration bei jedem Schritt die n√§chste Zahl im Bereich [0, n] berechnet.  Es ist lustig, dass der Name Œπ (der griechische Buchstabe iota) vor 50 Jahren auf die APL-Sprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verweist</a> .  Stick <code>|</code>  Mit dieser Option k√∂nnen Sie Pipelines von Intervallmodifikatoren schreiben, und die <code>transform</code> ist in der Tat ein solcher Modifikator, der mithilfe einer einfachen Lambda-Funktion eine Folge von Ganzzahlen in eine Reihe <code>transform</code> <math> </math> $ inline $ t_1, t_2, ... $ inline $   .  Alles ist einfach wie in <del>  ein M√§rchen </del>  Haskell. </p><br><p>  Aber wie macht man einen variablen Schritt?  Alles ist genauso einfach: </p><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen Mathe</b> <div class="spoiler_text"><p>  Als festen Schritt haben wir ein Zehntel unserer Funktionsperiode nahe der oberen Integrationsgrenze genommen <math> </math> $ inline $ \ Delta t_ {fixed} = 0.1 \ times 2 \ pi / 3 \ tau ^ 2 $ inline $   .  Jetzt wird der Schritt variabel sein: Sie werden es bemerken, wenn Sie nehmen <math> </math> $ inline $ t_i = \ tau (i / n) ^ {1/3} $ inline $   , (wo <math> </math> $ inline $ n $ inline $   Ist die Gesamtzahl der Punkte), dann wird der Schritt sein <math> </math> $ inline $ \ Delta t (t) \ ca. dt_i / di = \ tau ^ 3 / (3 nt ^ 2) $ inline $   Dies ist ein Zehntel der Periode einer integrierbaren Funktion f√ºr eine gegebene <math> </math> $ inline $ t $ inline $   wenn <math> </math> $ inline $ n = \ tau ^ 3 / (0.1 \ times 2 \ pi) $ inline $   .  Es bleibt zu "vern√ºnftigen" Partition f√ºr kleine Werte <math> </math> $ inline $ i $ inline $   . </p></div></div><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;range/v3/view/drop.hpp&gt; #include &lt;range/v3/view/iota.hpp&gt; #include &lt;range/v3/view/transform.hpp&gt; //... // trapezoidal rule of integration; step size is not fixed template &lt;typename T&gt; double integrate(T t_nodes) { double acc = 0; double t_prev = *(t_nodes.begin()); double f_prev = f(t_prev); for (auto t: t_nodes | ranges::v3::views::drop(1)) { double f_curr = f(t); acc += 0.5 * (t - t_prev) * (f_curr + f_prev); t_prev = t; f_prev = f_curr; } return acc; } //... auto step_f = [](long long i) { if (static_cast&lt;double&gt;(i) &lt;= 1 / a) { return pow(2 * M_PI, 1/3.0) * a * static_cast&lt;double&gt;(i); } else { return tau * pow(static_cast&lt;double&gt;(i) / static_cast&lt;double&gt;(n), 1/3.0); } }; auto t_nodes = ranges::v3::iota_view(0, n) | ranges::v3::views::transform(step_f); double res = integrate(t_nodes);</span></span></span></span></code> </pre> <br><p>  Ein aufmerksamer Leser stellte fest, dass wir in unserem Beispiel durch den variablen Schritt die Anzahl der Gitterpunkte um den Faktor drei reduzieren konnten, w√§hrend zus√§tzlich sp√ºrbare Kosten f√ºr die Berechnung anfallen <math> </math> $ inline $ t_i $ inline $   .  Aber wenn wir noch einen nehmen <math> </math> $ inline $ f (t) $ inline $   kann sich die Anzahl der Punkte viel mehr √§ndern ... (aber hier wird der Autor schon faul). </p><br><h2 id="itak-taymingi">  Also Timings </h2><br><p>  Wir haben folgende M√∂glichkeiten: </p><br><ul><li>  v1 - einfache Schleife </li><li>  v2 - <math> </math> $ inline $ t_i $ inline $   liegen in <code>std::vector</code> </li><li>  v3 - notd√ºrftiger <code>lazy_container</code> mit notd√ºrftigem Iterator </li><li>  v4 - Intervalle von C ++ 20 (Bereiche) </li><li>  v5 - Bereiche wieder, aber nur hier wird die Trapezmethode mit einer variablen Tonh√∂he geschrieben </li></ul><br><p>  Hier ist, wof√ºr es sich herausstellt (in Sekunden) <math> </math> $ inline $ \ tau = (10 \, 000 \, 001 \ times \ pi) ^ {1/3} $ inline $   , f√ºr g ++ 8.3.0 und clang ++ 8.0.0 auf Intel¬Æ Xeon¬Æ CPU¬Æ X5550 (Anzahl der Schritte ungef√§hr <math> </math> $ inline $ 1.5 \ times 10 ^ 8 $ inline $   , mit Ausnahme von v5, wo die Schritte dreimal kleiner sind (das Ergebnis der Berechnungen aller Methoden unterscheidet sich von den beiden um nicht mehr als 0,07): </p><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  v1 </td><td>  v2 </td><td>  v3 </td><td>  v4 </td><td>  v5 </td></tr><tr><td>  g ++ </td><td>  4.7 </td><td>  6.7 </td><td>  4.6 </td><td>  3.7 </td><td>  4.3 </td></tr><tr><td>  clang ++ </td><td>  5.0 </td><td>  7.2 </td><td>  4.6 </td><td>  4.8 </td><td>  4.1 </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">Fahnen ~~ aus farbigem Papier ~~</b> <div class="spoiler_text"><p>  g ++ -O3 -ffast-math -std = c ++ 2a -Wall -Wpedantic -I range-v3 / include <br>  clang ++ -Ofast -std = c ++ 2a -Wall -Wpedantic -I range-v3 / include </p></div></div><br><p>  Im Allgemeinen ging die Fliege √ºber das Feld, die Fliege fand eine M√ºnze! </p><br><div class="spoiler">  <b class="spoiler_title">g ++ im Debug-Modus</b> <div class="spoiler_text"><p>  Es kann f√ºr jemanden wichtig sein </p><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  v1 </td><td>  v2 </td><td>  v3 </td><td>  v4 </td><td>  v5 </td></tr><tr><td>  g ++ </td><td>  5.9 </td><td>  17.8 </td><td>  7.2 </td><td>  33.6 </td><td>  14.3 </td></tr></tbody></table></div></div></div><br><h2 id="itog">  Zusammenfassung </h2><br><p>  Selbst in einer sehr einfachen Aufgabe erwiesen sich Bereiche als sehr n√ºtzlich: Anstelle von Code mit selbst erstellten Iteratoren in mehr als 20 Zeilen haben wir 3 Zeilen geschrieben, ohne Probleme mit der Lesbarkeit des Codes oder seiner Leistung zu haben. </p><br><p>  Wenn wir bei diesen Tests die ultimative Leistung ben√∂tigen w√ºrden, m√ºssten wir nat√ºrlich das Beste aus dem Prozessor und dem Speicher herausholen, indem wir parallelen Code schreiben (oder eine Version unter OpenCL schreiben) ... Au√üerdem habe ich keine Ahnung, was passieren wird, wenn ich schreibe sehr lange Ketten von Modifikatoren.  Ist es einfach, Compiler-Meldungen zu debuggen und zu lesen, wenn Bereiche in komplexen Projekten verwendet werden?  Erh√∂ht die Kompilierungszeit.  Ich hoffe, dass jemals jemand √ºber diesen Artikel schreibt. </p><br><p>  Als ich diese Tests schrieb, wusste ich selbst nicht, was passieren w√ºrde.  Jetzt wei√ü ich - Bereiche verdienen es definitiv, in einem realen Projekt unter den Bedingungen getestet zu werden, unter denen Sie sie verwenden m√∂chten. </p><br><p><del>  Ich ging zum Basar, um einen Samowar zu kaufen. </del></p><br><h3 id="poleznye-ssylki">  N√ºtzliche Links </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Range-V3 nach Hause</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation und Fallstudien v3</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code aus diesem Artikel auf Github</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Listen in Haskell zum Vergleich</a> </p><br><h3 id="blagodarnosti">  Danksagung </h3><br><p>  Danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">fadey,</a> dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">du</a> beim Schreiben geholfen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">hast</a> ! </p><br><h3 id="ps">  PS </h3><br><p>  Ich hoffe, jemand kommentiert solche Kuriosit√§ten: i) Wenn Sie das Integrationsintervall zehnmal kleiner nehmen, ist das Beispiel v2 auf meinem Xeon 10% schneller als v1 und v4 dreimal schneller als v1.  ii) Der Intel-Compiler (icc 2019) erstellt in diesen Beispielen manchmal Code, der doppelt so schnell ist wie kompiliertes g ++.  Ist die Vektorisierung schuld?  Kann g ++ dazu gezwungen werden? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473844/">https://habr.com/ru/post/de473844/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473832/index.html">ShIoTiny: Updates und Benachrichtigungen</a></li>
<li><a href="../de473834/index.html">Blackbox-√úberwachung in Clos-Netzwerken. Yandex-Bericht</a></li>
<li><a href="../de473838/index.html">DJI Mavic Mini: der leichteste zusammenklappbare Quadrocopter</a></li>
<li><a href="../de473840/index.html">Streamen Sie Videos vom Android-Ger√§t √ºber UDP zur JAVA-Anwendung</a></li>
<li><a href="../de473842/index.html">Oktober Maschinelles Lernen und k√ºnstliche Intelligenz News Digest</a></li>
<li><a href="../de473846/index.html">So messen Sie die Leistung von Blockchain-Netzwerken. Schl√ºsselkennzahlen</a></li>
<li><a href="../de473848/index.html">c.tech auf HighLoad ++ 2019</a></li>
<li><a href="../de473852/index.html">Vor- und Nachteile der Nachtarbeit</a></li>
<li><a href="../de473854/index.html">Wie erinnern wir uns an die letzte JokerConf?</a></li>
<li><a href="../de473856/index.html">Gef√§hrliche Leichtigkeit, mit der Sie milit√§rische k√ºnstliche Intelligenz t√§uschen k√∂nnen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>