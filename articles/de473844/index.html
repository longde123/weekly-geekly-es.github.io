<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌦️ 🚸 🙅🏿 Warum brauchen wir Bereiche von C ++ 20 in einem einfachen Brecher? 👨🏽‍🔧 👩🏽‍🌾 🌬️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In letzter Zeit wurden die Bereiche, die in den C ++ 20-Standard aufgenommen werden sollten, viel diskutiert, einschließlich Habré ( ein Beispiel, in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum brauchen wir Bereiche von C ++ 20 in einem einfachen Brecher?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473844/"><p>  In letzter Zeit wurden <em>die</em> Bereiche, die in den C ++ 20-Standard aufgenommen werden sollten, viel diskutiert, einschließlich Habré ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel, in dem es viele Beispiele gibt</a> ).  Es gibt genug Kritiker von Intervallen, das sagen sie </p><br><ul><li>  Sie sind zu abstrakt und werden nur für sehr abstrakten Code benötigt </li><li>  Die Lesbarkeit des Codes mit ihnen verschlechtert sich nur </li><li>  Intervalle verlangsamen den Code </li></ul><br><p>  Mal sehen, ganz <del>  Arbeiter-Bauer </del>  praktische Aufgabe, um zu verstehen, ob diese Kritik gültig ist <del>  und ist es wahr, dass Eric Nibler von Bartosz Milewski gebissen wurde und Range-v3 nur bei Vollmond schreibt </del>  . </p><br><p><img src="https://habrastorage.org/webt/pb/dt/ih/pbdtihbl4gn8qiqwr5uk_j8qi0a.png" alt="kdpv"></p><br><p>  Wir werden die folgende Funktion mit der Trapezmethode integrieren: <math> </math> $ inline $ f (t) = 3 t ^ 2 \ sin t ^ 3 $ inline $   im Bereich von Null bis <math> </math> $ inline $ \ tau $ inline $   .  Wenn <math> </math> $ inline $ \ tau ^ 3 / \ pi $ inline $   gleich einer ungeraden Zahl, dann ist das Integral 2. </p><a name="habracut"></a><br><p> Das Problem: Wir schreiben einen Prototyp einer Funktion, die das Integral <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nach der Trapezmethode berechnet</a> .  Auf den ersten Blick scheint es, dass hier keine Abstraktionen benötigt werden, aber Geschwindigkeit ist wichtig.  In der Tat ist dies nicht ganz richtig.  Für die Arbeit muss ich oft "Zahlenbrecher" schreiben, deren Hauptnutzer ich selbst bin.  Also muss ich auch ihre Fehler unterstützen und damit umgehen (leider meine Kollegen - nicht immer nur ich).  Und es kommt auch vor, dass Code nicht verwendet wird, beispielsweise ein Jahr, und dann ... Im Allgemeinen müssen auch Dokumentation und Tests geschrieben werden. </p><br><p>  Welche Argumente sollte eine Integratorfunktion haben?  Integrierbare Funktion und Gitter (Punktmenge <math> </math> $ inline $ t_1, t_2, t_3 ... $ inline $  zur Berechnung des Integrals verwendet).  Und wenn mit der integrierten Funktion alles klar ist ( <code>std::function</code> ist hier genau richtig), in welcher Form soll dann das Netz übertragen werden?  Mal sehen. </p><br><h2 id="varianty">  Optionen </h2><br><p>  Zunächst schreiben wir - damit es etwas gibt, mit dem man die Leistung vergleichen kann - eine einfache <code>for</code> Schleife mit einem konstanten Zeitschritt: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// trapezoidal rule of integration with fixed time step; // dt_fixed is the timestep; n_fixed is the number of steps double integrate() { double acc = 0; for(long long i = 1; i &lt; n_fixed - 1; ++i) { double t = dt_fixed * static_cast&lt;double&gt;(i); acc += dt_fixed * f(t); } acc += 0.5 * dt_fixed * f(0); acc += 0.5 * dt_fixed * f(tau); return acc; }</span></span></code> </pre> <br><p>  Wenn Sie diesen Zyklus verwenden, können Sie den Beginn und das Ende des Integrationsintervalls sowie die Anzahl der Punkte für diese Integration selbst als Argumente an die Funktion übergeben.  Stop - die Trapezmethode findet auch mit einem variablen Schritt statt, und unsere integrierbare Funktion fordert einfach die Verwendung eines variablen Schritts an!  Lassen Sie uns noch einen Parameter haben ( <math> </math> $ inline $ b $ inline $   ) um die "Nichtlinearität" zu kontrollieren und unsere Schritte zum Beispiel wie folgt aussehen zu lassen: <math> </math> $ inline $ \ Delta t (t) = \ Delta t_0 + bt $ inline $   .  Dieser Ansatz (Einführung eines zusätzlichen numerischen Parameters) wird wahrscheinlich an einer Million Stellen verwendet, obwohl sein Fehler anscheinend für alle offensichtlich sein sollte.  Und wenn wir eine andere Funktion haben?  Und wenn wir irgendwo in der Mitte unseres numerischen Intervalls einen kleinen Schritt brauchen?  Was aber, wenn eine integrierbare Funktion mehrere Funktionen aufweist?  Im Allgemeinen müssen wir in der Lage sein, <em>jedes</em> Gitter zu vermitteln.  (Trotzdem werden wir in den Beispielen bis zum Ende die reale Trapezmethode „vergessen“ und der Einfachheit halber ihre Version mit einem konstanten Schritt betrachten, wobei zu berücksichtigen ist, dass das Gitter beliebig sein kann). </p><br><p>  Da das Raster beliebig sein kann, übergeben wir seine Werte <math> </math> $ inline $ t_1, t_2, ... $ inline $   eingewickelt in <code>std::vector</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// trapezoidal rule of integration with fixed time step double integrate(vector&lt;double&gt; t_nodes) { double acc = 0; for(auto t: t_nodes) { acc += dt_fixed * f(t); } acc -= 0.5 * dt_fixed * f(0); acc -= 0.5 * dt_fixed * f(tau); return acc; }</span></span></code> </pre> <br><p>  Es gibt mehr als genug Communities in diesem Ansatz, aber was ist mit der Leistung?  Mit Speicherverbrauch?  Wenn früher alles auf dem Prozessor zusammengefasst wurde, müssen wir jetzt zuerst den Speicherbereich ausfüllen und dann daraus lesen.  Und die Kommunikation mit dem Gedächtnis ist ziemlich langsam.  Und die Erinnerung ist immer noch nicht Gummi ( <del>  und Silikon </del>  ) </p><br><p>  Schauen wir uns die Wurzel des Problems an.  Was braucht ein Mensch, um glücklich zu sein?  Was braucht unser Zyklus (bereichsbasiert für Schleife)?  Jeder Container mit Iteratoren <code>begin()</code> und <code>end()</code> sowie <code>++</code> , <code>*</code> und <code>!=</code> Operatoren für Iteratoren.  Also werden wir schreiben. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    ,      template &lt;typename T&gt; double integrate(T t_nodes) { double acc = 0; for(auto t: t_nodes) { acc += dt_fixed * f(t); } acc -= 0.5 * dt_fixed * f(0); acc -= 0.5 * dt_fixed * f(tau); return acc; } // ... //      class lazy_container { public: long long int n_nodes; lazy_container() { n_nodes = n_fixed; } ~lazy_container() {} class iterator { public: long long int i; // index of the current node iterator() { i = 0; } ~iterator() {} iterator&amp; operator++() { i+= 1; return *this; } // ! bool operator!=(const iterator&amp; rhs) const { return i != rhs.i; } double operator* () const { return dt_fixed * static_cast&lt;double&gt;(i); } }; iterator begin() { return iterator(); } iterator end() { iterator it; it.i = n_nodes; return it; } }; // ... //      lazy_container t_nodes; double res = integrate(t_nodes);</span></span></code> </pre> <br><p>  Wir berechnen hier einen neuen Wert. <math> </math> $ inline $ t_i $ inline $   auf Anfrage, genau wie wir es in einer einfachen <code>for</code> Schleife getan haben.  Es gibt keine Speicherzugriffe und es besteht die Hoffnung, dass moderne Compiler den Code sehr effizient vereinfachen.  Gleichzeitig hat sich der Code der Integrationsfunktion nicht wesentlich geändert und kann <code>std::vector</code> . </p><br><p>  Wo ist die Flexibilität?  Tatsächlich können wir jetzt jede Funktion in den <code>++</code> Operator schreiben.  Das heißt, dieser Ansatz ermöglicht es tatsächlich, eine Funktion anstelle eines einzelnen numerischen Parameters zu übertragen.  Das im laufenden Betrieb erzeugte Raster kann beliebig sein, und wir verlieren (wahrscheinlich) auch nicht an Leistung.  Es fühlt sich jedoch überhaupt nicht <code>lazy_container</code> jedes Mal einen neuen <code>lazy_container</code> zu schreiben, um das Raster auf eine neue Weise zu verzerren (es sind die gleichen 27 Zeilen!).  Natürlich können Sie die Funktion, die für die Erzeugung des Rasters verantwortlich ist, zu einem Parameter unserer Integrationsfunktion machen und <code>lazy_container</code> , <code>lazy_container</code> entschuldigen Sie, kapseln Sie ihn. </p><br><p>  Sie fragen - dann wird wieder etwas falsch sein?  Ja!  Zunächst muss die Anzahl der zu integrierenden Punkte separat übertragen werden, was zu einem Fehler führen kann.  Zweitens muss das erstellte nicht standardmäßige Fahrrad von jemandem unterstützt und möglicherweise entwickelt werden.  Können Sie sich zum Beispiel sofort vorstellen, wie Sie mit diesem Ansatz einen Kombinator für Funktionen im <code>++</code> Operator <code>++</code> können? </p><br><p>  C ++ seit über 30 Jahren.  Viele in diesem Alter haben bereits Kinder, und C ++ hat nicht einmal Standard-Lazy-Container / Iteratoren.  Ein Albtraum!  Aber alles (im Sinne von Iteratoren, nicht von Kindern) wird sich bereits im nächsten Jahr ändern - der Standard (möglicherweise teilweise) wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Range-v3-</a> Bibliothek enthalten, die von Eric Nibler seit mehreren Jahren entwickelt wurde.  Wir werden die Werke seiner Früchte verwenden.  Der Code sagt alles für sich: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;range/v3/view/iota.hpp&gt; #include &lt;range/v3/view/transform.hpp&gt; //... auto t_nodes = ranges::v3::iota_view(0, n_fixed) | ranges::v3::views::transform( [](long long i){ return dt_fixed * static_cast&lt;double&gt;(i); } ); double res = integrate(t_nodes);</span></span></span></span></code> </pre> <br><p>  Die Integrationsfunktion bleibt gleich.  Das heißt, nur 3 Zeilen, um unser Problem zu lösen!  Hier erzeugt <code>iota_view(0, n)</code> ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verzögertes</a> <em>Intervall</em> (Bereich, ein Objekt, das den verallgemeinerten Anfang und das verallgemeinerte Ende kapselt; ein verzögerter Bereich ist eine Ansicht), das bei Iteration bei jedem Schritt die nächste Zahl im Bereich [0, n] berechnet.  Es ist lustig, dass der Name ι (der griechische Buchstabe iota) vor 50 Jahren auf die APL-Sprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verweist</a> .  Stick <code>|</code>  Mit dieser Option können Sie Pipelines von Intervallmodifikatoren schreiben, und die <code>transform</code> ist in der Tat ein solcher Modifikator, der mithilfe einer einfachen Lambda-Funktion eine Folge von Ganzzahlen in eine Reihe <code>transform</code> <math> </math> $ inline $ t_1, t_2, ... $ inline $   .  Alles ist einfach wie in <del>  ein Märchen </del>  Haskell. </p><br><p>  Aber wie macht man einen variablen Schritt?  Alles ist genauso einfach: </p><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen Mathe</b> <div class="spoiler_text"><p>  Als festen Schritt haben wir ein Zehntel unserer Funktionsperiode nahe der oberen Integrationsgrenze genommen <math> </math> $ inline $ \ Delta t_ {fixed} = 0.1 \ times 2 \ pi / 3 \ tau ^ 2 $ inline $   .  Jetzt wird der Schritt variabel sein: Sie werden es bemerken, wenn Sie nehmen <math> </math> $ inline $ t_i = \ tau (i / n) ^ {1/3} $ inline $   , (wo <math> </math> $ inline $ n $ inline $   Ist die Gesamtzahl der Punkte), dann wird der Schritt sein <math> </math> $ inline $ \ Delta t (t) \ ca. dt_i / di = \ tau ^ 3 / (3 nt ^ 2) $ inline $   Dies ist ein Zehntel der Periode einer integrierbaren Funktion für eine gegebene <math> </math> $ inline $ t $ inline $   wenn <math> </math> $ inline $ n = \ tau ^ 3 / (0.1 \ times 2 \ pi) $ inline $   .  Es bleibt zu "vernünftigen" Partition für kleine Werte <math> </math> $ inline $ i $ inline $   . </p></div></div><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;range/v3/view/drop.hpp&gt; #include &lt;range/v3/view/iota.hpp&gt; #include &lt;range/v3/view/transform.hpp&gt; //... // trapezoidal rule of integration; step size is not fixed template &lt;typename T&gt; double integrate(T t_nodes) { double acc = 0; double t_prev = *(t_nodes.begin()); double f_prev = f(t_prev); for (auto t: t_nodes | ranges::v3::views::drop(1)) { double f_curr = f(t); acc += 0.5 * (t - t_prev) * (f_curr + f_prev); t_prev = t; f_prev = f_curr; } return acc; } //... auto step_f = [](long long i) { if (static_cast&lt;double&gt;(i) &lt;= 1 / a) { return pow(2 * M_PI, 1/3.0) * a * static_cast&lt;double&gt;(i); } else { return tau * pow(static_cast&lt;double&gt;(i) / static_cast&lt;double&gt;(n), 1/3.0); } }; auto t_nodes = ranges::v3::iota_view(0, n) | ranges::v3::views::transform(step_f); double res = integrate(t_nodes);</span></span></span></span></code> </pre> <br><p>  Ein aufmerksamer Leser stellte fest, dass wir in unserem Beispiel durch den variablen Schritt die Anzahl der Gitterpunkte um den Faktor drei reduzieren konnten, während zusätzlich spürbare Kosten für die Berechnung anfallen <math> </math> $ inline $ t_i $ inline $   .  Aber wenn wir noch einen nehmen <math> </math> $ inline $ f (t) $ inline $   kann sich die Anzahl der Punkte viel mehr ändern ... (aber hier wird der Autor schon faul). </p><br><h2 id="itak-taymingi">  Also Timings </h2><br><p>  Wir haben folgende Möglichkeiten: </p><br><ul><li>  v1 - einfache Schleife </li><li>  v2 - <math> </math> $ inline $ t_i $ inline $   liegen in <code>std::vector</code> </li><li>  v3 - notdürftiger <code>lazy_container</code> mit notdürftigem Iterator </li><li>  v4 - Intervalle von C ++ 20 (Bereiche) </li><li>  v5 - Bereiche wieder, aber nur hier wird die Trapezmethode mit einer variablen Tonhöhe geschrieben </li></ul><br><p>  Hier ist, wofür es sich herausstellt (in Sekunden) <math> </math> $ inline $ \ tau = (10 \, 000 \, 001 \ times \ pi) ^ {1/3} $ inline $   , für g ++ 8.3.0 und clang ++ 8.0.0 auf Intel® Xeon® CPU® X5550 (Anzahl der Schritte ungefähr <math> </math> $ inline $ 1.5 \ times 10 ^ 8 $ inline $   , mit Ausnahme von v5, wo die Schritte dreimal kleiner sind (das Ergebnis der Berechnungen aller Methoden unterscheidet sich von den beiden um nicht mehr als 0,07): </p><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  v1 </td><td>  v2 </td><td>  v3 </td><td>  v4 </td><td>  v5 </td></tr><tr><td>  g ++ </td><td>  4.7 </td><td>  6.7 </td><td>  4.6 </td><td>  3.7 </td><td>  4.3 </td></tr><tr><td>  clang ++ </td><td>  5.0 </td><td>  7.2 </td><td>  4.6 </td><td>  4.8 </td><td>  4.1 </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">Fahnen ~~ aus farbigem Papier ~~</b> <div class="spoiler_text"><p>  g ++ -O3 -ffast-math -std = c ++ 2a -Wall -Wpedantic -I range-v3 / include <br>  clang ++ -Ofast -std = c ++ 2a -Wall -Wpedantic -I range-v3 / include </p></div></div><br><p>  Im Allgemeinen ging die Fliege über das Feld, die Fliege fand eine Münze! </p><br><div class="spoiler">  <b class="spoiler_title">g ++ im Debug-Modus</b> <div class="spoiler_text"><p>  Es kann für jemanden wichtig sein </p><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  v1 </td><td>  v2 </td><td>  v3 </td><td>  v4 </td><td>  v5 </td></tr><tr><td>  g ++ </td><td>  5.9 </td><td>  17.8 </td><td>  7.2 </td><td>  33.6 </td><td>  14.3 </td></tr></tbody></table></div></div></div><br><h2 id="itog">  Zusammenfassung </h2><br><p>  Selbst in einer sehr einfachen Aufgabe erwiesen sich Bereiche als sehr nützlich: Anstelle von Code mit selbst erstellten Iteratoren in mehr als 20 Zeilen haben wir 3 Zeilen geschrieben, ohne Probleme mit der Lesbarkeit des Codes oder seiner Leistung zu haben. </p><br><p>  Wenn wir bei diesen Tests die ultimative Leistung benötigen würden, müssten wir natürlich das Beste aus dem Prozessor und dem Speicher herausholen, indem wir parallelen Code schreiben (oder eine Version unter OpenCL schreiben) ... Außerdem habe ich keine Ahnung, was passieren wird, wenn ich schreibe sehr lange Ketten von Modifikatoren.  Ist es einfach, Compiler-Meldungen zu debuggen und zu lesen, wenn Bereiche in komplexen Projekten verwendet werden?  Erhöht die Kompilierungszeit.  Ich hoffe, dass jemals jemand über diesen Artikel schreibt. </p><br><p>  Als ich diese Tests schrieb, wusste ich selbst nicht, was passieren würde.  Jetzt weiß ich - Bereiche verdienen es definitiv, in einem realen Projekt unter den Bedingungen getestet zu werden, unter denen Sie sie verwenden möchten. </p><br><p><del>  Ich ging zum Basar, um einen Samowar zu kaufen. </del></p><br><h3 id="poleznye-ssylki">  Nützliche Links </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Range-V3 nach Hause</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation und Fallstudien v3</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code aus diesem Artikel auf Github</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Listen in Haskell zum Vergleich</a> </p><br><h3 id="blagodarnosti">  Danksagung </h3><br><p>  Danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">fadey,</a> dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">du</a> beim Schreiben geholfen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">hast</a> ! </p><br><h3 id="ps">  PS </h3><br><p>  Ich hoffe, jemand kommentiert solche Kuriositäten: i) Wenn Sie das Integrationsintervall zehnmal kleiner nehmen, ist das Beispiel v2 auf meinem Xeon 10% schneller als v1 und v4 dreimal schneller als v1.  ii) Der Intel-Compiler (icc 2019) erstellt in diesen Beispielen manchmal Code, der doppelt so schnell ist wie kompiliertes g ++.  Ist die Vektorisierung schuld?  Kann g ++ dazu gezwungen werden? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473844/">https://habr.com/ru/post/de473844/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473832/index.html">ShIoTiny: Updates und Benachrichtigungen</a></li>
<li><a href="../de473834/index.html">Blackbox-Überwachung in Clos-Netzwerken. Yandex-Bericht</a></li>
<li><a href="../de473838/index.html">DJI Mavic Mini: der leichteste zusammenklappbare Quadrocopter</a></li>
<li><a href="../de473840/index.html">Streamen Sie Videos vom Android-Gerät über UDP zur JAVA-Anwendung</a></li>
<li><a href="../de473842/index.html">Oktober Maschinelles Lernen und künstliche Intelligenz News Digest</a></li>
<li><a href="../de473846/index.html">So messen Sie die Leistung von Blockchain-Netzwerken. Schlüsselkennzahlen</a></li>
<li><a href="../de473848/index.html">c.tech auf HighLoad ++ 2019</a></li>
<li><a href="../de473852/index.html">Vor- und Nachteile der Nachtarbeit</a></li>
<li><a href="../de473854/index.html">Wie erinnern wir uns an die letzte JokerConf?</a></li>
<li><a href="../de473856/index.html">Gefährliche Leichtigkeit, mit der Sie militärische künstliche Intelligenz täuschen können</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>