<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>▪️ 🧑🏾 🍛 Async / tunggu dalam C #: konsep, desain internal, trik yang berguna 😤 🕔 👨‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari yang baik Kali ini kita akan berbicara tentang sebuah topik yang mulai dipahami oleh setiap penganut bahasa C # yang menghargai diri sendiri - pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Async / tunggu dalam C #: konsep, desain internal, trik yang berguna</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470830/">  Hari yang baik  Kali ini kita akan berbicara tentang sebuah topik yang mulai dipahami oleh setiap penganut bahasa C # yang menghargai diri sendiri - pemrograman asinkron menggunakan Tugas atau, pada orang umum, async / menunggu.  Microsoft melakukan pekerjaan yang baik - untuk menggunakan asinkron dalam kebanyakan kasus Anda hanya perlu mengetahui sintaks dan tidak ada detail lainnya.  Tetapi jika Anda masuk lebih dalam, topiknya cukup banyak dan kompleks.  Itu dinyatakan oleh banyak, masing-masing dengan gayanya sendiri.  Ada banyak artikel keren tentang topik ini, tetapi masih ada banyak kesalahpahaman di sekitarnya.  Kami akan mencoba memperbaiki situasi dan mengunyah materi sebanyak mungkin, tanpa mengorbankan kedalaman atau pemahaman. <br><br><img src="https://habrastorage.org/webt/zn/or/r1/znorr1o7rsk1tzudgdrmgchrss4.jpeg"><br><a name="habracut"></a><br>  Topik / bab yang dibahas: <br><br><ol><li> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konsep asinkron</a></b> - manfaat asinkron dan mitos tentang utas "diblokir" </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TAP.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sintaks dan kondisi kompilasi</a></b> - prasyarat untuk menulis metode kompilasi </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bekerja dengan penggunaan TAP</a></b> - mekanisme dan perilaku program dalam kode asinkron (membebaskan utas, memulai tugas dan menunggu mereka selesai) </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di belakang layar: mesin negara</a></b> - ikhtisar transformasi kompiler dan kelas yang dihasilkannya </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Asal-usul asynchrony.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perangkat metode asinkron standar</a></b> - metode asinkron untuk bekerja dengan file dan jaringan dari dalam </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas dan trik TAP</a></b> adalah <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">trik</a></b> bermanfaat yang dapat membantu Anda mengelola dan mempercepat program menggunakan TAP </li></ol><a name="conception"></a><br><h2>  Konsep asinkron </h2><br>  Asynchrony itu sendiri jauh dari baru.  Asynchrony biasanya menyiratkan melakukan operasi dalam gaya yang tidak berarti memblokir utas panggilan, yaitu, memulai operasi tanpa menunggu penyelesaiannya.  Memblokir tidak seburuk yang dijelaskan.  Satu dapat menemukan klaim yang diblokir thread menghabiskan waktu CPU, bekerja lebih lambat dan menyebabkan hujan.  Apakah yang terakhir tampaknya tidak mungkin?  Faktanya, 2 poin sebelumnya sama. <br><br>  Pada tingkat penjadwal OS, ketika utas berada dalam kondisi "diblokir", waktu prosesor yang berharga tidak akan dialokasikan untuk itu.  Penjadwal panggilan, sebagai aturan, jatuh pada operasi yang menyebabkan pemblokiran, penghenti waktu, dan gangguan lainnya.  Yaitu, ketika, misalnya, pengontrol disk menyelesaikan operasi baca dan memulai interupsi yang sesuai, penjadwal dimulai.  Dia akan memutuskan apakah akan memulai utas yang diblokir oleh operasi ini, atau yang lain dengan prioritas lebih tinggi. <br><br>  Pekerjaan yang lambat tampaknya bahkan lebih absurd.  Sesungguhnya, pekerjaan itu satu dan sama.  Hanya operasi asinkron yang akan menambah sedikit overhead. <br><br>  Tantangan hujan umumnya bukan sesuatu dari daerah ini. <br><br>  Masalah pemblokiran utama adalah konsumsi sumber daya komputer yang tidak masuk akal.  Bahkan jika kita lupa waktu untuk membuat utas dan bekerja dengan kumpulan utas, maka setiap utas yang diblokir akan menghabiskan ruang ekstra.  Nah, ada skenario di mana hanya satu utas dapat melakukan pekerjaan tertentu (misalnya, utas UI).  Karenanya, saya tidak ingin dia sibuk dengan tugas yang dapat dilakukan utas lain, mengorbankan kinerja operasi yang eksklusif untuknya. <br><br>  Asynchrony adalah konsep yang sangat luas dan dapat dicapai dengan banyak cara. <br>  <b>Berikut ini dapat dibedakan dalam sejarah .NET</b> : <br><br><ol><li>  EAP (Pola Asinkron Berbasis Kejadian) - sesuai namanya, kenaikan ini didasarkan pada peristiwa yang terjadi saat operasi selesai dan metode biasa yang menyebut operasi ini </li><li>  APM (Asynchronous Programming Model) - berdasarkan 2 metode.  Metode BeginSmth mengembalikan antarmuka IAsyncResult.  Metode EndSmth menerima IAsyncResult (jika operasi tidak selesai pada saat EndSmth dipanggil, utas diblokir) </li><li>  TAP (Pola Asinkron Berbasis Tugas) adalah async / menunggu yang sama (sebenarnya, kata-kata ini muncul setelah pendekatan dan jenis Tugas dan Tugas &lt;TResult&gt; muncul, tetapi async / menunggu secara signifikan meningkatkan konsep ini) </li></ol><br>  Pendekatan terakhir begitu sukses sehingga semua orang berhasil melupakan yang sebelumnya.  Jadi, ini tentang dia. <br><a name="tap_syntax"></a><br><h2>  Pola asinkron berbasis tugas.  Sintaks dan Kondisi Kompilasi </h2><br>  Metode asinkron gaya TAP standar sangat mudah untuk ditulis. <br><br>  <b>Untuk melakukan ini, Anda perlu</b> : <br><br><ol><li>  Untuk nilai pengembalian menjadi Tugas, Tugas &lt;T&gt;, atau batal (tidak disarankan, dibahas nanti).  Di C # 7 datang jenis-jenis Tugas (dibahas dalam bab terakhir).  Dalam C # 8, IAsyncEnumerable &lt;T&gt; dan IAsyncEnumerator &lt;T&gt; ditambahkan ke daftar ini. </li><li>  Sehingga metode tersebut ditandai dengan kata kunci async dan berisi menunggu di dalam.  Kata kunci ini dipasangkan.  Selain itu, jika metode berisi menunggu, pastikan untuk menandainya async, kebalikannya tidak benar, tetapi tidak ada gunanya </li><li>  Untuk kesopanan, patuhi konvensi suffix Async.  Tentu saja, kompiler tidak akan menganggap ini sebagai kesalahan.  Jika Anda adalah pengembang yang sangat baik, Anda dapat menambahkan kelebihan dengan PembatalanToken (dibahas pada bab terakhir) </li></ol><br>  Untuk metode seperti itu, kompiler melakukan pekerjaan yang serius.  Dan mereka menjadi benar-benar tidak dapat dikenali di balik layar, tetapi lebih pada itu nanti. <br><br>  Disebutkan bahwa metode tersebut harus mengandung kata kunci yang menunggu.  Ini (kata) menunjukkan perlunya asynchronous menunggu tugas yang akan dilakukan, yang merupakan objek tugas yang diterapkan. <br><br>  <b>Objek tugas juga memiliki kondisi tertentu sehingga menunggu dapat diterapkan padanya:</b> <br><br><ol><li>  Jenis yang diharapkan harus memiliki metode GetAwaiter () publik (atau internal), juga bisa menjadi metode ekstensi.  Metode ini mengembalikan objek tunggu. </li><li>  Objek menunggu harus mengimplementasikan antarmuka INotifyCompletion, yang memerlukan implementasi metode OnCompleted (Aksi lanjutan) void.  Itu juga harus memiliki properti instance bool IsCompleted, void GetResult () method.  Ini bisa berupa struktur atau kelas. </li></ol><br>  Contoh di bawah ini menunjukkan cara membuat int diharapkan, dan bahkan tidak pernah dieksekusi. <br><br><div class="spoiler">  <b class="spoiler_title">Ekstensi int</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WeirdExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnyTypeAwaiter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAwaiter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnyTypeAwaiter(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AnyTypeAwaiter</span></span> : <span class="hljs-title"><span class="hljs-title">INotifyCompletion</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCompleted =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCompleted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action continuation</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } }</code> </pre> <br></div></div><br><a name="tap_progr"></a><br><h2>  Bekerja dengan TAP </h2><br>  Sulit untuk pergi ke hutan tanpa memahami bagaimana sesuatu seharusnya bekerja.  Pertimbangkan TAP dalam hal perilaku program. <br><br>  Dalam terminologi: metode asinkron yang dimaksud, yang kodenya akan dipertimbangkan, saya akan memanggil <b>metode asinkron</b> , dan metode asinkron yang disebut di dalamnya saya akan memanggil <b>operasi asinkron</b> . <br><br>  Mari kita ambil contoh paling sederhana, sebagai operasi asinkron, kita mengambil Task.Delay, yang menunda untuk waktu yang ditentukan tanpa memblokir aliran. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DelayOperationAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   { BeforeCall(); Task task = Task.Delay(1000); //  AfterCall(); await task; AfterAwait(); }</span></span></span></span></code> </pre><br>  Eksekusi metode dalam hal perilaku adalah sebagai berikut. <br><br><ol><li>  Semua kode yang mendahului doa operasi asinkron dijalankan.  Dalam hal ini, ini adalah metode <i>BeforeCall</i> </li><li>  Panggilan operasi asinkron sedang berlangsung.  Pada tahap ini, utas tidak dibebaskan atau diblokir.  Operasi ini mengembalikan hasil - objek tugas yang disebutkan (biasanya Tugas), yang disimpan dalam variabel lokal </li><li>  Kode dijalankan setelah memanggil operasi asinkron, tetapi sebelum menunggu (menunggu).  Dalam contohnya - <i>AfterCall</i> </li><li>  Menunggu penyelesaian pada objek tugas (yang disimpan dalam variabel lokal) - tunggu tugas. <br><br>  Jika operasi asinkron selesai pada titik ini, maka eksekusi berlanjut secara sinkron, di utas yang sama. <br><br>  Jika operasi asinkron tidak selesai, maka kode disimpan yang harus dipanggil setelah penyelesaian operasi asinkron (yang disebut kelanjutan), dan aliran kembali ke kumpulan utas dan menjadi tersedia untuk digunakan. </li><li>  Eksekusi operasi setelah menunggu - <i>AfterAwait</i> - dilakukan segera, di utas yang sama, ketika operasi pada saat menunggu selesai, atau, setelah selesainya operasi, utas baru diambil yang akan dilanjutkan (disimpan pada langkah sebelumnya) </li></ol><br><a name="internals"></a><br><h2>  Di belakang layar.  Mesin negara </h2><br>  Bahkan, metode kami ditransformasikan oleh kompiler menjadi metode rintisan di mana kelas yang dihasilkan - mesin negara - diinisialisasi.  Kemudian (mesin) dimulai, dan objek Tugas yang digunakan pada langkah 2 dikembalikan dari metode. <br><br>  Yang menarik adalah metode <i>MoveNext</i> mesin negara.  Metode ini melakukan apa sebelum konversi dalam metode asinkron.  Itu memecahkan kode antara setiap panggilan tunggu.  Setiap bagian dilakukan dalam kondisi mesin tertentu.  Metode <i>MoveNext</i> itu sendiri dilampirkan ke objek tunggu sebagai kelanjutan.  Pelestarian negara menjamin pelaksanaan bagian itu yang secara logis mengikuti harapan. <br><br>  Seperti yang mereka katakan, lebih baik melihat 1 kali daripada mendengar 100 kali, jadi saya sangat menyarankan Anda membiasakan diri dengan contoh di bawah ini.  Saya menulis ulang kode sedikit, meningkatkan penamaan variabel, dan berkomentar dengan murah hati. <br><br><div class="spoiler">  <b class="spoiler_title">Kode sumber</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Metode rintisan</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AsyncStateMachine(typeof(DelaysStateMachine))</span></span>] [DebuggerStepThrough] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delays</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DelaysStateMachine stateMachine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DelaysStateMachine(); stateMachine.taskMethodBuilder = AsyncTaskMethodBuilder.Create(); stateMachine.currentState = <span class="hljs-number"><span class="hljs-number">-1</span></span>; AsyncTaskMethodBuilder builder = stateMachine.taskMethodBuilder; taskMethodBuilder.Start(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> stateMachine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stateMachine.taskMethodBuilder.Task; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Mesin negara</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DelaysStateMachine</span></span> : <span class="hljs-title"><span class="hljs-title">IAsyncStateMachine</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     await   //       await'a public int currentState; public AsyncTaskMethodBuilder taskMethodBuilder; //   private TaskAwaiter taskAwaiter; //  ,             ""  public int paramInt; private int localInt; private void MoveNext() { int num = currentState; try { TaskAwaiter awaiter5; TaskAwaiter awaiter4; TaskAwaiter awaiter3; TaskAwaiter awaiter2; TaskAwaiter awaiter; switch (num) { default: localInt = paramInt; //  await Console.WriteLine(1); //  await awaiter5 = Task.Delay(1000).GetAwaiter(); //  await if (!awaiter5.IsCompleted) //  await. ,    { num = (currentState = 0); // ,      taskAwaiter = awaiter5; //    ,        DelaysStateMachine stateMachine = this; //    taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter5, ref stateMachine); //                 return; } goto Il_AfterFirstAwait; //  ,   ,    case 0: //            ,        .   ,          awaiter5 = taskAwaiter; //   taskAwaiter = default(TaskAwaiter); //   num = (currentState = -1); //  goto Il_AfterFirstAwait; //       case 1: //  ,      ,    ,     . awaiter4 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterSecondAwait; case 2: // ,     . awaiter3 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterThirdAwait; case 3: //    awaiter2 = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); goto Il_AfterFourthAwait; case 4: //    { awaiter = taskAwaiter; taskAwaiter = default(TaskAwaiter); num = (currentState = -1); break; } Il_AfterFourthAwait: awaiter2.GetResult(); Console.WriteLine(5); //     awaiter = Task.Delay(1000).GetAwaiter(); //   if (!awaiter.IsCompleted) { num = (currentState = 4); taskAwaiter = awaiter; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine); return; } break; Il_AfterFirstAwait: //  ,        awaiter5.GetResult(); //       Console.WriteLine(2); //  ,     await awaiter4 = Task.Delay(1000).GetAwaiter(); //    if (!awaiter4.IsCompleted) { num = (currentState = 1); taskAwaiter = awaiter4; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter4, ref stateMachine); return; } goto Il_AfterSecondAwait; Il_AfterThirdAwait: awaiter3.GetResult(); Console.WriteLine(4); //     awaiter2 = Task.Delay(1000).GetAwaiter(); //   if (!awaiter2.IsCompleted) { num = (currentState = 3); taskAwaiter = awaiter2; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter2, ref stateMachine); return; } goto Il_AfterFourthAwait; Il_AfterSecondAwait: awaiter4.GetResult(); Console.WriteLine(3); //     awaiter3 = Task.Delay(1000).GetAwaiter(); //   if (!awaiter3.IsCompleted) { num = (currentState = 2); taskAwaiter = awaiter3; DelaysStateMachine stateMachine = this; taskMethodBuilder.AwaitUnsafeOnCompleted(ref awaiter3, ref stateMachine); return; } goto Il_AfterThirdAwait; } awaiter.GetResult(); } catch (Exception exception) { currentState = -2; taskMethodBuilder.SetException(exception); return; } currentState = -2; taskMethodBuilder.SetResult(); //    ,   ,       } void IAsyncStateMachine.MoveNext() {...} [DebuggerHidden] private void SetStateMachine(IAsyncStateMachine stateMachine) {...} void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine) {...} }</span></span></code> </pre><br></div></div><br>  Saya fokus pada frasa "pada saat ini belum dijalankan secara serempak."  Operasi asinkron juga dapat mengikuti jalur eksekusi yang sinkron.  Kondisi utama untuk metode asinkron saat ini untuk dieksekusi secara serempak, yaitu, tanpa mengubah utas, adalah penyelesaian operasi asinkron pada saat verifikasi <i>IsCompleted</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Contoh ini dengan jelas menunjukkan perilaku ini.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-comment"><span class="hljs-comment">//1 Task task = Task.Delay(1000); Thread.Sleep(1700); await task; Console.WriteLine(Thread.CurrentThread.ManagedThreadId); //1 }</span></span></code> </pre><br></div></div><br>  Tentang konteks sinkronisasi.  Metode <i>AwaitUnsafeOnCompleted</i> yang digunakan dalam mesin pada akhirnya menghasilkan panggilan ke metode <i>Task.SetContinuationForAwait</i> .  Dalam metode ini, konteks sinkronisasi saat ini <i>SynchronizationContext.Current</i> diambil.  Konteks sinkronisasi dapat diartikan sebagai jenis aliran.  Jika juga spesifik (misalnya, konteks utas UI), kelanjutan dibuat menggunakan kelas <i>SynchronizationContextAwaitTaskContinuation</i> .  Kelas ini untuk memulai kelanjutan memanggil metode Posting pada konteks yang disimpan, yang memastikan bahwa kelanjutan dieksekusi dalam konteks yang tepat di mana metode dijalankan.  Logika khusus untuk mengeksekusi kelanjutan tergantung pada metode <i>Post</i> dalam konteks yang, secara sederhana, tidak dikenal untuk kecepatan.  Jika tidak ada konteks sinkronisasi (atau ditunjukkan bahwa itu tidak masalah bagi kami di mana konteks eksekusi akan terus menggunakan ConfigureAwait (false), yang akan dibahas pada bab terakhir), kelanjutan akan dilakukan oleh utas dari kumpulan. <br><a name="libs"></a><br><h2>  Asal-usul asynchrony.  Metode asinkron standar perangkat </h2><br>  Kami melihat bagaimana metode menggunakan async dan menunggu penampilan dan apa yang terjadi di balik layar.  Informasi ini tidak jarang.  Tetapi penting untuk memahami sifat operasi asinkron.  Karena, seperti yang kita lihat di mesin negara, operasi asinkron dipanggil dalam kode, kecuali hasilnya diproses lebih licik.  Namun, apa yang terjadi di dalam operasi asinkron itu sendiri?  Mungkin sama, tetapi ini tidak dapat terjadi tanpa batas. <br><br>  Tugas penting adalah memahami sifat asinkron.  Ketika mencoba memahami asinkron, ada pergantian status "sekarang jelas" dan "sekarang lagi tidak bisa dipahami."  Dan pergantian ini akan sampai sumber asynchrony dipahami. <br><br>  Saat bekerja dengan asinkron, kami beroperasi pada tugas.  Ini sama sekali tidak sama dengan aliran.  Satu tugas dapat dilakukan oleh banyak utas, dan satu utas dapat melakukan banyak tugas. <br><br>  Asynchrony biasanya dimulai dengan metode yang mengembalikan Task (misalnya), tetapi tidak ditandai dengan async, dan karenanya tidak menggunakan menunggu di dalam.  Metode ini tidak mentolerir perubahan kompiler, tetapi dieksekusi apa adanya. <br><br>  <b>Jadi, mari kita lihat beberapa akar asynchrony.</b> <br><br><ol><li>  Task.Run, Task baru (..). Mulai (), Factory.StartNew dan sejenisnya.  Cara termudah untuk memulai eksekusi asinkron.  Metode ini hanya membuat objek tugas baru, melewati delegasi sebagai salah satu parameter.  Tugas ditransfer ke penjadwal, yang memberikannya untuk dieksekusi oleh salah satu utas di kumpulan.  Tugas selesai yang dapat diharapkan dikembalikan.  Biasanya, pendekatan ini digunakan untuk memulai komputasi (terikat CPU) di utas terpisah. </li><li>  TaskCompletionSource.  Kelas pembantu yang membantu mengontrol objek tugas.  Dirancang untuk mereka yang tidak dapat mengalokasikan delegasi untuk implementasi dan menggunakan mekanisme yang lebih canggih untuk mengendalikan penyelesaian.  Ini memiliki API yang sangat sederhana - SetResult, SetError, dll., Yang memperbarui tugas sesuai.  Tugas ini tersedia melalui properti Tugas.  Mungkin di dalam Anda akan membuat utas, memiliki logika yang kompleks untuk interaksi mereka atau selesai dengan acara.  Rincian lebih lanjut tentang kelas ini akan ada di bagian terakhir. </li></ol><br>  Dalam paragraf tambahan, Anda bisa membuat metode perpustakaan standar.  Ini termasuk membaca / menulis file, bekerja dengan jaringan, dan sejenisnya.  Sebagai aturan, metode populer dan umum tersebut menggunakan panggilan sistem yang bervariasi pada platform yang berbeda, dan perangkat mereka sangat menghibur.  Pertimbangkan bekerja dengan file dan jaringan. <br><br><h3>  File </h3><br>  Catatan penting - jika Anda ingin bekerja dengan file, Anda harus menentukan useAsync = true saat membuat FileStream. <br><br>  Semuanya diatur dalam file non-sepele dan membingungkan.  Kelas FileStream dinyatakan parsial.  Dan selain itu ada 6 add-on khusus platform lainnya.  Jadi, di Unix, akses asinkron ke file sewenang-wenang, sebagai suatu peraturan, menggunakan operasi sinkron di utas terpisah.  Di Windows ada panggilan sistem untuk operasi asinkron, yang tentu saja digunakan.  Ini menyebabkan perbedaan dalam pekerjaan pada platform yang berbeda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> . <br><br>  <b>Unix</b> <br><br>  Perilaku standar saat menulis atau membaca adalah melakukan operasi secara serempak, jika buffer memungkinkan dan aliran tidak sibuk dengan operasi lain: <br><br>  1. Stream tidak sibuk dengan operasi lain <br><br>  Kelas Filestream memiliki objek yang diwarisi dari SemaphoreSlim dengan parameter (1, 1) - yaitu, bagian kritis - fragmen kode yang dilindungi oleh semaphore ini dapat dieksekusi oleh hanya satu utas pada satu waktu.  Semaphore ini digunakan untuk membaca dan menulis.  Artinya, tidak mungkin menghasilkan sekaligus membaca dan menulis.  Dalam hal ini, pemblokiran pada semaphore tidak terjadi.  Metode this._asyncState.WaitAsync () dipanggil, yang mengembalikan objek tugas (tidak ada kunci atau menunggu, itu akan terjadi jika kata kunci tunggu diterapkan pada hasil metode).  Jika objek tugas ini tidak selesai - yaitu, semaphore ditangkap, maka kelanjutan (Task.ContinueWith) di mana operasi dilakukan dilampirkan ke objek menunggu yang dikembalikan.  Jika objek tersebut gratis, maka Anda perlu memeriksa yang berikut ini <br><br>  2. Buffer memungkinkan <br><br>  Di sini perilaku sudah tergantung pada sifat operasi. <br><br>  Untuk merekam - diperiksa bahwa ukuran data untuk menulis + posisi dalam file kurang dari ukuran buffer, yang secara default adalah 4096 byte.  Artinya, kita harus menulis 4096 byte dari awal, 2048 byte dengan offset 2048, dan seterusnya.  Jika demikian, maka operasi dilakukan secara serempak, jika tidak kelanjutannya dilampirkan (Tugas.Lanjutkan dengan).  Sekuelnya menggunakan panggilan sistem sinkron biasa.  Ketika buffer penuh, itu ditulis ke disk secara sinkron. <br>  Untuk membaca - diperiksa apakah ada cukup data dalam buffer untuk mengembalikan semua data yang diperlukan.  Jika tidak, maka, sekali lagi, kelanjutan (Task.ContinueWith) dengan panggilan sistem sinkron. <br><br>  Ngomong-ngomong, ada detail yang menarik.  Jika satu bagian data menempati seluruh buffer, mereka akan ditulis langsung ke file, tanpa partisipasi buffer.  Pada saat yang sama, ada situasi di mana akan ada lebih banyak data daripada ukuran buffer, tetapi mereka semua akan melewatinya.  Ini terjadi jika sudah ada sesuatu di buffer.  Kemudian data kita akan dibagi menjadi 2 bagian, satu akan mengisi buffer sampai akhir dan data akan ditulis ke file, yang kedua akan ditulis ke buffer jika masuk ke dalamnya atau langsung ke file jika tidak.  Jadi, jika kita membuat stream dan menulis 4097 bytes, mereka akan segera muncul dalam file, tanpa memanggil Buang.  Jika kita menulis 4095, maka tidak ada yang ada di file. <br><br>  <b>Windows</b> <br><br>  Di bawah Windows, algoritma untuk menggunakan buffer dan menulis secara langsung sangat mirip.  Tetapi perbedaan yang signifikan diamati secara langsung dalam sistem asinkron menulis dan membaca panggilan.  Berbicara tanpa masuk jauh ke panggilan sistem, ada struktur yang tumpang tindih.  Ini memiliki bidang yang penting bagi kita - MENANGANInya.  Ini adalah acara reset manual yang masuk ke kondisi alarm setelah operasi selesai.  Kembali ke implementasi.  Menulis secara langsung, serta menulis ke buffer, menggunakan pemanggilan sistem asinkron, yang menggunakan struktur di atas sebagai parameter.  Saat merekam, objek FileStreamCompletionSource dibuat - pewaris TaskCompletionSource, di mana IOCallback ditentukan.  Disebut dengan utas gratis dari kumpulan ketika operasi selesai.  Dalam panggilan balik, struktur Tumpang tindih diuraikan dan objek Tugas diperbarui sesuai.  Itu semua ajaib. <br><br><h3>  Jaringan </h3><br>  Sulit untuk menggambarkan segala sesuatu yang saya lihat mengerti sumbernya.  Path saya terletak dari HttpClient ke Socket dan ke SocketAsyncContext untuk Unix.  Skema umum sama dengan file.  Untuk Windows, struktur Tumpang tindih yang disebutkan digunakan dan operasi dilakukan secara tidak sinkron.  Di Unix, operasi jaringan juga menggunakan fungsi panggilan balik. <br><br>  Dan sedikit penjelasan.  Pembaca yang penuh perhatian akan melihat bahwa ketika menggunakan panggilan tidak sinkron antara panggilan dan panggilan balik, ada kekosongan tertentu yang entah bagaimana bekerja dengan data.  Di sini perlu dijelaskan untuk kelengkapannya.  Pada contoh file, disk controller melakukan operasi langsung dengan disk oleh disk controller, dialah yang memberikan sinyal tentang memindahkan kepala ke sektor yang diinginkan, dll.  Prosesor ini gratis saat ini.  Komunikasi dengan disk terjadi melalui port input / output.  Mereka menunjukkan jenis operasi, lokasi data pada disk, dll.  Selanjutnya, pengontrol dan disk terlibat dalam operasi ini dan setelah menyelesaikan pekerjaan mereka menghasilkan interupsi.  Karenanya, panggilan sistem asinkron hanya menyumbangkan informasi ke port input / output, sementara yang sinkron juga menunggu hasilnya, menempatkan aliran dalam status pemblokiran.  Skema ini tidak berpura-pura akurat (bukan tentang artikel ini), tetapi memberikan pemahaman konseptual tentang pekerjaan tersebut. <br><br>  Sekarang sifat prosesnya jelas.  Tetapi seseorang mungkin bertanya, apa yang harus dilakukan dengan asinkron?  Tidak mungkin untuk menulis async melalui metode selamanya. <br><br>  Pertama-tama  Aplikasi dapat dibuat sebagai layanan.  Dalam hal ini, titik masuk - Utama - ditulis dari awal oleh Anda.  Sampai saat ini, Main tidak dapat disinkronkan, dalam versi bahasa 7, fitur ini ditambahkan.  Tapi itu tidak mengubah apa pun secara radikal, hanya kompiler yang menghasilkan Main biasa, dan dari asynchronous hanya dibuat metode statis, yang disebut Main dan penyelesaiannya diharapkan secara serempak.  Jadi, kemungkinan besar Anda memiliki beberapa tindakan berumur panjang.  Untuk beberapa alasan, pada saat ini, banyak orang mulai berpikir tentang cara membuat utas untuk bisnis ini: melalui Task, ThreadPool, atau Utas secara umum, karena harus ada perbedaan dalam sesuatu.  Jawabannya sederhana - tentu saja Tugas.  Jika Anda menggunakan pendekatan TAP, jangan mengganggu pembuatan utas manual.  Ini mirip dengan menggunakan HttpClient untuk hampir semua permintaan, dan POST dilakukan secara independen melalui Socket. <br><br>  Kedua  Aplikasi web.  Setiap permintaan masuk menyebabkan utas baru ditarik dari ThreadPool untuk diproses.  Kolam, tentu saja, besar, tetapi tidak terbatas.  Jika ada banyak permintaan, mungkin tidak ada utas sama sekali, dan semua permintaan baru akan antri untuk diproses.  Situasi ini disebut kelaparan.  Tetapi dalam kasus menggunakan pengontrol asinkron, seperti dibahas sebelumnya, aliran kembali ke kumpulan dan dapat digunakan untuk memproses permintaan baru.  Dengan demikian, throughput server meningkat secara signifikan. <br><br>  Kami melihat proses asinkron dari awal hingga akhir.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan dipersenjatai dengan pemahaman tentang semua asinkron ini, yang bertentangan dengan sifat manusia, kami akan mempertimbangkan beberapa trik yang berguna ketika bekerja dengan kode asinkron. </font></font><br><a name="api"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kelas dan trik yang berguna saat bekerja dengan TAP </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keragaman statis dari kelas Tugas. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas Tugas memiliki beberapa metode statis yang berguna. </font><font style="vertical-align: inherit;">Di bawah ini adalah yang utama.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.WhenAny (..) adalah kombinator yang mengambil IEnumerable / params dari objek tugas dan mengembalikan objek tugas yang akan selesai ketika tugas pertama yang selesai selesai. </font><font style="vertical-align: inherit;">Artinya, ini memungkinkan Anda untuk menunggu salah satu dari beberapa tugas yang sedang berjalan</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task.WhenAll (..) - kombinator, menerima IEnumerable / params dari objek tugas dan mengembalikan objek tugas, yang akan diselesaikan setelah menyelesaikan semua tugas yang ditransfer </font></font></li><li> Task.FromResult&lt;T&gt;(T value) —    ,    .          </li><li> Task.Delay(..) —     </li><li> Task.Yield() —  .   ,      .  ,    ,      </li></ol><br><h3> ConfigureAwait </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara alami, fitur "lanjutan" paling populer. Metode ini milik kelas Tugas dan memungkinkan Anda menentukan apakah kami perlu melanjutkan dalam konteks yang sama di mana operasi asinkron dipanggil. Secara default, tanpa menggunakan metode ini, konteks diingat dan dilanjutkan di dalamnya menggunakan metode Post yang disebutkan. Namun, seperti yang kami katakan, Post adalah kesenangan yang sangat mahal. Oleh karena itu, jika kinerjanya berada di tempat pertama, dan kami melihat bahwa kelanjutan tidak akan, katakanlah, memperbarui UI, Anda dapat menentukan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.ConfigureAwait (false)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada objek yang menunggu </font><font style="vertical-align: inherit;">. Ini berarti bahwa tidak masalah bagi kami di mana kelanjutan akan dilakukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang tentang masalahnya. Seperti yang mereka katakan, menakutkan bukan ketidaktahuan, tetapi pengetahuan palsu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entah bagaimana saya mengamati kode aplikasi web, di mana setiap panggilan asinkron didekorasi dengan akselerator ini. </font><font style="vertical-align: inherit;">Ini tidak memiliki efek selain jijik visual. </font><font style="vertical-align: inherit;">Aplikasi web standar ASP.NET Core tidak memiliki konteks unik (kecuali jika Anda sendiri yang menulisnya). </font><font style="vertical-align: inherit;">Dengan demikian, metode Post tidak dipanggil di sana.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TaskCompletionSource &lt;T&gt; </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas yang memudahkan mengelola objek Tugas. </font><font style="vertical-align: inherit;">Kelas memiliki banyak peluang, tetapi paling berguna ketika kita ingin menyelesaikan tugas dengan tindakan, yang akhirnya terjadi pada suatu peristiwa. </font><font style="vertical-align: inherit;">Secara umum, kelas diciptakan untuk mengadaptasi metode asinkron lama ke TAP, tetapi seperti yang telah kita lihat, ini digunakan tidak hanya untuk ini. </font><font style="vertical-align: inherit;">Contoh kecil bekerja dengan kelas ini:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Contoh</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); FileSystemWatcher watcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileSystemWatcher { Path = Directory.GetCurrentDirectory(), NotifyFilter = NotifyFilters.LastAccess, EnableRaisingEvents = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; watcher.Changed += (o, e) =&gt; tcs.SetResult(e.FullPath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tcs.Task; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kelas ini membuat pembungkus asinkron untuk mendapatkan nama file yang diakses di folder saat ini. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PembatalanTokenSource </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memungkinkan Anda membatalkan operasi asinkron. </font><font style="vertical-align: inherit;">Garis besar umum menyerupai penggunaan TaskCompletionSource. </font><font style="vertical-align: inherit;">Pertama, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var cts = new PembatalanTokenSource () dibuat</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang, omong-omong, IDisposable, kemudian </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Token</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dilewatkan ke operasi asinkron </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Selanjutnya, mengikuti beberapa logika Anda, dalam kondisi tertentu, metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Cancel () dipanggil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Itu juga dapat berlangganan ke suatu acara atau apa pun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PembatalanToken</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah praktik yang baik. </font><font style="vertical-align: inherit;">Saat menulis metode asinkron Anda yang berfungsi di latar belakang, katakan dalam waktu tak terbatas, Anda cukup memasukkan satu baris ke badan loop: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cancellationToken.ThrowIfCancellationRequested ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang akan mengeluarkan pengecualian</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pengecualian ini diperlakukan sebagai pembatalan operasi dan tidak disimpan sebagai pengecualian di dalam objek tugas. </font><font style="vertical-align: inherit;">Juga, properti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsCanceled</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada objek Tugas akan menjadi benar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Longrunning </font></font></h3><br>   ,    ,     ,            .   ,         .      (    ),          .         : <br><br> <i>Task.Factory.StartNew(action, <b>TaskCreationOptions.LongRunning</b> )</i> <br><br>         <i>Task.Factory.StartNew</i> ,           . <br><br><h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena sifat non-deterministik dari eksekusi kode asinkron, pertanyaan tentang pengecualian sangat relevan. Akan memalukan jika Anda tidak bisa menangkap pengecualian dan itu dilemparkan ke utas kiri, membunuh proses. Kelas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dibuat untuk menangkap pengecualian dalam satu utas dan melemparkannya ke dalamnya </font><font style="vertical-align: inherit;">. Untuk menangkap pengecualian, metode statis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo.Capture (ex) digunakan, yang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengembalikan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tautan ke objek ini dapat diteruskan ke utas apa pun, yang kemudian memanggil metode Throw () untuk membuangnya. </font><font style="vertical-align: inherit;">Lemparan itu sendiri TIDAK terjadi di tempat panggilan operasi tidak sinkron, tetapi di tempat penggunaan operator yang menunggu. </font><font style="vertical-align: inherit;">Dan seperti yang Anda tahu, menunggu tidak dapat diterapkan untuk membatalkan. </font><font style="vertical-align: inherit;">Jadi, jika konteksnya ada, itu akan diteruskan dengan metode Post. </font><font style="vertical-align: inherit;">Kalau tidak, itu akan bersemangat dalam aliran dari kolam. </font><font style="vertical-align: inherit;">Dan ini hampir 100% halo pada runtuhnya aplikasi. </font><font style="vertical-align: inherit;">Dan di sini kita sampai pada praktik fakta bahwa kita harus menggunakan Tugas atau Tugas &lt;T&gt;, tetapi tidak batal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan satu hal lagi. </font><font style="vertical-align: inherit;">Penjadwal memiliki tugas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler.UnobservedTaskException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang menyala ketika </font><i><font style="vertical-align: inherit;">UnobservedTaskException</font></i><font style="vertical-align: inherit;"> dilempar</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pengecualian ini dilemparkan selama pengumpulan sampah ketika GC mencoba untuk mengumpulkan objek tugas yang memiliki pengecualian tidak tertangani.</font></font><br><br><h3> IAsyncEnumerable </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum C # 8 dan .NET Core 3.0, tidak mungkin untuk menggunakan iterator hasil dalam metode asinkron, yang mempersulit masa pakai dan membuatnya mengembalikan Tugas &lt;IEnumerable &lt;T&gt;&gt; dari metode ini, mis. tidak ada cara untuk mengulangi koleksi sampai diterima sepenuhnya. Sekarang ada kesempatan seperti itu. Pelajari lebih lanjut di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Untuk ini, tipe pengembalian harus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerable &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (atau </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerator &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Untuk melintasi koleksi seperti itu, Anda harus menggunakan foreach loop dengan kata kunci yang menunggu. Juga, metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WithCancellation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat dipanggil pada hasil operasi </font><font style="vertical-align: inherit;">, yang menunjukkan CancelationToken yang digunakan dan kebutuhan untuk melanjutkan dalam konteks yang sama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang diharapkan, semuanya dilakukan dengan malas mungkin. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bawah ini adalah contoh dan kesimpulan yang dia berikan.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Contoh</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); IAsyncEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; enumerable = AsyncYielding(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time after calling: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerable.WithCancellation(..).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"element: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{element}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Time: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds}</span></span></span><span class="hljs-string">"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> IAsyncEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncYielding</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uselessElement <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) { Task task = Task.Delay(TimeSpan.FromSeconds(uselessElement)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Task run: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{uselessElement}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> task; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uselessElement; } } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waktu setelah panggilan: 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas dijalankan: 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen: 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waktu: 1033 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas dijalankan: 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen: 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waktu: 3034 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas dijalankan: 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen: 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waktu: 6035</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Threadpool </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas ini digunakan secara aktif saat pemrograman dengan TAP. Karena itu, saya akan memberikan detail minimum implementasinya. Di dalam, ThreadPool memiliki array antrian: satu untuk setiap utas + satu global. Saat menambahkan pekerjaan baru ke kumpulan, utas yang memulai penambahan diperhitungkan. Dalam hal ini adalah utas dari kumpulan, karya diletakkan dalam antrian sendiri utas ini, jika itu adalah utas lain - di utas global. Ketika utas dipilih untuk berfungsi, antrian lokalnya pertama-tama terlihat. Jika kosong, utas mengambil pekerjaan dari global. Jika kosong, ia mulai mencuri dari yang lain. Juga, Anda tidak boleh mengandalkan urutan pekerjaan, karena, pada kenyataannya, tidak ada pesanan. Jumlah utas default dalam kumpulan bergantung pada banyak faktor, termasuk ukuran ruang alamat. Jika ada lebih banyak permintaan untuk eksekusi,dari jumlah utas yang tersedia, permintaan diantri.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utas di kumpulan utas adalah utas latar (properti isBackground = true). </font><font style="vertical-align: inherit;">Jenis utas ini tidak mendukung umur proses jika semua utas depan telah selesai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utas sistem memantau status pegangan tunggu. </font><font style="vertical-align: inherit;">Ketika operasi tunggu berakhir, callback yang ditransfer dijalankan oleh utas dari kelompok (ingat file di Windows).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jenis tugas-seperti </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disebutkan sebelumnya, tipe ini (struktur atau kelas) dapat digunakan sebagai nilai balik dari metode asinkron. </font><font style="vertical-align: inherit;">Tipe builder harus dikaitkan dengan tipe ini menggunakan atribut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[AsyncMethodBuilder (..)]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jenis ini harus memiliki karakteristik yang disebutkan di atas agar dapat menerapkan kata kunci yang menunggu untuk itu. </font><font style="vertical-align: inherit;">Itu dapat diparameterisasi untuk metode yang tidak mengembalikan nilai dan parameter untuk yang kembali. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Builder itu sendiri adalah kelas atau struktur yang kerangka kerjanya ditunjukkan pada contoh di bawah ini. </font><font style="vertical-align: inherit;">Metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memiliki parameter tipe T untuk tipe tugas seperti yang diparameterisasi oleh T. Untuk tipe non-parameter, metode ini tidak memiliki parameter.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka Builder yang Dibutuhkan</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTaskMethodBuilder</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MyTaskMethodBuilder&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start&lt;TStateMachine&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetStateMachine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAsyncStateMachine stateMachine</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception exception</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T result</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : INotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : ICriticalNotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyTask&lt;T&gt; Task { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinsip kerja dari sudut pandang penulisan jenis Tugas Anda akan dijelaskan di bawah ini. Sebagian besar sudah dijelaskan ketika menguraikan kode yang dihasilkan oleh kompiler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompiler menggunakan semua jenis ini untuk menghasilkan mesin negara. Kompiler tahu pembangun mana yang akan digunakan untuk jenis yang diketahuinya, di sini kami menentukan apa yang akan digunakan selama pembuatan kode. Jika mesin keadaan adalah struktur, maka itu akan dikemas saat memanggil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetStateMachine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pembangun dapat menyimpan salinan yang dikemas jika perlu. Pembangun harus memanggil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateMachine.MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau setelah dipanggil untuk memulai eksekusi dan memajukan mesin negara. Setelah memanggil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, properti Task akan dikembalikan dari metode. Saya sarankan Anda kembali ke metode rintisan dan melihat langkah-langkah ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika mesin negara selesai dengan sukses, metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult dipanggil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jika tidak, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika mesin keadaan mencapai menunggu, metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetAwaiter ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari </font><font style="vertical-align: inherit;">jenis seperti tugas </font><font style="vertical-align: inherit;">dijalankan </font><font style="vertical-align: inherit;">. Jika objek menunggu mengimplementasikan antarmuka </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICriticalNotifyCompletion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan IsCompleted = false, mesin state menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitUnsafeOnCompleted (ref awaiter, ref stateMachine)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AwaitUnsafeOnCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> harus memanggil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awaiter.OnCompleted (tindakan)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tindakan tersebut harus memanggil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stateMachine.MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ketika objek menunggu selesai. </font><font style="vertical-align: inherit;">Demikian pula untuk antarmuka </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INotifyCompletion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitOnCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara menggunakan ini terserah Anda. </font><font style="vertical-align: inherit;">Tetapi saya menyarankan Anda untuk memikirkan 514 kali sebelum menerapkan ini dalam produksi, dan bukan untuk memanjakan. </font><font style="vertical-align: inherit;">Berikut ini adalah contoh penggunaan. </font><font style="vertical-align: inherit;">Saya membuat sketsa hanya proksi untuk pembangun standar yang menampilkan ke konsol metode mana yang dipanggil dan pada jam berapa. </font><font style="vertical-align: inherit;">Omong-omong, Main asynchronous () tidak ingin mendukung jenis ekspektasi khusus (saya percaya bahwa lebih dari satu proyek produksi rusak karena putus asa oleh Microsoft). </font><font style="vertical-align: inherit;">Jika mau, Anda dapat memodifikasi logger proksi menggunakan logger normal dan mencatat lebih banyak informasi.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas Proksi Pencatatan</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Start"</span></span>); JustMethod().Task.Wait(); <span class="hljs-comment"><span class="hljs-comment">//   Console.WriteLine("Stop"); } public static async LogTask JustMethod() { await DelayWrapper(1000); } public static LogTask DelayWrapper(int milliseconds) =&gt; new LogTask { Task = Task.Delay(milliseconds)}; } [AsyncMethodBuilder(typeof(LogMethodBuilder))] public class LogTask { public Task Task { get; set; } public TaskAwaiter GetAwaiter() =&gt; Task.GetAwaiter(); } public class LogMethodBuilder { private AsyncTaskMethodBuilder _methodBuilder = AsyncTaskMethodBuilder.Create(); private LogTask _task; public static LogMethodBuilder Create() { Console.WriteLine($"Method: Create; {DateTime.Now :O}"); return new LogMethodBuilder(); } public void Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: Start; {DateTime.Now :O}"); _methodBuilder.Start(ref stateMachine); } public void SetStateMachine(IAsyncStateMachine stateMachine) { Console.WriteLine($"Method: SetStateMachine; {DateTime.Now :O}"); _methodBuilder.SetStateMachine(stateMachine); } public void SetException(Exception exception) { Console.WriteLine($"Method: SetException; {DateTime.Now :O}"); _methodBuilder.SetException(exception); } public void SetResult() { Console.WriteLine($"Method: SetResult; {DateTime.Now :O}"); _methodBuilder.SetResult(); } public void AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: AwaitOnCompleted; {DateTime.Now :O}"); _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine); } public void AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine { Console.WriteLine($"Method: AwaitUnsafeOnCompleted; {DateTime.Now :O}"); _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine); } public LogTask Task { get { Console.WriteLine($"Property: Task; {DateTime.Now :O}"); return _task ??= new LogTask {Task = _methodBuilder.Task}; } set =&gt; _task = value; } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode: Buat; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7152733 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode: Mulai; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7262226 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode: AwaitUnsafeOnCompleted; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7275206 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Properti: Tugas; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 13.7292005 + 03: 00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode: SetResult; </font><font style="vertical-align: inherit;">2019-10-09T17: 55: 14.7297967 + 03:00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stop</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Itu saja, terima kasih semuanya.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470830/">https://habr.com/ru/post/id470830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470820/index.html">Sebuah tes cepat terhadap puluhan hipotesis: bagaimana kita keluar dari rutinitas dan berdiskusi di kota lain</a></li>
<li><a href="../id470822/index.html">Pemantauan suhu di perusahaan</a></li>
<li><a href="../id470824/index.html">Dialog tentang Janji</a></li>
<li><a href="../id470826/index.html">Penambang, Penyelam dan Cobalt: Bagaimana Kami Menyediakan Pelanggan Akses Internet yang Aman</a></li>
<li><a href="../id470828/index.html">Daftar tertaut python: Kucing dalam kotak</a></li>
<li><a href="../id470834/index.html">Superinfeksi, antibiotik dan model kiamat zombie</a></li>
<li><a href="../id470838/index.html">Keamanan Kontainer dalam CI / CD</a></li>
<li><a href="../id470844/index.html">Proyek baru dari Durov bersaudara: Telegram Open Network</a></li>
<li><a href="../id470852/index.html">Memproses 40 TB kode dari 10 juta proyek pada server khusus dengan Go seharga $ 100</a></li>
<li><a href="../id470856/index.html">Telegram GRAM Wallet: ketentuan layanan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>