<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò∞ üÜñ üëèüèæ √çndices no PostgreSQL - 9 (BRIN) ü§¥üèª ü§µ üë©üèΩ‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos artigos anteriores, discutimos o mecanismo de indexa√ß√£o do PostgreSQL, a interface dos m√©todos de acesso e os seguintes m√©todos: √≠ndices de hash ,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices no PostgreSQL - 9 (BRIN)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452900/">  Nos artigos anteriores, discutimos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mecanismo de indexa√ß√£o do</a> PostgreSQL, a interface dos m√©todos de acesso e os seguintes m√©todos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√≠ndices de hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvores B</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GIN</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RUM</a> .  O t√≥pico deste artigo √© √≠ndices BRIN. <br><br><h1>  Brin </h1><br><h2>  Conceito geral </h2><br>  Ao contr√°rio dos √≠ndices com os quais j√° nos reunimos, a id√©ia do BRIN √© evitar procurar linhas definitivamente inadequadas, em vez de encontrar rapidamente as correspondentes.  Este √© sempre um √≠ndice impreciso: n√£o cont√©m TIDs de linhas da tabela. <br><br>  De maneira simplista, o BRIN funciona bem para colunas em que os valores se correlacionam com sua localiza√ß√£o f√≠sica na tabela.  Em outras palavras, se uma consulta sem a cl√°usula ORDER BY retornar os valores da coluna virtualmente na ordem crescente ou decrescente (e n√£o houver √≠ndices nessa coluna). <br><br>  Esse m√©todo de acesso foi criado no escopo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Axle</a> , o projeto europeu para bancos de dados anal√≠ticos extremamente grandes, de olho em tabelas com v√°rios terabytes ou dezenas de terabytes.  Um recurso importante do BRIN que nos permite criar √≠ndices nessas tabelas √© um tamanho pequeno e custos indiretos m√≠nimos de manuten√ß√£o. <br><br>  Isso funciona da seguinte maneira.  A tabela √© dividida em <em>intervalos</em> com v√°rias p√°ginas grandes (ou v√°rios blocos grandes, iguais) - da√≠ o nome: √çndice de intervalo de blocos, BRIN.  O √≠ndice armazena <em>informa√ß√µes resumidas</em> nos dados em cada intervalo.  Como regra, esses s√£o os valores m√≠nimos e m√°ximos, mas s√£o diferentes, conforme mostrado a seguir.  Suponha que seja realizada uma consulta que contenha a condi√ß√£o para uma coluna;  se os valores procurados n√£o entrarem no intervalo, todo o intervalo poder√° ser ignorado;  mas se receberem, todas as linhas em todos os blocos dever√£o ser examinadas para escolher as linhas correspondentes entre elas. <br><br>  N√£o ser√° um erro tratar o BRIN n√£o como um √≠ndice, mas como um acelerador da varredura seq√ºencial.  Podemos considerar o BRIN como uma alternativa ao particionamento se considerarmos cada intervalo como uma parti√ß√£o "virtual". <br><br>  Agora vamos discutir a estrutura do √≠ndice com mais detalhes. <br><a name="habracut"></a><br><h2>  Estrutura </h2><br>  A primeira p√°gina (mais exatamente, zero) cont√©m os metadados. <br><br>  As p√°ginas com as informa√ß√µes resumidas est√£o localizadas em um determinado deslocamento dos metadados.  Cada linha de √≠ndice nessas p√°ginas cont√©m informa√ß√µes resumidas em um intervalo. <br><br>  Entre a meta p√°gina e os dados resumidos, est√£o localizadas as p√°ginas com o <em>mapa de intervalo reverso</em> (abreviado como "revmap").  Na verdade, essa √© uma matriz de ponteiros (TIDs) para as linhas de √≠ndice correspondentes. <br><br><img src="https://habrastorage.org/webt/nr/pm/s9/nrpms932o5clzubwymywxtud6q4.png"><br><br>  Para alguns intervalos, o ponteiro em "revmap" pode levar a nenhuma linha de √≠ndice (uma √© marcada em cinza na figura).  Nesse caso, considera-se que o intervalo ainda n√£o possui informa√ß√µes resumidas. <br><br><h2>  Digitalizando o √≠ndice </h2><br>  Como o √≠ndice √© usado se n√£o cont√©m refer√™ncias √†s linhas da tabela?  Esse m√©todo de acesso certamente n√£o pode retornar linhas TID por TID, mas pode criar um bitmap.  Pode haver dois tipos de p√°ginas de bitmap: precisas para a linha e imprecisas para a p√°gina.  √â um bitmap impreciso usado. <br><br>  O algoritmo √© simples.  O mapa de intervalos √© varrido sequencialmente (ou seja, os intervalos s√£o percorridos na ordem de sua localiza√ß√£o na tabela).  Os ponteiros s√£o usados ‚Äã‚Äãpara determinar as linhas de √≠ndice com informa√ß√µes resumidas em cada intervalo.  Se um intervalo n√£o contiver o valor desejado, ele ser√° ignorado e se puder conter o valor (ou as informa√ß√µes de resumo n√£o estiverem dispon√≠veis), todas as p√°ginas do intervalo ser√£o adicionadas ao bitmap.  O bitmap resultante √© ent√£o usado como de costume. <br><br><h2>  Atualizando o √≠ndice </h2><br>  √â mais interessante como o √≠ndice √© atualizado quando a tabela √© alterada. <br><br>  Ao <strong>adicionar</strong> uma nova vers√£o de uma linha a uma p√°gina da tabela, determinamos em qual intervalo ela est√° contida e usamos o mapa de intervalos para localizar a linha de √≠ndice com as informa√ß√µes de resumo.  Todas essas s√£o opera√ß√µes aritm√©ticas simples.  Por exemplo, permita que o tamanho de um intervalo seja quatro e, na p√°gina 13, ocorra uma vers√£o de linha com o valor de 42.  O n√∫mero do intervalo (come√ßando com zero) √© 13/4 = 3, portanto, em "revmap", pegamos o ponteiro com o deslocamento 3 (seu n√∫mero de ordem √© quatro). <br><br>  O valor m√≠nimo para esse intervalo √© 31 e o m√°ximo √© 40. Como o novo valor de 42 est√° fora do intervalo, atualizamos o valor m√°ximo (veja a figura).  Mas se o novo valor ainda estiver dentro dos limites armazenados, o √≠ndice n√£o precisar√° ser atualizado. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba7/6ce/e4c/ba76cee4c3d40e9f428954d0478ecee0.png"><br><br>  Tudo isso se refere √† situa√ß√£o em que a nova vers√£o da p√°gina ocorre em um intervalo para o qual as informa√ß√µes de resumo est√£o dispon√≠veis.  Quando o √≠ndice √© criado, as informa√ß√µes de resumo s√£o calculadas para todos os intervalos dispon√≠veis, mas enquanto a tabela √© expandida, novas p√°ginas podem ocorrer que caem fora dos limites.  Duas op√ß√µes est√£o dispon√≠veis aqui: <br><br><ol><li>  Normalmente, o √≠ndice n√£o √© atualizado imediatamente.  Isso n√£o √© grande coisa: como j√° mencionado, ao verificar o √≠ndice, todo o intervalo ser√° analisado.  A atualiza√ß√£o real √© feita durante o "v√°cuo" ou pode ser feita manualmente chamando a fun√ß√£o "brin_summarize_new_values". </li><li>  Se criarmos o √≠ndice com o par√¢metro "autosummarize", a atualiza√ß√£o ser√° feita imediatamente.  Mas quando as p√°ginas do intervalo s√£o preenchidas com novos valores, as atualiza√ß√µes podem ocorrer com muita frequ√™ncia; portanto, esse par√¢metro √© desativado por padr√£o. </li></ol><br>  Quando novos intervalos ocorrem, o tamanho do "revmap" pode aumentar.  Sempre que o mapa, localizado entre a meta p√°gina e os dados de resumo, precisar ser estendido por outra p√°gina, as vers√µes de linha existentes ser√£o movidas para algumas outras p√°ginas.  Portanto, o mapa de intervalos est√° sempre localizado entre a meta p√°gina e os dados resumidos. <br><br>  Quando uma linha √© <strong>exclu√≠da</strong> , ... nada acontece.  Podemos notar que, √†s vezes, o valor m√≠nimo ou m√°ximo ser√° exclu√≠do; nesse caso, o intervalo poder√° ser reduzido.  Mas para detectar isso, ter√≠amos que ler todos os valores no intervalo, e isso √© caro. <br><br>  A corre√ß√£o do √≠ndice n√£o √© afetada, mas a pesquisa pode exigir a busca por mais intervalos do que o necess√°rio.  Em geral, as informa√ß√µes de resumo podem ser recalculadas manualmente para essa zona (chamando as fun√ß√µes "brin_desummarize_range" e "brin_summarize_new_values"), mas como podemos detectar essa necessidade?  De qualquer forma, nenhum procedimento convencional est√° dispon√≠vel para esse fim. <br><br>  Por fim, <strong>atualizar uma linha</strong> √© apenas uma exclus√£o da vers√£o desatualizada e a adi√ß√£o de uma nova. <br><br><h2>  Exemplo </h2><br>  Vamos tentar construir nosso pr√≥prio mini data warehouse para os dados das tabelas do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">banco de dados demo</a> .  Vamos supor que, para fins de relat√≥rios de BI, seja necess√°ria uma tabela n√£o normalizada para refletir os v√¥os partidos de um aeroporto ou aterrissados ‚Äã‚Äãno aeroporto com a precis√£o de um assento na cabine.  Os dados de cada aeroporto ser√£o adicionados √† tabela uma vez por dia, quando √© meia-noite no fuso hor√°rio apropriado.  Os dados n√£o ser√£o atualizados nem exclu√≠dos. <br><br>  A tabela ter√° a seguinte apar√™ncia: <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> flights_bi( airport_code <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>), airport_coord <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- geo coordinates of airport airport_utc_offset interval, -- time zone flight_no char(6), -- flight number flight_type text. -- flight type: departure / arrival scheduled_time timestamptz, -- scheduled departure/arrival time of flight actual_time timestamptz, -- actual time of flight aircraft_code char(3), seat_no varchar(4), -- seat number fare_conditions varchar(10), -- travel class passenger_id varchar(20), passenger_name text );</span></span></code> </pre> <br>  Podemos simular o procedimento de carregamento dos dados usando loops aninhados: um externo por dias (consideraremos <a href="">um banco de dados grande</a> , portanto, 365 dias) e um loop interno por fusos hor√°rios (de UTC + 02 a UTC + 12) .  A consulta √© bastante longa e n√£o √© de interesse particular, ent√£o eu a ocultarei sob o spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Simula√ß√£o de carregamento de dados no armazenamento</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-symbol"><span class="pgsql"><span class="hljs-symbol">&lt;&lt;local&gt;&gt;</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">DECLARE</span></span></span><span class="pgsql"> curdate </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">date</span></span></span><span class="pgsql"> := (</span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> min(scheduled_departure) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> flights); utc_offset </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">interval</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHILE</span></span></span><span class="pgsql"> (curdate &lt;= bookings.now()::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">date</span></span></span><span class="pgsql">) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> utc_offset := </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">interval</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'12 hours'</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHILE</span></span></span><span class="pgsql"> (utc_offset &gt;= </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">interval</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'2 hours'</span></span></span><span class="pgsql">) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INSERT</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> flights_bi </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WITH</span></span></span><span class="pgsql"> flight ( airport_code, airport_coord, flight_id, flight_no, scheduled_time, actual_time, aircraft_code, flight_type ) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ( </span><span class="hljs-comment"><span class="pgsql"><span class="hljs-comment">--  SELECT a.airport_code, a.coordinates, f.flight_id, f.flight_no, f.scheduled_departure, f.actual_departure, f.aircraft_code, 'departure' FROM airports a, flights f, pg_timezone_names tzn WHERE a.airport_code = f.departure_airport AND f.actual_departure IS NOT NULL AND tzn.name = a.timezone AND tzn.utc_offset = local.utc_offset AND timezone(a.timezone, f.actual_departure)::date = curdate UNION ALL --  SELECT a.airport_code, a.coordinates, f.flight_id, f.flight_no, f.scheduled_arrival, f.actual_arrival, f.aircraft_code, 'arrival' FROM airports a, flights f, pg_timezone_names tzn WHERE a.airport_code = f.arrival_airport AND f.actual_arrival IS NOT NULL AND tzn.name = a.timezone AND tzn.utc_offset = local.utc_offset AND timezone(a.timezone, f.actual_arrival)::date = curdate ) SELECT f.airport_code, f.airport_coord, local.utc_offset, f.flight_no, f.flight_type, f.scheduled_time, f.actual_time, f.aircraft_code, s.seat_no, s.fare_conditions, t.passenger_id, t.passenger_name FROM flight f JOIN seats s ON s.aircraft_code = f.aircraft_code LEFT JOIN boarding_passes bp ON bp.flight_id = f.flight_id AND bp.seat_no = s.seat_no LEFT JOIN ticket_flights tf ON tf.ticket_no = bp.ticket_no AND tf.flight_id = bp.flight_id LEFT JOIN tickets t ON t.ticket_no = tf.ticket_no; RAISE NOTICE '%, %', curdate, utc_offset; utc_offset := utc_offset - interval '1 hour'; END LOOP; curdate := curdate + 1; END LOOP; END; $$</span></span></span></span>;</code> </pre><br></div></div><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi;</code> </pre><pre> <code class="plaintext hljs"> count ---------- 30517076 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 4127 MB (1 row)</code> </pre><br>  Temos 30 milh√µes de linhas e 4 GB.  Um tamanho n√£o t√£o grande, mas bom o suficiente para um laptop: a varredura seq√ºencial levou cerca de 10 segundos. <br><br><h3>  Em quais colunas devemos criar o √≠ndice? </h3><br>  Como os √≠ndices BRIN t√™m um tamanho pequeno e os custos indiretos moderados e as atualiza√ß√µes ocorrem com pouca frequ√™ncia, se houver, surge uma rara oportunidade de criar muitos √≠ndices "por precau√ß√£o", por exemplo, em todos os campos nos quais os usu√°rios analistas podem criar suas consultas ad-hoc .  N√£o ser√° √∫til - n√£o importa, mas mesmo um √≠ndice que n√£o √© muito eficiente funcionar√° melhor do que a varredura seq√ºencial, com certeza.  Obviamente, existem campos nos quais √© absolutamente in√∫til criar um √≠ndice;  o puro senso comum os motivar√°. <br><br>  Mas deve ser estranho nos limitar a esse conselho, portanto, vamos tentar estabelecer um crit√©rio mais preciso. <br><br>  J√° mencionamos que os dados devem se correlacionar um pouco com sua localiza√ß√£o f√≠sica.  Aqui faz sentido lembrar que o PostgreSQL re√∫ne estat√≠sticas da coluna da tabela, que incluem o valor da correla√ß√£o.  O planejador usa esse valor para selecionar entre uma verifica√ß√£o de √≠ndice regular e uma verifica√ß√£o de bitmap, e podemos us√°-lo para estimar a aplicabilidade do √≠ndice BRIN. <br><br>  No exemplo acima, os dados s√£o evidentemente ordenados por dias (por "hor√°rio_ agendado" e tamb√©m por "hor√°rio_atual" - n√£o h√° muita diferen√ßa).  Isso ocorre porque quando as linhas s√£o adicionadas √† tabela (sem exclus√µes e atualiza√ß√µes), elas s√£o dispostas no arquivo uma ap√≥s a outra.  Na simula√ß√£o do carregamento de dados, nem usamos a cl√°usula ORDER BY; portanto, as datas dentro de um dia podem, em geral, ser misturadas de maneira arbitr√°ria, mas a ordem deve estar em vigor.  Vamos verificar isso: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> flights_bi; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename=<span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> correlation <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nulls last</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation --------------------+------------- scheduled_time | 0.999994 actual_time | 0.999994 fare_conditions | 0.796719 flight_type | 0.495937 airport_utc_offset | 0.438443 aircraft_code | 0.172262 airport_code | 0.0543143 flight_no | 0.0121366 seat_no | 0.00568042 passenger_name | 0.0046387 passenger_id | -0.00281272 airport_coord | (12 rows)</code> </pre><br>  O valor que n√£o est√° muito pr√≥ximo de zero (idealmente, pr√≥ximo de mais um menos, como neste caso), nos diz que o √≠ndice BRIN ser√° apropriado. <br><br>  A classe de viagem "fare_condition" (a coluna cont√©m tr√™s valores exclusivos) e o tipo de voo "flight_type" (dois valores exclusivos) inesperadamente pareciam estar no segundo e no terceiro lugares.  Isso √© uma ilus√£o: formalmente, a correla√ß√£o √© alta, enquanto, em v√°rias p√°ginas sucessivas, todos os valores poss√≠veis ser√£o encontrados com certeza, o que significa que o BRIN n√£o far√° nenhum bem. <br><br>  O fuso hor√°rio "airport_utc_offset" segue a seguir: no exemplo considerado, em um ciclo di√°rio, os aeroportos s√£o ordenados por fusos hor√°rios "por constru√ß√£o". <br><br>  S√£o esses dois campos, hor√°rio e fuso hor√°rio, que iremos experimentar mais adiante. <br><br><h3>  Poss√≠vel enfraquecimento da correla√ß√£o </h3><br>  A correla√ß√£o que √© o local "por constru√ß√£o" pode ser facilmente enfraquecida quando os dados s√£o alterados.  E o problema aqui n√£o est√° na altera√ß√£o de um valor espec√≠fico, mas na estrutura do controle de simultaneidade multivers√£o: a vers√£o da linha desatualizada √© exclu√≠da em uma p√°gina, mas uma nova vers√£o pode ser inserida sempre que houver espa√ßo livre dispon√≠vel.  Devido a isso, linhas inteiras se misturam durante as atualiza√ß√µes. <br><br>  Podemos controlar parcialmente esse efeito, reduzindo o valor do par√¢metro de armazenamento "fillfactor" e, dessa forma, deixando espa√ßo livre em uma p√°gina para futuras atualiza√ß√µes.  Mas queremos aumentar o tamanho de uma mesa j√° grande?  Al√©m disso, isso n√£o resolve o problema das exclus√µes: elas tamb√©m "configuram traps" para novas linhas, liberando espa√ßo em algum lugar nas p√°ginas existentes.  Por esse motivo, as linhas que, de outra forma, chegariam ao final do arquivo, ser√£o inseridas em algum local arbitr√°rio. <br><br>  A prop√≥sito, este √© um fato curioso.  Como o √≠ndice BRIN n√£o cont√©m refer√™ncias √†s linhas da tabela, sua disponibilidade n√£o deve impedir as atualiza√ß√µes HOT, mas sim. <br><br>  Portanto, o BRIN √© projetado principalmente para tabelas de tamanhos grandes e at√© enormes, que n√£o s√£o atualizadas ou s√£o levemente atualizadas.  No entanto, ele lida perfeitamente com a adi√ß√£o de novas linhas (no final da tabela).  Isso n√£o √© surpreendente, pois esse m√©todo de acesso foi criado com vista a data warehouses e relat√≥rios anal√≠ticos. <br><br><h3>  Qual o tamanho de um intervalo que precisamos selecionar? </h3><br>  Se lidarmos com uma tabela de terabytes, nossa principal preocupa√ß√£o ao selecionar o tamanho de um intervalo provavelmente n√£o ser√° tornar o √≠ndice BRIN muito grande.  No entanto, em nossa situa√ß√£o, podemos nos permitir analisar dados com mais precis√£o. <br><br>  Para fazer isso, podemos selecionar valores exclusivos de uma coluna e ver quantas p√°ginas elas ocorrem.  A localiza√ß√£o dos valores aumenta as chances de sucesso na aplica√ß√£o do √≠ndice BRIN.  Al√©m disso, o n√∫mero encontrado de p√°ginas solicitar√° o tamanho de um intervalo.  Mas se o valor for "espalhado" por todas as p√°ginas, o BRIN ser√° in√∫til. <br><br>  Obviamente, devemos usar essa t√©cnica observando atentamente a estrutura interna dos dados.  Por exemplo, n√£o faz sentido considerar cada data (mais exatamente, um carimbo de data / hora, incluindo tamb√©m a hora) como um valor √∫nico - precisamos arredond√°-lo para dias. <br><br>  Tecnicamente, essa an√°lise pode ser feita observando o valor da coluna "ctid" oculta, que fornece o ponteiro para uma vers√£o de linha (TID): o n√∫mero da p√°gina e o n√∫mero da linha dentro da p√°gina.  Infelizmente, n√£o existe uma t√©cnica convencional para decompor o TID em seus dois componentes; portanto, temos que converter tipos atrav√©s da representa√ß√£o de texto: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> min(numblk), round(avg(numblk)) avg, max(numblk) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(<span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> (ctid::<span class="hljs-type"><span class="hljs-type">text</span></span>::<span class="hljs-type"><span class="hljs-type">point</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]) numblk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> scheduled_time::<span class="hljs-type"><span class="hljs-type">date</span></span> ) t;</code> </pre><pre> <code class="plaintext hljs"> min | avg | max ------+------+------ 1192 | 1500 | 1796 (1 row)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname = <span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 528172 (1 row)</code> </pre><br>  Podemos ver que cada dia √© distribu√≠do pelas p√°ginas de maneira bastante uniforme, e os dias s√£o levemente misturados entre si (1500 vezes 365 = 547500, que √© apenas um pouco maior que o n√∫mero de p√°ginas na tabela 528172).  Isso √© realmente claro "por constru√ß√£o" de qualquer maneira. <br><br>  Informa√ß√µes valiosas aqui s√£o um n√∫mero espec√≠fico de p√°ginas.  Com um tamanho de intervalo convencional de 128 p√°ginas, cada dia preencher√° de 9 a 14 intervalos.  Isso parece realista: com uma consulta para um dia espec√≠fico, podemos esperar um erro em torno de 10%. <br><br>  Vamos tentar: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> brin(scheduled_time);</code> </pre><br>  O tamanho do √≠ndice √© t√£o pequeno quanto 184 KB: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 184 kB (1 row)</code> </pre><br>  Nesse caso, dificilmente faz sentido aumentar o tamanho de um intervalo com o custo de perder a precis√£o.  Mas podemos reduzir o tamanho, se necess√°rio, e a precis√£o aumentar√° (pelo contr√°rio, juntamente com o tamanho do √≠ndice). <br><br>  Agora vamos ver os fusos hor√°rios.  Aqui tamb√©m n√£o podemos usar uma abordagem de for√ßa bruta.  Todos os valores devem ser divididos pelo n√∫mero de ciclos do dia, pois a distribui√ß√£o √© repetida em cada dia.  Al√©m disso, como existem apenas alguns fusos hor√°rios, podemos observar toda a distribui√ß√£o: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> airport_utc_offset, count(<span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> (ctid::<span class="hljs-type"><span class="hljs-type">text</span></span>::<span class="hljs-type"><span class="hljs-type">point</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>])/<span class="hljs-number"><span class="hljs-number">365</span></span> numblk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> airport_utc_offset <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> airport_utc_offset | numblk --------------------+-------- 12:00:00 | 6 06:00:00 | 8 02:00:00 | 10 11:00:00 | 13 08:00:00 | 28 09:00:00 | 29 10:00:00 | 40 04:00:00 | 47 07:00:00 | 110 05:00:00 | 231 03:00:00 | 932 (11 rows)</code> </pre><br>  Em m√©dia, os dados para cada fuso hor√°rio preenchem 133 p√°ginas por dia, mas a distribui√ß√£o √© altamente n√£o uniforme: Petropavlovsk-Kamchatskiy e Anadyr cabem apenas seis p√°ginas, enquanto Moscou e seus arredores exigem centenas delas.  O tamanho padr√£o de um intervalo n√£o √© bom aqui;  vamos, por exemplo, configur√°-lo para quatro p√°ginas. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> brin(airport_utc_offset) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (pages_per_range=<span class="hljs-number"><span class="hljs-number">4</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_airport_utc_offset_idx'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 6528 kB (1 row)</code> </pre><br><h2>  Plano de execu√ß√£o </h2><br>  Vejamos como nossos √≠ndices funcionam.  Vamos selecionar um dia, digamos, uma semana atr√°s (no banco de dados demo, "hoje" √© determinado pela fun√ß√£o "booking.now"): <br><br><pre> <code class="pgsql hljs">demo=# \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> d <span class="hljs-string"><span class="hljs-string">'bookings.now()::date - interval \'</span></span><span class="hljs-number"><span class="hljs-number">7</span></span> days\<span class="hljs-string"><span class="hljs-string">''</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduled_time &gt;= :d <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> scheduled_time &lt; :d + <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=10.282..94.328 rows=83954 loops=1) Recheck Cond: ... Rows Removed by Index Recheck: 12045 Heap Blocks: lossy=1664 -&gt; Bitmap Index Scan on flights_bi_scheduled_time_idx (actual time=3.013..3.013 rows=16640 loops=1) Index Cond: ... Planning time: 0.375 ms Execution time: 97.805 ms</code> </pre><br>  Como podemos ver, o planejador usou o √≠ndice criado.  Qual √© a precis√£o?  A propor√ß√£o do n√∫mero de linhas que atendem √†s condi√ß√µes da consulta ("linhas" do n√≥ Bitmap Heap Scan) e o n√∫mero total de linhas retornadas usando o √≠ndice (o mesmo valor mais Linhas removidas pela verifica√ß√£o do √≠ndice) nos informa sobre isso.  Nesse caso, 83954 / (83954 + 12045), que √© de aproximadamente 90%, conforme o esperado (esse valor ser√° alterado de um dia para outro). <br><br>  De onde se origina o n√∫mero 16640 em "linhas reais" do n√≥ Bitmap Index Scan?  O fato √© que esse n√≥ do plano cria um bitmap impreciso (p√°gina por p√°gina) e n√£o tem conhecimento de quantas linhas o bitmap tocar√°, enquanto algo precisa ser mostrado.  Portanto, em desespero, assume-se que uma p√°gina cont√©m 10 linhas.  O bitmap cont√©m 1664 p√°ginas no total (esse valor √© mostrado em "Heap Blocks: lossy = 1664");  ent√£o, obtemos 16640. No total, esse √© um n√∫mero sem sentido, ao qual n√£o devemos prestar aten√ß√£o. <br><br>  E os aeroportos?  Por exemplo, vamos usar o fuso hor√°rio de Vladivostok, que preenche 28 p√°ginas por dia: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> airport_utc_offset = <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'8 hours'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=75.151..192.210 rows=587353 loops=1) Recheck Cond: (airport_utc_offset = '08:00:00'::interval) Rows Removed by Index Recheck: 191318 Heap Blocks: lossy=13380 -&gt; Bitmap Index Scan on flights_bi_airport_utc_offset_idx (actual time=74.999..74.999 rows=133800 loops=1) Index Cond: (airport_utc_offset = '08:00:00'::interval) Planning time: 0.168 ms Execution time: 212.278 ms</code> </pre><br>  O planejador novamente usa o √≠ndice BRIN criado.  A precis√£o √© pior (cerca de 75% nesse caso), mas isso √© esperado, pois a correla√ß√£o √© menor. <br><br>  V√°rios √≠ndices BRIN (como qualquer outro) certamente podem ser unidos no n√≠vel de bitmap.  Por exemplo, a seguir est√£o os dados no fuso hor√°rio selecionado para um m√™s (observe o n√≥ "BitmapAnd"): <br><br><pre> <code class="pgsql hljs">demo=# \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> d <span class="hljs-string"><span class="hljs-string">'bookings.now()::date - interval \'</span></span><span class="hljs-number"><span class="hljs-number">60</span></span> days\<span class="hljs-string"><span class="hljs-string">''</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduled_time &gt;= :d <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> scheduled_time &lt; :d + <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'30 days'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> airport_utc_offset = <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'8 hours'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=62.046..113.849 rows=48154 loops=1) Recheck Cond: ... Rows Removed by Index Recheck: 18856 Heap Blocks: lossy=1152 -&gt; BitmapAnd (actual time=61.777..61.777 rows=0 loops=1) -&gt; Bitmap Index Scan on flights_bi_scheduled_time_idx (actual time=5.490..5.490 rows=435200 loops=1) Index Cond: ... -&gt; Bitmap Index Scan on flights_bi_airport_utc_offset_idx (actual time=55.068..55.068 rows=133800 loops=1) Index Cond: ... Planning time: 0.408 ms Execution time: 115.475 ms</code> </pre><br><h3>  Compara√ß√£o com b-tree </h3><br>  E se criarmos um √≠ndice de √°rvore B regular no mesmo campo que o BRIN? <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_bi_scheduled_time_btree <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi(scheduled_time); demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_btree'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 654 MB (1 row)</code> </pre><br>  Parecia ser <em>milhares de vezes maior</em> que o nosso BRIN!  No entanto, a consulta √© realizada um pouco mais r√°pido: o planejador usou as estat√≠sticas para descobrir que os dados est√£o ordenados fisicamente e n√£o √© necess√°rio criar um bitmap e, principalmente, que a condi√ß√£o do √≠ndice n√£o precisa ser verificada novamente: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduled_time &gt;= :d <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> scheduled_time &lt; :d + <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------- Index Scan using flights_bi_scheduled_time_btree on flights_bi (actual time=0.099..79.416 rows=83954 loops=1) Index Cond: ... Planning time: 0.500 ms Execution time: 85.044 ms</code> </pre><br>  √â o que h√° de mais maravilhoso no BRIN: sacrificamos a efici√™ncia, mas ganhamos muito espa√ßo. <br><br><h2>  Classes de operadores </h2><br><h3>  minmax </h3><br>  Para tipos de dados cujos valores podem ser comparados entre si, as informa√ß√µes de resumo consistem <em>nos valores m√≠nimo e m√°ximo</em> .  Os nomes das classes de operadores correspondentes cont√™m "minmax", por exemplo, "date_minmax_ops".  Na verdade, esses s√£o os tipos de dados que est√°vamos considerando at√© agora e a maioria deles √© desse tipo. <br><br><h3>  inclusivo </h3><br>  Operadores de compara√ß√£o n√£o s√£o definidos para todos os tipos de dados.  Por exemplo, eles n√£o est√£o definidos para pontos (tipo "ponto"), que representam as coordenadas geogr√°ficas dos aeroportos.  A prop√≥sito, √© por esse motivo que as estat√≠sticas n√£o mostram a correla√ß√£o para esta coluna. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename=<span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> attname = <span class="hljs-string"><span class="hljs-string">'airport_coord'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation ---------------+------------- airport_coord | (1 row)</code> </pre><br>  Mas muitos desses tipos nos permitem introduzir um conceito de "√°rea delimitadora", por exemplo, um ret√¢ngulo delimitador para formas geom√©tricas.  Discutimos em detalhes como o √≠ndice <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GiST</a> usa esse recurso.  Da mesma forma, o BRIN tamb√©m permite reunir informa√ß√µes de resumo em colunas com tipos de dados como estes: <em>a √°rea delimitadora para todos os valores dentro de um intervalo</em> √© apenas o valor de resumo. <br><br>  Diferentemente do GiST, o valor de resumo para BRIN deve ser do mesmo tipo que os valores que est√£o sendo indexados.  Portanto, n√£o podemos construir o √≠ndice para pontos, embora seja claro que as coordenadas possam funcionar no BRIN: a longitude est√° intimamente ligada ao fuso hor√°rio.  Felizmente, nada impede a cria√ß√£o do √≠ndice em uma express√£o ap√≥s transformar pontos em ret√¢ngulos degenerados.  Ao mesmo tempo, definiremos o tamanho de um intervalo para uma p√°gina, apenas para mostrar o caso limite: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> brin (box(airport_coord)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (pages_per_range=<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  O tamanho do √≠ndice √© t√£o pequeno quanto 30 MB, mesmo em uma situa√ß√£o t√£o extrema: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_box_idx'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 30 MB (1 row)</code> </pre><br>  Agora podemos fazer consultas que limitam os aeroportos por coordenadas.  Por exemplo: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> airport_code, airport_name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> airports <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(coordinates) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> airport_code | airport_name --------------+----------------- KHV | Khabarovsk-Novyi VVO | Vladivostok (2 rows)</code> </pre><br>  O planejador, no entanto, se recusar√° a usar nosso √≠ndice. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> flights_bi; demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(airport_coord) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Seq Scan on flights_bi (cost=0.00..985928.14 rows=30517 width=111) Filter: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box)</code> </pre><br>  Porque  Vamos desativar a varredura sequencial e ver o que acontece: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(airport_coord) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (cost=14079.67..1000007.81 rows=30517 width=111) Recheck Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) -&gt; Bitmap Index Scan on flights_bi_box_idx (cost=0.00..14072.04 rows=30517076 width=0) Index Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box)</code> </pre><br>  Parece que o √≠ndice <em>pode ser</em> usado, mas o planejador sup√µe que o bitmap precise ser constru√≠do em toda a tabela (veja "linhas" do n√≥ Bitmap Index Scan) e n√£o √© de admirar que o planejador escolha a varredura seq√ºencial em neste caso.  A quest√£o aqui √© que, para os tipos geom√©tricos, o PostgreSQL n√£o coleta nenhuma estat√≠stica, e o planejador precisa ir √†s cegas: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'flights_bi_box_idx'</span></span> \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------+------------------- schemaname | bookings tablename | flights_bi_box_idx attname | box inherited | f null_frac | 0 avg_width | 32 n_distinct | 0 most_common_vals | most_common_freqs | histogram_bounds | correlation | most_common_elems | most_common_elem_freqs | elem_count_histogram |</code> </pre><br>  Infelizmente.  Mas n√£o h√° reclama√ß√µes sobre o √≠ndice - ele funciona e funciona bem: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(airport_coord) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=158.142..315.445 rows=781790 loops=1) Recheck Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) Rows Removed by Index Recheck: 70726 Heap Blocks: lossy=14772 -&gt; Bitmap Index Scan on flights_bi_box_idx (actual time=158.083..158.083 rows=147720 loops=1) Index Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) Planning time: 0.137 ms Execution time: 340.593 ms</code> </pre><br>  A conclus√£o deve ser assim: PostGIS √© necess√°rio se algo n√£o trivial for necess√°rio para a geometria.  Ele pode coletar estat√≠sticas de qualquer maneira. <br><br><h2>  Internals </h2><br>  A extens√£o convencional "pageinspect" nos permite examinar o √≠ndice BRIN. <br><br>  Primeiro, a metainforma√ß√£o nos solicitar√° o tamanho de um intervalo e quantas p√°ginas est√£o alocadas para "revmap": <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> magic | version | pagesperrange | lastrevmappage ------------+---------+---------------+---------------- 0xA8109CFA | 1 | 128 | 3 (1 row)</code> </pre><br>  As p√°ginas 1-3 aqui s√£o alocadas para "revmap", enquanto o restante cont√©m dados resumidos.  No "revmap", podemos obter refer√™ncias a dados resumidos para cada intervalo.  Digamos, as informa√ß√µes do primeiro intervalo, incorporando as primeiras 128 p√°ginas, est√£o localizadas aqui: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_revmap_data(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pages --------- (6,197) (1 row)</code> </pre><br>  E este √© o pr√≥prio resumo dos dados: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> allnulls, hasnulls, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_page_items( get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> itemoffset = <span class="hljs-number"><span class="hljs-number">197</span></span>;</code> </pre><pre> <code class="plaintext hljs"> allnulls | hasnulls | value ----------+----------+---------------------------------------------------- f | f | {2016-08-15 02:45:00+03 .. 2016-08-15 17:15:00+03} (1 row)</code> </pre><br>  Pr√≥ximo intervalo: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_revmap_data(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pages --------- (6,198) (1 row)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> allnulls, hasnulls, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_page_items( get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> itemoffset = <span class="hljs-number"><span class="hljs-number">198</span></span>;</code> </pre><pre> <code class="plaintext hljs"> allnulls | hasnulls | value ----------+----------+---------------------------------------------------- f | f | {2016-08-15 06:00:00+03 .. 2016-08-15 18:55:00+03} (1 row)</code> </pre><br>  E assim por diante <br><br>  Para classes "inclus√£o", o campo "valor" exibir√° algo como <br><br><pre> <code class="plaintext hljs"> {(94.4005966186523,69.3110961914062),(77.6600036621,51.6693992614746) .. f .. f}</code> </pre><br>  O primeiro valor √© o ret√¢ngulo de incorpora√ß√£o, e as letras "f" no final denotam a falta de elementos vazios (o primeiro) e a falta de valores imersos (o segundo).  Na verdade, os √∫nicos valores n√£o substitu√≠veis s√£o os endere√ßos "IPv4" e "IPv6" (tipo de dados "inet"). <br><br><h2>  Propriedades </h2><br>  Lembrando as consultas que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">j√° foram fornecidas</a> . <br><br>  A seguir est√£o as propriedades do m√©todo de acesso: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- brin | can_order | f brin | can_unique | f brin | can_multi_col | t brin | can_exclude | f</code> </pre><br>  Os √≠ndices podem ser criados em v√°rias colunas.  Nesse caso, suas pr√≥prias estat√≠sticas de resumo s√£o reunidas para cada coluna, mas s√£o armazenadas juntas para cada intervalo.  Obviamente, esse √≠ndice faz sentido se um e o mesmo tamanho de um intervalo for adequado para todas as colunas. <br><br>  As seguintes propriedades da camada de √≠ndice est√£o dispon√≠veis: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Evidentemente, apenas a verifica√ß√£o de bitmap √© suportada. <br><br>  No entanto, a falta de cluster pode parecer confusa.  Aparentemente, como o √≠ndice BRIN √© sens√≠vel √† ordem f√≠sica das linhas, seria l√≥gico poder agrupar dados de acordo com o √≠ndice.  Mas isso n√£o √© verdade.  S√≥ podemos criar um √≠ndice "regular" (√°rvore B ou GiST, dependendo do tipo de dados) e agrupar de acordo com ele.  A prop√≥sito, voc√™ deseja agrupar uma tabela supostamente enorme, levando em considera√ß√£o bloqueios exclusivos, tempo de execu√ß√£o e consumo de espa√ßo em disco durante a reconstru√ß√£o? <br><br>  A seguir est√£o as propriedades da camada de coluna: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | t</code> </pre><br>  A √∫nica propriedade dispon√≠vel √© a capacidade de manipular NULLs. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Continue lendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452900/">https://habr.com/ru/post/pt452900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452886/index.html">Projetos Wiki e nome Noosfera em HACKNOWLEGE</a></li>
<li><a href="../pt452888/index.html">Perto de Munique, come√ßou a testar o tiltrotor Lilium Jet de cinco lugares</a></li>
<li><a href="../pt452890/index.html">23 de maio, 18:30 - transmiss√£o ao vivo da cozinha QIWI</a></li>
<li><a href="../pt452892/index.html">Como um n√£o programador pode se mudar para os EUA: instru√ß√µes passo a passo</a></li>
<li><a href="../pt452894/index.html">Enfrente o Anti-Spoofing ou reconhe√ßa tecnologicamente um trapaceiro entre mil</a></li>
<li><a href="../pt452902/index.html">Terminando 4 anos de treinamento como programador, entendo que estou longe de ser um programador</a></li>
<li><a href="../pt452904/index.html">Como as m√°quinas se comunicam - protocolo MQTT</a></li>
<li><a href="../pt452906/index.html">Mecanismos JavaScript: como eles funcionam? Da pilha de chamadas √†s promessas, (quase) tudo o que voc√™ precisa saber</a></li>
<li><a href="../pt452908/index.html">Selenium WebDriver - M√©trica de teste em tempo real usando Grafana e InfluxDB</a></li>
<li><a href="../pt452910/index.html">Ol√° Habr! Ol√° Tercon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>