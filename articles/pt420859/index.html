<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêß üòø üë®‚Äçüë¶ √Ä quest√£o de Wirth e correntes ‚ú°Ô∏è üßôüèº üë©üèº‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algoritmos + estruturas de dados = programas - Virt N. 
 ‚ÄúTivemos uma oportunidade maravilhosa de realizar um exerc√≠cio t√°tico pequeno, mas extremamen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√Ä quest√£o de Wirth e correntes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420859/"><h2>  Algoritmos + estruturas de dados = programas - Virt N. </h2><br><img src="https://habrastorage.org/webt/00/wp/ch/00wpchad9zptu4pxyqszkymsin4.jpeg" align="left"><h3>  ‚ÄúTivemos uma oportunidade maravilhosa de realizar um exerc√≠cio t√°tico pequeno, mas extremamente instrutivo‚Äù </h3><br>  Apesar da primeira ep√≠grafe deste post, permito-me discordar do autor e tento mostrar que, em alguns casos, a escolha certa da estrutura de dados pode ser mais significativa do que a escolha certa de algoritmos.  Para ilustrar uma tese t√£o sediciosa, consideremos uma tarefa simples, mas promissora, para estudar o jogo "Cadeia". <br><a name="habracut"></a><br>  Primeiro, sobre as regras do jogo - dois jogadores jogam, a posi√ß√£o inicial consiste em N objetos localizados nas proximidades.  O pr√≥ximo passo √© remover qualquer um ou dois objetos localizados nas proximidades (voc√™ pode tentar dar uma defini√ß√£o formal de "localiza√ß√£o pr√≥xima", mas √© compreens√≠vel em um n√≠vel intuitivo).  O jogador que remove o √∫ltimo objeto ganha - o jogo direto, ou aquele que deve (voc√™ n√£o pode pular a jogada) pegar o √∫ltimo objeto - o jogo inverso vence.  Como nesta vers√£o das regras, um jogo direto ser√° simplesmente desinteressante (mais sobre isso mais tarde), uma restri√ß√£o adicional √© introduzida - apenas um objeto pode ser exclu√≠do na primeira jogada. <br><br>  Primeiro, determinamos que o jogo √© finito, porque a cada movimento o n√∫mero de objetos diminui estritamente e o jogo termina quando o n√∫mero de objetos calculado por zero √© atingido, portanto, temos o direito de contar com sucesso no estudo desse jogo.  Al√©m disso, √© √≥bvio que o jogo n√£o pode durar mais que N movimentos, lembremo-nos desse fato. <br><br>  O estudo do jogo consiste em determinar se, para um n√∫mero inicial espec√≠fico de objetos, o jogador que est√° fazendo o primeiro movimento est√° ganhando (j√° que este √© um jogo com soma zero, caso contr√°rio ele est√° perdendo) com um jogo ideal de ambos os lados e em qual n√∫mero m√≠nimo de movimentos o ganho √© alcan√ßado (ou por qual √© o n√∫mero m√°ximo de movimentos que a perda se afasta). <br><br>  Para alguns de H, a resposta √© √≥bvia - com um objeto, o primeiro ganha um jogo direto em um turno e tamb√©m perde um jogo inverso (P1 = 1, I1 = -1).  Com dois objetos, o primeiro jogador perde em dois movimentos em um jogo direto e vence em dois movimentos em inverso (P2 = -2, I2 = 2), o que pode dar origem a uma hip√≥tese sobre a simplicidade de avaliar esse jogo, confirmada pelo caso de tr√™s objetos (P2 = 3, I3 = -3).  Felizmente (caso contr√°rio, este post n√£o teria sido publicado), um jogo com quatro objetos muda um pouco a imagem (P4 = -4, mas I4 = -3), portanto, √© realmente necess√°rio pesquisar o jogo. <br><br>  Para alguns de H e para um certo tipo de jogo, existem algoritmos heur√≠sticos que oferecem recompensa garantida.  Por exemplo, para um jogo direto com um inicial H √≠mpar, voc√™ pode ganhar se remover o objeto central com o primeiro movimento e depois repetir os movimentos do oponente usando um local central como o eixo de simetria; ent√£o, garantimos que vamos pegar o √∫ltimo objeto e vencer.  A mesma estrat√©gia funcionaria com um n√∫mero par de objetos, se n√£o fosse pelas restri√ß√µes na primeira jogada, o que torna o jogo n√£o t√£o trivial.  De um modo geral, o uso de estrat√©gias sim√©tricas √© uma ocorr√™ncia bastante comum na contagem de jogos, mas n√£o uma panac√©ia, porque, por exemplo, em nosso jogo inverso, essa estrat√©gia falha.  Deve-se notar que as heur√≠sticas fornecem um algoritmo vencedor, mas n√£o fornecem uma estimativa precisa da posi√ß√£o, pois pode haver estrat√©gias que levam a ganhos mais r√°pidos (esse √© o caso desse jogo em particular). <br><br>  Como podemos fazer uma avalia√ß√£o do jogo - exatamente como recebi as estimativas anteriores para 1 a 4 objetos - o m√©todo √© chamado de pesquisa exaustiva de cima para baixo - devemos considerar a √°rvore completa do jogo, ou seja, todos os movimentos poss√≠veis para ambos os lados e avaliar cada posi√ß√£o, incluindo fonte, de acordo com certas regras.  Deve-se observar que a exist√™ncia de heur√≠sticas bem-sucedidas n√£o nos garante uma avalia√ß√£o precisa, pois responde apenas √† primeira metade da pergunta - quem vence, mas n√£o fornece o n√∫mero m√≠nimo necess√°rio de jogadas. <br><br>  Isso significa que devemos construir uma √°rvore de jogo completa, mas antes de prosseguir com a constru√ß√£o, devemos criar um modelo do objeto em estudo, no nosso caso, o jogo. <br><br>  Por que me concentro nesse est√°gio - porque n√£o podemos explorar o objeto em sua concretiza√ß√£o material.  N√£o, puramente teoricamente isso √© poss√≠vel (‚Äúpouco √© poss√≠vel no mundo em geral puramente teoricamente‚Äù) e posso imaginar uma imagem em que um n√∫mero muito grande de rob√¥s joga muitos jogos no mundo real, mas os custos de material para uma solu√ß√£o para o problema de avaliar o jogo excedem o quantidades, ent√£o somos for√ßados a embarcar no caminho de modelar objetos reais com suas contrapartes de software.  E aqui √© muito importante seguir uma linha fina, combinando um n√≠vel suficiente de adequa√ß√£o do modelo e a simplifica√ß√£o necess√°ria. <br><br>  Mas primeiro, um pouco de matem√°tica para avaliar a complexidade da tarefa - precisamos classificar todos os movimentos poss√≠veis no jogo (aten√ß√£o n√£o s√£o todas as posi√ß√µes poss√≠veis, este √© o t√≥pico de outro m√©todo, ou seja, os movimentos) e gostar√≠amos de avaliar a quantidade necess√°ria de recursos antes de come√ßar o trabalho - para determinar a ordem da tarefa.  No primeiro movimento, temos a oportunidade de remover qualquer chip (continuarei chamando objetos) de H dispon√≠vel, no pr√≥ximo movimento - qualquer um dos restantes H-1 ou dois chips pr√≥ximos (n√£o haver√° mais do que H-2), que fornece o n√∫mero total de op√ß√µes Hx (H-1 + H-2).  √â f√°cil ver que, ap√≥s o terceiro movimento, temos Hx (H-1 + H-2) x (H-2 + H-3 + Œî) e assim por diante. <br><br>  Se nos restringirmos em cada colchete apenas aos primeiros termos da soma, obteremos uma estimativa do n√∫mero total de movimentos como H!, O que nos fornece uma estimativa nas quadraturas de H ^ H. <br><br>  Esse √© um resultado muito desagrad√°vel, que afirma que teremos problemas muito grandes com o H significativo, de modo que a modelagem "prov√°vel" implicar√° custos computacionais significativos.  Por exemplo, para 16 fichas na posi√ß√£o inicial, precisaremos considerar aproximadamente 16! = 10 √ó 13 jogadas, e se uma jogada for 10E-9 segundos (estimativa bastante otimista), o tempo total ser√° de 10E4 segundos ou quase 3 horas, o que √© um pouco demais , mas aceit√°vel, mas por apenas 20 chips, o tempo de c√°lculo esperado √© de 77 anos, o que √© claramente inaceit√°vel.  O fatorial est√° crescendo muito r√°pido e n√£o h√° nada a ser feito sobre isso. <br><br>  Chamamos aten√ß√£o para o fato de que o n√∫mero de movimentos excede significativamente o n√∫mero de posi√ß√µes poss√≠veis, que √© de apenas 2 ^ N, e √© √≥bvio que cairemos em uma posi√ß√£o separada por 16 fichas 10E (13-5) = 10E7 vezes, o que √© uma ocorr√™ncia bastante comum para tarefas de pesquisa.  Lembre-se deste fato, ser√° √∫til para n√≥s mais tarde. <br><br>  No entanto, come√ßaremos a escrever um programa, para o qual determinaremos o modelo.  Primeiro, numeramos os chips de 1 a H, depois criamos uma matriz com o n√∫mero de elementos H e determinamos que o n√∫mero 1 no elemento da matriz com √≠ndice n significa a presen√ßa do n√∫mero de chip n e o n√∫mero 0 - sua aus√™ncia em uma posi√ß√£o espec√≠fica.  Esse modelo √© adequado, simples, intuitivo e permite efetivar as opera√ß√µes de remo√ß√£o de cavacos, al√©m de determinar a condi√ß√£o de "proximidade". <br><br>  Agora que temos um modelo (estrutura de dados), podemos come√ßar a puxar (corujas do mundo) o algoritmo desse modelo.  O algoritmo de enumera√ß√£o completa com retorno √© simples no diagrama de blocos e consiste em duas partes independentes - a enumera√ß√£o e avalia√ß√£o das posi√ß√µes, para come√ßar, implementaremos a primeira parte.  Observe que esse algoritmo n√£o √© melhor implementado dentro da estrutura do paradigma de programa√ß√£o estrutural e seria um pouco mais eficaz se nos permitirmos usar uma transi√ß√£o ou repetir o c√≥digo, mas mesmo sem esses desvios do estilo, a implementa√ß√£o n√£o √© de forma pretensiosa (a complexidade ciclom√°tica √© bastante aceit√°vel) .  Como ainda n√£o introduzimos uma avalia√ß√£o e gostar√≠amos de obter o resultado do programa, simplesmente derivamos as posi√ß√µes em considera√ß√£o e as examinamos com nossos olhos para avaliar a implementa√ß√£o correta e garantir que os resultados correspondam aos esperados. <br><br>  Agora vamos adicionar uma estimativa de posi√ß√£o - √© claro, o c√≥digo bem escrito √© auto-documentado (embora haja opini√µes diferentes sobre essa afirma√ß√£o), mas essa parte √© melhor descrita em palavras.  A id√©ia √© que damos uma avalia√ß√£o inequ√≠voca das posi√ß√µes finais (no nosso caso, √© √∫nica e consiste em zero fichas), com base nas regras do jogo, e para todas as outras posi√ß√µes, damos uma avalia√ß√£o neutra preliminar e depois come√ßamos a refin√°-la, movendo a estimativa para a √°rvore .  Ao retroceder, a estimativa da posi√ß√£o atual muda em um na dire√ß√£o de zero, depois √© invertida e transferida para a posi√ß√£o anterior, onde √© combinada com a estimativa anterior de acordo com as seguintes regras: <br><br><ol><li>  avalia√ß√£o neutra muda para uma nova, </li><li>  uma classifica√ß√£o positiva muda para uma menor positiva, </li><li>  uma avalia√ß√£o negativa muda para uma grande negativa ou positiva. </li></ol><br>  Depois de passarmos por todas as jogadas, a avalia√ß√£o da posi√ß√£o inicial √© final. <br><br>  Adicionamos estimativas ao nosso procedimento para gerar todas as posi√ß√µes e podemos admirar os resultados da an√°lise, exibidos em uma tabela, adicionar um contador de progresso e um contador de tempo para a an√°lise.  No compilador gcc (no modo de otimiza√ß√£o -O2) em uma m√°quina com um processador, recebi uma tabela que confirma totalmente nossas suposi√ß√µes iniciais sobre a ordem fatorial de complexidade da tarefa.  Da mesma tabela, vemos que parei de esperar resultados com H superior a 11, porque o tempo de c√°lculo se tornou inaceit√°vel (para mim, talvez voc√™ esteja pronto para esperar meia hora) e nossa suposi√ß√£o sobre o curso e o nanossegundo n√£o corresponde √† realidade (tempo m√©dio considera√ß√£o da posi√ß√£o √© de 100 segundos).  Surge a pergunta - o que devemos fazer se quisermos ter uma estimativa para mais de 11 fichas na posi√ß√£o inicial. <br><br>  Poder√≠amos pegar o caminho de pequenas otimiza√ß√µes, brincar com transi√ß√µes e sinalizadores, entrar em inser√ß√µes de montador, aplicar opera√ß√µes vetoriais complicadas no sistema de instru√ß√µes do nosso processador e, dessa maneira, voc√™ pode ganhar velocidade sem ambiguidade √†s vezes, por uma ordem de magnitude - talvez duas ordens de magnitude - √© muito improv√°vel, mas precisamos de um ganho de muitas ordens de magnitude, j√° que na ordem (e at√© mais) vamos aumentar um H em um em mais de 10. A prop√≥sito, se voc√™ apenas ativar a otimiza√ß√£o do compilador, isso far√° algo para n√≥s e o tempo de execu√ß√£o diminuir√°  Eu tenho 4 vezes - n√£o √© mau em tudo e em linha com as nossas expectativas. <br><br>  Portanto, devemos primeiro tentar melhorar os algoritmos aplicados, e o primeiro deles (e o principal) aprimoramento √© o m√©todo de for√ßa bruta de corte ou o "procedimento alfa-beta".  Sua id√©ia principal parece bastante robusta e consiste no fato de que se classificarmos uma determinada posi√ß√£o como vencedora, paramos de melhorar a classifica√ß√£o para essa e voltamos √† √°rvore.  Essa abordagem pode aumentar bastante a velocidade do algoritmo, especialmente se investigarmos movimentos bem-sucedidos (levando a uma vit√≥ria) em primeiro lugar.  Mas tamb√©m pode aumentar o tempo, uma vez que a verifica√ß√£o da avalia√ß√£o atual √© adicionada e o procedimento de escolha do curso √© complicado, √© muito dif√≠cil estimar a influ√™ncia desse m√©todo com anteced√™ncia, √© necess√°rio realizar um experimento.  E mais uma considera√ß√£o - n√£o devemos esquecer que, no caso de uma pesquisa com um ponto de corte, no caso de uma posi√ß√£o vencedora, fornecemos uma estimativa verdadeira, mas n√£o precisa, uma vez que n√£o consideramos parte das op√ß√µes e elas poderiam obter uma vit√≥ria em menos movimentos.  Se tal redu√ß√£o na precis√£o nos conv√©m, por que n√£o usar esse m√©todo, mas para uma avalia√ß√£o precisa, nada al√©m de pesquisa exaustiva n√£o funciona. <br><br>  Os resultados da enumera√ß√£o de recorte s√£o mostrados na tabela a seguir e vemos que h√° um ganho de desempenho e um aumento significativo, mas n√£o o suficiente para estudar grandes valores de N. Em que dire√ß√£o continuaremos nossa pesquisa - primeiro, examinaremos outra estrutura de dados, bem, e ent√£o, voc√™ adivinhou (√© bom lidar com um p√∫blico astuto) √© outro algoritmo. <br><br>  Vamos prestar aten√ß√£o ao fato de que a estrutura de dados adotada por n√≥s torna os chips √∫nicos e, por exemplo, um √∫nico chip (n√£o tendo adjacente) na posi√ß√£o n√£o √© equivalente a um √∫nico chip na posi√ß√£o n + 2, o que est√° completamente errado.  Selecionamos o elemento-chave da posi√ß√£o do jogo - o grupo de fichas localizado pr√≥ximo a ele e determinamos sua principal caracter√≠stica - o n√∫mero de fichas no grupo.  S√£o essas informa√ß√µes que determinam exclusivamente qualquer posi√ß√£o no jogo, e devemos apresent√°-las de uma forma conveniente para a programa√ß√£o.  Escolhemos a estrutura de dados mais simples e √≥bvia - iniciamos uma matriz de elementos H e armazenamos no elemento n da matriz o n√∫mero de grupos com exatamente n chips.  Ent√£o, por exemplo.  Para a posi√ß√£o inicial com 3 fichas, teremos a representa√ß√£o {0,0,1}.  O procedimento de execu√ß√£o para a apresenta√ß√£o dada ainda √© simples e eficaz, embora, √© claro, seja mais complicado do que na primeira vers√£o.  Ap√≥s o primeiro movimento (dos quais havia dois em vez de tr√™s), obtemos as posi√ß√µes {0,1,0} e {2,0,0}. <br><br>  Vamos tentar estimar o ganho esperado no n√∫mero de movimentos para uma determinada estrutura de dados.  Para o primeiro movimento, temos (H-1) / 2 + 1 op√ß√µes, para o segundo (dividimos o grupo H em me N-m-1) (m-1) / 2 + (N-m-1-1) / 2 (pegue 1 chip) + (m-2) / 2 + (N-m-1-2) / 2 (pegue 2 chips) = (H-3) / 2 + (H-5) / 2 e por analogia , conclu√≠mos que a cada passo economizamos pelo menos metade dos movimentos.  Ent√£o nosso ganho deve ser de pelo menos 2 ^ H, o que √© muito, muito bom para H. grande  De fato, o ganho ser√° ainda maior, por exemplo, para a posi√ß√£o {8,0 ...} na primeira modalidade, voc√™ precisar√° ordenar 8 movimentos e no segundo apenas 1 e o ganho neste caso ser√° 8 vezes.  Portanto, podemos contar com 2 ^ H, mas esperamos muito mais, o que verificaremos.  E com certeza, para o programa de acordo com essa representa√ß√£o, obtemos a Tabela 4, a √∫ltima linha mostra o ganho de desempenho ao mudar para a segunda vers√£o da estrutura de dados (calculada manualmente).  O crescimento √© simplesmente colossal e, com confian√ßa (chegamos ao fundo), rompemos o limite da possibilidade de an√°lise de at√© 20 chips na posi√ß√£o inicial, a um custo de tempo razo√°vel. <br><br>  Al√©m disso, podemos nos engajar na otimiza√ß√£o sutil do algoritmo para uma dada estrutura de dados e obter um ganho ainda maior no desempenho, mas n√£o obteremos um crescimento t√£o dram√°tico (por ordem de magnitude), o que mais uma vez indica que Wirth estava errado.  Por exemplo, no programa acima, o procedimento para criar o pr√≥ximo candidato para a mudan√ßa n√£o foi deliberadamente ideal e sua corre√ß√£o √≥bvia (vamos deixar para o leitor curioso) aumentar√° a velocidade em 3 vezes, mas isso √© um pouco, embora agrad√°vel. <br><br>  Vamos prestar aten√ß√£o aos resultados e ver algumas coisas n√£o √≥bvias.  Por exemplo, o programa afirma que uma vit√≥ria garantida em um jogo direto por 9 fichas √© alcan√ßada n√£o em 9 jogadas, como segue o algoritmo sim√©trico heur√≠stico, mas em apenas 7, e a primeira jogada coincide com a heur√≠stica (e, al√©m disso, √© a √∫nica posi√ß√£o vencedora ), mas o terceiro e os seguintes n√£o devem repetir os movimentos do oponente, como segue o algoritmo ing√™nuo, e a chave aqui √© {1,0,0,1}, que tem uma classifica√ß√£o de +4.  Agora que fizemos uma avalia√ß√£o precisa do jogo, podemos fazer perguntas interessantes sobre a presen√ßa de posi√ß√µes com uma avalia√ß√£o est√°vel (na qual podemos deixar o oponente ir por n√≥s mesmos), a presen√ßa de posi√ß√µes-chave na √°rvore de enumera√ß√£o, encontrar posi√ß√µes com o √∫nico movimento certo e assim por diante (e at√© obter respostas para essas perguntas e as corretas). <br><br>  Aqui est√° a tabela de notas resumidas <br><table><tbody><tr><th>  Chips </th><th>  Direto </th><th>  Coment√°rios </th><th>  Posi√ß√µes / Tempo </th><th>  Posi√ß√µes / Tempo </th></tr><tr><td>  1 </td><td>  1 </td><td>  -1 </td><td>  1/0 </td><td>  1/0 </td></tr><tr><td>  2 </td><td>  -2 </td><td>  2 </td><td>  4/0 </td><td>  2/0 </td></tr><tr><td>  3 </td><td>  3 </td><td>  -3 </td><td>  17/0 </td><td>  7/0 </td></tr><tr><td>  4 </td><td>  -4 </td><td>  -3 </td><td>  82/0 </td><td>  20/0 </td></tr><tr><td>  5 </td><td>  5 </td><td>  4 </td><td>  463/0 </td><td>  71/0 </td></tr><tr><td>  6 </td><td>  5 </td><td>  -5 </td><td>  3032/0 </td><td>  263/0 </td></tr><tr><td>  7 </td><td>  7 </td><td>  6 </td><td>  22693/0 </td><td>  1107/0 </td></tr><tr><td>  8 </td><td>  -8 </td><td>  -7 </td><td>  191422/0 </td><td>  4945/0 </td></tr><tr><td>  9 </td><td>  7 </td><td>  -7 </td><td>  1798427 / 0.1 </td><td>  24.283 / 0 </td></tr><tr><td>  10 </td><td>  9 </td><td>  8 </td><td>  18634228 / 0.8 </td><td>  125419/0 </td></tr><tr><td>  11 </td><td>  11 </td><td>  -9 </td><td>  211177537 / 10.4 </td><td>  699165 / 0.1 </td></tr><tr><td>  12 </td><td>  -10 </td><td>  -9 </td><td>  *** / 127 </td><td>  4057686 / 0.6 </td></tr><tr><td>  13 </td><td>  11 </td><td>  10 </td><td></td><td>  25056975 / 3,84 </td></tr><tr><td>  14 </td><td>  -12 </td><td>  -11 </td><td></td><td>  160643971/28 </td></tr><tr><td>  15 </td><td>  13 </td><td>  12 </td><td></td><td>  1082854607/213 </td></tr><tr><td>  16 </td><td>  -14 </td><td>  -13 </td><td></td><td>  *** / 1698 </td></tr></tbody></table>  No entanto, vemos que a estimativa do tempo de opera√ß√£o permaneceu fatorial, embora com uma queda significativa na taxa de crescimento.  Vamos procurar outras maneiras de explorar a √°rvore do jogo. <br><br>  Aperfei√ßoamos o algoritmo de cima para baixo (bem, √© claro, n√£o o terminamos na forma feia que eu desenhei na parte de tr√°s do envelope, voc√™ pode melhorar significativamente o desempenho reescrevendo cuidadosamente os procedimentos b√°sicos, e isso certamente ser√° feito, mas o problema n√£o √© fundamental decide), ent√£o vamos para o outro lado - de baixo para cima.  A id√©ia desse m√©todo √© intuitivamente simples e compreens√≠vel, mas muito dif√≠cil para o uso humano - partimos da posi√ß√£o final, que √© estimada de acordo com as regras do jogo, e come√ßamos a transferir a estimativa para a √°rvore de acordo com as mesmas regras da pesquisa de cima para baixo.  √â claro que, ao mesmo tempo, estamos considerando que n√£o s√£o poss√≠veis movimentos para baixo da posi√ß√£o atual, mas estamos considerando todas as posi√ß√µes das quais poder√≠amos entrar na atual em um movimento.  Transferimos a estimativa de acordo com as regras acima.  Al√©m disso, aplicamos esse procedimento iterativamente e quando ele deixa de produzir resultados, ou seja, na pr√≥xima rodada, nenhuma posi√ß√£o mudou a avalia√ß√£o, a tarefa √© conclu√≠da e a avalia√ß√£o da posi√ß√£o inicial √© correta e precisa.  Essa abordagem permite reduzir bastante o tempo de pesquisa, especialmente se voc√™ fizer algumas melhorias, mas possui uma forte desvantagem (e isso √© um cl√°ssico - alteramos o tempo da mem√≥ria), limitando significativamente seu escopo - altos requisitos de mem√≥ria, pois precisamos armazenar estimativas     ,          (     ).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No caso do jogo em quest√£o, o m√©todo de representa√ß√£o de bits para a primeira estrutura de dados sugere a si pr√≥prio, existem outros m√©todos que podem reduzir a quantidade de mem√≥ria necess√°ria (armazenando apenas os tr√™s n√≠veis de √°rvore considerados, com exce√ß√£o da camada inferior), mas, √© claro, degradando o desempenho, pois a pesquisa se torna muito trivial. No entanto, para H n√£o superior a 20, o n√∫mero total de posi√ß√µes n√£o ser√° superior a 2 ^ 20, e uma matriz desse tamanho na mem√≥ria para elementos contendo um n√∫mero de -20 a 20, ou seja, um n√∫mero de 8 bits, sou capaz de imaginar e sua implementa√ß√£o n√£o ser√° dif√≠cil. Portanto, √© poss√≠vel escrever um programa para esse algoritmo e avaliar o desempenho resultante, mas n√£o vamos nos apressar e fazer estimativas. Que tipo de mem√≥ria teremos que alocar n√£o √© dif√≠cil de determinar, mas com par√¢metros tempor√°rios √© um pouco mais complicado.Suponha que criamos imediatamente todas as posi√ß√µes poss√≠veis, elas ser√£o M e, em seguida, o n√∫mero m√©dio de movimentos de uma posi√ß√£o pode ser estimado como n√£o mais de 2 * N (uma estimativa muito aproximada). Ent√£o, a cada itera√ß√£o, precisamos realizar n√£o mais do que transfer√™ncia M * 2 * H da estimativa e, como em cada ciclo melhoraremos a estimativa de pelo menos uma posi√ß√£o, o tempo total de trabalho ser√° da ordem M * 2 * H * M.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, para a primeira maneira de apresentar os dados, obtemos 2 ^ H * M * 2 ^ H = 2 ^ (2 * H) * M (enfatizamos mais uma vez que esta estimativa √© muito forte de cima) e, por exemplo, para H = 20, a estimativa do tempo de pesquisa de cima -down ser√° 20! ~ 10E18, e para a pesquisa de baixo para cima, temos 2 ^ 40 * 20 = (2 ^ 10) ^ 4 * 40 = (10 ^ 3) ^ 4 * 40 ~ 10 ^ 14, ou seja, por 20 chips ganhamos no tempo pelo menos 10E6 vezes, o que √© muito bom. Tamb√©m contaremos para 9 fichas iniciais, obtendo 9! ~ 10E6 para a pesquisa superior e 2 ^ 9 * 2 ^ 9 * 18 ~ 10E6 para a triagem de baixo para cima, ou seja, a partir desse n√∫mero, a pesquisa final ganha. A √∫ltima afirma√ß√£o √© um tanto precipitada, uma vez que o procedimento para avaliar a pr√≥xima posi√ß√£o se tornou significativamente mais longo - teremos que procur√°-la entre as j√° geradas, mas para essa representa√ß√£o espec√≠fica na forma de uma matriz de bits, esse procedimento √© realizado em O (1).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para a segunda apresenta√ß√£o, √© necess√°rio avaliar o n√∫mero de posi√ß√µes diferentes, tarefa do campo da combinat√≥ria. Como exemplo, considere um jogo com 9 fichas iniciais, para o qual o n√∫mero total de posi√ß√µes diferentes ser√°: 1+ (1 + 4) + (1 + 3 + 2) + (1 + 3 + 3 + 2) + (1 + 2 + 2 + 1 + 1) + (1 + 2 + 1 + 1) + (1 + 1 + 1) + (1 + 1) + 1 = 1 + 5 + 6 + 9 + 7 + 5 + 3 + 2 + 1 = 39 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, uma estimativa pelo mesmo m√©todo levar√° ao valor H * M * M = 39 * 39 * 9 ~ 10E4, que √© duas ordens de magnitude com melhor velocidade em compara√ß√£o com a primeira representa√ß√£o e, √† medida que H aumenta, o ganho aumentar√° apenas. Comparado a exagerar na segunda visualiza√ß√£o, voc√™ tamb√©m deve esperar uma melhoria significativa no desempenho, mas √© mais dif√≠cil de avaliar, por isso √© mais f√°cil tentar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, se voc√™ fizer um programa de an√°lise de baixo para cima, fa√ßa a segunda apresenta√ß√£o. N√£o vou dar o programa, preciso deixar algo para os leitores fazerem an√°lises em casa. Devemos obter resultados para H significativo em um tempo bastante razo√°vel. Outra vantagem de rebater a partir de baixo √© que podemos economizar significativamente fixando a estimativa para a metade inferior das posi√ß√µes (que tem um n√∫mero menor de fichas que N / 2), uma vez que a metade inferior estimada √© transferida sem altera√ß√µes para o pr√≥ximo n√∫mero de fichas, o que nos dar√° uma vit√≥ria adicional em 2 vezes.</font></font><br><br><h4>   ‚Äî        ,         ,      .       ,     ,       (    )   . </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, em conclus√£o, a explica√ß√£o necess√°ria para aqueles que levaram meu post muito a s√©rio e queimam com indigna√ß√£o (justa) - n√£o tenho certeza absoluta de que especificar os algoritmos como o primeiro termo na f√≥rmula de defini√ß√£o de programa confirme sua maior import√¢ncia. Concordo plenamente que em algumas situa√ß√µes espec√≠ficas, um algoritmo selecionado corretamente pode dar um aumento ordenado na produtividade, e eu n√£o incriminaria Dijkstra (a quem respeito com respeito) por erros. Era tudo uma frase para atrair aten√ß√£o, e o post √© sobre outra coisa - que a estrutura de dados tamb√©m √© extremamente importante em termos de desempenho e eu queria n√£o ser esquecido disso no processo de design.</font></font><br><br>  PS.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eles me dizem aqui da plat√©ia (oi Max) que existe outro m√©todo de pesquisar o jogo - matem√°tico e, dada a hip√≥tese de sobrenome duplo de que a maioria dos jogos contados se resume ao jogo de Nim, ent√£o s√≥ precisamos calcul√°-lo - a soma a posi√ß√£o inicial (na minha opini√£o, a afirma√ß√£o √© duvidosa) e voc√™ tamb√©m pode converter o jogo original em jogos no gr√°fico (n√£o h√° obje√ß√µes), para os quais voc√™ pode esperar uma estimativa de 1.878 ^ N na hora do trabalho (embora o n√∫mero espec√≠fico tenha me intrigado). </font><font style="vertical-align: inherit;">Provavelmente, essas considera√ß√µes t√™m direito √† vida, pelo menos os artigos deste conte√∫do parecem convincentes, mas sou um praticante puro e deixo essas op√ß√µes novamente para leitores curiosos (ars longa, vita brevis).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O programa est√° oculto aqui</font></font></b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctime&gt; #include "stdio.h" #define MaxMax 17 #define Forward 1 // 1-   0 -  #define Version 1 // 0-   1 -   int hod[MaxMax+1],nf[MaxMax+1],oc[MaxMax+1],sm[MaxMax+1]; int lvl,count,nhod; #if Version==0 int pos[MaxMax+1]; inline void Start(int Max) { for (int i=0; i&lt;Max; i++) oc[i]=0; for (int i=0; i&lt;Max; ++i) pos[i]=1; pos[Max]=0; }; inline void FirstStep(int Max) { hod[lvl]=0; nf[lvl]=1; }; inline int ValidStep() { if ( (pos[hod[lvl]]==1) &amp;&amp; ((nf[lvl]==1) || (pos[hod[lvl]+1]==1)) ) return 1; else return 0; }; inline void MakeStep(void) { pos[hod[lvl]]=0; --count; if (nf[lvl]==2) { pos[hod[lvl]+1]=0; --count; }; }; inline void DownStep(int Max) { ++lvl; oc[lvl]=0; hod[lvl]=-1; nf[lvl]=2; }; inline void RemoveStep(void) { pos[hod[lvl]]=1; ++count; if (nf[lvl]==2) { pos[hod[lvl]+1]=1; ++count; }; }; inline void NextStep(void) { if ((nf[lvl]==1) &amp;&amp; (lvl&gt;0)) nf[lvl]=2; else { ++hod[lvl]; nf[lvl]=1; }; }; inline int LastStep(int Max) {if (hod[lvl]&gt;=Max) return 1; else return 0; }; void print(int Max) { for (int i=0; i&lt;Max; ++i) if (pos[i]==1) printf("*"); else printf("."); for (int i=0; i&lt;Max; ++i) if (i&lt;=lvl) printf ("%2d,%1d",hod[i],nf[i]); else printf(" "); printf("%3d ",count); for (int i=0; i&lt;Max; ++i) printf("%3d",oc[i]); printf("\n"); }; #endif #if Version==1 int gr[MaxMax+1]; inline void Start(int Max) { for (int i=0; i&lt;Max; i++) oc[i]=0; for (int i=0; i&lt;MaxMax; ++i) { gr[i]=0; }; gr[Max]=1; }; inline void FirstStep(int Max) { hod[lvl]=Max; nf[lvl]=1; sm[lvl]=0; }; inline int ValidStep(void) { if ( (gr[hod[lvl]]&gt;0) &amp;&amp; (hod[lvl]&gt;=nf[lvl]) ) return 1; else return 0; }; inline void MakeStep(void) { gr[hod[lvl]]-=1; gr[hod[lvl]-nf[lvl]-sm[lvl]]+=1; if (sm[lvl]&gt;0) gr[sm[lvl]]+=1; count-=nf[lvl]; }; inline void NextStep(void) { sm[lvl]++; if ( sm[lvl]*2 &gt; (hod[lvl]-nf[lvl]) ) { if ( (lvl&gt;0) &amp;&amp; (nf[lvl]==1) ) { nf[lvl]=2; sm[lvl]=0; } else { hod[lvl]-=1; sm[lvl]=0; nf[lvl]=1; }; }; }; inline void DownStep(int Max) { ++lvl; oc[lvl]=0; hod[lvl]=Max; nf[lvl]=1; sm[lvl]=0; }; inline void RemoveStep(void) { if (sm[lvl]&gt;0) gr[sm[lvl]]-=1; gr[hod[lvl]-nf[lvl]-sm[lvl]]-=1; gr[hod[lvl]]+=1; count+=nf[lvl]; }; inline int LastStep(int Max) {if (hod[lvl]&lt;=0) return 1; else return 0; }; void print(int Max) { if (Max==18) { for (int i=1; i&lt;=Max; ++i) printf("%2d,",gr[i]); for (int i=0; i&lt;Max; ++i) if (i&lt;=lvl) printf (" =&gt;%2d:%2d,%1d,%2d",i,hod[i],nf[i],sm[i]); else printf(" "); printf(" %3d:: ",count); for (int i=0; i&lt;Max; ++i) printf("%2d",oc[i]); printf("\n"); }; }; #endif inline void MoveOc(void) { int newoc=-oc[lvl+1]; if (newoc&gt;0) ++newoc; else --newoc; if ( (oc[lvl]==0) || ( (oc[lvl]&lt;0) &amp;&amp; (newoc&gt;0) ) || ( (oc[lvl]&gt;0) &amp;&amp; (newoc&gt;0) &amp;&amp; (newoc&lt;oc[lvl]) ) || ( (oc[lvl]&lt;0) &amp;&amp; (newoc&lt;0) &amp;&amp; (newoc&lt;oc[lvl]) ) ) { oc[lvl]=newoc; // if (oc[0]&gt;0) --ur; }; }; int ocenka(int Max) { Start(Max); count=Max; nhod=0; lvl=0; FirstStep(Max); while (lvl&gt;=0) { //print(Max); if ( ValidStep()==1) { MakeStep(); ++nhod; //print(Max); if (count&gt;0) DownStep(Max); else { #if Forward==1 oc[lvl]=1; #else if (oc[lvl]==0) oc[lvl]=-1; #endif RemoveStep(); }; //print(Max); }; NextStep(); if (LastStep(Max)==1) { --lvl; if (lvl&gt;-1) { MoveOc(); RemoveStep(); NextStep(); }; }; }; return nhod; }; void reverse(void); int main(void) { int last=1; for (int i=1; i&lt;=MaxMax; ++i) { clock_t start_time = clock(); int j=ocenka(i); printf("%2d %3d %12d %5.2f %5.2f\n",i,oc[0],j,(float)j/last,(clock()-start_time)/1000.); last=j; }; return 1; };</span></span></span></span></code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420859/">https://habr.com/ru/post/pt420859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420843/index.html">7 de setembro de Ecaterimburgo - uma reuni√£o para desenvolvedores .NET</a></li>
<li><a href="../pt420845/index.html">Domar os obstinados com o uso de uma muleta: o orif√≠cio do adaptador Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../pt420847/index.html">Introdu√ß√£o √† programa√ß√£o de sombreador para layouts</a></li>
<li><a href="../pt420853/index.html">Conhe√ßa o Pseudo Console do Windows (ConPTY)</a></li>
<li><a href="../pt420857/index.html">Roaming sem fio de Wi-Fi: teoria na pr√°tica</a></li>
<li><a href="../pt420861/index.html">Preparando-se para C ++ 20. Estudo de caso real da Coroutines TS</a></li>
<li><a href="../pt420863/index.html">Como fizemos o primeiro smartphone russo, continuamos</a></li>
<li><a href="../pt420865/index.html">O princ√≠pio da menor a√ß√£o. Parte 1</a></li>
<li><a href="../pt420867/index.html">C√°lculo de integrais definidas: algoritmos b√°sicos</a></li>
<li><a href="../pt420869/index.html">Evacua√ß√£o, HAMR e MAMR - tr√™s maneiras de maximizar a capacidade dos HDDs modernos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>