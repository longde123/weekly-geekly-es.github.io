<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎤 🤠 💒 Memecahkan Teka-Teki Silang Jepang dengan P̶y̶t̶h̶o̶̶n̶ Rust dan WebAssembly 📂 💭 🚼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cara membuat pemecah nonogram untuk Python, tulis ulang ke Rust untuk menjalankannya langsung di peramban melalui WebAssembly. 


 TL; DR 
 Mulai 


 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memecahkan Teka-Teki Silang Jepang dengan P̶y̶t̶h̶o̶̶n̶ Rust dan WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454586/"><p><img src="https://habrastorage.org/webt/sy/k0/va/syk0va4uczwmji3lwzhq2nqq2hy.png" alt="Logo karat sebagai nonogram"></p><br><p>  Cara membuat pemecah nonogram untuk Python, tulis ulang ke Rust untuk menjalankannya langsung di peramban melalui WebAssembly. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TL; DR</a> </p><a name="habracut"></a><br><h2 id="nachalo">  Mulai </h2><br><p>  Tentang teka-teki silang Jepang (nonogram) di Habré sudah ada beberapa pos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh</a> <br>  dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu lagi</a> . </p><br><blockquote>  Gambar dienkripsi dengan angka yang terletak di sebelah kiri baris, serta di atas kolom.  Jumlah angka menunjukkan berapa banyak kelompok sel hitam (atau warnanya, untuk teka-teki silang warna) dalam baris atau kolom yang sesuai, dan angka itu sendiri - berapa banyak sel yang digabungkan yang berisi masing-masing grup ini (misalnya, kumpulan tiga angka - 4, 1, dan 3) berarti bahwa dalam baris ini ada tiga kelompok: yang pertama - dari empat, yang kedua - dari satu, yang ketiga - dari tiga sel hitam).  Dalam teka-teki silang hitam dan putih, grup harus dipisahkan oleh setidaknya satu sel kosong, dalam warna aturan ini hanya berlaku untuk grup satu warna, dan grup multi-warna dapat diberi jarak yang dekat (sel kosong juga dapat berada di sepanjang tepi baris).  Penting untuk menentukan lokasi kelompok sel. </blockquote><p>  Salah satu sudut pandang yang paling umum diterima adalah bahwa teka-teki silang yang "benar" hanya dapat disebut dengan teka-teki yang diselesaikan dengan cara yang "logis".  Ini biasanya disebut metode solusi, di mana ketergantungan antara baris dan / atau kolom yang berbeda tidak diperhitungkan.  Dengan kata lain, solusi adalah urutan keputusan <strong>independen</strong> dari baris atau kolom individu sampai semua sel terisi (lebih lanjut tentang algoritma di bawah).  Misalnya, hanya nonograms yang dapat ditemukan di situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://nonograms.org/</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://nonograms.ru/</a> ).  Nonogram dari situs ini telah dikutip sebagai contoh dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memecahkan Teka-Teki Warna Jepang dengan Kecepatan Cahaya</a> .  Untuk tujuan perbandingan dan verifikasi, pemecah masalah saya juga menambahkan dukungan untuk mengunduh dan mengurai teka-teki silang dari situs ini (terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">KyberPrizrak</a> untuk izin menggunakan bahan dari situsnya). </p><br><p>  Namun, konsep nonograms dapat diperluas ke masalah yang lebih umum, ketika metode "logis" yang biasa mengarah pada jalan buntu.  Dalam kasus seperti itu, kita harus membuat asumsi tentang warna sel dan, setelah membuktikan bahwa warna ini mengarah ke kontradiksi, tandai warna yang berlawanan untuk sel ini.  Urutan langkah-langkah tersebut dapat (jika Anda memiliki kesabaran) memberi kami semua solusi.  Artikel ini terutama membahas penyelesaian kasus teka-teki silang yang lebih umum. </p><br><h2 id="python">  Python </h2><br><p>  Sekitar satu setengah tahun yang lalu, saya tidak sengaja menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> yang menggambarkan metode untuk menyelesaikan satu baris (ternyata kemudian, metode ini agak lambat). </p><br><p>  Ketika saya menerapkan metode ini dalam Python (bahasa kerja utama saya) dan menambahkan pembaruan berurutan dari semua baris, saya melihat bahwa semua ini tidak diselesaikan dengan sangat cepat.  Setelah mempelajari materiil, ternyata pada topik ini ada banyak pekerjaan dan implementasi yang menawarkan pendekatan berbeda untuk tugas ini. </p><br><p>  Tampak bagi saya bahwa pekerjaan yang paling ambisius pada analisis berbagai implementasi solver dilakukan oleh Jan Wolter, menerbitkan di situsnya (yang, sejauh yang saya tahu, tetap menjadi repositori publik terbesar nonograms di Internet), sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">studi terperinci yang</a> berisi banyak informasi dan tautan yang dapat membantu dalam membuat solver Anda sendiri. </p><br><p>  Mempelajari banyak sumber (akan ada di akhir artikel), saya secara bertahap meningkatkan kecepatan dan fungsionalitas pemecah saya.  Sebagai hasilnya, saya kecanduan dan saya terlibat dalam implementasi, refactoring, debugging algoritma selama sekitar 10 bulan di waktu luang dari pekerjaan. </p><br><h3 id="osnovnye-algoritmy">  Algoritma inti </h3><br><p>  Pemecah yang dihasilkan dapat diwakili dalam bentuk empat tingkat keputusan: </p><br><ul><li><p>  ( <strong>line</strong> ) linear solver: pada input, garis sel dan garis deskripsi (petunjuk), pada output, garis yang diselesaikan sebagian.  Dalam solusi python, saya menerapkan 4 algoritma yang berbeda (3 di antaranya diadaptasi untuk teka-teki warna).  Yang tercepat ternyata adalah algoritma BguSolver, dinamai dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber aslinya</a> .  Ini adalah metode yang sangat efektif dan hampir standar untuk menyelesaikan string nonogram menggunakan pemrograman dinamis.  Pseudocode metode ini dapat ditemukan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel ini</a> . </p><br></li><li><p>  ( <strong>propagasi</strong> ) kami menempatkan semua baris dan kolom dalam antrian, melewatinya dengan pemecah linear, ketika kami menerima informasi baru ketika memecahkan baris (kolom), kami memperbarui antrian, masing-masing, dengan kolom baru (baris).  Lanjutkan sampai saluran kosong. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh dan kode</b> <div class="spoiler_text"><p> Kami mengambil tugas selanjutnya untuk menyelesaikan dari antrian.  Biarkan itu menjadi string kosong (tidak terselesaikan) dengan panjang 7 (kami menyatakan sebagai <code>???????</code> ) dengan deskripsi dari blok <code>[2, 3]</code> .  Pemecah linear akan menghasilkan string yang sebagian diselesaikan <code>?X??XX?</code>  di mana <code>X</code> adalah sel yang diisi.  Saat memperbarui baris, kita melihat bahwa kolom dengan angka 1, 4, 5 telah berubah (pengindeksan dimulai pada 0).  Ini berarti bahwa informasi baru telah muncul di kolom yang ditunjukkan dan mereka dapat dikembalikan ke pemecah "linear".  Kami menempatkan kolom-kolom ini dalam antrian tugas-tugas dengan prioritas lebih tinggi (untuk memberikannya kepada pemecah linear berikutnya). </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">propagation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(board)</span></span></span><span class="hljs-function">:</span></span> line_jobs = PriorityDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.height): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, row_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> column_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.width): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, column_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (is_column, index), priority <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> line_jobs.sorted_iter(): new_jobs = solve_and_update(board, index, is_column) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> new_job <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_jobs: <span class="hljs-comment"><span class="hljs-comment"># upgrade priority new_priority = priority - 1 line_jobs[new_job] = new_priority def solve_and_update(board, index, is_column): if is_column: row_desc = board.columns_descriptions[index] row = tuple(board.get_column(index)) else: row_desc = board.rows_descriptions[index] row = tuple(board.get_row(index)) updated = line_solver(row_desc, row) if row != updated: for i, (pre, post) in enumerate(zip(row, updated)): if _is_pixel_updated(pre, post): yield (not is_column, i) if is_column: board.set_column(index, updated) else: board.set_row(index, updated)</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  ( <strong>menyelidiki</strong> ) untuk setiap sel yang belum terselesaikan, kami memilah-milah semua pilihan warna dan mencoba menyebarkan dengan informasi baru ini.  Jika kita mendapat kontradiksi, kita membuang warna ini dari opsi warna untuk sel dan mencoba mengambil manfaat darinya lagi menggunakan propagasi.  Jika diselesaikan hingga akhir, kami menambahkan solusi ke daftar solusi, tetapi terus bereksperimen dengan warna lain (mungkin ada beberapa solusi).  Jika kita sampai pada situasi di mana tidak mungkin untuk diselesaikan lebih lanjut, kita cukup mengabaikan dan mengulangi prosedur dengan warna / sel yang berbeda. </p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><p>  Pengembalian Benar jika kontradiksi diterima sebagai hasil dari sampel. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cell_state)</span></span></span><span class="hljs-function">:</span></span> board = self.board pos, assumption = cell_state.position, cell_state.color <span class="hljs-comment"><span class="hljs-comment"># already solved if board.is_cell_solved(pos): return False if assumption not in board.cell_colors(pos): LOG.warning("The probe is useless: color '%s' already unset", assumption) return False save = board.make_snapshot() try: board.set_color(cell_state) propagation( board, row_indexes=(cell_state.row_index,), column_indexes=(cell_state.column_index,)) except NonogramError: LOG.debug('Contradiction', exc_info=True) # rollback solved cells board.restore(save) else: if board.is_solved_full: self._add_solution() board.restore(save) return False LOG.info('Found contradiction at (%i, %i)', *pos) try: board.unset_color(cell_state) except ValueError as ex: raise NonogramError(str(ex)) propagation( board, row_indexes=(pos.row_index,), column_indexes=(pos.column_index,)) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  ( <strong>mundur</strong> ) jika selama penyelidikan Anda tidak mengabaikan teka-teki yang sebagian terpecahkan, tetapi terus menggunakan prosedur yang sama secara rekursif, kami mendapatkan pengulangan (dengan kata lain, berjalan lengkap ke kedalaman pohon keputusan potensial).  Di sini, peran besar mulai dimainkan, sel mana yang akan dipilih sebagai perpanjangan selanjutnya dari solusi potensial.  Penelitian yang baik tentang topik ini ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di publikasi ini</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><p>  Mundur dengan saya cukup berantakan, tetapi dua fungsi ini menggambarkan kira-kira apa yang terjadi selama pencarian rekursif </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, search_directions, path=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Return False if the given path is a dead end (no solutions can be found) """</span></span> board = self.board depth = len(path) save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> search_directions: state = search_directions.popleft() assumption, pos = state.color, state.position cell_colors = board.cell_colors(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> assumption <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cell_colors: LOG.warning(<span class="hljs-string"><span class="hljs-string">"The assumption '%s' is already expired. "</span></span> <span class="hljs-string"><span class="hljs-string">"Possible colors for %s are %s"</span></span>, assumption, pos, cell_colors) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(cell_colors) == <span class="hljs-number"><span class="hljs-number">1</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Only one color for cell %r left: %s. Solve it unconditionally'</span></span>, pos, assumption) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> NonogramError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The path %s is invalid"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The only color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> rate = board.solution_rate guess_save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Trying state: %s (depth=%d, rate=%.4f, previous=%s)'</span></span>, state, depth, rate, path) success = self._try_state(state, path) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: board.restore(guess_save) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> success: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning( <span class="hljs-string"><span class="hljs-string">"Unset the color %s for cell '%s'. Solve it unconditionally"</span></span>, assumption, pos) board.unset_color(state) self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The whole branch (depth=%d) is invalid. "</span></span>, assumption, pos, depth) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The negation of color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: <span class="hljs-comment"><span class="hljs-comment"># do not restore the solved cells on a root path - they are really solved! if path: board.restore(save) return True def _try_state(self, state, path): board = self.board full_path = path + (state,) probe_jobs = self._get_all_unsolved_jobs(board) try: # update with more prioritized cells for new_job, priority in self._set_guess(state): probe_jobs[new_job] = priority __, best_candidates = self._solve_jobs(probe_jobs) except NonogramError as ex: LOG.warning('Dead end found (%s): %s', full_path[-1], str(ex)) return False rate = board.solution_rate LOG.info('Reached rate %.4f on %s path', rate, full_path) if rate == 1: return True cells_left = round((1 - rate) * board.width * board.height) LOG.info('Unsolved cells left: %d', cells_left) if best_candidates: return self.search(best_candidates, path=full_path) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><p>  Jadi, kami mulai memecahkan teka-teki silang kami dari tingkat kedua (yang pertama hanya cocok untuk kasus degenerasi, ketika di seluruh teka-teki silang hanya ada satu baris atau kolom) dan secara bertahap naik ke atas tingkat.  Seperti yang Anda tebak, setiap level menyebabkan level yang mendasari beberapa kali, jadi untuk solusi yang efektif sangat penting untuk memiliki level pertama dan kedua yang cepat, yang dapat dipanggil jutaan kali untuk teka-teki kompleks. </p><br><p>  Pada tahap ini, ternyata (agak diharapkan) bahwa python sama sekali bukan alat yang cocok untuk kinerja maksimum dalam tugas intensif CPU: semua perhitungan di dalamnya sangat tidak efisien dibandingkan dengan bahasa tingkat rendah.  Sebagai contoh, pemecah BGU yang paling algoritmik (di Jawa), menurut hasil pengukuran, ternyata 7-17 (kadang-kadang hingga 27) kali lebih cepat pada berbagai tugas. </p><br><div class="spoiler">  <b class="spoiler_title">Lebih detail</b> <div class="spoiler_text"><pre>         pynogram_my BGU_my speedup
 Dancer 0,976 0,141 6,921986      
 Cat 1.064 0.110 9.672727      
 Skid 1.084 0.101 10.732673     
 Bucks 1,116 0,118 9,457627      
 Edge 1,208 0,094 12,851064     
 Asap 1.464 0.120 12.200000     
 Simpul 1,332 0,140 9,514286      
 Ayunkan 1,784 0,138 12,927536     
 Ibu 2.108 0,147 14,340136     
 DiCap 2.076 0.176 11.795455     
 Tragis 2,368 0,265 8,935849      
 Merka 2.084 0.196 10.632653     
 Petro 2.948 0.219 13.461187     
 M&amp;M 3.588 0,375 9,568000      
 Ditandatangani 4.068 0,242 16,809917     
 Cahaya 3,848 0,488 7,885246      
 Selamanya 111.000 13.570 8.179808  
 Center 5.700 0.327 17.431193     
 Panas 3.150 0.278 11.330935     
 Karate 2.500 0,219 11,415525     
 9-Dom 510.000 70.416 7.242672      
 Bendera 149.000 5.628 26.474769     
 Singa 71.000 2.895 24.525043     
 Marley 12.108 4.405 2.748695      
 Hal 321.000 46.166 6.953169      
 Inf alam 433.138 inf     
 Tambah inf NaN      
 Gettys inf inf NaN      
</pre><br><p>  Pengukuran dilakukan pada mobil saya, teka-teki diambil dari set standar yang digunakan Jan Wolter dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perbandingannya</a> </p></div></div><br><p>  Dan ini sudah setelah saya mulai menggunakan PyPy, dan pada CPython standar waktu perhitungan lebih lama dari pada PyPy 4-5 kali!  Kita dapat mengatakan bahwa kinerja pemecah Java yang serupa ternyata 28-85 kali lebih tinggi daripada kode CPython. </p><br><p>  Upaya untuk meningkatkan kinerja solver saya menggunakan profil (cProfile, SnakeViz, line_profiler) menyebabkan beberapa percepatan, tetapi tentu saja mereka tidak memberikan hasil yang luar biasa. </p><br><h3 id="itogihttpsgithubcomtsionyxpynogram">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ringkasan</a> : </h3><br><p>  <strong>+</strong> pemecah dapat menyelesaikan semua teka-teki dari situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://webpbn.com</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://nonograms.org</a> dan formatnya sendiri (berbasis-berbasis) </p><br><p>  <strong>+</strong> memecahkan nonograms hitam-putih dan warna dengan jumlah warna apa pun (jumlah warna maksimum yang dipenuhi adalah 10) </p><br><p>  <strong>+</strong> memecahkan teka-teki dengan ukuran blok yang hilang (blotted).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh dari teka-teki seperti itu</a> . </p><br><p>  <strong>+</strong> dapat membuat teka-teki ke konsol / ke kutukan / jendela di browser (saat memasang opsi <em>pynogram-web</em> tambahan).  Untuk semua mode, melihat progres solusi secara real time didukung. </p><br><p>  <strong>-</strong> perhitungan lambat (dibandingkan dengan implementasi yang dijelaskan dalam artikel-perbandingan pemecah, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel</a> ). </p><br><p>  <strong>-</strong> backtracking yang tidak efisien: beberapa puzzle dapat dipecahkan berjam-jam (ketika pohon keputusan sangat besar). </p><br><h2 id="rust">  Karat </h2><br><p>  Pada awal tahun, saya mulai belajar Rust.  Saya mulai, seperti biasa, dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Book</a> , belajar tentang WASM, mempelajari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial yang diajukan</a> .  Namun, saya menginginkan beberapa tugas nyata di mana Anda dapat terlibat dalam kekuatan bahasa (terutama kinerja supernya), dan bukan beberapa contoh yang ditemukan oleh seseorang.  Jadi saya kembali ke nonogram.  Tapi sekarang saya sudah memiliki versi yang berfungsi dari semua algoritma di Python, diserahkan kepada "hanya" menulis ulang. </p><br><p>  Berita baik itu menantikan saya dari awal: ternyata Rust, dengan sistem tipenya, dengan sempurna menggambarkan struktur data untuk tugas saya.  Misalnya, salah satu korespondensi dasar <em>BinaryColor + BinaryBlock</em> / <em>MultiColor + ColoredBlock</em> memungkinkan <em>Anda</em> untuk memisahkan <em>non</em> -hitam-putih dan warna secara permanen.  Jika di suatu tempat dalam kode kami mencoba untuk menyelesaikan string berwarna menggunakan blok deskripsi biner biasa, kami mendapatkan kesalahan kompilasi tentang tipe mismatch. </p><br><div class="spoiler">  <b class="spoiler_title">Tipe dasar terlihat seperti ini</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blank</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_solved</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solution_rate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_updated_with</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, new: &amp;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">variants</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_color_id</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_color_ids</span></span></span></span>(ids: &amp;[ColorId]) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span>: Color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_str_and_color</span></span></span></span>(s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = s.parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;().expect(<span class="hljs-string"><span class="hljs-string">"Non-integer block size given"</span></span>); Self::from_size_and_color(size, color) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_size_and_color</span></span></span></span>(size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">color</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::Color; } <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, PartialEq, Eq, Hash, Clone)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Description</span></span></span></span>&lt;T: Block&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: Block, { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;T&gt;, } <span class="hljs-comment"><span class="hljs-comment">// for black-and-white puzzles #[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd)] pub enum BinaryColor { Undefined, White, Black, BlackOrWhite, } impl Color for BinaryColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct BinaryBlock(pub usize); impl Block for BinaryBlock { type Color = BinaryColor; // omitted } // for multicolor puzzles #[derive(Debug, PartialEq, Eq, Hash, Default, Copy, Clone, PartialOrd, Ord)] pub struct MultiColor(pub ColorId); impl Color for MultiColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct ColoredBlock { size: usize, color: ColorId, } impl Block for ColoredBlock { type Color = MultiColor; // omitted }</span></span></code> </pre> </div></div><br><p>  Saat porting kode, beberapa titik dengan jelas menunjukkan bahwa bahasa yang diketik secara statis seperti Rust (well, atau, misalnya, C ++) lebih cocok untuk tugas ini.  Lebih tepatnya, generik dan sifat menggambarkan domain lebih baik daripada hierarki kelas.  Jadi dalam kode Python, saya punya dua kelas untuk <code>BguSolver</code> linear, <code>BguSolver</code> dan <code>BguColoredSolver</code> yang masing-masing memecahkan garis hitam-putih dan garis warna.  Dalam kode Rust, saya masih memiliki satu-satunya <code>struct DynamicSolver&lt;B: Block, S = &lt;B as Block&gt;::Color&gt;</code> generik <code>struct DynamicSolver&lt;B: Block, S = &lt;B as Block&gt;::Color&gt;</code> struktur, yang dapat menyelesaikan kedua jenis tugas, tergantung pada jenis yang diteruskan selama pembuatan ( <code>DynamicSolver&lt;BinaryBlock&gt;, DynamicSolver&lt;ColoredBlock&gt;</code> ).  Ini, tentu saja, tidak berarti bahwa sesuatu yang serupa tidak dapat dilakukan dengan Python, hanya dalam sistem tipe Rust jelas menunjukkan kepada saya bahwa jika Anda tidak pergi dengan cara ini, Anda harus menulis satu ton kode berulang. </p><br><p>  Selain itu, siapa pun yang mencoba menulis di Rust, tidak diragukan lagi memperhatikan efek "kepercayaan" pada kompiler, ketika proses penulisan kode turun ke algoritma pseudo-meta berikut: </p><br><pre> write_initial_code
 while (compiler_hints = $ (cek kargo))! = 0;  lakukan
     fix_errors (compiler_hints)
 akhir
</pre><br><p>  Ketika kompiler berhenti mengeluarkan kesalahan dan peringatan, kode Anda akan konsisten dengan sistem tipe dan pemeriksa pinjaman dan Anda akan memberi peringatan sebelumnya tentang adanya bug potensial (tentu saja, tergantung pada desain tipe data yang cermat). </p><br><p>  Saya akan memberikan beberapa contoh fungsi yang menunjukkan betapa ringkasnya kode Rust (dibandingkan dengan rekan-rekan Python). </p><br><div class="spoiler">  <b class="spoiler_title">unsolved_neighbours</b> <div class="spoiler_text"><p>  Memberikan daftar "tetangga" yang tidak terselesaikan untuk titik tertentu (x, y) </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, position)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.neighbours(position): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.is_cell_solved(*pos): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> pos</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, point: &amp;Point) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item = Point&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'_</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.neighbours(&amp;point) .into_iter() .filter(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |n| !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cell(n).is_solved()) }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">partial_sums</b> <div class="spoiler_text"><p>  Untuk satu set blok yang menggambarkan satu garis, berikan jumlah parsial (dengan memperhitungkan celah yang diperlukan di antara blok-blok) .Indeks yang dihasilkan akan menunjukkan posisi minimum di mana blok dapat berakhir (informasi ini digunakan kemudian untuk pemecah linier). </p><br><p>  Sebagai contoh, untuk seperangkat blok <code>[2, 3, 1]</code> kita miliki pada output <code>[2, 6, 8]</code> , yang berarti bahwa blok pertama dapat secara maksimal digeser ke kiri sehingga tepi kanannya menempati sel ke-2, sama dengan sisanya. blok: </p><br><pre>             1 2 3 4 5 6 7 8 9 
             _ _ _ _ _ _ _ _ _ _
      2 3 1 | _ | _ | _ | _ | _ | _ | _ | _ | 
               ^ ^ ^
               |  |  |
 akhir 1 blok |  |  | 
 akhir blok 2 -------- |
 akhir blok 3 ------------
</pre><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@expand_generator def partial_sums(blocks): if not blocks: return sum_so_far = blocks[0] yield sum_so_far for block in blocks[1:]: sum_so_far += block + 1 yield sum_so_far</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partial_sums</span></span></span></span>(desc: &amp;[<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { desc.iter() .scan(<span class="hljs-literal"><span class="hljs-literal">None</span></span>, |prev, block| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> current = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> prev_size) = prev { prev_size + block.<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { block.<span class="hljs-number"><span class="hljs-number">0</span></span> }; *prev = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(current); *prev }) .collect() }</code> </pre> </div></div><br><p>  Saat porting, saya membuat beberapa perubahan </p><br><ul><li>  core solver (algoritma) mengalami perubahan kecil (terutama untuk mendukung tipe generik untuk sel dan blok) </li><li>  meninggalkan satu-satunya algoritma (tercepat) untuk pemecah linear </li><li>  alih-alih format ini, memperkenalkan format TOML yang sedikit dimodifikasi </li><li>  tidak menambahkan dukungan untuk teka-teki silang blotted, karena, sebenarnya, ini adalah kelas tugas yang berbeda </li><li><p>  meninggalkan satu-satunya cara untuk output - hanya untuk konsol, tetapi sekarang sel-sel berwarna di konsol ditarik benar-benar berwarna (berkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peti ini</a> ) </p><br><div class="spoiler">  <b class="spoiler_title">seperti itu</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xm/fd/ez/xmfdezlfahkoksuj3h0djom3p9k.png" alt="Jack sparrow"></p><br></div></div><br></li></ul><br><h3 id="poleznye-instrumenty">  Alat yang berguna </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Clippy</a> adalah penganalisa statis standar yang kadang-kadang bahkan dapat memberikan tips sedikit meningkatkan kinerja kode. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">valgrind</a> adalah alat untuk analisis aplikasi dinamis.  Saya menggunakannya sebagai profiler untuk mencari botneks ( <code>valrgind --tool=callgrind</code> ) dan khususnya bagian kode yang <code>valrgind --tool=massif</code> memori ( <code>valrgind --tool=massif</code> ).  Kiat: atur <em>[profile.release] debug = true</em> ke Cargo.toml sebelum memulai profiler.  Ini akan meninggalkan karakter debug di executable. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kcachegrind</a> untuk melihat file callgrind.  Alat yang sangat berguna untuk menemukan tempat yang paling bermasalah dalam hal kinerja. </li></ul><br><h3 id="proizvoditelnost">  Performa </h3><br><p>  Itu untuk apa penulisan ulang pada Rust dimulai.  Kami mengambil teka-teki silang dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel perbandingan yang</a> telah disebutkan dan menjalankannya melalui pemecah terbaik yang dijelaskan dalam artikel asli.  Hasil dan deskripsi jalan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Kami mengambil <a href="">file yang</a> dihasilkan dan membangun beberapa grafik di atasnya. Karena waktu solusi bervariasi dari milidetik hingga puluhan menit, grafik dibuat dengan skala logaritmik. </p><br><div class="spoiler">  <b class="spoiler_title">dijalankan di laptop jupyter</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt %matplotlib inline <span class="hljs-comment"><span class="hljs-comment"># strip the spaces df = pd.read_csv('perf.csv', skipinitialspace=True) df.columns = df.columns.str.strip() df['name'] = df['name'].str.strip() # convert to numeric df = df.replace('\+\ *', np.inf, regex=True) ALL_SOLVERS = list(df.columns[3:]) df.loc[:,ALL_SOLVERS] = df.loc[:,ALL_SOLVERS].apply(pd.to_numeric) # it cannot be a total zero df = df.replace(0, 0.001) #df.set_index('name', inplace=True) SURVEY_SOLVERS = [s for s in ALL_SOLVERS if not s.endswith('_my')] MY_MACHINE_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] in SURVEY_SOLVERS] MY_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] not in SURVEY_SOLVERS] bar_width = 0.17 df_compare = df.replace(np.inf, 10000, regex=True) plt.rcParams.update({'font.size': 20}) def compare(first, others): bars = [first] + list(others) index = np.arange(len(df)) fig, ax = plt.subplots(figsize=(30,10)) df_compare.sort_values(first, inplace=True) for i, column in enumerate(bars): ax.bar(index + bar_width*i, df_compare[column], bar_width, label=column[:-3]) ax.set_xlabel("puzzles") ax.set_ylabel("Time, s (log)") ax.set_title("Compare '{}' with others (lower is better)".format(first[:-3])) ax.set_xticks(index + bar_width / 2) ax.set_xticklabels("#" + df_compare['ID'].astype(str) + ": " + df_compare['name'].astype(str)) ax.legend() plt.yscale('log') plt.xticks(rotation=90) plt.show() fig.savefig(first[:-3] + '.png', bbox_inches='tight') for my in MY_SOLVERS: compare(my, MY_MACHINE_SOLVERS) compare(MY_SOLVERS[0], MY_SOLVERS[1:])</span></span></code> </pre> </div></div><br><h5 id="python-solver">  pemecah python </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/si/qb/5o/siqb5ohxk_bjjaulmkohy1uhzkw.png" alt="kinerja-pynogram"><br></a> <br>  ( <em>gambar dapat diklik</em> ) </p><br><p>  Kita melihat bahwa <em>pynogram di</em> sini lebih lambat dari semua pemecah yang disajikan.  Satu-satunya pengecualian untuk aturan ini adalah pemecah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tamura / Copris</a> berdasarkan SAT, yang memecahkan teka-teki paling sederhana (bagian kiri grafik) lebih lama dari kita.  Namun, ini adalah fitur SAT-solver: mereka dirancang untuk teka-teki silang super kompleks di mana solver biasa terjebak dalam backtracking untuk waktu yang lama.  Ini terlihat jelas di sisi kanan grafik, di mana <em>Tamura / Copris</em> memecahkan teka-teki paling sulit puluhan dan ratusan kali lebih cepat daripada yang lainnya. </p><br><h5 id="rust-solver">  pemecah karat </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/bh/be/cb/bhbecb0ccinpwfhysauyjkrcx24.png" alt="nonogrid-kinerja"><br></a> <br>  ( <em>gambar dapat diklik</em> ) </p><br><p>  Grafik ini menunjukkan bahwa <em>nonogrid</em> pada tugas-tugas sederhana juga mengatasi atau sedikit lebih buruk daripada pemecah kinerja tinggi yang ditulis dalam C dan C ++ ( <em>Wolter</em> dan <em>Syromolotov</em> ).  Dengan kerumitan tugas, pemecah kami kira-kira mengulangi lintasan pemecah <em>BGU</em> (Jawa), tetapi hampir selalu di depannya dengan sekitar urutan besarnya.  Pada tugas yang paling sulit, <em>Tamura / Copris</em> selalu di depan semua orang. </p><br><h5 id="rust-vs-python">  karat vs python </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/ih/0b/2r/ih0b2rnmyk5o_rpgckz_5hkkifc.png" alt="kinerja py-vs-karat"><br></a> <br>  ( <em>gambar dapat diklik</em> ) </p><br><p>  Dan akhirnya, perbandingan dua pemecah kami yang dijelaskan di sini.  Dapat dilihat bahwa solver Rust hampir selalu adalah 1-3 urutan besarnya di depan solver python. </p><br><h3 id="itogihttpsgithubcomtsionyxnonogrid">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ringkasan</a> : </h3><br><p>  <strong>+</strong> solver dapat menyelesaikan semua teka-teki dari situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://webpbn.com</a> (kecuali blotted - dengan ukuran blok yang sebagian tersembunyi), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://nonograms.org</a> dan formatnya sendiri (berbasis TOML) </p><br><p>  <strong>+</strong> Memecahkan nonograms hitam dan putih dan warna dengan sejumlah warna </p><br><p>  <strong>+</strong> dapat membuat teka-teki ke konsol (warna c webpbn.com menarik warna asli) </p><br><p>  <strong>+</strong> bekerja cepat (dibandingkan dengan implementasi yang dijelaskan dalam artikel-perbandingan pemecah, lihat tabel). </p><br><p>  <strong>-</strong> Mundur tetap tidak efektif, seperti dalam solusi Python: beberapa teka-teki (misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, 20x20 tidak berbahaya</a> ) dapat diselesaikan selama berjam-jam (ketika pohon keputusan sangat besar).  Mungkin alih-alih mundur, ada baiknya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemecah SAT yang</a> telah disebutkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hub</a>  Benar, satu-satunya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemecah SAT yang</a> saya temukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Rust</a> pada pandangan pertama tampaknya belum selesai dan ditinggalkan. </p><br><h2 id="webassembly">  Perakitan web </h2><br><p>  Jadi, menulis ulang kode di Rust telah terbayar: pemecah masalah menjadi jauh lebih cepat.  Namun, Rust menawarkan kepada kami fitur keren lainnya: kompilasi di WebAssembly dan kemampuan untuk menjalankan kode Anda langsung di browser. </p><br><p>  Untuk mengimplementasikan fitur ini, ada alat khusus untuk Rust yang menyediakan pengikat yang diperlukan dan menghasilkan <em>pelat ketel</em> untuk Anda tanpa <em>kesulitan</em> menjalankan fungsi Rust dalam kode JS - <em>paket wasm</em> ini (+ <em>wasm-bindgen</em> ).  Sebagian besar pekerjaan dengan itu dan alat penting lainnya sudah dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial Karat dan WebAssembly</a> .  Namun, ada beberapa poin yang harus saya pikirkan sendiri: </p><br><ul><li><p>  saat membaca, itu menciptakan perasaan bahwa tutorial ini terutama ditulis untuk pengembang JS yang ingin mempercepat kodenya dengan Rust.  Ya, atau setidaknya untuk seseorang yang terbiasa dengan <em>npm</em> .  Bagi saya, sebagai orang yang jauh dari ujung depan, itu mengejutkan untuk menemukan bahwa bahkan contoh standar dari buku tidak ingin bekerja dengan server web pihak ketiga yang berbeda dari <code>npm run start</code> . </p><br><p>  Untungnya, wasm-pack memiliki mode yang memungkinkan Anda untuk menghasilkan kode JS biasa (yang bukan modul npm).  <code>wasm-pack build --target no-modules --no-typescript</code> pada output hanya akan menghasilkan dua file: <em>project-name.wasm</em> - biner dari kode Rust yang dikompilasi ke dalam WebAssembly dan <em>project-name.js</em> .  File terakhir dapat ditambahkan ke halaman HTML apa saja <code>&lt;script src="project-name.js"&gt;&lt;/script&gt;</code> dan gunakan fungsi WASM tanpa mengganggu npm, webpack, ES6, modul, dan kesenangan lain dari pengembang JS modern.  Mode <code>no-modules</code> ideal untuk pengembang non-front-end selama pengembangan aplikasi WASM, serta untuk contoh dan demo, karena tidak memerlukan infrastruktur front-end tambahan. </p><br></li><li><p>  WebAssembly baik untuk tugas-tugas yang terlalu berat untuk JavaScript.  Pertama-tama, ini adalah tugas yang melakukan banyak perhitungan.  Dan jika demikian, tugas seperti itu dapat dilakukan untuk waktu yang lama bahkan dengan WebAssembly dan dengan demikian melanggar prinsip asinkron dari web modern.  Saya berbicara tentang semua jenis <em>Peringatan: Skrip tidak responsif</em> yang kebetulan saya amati ketika pemecah saya bekerja.  Untuk mengatasi masalah ini, Anda dapat menggunakan mekanisme <em>pekerja Web</em> .  Dalam kasus ini, skema untuk bekerja dengan fungsi WASM "berat" mungkin terlihat seperti ini: </p><br><ol><li>  dari skrip utama untuk suatu acara (misalnya, mengklik tombol) mengirim pesan ke pekerja dengan tugas meluncurkan fungsi yang berat. </li><li>   ,        . </li><li>      -   () </li></ol><br></li></ul><br><p>   WASM-         JS,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  WASM</a> .      -   (       ),     <code>HashMap</code>       ,     .    ( JS)    ,          /   . </p><br><p>       ,  <a href="">  Mutex</a> ,        thread-safe.       smart-    .   thread-safe     <em>Rc</em>  <em>Arc</em>  <em>RefCell</em>  <em>RwLock</em> .         :         30%.         <code>--features=threaded</code>      thread-safe ,     WASM-. </p><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6574</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8098</a>    (     10 ): </p><br><div class="scrollable-table"><table><thead><tr><th> id </th><th> non-thread-safe </th><th> thread-safe </th><th> web-interface </th></tr></thead><tbody><tr><td> 6574 </td><td> 5.4 </td><td> 7.4 </td><td> 9.2 </td></tr><tr><td> 8098 </td><td> 21.5 </td><td> 28.4 </td><td> 29.9 </td></tr></tbody></table></div><br><p> ,   -    40..70% ,       ,      (32..37%)      thread-safe  ( <code>cargo build --release --features=threaded</code> ). </p><br><p>    Firefox 67.0  Chromium 74.0. </p><br><p> WASM-   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ).            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://webpbn.com/</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.nonograms.org/</a> </p><br><h3 id="todo"> TODO </h3><br><ul><li><p> ""  /,  /    . </p><br></li><li><p>     ,     .      "" ,    ,        .      . </p><br></li><li><p>     (    ,      3600 ).  WASM     ,     (  ,   (!) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,   ,     WASM). ,  , -  ,       nonogrid  . </p><br></li><li><p>   .      : ,       ,      WASM   .    ,         ( )    ,    JS  ,      . </p><br></li><li><p>     JS.         backtrace,       . </p><br></li><li><p>        (     <a href="">TOML-</a> ) </p><br></li></ul><br><h2 id="itogi">  Ringkasan </h2><br><ul><li><p>           ,    (, , etc). </p><br></li><li><p>   Rust  1-3     PyPy       1.5-2  (  ). </p><br></li><li><p>    Python  Rust  ,            Python (, , comprehensions),      Rust-. </p><br></li><li><p>   Rust  WebAssembly   .     Rust ,   WASM,      (     1.5  ). </p><br></li></ul><br><h2 id="osnovnye-istochniki">   </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The 'pbnsolve' Paint-by-Number Puzzle Solver by Jan Wolter</a> and the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">survey</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The BGU Nonograms Project</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solving Nonograms by combining relaxations</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">An Efficient Approach to Solving Nonograms</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">      </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Color and black and white Japanese crosswords on-line</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">      </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">'Nonolib' library by Dr. Steven Simpson</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rust and WebAssembly</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454586/">https://habr.com/ru/post/id454586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454574/index.html">Pembelajaran mesin dalam keuangan mikro: membangun model penilaian untuk klien dengan sejarah kredit yang kosong</a></li>
<li><a href="../id454576/index.html">Penulis GandCrab berhenti bekerja: mereka mengklaim telah cukup mencuri</a></li>
<li><a href="../id454578/index.html">Bagaimana menghubungkan galeri PhotoSwipe di tampilan web android</a></li>
<li><a href="../id454582/index.html">Haruskah panjang array disimpan ke variabel lokal di C #?</a></li>
<li><a href="../id454584/index.html">Sekolah pengembangan antarmuka: analisis tugas untuk Minsk dan perangkat baru di Moskow</a></li>
<li><a href="../id454588/index.html">Gazprom Neft mengundang Anda untuk mengunjungi: GPN Data Science Meetup</a></li>
<li><a href="../id454590/index.html">Zimbra Collaboration Suite dan Kontrol Seluler dengan ABQ</a></li>
<li><a href="../id454592/index.html">WAF melalui mata para peretas</a></li>
<li><a href="../id454596/index.html">Model mental dalam keamanan informasi</a></li>
<li><a href="../id454598/index.html">Arsitektur tanpa server dan layanan mikro: pasangan sempurna?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>