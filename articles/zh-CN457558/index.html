<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💔 🏧 ⛎ EvilParcel漏洞分析 💃🏼 👩🏾‍⚕️ 🤶🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 
 4月中旬，我们发布了有关Android.InfectionAds.1木马的新闻 ，该木马利用了Android OS中的几个关键漏洞。 其中之一-CVE-2017-13156（也称为Janus ）-允许恶意程序感染APK文件而不会破坏其数字签名。 

 另一个是CVE-2017-13315。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EvilParcel漏洞分析</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/drweb/blog/457558/"><h3> 引言 </h3><br>  4月中旬，我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布了</a>有关<b>Android.InfectionAds.1</b>木马的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新闻</a> ，该木马利用了Android OS中的几个关键漏洞。 其中之一-CVE-2017-13156（也称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Janus</a> ）-允许恶意程序感染APK文件而不会破坏其数字签名。 <br><br> 另一个是CVE-2017-13315。 它赋予Trojan高级特权，并且可以独立安装和卸载应用程序。 我们的病毒库中提供了对<b>Android.InfectionAds.1</b>的详细分析，可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到。 我们将更详细地介绍漏洞CVE-2017-13315，看看它是什么。 <br><a name="habracut"></a><br>  CVE-2017-13315属于漏洞组，其通用名称为EvilParcel。 它们可以在Android OS的各种系统类中找到。 由于在应用程序和系统之间交换数据时后者中的错误，因此可以替换此数据。 利用EvilParcel漏洞的恶意程序将获得更高的特权，并且可以在他们的帮助下执行以下操作： <br><br><ul><li> 未经用户确认，以任何权限安装和卸载应用程序； </li><li> 与其他漏洞一起使用时，请感染设备上已安装的程序，并用受感染的副本替换“干净”的原件； </li><li> 重置Android设备的屏幕锁定代码 </li><li> 重置Android设备锁定屏幕PIN。 </li></ul><br> 当前有7种此类已知漏洞： <br><br><ul><li>  CVE-2017-0806（GateKeeperResponse类中的错误），于2017年10月发布; </li><li>  CVE-2017-13286（类OutputConfiguration中的错误，于2018年4月发布; </li><li>  CVE-2017-13287（VerifyCredentialResponse类中的错误），于2018年4月发布; </li><li>  CVE-2017-13288（PeriodicAdvertizingReport类中的错误），于2018年4月发布; </li><li>  CVE-2017-13289（ParcelableRttResults类中的错误），于2018年4月发布; </li><li>  CVE-2017-13311（SparseMappingTable类中的错误），于2018年5月发布; </li><li>  CVE-2017-13315（DcParamObject类错误），于2018年5月发布。 </li></ul><br> 所有这些都威胁运行Android OS 5.0-8.1的设备，这些设备未安装May 2018和更高版本的安全更新。 <br><br><h3>  EvilParcel漏洞的前提条件 </h3><br> 让我们看看EvilParcel漏洞是如何产生的。 首先，我们将介绍Android应用程序的某些功能。 在Android OS中，所有程序都通过发送和接收Intent类型的对象相互之间以及与操作系统本身进行交互。 这些对象可以在Bundle类型的对象内包含任意数量的键/值对。 <br><br> 传输Intent时，Bundle对象将转换（序列化）为包裹在Parcel中的字节数组，并且当从序列化Bundle中读取键和值时，它将自动反序列化。 <br><br> 在Bundle中，字符串是键，值几乎可以是任何值。 例如，原始类型，字符串或包含原始类型或字符串的容器。 此外，它可以是Parcelable类型的对象。 <br><br> 因此，可以在Bundle中放置实现Parcelable接口的任何类型的对象。 为此，您需要实现writeToParcel（）和createFromParcel（）方法来序列化和反序列化对象。 <br><br> 作为一个很好的例子，让我们创建一个简单的序列化Bundle。 让我们写一个代码，将三个键值对放入Bundle中并对其进行序列化： <br><br> 捆绑包演示=新捆绑包（）; <br>  demo.putString（“ String”，“你好，世界！”）; <br>  demo.putInt（“ Integer”，42）; <br>  demo.putByteArray（“ ByteArray”，新的字节[] {1,2,3,4,5,6,7,8}）; <br> 宗地宗地= Parcel.obtain（）; <br>  parcel.writeBundle（演示）; <br><br> 执行此代码后，我们将获得以下格式的捆绑包： <br><br><img src="https://habrastorage.org/webt/53/gn/x5/53gnx5bjhjfdaqjr5isxgva6fzg.png"><br><br>  <b>图1.</b>序列化Bundle对象的结构。 <br><br> 让我们注意Bundle序列化的以下功能： <br><br><ul><li> 所有键值对都一个接一个地写入； </li><li> 在每个值之前指示其类型（13表示字节数组，1表示整数，0表示字符串，依此类推）； </li><li> 在可变长度的数据之前，指示其大小（字符串的长度，数组的字节数）； </li><li> 所有值均以4字节的对齐方式写入。 </li></ul><br> 由于Bundle中的所有键和值都是顺序写入的，因此在访问键或序列化Bundle对象的值时，后者会完全反序列化，包括初始化其中包含的所有Parcelable对象。 <br><br> 看起来可能是什么问题？ 在某些实现Parcelable的系统类中，createFromParcel（）和writeToParcel（）方法可能会遇到错误。 在这些类中，在createFromParcel（）方法中读取的字节数将与在writeToParcel（）方法中写入的字节数不同。 如果将此类的对象放置在Bundle中，则重新序列化后，Bundle中对象的边界将发生变化。 这就是创建利用EvilParcel漏洞的条件的地方。 <br><br> 这是带有类似错误的类的示例： <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parcelable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Demo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = in.readInt(); data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[length]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { in.readByteArray(data); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Creator&lt;Demo&gt; CREATOR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Creator&lt;Demo&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Demo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFromParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel in)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Demo(in); } }; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToParcel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcel parcel, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ parcel.writeInt(data.length); parcel.writeByteArray(data); } }</code> </pre> <br> 如果数据数组的大小为0，则在createFromParcel（）中创建对象时，将读取一个int（4个字节），并将两个int（8个字节）写入writeToParcel（）。 第一个int将在对writeInt的显式调用中写入。 调用writeByteArray（）时将写入第二个int，因为数组的长度始终在其之前写入Parcel（请参见图1）。 <br><br> 数据数组的大小为0的情况很少见。 但是即使发生这种情况，如果一次仅以序列化形式传输一个对象（在我们的示例中为Demo对象），程序仍然可以继续工作。 因此，通常不会注意到此类错误。 <br><br> 现在，让我们尝试在Bundle中放置一个数组长度为零的Demo对象： <br><br><img src="https://habrastorage.org/webt/2y/2v/i0/2y2vi0ftdkartg9i01cc-b858g0.png"><br>  <b>图2.</b>将具有零数组长度的Demo对象添加到Bundle中的结果。 <br><br> 我们序列化对象： <br><br><img src="https://habrastorage.org/webt/hv/tw/if/hvtwifj9curkc7ip6jplbdlk-yc.png"><br>  <b>图3.</b>序列化后的Bundle对象。 <br><br> 让我们尝试反序列化它： <br><br><img src="https://habrastorage.org/webt/_u/a1/k4/_ua1k4hp34wknsvnppv8zla0jei.png"><br>  <b>图4.</b>反序列化Bundle对象之后。 <br><br> 结果如何？ 考虑一个包裹片段： <br><br><img src="https://habrastorage.org/webt/g0/qs/y4/g0qsy4cigykwv2gxgpizo2qsu7u.png"><br>  <b>图5.</b>捆反序列化后的包裹结构。 <br><br> 从图4和5中，我们看到在反序列化期间，在createFromParcel方法中读取了一个int，而不是之前写入的两个int。 因此，未正确读取捆绑中的所有后续值。 地址0x60处的值0x0被读取为下一个键的长度。 地址0x64的值0x1被读取为键。 在这种情况下，将地址0x68处的值0x31读取为值的类型。  Parcel中没有类型为0x31的值，因此readFromParcel（）忠实地报告了一个错误（异常）。 <br><br> 如何在实践中使用它并使其成为漏洞？ 让我们来看看！ 上面在Parcelable系统类中描述的错误使您可以构造Bundle，在第一次和重复的反序列化过程中，它们可能会有所不同。 为了说明这一点，请修改前面的示例： <br><br><pre> <code class="java hljs">Parcel data = Parcel.obtain(); data.writeInt(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 entries data.writeString("vuln_class"); data.writeInt(4); // value is Parcelable data.writeString("com.drweb.testbundlemismatch.Demo"); data.writeInt(0); // data.length data.writeInt(1); // key length -&gt; key value data.writeInt(6); // key value -&gt; value is long data.writeInt(0xD); // value is bytearray -&gt; low(long) data.writeInt(-1); // bytearray length dummy -&gt; high(long) int startPos = data.dataPosition(); data.writeString("hidden"); // bytearray data -&gt; hidden key data.writeInt(0); // value is string data.writeString("Hi there"); // hidden value int endPos = data.dataPosition(); int triggerLen = endPos - startPos; data.setDataPosition(startPos - 4); data.writeInt(triggerLen); // overwrite dummy value with the real value data.setDataPosition(endPos); data.writeString("A padding"); data.writeInt(0); // value is string data.writeString("to match pair count"); int length = data.dataSize(); Parcel bndl = Parcel.obtain(); bndl.writeInt(length); bndl.writeInt(0x4C444E42); // bundle magic bndl.appendFrom(data, 0, length); bndl.setDataPosition(0);</span></span></code> </pre> <br> 此代码创建一个包含易受攻击类的序列化Bundle。 让我们看一下执行此代码的结果： <br><br><img src="https://habrastorage.org/webt/tc/ke/wf/tckewffnaop28wllxnrt7pagdvs.png"><br>  <b>图6.</b>用一个易受攻击的类创建一个包 <br><br> 第一次反序列化之后，此捆绑包将包含以下密钥： <br><br><img src="https://habrastorage.org/webt/cj/si/l0/cjsil0--g_jsoew8ht-oxely1u4.png"><br>  <b>图7.</b>对具有脆弱类的Bundle进行反序列化的结果。 <br><br> 现在再次序列化生成的Bundle，然后再次对其进行反序列化，然后查看密钥列表： <br><br><img src="https://habrastorage.org/webt/uw/e1/mj/uwe1mjdtywr59oyshaah2q1gkus.png"><br>  <b>图8.</b>具有弱类的Bundle重新序列化和反序列化的结果。 <br><br> 我们看到了什么？ 隐藏的键（字符串值为“ Hi there！”）出现在Bundle中，以前没有。 考虑此捆绑包的包裹片段以了解发生这种情况的原因： <br><br><img src="https://habrastorage.org/webt/cx/za/dz/cxzadza4tugyeemlefk1lmlkdbu.png"><br>  <b>图9.</b>经过两个序列化-反序列化循环后，带有易受攻击类的Bundle对象的包裹结构。 <br><br> 在这里，EvilParcel漏洞的本质变得更加清晰。 可以创建一个包含易受攻击类的特殊格式的Bundle。 更改此类的边界将使您可以在此Bundle中放置任何对象-例如，Intent，仅在第二次反序列化之后才会出现在Bundle中。 这将有可能在操作系统的保护机制中隐藏Intent。 <br><br><h3> 邪恶包裹行动 </h3><br> 使用CVE-2017-13315的Android.InfectionAds.1自行安装和卸载程序，而无需受感染设备所有者的干预。 但是怎么回事？ <br><br> 在2013年，还发现了错误<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7699048</a> ，也称为Launch AnyWhere。 它允许第三方应用程序代表特权更大的用户系统运行任意活动。 下图显示了其作用机理： <br><br><img src="https://habrastorage.org/webt/dg/no/n9/dgnon92txtobknvvgr5eo2cmi54.png"><br>  <b>图10.</b>错误方案7699048。 <br><br> 利用此漏洞，利用程序可以实现AccountAuthenticator服务，该服务旨在向操作系统添加新帐户。 多亏了错误7699048，该漏洞利用程序才能运行活动来安装，卸载，替换应用程序，重置PIN或模式锁定以及执行其他不愉快的事情。 <br><br>  Google通过禁止从AccountManager启动任意活动来解决了这一差距。 现在，AccountManager仅允许启动来自同一应用程序的活动。 为此，它将检查启动活动开始的程序的数字签名，并将其与启动的活动所在的应用程序的签名进行比较。 看起来像这样： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* * The Authenticator API allows third party authenticators to * supply arbitrary intents to other apps that they can run, * this can be very bad when those apps are in the system like * the System Settings. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> authenticatorUid = Binder.getCallingUid(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> bid = Binder.clearCallingIdentity(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { PackageManager pm = mContext.getPackageManager(); ResolveInfo resolveInfo = pm.resolveActivityAsUser(intent, <span class="hljs-number"><span class="hljs-number">0</span></span>, mAccounts.userId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetUid = resolveInfo.activityInfo.applicationInfo.uid; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PackageManager.SIGNATURE_MATCH != pm.checkSignatures(authenticatorUid, targetUid)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecurityException( <span class="hljs-string"><span class="hljs-string">"Activity to be started with KEY_INTENT must "</span></span> + <span class="hljs-string"><span class="hljs-string">"share Authenticator's signatures"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Binder.restoreCallingIdentity(bid); } }</code> </pre><br> 看来问题已经解决了，但并不是所有事情都这么顺利。 事实证明，可以使用众所周知的漏洞EvilParcel CVE-2017-13315来绕过此修复程序！ 众所周知，修复了Launch AnyWhere之后，系统会检查应用程序的数字签名。 如果此检查成功，则将Bundle传递给IAccountManagerResponse.onResult（）。 同时，通过IPC机制调用onResult（），因此再次对Bundle进行序列化。 在onResult（）实现中，发生以下情况： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** Handles the responses from the AccountManager */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAccountManagerResponse</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stub</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = bundle.getParcelable(KEY_INTENT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; mActivity != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// since the user provided an Activity we will silently start intents // that we see mActivity.startActivity(intent); // leave the Future running to wait for the real response to this request } //&lt;.....&gt; } //&lt;.....&gt; }</span></span></code> </pre><br> 接下来，提取捆绑包的意图键，并在不检查的情况下启动活动。 结果，要启动具有系统权限的任意活动，以这种方式构造Bundle就足够了，即intent字段在第一个反序列化中隐藏，而在第二个反序列化中出现。 而且，正如我们已经看到的那样，EvilParcel漏洞正是完成了此任务。 <br><br> 目前，所有此类已知漏洞已通过易受攻击的Parcelable类本身的修复程序修复。 但是，不能排除将来会再次出现弱势群体。  Bundle的实现和添加新帐户的机制仍然与以前相同。 当发现（或新的）易受攻击的Parcelable类时，它们仍然允许您创建完全相同的漏洞利用。 而且，这些类的实现仍然是手动完成的，程序员必须注意序列化的Parcelable对象的恒定长度。 这是造成所有后果的人为因素。 但是，我们希望此类错误会尽可能少，并且EvilParcel的漏洞不会打扰Android设备的用户。 <br><br> 您可以使用我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dr.Web Security Space</a>防病毒软件检查您的移动设备是否存在EvilParcel漏洞。 内置的“安全审核员”将报告已发现的问题，并提出解决问题的建议。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN457558/">https://habr.com/ru/post/zh-CN457558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN457542/index.html">黑客和保护加密驱动器LUKS</a></li>
<li><a href="../zh-CN457546/index.html">演示日：这一切为何，怎么做UPD + Broadcast</a></li>
<li><a href="../zh-CN457548/index.html">在TMS320F28027上产生多相PWM信号</a></li>
<li><a href="../zh-CN457550/index.html">需要保护数字产业免受什么伤害</a></li>
<li><a href="../zh-CN457552/index.html">Zafasadia的登山者。 拉赫塔中心塔楼的小样如何工作</a></li>
<li><a href="../zh-CN457560/index.html">代币化的股票：如何在首次公开募股前成为普通投资者</a></li>
<li><a href="../zh-CN457562/index.html">Ivideon Counter 3D：由谁，如何以及为什么对访问者进行计数</a></li>
<li><a href="../zh-CN457564/index.html">估算公司IT系统的成本</a></li>
<li><a href="../zh-CN457566/index.html">压力正常：为什么数据中心需要气压控制？</a></li>
<li><a href="../zh-CN457568/index.html">未来大会：未来传道者的话</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>