<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏿 🚴🏻 💃🏿 C # atau Java? TypeScript atau JavaScript? Pembelajaran berbasis mesin klasifikasi bahasa pemrograman ♉️ 👈🏾 👩‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GitHub meng-host lebih dari 300 bahasa pemrograman - dari bahasa yang umum digunakan seperti Python, Jawa, dan Javascript ke bahasa esoterik seperti B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # atau Java? TypeScript atau JavaScript? Pembelajaran berbasis mesin klasifikasi bahasa pemrograman</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/459094/">  GitHub meng-host lebih dari 300 bahasa pemrograman - dari bahasa yang umum digunakan seperti Python, Jawa, dan Javascript ke bahasa esoterik seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Befunge</a> , hanya diketahui oleh komunitas yang sangat kecil. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3fa/593/e73/3fa593e735a40717b6d099826b3eefc9.png"><br>  <i>Gambar 1: 10 bahasa pemrograman teratas yang dihosting oleh GitHub dengan jumlah repositori</i> <br><br>  Salah satu tantangan penting yang dihadapi GitHub adalah untuk dapat mengenali bahasa-bahasa yang berbeda ini.  Ketika beberapa kode didorong ke repositori, penting untuk mengenali jenis kode yang ditambahkan untuk keperluan pencarian, peringatan kerentanan keamanan, dan penyorotan sintaksis - dan untuk menunjukkan distribusi konten repositori kepada pengguna. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ahli bahasa</a> adalah alat yang saat ini kami gunakan untuk mendeteksi bahasa pengkodean di GitHub.  Ahli bahasa aplikasi berbasis Ruby yang menggunakan berbagai strategi untuk deteksi bahasa, meningkatkan konvensi penamaan dan ekstensi file dan juga mempertimbangkan modelines Vim atau Emacs, serta konten di bagian atas file (shebang).  Ahli bahasa menangani disambiguasi bahasa melalui heuristik dan, gagal itu, melalui pengklasifikasi Naif Bayes dilatih pada sampel data kecil. <br><br>  Meskipun Linguist melakukan pekerjaan yang baik dengan membuat prediksi bahasa tingkat file (akurasi 84%), kinerjanya menurun secara signifikan ketika file menggunakan konvensi penamaan yang tidak terduga dan, yang terpenting, ketika ekstensi file tidak disediakan.  Ini membuat Ahli Bahasa tidak cocok untuk konten seperti GitHub Intisari atau cuplikan kode di dalam README, masalah, dan permintaan tarik. <br><br>  Untuk membuat deteksi bahasa lebih kuat dan dapat dipelihara dalam jangka panjang, kami mengembangkan classifier pembelajaran mesin bernama Octo Lingua berdasarkan arsitektur Jaringan Syaraf Tiruan (JST) yang dapat menangani prediksi bahasa dalam skenario yang rumit.  Versi model saat ini dapat membuat prediksi untuk 50 bahasa teratas yang diselenggarakan oleh GitHub dan melampaui Linguist dalam hal akurasi dan kinerja. <a name="habracut"></a><br><br><h2>  Mur dan Baut Dibalik OctoLingua </h2><br>  OctoLingua dibangun dari awal menggunakan Python, Keras dengan backend TensorFlow - dan dibuat agar akurat, kuat, dan mudah dirawat.  Di bagian ini, kami menjelaskan sumber data kami, arsitektur model, dan tolok ukur kinerja untuk OctoLingua.  Kami juga menjelaskan apa yang diperlukan untuk menambahkan dukungan untuk bahasa baru. <br><br><h3>  Sumber data </h3><br>  Versi OctoLingua saat ini dilatih tentang file yang diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rosetta Code</a> dan dari serangkaian repositori kualitas internal crowdsourced.  Kami membatasi bahasa kami disetel ke 50 bahasa teratas yang dihosting di GitHub. <br><br>  Rosetta Code adalah dataset pemula yang sangat baik karena mengandung kode sumber untuk tugas yang sama diekspresikan dalam bahasa pemrograman yang berbeda.  Misalnya, tugas menghasilkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">urutan Fibonacci</a> dinyatakan dalam C, C ++, CoffeeScript, D, Java, Julia, dan banyak lagi.  Namun, cakupan antar bahasa tidak seragam di mana beberapa bahasa hanya memiliki beberapa file dan beberapa file terlalu sedikit populasinya.  Oleh karena itu, menambah rangkaian pelatihan kami dengan beberapa sumber tambahan diperlukan dan secara substansial meningkatkan cakupan dan kinerja bahasa. <br><br>  Proses kami untuk menambahkan bahasa baru sekarang sepenuhnya otomatis.  Kami secara pemrograman mengumpulkan kode sumber dari repositori publik di GitHub.  Kami memilih repositori yang memenuhi kriteria kualifikasi minimum seperti memiliki jumlah garpu minimum, mencakup bahasa target dan mencakup ekstensi file tertentu.  Untuk tahap pengumpulan data ini, kami menentukan bahasa utama repositori menggunakan klasifikasi dari Linguist. <br><br><h3>  Fitur: meningkatkan pengetahuan sebelumnya </h3><br>  Secara tradisional, untuk masalah klasifikasi teks dengan Neural Networks, arsitektur berbasis memori seperti Recurrent Neural Networks (RNN) dan Long Short Term Memory Networks (LSTM) sering digunakan.  Namun, mengingat bahwa bahasa pemrograman memiliki perbedaan dalam kosa kata, gaya komentar, ekstensi file, struktur, gaya impor perpustakaan dan perbedaan kecil lainnya, kami memilih pendekatan yang lebih sederhana yang memanfaatkan semua informasi ini dengan mengekstraksi beberapa fitur yang relevan dalam bentuk tabel untuk diumpankan ke classifier kami.  Fitur yang saat ini diekstraksi adalah sebagai berikut: <br><br><ol><li>  Lima karakter khusus teratas per file </li><li>  20 token teratas per file </li><li>  Ekstensi file </li><li>  Kehadiran karakter khusus tertentu yang biasa digunakan dalam file kode sumber seperti titik dua, kurung kurawal, dan titik koma </li></ol><br><h3>  Model Jaringan Syaraf Tiruan (JST) </h3><br>  Kami menggunakan fitur di atas sebagai input ke Jaringan Syaraf Tiruan dua lapis yang dibangun menggunakan Keras dengan backend Tensorflow. <br><br>  Diagram di bawah ini menunjukkan bahwa langkah ekstraksi fitur menghasilkan input tabel n-dimensi untuk classifier kami.  Ketika informasi bergerak di sepanjang lapisan jaringan kami, ia diatur oleh dropout dan pada akhirnya menghasilkan output 51-dimensi yang mewakili probabilitas yang diprediksi bahwa kode yang diberikan ditulis dalam masing-masing dari 50 bahasa GitHub teratas ditambah probabilitas bahwa itu tidak tertulis di salah satu dari mereka. <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/21c/3d4/1d0/21c3d41d0f7c82c8f0751bde7036bd55.png"></div><br>  <i>Gambar 2: Struktur JST model awal kami (50 bahasa + 1 untuk "lainnya")</i> <br><br>  Kami menggunakan 90% dari dataset kami untuk pelatihan selama kurang lebih delapan zaman.  Selain itu, kami menghapus persentase ekstensi file dari data pelatihan kami pada langkah pelatihan, untuk mendorong model untuk belajar dari kosakata file, dan tidak overfit pada fitur ekstensi file, yang sangat prediktif. <br><br><h3>  Tolok ukur kinerja </h3><br>  <b>OctoLingua vs</b>  <b>Ahli bahasa</b> <br><br>  Pada Gambar 3, kami menunjukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skor F1</a> (rata-rata harmonis antara presisi dan recall) dari OctoLingua dan Linguist yang dihitung pada set tes yang sama (10% dari sumber data awal kami). <br><br>  Di sini kami menunjukkan tiga tes.  Tes pertama adalah dengan set tes yang tidak tersentuh dengan cara apa pun.  Tes kedua menggunakan set file tes yang sama dengan informasi ekstensi file dihapus dan tes ketiga juga menggunakan set file yang sama tetapi kali ini dengan ekstensi file diacak sehingga membingungkan pengelompokkan (misalnya, file Java mungkin memiliki ". txt "ekstensi dan file Python mungkin memiliki ekstensi" .java "). <br><br>  Intuisi di balik pengacakan atau menghapus ekstensi file dalam set pengujian kami adalah untuk menilai kekokohan OctoLingua dalam mengklasifikasikan file ketika fitur utama dihapus atau menyesatkan.  Penggolong yang tidak terlalu bergantung pada ekstensi akan sangat berguna untuk mengklasifikasikan intisari dan cuplikan, karena dalam kasus-kasus tersebut adalah umum bagi orang-orang untuk tidak memberikan informasi ekstensi yang akurat (misalnya, banyak intisari terkait kode memiliki ekstensi .txt). <br><br>  Tabel di bawah ini menunjukkan bagaimana OctoLingua mempertahankan kinerja yang baik dalam berbagai kondisi, menunjukkan bahwa model belajar terutama dari kosakata kode, daripada dari informasi meta (yaitu ekstensi file), sedangkan Ahli Bahasa gagal segera setelah informasi tentang ekstensi file diubah. <br><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/4d9/a60/93d/4d9a6093ded8dbeb762c34dacd9d279f.png"></div>  <i>Gambar 3: Kinerja OctoLingua vs.</i>  <i>Ahli bahasa pada set tes yang sama</i> <br><br>  <b>Efek menghapus ekstensi file selama waktu pelatihan</b> <br><br>  Seperti disebutkan sebelumnya, selama waktu pelatihan kami menghapus persentase ekstensi file dari data pelatihan kami untuk mendorong model untuk belajar dari kosakata file.  Tabel di bawah ini menunjukkan kinerja model kami dengan fraksi berbeda dari ekstensi file yang dihapus selama waktu pelatihan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ace/a5e/7d3/acea5e7d33553fe499f7d386d97b7caf.png"><br>  <i>Gambar 4: Kinerja OctoLingua dengan persentase berbeda dari ekstensi file yang dihapus pada tiga variasi pengujian kami</i> <br><br>  Perhatikan bahwa tanpa ekstensi file yang dihapus selama waktu pelatihan, kinerja OctoLingua pada file uji tanpa ekstensi dan ekstensi acak menurun secara signifikan dari pada data uji reguler.  Di sisi lain, ketika model dilatih pada dataset di mana beberapa ekstensi file dihapus, kinerja model tidak banyak menurun pada set tes yang dimodifikasi.  Ini menegaskan bahwa menghapus ekstensi file dari sebagian kecil file pada waktu pelatihan mendorong classifier kami untuk belajar lebih banyak dari kosakata.  Ini juga menunjukkan bahwa fitur ekstensi file, meskipun sangat prediktif, memiliki kecenderungan untuk mendominasi dan mencegah lebih banyak bobot ditugaskan ke fitur konten. <br><br><h3>  Mendukung bahasa baru </h3><br>  Menambahkan bahasa baru di OctoLingua cukup mudah.  Itu dimulai dengan memperoleh sejumlah besar file dalam bahasa baru (kita bisa melakukan ini secara terprogram seperti yang dijelaskan dalam sumber data).  File-file ini dipecah menjadi pelatihan dan set uji dan kemudian dijalankan melalui preprocessor dan extractor fitur kami.  Kumpulan tes dan kereta baru ini ditambahkan ke kumpulan data pelatihan dan pengujian kami yang ada.  Set pengujian baru memungkinkan kami untuk memverifikasi bahwa akurasi model kami tetap dapat diterima. <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/dcd/9fa/d5c/dcd9fad5ceed5cb24cefdf6e78c3e99f.png"></div>  <i>Gambar 5: Menambahkan bahasa baru dengan OctoLingua</i> <br><br><h2>  Rencana kami </h2><br>  Sampai sekarang, OctoLingua berada pada "tahap prototyping lanjutan".  Mesin klasifikasi bahasa kami sudah kuat dan andal, tetapi belum mendukung semua bahasa pengkodean di platform kami.  Selain memperluas dukungan bahasa - yang akan lebih mudah - kami bertujuan untuk memungkinkan deteksi bahasa pada berbagai tingkat granularity.  Implementasi kami saat ini sudah memungkinkan kami, dengan sedikit modifikasi pada mesin pembelajaran mesin kami, untuk mengklasifikasikan snipet kode.  Tidak akan terlalu jauh untuk membawa model ke tahap di mana ia dapat mendeteksi dan mengklasifikasikan bahasa tertanam dengan andal. <br><br>  Kami juga mempertimbangkan kemungkinan sumber terbuka model kami dan akan senang mendengar dari komunitas jika Anda tertarik. <br><br><h2>  Ringkasan </h2><br>  Dengan OctoLingua, tujuan kami adalah untuk menyediakan layanan yang memungkinkan deteksi bahasa kode sumber yang kuat dan andal di berbagai tingkat granularitas, dari level file atau level snippet hingga deteksi dan klasifikasi bahasa tingkat level yang berpotensi.  Akhirnya, layanan ini dapat mendukung, antara lain, pencarian kode, berbagi kode, menyoroti bahasa, dan rendering berbeda - semua ini ditujukan untuk mendukung pengembang dalam pekerjaan pengembangan mereka sehari-hari di samping membantu mereka menulis kode kualitas.  Jika Anda tertarik untuk memanfaatkan atau berkontribusi pada pekerjaan kami, silakan menghubungi Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@github</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459094/">https://habr.com/ru/post/id459094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459084/index.html">Sedikit tentang Google Home Hub, atau bagaimana saya membeli bingkai foto seharga 130 Euro</a></li>
<li><a href="../id459086/index.html">Distribusi statis objek FreeRTOS</a></li>
<li><a href="../id459088/index.html">Metode segmentasi titik dalam Point Clouds</a></li>
<li><a href="../id459090/index.html">Bawa pengalaman pengembangan Linux Anda di Windows ke level berikutnya dengan WSL dan Visual Studio Code Remote</a></li>
<li><a href="../id459092/index.html">X.Spectator - pemantauan negara dalam .NET</a></li>
<li><a href="../id459098/index.html">Registry Paket GitHub akan mendukung paket Swift</a></li>
<li><a href="../id459100/index.html">Registry Paket GitHub akan mendukung paket Swift</a></li>
<li><a href="../id459102/index.html">Hadiah piring atau musik gratis untuk pecinta cola dan sarapan siap saji</a></li>
<li><a href="../id459104/index.html">C # atau Java? TypeScript atau JavaScript? Klasifikasi bahasa pemrograman berdasarkan pembelajaran mesin</a></li>
<li><a href="../id459108/index.html">Tesla akan menghadirkan beberapa kejutan sekaligus di paruh kedua tahun ini</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>