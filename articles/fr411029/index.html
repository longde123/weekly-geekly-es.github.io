<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👫 🍓 🔳 Comment utiliser les interfaces dans Go 🤸🏿 👩🏼‍🌾 ☃️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans ses temps libres de l'œuvre principale, l'auteur du matériel consulte Go et analyse le code. Naturellement, au cours d'une telle activité, il lit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment utiliser les interfaces dans Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wirex/blog/411029/"><img src="https://habrastorage.org/webt/3r/a6/gf/3ra6gfzzmia3bmlydkdkqbmpl6a.jpeg"><br><br>  <i>Dans ses temps libres de l'œuvre principale, l'auteur du matériel consulte Go et analyse le code.</i>  <i>Naturellement, au cours d'une telle activité, il lit beaucoup de code écrit par d'autres personnes.</i>  <i>Récemment, l'auteur de cet article a l'impression (oui, l'impression, pas de statistiques) que les programmeurs sont plus susceptibles de travailler avec des interfaces de «style Java».</i> <i><br><br></i>  <i>Cet article contient des recommandations de l'auteur sur l'utilisation optimale des interfaces dans Go, basées sur son expérience dans l'écriture de code.</i> <br><br>  Dans les exemples de ce billet, nous utiliserons deux packages <code>animal</code> et <code>circus</code> .  Beaucoup de choses dans ce post décrivent le travail avec du code à la limite de l'utilisation régulière des packages. <br><br><h3>  Comment ne pas faire </h3><br>  Un phénomène très courant que j'observe: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> animals <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Animal <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Speaks() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  Animal type Dog struct{} func (a Dog) Speaks() string { return "woof" }</span></span></code> </pre> <a name="habracut"></a><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> circus <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"animals"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a animal.Animal)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.Speaks() }</code> </pre> <br>  C'est ce qu'on appelle l'utilisation d'interfaces de style Java.  Il peut être caractérisé par les étapes suivantes: <br><br><ol><li>  Définissez une interface. </li><li>  Définissez un type qui satisfait le comportement de l'interface. </li><li>  Définissez des méthodes qui satisfont l'implémentation de l'interface. </li></ol><br>  En résumé, nous avons affaire à des «types d'écriture qui satisfont les interfaces».  Ce code a sa propre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">odeur</a> distincte, suggérant les pensées suivantes: <br><br><ul><li>  Un seul type satisfait l'interface, sans aucune intention de l'étendre davantage. </li><li>  Les fonctions prennent généralement des types concrets au lieu de types d'interface. </li></ul><br><h3>  Comment faire à la place </h3><br>  Les interfaces dans Go encouragent une approche paresseuse, ce qui est bien.  Au lieu d'écrire des types qui satisfont aux interfaces, vous devez écrire des interfaces qui répondent à de réelles exigences pratiques. <br><br>  Ce qui signifie: au lieu de définir <code>Animal</code> dans le package <code>animals</code> , définissez-le au point d'utilisation, c'est-à-dire le package <code>circus</code> <abbr title="Vous pouvez, bien sûr, le définir dans une signature de fonction, mais c'est une approche trop bâclée">*</abbr> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> animals <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Dog <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a Dog)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Speaks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"woof"</span></span> }</code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> circus <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Speaker <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Speaks() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a Speaker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.Speaks() }</code> </pre> <br>  Une façon plus naturelle de procéder est la suivante: <br><br><ol><li>  Définir les types </li><li>  Définissez l'interface au point d'utilisation. </li></ol><br>  Cette approche réduit la dépendance à l'égard des composants de l'emballage des <code>animals</code> .  Réduire les dépendances est le bon moyen de créer un logiciel tolérant aux pannes. <br><br><h3>  La loi du lit </h3><br>  Il existe un bon principe pour écrire un bon logiciel.  C'est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">loi de Postel</a> , qui est souvent formulée comme suit: <br><blockquote>  "Soyez conservateur sur ce que vous référez et libéral sur ce que vous acceptez" </blockquote>  En termes de Go, la loi est: <br><br><blockquote>  "Accepter les interfaces, retourner les structures" </blockquote><br>  Dans l'ensemble, c'est une très bonne règle pour concevoir des choses stables et tolérantes aux pannes <abbr title="Bien sûr, il y a des nuances que j'omets. Par exemple, dans les cas avec du code contextuel, il sera très utile d'accepter et de donner des interfaces)">*</abbr> .  L'unité principale de code dans Go est une fonction.  Lors de la conception de fonctions et de méthodes, il est utile de respecter le modèle suivant: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a INTERFACETYPE)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CONCRETETYPE</span></span></span></span></code> </pre> <br>  Ici, nous acceptons tout ce qui implémente une interface qui peut être n'importe quoi, y compris une interface vide.  Une valeur d'un type spécifique est suggérée.  Bien sûr, limiter ce qui peut être logique est logique.  Comme le dit un proverbe Go: <br><br><blockquote>  "L'interface vide ne dit rien", <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rob Pike</a> </blockquote><br>  Par conséquent, il est fortement conseillé d'empêcher les fonctions d'accepter l' <code>interface{}</code> . <br><br><h3>  Exemple d'application: imitation </h3><br>  Les cas types constituent un exemple frappant des avantages de l'application de la loi Postel.  Disons que vous avez une fonction qui ressemble à ceci: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Takes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db Database)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br>  Si la <code>Database</code> est une interface, alors dans le code de test, vous pouvez simplement fournir une imitation de l'implémentation de la <code>Database</code> sans avoir à passer un véritable objet DB. <br><br><h3>  Lorsque la définition d'une interface à l'avance est acceptable </h3><br>  Pour vous dire la vérité, la programmation est un moyen assez libre d'exprimer des idées.  Il n'y a pas de règles inébranlables.  Bien sûr, vous pouvez toujours définir des interfaces à l'avance, sans craindre d'être arrêté par la police du code.  Dans le contexte de nombreux packages, si vous connaissez vos fonctions et avez l'intention d'accepter une interface spécifique au sein du package, faites-le. <br><br>  Définir une interface dégage généralement une ingénierie excessive, mais il y a des situations dans lesquelles vous devriez évidemment faire exactement cela.  En particulier, les exemples suivants me viennent à l'esprit: <br><br><ul><li>  Interfaces scellées </li><li>  Types de données abstraits </li><li>  Interfaces récursives </li></ul><br>  Ensuite, nous examinons brièvement chacun d'eux. <br><br><h3>  Interfaces scellées </h3><br>  Les interfaces scellées ne peuvent être discutées que dans le contexte de plusieurs packages.  Une interface scellée est une interface avec des méthodes non exportées.  Cela signifie que les utilisateurs en dehors de ce package ne peuvent pas créer de types qui satisfont cette interface.  Ceci est utile pour émuler un type variant afin de rechercher de manière exhaustive les types satisfaisant l'interface. <br><br>  Si vous avez défini quelque chose comme ceci: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Fooer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Foo() sealed() }</code> </pre> <br>  Seul le package défini par <code>Fooer</code> peut l'utiliser et en créer quelque chose de valeur.  Cela vous permet de créer des opérateurs de commutateur à force brute pour les types. <br><br>  L'interface scellée permet également aux outils d'analyse de détecter facilement toutes les correspondances de motif de non-collision.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le package sumtypes</a> de BurntSushi vise à résoudre ce problème. <br><br><h3>  Types de données abstraits </h3><br>  Un autre cas de définition préalable d'une interface implique la création de types de données abstraits.  Ils peuvent être scellés ou non scellés. <br><br>  Un bon exemple de ceci est le package de <code>sort</code> , qui fait partie de la bibliothèque standard.  Il définit une collection triable comme suit <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Interface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Len —    . Len() int // Less      //   i     j. Less(i, j int) bool // Swap     i  j. Swap(i, j int) }</span></span></code> </pre> <br>  Ce morceau de code a bouleversé beaucoup de gens, car si vous voulez utiliser le package de <code>sort</code> , vous devrez implémenter des méthodes pour l'interface.  Beaucoup n'aiment pas la nécessité d'ajouter trois lignes de code supplémentaires. <br><br>  Cependant, je trouve que c'est une forme très élégante de génériques dans Go.  Son utilisation devrait être plus souvent encouragée. <br><br>  Des options de conception alternatives et en même temps élégantes nécessiteront des types d'ordre supérieur.  Dans cet article, nous ne les examinerons pas. <br><br><h3>  Interfaces récursives </h3><br>  C'est probablement un autre exemple de code avec un stock, mais il y a des moments où il est tout simplement impossible d'éviter de l'utiliser.  Des manipulations simples vous permettent d'obtenir quelque chose comme <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Fooer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Foo() Fooer }</code> </pre> <br>  Un modèle d'interface récursif nécessitera évidemment sa définition à l'avance.  La recommandation de définition d'interface de point d'utilisation n'est pas applicable ici. <br><br>  Ce modèle est utile pour créer des contextes contenant des travaux ultérieurs.  Le code chargé par le contexte s'enferme généralement à l'intérieur du package avec l'exportation uniquement des contextes (ala le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tensor</a> ), donc, dans la pratique, je rencontre ce cas pas si souvent.  Je peux vous dire autre chose sur les modèles contextuels, mais laissez-le pour un autre post. <br><br><h3>  Conclusion </h3><br>  Malgré le fait que l’une des rubriques de l’article soit «Comment ne pas le faire», je n’essaie en aucun cas d’interdire quoi que ce soit.  Je veux plutôt inciter les lecteurs à réfléchir plus souvent aux conditions frontalières, car c'est dans de tels cas que diverses situations d'urgence surviennent. <br><br>  Je trouve le principe de la déclaration du point d'utilisation extrêmement utile.  Du fait de son application dans la pratique, je ne rencontre pas de problèmes qui se posent si je le néglige. <br><br>  Cependant, j'écris aussi occasionnellement des interfaces de style Java.  En règle générale, cela se produit si, peu de temps avant, j'écrivais beaucoup de code en Java ou en Python.  Le désir de trop compliquer et de «tout représenter sous forme de classes» est parfois très fort, surtout si vous écrivez du code Go après avoir écrit beaucoup de code orienté objet. <br><br>  Ainsi, ce message sert également de rappel à soi-même à quoi ressemble le chemin pour écrire du code qui ne causera pas de maux de tête par la suite.  En attendant vos commentaires! <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/4bd/bf6/597/4bdbf659775744b1bdbb4d8a00a0a980.png" alt="image"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr411029/">https://habr.com/ru/post/fr411029/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr411017/index.html">La solitude du né. Développement par le vol. Difficile pour vous</a></li>
<li><a href="../fr411019/index.html">Pour quitter la Russie et trouver du travail à l'étranger: nous nous préparons pour un entretien en anglais</a></li>
<li><a href="../fr411021/index.html">Sunlike - la nouvelle génération de lumière LED</a></li>
<li><a href="../fr411023/index.html">Anthropocène africain</a></li>
<li><a href="../fr411027/index.html">Jeux olympiques scolaires: Jedi Sword, Jetpack et Teleport to 2035</a></li>
<li><a href="../fr411031/index.html">Le premier scanner MEG portable au monde</a></li>
<li><a href="../fr411033/index.html">«Faire», «comprendre», «accepter»: synonymes en anglais</a></li>
<li><a href="../fr411035/index.html">Ou peut-être que vous dormez maintenant?</a></li>
<li><a href="../fr411037/index.html">Sochi.Camera: comment un fournisseur régional a créé un site de diffusion vidéo avec une visite de 500 000 personnes par mois</a></li>
<li><a href="../fr411039/index.html">Le deuxième contact, ou à la place de l'épilogue</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>