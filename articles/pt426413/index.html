<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèº üßí üéº Princ√≠pios do SOLID que todo desenvolvedor deve conhecer üåÅ üëéüèø ü•à</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A programa√ß√£o orientada a objetos trouxe novas abordagens para o design de aplicativos no desenvolvimento de software. Em particular, o OOP permitiu q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Princ√≠pios do SOLID que todo desenvolvedor deve conhecer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426413/">  A programa√ß√£o orientada a objetos trouxe novas abordagens para o design de aplicativos no desenvolvimento de software.  Em particular, o OOP permitiu que os programadores combinassem entidades, unidas por um objetivo ou funcionalidade comum, em classes separadas, projetadas para resolver problemas independentes e independentes de outras partes do aplicativo.  No entanto, o uso do OOP sozinho n√£o significa que o desenvolvedor esteja seguro da possibilidade de criar c√≥digo obscuro e confuso, dif√≠cil de manter.  Robert Martin, a fim de ajudar todos que desejam desenvolver aplicativos OOP de alta qualidade, desenvolveu cinco princ√≠pios de programa√ß√£o e design orientados a objetos, falando sobre os quais, com a ajuda de Michael Fazers, eles usam o acr√¥nimo SOLID. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/46/xx/ol/46xxolpv46av7bknmyywp3ii9vs.jpeg"></a> <br><br>  O material, cuja tradu√ß√£o publicamos hoje, √© dedicado aos conceitos b√°sicos do SOLID e destina-se a desenvolvedores iniciantes. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">O que √© o SOLID?</font> </h2><br>  Veja como o acr√¥nimo SOLID significa: <br><br><ul><li>  S: Princ√≠pio da responsabilidade √∫nica. </li><li>  O: Princ√≠pio Aberto-Fechado. </li><li>  L: Princ√≠pio de substitui√ß√£o de Liskov (Princ√≠pio de substitui√ß√£o de Barbara Liskov). </li><li>  I: Princ√≠pio de Segrega√ß√£o de Interface. </li><li>  D: Princ√≠pio da invers√£o de depend√™ncia. </li></ul><br>  Agora vamos considerar esses princ√≠pios em exemplos esquem√°ticos.  Observe que o principal objetivo dos exemplos √© ajudar o leitor a entender os princ√≠pios do SOLID, aprender como aplic√°-los e como segui-los ao projetar aplicativos.  O autor do material n√£o se esfor√ßou para alcan√ßar um c√≥digo de trabalho que pudesse ser usado em projetos reais. <br><br><h2>  <font color="#3AC1EF">Princ√≠pio da responsabilidade exclusiva</font> </h2><br>  <i><font color="#999999">‚ÄúUma tarefa.</font></i>  <i><font color="#999999">S√≥ uma coisa.</font></i>  <i><font color="#999999">- Loki diz a Skurge no filme Thor: Ragnarok.</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">Cada classe deve resolver apenas um problema.</font></i> <br><br>  Uma classe s√≥ deve ser respons√°vel por uma coisa.  Se uma classe √© respons√°vel por resolver v√°rios problemas, seus subsistemas que implementam a solu√ß√£o desses problemas acabam se relacionando.  Altera√ß√µes em um desses subsistemas levam a altera√ß√µes em outro. <br><br>  Observe que esse princ√≠pio se aplica n√£o apenas √†s classes, mas tamb√©m aos componentes de software em um sentido mais amplo. <br><br>  Por exemplo, considere este c√≥digo: <br><br><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {    constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">){ }    getAnimalName() { }    saveAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { } }</span></span></code> </pre> <br>  A classe <code>Animal</code> apresentada aqui descreve algum tipo de animal.  Esta classe viola o princ√≠pio de responsabilidade exclusiva.  Como exatamente esse princ√≠pio √© violado? <br><br>  De acordo com o princ√≠pio da responsabilidade exclusiva, uma classe deve resolver apenas uma tarefa.  Ele resolve os dois trabalhando com o armaz√©m de dados no m√©todo <code>saveAnimal</code> e manipulando as propriedades do objeto no construtor e no m√©todo <code>getAnimalName</code> . <br><br>  Como essa estrutura de classes pode levar a problemas? <br><br>  Se o procedimento para trabalhar com o armaz√©m de dados usado pelo aplicativo for alterado, ser√° necess√°rio fazer altera√ß√µes em todas as classes que trabalham com o armaz√©m.  Essa arquitetura n√£o √© flex√≠vel, as altera√ß√µes em alguns subsistemas afetam outras, que se assemelham ao efeito domin√≥. <br><br>  Para alinhar o c√≥digo acima com o princ√≠pio de responsabilidade exclusiva, criaremos outra classe cuja √∫nica tarefa √© trabalhar com o reposit√≥rio, em particular, armazenar objetos da classe <code>Animal</code> nele: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class"> {   constructor(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">){ }   getAnimalName() { } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AnimalDB</span></span></span><span class="hljs-class"> {   getAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { }   saveAnimal(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Animal</span></span></span><span class="hljs-class">) { } }</span></span></code> </pre> <br>  Eis o que Steve Fenton diz sobre isso: ‚ÄúAo projetar classes, devemos nos esfor√ßar para integrar componentes relacionados, ou seja, aqueles nos quais as mudan√ßas ocorrem pelos mesmos motivos.  Devemos tentar separar os componentes, mudan√ßas nas quais causam v√°rias raz√µes ". <br><br>  A aplica√ß√£o correta do princ√≠pio de responsabilidade exclusiva leva a um alto grau de conectividade dos elementos dentro do m√≥dulo, ou seja, ao fato de que as tarefas resolvidas nele correspondem bem ao seu objetivo principal. <br><br><h2>  <font color="#3AC1EF">Princ√≠pio aberto-fechado</font> </h2><br>  <i><font color="#999999">As entidades de software (classes, m√≥dulos, fun√ß√µes) devem estar abertas para expans√£o, mas n√£o para modifica√ß√£o.</font></i> <br><br>  Continuamos a trabalhar na classe <code>Animal</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name: string){ }   getAnimalName() { } }</code> </pre> <br>  Queremos classificar a lista de animais, cada um dos quais √© representado por um objeto da classe <code>Animal</code> , e descobrir quais sons eles produzem.  Imagine que resolvemos esse problema usando a fun√ß√£o <code>AnimalSounds</code> : <br><br><pre> <code class="hljs powershell">//... const animals: Array&lt;Animal&gt; = [   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'lion'</span></span>),   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'mouse'</span></span>) ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'lion'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'mouse'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;   } } AnimalSound(animals);</code> </pre> <br>  O principal problema dessa arquitetura √© que a fun√ß√£o determina que tipo de som um animal faz ao analisar objetos espec√≠ficos.  A fun√ß√£o <code>AnimalSound</code> est√° de acordo com o princ√≠pio de abertura-abertura, pois, por exemplo, quando novos tipos de animais aparecem, precisamos alter√°-la para us√°-la para reconhecer os sons emitidos por eles. <br><br>  Adicione um novo elemento √† matriz: <br><br><pre> <code class="hljs powershell">//... const animals: Array&lt;Animal&gt; = [   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'lion'</span></span>),   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'mouse'</span></span>),   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Animal</span></span>(<span class="hljs-string"><span class="hljs-string">'snake'</span></span>) ] //...</code> </pre> <br>  Depois disso, temos que alterar o c√≥digo da fun√ß√£o <code>AnimalSound</code> : <br><br><pre> <code class="hljs powershell">//... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'lion'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'mouse'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a[<span class="hljs-type"><span class="hljs-type">i</span></span>].name == <span class="hljs-string"><span class="hljs-string">'snake'</span></span>)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hiss'</span></span>;   } } AnimalSound(animals);</code> </pre> <br>  Como voc√™ pode ver, ao adicionar um novo animal √† matriz, voc√™ precisar√° complementar o c√≥digo da fun√ß√£o.  Um exemplo √© muito simples, mas se uma arquitetura semelhante for usada em um projeto real, a fun√ß√£o precisar√° ser constantemente expandida, adicionando novas express√µes <code>if</code> a ela. <br><br>  Como alinhar a fun√ß√£o <code>AnimalSound</code> com o princ√≠pio de aberto-fechado?  Por exemplo, assim: <br><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {       makeSound();       //... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {   makeSound() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'roar'</span></span>;   } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Squirrel</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {   makeSound() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'squeak'</span></span>;   } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Snake</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {   makeSound() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hiss'</span></span>;   } } //... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalSound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       a[<span class="hljs-type"><span class="hljs-type">i</span></span>].makeSound();   } } AnimalSound(animals);</code> </pre> <br>  Voc√™ pode perceber que a classe <code>Animal</code> agora tem um m√©todo <code>makeSound</code> virtual.  Com essa abordagem, √© necess√°rio que as classes projetadas para descrever animais espec√≠ficos expandam a classe <code>Animal</code> e implementem esse m√©todo. <br><br>  Como resultado, cada classe que descreve um animal ter√° seu pr√≥prio m√©todo <code>makeSound</code> e, ao iterar sobre uma matriz com animais na fun√ß√£o <code>AnimalSound</code> , ser√° suficiente chamar esse m√©todo para cada elemento da matriz. <br><br>  Se voc√™ agora adicionar um objeto que descreve o novo animal √† matriz, n√£o precisar√° alterar a fun√ß√£o <code>AnimalSound</code> .  N√≥s o alinhamos com o princ√≠pio de abertura-proximidade. <br><br>  Considere outro exemplo. <br><br>  Suponha que tenhamos uma loja.  Damos aos clientes um desconto de 20% usando esta classe: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Discount</span></span></span><span class="hljs-class"> </span></span>{   giveDiscount() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.2</span></span>   } }</code> </pre> <br>  Agora foi decidido dividir os clientes em dois grupos.  Os clientes favoritos ( <code>fav</code> ) recebem 20% de desconto e os clientes VIP ( <code>vip</code> ) - dobram o desconto, ou seja - 40%.  Para implementar essa l√≥gica, decidiu-se modificar a classe da seguinte maneira: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Discount</span></span></span><span class="hljs-class"> </span></span>{   giveDiscount() {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.customer == <span class="hljs-string"><span class="hljs-string">'fav'</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.2</span></span>;       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.customer == <span class="hljs-string"><span class="hljs-string">'vip'</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.price * <span class="hljs-number"><span class="hljs-number">0.4</span></span>;       }   } }</code> </pre> <br>  Essa abordagem viola o princ√≠pio de abertura-proximidade.  Como voc√™ pode ver, aqui, se precisarmos dar um desconto especial a um determinado grupo de clientes, precisamos adicionar um novo c√≥digo √† classe. <br><br>  Para processar esse c√≥digo de acordo com o princ√≠pio de abertura-proximidade, adicionamos uma nova classe ao projeto que estende a classe <code>Discount</code> .  Nesta nova classe, estamos implementando um novo mecanismo: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VIPDiscount</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Discount {   getDiscount</span></span></span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getDiscount() * <span class="hljs-number"><span class="hljs-number">2</span></span>;   } }</code> </pre> <br>  Se voc√™ decidir conceder um desconto de 80% aos clientes ‚Äúsuper VIP‚Äù, deve ficar assim: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperVIPDiscount</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIPDiscount {   getDiscount</span></span></span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getDiscount() * <span class="hljs-number"><span class="hljs-number">2</span></span>;   } }</code> </pre> <br>  Como voc√™ pode ver, o empoderamento das classes √© usado aqui, n√£o sua modifica√ß√£o. <br><br><h2>  <font color="#3AC1EF">O princ√≠pio da substitui√ß√£o de Barbara Liskov</font> </h2><br>  <i><font color="#999999">√â necess√°rio que as subclasses sirvam como um substituto para suas superclasses.</font></i> <br><br>  O objetivo desse princ√≠pio √© que as classes de heran√ßa possam ser usadas em vez das classes pai das quais elas s√£o formadas sem interromper o programa.  Se o tipo de classe for verificado no c√≥digo, o princ√≠pio da substitui√ß√£o ser√° violado. <br><br>  Considere a aplica√ß√£o desse princ√≠pio, retornando ao exemplo com a classe <code>Animal</code> .  Escreveremos uma fun√ß√£o projetada para retornar informa√ß√µes sobre o n√∫mero de membros de um animal. <br><br><pre> <code class="hljs powershell">//... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Lion)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LionLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Mouse)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MouseLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Snake)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SnakeLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);   } } AnimalLegCount(animals);</code> </pre> <br>  A fun√ß√£o viola o princ√≠pio de substitui√ß√£o (e o princ√≠pio de abertura-fechamento).  Esse c√≥digo deve conhecer os tipos de todos os objetos processados ‚Äã‚Äãpor ele e, dependendo do tipo, usar a fun√ß√£o correspondente para calcular os membros de um animal em particular.  Como resultado, ao criar um novo tipo de animal, a fun√ß√£o precisar√° ser reescrita: <br><br><pre> <code class="hljs powershell">//... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pigeon</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> {      } const animals[]: Array&lt;Animal&gt; = [   //<span class="hljs-type"><span class="hljs-type">...</span></span>,   <span class="hljs-type"><span class="hljs-type">new</span></span> <span class="hljs-type"><span class="hljs-type">Pigeon</span></span>(); ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Lion)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LionLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Mouse)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MouseLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Snake)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SnakeLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(typeof a[<span class="hljs-type"><span class="hljs-type">i</span></span>] == Pigeon)           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PigeonLegCount(a[<span class="hljs-type"><span class="hljs-type">i</span></span>]);   } } AnimalLegCount(animals);</code> </pre> <br>  Para que essa fun√ß√£o n√£o viole o princ√≠pio da substitui√ß√£o, n√≥s a transformamos usando os requisitos formulados por Steve Fenton.  Eles consistem no fato de que m√©todos que aceitam ou retornam valores com o tipo de uma determinada superclasse ( <code>Animal</code> no nosso caso) tamb√©m devem aceitar e retornar valores cujos tipos s√£o suas subclasses ( <code>Pigeon</code> ). <br><br>  Armado com essas considera√ß√µes, podemos refazer a fun√ß√£o <code>AnimalLegCount</code> : <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Array&lt;Animal&gt;)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt;= a.length; i++)</span></span></span><span class="hljs-function"> {       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;   } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnimalLegCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animals)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Agora, esta fun√ß√£o n√£o est√° interessada nos tipos de objetos passados ‚Äã‚Äãpara ela.  Ela simplesmente chama seus m√©todos <code>LegCount</code> .  Tudo o que ela sabe sobre tipos √© que os objetos que processa devem pertencer √† classe <code>Animal</code> ou a suas subclasses. <br><br>  O m√©todo <code>LegCount</code> agora deve aparecer na classe <code>Animal</code> : <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//...   LegCount(); }</span></span></code> </pre> <br>  E suas subclasses precisam implementar este m√©todo: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class">{   //...   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LegCount</span></span></span><span class="hljs-class">() {       //...   } } //...</span></span></code> </pre> <br>  Como resultado, por exemplo, ao acessar o m√©todo <code>LegCount</code> para uma inst√¢ncia da classe <code>Lion</code> , o m√©todo implementado nesta classe √© chamado e √© retornado exatamente o que √© esperado de chamar esse m√©todo. <br><br>  Agora, a fun√ß√£o <code>AnimalLegCount</code> n√£o precisa saber sobre qual objeto de uma subclasse espec√≠fica da classe <code>Animal</code> processa para descobrir informa√ß√µes sobre o n√∫mero de membros no animal representado por esse objeto.  A fun√ß√£o simplesmente chama o m√©todo <code>LegCount</code> da classe <code>Animal</code> , pois as subclasses dessa classe devem implementar esse m√©todo para que possam ser usadas em vez disso, sem violar a opera√ß√£o correta do programa. <br><br><h2>  <font color="#3AC1EF">Princ√≠pio de separa√ß√£o de interface</font> </h2><br>  <i><font color="#999999">Crie interfaces altamente especializadas projetadas para um cliente espec√≠fico.</font></i>  <i><font color="#999999">Os clientes n√£o devem depender de interfaces que eles n√£o usam.</font></i> <br><br>  Este princ√≠pio visa solucionar as defici√™ncias associadas √† implementa√ß√£o de grandes interfaces. <br><br>  Considere a interface <code>Shape</code> : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Shape</span></span> {   drawCircle();   drawSquare();   drawRectangle(); }</code> </pre> <br>  Ele descreve m√©todos para desenhar c√≠rculos ( <code>drawCircle</code> ), quadrados ( <code>drawSquare</code> ) e ret√¢ngulos ( <code>drawRectangle</code> ).  Como resultado, as classes que implementam essa interface e representam formas geom√©tricas individuais, como um c√≠rculo, um quadrado e um ret√¢ngulo, devem conter uma implementa√ß√£o de todos esses m√©todos.  √â assim: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Circle</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Square</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rectangle</span></span></span><span class="hljs-class"> implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> {   drawCircle(){       //...   }   drawSquare(){       //...   }   drawRectangle(){       //...   } }</span></span></code> </pre> <br>  C√≥digo estranho acabou.  Por exemplo, a classe <code>Rectangle</code> representa um ret√¢ngulo implementa m√©todos ( <code>drawCircle</code> e <code>drawSquare</code> ) que ele n√£o precisa.  O mesmo pode ser visto ao analisar o c√≥digo de duas outras classes. <br><br>  Suponha que decidimos adicionar outro m√©todo √† interface <code>Shape</code> , <code>drawTriangle</code> , projetada para desenhar tri√¢ngulos: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Shape</span></span> {   drawCircle();   drawSquare();   drawRectangle();   drawTriangle(); }</code> </pre> <br>  Isso resultar√° em classes que representam formas geom√©tricas espec√≠ficas, al√©m de implementar o m√©todo <code>drawTriangle</code> .  Caso contr√°rio, ocorrer√° um erro. <br><br>  Como voc√™ pode ver, com essa abordagem, √© imposs√≠vel criar uma classe que implemente um m√©todo para gerar um c√≠rculo, mas n√£o implemente m√©todos para derivar um quadrado, ret√¢ngulo e tri√¢ngulo.  Esses m√©todos podem ser implementados para que, quando eles sejam gerados, seja gerado um erro indicando que tal opera√ß√£o n√£o possa ser executada. <br><br>  O princ√≠pio da separa√ß√£o de interface nos adverte contra a cria√ß√£o de interfaces como <code>Shape</code> partir do nosso exemplo.  Clientes (temos as classes <code>Circle</code> , <code>Square</code> e <code>Rectangle</code> ) n√£o devem implementar m√©todos que eles n√£o precisam usar.  Al√©m disso, esse princ√≠pio indica que a interface deve resolver apenas uma tarefa (pois √© semelhante ao princ√≠pio de responsabilidade exclusiva); portanto, tudo o que excede o escopo dessa tarefa deve ser transferido para outra interface ou interfaces. <br><br>  No nosso caso, a interface <code>Shape</code> resolve problemas cuja solu√ß√£o √© necess√°ria para criar interfaces separadas.  Seguindo essa id√©ia, reformulamos o c√≥digo criando interfaces separadas para resolver v√°rias tarefas altamente especializadas: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> </span></span>{   draw(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICircle</span></span></span><span class="hljs-class"> </span></span>{   drawCircle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISquare</span></span></span><span class="hljs-class"> </span></span>{   drawSquare(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IRectangle</span></span></span><span class="hljs-class"> </span></span>{   drawRectangle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ITriangle</span></span></span><span class="hljs-class"> </span></span>{   drawTriangle(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Circle</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICircle</span></span></span><span class="hljs-class"> </span></span>{   drawCircle() {       <span class="hljs-comment"><span class="hljs-comment">//...   } } class Square implements ISquare {   drawSquare() {       //...   } } class Rectangle implements IRectangle {   drawRectangle() {       //...   } } class Triangle implements ITriangle {   drawTriangle() {       //...   } } class CustomShape implements Shape {  draw(){     //...  } }</span></span></code> </pre> <br>  Agora, a interface <code>ICircle</code> usada apenas para desenhar c√≠rculos, bem como outras interfaces especializadas para desenhar outras formas.  A interface <code>Shape</code> pode ser usada como interface universal. <br><br><h2>  <font color="#3AC1EF">Princ√≠pio de Invers√£o de Depend√™ncia</font> </h2><br>  <i><font color="#999999">O objeto da depend√™ncia deve ser uma abstra√ß√£o, n√£o algo espec√≠fico.</font></i> <br><br><ol><li>  Os m√≥dulos de n√≠vel superior n√£o devem depender dos m√≥dulos de n√≠vel inferior.  Ambos os tipos de m√≥dulos devem depender de abstra√ß√µes. </li><li>  As abstra√ß√µes n√£o devem depender dos detalhes.  Os detalhes devem depender de abstra√ß√µes. </li></ol><br>  No processo de desenvolvimento de software, h√° um momento em que a funcionalidade do aplicativo deixa de caber no mesmo m√≥dulo.  Quando isso acontece, temos que resolver o problema das depend√™ncias do m√≥dulo.  Como resultado, por exemplo, pode acontecer que os componentes de alto n√≠vel dependam dos componentes de baixo n√≠vel. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpRequestService</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http</span></span></span><span class="hljs-class"> </span></span>{   constructor(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> xmlhttpService: <span class="hljs-type"><span class="hljs-type">XMLHttpService</span></span>) { }   get(url: string , options: any) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xmlhttpService.request(url,<span class="hljs-symbol"><span class="hljs-symbol">'GE</span></span>T');   }   post() {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xmlhttpService.request(url,<span class="hljs-symbol"><span class="hljs-symbol">'POS</span></span>T');   }   <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Aqui, a classe <code>Http</code> √© um componente de alto n√≠vel e o <code>XMLHttpService</code> √© um componente de baixo n√≠vel.  Essa arquitetura viola a cl√°usula A do princ√≠pio da invers√£o de depend√™ncia: ‚ÄúM√≥dulos de n√≠veis mais altos n√£o devem depender de m√≥dulos de n√≠veis mais baixos.  Ambos os tipos de m√≥dulos devem depender de abstra√ß√µes. ‚Äù <br><br>  A classe <code>Http</code> √© for√ßada a depender da classe <code>XMLHttpService</code> .  Se decidirmos alterar o mecanismo usado pela classe <code>Http</code> para interagir com a rede, digamos que ser√° um servi√ßo Node.js. ou, por exemplo, um servi√ßo stub usado para fins de teste, teremos que editar todas as inst√¢ncias da classe <code>Http</code> alterando o c√≥digo correspondente.  Isso viola o princ√≠pio de abertura-proximidade. <br><br>  A classe <code>Http</code> n√£o deve saber exatamente o que √© usado para estabelecer uma conex√£o de rede.  Portanto, criaremos a interface de <code>Connection</code> : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Connection</span></span> {   request(url: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, opts:any); }</code> </pre> <br>  A interface de <code>Connection</code> cont√©m uma descri√ß√£o do m√©todo de <code>request</code> e passamos o argumento do tipo de <code>Connection</code> para a classe <code>Http</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> httpConnection: Connection) { }   <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url: string , options: any) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpConnection.request(url,<span class="hljs-string"><span class="hljs-string">'GET'</span></span>);   }   post() {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpConnection.request(url,<span class="hljs-string"><span class="hljs-string">'POST'</span></span>);   }   <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Agora, independentemente do que √© usado para organizar a intera√ß√£o com a rede, a classe <code>Http</code> pode usar o que foi passado para ela, sem se preocupar com o que est√° oculto por tr√°s da interface do <code>Connection</code> . <br><br>  <code>XMLHttpService</code> classe <code>XMLHttpService</code> para que ela implemente esta interface: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest();   <span class="hljs-comment"><span class="hljs-comment">//...   request(url: string, opts:any) {       xhr.open();       xhr.send();   } }</span></span></code> </pre> <br>  Como resultado, podemos criar muitas classes que implementam a interface <code>Connection</code> e s√£o adequadas para uso na classe <code>Http</code> para organizar a troca de dados pela rede: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeHttpService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class"> </span></span>{   request(url: string, opts:any) {       <span class="hljs-comment"><span class="hljs-comment">//...   } } class MockHttpService implements Connection {   request(url: string, opts:any) {       //...   } }</span></span></code> </pre> <br>  Como voc√™ pode ver, aqui os m√≥dulos de alto e baixo n√≠vel dependem de abstra√ß√µes.  A classe <code>Http</code> (m√≥dulo de alto n√≠vel) depende da interface de <code>Connection</code> (abstra√ß√£o).  As <code>XMLHttpService</code> , <code>NodeHttpService</code> e <code>MockHttpService</code> (m√≥dulos de baixo n√≠vel) tamb√©m dependem da interface de <code>Connection</code> . <br><br>  Al√©m disso, vale ressaltar que, seguindo o princ√≠pio da invers√£o da depend√™ncia, observamos o princ√≠pio da substitui√ß√£o Barbara Liskov.  Ou seja, os tipos <code>XMLHttpService</code> , <code>NodeHttpService</code> e <code>MockHttpService</code> podem servir como um substituto para o tipo b√°sico <code>Connection</code> . <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Aqui, analisamos cinco princ√≠pios do SOLID que todos os desenvolvedores de OOP devem aderir.  No in√≠cio, isso pode n√£o ser f√°cil, mas se voc√™ se esfor√ßar para isso, refor√ßando os desejos da pr√°tica, esses princ√≠pios se tornar√£o uma parte natural do fluxo de trabalho, que ter√° um enorme impacto positivo na qualidade dos aplicativos e facilitar√° muito o suporte deles. <br><br>  <b>Caros leitores!</b>  Voc√™ usa os princ√≠pios do SOLID em seus projetos? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426413/">https://habr.com/ru/post/pt426413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426401/index.html">Amazon ensinar√° sua IA a definir emo√ß√µes humanas</a></li>
<li><a href="../pt426405/index.html">Hackers no √¢mbito das leis da Federa√ß√£o Russa</a></li>
<li><a href="../pt426407/index.html">Como tornar a viagem para a confer√™ncia o mais in√∫til poss√≠vel</a></li>
<li><a href="../pt426409/index.html">O hacker Alexei, que protege os roteadores MikroTik sem a permiss√£o dos propriet√°rios, tornou-se famoso</a></li>
<li><a href="../pt426411/index.html">Desenvolvendo Classes de Descritores C ++ / CLI</a></li>
<li><a href="../pt426415/index.html">Fintech-digest: controle de digitaliza√ß√£o pelo Banco Central, sal√°rio de criptomoeda, cart√£o Mir em forma de pulseiras e chaveiros</a></li>
<li><a href="../pt426417/index.html">Pavel 2.0: consultor reptil√≥ide em JS, node.js com soquetes e telefonia</a></li>
<li><a href="../pt426419/index.html">M√©todos de sobrecarga ou ponte proibidos em Java</a></li>
<li><a href="../pt426421/index.html">EHCI humanamente em russo</a></li>
<li><a href="../pt426423/index.html">mmWave em smartphones: como a Qualcomm tornou poss√≠vel o imposs√≠vel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>