<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê´ üòæ üåï Am√©lioration de la mise en cache des gestionnaires d'√©v√©nements et des performances des applications React üèø üìµ ü•Ç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, nous publions une traduction du mat√©riel, dont l'auteur, apr√®s avoir analys√© les caract√©ristiques du travail avec des objets en JavaScrip...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Am√©lioration de la mise en cache des gestionnaires d'√©v√©nements et des performances des applications React</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426053/">  Aujourd'hui, nous publions une traduction du mat√©riel, dont l'auteur, apr√®s avoir analys√© les caract√©ristiques du travail avec des objets en JavaScript, propose aux d√©veloppeurs de React une m√©thodologie pour acc√©l√©rer les applications.  En particulier, nous parlons du fait qu'une variable, qui, comme on dit, est "affect√©e √† un objet", et qui est souvent appel√©e simplement "objet", en fait, ne stocke pas l'objet lui-m√™me, mais un lien vers celui-ci.  Les fonctions en JavaScript sont √©galement des objets, donc ce qui pr√©c√®de est vrai pour eux.  Gardant cela √† l'esprit, la conception de composants React et l'analyse critique de leur code peuvent am√©liorer leurs m√©canismes internes et am√©liorer les performances des applications. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54f/6b5/80a/54f6b580affe2d9741da8207f93b4746.png"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Fonctionnalit√©s de travail avec des objets en JavaScript</font> </h2><br>  Si vous cr√©ez quelques fonctions qui se ressemblent exactement et que vous essayez de les comparer, il s'av√®re qu'elles sont diff√©rentes du point de vue du syst√®me.  Afin de v√©rifier cela, vous pouvez ex√©cuter le code suivant: <br><br><pre><code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionOne = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionTwo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; functionOne === functionTwo; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Essayons maintenant d'affecter une variable √† une fonction existante d√©j√† affect√©e √† une autre variable et comparons ces deux variables: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionThree = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionFour = functionThree; functionThree === functionFour; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Comme vous pouvez le voir, avec cette approche, l'op√©rateur d'√©galit√© stricte renvoie <code>true</code> . <br>  Les objets se comportent naturellement de la m√™me mani√®re: <br><br><pre> <code class="hljs julia"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object1 === object2; // <span class="hljs-literal"><span class="hljs-literal">false</span></span> object1 === object3; // <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Ici, nous parlons de JavaScript, mais si vous avez de l'exp√©rience dans le d√©veloppement dans d'autres langues, vous connaissez peut-√™tre le concept de pointeurs.  Dans le code ci-dessus, chaque fois qu'un objet est cr√©√©, une partie de la m√©moire syst√®me lui est allou√©e.  Lorsque nous utilisons une commande de la forme <code>object1 = {}</code> , cela conduit √† remplir avec certaines donn√©es un morceau de m√©moire allou√© sp√©cifiquement pour <code>object1</code> . <br><br>  Il est tout √† fait possible d'imaginer <code>object1</code> comme l'adresse √† laquelle les structures de donn√©es li√©es √† l'objet sont situ√©es en m√©moire.  L'ex√©cution de la commande <code>object2 = {}</code> conduit √† l'allocation d'une autre zone m√©moire, con√ßue sp√©cifiquement pour <code>object2</code> .  <code>obect1</code> et <code>obect1</code> sont- <code>obect1</code> <code>object2</code> dans la m√™me zone de m√©moire?  Non, chacun d'eux a son propre complot.  C'est pourquoi lorsque nous essayons de comparer <code>object1</code> et <code>object1</code> <code>object2</code> nous obtenons <code>false</code> .  Ces objets peuvent avoir une structure identique, mais les adresses dans la m√©moire o√π ils se trouvent diff√®rent, et ce sont les adresses qui sont v√©rifi√©es lors de la comparaison. <br><br>  En ex√©cutant la commande <code>object3 = object1</code> , nous √©crivons l'adresse de <code>object1</code> dans la constante <code>object3</code> .  Ce n'est pas un nouvel objet.  Cette constante se voit attribuer l'adresse d'un objet existant.  Vous pouvez le v√©rifier en: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { x: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object3.x = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; object1.x; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Dans cet exemple, un objet est cr√©√© en m√©moire et son adresse est √©crite dans la constante <code>object1</code> .  Ensuite, la m√™me adresse est √©crite dans la constante <code>object3</code> .  Changer <code>object3</code> change l'objet en m√©moire.  Cela signifie que lorsque vous acc√©dez √† un objet en utilisant toute autre r√©f√©rence √† celui-ci, par exemple celui stock√© dans <code>object1</code> , nous travaillerons d√©j√† avec sa version modifi√©e. <br><br><h2>  <font color="#3AC1EF">Fonctions, objets et r√©action</font> </h2><br>  La m√©connaissance du m√©canisme ci-dessus par les d√©veloppeurs novices conduit souvent √† des erreurs et, peut-√™tre, la prise en compte des fonctionnalit√©s de travail avec des objets m√©rite un article s√©par√©.  Cependant, notre sujet aujourd'hui est la performance des applications React.  Dans ce domaine, des erreurs peuvent √™tre commises m√™me par des d√©veloppeurs assez exp√©riment√©s qui ne font tout simplement pas attention √† la fa√ßon dont les applications React sont affect√©es par le fait que les variables et les constantes JavaScript ne sont pas stock√©es dans les objets eux-m√™mes, mais seulement des liens vers eux. <br><br>  Qu'est-ce que cela a √† voir avec React?  React dispose de m√©canismes intelligents pour √©conomiser les ressources syst√®me visant √† am√©liorer les performances des applications: si les propri√©t√©s et l'√©tat du composant ne changent pas, alors ce que la fonction de <code>render</code> ne change pas.  √âvidemment, si le composant reste le m√™me, il n'a pas besoin d'√™tre rendu √† nouveau.  Si rien ne change, la fonction de <code>render</code> retournera la m√™me chose qu'avant, il n'est donc pas n√©cessaire de l'ex√©cuter.  Ce m√©canisme rend React rapide.  Quelque chose ne s'affiche que lorsque cela est n√©cessaire. <br><br>  React v√©rifie l'√©galit√© des propri√©t√©s et de l'√©tat des composants √† l'aide de fonctionnalit√©s JavaScript standard, c'est-√†-dire qu'il les compare simplement √† l'aide de l'op√©rateur <code>==</code> .  React n'effectue pas de comparaison ¬´superficielle¬ª ou ¬´profonde¬ª d'objets afin de d√©terminer leur √©galit√©.  Une ¬´comparaison superficielle¬ª est un concept utilis√© pour d√©crire une comparaison de chaque paire cl√©-valeur d'un objet, par opposition √† une comparaison dans laquelle seules les adresses des objets en m√©moire sont compar√©es (r√©f√©rences √† celles-ci).  La comparaison ¬´profonde¬ª des objets va encore plus loin, et si les valeurs des propri√©t√©s compar√©es des objets sont √©galement des objets, elles comparent √©galement les paires cl√©-valeur de ces objets.  Ce processus est r√©p√©t√© pour tous les objets imbriqu√©s dans d'autres objets.  React ne fait rien de tel, v√©rifiant simplement l'√©galit√© des liens. <br><br>  Si, par exemple, vous modifiez la propri√©t√© d'un composant repr√©sent√© par un objet de la forme <code>{ x: 1 }</code> en un autre objet qui a exactement la m√™me apparence, React restitue le composant, car ces objets se trouvent dans diff√©rentes zones de m√©moire.  Si vous vous souvenez de l'exemple ci-dessus, alors, lorsque vous changez les propri√©t√©s d'un composant d' <code>object1</code> en <code>object3</code> , React ne restitue pas un tel composant, car les constantes <code>object1</code> et <code>object3</code> font r√©f√©rence au m√™me objet. <br><br>  L'utilisation des fonctions en JavaScript est organis√©e exactement de la m√™me mani√®re.  Si React rencontre les m√™mes fonctionnalit√©s dont les adresses sont diff√©rentes, il sera restitu√©.  Si la ¬´nouvelle fonction¬ª n'est qu'un lien vers une fonction qui a d√©j√† √©t√© utilis√©e, il n'y aura pas de nouveau rendu. <br><br><h2>  <font color="#3AC1EF">Un probl√®me typique lors de l'utilisation de composants</font> </h2><br>  Voici l'un des sc√©narios de travail avec des composants, qui, malheureusement, me revient constamment √† l'esprit lors de la v√©rification du code de quelqu'un d'autre: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert('!')} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Devant nous est un composant tr√®s simple.  Il s'agit d'un bouton, lorsque vous cliquez dessus, une notification s'affiche.  √Ä c√¥t√© du bouton sont affich√©es des instructions pour son utilisation, informant l'utilisateur s'il doit appuyer sur ce bouton.  Contr√¥lez quelle instruction sera affich√©e en d√©finissant la <code>SomeComponent</code> <code>do</code> ( <code>do={true}</code> ou <code>do={false}</code> ) <code>SomeComponent</code> . <br><br>  Chaque fois que le composant <code>SomeComponent</code> est restitu√© (lorsque la valeur de la propri√©t√© <code>do</code> passe de <code>true</code> √† <code>false</code> et vice versa), l'√©l√©ment <code>Button</code> est √©galement rendu.  Le gestionnaire <code>onClick</code> , bien qu'il soit toujours le m√™me, est recr√©√© √† chaque appel de la fonction de <code>render</code> .  Par cons√©quent, il s'av√®re que chaque fois que le composant est affich√© en m√©moire, une nouvelle fonction est cr√©√©e, puisque sa cr√©ation est effectu√©e dans la fonction de <code>render</code> , un lien vers la nouvelle adresse en m√©moire est transmis √† <code>&lt;Button /&gt;</code> , et le composant <code>Button</code> est √©galement rendu √† nouveau, malgr√© le fait que dans rien n'a chang√© du tout. <br><br>  Parlons de la fa√ßon de le r√©parer. <br><br><h2>  <font color="#3AC1EF">R√©solution de probl√®mes</font> </h2><br>  Si la fonction est ind√©pendante du composant ( <code>this</code> contexte), vous pouvez la d√©finir en dehors du composant.  Toutes les instances du composant utiliseront la m√™me r√©f√©rence de fonction, car dans tous les cas, ce sera la m√™me fonction.  Voici √† quoi √ßa ressemble: <br><br><pre> <code class="hljs scala">const createAlertBox = () =&gt; alert('!'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Contrairement √† l'exemple pr√©c√©dent, <code>createAlertBox</code> , avec chaque appel √† <code>render</code> , contiendra le m√™me lien vers la m√™me zone en m√©moire.  Par cons√©quent, <code>Button</code> sortie r√©p√©t√©e <code>Button</code> ne sera pas ex√©cut√©e. <br><br>  Alors que le composant <code>Button</code> est petit et rendu rapidement, le probl√®me d√©crit ci-dessus associ√© √† la d√©claration interne des fonctions peut √©galement √™tre trouv√© dans les grands composants complexes qui prennent beaucoup de temps √† rendre.  Cela peut ralentir consid√©rablement l'application React.  √Ä cet √©gard, il est logique de suivre la recommandation, selon laquelle de telles fonctions ne devraient jamais √™tre d√©clar√©es dans la m√©thode de <code>render</code> . <br><br>  Si la fonction d√©pend du composant, c'est-√†-dire qu'elle ne peut pas √™tre d√©finie en dehors de celui-ci, la m√©thode du composant peut √™tre pass√©e en tant que gestionnaire d'√©v√©nements: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ createAlertBox = () =&gt; {   alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message); }; get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Dans ce cas, dans chaque instance de <code>SomeComponent</code> lorsque vous cliquez sur le bouton, divers messages s'affichent.  Le gestionnaire d'√©v√©nements de l'√©l√©ment <code>Button</code> doit √™tre unique √† <code>SomeComponent</code> .  Lors du passage de la m√©thode <code>cteateAlertBox</code> , peu importe si <code>SomeComponent</code> restitu√©.  Peu importe si la propri√©t√© du <code>message</code> a chang√©.  L'adresse de la fonction <code>createAlertBox</code> change pas, ce qui signifie que l'√©l√©ment <code>Button</code> ne doit pas √™tre restitu√©.  Gr√¢ce √† cela, vous pouvez √©conomiser des ressources syst√®me et am√©liorer la vitesse de rendu de l'application. <br><br>  Tout cela est bien.  Mais que faire si les fonctions sont dynamiques? <br><br><h2>  <font color="#3AC1EF">R√©soudre un probl√®me plus complexe</font> </h2><br>  <i>L'auteur de ce document vous demande de pr√™ter attention au fait qu'il a pr√©par√© les exemples de cette section, en prenant la premi√®re chose qui lui est venue √† l'esprit, appropri√©e pour illustrer la r√©utilisation des fonctions.</i>  <i>Ces exemples sont destin√©s √† aider le lecteur √† saisir l'essence de l'id√©e.</i>  <i>Bien que cette section soit recommand√©e √† la lecture pour comprendre l'essence de ce qui se passe, l'auteur conseille de pr√™ter attention aux commentaires sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article original</a> , car certains lecteurs ont sugg√©r√© de meilleures versions des m√©canismes discut√©s ici, qui prennent en compte les fonctionnalit√©s d'invalidation du cache et les m√©canismes de gestion de la m√©moire int√©gr√©s dans React.</i> <br><br>  Ainsi, il est extr√™mement courant que dans un composant, il existe de nombreux gestionnaires d'√©v√©nements dynamiques uniques, par exemple, quelque chose de similaire peut √™tre vu dans le code, o√π la m√©thode de tableau de <code>map</code> est utilis√©e dans la m√©thode de <code>render</code> : <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;ul&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</code> </pre> <br>  Ici, un nombre diff√©rent de boutons sera affich√© et un nombre diff√©rent de gestionnaires d'√©v√©nements seront cr√©√©s, chacun √©tant repr√©sent√© par une fonction unique, et, √† l'avance, lors de la cr√©ation de <code>SomeComponent</code> , on ne sait pas quelles seront ces fonctions.  Comment r√©soudre ce puzzle? <br><br>  Ici, la m√©morisation nous aidera, ou, plus simplement, la mise en cache.  Pour chaque valeur unique, cr√©ez une fonction et placez-la dans le cache.  Si cette valeur unique se reproduit, il suffira de prendre dans le cache la fonction qui lui correspond, qui √©tait auparavant plac√©e dans le cache. <br><br>  Voici √† quoi ressemble la mise en ≈ìuvre de cette id√©e: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    SomeComponent        //   . clickHandlers = {}; //       //    . getClickHandler(key) {   //       ,  .   if (!Object.prototype.hasOwnProperty.call(this.clickHandlers, key)) {     this.clickHandlers[key] = () =&gt; alert(key);   }   return this.clickHandlers[key]; } render() {   return (     &lt;ul&gt;       {this.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;Button onClick={this.getClickHandler(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</span></span></code> </pre> <br>  Chaque √©l√©ment du tableau est trait√© par la m√©thode <code>getClickHandler</code> .  Cette m√©thode, la premi√®re fois qu'elle sera appel√©e avec une certaine valeur, cr√©era une fonction unique √† cette valeur, la placera dans le cache et la renverra.  Tous les appels ult√©rieurs √† cette m√©thode, en lui passant la m√™me valeur, la feront simplement renvoyer un lien vers la fonction √† partir du cache. <br><br>  Par cons√©quent, le nouveau rendu de <code>SomeComponent</code> ne rendra pas le <code>Button</code> .  De m√™me, l'ajout d'√©l√©ments √† la propri√©t√© <code>list</code> cr√©era dynamiquement des gestionnaires d'√©v√©nements pour chaque bouton. <br><br>  Vous devrez √™tre cr√©atif dans la cr√©ation d'identifiants uniques pour les gestionnaires s'ils sont d√©finis par plusieurs variables, mais ce n'est pas beaucoup plus compliqu√© que la cr√©ation habituelle d'une propri√©t√© de <code>key</code> unique pour chaque objet JSX obtenu √† la suite de la m√©thode <code>map</code> . <br><br>  Ici, je voudrais vous mettre en garde contre d'√©ventuels probl√®mes d'utilisation d'index de tableau comme identificateurs.  Le fait est qu'avec cette approche, vous pouvez rencontrer des erreurs si l'ordre des √©l√©ments du tableau change ou si certains de ses √©l√©ments sont supprim√©s.  Ainsi, par exemple, si au d√©but un tableau similaire ressemblait √† <code>[ 'soda', 'pizza' ]</code> , puis transform√© en <code>[ 'pizza' ]</code> , et que vous mettiez en cache les gestionnaires d'√©v√©nements √† l'aide d'une commande de la forme <code>listeners[0] = () =&gt; alert('soda')</code> , vous constaterez que lorsque l'utilisateur clique sur le bouton auquel le gestionnaire avec l'identifiant 0 est affect√© et qui, conform√©ment au contenu du tableau <code>[ 'pizza' ]</code> , devrait afficher un message de <code>pizza</code> , un message de <code>soda</code> sera affich√©.  Pour la m√™me raison, il n'est pas recommand√© d'utiliser des indices de tableau comme propri√©t√©s de cl√©. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Dans cet article, nous avons examin√© les fonctionnalit√©s des m√©canismes internes JavaScript, en envisageant la possibilit√© d'acc√©l√©rer le rendu des applications React.  Nous esp√©rons que les id√©es pr√©sent√©es ici vous seront utiles. <br><br>  <b>Chers lecteurs!</b>  Si vous connaissez des moyens int√©ressants d'optimiser les applications React, partagez-les. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426053/">https://habr.com/ru/post/fr426053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426039/index.html">Lancement d'urgence "Soyouz MS-10" (√©quipage sauv√©, retransmis)</a></li>
<li><a href="../fr426041/index.html">Solution symbolique d'√©quations et de syst√®mes diff√©rentiels lin√©aires par la m√©thode de transformation de Laplace utilisant SymPy</a></li>
<li><a href="../fr426045/index.html">Exceptions sp√©ciales dans .NET et comment les pr√©parer</a></li>
<li><a href="../fr426047/index.html">10 grands livres pour d√©butants en anglais</a></li>
<li><a href="../fr426051/index.html">Am√©liorer les comp√©tences de d√©bogage de logiciels - quelques conseils</a></li>
<li><a href="../fr426055/index.html">TensorFlow.js et clmtrackr.js: suivre la direction du regard de l'utilisateur dans le navigateur</a></li>
<li><a href="../fr426059/index.html">Meetup Tutu PHP # 2: Vid√©o des discours</a></li>
<li><a href="../fr426061/index.html">Microsoft rejoint le r√©seau Open Invention et octroie 60 000 licences</a></li>
<li><a href="../fr426063/index.html">Innovations de baies d'entr√©e de gamme HPE MSA: baie flash plus abordable et int√©gration de solutions riches</a></li>
<li><a href="../fr426065/index.html">Smart TV, qui d√©termine elle-m√™me la cha√Æne la plus int√©ressante, ou une solution inhabituelle de Sudoku pour le contenu vid√©o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>