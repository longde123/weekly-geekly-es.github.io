<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🚒 🏳️‍🌈 🙅🏼 Manual Node.js, Bagian 7: Pemrograman Asinkron 🌀 👨‍🚒 😗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini, dalam terjemahan bagian ketujuh dari manual Node.js, kita akan berbicara tentang pemrograman asinkron, mempertimbangkan masalah-masalah sepe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manual Node.js, Bagian 7: Pemrograman Asinkron</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424555/">  Hari ini, dalam terjemahan bagian ketujuh dari manual Node.js, kita akan berbicara tentang pemrograman asinkron, mempertimbangkan masalah-masalah seperti penggunaan panggilan balik, janji-janji dan konstruk async / menunggu, dan membahas cara bekerja dengan acara. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Kami menyarankan Anda untuk membaca] Bagian lain dari siklus ini</b> <div class="spoiler_text">  Bagian 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Informasi Umum dan Memulai</a> <br>  Bagian 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaScript, V8, beberapa trik pengembangan</a> <br>  Bagian 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hosting, REPL, bekerja dengan konsol, modul</a> <br>  Bagian 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm, package.json dan file package-lock.json</a> <br>  Bagian 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npm dan npx</a> <br>  Bagian 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">loop acara, tumpukan panggilan, timer</a> <br>  Bagian 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrograman Asinkron</a> <br>  Bagian 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Node.js, Bagian 8: HTTP dan Protokol WebSocket</a> <br>  Bagian 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Node.js, bagian 9: bekerja dengan sistem file</a> <br>  Bagian 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Node.js, Bagian 10: Modul Standar, Streaming, Database, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF lengkap dari Node.js Guide</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Sinkronisasi dalam bahasa pemrograman</font> </h2><br>  JavaScript sendiri adalah bahasa pemrograman sinkron dan berulir tunggal.  Ini berarti Anda tidak dapat membuat utas baru dalam kode yang berjalan secara paralel.  Namun, komputer pada dasarnya asinkron.  Artinya, tindakan tertentu dapat dilakukan terlepas dari aliran eksekusi program utama.  Di komputer modern, setiap program dialokasikan sejumlah waktu prosesor tertentu, ketika waktu ini habis, sistem memberikan sumber daya ke program lain, juga untuk sementara waktu.  Pergantian tersebut dilakukan secara siklis, dilakukan dengan sangat cepat sehingga seseorang tidak dapat melihatnya, karena itu, kami berpikir bahwa komputer kami menjalankan banyak program secara bersamaan.  Tapi ini ilusi (belum lagi mesin multiprosesor). <br><br>  Dalam isi program, interupsi digunakan - sinyal dikirimkan ke prosesor dan memungkinkan untuk menarik perhatian sistem.  Kami tidak akan masuk ke perincian, yang paling penting adalah untuk mengingat bahwa perilaku asinkron ketika sebuah program dijeda hingga membutuhkan sumber daya prosesor sepenuhnya normal.  Pada saat program tidak memuat sistem dengan pekerjaan, komputer dapat memecahkan masalah lain.  Misalnya, dengan pendekatan ini, ketika suatu program menunggu respons terhadap permintaan jaringan yang dibuat untuknya, ia tidak memblokir prosesor hingga respons diterima. <br><br>  Sebagai aturan, bahasa pemrograman asinkron, beberapa dari mereka memberi programmer kemampuan untuk mengontrol mekanisme asinkron, baik menggunakan alat bahasa bawaan atau perpustakaan khusus.  Kita berbicara tentang bahasa seperti C, Java, C #, PHP, Go, Ruby, Swift, Python.  Beberapa di antaranya memungkinkan Anda memprogram dalam gaya asinkron, menggunakan utas, memulai proses baru. <br><br><h2>  <font color="#3AC1EF">Asynchrony JavaScript</font> </h2><br>  Seperti yang telah disebutkan, JavaScript adalah bahasa sinkron utas tunggal.  Garis-garis kode yang ditulis dalam JS dieksekusi dalam urutan di mana mereka muncul dalam teks, satu demi satu.  Misalnya, di sini adalah program JS yang sangat normal yang menunjukkan perilaku ini: <br><br><pre><code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a * b console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(c) doSomething()</code> </pre> <br>  Tetapi JavaScript dibuat untuk digunakan di browser.  Tugas utamanya, pada awalnya, adalah mengatur pemrosesan acara yang terkait dengan aktivitas pengguna.  Misalnya, ini adalah acara seperti <code>onClick</code> , <code>onMouseOver</code> , <code>onChange</code> , <code>onSubmit</code> , dan sebagainya.  Bagaimana mengatasi masalah seperti itu dalam kerangka model pemrograman sinkron? <br><br>  Jawabannya terletak pada lingkungan di mana JavaScript berjalan.  Yaitu, browser memungkinkan Anda untuk secara efektif menyelesaikan masalah seperti itu, memberikan programmer API yang sesuai. <br><br>  Di lingkungan Node.js ada alat untuk melakukan I / O non-blocking, seperti bekerja dengan file, mengatur pertukaran data melalui jaringan, dan sebagainya. <br><br><h2>  <font color="#3AC1EF">Telepon balik</font> </h2><br>  Jika kita berbicara tentang JavaScript berbasis browser, dapat dicatat bahwa tidak mungkin untuk mengetahui terlebih dahulu ketika pengguna mengklik tombol.  Untuk memastikan bahwa sistem merespons peristiwa semacam itu, pawang dibuat untuk itu. <br><br>  Pengatur kejadian menerima fungsi yang akan dipanggil ketika acara tersebut terjadi.  Ini terlihat seperti ini: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    })</code> </pre> <br>  Fungsi seperti ini juga disebut fungsi callback atau panggilan balik. <br><br>  Panggilan balik adalah fungsi biasa yang diteruskan sebagai nilai ke fungsi lain.  Ini akan dipanggil hanya ketika suatu peristiwa tertentu terjadi.  JavaScript mengimplementasikan konsep fungsi kelas satu.  Fungsi semacam itu dapat ditugaskan ke variabel dan diteruskan ke fungsi lain (disebut fungsi tingkat tinggi). <br><br>  Pendekatan pengembangan JavaScript sisi klien tersebar luas ketika semua kode klien dibungkus dengan pendengar peristiwa <code>load</code> objek <code>window</code> , yang memanggil panggilan balik yang diteruskan setelah halaman siap untuk bekerja: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     })</code> </pre> <br>  Callback digunakan di mana-mana, dan tidak hanya untuk menangani acara DOM.  Misalnya, kami telah bertemu dengan penggunaannya dalam timer: <br><br><pre> <code class="hljs javascript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Permintaan XHR</a> juga menggunakan callback.  Dalam hal ini, sepertinya menetapkan fungsi ke properti yang sesuai.  Fungsi serupa akan dipanggil ketika peristiwa tertentu terjadi.  Dalam contoh berikut, peristiwa semacam itu adalah perubahan status permintaan: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest() xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {   xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(xhr.responseText) : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'error'</span></span>) } } xhr.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://yoursite.com'</span></span>) xhr.send()</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Kesalahan dalam menangani panggilan balik</font> </h3><br>  Mari kita bicara tentang cara menangani kesalahan dalam panggilan balik.  Ada satu strategi umum untuk menangani kesalahan seperti itu, yang juga digunakan di Node.js.  Terdiri dari fakta bahwa parameter pertama dari setiap fungsi panggilan balik adalah objek kesalahan.  Jika tidak ada kesalahan, <code>null</code> akan ditulis ke parameter ini.  Jika tidak, akan ada objek kesalahan yang berisi uraiannya dan informasi tambahan tentangnya.  Begini tampilannya: <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/file.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Masalah panggilan balik</font> </h3><br>  Panggilan balik mudah digunakan dalam situasi sederhana.  Namun, setiap panggilan balik adalah level tambahan kode yang bersarang.  Jika beberapa panggilan balik bersarang digunakan, ini dengan cepat menyebabkan komplikasi yang signifikan dari struktur kode: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     items.forEach(item =&gt; {       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,  -      })   }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) }) })</code> </pre> <br>  Dalam contoh ini, hanya 4 level kode yang ditampilkan, tetapi dalam praktiknya seseorang dapat menemukan sejumlah besar level, biasanya disebut "panggilan balik neraka".  Anda dapat mengatasi masalah ini menggunakan konstruksi bahasa lain. <br><br><h2>  <font color="#3AC1EF">Janji dan async / menunggu</font> </h2><br>  Dimulai dengan standar ES6, JavaScript memperkenalkan fitur-fitur baru yang membuatnya lebih mudah untuk menulis kode asinkron, menghilangkan kebutuhan akan callback.  Kita berbicara tentang janji-janji yang muncul di ES6, dan konstruk async / menunggu yang muncul di ES8. <br><br><h3>  <font color="#3AC1EF">▍ Janji</font> </h3><br>  Janji (objek janji) adalah salah satu cara untuk bekerja dengan konstruksi perangkat lunak asinkron dalam JavaScript, yang, secara umum, mengurangi penggunaan panggilan balik. <br><br><h4>  Kenalan dengan Janji </h4><br>  Janji-janji biasanya didefinisikan sebagai objek proxy untuk nilai-nilai tertentu, yang penampilannya diharapkan di masa depan.  Janji juga disebut "janji" atau "hasil yang dijanjikan."  Meskipun konsep ini telah ada selama bertahun-tahun, janji-janji dibakukan dan ditambahkan ke bahasa hanya di ES2015.  Dalam ES2017, desain async / menunggu, yang didasarkan pada janji, dan yang dapat dianggap sebagai pengganti yang mudah digunakan, telah muncul.  Oleh karena itu, bahkan jika Anda tidak berencana untuk menggunakan janji-janji biasa, pemahaman tentang bagaimana mereka bekerja adalah penting untuk penggunaan yang efektif dari async / menunggu konstruksi <br><br><h4>  Cara kerja janji </h4><br>  Setelah janji dipanggil, itu masuk ke status tertunda.  Ini berarti bahwa fungsi yang menyebabkan janji terus dieksekusi, sementara beberapa perhitungan dilakukan dalam janji, setelah itu janji menginformasikan tentang hal itu.  Jika operasi yang dilakukan oleh janji selesai dengan sukses, maka janji tersebut ditransfer ke negara yang dipenuhi.  Janji semacam itu dikatakan berhasil diselesaikan.  Jika operasi selesai dengan kesalahan, janji ditempatkan di negara yang ditolak. <br><br>  Mari kita bicara tentang bekerja dengan janji. <br><br><h4>  Buat Janji </h4><br>  API untuk bekerja dengan janji memberi kita konstruktor yang sesuai, yang dipanggil oleh perintah dari bentuk <code>new Promise()</code> .  Begini caranya janji dibuat: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (done) {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workDone = <span class="hljs-string"><span class="hljs-string">'Here is the thing I built'</span></span>     resolve(workDone)   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> why = <span class="hljs-string"><span class="hljs-string">'Still working on something else'</span></span>     reject(why)   } } )</code> </pre> <br>  Promis memeriksa konstanta global yang <code>done</code> , dan jika nilainya <code>true</code> , ia berhasil diselesaikan.  Kalau tidak, janji itu ditolak.  Menggunakan parameter <code>resolve</code> dan <code>reject</code> , yang merupakan fungsi, kita dapat mengembalikan nilai dari janji.  Dalam hal ini, kami mengembalikan string, tetapi di sini objek dapat digunakan. <br><br><h4>  Bekerja dengan Janji </h4><br>  Kami menciptakan janji di atas, sekarang pertimbangkan untuk bekerja dengannya.  Ini terlihat seperti ini: <br><br><pre> <code class="hljs coffeescript">const isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... ) const checkIfItsDone = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { isItDoneYet   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ok)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ok)   })   .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   }) } checkIfItsDone()</code> </pre> <br>  Memanggil <code>checkIfItsDone()</code> akan mengarah pada pelaksanaan <code>isItDoneYet()</code> isItDoneYet <code>isItDoneYet()</code> dan organisasi yang menunggu penyelesaiannya.  Jika janji berhasil diselesaikan, panggilan balik yang dilewati ke metode <code>.then()</code> akan berfungsi.  Jika kesalahan terjadi, yaitu, janji itu akan ditolak, itu bisa diproses dalam fungsi yang diteruskan ke metode <code>.catch()</code> . <br><br><h4>  Janji-janji Rantai </h4><br>  Metode janji mengembalikan janji, yang memungkinkan Anda untuk menggabungkannya menjadi rantai.  Contoh yang baik dari perilaku ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ambil API</a> berbasis browser, yang merupakan lapisan abstraksi atas <code>XMLHttpRequest</code> .  Ada paket npm yang cukup populer untuk Node.js yang mengimplementasikan Fetch API, yang akan kita bahas nanti.  API ini dapat digunakan untuk memuat sumber daya jaringan tertentu dan, berkat kemungkinan menggabungkan janji dalam rantai, untuk mengatur pemrosesan selanjutnya dari data yang diunduh.  Bahkan, saat Anda memanggil API Ambil melalui panggilan ke fungsi <code>fetch()</code> , sebuah janji dibuat. <br><br>  Pertimbangkan contoh janji perantaraan berikut: <br><br><pre> <code class="hljs coffeescript">const fetch = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'node-fetch'</span></span>) const status = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.status &gt;= <span class="hljs-number"><span class="hljs-number">200</span></span> &amp;&amp; response.status &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolve(response) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(response.statusText)) } const json = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json() fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(status) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(json) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request succeeded with JSON response'</span></span>, data) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request failed'</span></span>, error) })</code> </pre> <br>  Di sini kita menggunakan paket npm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">node-fetch</a> dan sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jsonplaceholder.typicode.com</a> sebagai sumber data JSON. <br><br>  Dalam contoh ini, fungsi <code>fetch()</code> digunakan untuk memuat item daftar TODO menggunakan rantai janji.  Setelah mengeksekusi <code>fetch()</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">respons</a> dikembalikan yang memiliki banyak properti, di antaranya kami tertarik pada yang berikut: <br><br><ul><li>  <code>status</code> adalah nilai numerik yang mewakili kode status HTTP. </li><li>  <code>statusText</code> - deskripsi tekstual dari kode status HTTP, yang diwakili oleh string <code>OK</code> jika permintaan berhasil. </li></ul><br>  Objek <code>response</code> memiliki metode <code>json()</code> yang mengembalikan janji, setelah resolusi yang konten diproses dari badan permintaan disajikan, disajikan dalam format JSON. <br><br>  Dengan penjelasan di atas, kami menjelaskan apa yang terjadi dalam kode ini.  Janji pertama dalam rantai diwakili oleh fungsi <code>status()</code> yang kami umumkan, yang memeriksa status respons, dan jika itu menunjukkan bahwa permintaan gagal (yaitu, kode status HTTP tidak dalam kisaran antara 200 dan 299), janji itu ditolak.  Operasi ini mengarah pada fakta bahwa ekspresi <code>.catch()</code> lainnya dalam rantai janji tidak dieksekusi dan kami segera sampai ke metode <code>.catch()</code> , menghasilkan ke konsol, bersama dengan pesan kesalahan, teks <code>Request failed</code> . <br><br>  Jika kode status HTTP cocok untuk kita, fungsi <code>json()</code> dideklarasikan oleh kita disebut.  Karena janji sebelumnya, jika berhasil diselesaikan, mengembalikan objek <code>response</code> , kami menggunakannya sebagai nilai input untuk janji kedua. <br><br>  Dalam hal ini, kami mengembalikan data JSON yang diproses, sehingga janji ketiga menerimanya, setelah itu, didahului oleh pesan bahwa sebagai hasil dari permintaan itu mungkin untuk mendapatkan data yang diperlukan, ditampilkan di konsol. <br><br><h4>  Menangani kesalahan </h4><br>  Dalam contoh sebelumnya, kami memiliki metode <code>.catch()</code> yang melekat pada rantai janji.  Jika sesuatu dalam rantai janji salah dan terjadi kesalahan, atau jika salah satu janji ternyata ditolak, kontrol ditransfer ke ekspresi terdekat <code>.catch()</code> .  Inilah situasi ketika kesalahan terjadi dalam sebuah janji: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Berikut adalah contoh pemicu <code>.catch()</code> setelah menolak janji: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br><h4>  Penanganan kesalahan Cascading </h4><br>  Bagaimana jika terjadi kesalahan dalam ekspresi <code>.catch()</code> ?  Untuk menangani kesalahan ini, Anda bisa memasukkan ekspresi <code>.catch()</code> di rantai janji (dan kemudian Anda bisa melampirkan ekspresi <code>.catch()</code> ke rantai sesuai kebutuhan): <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Sekarang mari kita lihat beberapa metode berguna yang digunakan untuk mengelola janji. <br><br><h4>  Promise.all () </h4><br>  Jika Anda perlu melakukan beberapa tindakan setelah menyelesaikan beberapa janji, Anda bisa melakukan ini menggunakan perintah <code>Promise.all()</code> .  Pertimbangkan sebuah contoh: <br><br><pre> <code class="hljs coffeescript">const f1 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/1'</span></span>) const f2 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/2'</span></span>) Promise.all([f1, f2]).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Array of results'</span></span>, res) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Di ES2015, sintaks penugasan destruktif telah muncul, dengan menggunakannya, Anda dapat membuat konstruksi dari formulir berikut: <br><br><pre> <code class="hljs powershell">Promise.all([<span class="hljs-type"><span class="hljs-type">f1</span></span>, <span class="hljs-type"><span class="hljs-type">f2</span></span>]).then(([<span class="hljs-type"><span class="hljs-type">res1</span></span>, <span class="hljs-type"><span class="hljs-type">res2</span></span>]) =&gt; {   console.log(<span class="hljs-string"><span class="hljs-string">'Results'</span></span>, res1, res2) })</code> </pre> <br>  Di sini, sebagai contoh, kami mempertimbangkan Ambil API, tetapi <code>Promise.all()</code> , tentu saja, memungkinkan Anda untuk bekerja dengan janji apa pun. <br><br><h4>  Promise.race () </h4><br>  Perintah <code>Promise.race()</code> memungkinkan Anda untuk melakukan tindakan yang ditentukan setelah salah satu dari janji yang dijatuhkan kepadanya diselesaikan.  Callback terkait yang berisi hasil dari janji pertama ini disebut hanya sekali.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">'first'</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'second'</span></span>) }) <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([first, second]).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">// second })</span></span></code> </pre> <br><h4>  Kesalahan TypeError yang tidak tertangkap yang terjadi saat bekerja dengan janji </h4><br>  Jika, ketika bekerja dengan janji-janji, Anda menemukan <code>Uncaught TypeError: undefined is not a promise</code> kesalahan <code>Uncaught TypeError: undefined is not a promise</code> , pastikan bahwa konstruk <code>new Promise()</code> digunakan bukan hanya <code>Promise()</code> saat membuat janji. <br><br><h3>  <font color="#3AC1EF">▍ async / tunggu desain</font> </h3><br>  Konstruksi async / await adalah pendekatan modern untuk pemrograman asinkron, yang menyederhanakannya.  Fungsi asinkron dapat direpresentasikan sebagai kombinasi dari janji dan generator, dan, secara umum, konstruksi ini adalah abstraksi atas janji. <br><br>  Desain async / await mengurangi jumlah kode boilerplate yang harus Anda tulis saat bekerja dengan janji.  Ketika janji muncul dalam standar ES2015, mereka bertujuan memecahkan masalah membuat kode asinkron.  Mereka mengatasi tugas ini, tetapi dalam dua tahun, berbagi output dari standar ES2015 dan ES2017, menjadi jelas bahwa mereka tidak dapat dianggap sebagai solusi akhir untuk masalah ini. <br><br>  Salah satu masalah yang dijanjikan diselesaikan adalah "neraka panggilan balik" yang terkenal, tetapi mereka, memecahkan masalah ini, menciptakan masalah mereka sendiri dengan sifat yang serupa. <br><br>  Janji adalah konstruksi sederhana di mana seseorang dapat membangun sesuatu dengan sintaksis yang lebih sederhana.  Akibatnya, ketika saatnya tiba, konstruk async / menunggu muncul.  Penggunaannya memungkinkan Anda untuk menulis kode yang terlihat seperti sinkron, tetapi asinkron, khususnya, tidak memblokir utas utama. <br><br><h4>  Bagaimana async / menunggu konstruksi berfungsi </h4><br>  Fungsi asinkron mengembalikan janji, seperti dalam contoh berikut: <br><br><pre> <code class="hljs coffeescript">const doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve)</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) }</code> </pre> <br>  Ketika Anda perlu memanggil fungsi yang serupa, Anda harus menempatkan kata kunci yang <code>await</code> sebelum perintah untuk memanggilnya.  Ini akan menyebabkan kode yang memanggilnya menunggu izin atau penolakan dari janji yang sesuai.  Perlu dicatat bahwa fungsi yang menggunakan kata kunci <code>await</code> harus dinyatakan menggunakan <code>async</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) }</code> </pre> <br>  Gabungkan dua fragmen kode di atas dan periksa perilakunya: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br>  Kode ini akan menampilkan yang berikut: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> I did something</code> </pre> <br>  Teks <code>I did something</code> masuk ke konsol dengan penundaan 3 detik. <br><br><h4>  Tentang Janji dan Fungsi Asinkron </h4><br>  Jika Anda mendeklarasikan fungsi tertentu menggunakan <code>async</code> , ini akan berarti bahwa fungsi tersebut akan mengembalikan janji bahkan jika itu tidak dilakukan secara eksplisit.  Itulah sebabnya, misalnya, contoh berikut adalah kode yang berfungsi: <br><br><pre> <code class="hljs powershell">const a<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } aFunction().then(console.log) //    <span class="hljs-string"><span class="hljs-string">'test'</span></span></code> </pre> <br>  Desain ini mirip dengan ini: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFunction = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) } aFunction().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">//    'test'</span></span></code> </pre> <br><h4>  Kekuatan async / menunggu </h4><br>  Dengan menganalisis contoh-contoh di atas, Anda dapat melihat bahwa kode yang menggunakan async / menunggu lebih sederhana daripada kode yang menggunakan pengingkaran janji, atau kode berdasarkan fungsi panggilan balik.  Di sini, tentu saja, kami melihat contoh yang sangat sederhana.  Anda dapat sepenuhnya merasakan manfaat di atas dengan bekerja dengan kode yang jauh lebih kompleks.  Di sini, misalnya, adalah cara memuat dan mem-parsing data JSON menggunakan janji: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(response =&gt; response.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(users =&gt; users[<span class="hljs-number"><span class="hljs-number">0</span></span>]) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`)) //       .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(userResponse =&gt; userResponse.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> } getFirstUserData()</code> </pre> <br>  Inilah solusi untuk masalah yang sama seperti menggunakan async / tunggu: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = async () =&gt; { const response = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //    const users = await response.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = users[<span class="hljs-number"><span class="hljs-number">0</span></span>] //    const userResponse = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`) //     const userData = await userResponse.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userData } getFirstUserData()</code> </pre> <br><h4>  Menggunakan urutan dari fungsi asinkron </h4><br>  Fungsi asinkron dapat dengan mudah digabungkan ke dalam desain yang menyerupai rantai Janji.  Namun, hasil dari kombinasi semacam itu adalah keterbacaan yang jauh lebih baik: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promiseToDoSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneWatchingSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) })</code> </pre> <br>  Kode ini akan menampilkan teks berikut: <br><br><pre> <code class="hljs pgsql">I did something <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> well</code> </pre> <br><h4>  Debugging sederhana </h4><br>  Janji sulit untuk di-debug, karena dengan menggunakannya Anda tidak bisa menggunakan alat debugger yang biasa (seperti "step bypass", step-over).  Kode yang ditulis menggunakan async / await dapat didebug menggunakan metode yang sama seperti kode sinkron biasa. <br><br><h2>  <font color="#3AC1EF">Pembuatan Acara di Node.js</font> </h2><br>  Jika Anda bekerja dengan JavaScript di browser, maka Anda tahu bahwa acara memainkan peran besar dalam menangani interaksi pengguna dengan halaman.  Ini tentang menangani acara yang disebabkan oleh klik dan gerakan mouse, penekanan tombol pada keyboard, dan sebagainya.  Di Node.js, Anda bisa bekerja dengan acara yang dibuat oleh programmer sendiri.  Di sini Anda dapat membuat sistem acara Anda sendiri menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">acara</a> .  Secara khusus, modul ini menawarkan kelas <code>EventEmitter</code> , yang kemampuannya dapat digunakan untuk mengatur pekerjaan dengan acara.  Sebelum menggunakan mekanisme ini, Anda harus menghubungkannya: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter</code> </pre> <br>  Ketika bekerja dengannya, metode <code>on()</code> dan <code>emit()</code> tersedia untuk kita, antara lain.  Metode <code>emit</code> digunakan untuk memanggil peristiwa.  Metode <code>on</code> digunakan untuk mengonfigurasi panggilan balik, penangan peristiwa yang dipanggil saat peristiwa tertentu dipanggil. <br><br>  Misalnya, mari kita buat acara <code>start</code> .  Ketika itu terjadi, kami akan menampilkan sesuatu ke konsol: <br><br><pre> <code class="hljs coffeescript">eventEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'started'</span></span>) })</code> </pre> <br>  Untuk memicu acara ini, konstruksi berikut digunakan: <br><br><pre> <code class="hljs mel">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">emit</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>)</code> </pre> <br>  Sebagai hasil dari pelaksanaan perintah ini, pengendali event dipanggil dan string <code>started</code> sampai ke konsol. <br><br>  Anda bisa meneruskan argumen ke event handler, mewakili mereka sebagai argumen tambahan ke metode <code>emit()</code> : <br><br><pre> <code class="hljs coffeescript">eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">started ${number}</span></span>`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>)</code> </pre> <br>  Hal yang sama terjadi dalam kasus di mana pawang harus melewati beberapa argumen: <br><br><pre> <code class="hljs pgsql">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) =&gt; { console.log(`started <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>}`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  <code>EventEmitter</code> kelas <code>EventEmitter</code> memiliki beberapa metode berguna lainnya: <br><br><ul><li>  <code>once()</code> - memungkinkan Anda untuk mendaftar pengendali acara yang hanya dapat dipanggil sekali. </li><li>  <code>removeListener()</code> - memungkinkan Anda untuk menghapus handler yang diteruskan ke dalamnya dari array handler dari event yang diteruskan ke sana. </li><li>  <code>removeAllListeners()</code> - memungkinkan Anda untuk menghapus semua penangan acara yang diteruskan ke sana. </li></ul><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Hari ini kita berbicara tentang pemrograman asinkron dalam JavaScript, khususnya, kita membahas panggilan balik, janji, dan konstruk async / menunggu.  Di sini kami menyinggung masalah bekerja dengan acara yang dijelaskan oleh pengembang menggunakan modul <code>events</code> .  Topik kita berikutnya adalah mekanisme jaringan platform Node.js. <br><br>  <b>Pembaca yang budiman!</b>  Saat memprogram untuk Node.js, apakah Anda menggunakan konstruk async / wait? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424555/">https://habr.com/ru/post/id424555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424539/index.html">Java 11: baru dalam String</a></li>
<li><a href="../id424541/index.html">Kisah kegagalan UGJ 2018: cara membuat game yang tidak disukai siapa pun (jangan lakukan itu!)</a></li>
<li><a href="../id424543/index.html">Java 11 / JDK 11: Ketersediaan Umum</a></li>
<li><a href="../id424551/index.html">Hangat dan tabung: lima balalaika tentang teknologi audio magnetik</a></li>
<li><a href="../id424553/index.html">Panduan Node.js, Bagian 6: Loop Peristiwa, Stack Panggilan, Pengatur Waktu</a></li>
<li><a href="../id424557/index.html">Panduan Node.js, Bagian 8: Protokol HTTP dan WebSocket</a></li>
<li><a href="../id424559/index.html">Big Data resistance 1 atau Joe yang sulit dipahami. Anonimitas internet, anti-deteksi, anti-pelacakan untuk anti-Anda dan anti-us</a></li>
<li><a href="../id424563/index.html">Langsung menuju detail percakapan ke orang asing</a></li>
<li><a href="../id424565/index.html">Tinjauan umum: Pemindaian 3D dari bangunan real estat</a></li>
<li><a href="../id424567/index.html">Pengalaman memblokir iklan online di jaringan lokal perusahaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>