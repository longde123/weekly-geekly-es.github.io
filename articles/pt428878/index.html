<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèº üôèüèΩ üë®üèΩ‚Äçüîß Voo de porco ou otimiza√ß√£o de int√©rpretes de bytecode üìö ü§± ü§ü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""N√£o importa o quanto voc√™ tente, voc√™ n√£o pode fazer um cavalo de corrida com um porco. Voc√™ pode, no entanto, fazer um porco mais r√°pido" (coment√°ri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Voo de porco ou otimiza√ß√£o de int√©rpretes de bytecode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/428878/"><p><img src="https://habrastorage.org/webt/bg/lp/cz/bglpczwnjg-u0usatiwfxggd-zi.jpeg"></p><br><blockquote>  "N√£o importa o quanto voc√™ tente, voc√™ n√£o pode fazer um cavalo de corrida com um porco. Voc√™ pode, no entanto, fazer um porco mais r√°pido" (coment√°rio no c√≥digo fonte do Emax) </blockquote><p>  Todo mundo sabe que os porcos n√£o voam.  N√£o menos popular √© a opini√£o de que os int√©rpretes de bytecode como uma t√©cnica para executar linguagens de alto n√≠vel n√£o podem ser acelerados sem o uso de compila√ß√£o din√¢mica demorada. </p><br><p>  Na segunda parte de uma s√©rie de artigos sobre int√©rpretes de bytecode, tentarei mostrar pelo exemplo de uma pequena m√°quina virtual da FDA empilhada (Pig Virtual Machine) que nem tudo est√° perdido para leit√µes trabalhadores com ambi√ß√µes e que √© bem poss√≠vel acelerar dentro da estrutura (principalmente) do padr√£o C o trabalho de tais int√©rpretes √© pelo menos uma vez e meia. </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte I, Introdut√≥ria</a> <br>  Parte dois, otimizando (atual) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte Tr√™s, Aplicada</a> </p><br><h1 id="porosenokvm">  Leit√£o </h1><br><p>  Vamos nos familiarizar. </p><br><p>  <a href="">O Piglet</a> VM √© uma m√°quina empilhada comum, baseada em um <a href="">exemplo</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte de uma</a> s√©rie de artigos.  Nosso porco conhece apenas um tipo de dados - uma palavra de m√°quina de 64 bits, e todos os c√°lculos (inteiros) s√£o realizados na pilha com uma profundidade m√°xima de 256 palavras de m√°quina.  Al√©m da pilha, este leit√£o tem uma mem√≥ria de trabalho de 65.536 palavras de m√°quina.  O resultado da execu√ß√£o do programa - uma palavra de m√°quina - pode ser colocado no registro de resultados ou simplesmente gerar a sa√≠da padr√£o (stdout). </p><br><p>  Todo o estado na m√°quina Piglet VM √© armazenado em uma √∫nica estrutura: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Current instruction pointer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-comment"><span class="hljs-comment">/* Fixed-size stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[STACK_MAX]; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> *stack_top; <span class="hljs-comment"><span class="hljs-comment">/* Operational memory */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> memory[MEMORY_SIZE]; <span class="hljs-comment"><span class="hljs-comment">/* A single register containing the result */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> result; } vm;</code> </pre> <br><p>  O exposto acima nos permite atribuir essa m√°quina a m√°quinas virtuais de baixo n√≠vel, quase toda a sobrecarga na qual recai a manuten√ß√£o do ciclo principal do programa: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(bytecode); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_PUSHI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg = NEXT_ARG(); PUSH(arg); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADD: { <span class="hljs-comment"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = POP(); *TOS_PTR() += arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * ... * Lots of other instruction handlers here * ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_END_OF_STREAM; }</code> </pre> <br><p>  O c√≥digo mostra que, para cada c√≥digo de opera√ß√£o, o piggy deve: </p><br><ol><li>  Recupere o c√≥digo de opera√ß√£o do fluxo de instru√ß√µes. </li><li>  Verifique se o c√≥digo de opera√ß√£o est√° no intervalo v√°lido de valores de c√≥digo de opera√ß√£o (essa l√≥gica √© adicionada pelo compilador C ao gerar o c√≥digo do comutador). </li><li>  V√° para as instru√ß√µes do corpo. </li><li>  Extraia argumentos de instru√ß√£o da pilha ou decodifique um argumento de instru√ß√£o localizado diretamente no bytecode. </li><li>  Realize uma opera√ß√£o. </li><li>  Se houver um resultado do c√°lculo, coloque-o na pilha. </li><li>  Mova o ponteiro da instru√ß√£o atual para a pr√≥xima. </li></ol><br><p>  A carga √∫til aqui est√° apenas no quinto par√°grafo, o restante est√° sobrecarregado: decodificando ou recuperando os argumentos de instru√ß√£o da pilha (cl√°usula 4), verificando o valor do opcode (cl√°usula 2), retornando repetidamente para o in√≠cio do loop principal e a subsequente transi√ß√£o condicional dificilmente prevista (cl√°usula 3). </p><br><p>  Em suma, o porco excedeu claramente o √≠ndice de massa corporal recomendado e, se quisermos mold√°-lo, teremos que lidar com todos esses excessos. </p><br><h1 id="svinskiy-yazyk-assemblera-i-resheto-eratosfena">  Linguagem de montagem de su√≠nos e peneira de Erat√≥stenes </h1><br><p>  Primeiro, vamos decidir sobre as regras do jogo. </p><br><p>  Escrever programas para uma m√°quina virtual diretamente em C √© uma p√©ssima id√©ia, mas criar uma linguagem de programa√ß√£o √© um longo tempo, por isso decidimos nos limitar a uma linguagem assembly piggy. </p><br><p>  Um programa que calcula a soma dos n√∫meros de 1 a 65.536 neste montador se parece com isso: </p><br><pre> <code class="plaintext hljs"># sum numbers from 1 to 65535 # init the current sum and the index PUSHI 1 PUSHI 1 # stack s=1, i=1 STOREI 0 # stack: s=1 # routine: increment the counter, add it to the current sum incrementandadd: # check if index is too big LOADI 0 # stack: s, i ADDI 1 # stack: s, i+1 DUP # stack: s, i+1, i+1 GREATER_OR_EQUALI 65535 # stack: s, i+1, 1 or 0 JUMP_IF_TRUE done # stack: s, i+1 DUP # stack: s, i+1, i+1 STOREI 0 # stack: s, i+1 ADD # stack: s+i+1 JUMP incrementandadd done: DISCARD PRINT DONE</code> </pre> <br><p>  N√£o √© Python, √© claro, mas h√° tudo o que voc√™ precisa para a felicidade dos porcos: coment√°rios, tags, saltos condicionais e incondicionais, mnem√¥nicos para instru√ß√µes e a capacidade de especificar argumentos diretos para as instru√ß√µes. </p><br><p>  Completo com a m√°quina "Piglet VM", s√£o montadores e desmontadores, que s√£o corajosos em esp√≠rito e t√™m muito tempo livre, os leitores podem testar independentemente em batalha. </p><br><p>  Os n√∫meros se somam muito rapidamente, ent√£o, para testar o desempenho, escrevi outro programa - uma implementa√ß√£o ing√™nua da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">peneira de Erat√≥stenes</a> . </p><br><p>  De fato, o leit√£o corre muito r√°pido de qualquer maneira (suas instru√ß√µes est√£o pr√≥ximas das da m√°quina); portanto, para obter resultados claros, eu farei cada medi√ß√£o para cem partidas do programa. </p><br><p>  A primeira vers√£o do nosso porco n√£o otimizado funciona assim: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve-unoptimized.bin 100 &gt; /dev/null PROFILE: switch code finished took 545ms</code> </pre> <br><p>  Meio segundo!  A compara√ß√£o √© certamente desonesta, mas o mesmo algoritmo Python torna centenas de execu√ß√µes um pouco mais lentas: </p><br><pre> <code class="plaintext hljs">&gt; python test/sieve.py &gt; /dev/null 4.66692185402</code> </pre> <br><p>  4,5 segundos ou nove vezes mais lento.  Devemos prestar homenagem ao leit√£o - ele tem a capacidade!  Bem, agora vamos ver se o nosso porco pode bombear a prensa. <br><img src="https://habrastorage.org/webt/ce/eq/ni/ceeqnik6-41cuvd3rwvkkuquoes.jpeg"></p><br><h1 id="uprazhnenie-pervoe-staticheskie-superinstrukcii">  Exerc√≠cio Um: Superinstru√ß√µes Est√°ticas </h1><br><p>  A primeira regra do c√≥digo r√°pido √© n√£o fazer muito trabalho.  A segunda regra do c√≥digo r√°pido √© nunca fazer muito trabalho.  Ent√£o, que tipo de trabalho extra o Piglet VM faz? </p><br><p>  Observa√ß√£o um: criar um perfil do nosso programa mostra que existem sequ√™ncias de instru√ß√µes mais comuns que outras.  N√£o atormentaremos muito nosso porco e nos restringiremos apenas a algumas instru√ß√µes: </p><br><ol><li>  LOADI 0, ADICIONAR - coloque na pilha um n√∫mero da mem√≥ria no endere√ßo 0 e adicione-o ao n√∫mero no topo da pilha. </li><li>  PUSHI 65536, GREATER_OR_EQUAL - coloque um n√∫mero na pilha e compare-o com o n√∫mero que estava anteriormente no topo da pilha, colocando o resultado da compara√ß√£o (0 ou 1) de volta na pilha. </li><li>  PUSHI 1, ADD - coloque um n√∫mero na pilha, adicione-o ao n√∫mero que estava anteriormente no topo da pilha e coloque o resultado da adi√ß√£o novamente na pilha. </li></ol><br><p>  H√° pouco mais de 20 instru√ß√µes na m√°quina Piglet VM e um byte inteiro √© usado para codifica√ß√£o - 256 valores.  A introdu√ß√£o de novas instru√ß√µes n√£o √© um problema.  O que faremos: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-comment"><span class="hljs-comment">/* * Other instructions here * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LOADADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get immediate argument as an memory address , add it to value from the address to the top * of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> addr = NEXT_ARG(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> val = vm.memory[addr]; *TOS_PTR() += val; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_GREATER_OR_EQUALI:{ <span class="hljs-comment"><span class="hljs-comment">/* get the immediate argument, compare it with the value from the address to the top of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = NEXT_ARG(); *TOS_PTR() = PEEK() &gt;= arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* Add immediate value to the top of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg_right = NEXT_ARG(); *TOS_PTR() += arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * Other instructions here * */</span></span> }</code> </pre><br><p>  Nada complicado.  Vamos ver o que aconteceu: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 410ms</code> </pre> <br><p>  Uau!  O c√≥digo √© apenas para tr√™s novas instru√ß√µes, e ganhamos um milh√£o e meio de milissegundos! </p><br><p>  O ganho aqui √© alcan√ßado devido ao fato de nosso porquinho n√£o fazer movimentos desnecess√°rios ao executar essas instru√ß√µes: o segmento de execu√ß√£o n√£o cai no loop principal, nada √© decodificado e os argumentos das instru√ß√µes n√£o voltam a ser empilhados novamente. </p><br><p>  Isso √© chamado de superinstru√ß√µes est√°ticas, pois instru√ß√µes adicionais s√£o definidas estaticamente, ou seja, pelo programador da m√°quina virtual no est√°gio de desenvolvimento.  Essa √© uma t√©cnica simples e eficaz que todas as m√°quinas virtuais de linguagens de programa√ß√£o usam de uma forma ou de outra. </p><br><p>  O principal problema das superinstru√ß√µes est√°ticas √© que, sem um programa espec√≠fico, √© imposs√≠vel determinar quais instru√ß√µes devem ser combinadas.  Programas diferentes usam sequ√™ncias de instru√ß√µes diferentes e voc√™ pode descobrir essas sequ√™ncias apenas no est√°gio de lan√ßamento de um c√≥digo espec√≠fico. </p><br><p>  O pr√≥ximo passo pode ser a compila√ß√£o din√¢mica de superinstru√ß√µes no contexto de um programa espec√≠fico, ou seja, superinstru√ß√µes din√¢micas (nos anos 90 e in√≠cio dos anos 2000, essa t√©cnica desempenhou o papel de uma compila√ß√£o JIT primitiva). </p><br><p>  √â imposs√≠vel criar instru√ß√µes em tempo real no √¢mbito do C comum, e nosso leit√£o com raz√£o n√£o considera isso uma competi√ß√£o honesta.  Felizmente, tenho alguns exerc√≠cios melhores para ele. </p><br><h1 id="uprazhnenie-vtoroe-proverka-intervala-znacheniy-opkodov">  Exerc√≠cio dois: verificando o intervalo de valores do c√≥digo de opera√ß√£o </h1><br><p>  Seguindo nossas regras r√°pidas de c√≥digo, mais uma vez nos perguntamos a eterna pergunta: o que voc√™ n√£o pode fazer? </p><br><p>  Quando nos familiarizamos com o dispositivo da m√°quina VM Piglet, listei todas as a√ß√µes que a m√°quina virtual executa para cada c√≥digo de opera√ß√£o.  E o ponto 2 (verificar o valor do c√≥digo de opera√ß√£o para ajustar-se ao intervalo v√°lido de valores do comutador) √© o mais suspeito. </p><br><p>  Vamos dar uma olhada em como o GCC compila a constru√ß√£o do switch: </p><br><ol><li>  Uma tabela de transi√ß√£o √© constru√≠da, ou seja, uma tabela que exibe o valor do c√≥digo de opera√ß√£o para o endere√ßo do c√≥digo que executa o corpo da instru√ß√£o. </li><li>  √â inserido um c√≥digo que verifica se o c√≥digo de opera√ß√£o recebido est√° dentro do intervalo de todos os valores poss√≠veis do comutador e o envia para o r√≥tulo padr√£o se n√£o houver manipulador para o c√≥digo de opera√ß√£o. </li><li>  O c√≥digo que vai para o manipulador √© inserido. </li></ol><br><p>  Mas por que verificar o intervalo de valores para cada instru√ß√£o?  Acreditamos que o opcode est√° correto - terminando a execu√ß√£o pela instru√ß√£o OP_DONE ou incorreto - indo al√©m do bytecode.  A cauda do fluxo de c√≥digos de opera√ß√£o √© marcada com zero e zero √© o c√≥digo de opera√ß√£o da instru√ß√£o OP_ABORT, que completa a execu√ß√£o do bytecode com um erro. </p><br><p>  Acontece que essa verifica√ß√£o n√£o √© necess√°ria!  E o leit√£o deve ser capaz de transmitir essa id√©ia ao compilador.  Vamos tentar consertar um pouco o switch principal: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-comment"><span class="hljs-comment">/* Let the compiler know that opcodes are always between 0 and 31 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* All the instructions here */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">26</span></span> ... <span class="hljs-number"><span class="hljs-number">0x1f</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/*Handle the remaining 5 non-existing opcodes*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } }</code> </pre> <br><p>  Sabendo que temos apenas 26 instru√ß√µes, impomos uma m√°scara de bit (o valor octal 0x1f √© um 0b11111 bin√°rio que cobre o intervalo de valores de 0 a 31) no c√≥digo de opera√ß√£o e adicionamos manipuladores a valores n√£o utilizados no intervalo de 26 a 31. </p><br><p>  As instru√ß√µes de bits s√£o algumas das mais baratas da arquitetura x86 e certamente s√£o mais baratas que as ramifica√ß√µes condicionais problem√°ticas, como a que usa a verifica√ß√£o de intervalo.  Teoricamente, devemos ganhar v√°rios ciclos em cada instru√ß√£o execut√°vel se o compilador entender nossa dica. </p><br><p>  A prop√≥sito, a maneira de especificar o intervalo de valores no caso n√£o √© C padr√£o, mas uma extens√£o do GCC.  Mas, para nossos prop√≥sitos, esse c√≥digo √© adequado, principalmente porque n√£o √© dif√≠cil refaz√™-lo em v√°rios manipuladores para cada um dos valores desnecess√°rios. </p><br><p>  Tentamos: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 437ms PROFILE: switch code (no range check) finished took 383ms</code> </pre> <br><p>  Mais 50 milissegundos!  Leit√£o, √© como se voc√™ se ouvisse nos seus ombros! </p><br><h1 id="uprazhnenie-trete-trassy">  Exerc√≠cio Tr√™s: Trilhas </h1><br><p>  Que outros exerc√≠cios podem ajudar nosso leit√£o?  A maior economia de tempo que obtivemos gra√ßas a super instru√ß√µes.  E eles reduzem o n√∫mero de sa√≠das para o ciclo principal e permitem que voc√™ se livre dos custos indiretos correspondentes. </p><br><p>  O switch central √© o principal problema para qualquer processador, com uma execu√ß√£o extraordin√°ria de instru√ß√µes.  Os preditores modernos de ramifica√ß√£o aprenderam a prever bem at√© mesmo tais transi√ß√µes indiretas complexas, mas "borrar" pontos de ramifica√ß√£o ao longo do c√≥digo pode ajudar o processador a mudar rapidamente de instru√ß√£o para instru√ß√£o. </p><br><p>  Outro problema √© a leitura byte a byte dos opcodes de instru√ß√µes e argumentos diretos do bytecode.  M√°quinas f√≠sicas operam com uma palavra de m√°quina de 64 bits e realmente n√£o gostam quando o c√≥digo opera com valores mais baixos. </p><br><p>  Os compiladores geralmente operam com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blocos b√°sicos</a> , ou seja, sequ√™ncias de instru√ß√µes sem ramifica√ß√µes e r√≥tulos dentro.  O bloco base inicia no in√≠cio do programa ou no r√≥tulo e termina com o final do programa, ramifica√ß√£o condicional ou um salto direto para o r√≥tulo que inicia o pr√≥ximo bloco base. </p><br><p>  H√° muitas vantagens em trabalhar com unidades de base, mas nosso porco est√° interessado em sua caracter√≠stica principal: as instru√ß√µes dentro da unidade de base s√£o executadas sequencialmente.  Seria √≥timo isolar esses blocos de base e seguir as instru√ß√µes neles sem perder tempo entrando no loop principal. </p><br><p>  No nosso caso, voc√™ pode at√© estender a defini√ß√£o da unidade base para a pista.  A faixa em termos da m√°quina Piglet VM incluir√° todos os blocos de base conectados sequencialmente (ou seja, usando saltos incondicionais). </p><br><p>  Al√©m da execu√ß√£o seq√ºencial de instru√ß√µes, seria bom decodificar os argumentos diretos das instru√ß√µes com anteced√™ncia. </p><br><p>  Tudo soa bem assustador e se assemelha a uma compila√ß√£o din√¢mica, que decidimos n√£o usar.  O porco at√© duvidou um pouco de sua for√ßa, mas na pr√°tica n√£o ficou t√£o ruim. </p><br><p>  Vamos primeiro pensar em como voc√™ pode imaginar as instru√ß√µes inclu√≠das na faixa: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg; trace_op_handler *handler; };</code> </pre> <br><p>  Aqui arg √© o argumento pr√©-decodificado da instru√ß√£o e handler √© um ponteiro para uma fun√ß√£o que executa a l√≥gica da instru√ß√£o. </p><br><p>  Agora, a visualiza√ß√£o de cada rastreamento √© assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> scode trace[MAX_TRACE_LEN];</code> </pre> <br><p>  Ou seja, um rastreio √© uma sequ√™ncia de c√≥digos s de comprimento limitado.  O pr√≥prio cache de rastreamento dentro da m√°quina virtual √© semelhante a este: </p><br><pre> <code class="cpp hljs">trace trace_cache[MAX_CODE_LEN];</code> </pre> <br><p>  Isso √© apenas uma matriz de rastreios com um comprimento que n√£o excede o comprimento poss√≠vel do bytecode.  A solu√ß√£o √© pregui√ßosa, para economizar mem√≥ria, faz sentido usar uma tabela de hash. </p><br><p>  No in√≠cio do int√©rprete, o primeiro manipulador de cada rastreamento ser√° compilado: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> trace_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; trace_i &lt; MAX_CODE_LEN; trace_i++ ) vm_trace.trace_cache[trace_i][<span class="hljs-number"><span class="hljs-number">0</span></span>].handler = trace_compile_handler;</code> </pre> <br><p>  O loop principal do int√©rprete agora fica assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(vm_trace.is_running) { scode *code = &amp;vm_trace.trace_cache[vm_trace.pc][<span class="hljs-number"><span class="hljs-number">0</span></span>]; code-&gt;handler(code); }</code> </pre> <br><p>  Um compilador de rastreio √© um pouco mais complicado e, al√©m de criar um rastreio a partir da instru√ß√£o atual, ele faz o seguinte: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace_compile_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *trace_head)</span></span></span><span class="hljs-function"> </span></span>{ scode *trace_tail = trace_head; <span class="hljs-comment"><span class="hljs-comment">/* * Trace building here */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* now, run the chain that has a trace_compile_handler replaced with proper instruction handler * function pointer */</span></span> trace_head-&gt;handler(trace_head); }</code> </pre><br><p>  Manipulador de instru√ß√µes normal: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_add_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *code)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = POP(); *TOS_PTR() += arg_right; <span class="hljs-comment"><span class="hljs-comment">/* * Call the next trace handler * */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* scodes are located in an array so we can use pointer arithmetic to get the next handler */</span></span> code++; code-&gt;handler(code); }</code> </pre> <br><p>  Um manipulador que n√£o faz nenhuma chamada no final da fun√ß√£o termina cada rastreamento: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_done_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *code)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) code; vm_trace.is_running = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; vm_trace.error = SUCCESS; }</code> </pre> <br><p>  Tudo isso, √© claro, √© mais complicado do que adicionar superinstru√ß√µes, mas vamos ver se isso nos deu alguma coisa: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 427ms PROFILE: switch code (no range check) finished took 395ms PROFILE: trace code finished took 367ms</code> </pre> <br><p>  Viva, mais 30 milissegundos! </p><br><p>  Como assim?  Em vez de simplesmente navegar pelos r√≥tulos, criamos cadeias de chamadas de manipuladores de instru√ß√µes, gastamos tempo em chamadas e passando argumentos, mas nosso porquinho ainda segue as trilhas mais rapidamente do que um simples comutador com seus r√≥tulos. </p><br><p>  Esse ganho no desempenho da pista √© alcan√ßado devido a tr√™s fatores: </p><br><ol><li>  √â f√°cil prever ramifica√ß√µes espalhadas em diferentes lugares do c√≥digo. </li><li>  Os argumentos dos manipuladores s√£o sempre pr√©-codificados em uma palavra de m√°quina completa, e isso √© feito apenas uma vez - durante a compila√ß√£o do rastreamento. </li><li>  O compilador transforma as cadeias de fun√ß√µes em uma √∫nica chamada para a primeira fun√ß√£o do manipulador, o que √© poss√≠vel devido √† otimiza√ß√£o da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chamada final</a> . </li></ol><br><p>  Antes de resumir os resultados de nosso treinamento, o leit√£o e eu decidimos tentar outra t√©cnica antiga para interpretar programas - o c√≥digo costurado. </p><br><h1 id="uprazhnenie-chetvertoe-shityy-kod">  Exerc√≠cio Quatro: C√≥digo "Costurado" </h1><br><p>  Qualquer porco interessado na hist√≥ria dos int√©rpretes ouviu um c√≥digo encadeado.  Existem muitas op√ß√µes para essa t√©cnica, mas todas se resumem a, em vez de seguir uma matriz de c√≥digos de opera√ß√£o, seguindo uma matriz de, por exemplo, ponteiros para fun√ß√µes ou etiquetas, seguindo-os diretamente sem um c√≥digo de opera√ß√£o intermedi√°rio. </p><br><p>  Chamar fun√ß√µes √© um neg√≥cio caro e sem sentido atualmente;  a maioria das outras vers√µes do c√≥digo costurado √© irrealiz√°vel dentro da estrutura do padr√£o C. Mesmo a t√©cnica, que ser√° discutida abaixo, usa a extens√£o C difusa, mas n√£o padronizada - indicadores para etiquetas. </p><br><p>  Na vers√£o do c√≥digo costurado (c√≥digo encadeado do token em ingl√™s) que escolhi para atingir nossos objetivos de porco, salvamos o bytecode, mas antes de iniciar a interpreta√ß√£o, criamos uma tabela que exibe os c√≥digos de instru√ß√£o para o endere√ßo dos r√≥tulos do processador de instru√ß√µes: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *labels[] = { [OP_PUSHI] = &amp;&amp;op_pushi, [OP_LOADI] = &amp;&amp;op_loadi, [OP_LOADADDI] = &amp;&amp;op_loadaddi, [OP_STORE] = &amp;&amp;op_store, [OP_STOREI] = &amp;&amp;op_storei, [OP_LOAD] = &amp;&amp;op_load, [OP_DUP] = &amp;&amp;op_dup, [OP_DISCARD] = &amp;&amp;op_discard, [OP_ADD] = &amp;&amp;op_add, [OP_ADDI] = &amp;&amp;op_addi, [OP_SUB] = &amp;&amp;op_sub, [OP_DIV] = &amp;&amp;op_div, [OP_MUL] = &amp;&amp;op_mul, [OP_JUMP] = &amp;&amp;op_jump, [OP_JUMP_IF_TRUE] = &amp;&amp;op_jump_if_true, [OP_JUMP_IF_FALSE] = &amp;&amp;op_jump_if_false, [OP_EQUAL] = &amp;&amp;op_equal, [OP_LESS] = &amp;&amp;op_less, [OP_LESS_OR_EQUAL] = &amp;&amp;op_less_or_equal, [OP_GREATER] = &amp;&amp;op_greater, [OP_GREATER_OR_EQUAL] = &amp;&amp;op_greater_or_equal, [OP_GREATER_OR_EQUALI] = &amp;&amp;op_greater_or_equali, [OP_POP_RES] = &amp;&amp;op_pop_res, [OP_DONE] = &amp;&amp;op_done, [OP_PRINT] = &amp;&amp;op_print, [OP_ABORT] = &amp;&amp;op_abort, };</code> </pre> <br><p>  Preste aten√ß√£o aos s√≠mbolos &amp;&amp; - s√£o indicadores de etiquetas com o corpo de instru√ß√µes, a extens√£o mais n√£o-padr√£o do GCC. </p><br><p>  Para come√ßar a executar o c√≥digo, basta clicar no ponteiro correspondente ao primeiro c√≥digo operacional do programa: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *labels[NEXT_OP()];</code> </pre> <br><p>  N√£o h√° ciclo aqui e n√£o haver√°, cada uma das instru√ß√µes em si salta para o seguinte manipulador: </p><br><pre> <code class="cpp hljs">op_pushi: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg = NEXT_ARG(); PUSH(arg); <span class="hljs-comment"><span class="hljs-comment">/* jump to the next instruction*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *labels[NEXT_OP()]; }</code> </pre> <br><p>  A aus√™ncia de uma op√ß√£o ‚Äúespalha‚Äù os pontos de ramifica√ß√£o ao longo dos corpos de instru√ß√µes, o que, em teoria, deve ajudar o preditor de ramifica√ß√£o em caso de execu√ß√£o extraordin√°ria de instru√ß√µes.  √â como se incorpor√°ssemos o switch diretamente nas instru√ß√µes e form√°ssemos manualmente uma tabela de transi√ß√£o. </p><br><p>  Essa √© toda a t√©cnica.  Ela gostou do leit√£o por sua simplicidade.  Vamos ver o que acontece na pr√°tica: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 443ms PROFILE: switch code (no range check) finished took 389ms PROFILE: threaded code finished took 477ms PROFILE: trace code finished took 364ms</code> </pre> <br><p>  Opa!  Esta √© a mais lenta de todas as nossas t√©cnicas!  O que aconteceu?  Vamos executar os mesmos testes, desativando todas as otimiza√ß√µes do GCC: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 969ms PROFILE: switch code (no range check) finished took 940ms PROFILE: threaded code finished took 824ms PROFILE: trace code finished took 1169ms</code> </pre> <br><p>  Aqui, o c√≥digo costurado tem melhor desempenho. </p><br><p>  Tr√™s fatores desempenham um papel aqui: </p><br><ol><li>  O pr√≥prio compilador de otimiza√ß√£o criar√° uma tabela de convers√£o n√£o pior do que nossa placa de etiquetas manual. </li><li>  Os compiladores modernos se livram notavelmente de chamadas de fun√ß√£o extras. </li><li>  Come√ßando na gera√ß√£o Haswell de processadores Intel, os preditores de ramifica√ß√£o aprenderam a prever com precis√£o as transi√ß√µes em um √∫nico ponto de ramifica√ß√£o. </li></ol><br><p>  Segundo a mem√≥ria antiga, essa t√©cnica ainda √© usada no c√≥digo, por exemplo, do interpretador Python VM, mas, francamente, hoje em dia j√° √© arca√≠smo. </p><br><p>  Vamos finalmente resumir e avaliar os sucessos alcan√ßados por nosso porco. </p><br><h1 id="razbor-porosyachih-poletov">  Debriefing </h1><br><p><img src="https://habrastorage.org/webt/co/vy/6k/covy6k28ts8__ozuzuswtqpcora.jpeg"><br>  N√£o tenho certeza do que pode ser chamado de voo, mas, convenhamos, nosso porquinho percorreu um longo caminho de 550 milissegundos para cem corridas na "peneira" at√© os 370 milissegundos finais.  Usamos diferentes t√©cnicas: super-instru√ß√µes, eliminando intervalos de verifica√ß√£o de valores, mec√¢nica complicada de tra√ßos e, finalmente, at√© c√≥digo costurado.  Ao mesmo tempo, em geral, agimos dentro da estrutura das coisas implementadas em todos os compiladores populares C. A acelera√ß√£o uma vez e meia, como me parece, √© um bom resultado, e o leit√£o merece uma por√ß√£o extra de farelo na cavidade. </p><br><p>  Uma das condi√ß√µes impl√≠citas que estabelecemos para n√≥s mesmos com o porco √© preservar a arquitetura de pilha da m√°quina VM Piglet.  A transi√ß√£o para registrar a arquitetura, via de regra, reduz o n√∫mero de instru√ß√µes necess√°rias para a l√≥gica dos programas e, consequentemente, pode ajudar a eliminar sa√≠das desnecess√°rias ao gerenciador de instru√ß√µes.  Eu acho que outros 10 a 20% do tempo podem ser cortados. </p><br><p>  Nossa principal condi√ß√£o - a falta de compila√ß√£o din√¢mica - tamb√©m n√£o √© uma lei da natureza.  Bombear um porco com ester√≥ides na forma de uma compila√ß√£o JIT √© muito f√°cil atualmente: em bibliotecas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GNU Lightning</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LibJIT,</a> todo o trabalho sujo j√° foi feito.  Mas o tempo de desenvolvimento e a quantidade total de c√≥digo, mesmo usando bibliotecas, est√£o crescendo tremendamente. </p><br><p>  √â claro que existem outros truques para os quais nosso porquinho n√£o alcan√ßou o casco.    ,     ‚Äî       - ‚Äî    - .         ,       . </p><br><p> <strong>PS</strong>    ,  ,   ,   ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.instagram.com/vovazomb/</a> ),   . </p><br><p> <strong>PPS</strong>       ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">true-grue</a> -           ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PigletC</a> .     ! </p><br><p> <strong>PPPS</strong>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">iliazeus</a>    :      .            ;             .      <a href=""></a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428878/">https://habr.com/ru/post/pt428878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428866/index.html">7 princ√≠pios de design, atitude em rela√ß√£o √†s tend√™ncias de design, portf√≥lio de designers UX, ...</a></li>
<li><a href="../pt428868/index.html">JARs de v√°rias vers√µes - Ruim ou Bom?</a></li>
<li><a href="../pt428870/index.html">Mrr: FRP total para reagir</a></li>
<li><a href="../pt428872/index.html">A hist√≥ria de um olho e 20 opera√ß√µes (n√£o lidas para impress√£o) ou ele queria ser um piloto, mas ele n√£o era permitido no c√©u</a></li>
<li><a href="../pt428876/index.html">N√£o h√° como voltar atr√°s: a experi√™ncia pessoal do testador</a></li>
<li><a href="../pt428880/index.html">Novos m√©todos de autentica√ß√£o - uma amea√ßa √† privacidade?</a></li>
<li><a href="../pt428882/index.html">Mobile Yandex Blitz: analisamos tarefas</a></li>
<li><a href="../pt428888/index.html">qml: poder e simplicidade</a></li>
<li><a href="../pt428890/index.html">Toda a verdade sobre o RTOS. Artigo # 18 Grupos de Sinalizadores de Eventos: Servi√ßos Auxiliares e Estruturas de Dados</a></li>
<li><a href="../pt428892/index.html">Como criar uma IA de jogo: um guia para iniciantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>