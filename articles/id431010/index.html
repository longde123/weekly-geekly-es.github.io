<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ½â€ğŸ« ğŸ§šğŸ¾ ğŸ’‡ğŸ¼ Memori komputer Anda ketinggalan setiap 7,8 Î¼s âœŒğŸ¿ ğŸ‘… ğŸ‡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SDRAM DDR3 modern. Sumber: BY-SA / 4.0 oleh Kjerish 

 Selama kunjungan baru-baru ini ke Computer History Museum di Mountain View, sampel kuno dari me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memori komputer Anda ketinggalan setiap 7,8 Î¼s</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431010/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/f53/c6e/dc7f53c6eb17bfa58db7c138915bce84.jpg"></div><br>  <i><font color="gray">SDRAM DDR3 modern.</font></i>  <i><font color="gray">Sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BY-SA / 4.0 oleh Kjerish</a></font></i> <br><br>  Selama kunjungan baru-baru ini ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Computer History Museum</a> di Mountain View, sampel kuno dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memori ferit</a> menarik perhatian saya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b2/d31/5c6/2b2d315c67b80adcd5f0b5bf4dd23e7a.jpg"></div><br>  <i><font color="gray">Sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BY-SA / 3.0 oleh Konstantin Lanzet</a></font></i> <br><a name="habracut"></a><br>  Saya dengan cepat sampai pada kesimpulan bahwa saya tidak tahu bagaimana hal-hal seperti itu bekerja.  Apakah cincinnya berputar (tidak), dan mengapa tiga kabel melewati masing-masing cincin (saya masih tidak mengerti cara kerjanya).  Lebih penting lagi, saya menyadari bahwa saya memiliki sedikit sekali gagasan tentang cara kerja RAM dinamis modern! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/cb6/f41/7fccb6f418a426c7829b7e9bb1b5d3c3.png"></div><br>  <i><font color="gray">Sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memory Cycle Ulrich Drapper</a></font></i> <br><br>  Saya sangat tertarik pada salah satu konsekuensi dari cara kerja RAM dinamis.  Ternyata setiap bit data disimpan oleh muatan (atau ketidakhadirannya) pada kapasitor kecil dalam chip RAM.  Tetapi kapasitor ini secara bertahap kehilangan muatannya seiring waktu.  Untuk menghindari hilangnya data yang disimpan, data harus diperbarui secara berkala untuk mengembalikan biaya (jika ada) ke tingkat semula.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proses pembaruan</a> ini melibatkan membaca setiap bit dan kemudian menulisnya kembali.  Selama "pembaruan" ini, memori sibuk dan tidak dapat melakukan operasi normal, seperti menulis atau menyimpan bit. <br><br>  Ini mengganggu saya untuk waktu yang lama, dan saya bertanya-tanya ... apakah mungkin untuk melihat penundaan pembaruan di tingkat program? <br><br><h1>  Basis Pelatihan Peningkatan RAM Dinamis </h1><br>  Setiap DIMM terdiri dari "sel" dan "baris", "kolom", "sisi" dan / atau "peringkat".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Presentasi</a> dari Universitas Utah ini menjelaskan nomenklatur tersebut.  Konfigurasi memori komputer dapat diperiksa dengan perintah <code>decode-dimms</code> .  Berikut ini sebuah contoh: <br><br><pre>  $ decode-dimms
 Ukuran 4096 MB
 Bank x Baris x Kolom x Bit 8 x 15 x 10 x 64
 Peringkat 2 </pre><br>  Kami tidak perlu memahami seluruh skema DDR DIMM, kami ingin memahami operasi hanya satu sel yang menyimpan sedikit informasi.  Lebih tepatnya, kami hanya tertarik pada proses pembaruan. <br><br>  Pertimbangkan dua sumber: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tutorial Pembaruan DRAM</a> Universitas Utah </li><li>  Dan dokumentasi chip gigabit yang luar biasa dari Micron: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Merancang TN-46-09 untuk 1Gb DDR SDRAM"</a> </li></ul><br>  Setiap bit dalam memori dinamis harus diperbarui: ini biasanya terjadi setiap 64 ms (yang disebut pembaruan statis).  Ini adalah operasi yang agak mahal.  Untuk menghindari satu perhentian besar setiap 64 ms, proses ini dibagi menjadi 8192 operasi pembaruan yang lebih kecil.  Di masing-masing, pengontrol memori komputer mengirimkan perintah pembaruan ke chip DRAM.  Setelah menerima instruksi, chip akan memperbarui 1/8192 sel.  Jika Anda menghitung, maka 64 ms / 8192 = 7812,5 ns atau 7,81 Î¼s.  Ini berarti yang berikut: <br><br><ul><li>  Perintah pembaruan dijalankan setiap 7812,5 ns.  Ini disebut tREFI. </li><li>  Proses pembaruan dan pemulihan memerlukan waktu, sehingga chip dapat kembali melakukan operasi baca dan tulis normal.  Yang disebut tRFC sama dengan 75 ns atau 120 ns (seperti dalam dokumentasi Micron yang disebutkan). </li></ul><br>  Jika memori panas (lebih dari 85 Â° C), maka waktu penyimpanan data dalam memori berkurang, dan waktu pembaruan statis dikurangi setengahnya menjadi 32 ms.  Dengan demikian, tREFI turun menjadi 3906,25 ns. <br><br>  Chip memori biasa sibuk memperbarui untuk sebagian besar masa pakainya: dari 0,4% hingga 5%.  Selain itu, chip memori bertanggung jawab atas bagian non-sepele dari konsumsi daya komputer biasa, dan sebagian besar daya ini dihabiskan untuk peningkatan. <br><br>  Seluruh chip memori diblokir selama pembaruan.  Artinya, setiap bit dalam memori dikunci selama lebih dari 75 ns setiap 7812 ns.  Mari kita ukur. <br><br><h1>  Persiapan percobaan </h1><br>  Untuk mengukur operasi dengan akurasi nanosecond, Anda memerlukan siklus yang sangat ketat, mungkin dalam C. Sepertinya: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ...; i++) { <span class="hljs-comment"><span class="hljs-comment">//   . *(volatile int *) one_global_var; //   CPU.    _mm_clflush(one_global_var); //   ,     //    (25    160). // , - . asm volatile("mfence"); //     clock_gettime(CLOCK_MONOTONIC, &amp;ts); }</span></span></code> </pre> <br>  <a href="">Kode lengkap tersedia di GitHub.</a> <br><br>  Kode ini sangat sederhana.  Lakukan pembacaan memori.  Kami membuang data dari cache CPU.  Kami mengukur waktu. <br><br>  (Catatan: dalam <a href="">percobaan kedua,</a> saya mencoba menggunakan MOVNTDQA untuk memuat data, tetapi ini membutuhkan halaman memori non-cacheable khusus dan hak root). <br><br>  Di komputer saya, program menampilkan data berikut: <br><br><pre>  # timestamp, waktu siklus
 3101895733, 134
 3101895865, 132
 3101896002, 137
 3101896134, 132
 3101896268, 134
 3101896403, 135
 3101896762, 359
 3101896901, 139
 3101897038, 137 </pre><br>  Biasanya, siklus dengan durasi sekitar 140 ns diperoleh, secara berkala waktu melonjak menjadi sekitar 360 ns.  Terkadang hasil yang aneh muncul lebih dari 3200 ns. <br><br>  Sayangnya, datanya terlalu berisik.  Sangat sulit untuk melihat apakah ada penundaan nyata terkait dengan siklus pembaruan. <br><br><h1>  Transformasi Fourier Cepat </h1><br>  Pada titik tertentu saya sadar.  Karena kami ingin menemukan acara dengan interval tetap, kami dapat mengirimkan data ke algoritma FFT (transformasi Fourier cepat), yang mendekripsi frekuensi utama. <br><br>  Saya bukan orang pertama yang memikirkannya: Mark Seaborn dengan kerentanan terkenal <a href="">Rowhammer</a> menerapkan teknik ini pada tahun 2015.  Bahkan setelah melihat kode Mark, membuat FFT bekerja lebih sulit daripada yang saya harapkan.  Tetapi pada akhirnya, saya mengumpulkan semua bagian. <br><br>  Pertama, Anda perlu menyiapkan data.  FFT membutuhkan input dengan interval pengambilan sampel yang konstan.  Kami juga ingin memotong data untuk mengurangi kebisingan.  Dengan coba-coba, saya menemukan bahwa hasil terbaik dicapai setelah pemrosesan awal data: <br><br><ul><li>  Nilai-nilai kecil (kurang dari 1,8 rata-rata) dari iterasi loop terputus, diabaikan, dan diganti dengan nol.  Kami benar-benar tidak ingin membuat kebisingan. </li><li>  Semua bacaan lainnya diganti oleh unit, karena amplitudo penundaan yang disebabkan oleh beberapa kebisingan benar-benar tidak penting bagi kami. </li><li>  Saya memilih interval sampling 100 ns, tetapi angka berapa pun hingga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">frekuensi Nyquist (frekuensi yang diharapkan ganda) akan berhasil</a> . </li><li>  Data harus diambil sampelnya pada waktu yang tetap sebelum dikirim ke FFT.  Semua metode pengambilan sampel yang masuk akal berfungsi dengan baik, saya memilih interpolasi linear dasar. </li></ul><br>  Algoritme adalah sesuatu seperti ini: <br><br><pre> <code class="cpp hljs">UNIT=<span class="hljs-number"><span class="hljs-number">100</span></span>ns A = [(timestamp, loop_duration),...] p = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> curr_ts in frange(fist_ts, last_ts, UNIT): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp &lt;= curr_ts &lt; A[p].timestamp): p += <span class="hljs-number"><span class="hljs-number">1</span></span> v1 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v2 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v = estimate_linear(v1, v2, A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp, curr_ts, A[p].timestamp) B.append( v )</code> </pre> <br>  Yang pada data saya menghasilkan vektor yang agak membosankan seperti ini: <br><br><pre>  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...] </pre><br>  Namun, vektornya cukup besar, biasanya sekitar 200 ribu titik data.  Dengan data tersebut, Anda dapat menggunakan FFT! <br><br><pre> <code class="cpp hljs">C = numpy.fft.fft(B) C = numpy.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(C) F = numpy.fft.fftfreq(len(B)) * (<span class="hljs-number"><span class="hljs-number">1000000000</span></span>/UNIT)</code> </pre> <br>  Cukup sederhana, bukan?  Ini menghasilkan dua vektor: <br><br><ul><li>  C berisi sejumlah komponen frekuensi yang kompleks.  Kami tidak tertarik dengan bilangan kompleks, dan Anda dapat memuluskannya dengan perintah <code>abs()</code> . </li><li>  F berisi label, yang rentang frekuensi terletak di tempat vektor C. Kami menormalkan eksponen ke hertz dengan mengalikannya dengan frekuensi sampling dari vektor input. </li></ul><br>  Hasilnya dapat diplot pada grafik: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/580/d99/6ad/580d996adeb168c27821b2efb11bac2c.png"><br><br>  Sumbu Y tanpa unit, karena kami menormalkan waktu tunda.  Meskipun demikian, semburan terlihat jelas di beberapa rentang frekuensi tetap.  Mari kita pertimbangkan mereka lebih dekat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf2/d37/2ed/bf2d372ed5483d677e1d775b863c6b76.png"><br><br>  Kami jelas melihat tiga puncak pertama.  Setelah sedikit aritmatika yang tidak ekspresif, termasuk membaca pemfilteran setidaknya sepuluh kali rata-rata, Anda dapat mengekstrak frekuensi basis: <br><br><pre>  127850.0
 127900.0
 127950.0
 255700.0
 255750.0
 255800.0
 255850.0
 255900.0
 255950.0
 383600.0
 383650.0 </pre><br>  Kami menganggap: 1000000000 (ns / s) / 127900 (Hz) = 7818,6 ns <br><br>  Hore!  Lompatan pertama dalam frekuensi benar-benar apa yang kita cari, dan itu benar-benar berkorelasi dengan waktu pembaruan. <br><br>  Puncak yang tersisa pada 256 kHz, 384 kHz, 512 kHz adalah harmonik yang disebut yang merupakan kelipatan dari frekuensi dasar kami yaitu 128 kHz.  Ini adalah efek samping yang sepenuhnya diantisipasi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerapkan FFT ke sesuatu seperti gelombang persegi</a> . <br><br>  Untuk memfasilitasi percobaan, kami membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi untuk baris perintah</a> .  Anda dapat menjalankan kode sendiri.  Berikut adalah contoh peluncuran di server saya: <br><br><pre>  ~ / 2018-11-memory-refresh $ make
 gcc -msse4.1 -ggdb -O3 -Wall -Wextra ukur-dram.c -o ukur-dram
 ./measure-dram |  python3 ./analyze-dram.py
 [*] Memverifikasi ASLR: main = 0x555555554890 tumpukan = 0x7fffffefe2ec
 [] Fakta menyenangkan.  Saya melakukan 40663553 clock_gettime () per detik
 [*] Mengukur waktu MOVQ + CLFLUSH.  Menjalankan 131072 iterasi.
 [*] Menulis data
 [*] Input data: min = 117 rata-rata = 176 med = 167 maks = 8172 item = 131072
 [*] Kisaran cutoff 212-inf
 [] 127849 item di bawah cutoff, 0 item di atas cutoff, 3223 item tidak nol
 [*] Menjalankan FFT
 [*] Frekuensi teratas di atas 2kHz di bawah 250kHz memiliki besaran 7716
 [+] Paku frekuensi teratas di atas 2kHZ berada di:
 127906Hz 7716
 255813Hz 7947
 383720Hz 7460
 511626Hz 7141 </pre><br>  Saya harus akui, kodenya tidak sepenuhnya stabil.  Jika terjadi masalah, disarankan untuk menonaktifkan Turbo Boost, penskalaan frekuensi CPU, dan pengoptimalan untuk kinerja. <br><br><h1>  Kesimpulan </h1><br>  Ada dua kesimpulan utama dari karya ini. <br><br>  Kami melihat bahwa data tingkat rendah cukup sulit untuk dianalisis dan tampaknya agak bising.  Alih-alih mengevaluasi dengan mata telanjang, Anda selalu dapat menggunakan FFT tua yang baik.  Dalam persiapan data, perlu, dalam arti tertentu, untuk angan-angan. <br><br>  Yang paling penting, kami telah menunjukkan bahwa seringkali mungkin untuk mengukur perilaku perangkat keras yang halus dari proses sederhana di ruang pengguna.  Pemikiran semacam ini mengarah pada penemuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerentanan Rowhammer yang asli</a> , itu diimplementasikan dalam serangan Meltdown / Spectre dan sekali lagi ditunjukkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reinkarnasi Rowhammer</a> baru-baru ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk memori ECC</a> . <br><br>  Masih banyak di luar ruang lingkup artikel ini.  Kami nyaris tidak menyentuh operasi internal subsistem memori.  Untuk bacaan lebih lanjut, saya sarankan: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memetakan L3 Cache pada Prosesor Sandy Bridge</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana alamat fisik memetakan ke baris dan bank dalam DRAM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hannu Hartikainen meretas DDR3 SO-DIMM dan membuatnya bekerja ... lebih lambat</a> </li></ul><br>  Akhirnya, berikut ini adalah deskripsi yang baik dari memori ferit lama: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjelasan Memori Ferit PDP-11 dari University of Sydney</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431010/">https://habr.com/ru/post/id431010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430996/index.html">Bug LittleBigPlanet yang sulit dipahami</a></li>
<li><a href="../id430998/index.html">XMPP (Jabber) merilis server Prosody 0.11.0</a></li>
<li><a href="../id431000/index.html">Sindrom Plumbing: Aturan Kode Warisan untuk Pengujian</a></li>
<li><a href="../id431004/index.html">Sistem pengenalan wajah orang Tionghoa menganggap citra seseorang di bus sebagai pelanggar lalu lintas</a></li>
<li><a href="../id431006/index.html">InSight sedang bersiap untuk mendarat di Mars</a></li>
<li><a href="../id431012/index.html">Buat pembaca e-book menggunakan PDFKit di Swift</a></li>
<li><a href="../id431014/index.html">Flexbox Infografis teknologi</a></li>
<li><a href="../id431016/index.html">Amerika Serikat meminta mitra untuk meninggalkan penggunaan peralatan Huawei</a></li>
<li><a href="../id431018/index.html">Menerapkan sistem CRM? Buka kacamata merah muda</a></li>
<li><a href="../id431020/index.html">Laporan Club of Rome 2018, Bab 1.7 â€œPertumbuhan Populasi yang Tidak Berkelanjutan dan Urbanisasiâ€</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>