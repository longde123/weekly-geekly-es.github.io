<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìë üî£ ‚è≠Ô∏è Spring Data JPA: lo que es bueno y lo que es malo üí™üèø ‚úã üö£üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beb√© hijo vino a su padre 
 Y le pregunte al bebe 
 - lo que es bueno 
 y que es malo 
 
 Vladimir Mayakovsky 


 Este art√≠culo trata sobre Spring Dat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring Data JPA: lo que es bueno y lo que es malo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441386/"><p> <em>Beb√© hijo vino a su padre</em> <em><br></em>  <em>Y le pregunte al bebe</em> <em><br></em>  <em>- lo que es bueno</em> <em><br></em>  <em>y que es malo</em> <em><br></em> <br>  Vladimir Mayakovsky </p><br><p>  Este art√≠culo trata sobre Spring Data JPA, es decir, sobre el rastrillo submarino que conoc√≠ en mi camino y, por supuesto, sobre el rendimiento. </p><a name="habracut"></a><br><p>  Los ejemplos descritos en el art√≠culo se pueden ejecutar en el entorno de prueba, accesible por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">referencia</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Nota para aquellos que a√∫n no se han mudado a Spring Boot 2</b> <div class="spoiler_text"><p> En las versiones de Spring Data JPA 2. * la interfaz principal para trabajar con repositorios, concretamente <code>CrudRepository</code> , de la cual se hereda <code>JpaRepository</code> , ha <code>JpaRepository</code> .  En las versiones 1. * los m√©todos principales se ve√≠an as√≠: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span></span>; }</code> </pre> <br><p>  En nuevas versiones: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Optional&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span></span>; }</code> </pre> </div></div><br><p>  Entonces comencemos. </p><br><h4 id="select-t-from-t-where-tid-in-">  seleccione t. * desde t donde t.id en (...) </h4><br><p>  Una de las consultas m√°s comunes es una consulta de la forma "seleccionar todos los registros para los que la clave se encuentra en el conjunto transmitido".  Estoy seguro de que casi todos escribieron o vieron algo como </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> List&lt;Long&gt; ids)</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Set&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Estas son solicitudes adecuadas y que funcionan, no hay problemas de captura o rendimiento, pero hay un peque√±o inconveniente completamente discreto. </p><br><div class="spoiler">  <b class="spoiler_title">Antes de abrir el forro, trata de pensar por ti mismo.</b> <div class="spoiler_text"><p>  La desventaja es que la interfaz es demasiado estrecha para transmitir claves.  "¬øY qu√©?"  - usted dice  "Bueno, la lista, el conjunto, no veo ning√∫n problema aqu√≠".  Sin embargo, si observamos los m√©todos de la interfaz ra√≠z que toman muchos valores, en todas partes vemos <code>Iterable</code> : </p><br><p>  "¬øY qu√©? Y quiero una lista. ¬øPor qu√© es peor?" <br>  No peor, solo prep√°rate para la aparici√≥n de c√≥digo similar en un nivel superior en tu aplicaci√≥n: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Long&gt; userIds)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;Long&gt; ids = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(userIds); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.findByUserIds(ids); } <span class="hljs-comment"><span class="hljs-comment">// public List&lt;BankAccount&gt; findByUserIds(Set&lt;Long&gt; userIds) { List&lt;Long&gt; ids = new ArrayList&lt;&gt;(userIds); return repository.findByUserIds(ids); }</span></span></code> </pre> <br><p>  Este c√≥digo no hace m√°s que invertir las colecciones.  Puede suceder que el argumento del m√©todo sea una lista, y el m√©todo del repositorio acepta el conjunto (o viceversa), y solo tiene que volver a invocarlo para pasar la compilaci√≥n.  Por supuesto, esto no se convertir√° en un problema en el contexto de los costos generales de la solicitud en s√≠, se trata m√°s de gestos innecesarios. </p><br><p>  Por lo tanto, es una buena pr√°ctica usar <code>Iterable</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Z.Y.  Si estamos hablando de un m√©todo de <code>*RepositoryCustom</code> , entonces tiene sentido usar <code>Collection</code> para simplificar el c√°lculo del tama√±o dentro de la implementaci√≥n: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccountRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMoneyAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Long&gt; accountIds)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccountRepositoryImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMoneyAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Long&gt; accountIds)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ids.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre> </div></div><br><h4 id="lishniy-kod-nepovtoryayuschiesya-klyuchi">  C√≥digo extra: claves no duplicadas </h4><br><p>  En la continuaci√≥n de la √∫ltima secci√≥n, quiero llamar la atenci√≥n sobre un error com√∫n: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Set&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Otras manifestaciones del mismo error: </p><br><pre> <code class="java hljs">Set&lt;Long&gt; ids = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(notUniqueIds); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids); List&lt;Long&gt; ids = ts.stream().map(T::id).distinct().collect(toList()); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids); Set&lt;Long&gt; ids = ts.stream().map(T::id).collect(toSet()); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids);</code> </pre> <br><p>  A primera vista, nada inusual, ¬øverdad? </p><br><div class="spoiler">  <b class="spoiler_title">T√≥mate tu tiempo, piensa por ti mismo;)</b> <div class="spoiler_text"><p>  Las consultas HQL / JPQL del formulario <code>select t from t where t.field in ...</code> eventualmente se convertir√°n en una consulta </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> b.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> BankAccount b <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> b.user_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (?, ?, ?, ?, ?, ‚Ä¶)</code> </pre> <br><p>  que siempre devolver√° lo mismo independientemente de la presencia de repeticiones en el argumento.  Por lo tanto, para garantizar la unicidad de las claves no es necesario.  Hay un caso especial: Oracle, donde presionar m√°s de 1000 teclas conduce a un error.  Pero si est√° tratando de reducir el n√∫mero de teclas excluyendo repeticiones, entonces deber√≠a pensar en el motivo de su aparici√≥n.  Lo m√°s probable es que el error est√© en alg√∫n lugar arriba. </p><br><p>  Entonces, en un buen c√≥digo, use <code>Iterable</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> </div></div><br><h4 id="samopis">  Samopis </h4><br><p>  Eche un vistazo de cerca a este c√≥digo y encuentre aqu√≠ tres fallas y un posible error: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"from User u where u.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;User&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Piensa un poco mas</b> <div class="spoiler_text"><ul><li>  todo ya est√° implementado en <code>SimpleJpaRepository::findAllById</code> </li><li>  solicitud inactiva al pasar una lista vac√≠a (en <code>SimpleJpaRepository::findAllById</code> hay una verificaci√≥n correspondiente) </li><li>  todas las consultas descritas con <code>@Query</code> se verifican en la etapa de generar el contexto, lo que lleva tiempo (a diferencia de <code>SimpleJpaRepository::findAllById</code> ) </li><li>  si se usa Oracle, cuando la colecci√≥n de claves est√° vac√≠a, obtenemos el error <code>ORA-00936: missing expression</code> (que no suceder√° al usar <code>SimpleJpaRepository::findAllById</code> , ver punto 2) </li></ul></div></div><br><h4 id="garri-potter-i-sostavnoy-klyuch">  Harry potter y llave compuesta </h4><br><p>  Eche un vistazo a dos ejemplos y elija el que prefiera: </p><br><p>  M√©todo n√∫mero veces </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Embeddable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ Long key1; Long key2; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKeyEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@EmbeddedId</span></span> CompositeKey key; }</code> </pre> <br><p>  M√©todo n√∫mero dos </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Embeddable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ Long key1; Long key2; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@IdClass</span></span>(value = CompositeKey.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKeyEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long key1; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long key2; }</code> </pre> <br><p>  A primera vista, no hay diferencia.  Ahora prueba el primer m√©todo y ejecuta una prueba simple: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//case for @EmbeddedId @Test public void findAll() { int size = entityWithCompositeKeyRepository.findAllById(compositeKeys).size(); assertEquals(size, 5); }</span></span></code> </pre> <br><p>  En el registro de consultas (lo mantiene, ¬øverdad?) Veremos esto: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ?</code> </pre> <br><p>  Ahora segundo ejemplo </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//case for @Id @Id @Test public void _findAll() { int size = anotherEntityWithCompositeKeyRepository.findAllById(compositeKeys).size(); assertEquals(size, 5); }</span></span></code> </pre> <br><p>  El registro de consultas se ve diferente: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=?</code> </pre> <br><p>  Esa es la diferencia: en el primer caso, siempre recibimos 1 solicitud, en el segundo, n solicitudes. <br>  La raz√≥n de este comportamiento radica en <code>SimpleJpaRepository::findAllById</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ... if (entityInfo.hasCompositeId()) { List&lt;T&gt; results = new ArrayList&lt;&gt;(); for (ID id : ids) { findById(id).ifPresent(results::add); } return results; } // ...</span></span></code> </pre> <br><p>  El mejor m√©todo es el que debe determinar seg√∫n la importancia del n√∫mero de solicitudes. </p><br><h4 id="lishniy-crudrepositorysave">  Extra CrudRepository :: guardar </h4><br><p>  A menudo en el c√≥digo hay tal antipatr√≥n: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, BigDecimal rate)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setRate(rate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repo.save(account); }</code> </pre> <br><p>  El lector est√° perplejo: ¬ød√≥nde est√° el antipatr√≥n?  Este c√≥digo parece muy l√≥gico: obtenemos la entidad - actualizar - guardar.  Todo es como en las mejores casas de San Petersburgo.  Me atrevo a decir que llamar a <code>CrudRepository::save</code> es superfluo aqu√≠. </p><br><p>  Primero: el m√©todo <code>updateRate</code> transaccional, por lo tanto, Hibernate realiza un seguimiento de todos los cambios en la entidad administrada y se convierte en una solicitud cuando <code>Session::flush</code> ejecuta <code>Session::flush</code> , que en este c√≥digo ocurre cuando finaliza el m√©todo. </p><br><p>  En segundo lugar, <code>CrudRepository::save</code> un vistazo al m√©todo <code>CrudRepository::save</code> .  Como sabes, todos los repositorios se basan en <code>SimpleJpaRepository</code> .  Aqu√≠ est√° la implementaci√≥n de <code>CrudRepository::save</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInformation.isNew(entity)) { em.persist(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.merge(entity); } }</code> </pre> <br><p>  Hay una sutileza que no todos recuerdan: Hibernate funciona a trav√©s de eventos.  En otras palabras, cada acci√≥n del usuario genera un evento que se pone en cola y se procesa teniendo en cuenta otros eventos en la misma cola.  En este caso, una llamada a <code>EntityManager::merge</code> genera un <code>MergeEvent</code> , que se procesa de manera predeterminada en el <code>DefaultMergeEventListener::onMerge</code> .  Contiene una l√≥gica bastante ramificada pero simple para cada uno de los estados del argumento de entidad.  En nuestro caso, la entidad se obtiene del repositorio dentro del m√©todo transaccional y est√° en el estado PERSISTENTE (es decir, esencialmente controlado por el marco): </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entityIsPersistent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MergeEvent event, Map copyCache)</span></span></span><span class="hljs-function"> </span></span>{ LOG.trace(<span class="hljs-string"><span class="hljs-string">"Ignoring persistent instance"</span></span>); Object entity = event.getEntity(); EventSource source = event.getSession(); EntityPersister persister = source.getEntityPersister(event.getEntityName(), entity); ((MergeContext)copyCache).put(entity, entity, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cascadeOnMerge(source, persister, entity, copyCache); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- this.copyValues(persister, entity, entity, source, copyCache); //&lt;---- event.setResult(entity); }</span></span></code> </pre> <br><p>  El diablo est√° en los detalles, es decir, en los m√©todos <code>DefaultMergeEventListener::cascadeOnMerge</code> y <code>DefaultMergeEventListener::copyValues</code> .  Escuchemos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discurso directo de Vlad Mikhalche</a> , uno de los desarrolladores clave de Hibernate: </p><br><blockquote>  En la llamada al m√©todo copyValues, el estado hidratado se copia de nuevo, por lo que se crea una nueva matriz de forma redundante, lo que desperdicia los ciclos de la CPU.  Si la entidad tiene asociaciones secundarias y la operaci√≥n de fusi√≥n tambi√©n se conecta en cascada de entidades principales a secundarias, la sobrecarga es a√∫n mayor porque cada entidad secundaria propagar√° un Evento de combinaci√≥n y el ciclo contin√∫a. </blockquote><p>  En otras palabras, se est√° haciendo un trabajo que no puede hacer.  Como resultado, nuestro c√≥digo se puede simplificar mientras se mejora su rendimiento: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, BigDecimal rate)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setRate(rate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> account; }</code> </pre> <br><p>  Por supuesto, es inconveniente tener esto en cuenta al desarrollar y corregir el c√≥digo de otra persona, por lo que nos gustar√≠a realizar cambios a nivel de estructura met√°lica para que el m√©todo <code>JpaRepository::save</code> pierda sus propiedades da√±inas.  ¬øEs esto posible? </p><br><div class="spoiler">  <b class="spoiler_title">Si tal vez</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// @Transactional public &lt;S extends T&gt; S save(S entity) { if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else { return em.merge(entity); } } // @Transactional public &lt;S extends T&gt; S save(S entity) { if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else if (!em.contains(entity)) { return em.merge(entity); } return entity; }</span></span></code> </pre> <br><p>  Estos cambios se hicieron en diciembre de 2017: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://jira.spring.io/browse/DATAJPA-931</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/spring-projects/spring-data-jpa/pull/237</a> </p></div></div><br><p>  Sin embargo, el lector sofisticado probablemente ya sinti√≥ que algo andaba mal.  De hecho, este cambio no romper√° nada, sino solo en el caso simple cuando no hay entidades secundarias: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> BigDecimal rate = BigDecimal.ZERO; }</code> </pre> <br><p>  Ahora suponga que su propietario est√° vinculado a la cuenta: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> BigDecimal rate = BigDecimal.ZERO; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>) User user; }</code> </pre> <br><p>  Hay un m√©todo que le permite desconectar al usuario de la cuenta y transferirlo al nuevo usuario: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, User newUser)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setUser(newUser); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repo.save(account); }</code> </pre> <br><p>  ¬øQu√© pasar√° ahora?  La comprobaci√≥n de <code>em.contains(entity)</code> devolver√° verdadero, lo que significa que no se llamar√° a <code>em.merge(entity)</code> .  Si la clave de entidad de <code>User</code> se crea sobre la base de la secuencia (uno de los casos m√°s comunes), no se crear√° hasta que se complete la transacci√≥n (o <code>Session::flush</code> llame a <code>Session::flush</code> manualmente), es decir, el usuario estar√° en el estado DESCONECTADO y su entidad principal ( cuenta) - en el estado PERSISTENTE.  En algunos casos, esto puede romper la l√≥gica de la aplicaci√≥n, que es lo que sucedi√≥: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">02/03/2018 DATAJPA-931 rompe la fusi√≥n con RepositoryItemWriter</a> </p><br><p>  En este sentido, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se cre√≥</a> la tarea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Revert optimizaciones realizadas para entidades existentes en CrudRepository :: save</a> y se realizaron los cambios: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Revert DATAJPA-931</a> . </p><br><h4 id="slepoy-crudrepositoryfindbyid">  Blind CrudRepository :: findById </h4><br><p>  Seguimos considerando el mismo modelo de datos: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-comment"><span class="hljs-comment">// ... } @Entity public class BankAccount { @Id Long id; @ManyToOne @JoinColumn(name = "user_id") User user; }</span></span></code> </pre> <br><p>  La aplicaci√≥n tiene un m√©todo que crea una nueva cuenta para el usuario especificado: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); userRepository.findById(userId).ifPresent(account::setUser); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><p>  Con la versi√≥n 2. * el antipatr√≥n indicado por la flecha no es tan llamativo, se ve m√°s claramente en versiones anteriores: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); account.setUser(userRepository.findOne(userId)); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Si no ve la falla "a simple vista", eche un vistazo a las consultas:</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> u.id, u.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> u.id = ? <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hibernate_sequence <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> bank_account (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span> user_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span>)</code> </pre> </div></div><br><p>  La primera solicitud la obtenemos al usuario por clave.  A continuaci√≥n, obtenemos la clave para la cuenta de reci√©n nacido de la base de datos y la insertamos en la tabla.  Y lo √∫nico que tomamos del usuario es la clave, que ya tenemos como argumento de m√©todo.  Por otro lado, <code>BankAccount</code> contiene el campo "usuario" y no podemos dejarlo vac√≠o (como personas decentes establecemos una restricci√≥n en el esquema).  Los desarrolladores experimentados probablemente ya vean un camino <del>  y comer un pez, y montar a caballo </del>  obtener tanto el usuario como la solicitud de no: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); account.setUser(userRepository.getOne(userId)); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><p>  <code>JpaRepository::getOne</code> devuelve un contenedor sobre la clave que tiene el mismo tipo que la "entidad" viva.  Este c√≥digo solo da dos solicitudes: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hibernate_sequence <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> bank_account (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span> user_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*‚Ä¶*/</span></span>)</code> </pre> <br><p>  Cuando una entidad que se crea contiene muchos campos con una relaci√≥n de muchos a uno / uno a uno, esta t√©cnica ayudar√° a acelerar el ahorro y reducir la carga en la base de datos. </p><br><h4 id="ispolnenie-hql-zaprosov">  Ejecutando consultas HQL </h4><br><p>  Este es un tema separado e interesante :).  El modelo de dominio es el mismo y existe tal solicitud: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select count(ba) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from BankAccount ba "</span></span> + <span class="hljs-string"><span class="hljs-string">" join ba.user user "</span></span> + <span class="hljs-string"><span class="hljs-string">" where user.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUserAccounts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p>  Considere la HQL "pura": </p><br><pre> <code class="plaintext hljs">select count(ba) from BankAccount ba join ba.user user where user.id = :id</code> </pre> <br><p>  Cuando se ejecute, se crear√° la siguiente consulta SQL: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ba.user_id = u.id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> u.id = ?</code> </pre> <br><p>  El problema aqu√≠ no es evidente de inmediato, incluso por una vida sabia y una buena comprensi√≥n de los desarrolladores de SQL: <code>inner join</code> por clave de usuario excluir√° las cuentas con falta de <code>user_id</code> de la selecci√≥n (y de una buena manera, insertarlas deber√≠a estar prohibido en el nivel de esquema), lo que significa que no es <code>user_id</code> unirse a la tabla de <code>user</code> Necesito  La solicitud se puede simplificar (y acelerar): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ba.user_id = ?</code> </pre> <br><p>  Hay una manera de lograr f√°cilmente este comportamiento en c usando HQL: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select count(ba) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from BankAccount ba "</span></span> + <span class="hljs-string"><span class="hljs-string">" where ba.user.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUserAccounts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p>  Este m√©todo crea una solicitud "lite". </p><br><h4 id="annotaciya-query-protiv-metoda">  Consulta vs m√©todo abstracto </h4><br><p>  Una de las caracter√≠sticas principales de Spring Data es la capacidad de crear una consulta a partir del nombre del m√©todo, lo cual es muy conveniente, especialmente en combinaci√≥n con el complemento inteligente de IntelliJ IDEA.  La consulta descrita en el ejemplo anterior se puede reescribir f√°cilmente: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// @Query("select count(ba) " + " from BankAccount ba " + " where ba.user.id = :id") long countUserAccounts(@Param("id") Long id); // long countByUserAccount_Id(Long id);</span></span></code> </pre> <br><p>  Parece ser m√°s simple, m√°s corto, m√°s legible y, lo m√°s importante, no es necesario que mire la solicitud en s√≠.  Le√≠ el nombre del m√©todo, y ya est√° claro qu√© elige y c√≥mo.  Pero el diablo est√° aqu√≠ en los detalles.  La consulta final para el m√©todo marcado con <code>@Query</code> ya hemos visto.  ¬øQu√© pasar√° en el segundo caso? </p><br><div class="spoiler">  <b class="spoiler_title">Babah!</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> // &lt;<span class="hljs-comment"><span class="hljs-comment">--- !!!!!!! user u on ba.user_id = u.id where u.id = ?</span></span></code> </pre> </div></div><br><p>  "¬øQu√© demonios?"  - El desarrollador exclamar√°.  Despu√©s de todo, ya hemos visto eso <del>  violinista </del>  <code>join</code> no <code>join</code> necesario. </p><br><p>  La raz√≥n es prosaica: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JPADATAJPA-729 UNOUTER OUTER innecesario se genera para contar una sola tabla</a> </li><li><del>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DATAJPA-1238 √öNICA IZQUIERDA EXTERIOR √öNASE cuando un DONDE podr√≠a haberse utilizado</a> </del></li></ul><br><p>  Si a√∫n no ha actualizado a las versiones parcheadas, y unirse a la tabla ralentiza la solicitud aqu√≠ y ahora, entonces no se desespere: hay dos formas de aliviar el dolor: </p><br><ul><li><p>  una buena manera es agregar <code>optional = false</code> (si el circuito lo permite): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>, optional = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) User user; }</code> </pre> <br></li><li><p>  La forma de muleta es agregar una columna del mismo tipo que la clave de entidad de <code>User</code> y usarla en consultas en lugar del campo de <code>user</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>) User user; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>, insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) Long userId; }</code> </pre> <br><p>  Ahora la solicitud de m√©todo ser√° m√°s agradable: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countByUserId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span></span>;</code> </pre> <br><p>  da </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ba.user_id = ?</code> </pre> <br><p>  ¬øQu√© logramos? </p><br></li></ul><br><h4 id="ogranichenie-vyborki">  L√≠mite de muestreo </h4><br><p>  Para nuestros prop√≥sitos, necesitamos limitar la selecci√≥n (por ejemplo, queremos devolver <code>Optional</code> desde el m√©todo <code>*RepositoryCustom</code> ): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ba.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ba.rate <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> ?</code> </pre> <br><p>  Ahora Java: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithHighestRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select b from BankAccount b order by b.rate"</span></span>; BankAccount account = em .createQuery(query, BankAccount.class) .setFirstResult(<span class="hljs-number"><span class="hljs-number">0</span></span>) .setMaxResults(<span class="hljs-number"><span class="hljs-number">1</span></span>) .getSingleResult(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Optional.ofNullable(bankAccount); }</code> </pre> <br><p>  El c√≥digo especificado tiene una caracter√≠stica desagradable: en el caso de que la solicitud devuelva una selecci√≥n vac√≠a, se generar√° una excepci√≥n </p><br><pre> <code class="plaintext hljs">Caused by: javax.persistence.NoResultException: No entity found for query</code> </pre> <br><p>  En los proyectos que vi, esto se resolvi√≥ de dos maneras principales: </p><br><ul><li>  try-catch con variaciones de <code>Optonal.empty()</code> sin rodeos <code>Optonal.empty()</code> excepci√≥n y devolver <code>Optonal.empty()</code> a m√©todos m√°s avanzados, como pasar una lambda con una solicitud a un m√©todo de utilidad </li><li>  aspecto en el que los m√©todos de repositorio envueltos regresan <code>Optional</code> </li></ul><br><p>  Y muy raramente, vi la soluci√≥n correcta: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithHighestRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select b from BankAccount b order by b.rate"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.unwrap(Session.class) .createQuery(query, BankAccount.class) .setFirstResult(<span class="hljs-number"><span class="hljs-number">0</span></span>) .setMaxResults(<span class="hljs-number"><span class="hljs-number">1</span></span>) .uniqueResultOptional(); }</code> </pre> <br><p>  <code>EntityManager</code> es parte del est√°ndar JPA, mientras que <code>Session</code> pertenece a Hibernate y es en mi humilde opini√≥n una herramienta m√°s avanzada, que a menudo se olvida. </p><br><h4 id="inogda-vrednoe-uluchshenie">  [A veces] mejora perjudicial </h4><br><p>  Cuando necesita obtener un campo peque√±o de una entidad "gruesa", hacemos esto: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select a.available from BankAccount a where a.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findIfAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p>  La solicitud le permite obtener un campo del tipo <code>boolean</code> sin cargar toda la entidad (con la adici√≥n de un cach√© de primer nivel, verificar los cambios al final de la sesi√≥n y otros gastos).  A veces, esto no solo no mejora el rendimiento, sino viceversa: crea consultas innecesarias desde cero.  Imagine un c√≥digo que realiza algunas comprobaciones: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount acc = repository.findById(id).orElseThow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... return repository.findIfAvailable(id); }</span></span></code> </pre> <br><p>  Este c√≥digo realiza al menos 2 solicitudes, aunque la segunda podr√≠a evitarse: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount acc = repository.findById(id).orElseThow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... return repository.findById(id) //    .map(BankAccount::isAvailable) .orElseThrow(IllegalStateException::new); }</span></span></code> </pre> <br><p>  La conclusi√≥n es simple: no descuide el cach√© del primer nivel, en el marco de una transacci√≥n, solo el primer <code>JpaRepository::findById</code> refiere a la base de datos, <code>JpaRepository::findById</code> cach√© del primer nivel siempre est√° <code>JpaRepository::findById</code> y vinculado a una sesi√≥n, que generalmente est√° vinculada a la transacci√≥n actual. </p><br><p>  Pruebas para jugar (el enlace al repositorio se encuentra al principio del art√≠culo): </p><br><ul><li>  prueba de interfaz estrecha: <code>InterfaceNarrowingTest</code> </li><li>  prueba para un ejemplo con una clave compuesta: <code>EntityWithCompositeKeyRepositoryTest</code> </li><li>  prueba exceso <code>CrudRepository::save</code> : <code>ModifierTest.java</code> </li><li>  prueba ciega <code>CrudRepository::findById</code> : <code>ChildServiceImplTest</code> </li><li>  prueba de <code>left join</code> innecesaria: <code>BankAccountControlRepositoryTest</code> </li></ul><br><p>  El costo de una llamada adicional a <code>CrudRepository::save</code> se puede calcular usando <code>RedundantSaveBenchmark</code> .  Se inicia utilizando la clase <code>BenchmarkRunner</code> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441386/">https://habr.com/ru/post/441386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441376/index.html">M√°s all√° de la pureza: qu√© puede y qu√© no puede revertir la membrana de √≥smosis</a></li>
<li><a href="../441378/index.html">Investigadores de Google: para protegerse contra Spectre requiere un cambio en la arquitectura del procesador, los parches de software no ayudar√°n</a></li>
<li><a href="../441380/index.html">7 puntos de crecimiento de conversi√≥n o c√≥mo aumentar la posibilidad de hacer clic en los botones</a></li>
<li><a href="../441382/index.html">Cient√≠ficos chinos han desarrollado un generador piezoel√©ctrico para marcapasos</a></li>
<li><a href="../441384/index.html">Impresi√≥n masiva en Windows</a></li>
<li><a href="../441388/index.html">Rayas de cebra: es una zona de exclusi√≥n a√©rea para mosquitos</a></li>
<li><a href="../441390/index.html">No solo un tel√©fono plegable: Samsung ha actualizado toda su l√≠nea de dispositivos port√°tiles</a></li>
<li><a href="../441392/index.html">Funciones de CPU RDRAND y RDSEED ahora disponibles</a></li>
<li><a href="../441394/index.html">Arte ASCII "aplicado"</a></li>
<li><a href="../441398/index.html">Cruise abre el c√≥digo fuente de Worldview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>