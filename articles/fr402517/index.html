<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèæ üë©üèº‚Äçüè´ üëú √âcrans graphiques et texte Winstar üôéüèª üî• ‚öîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les affichages graphiques, y compris ceux du type OLED, les plus repr√©sent√©s sur notre march√© par Winstar, ont une demande beaucoup plus faible par ra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√âcrans graphiques et texte Winstar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402517/"> Les affichages graphiques, y compris ceux du type OLED, les plus repr√©sent√©s sur notre march√© par Winstar, ont une demande beaucoup plus faible par rapport aux minuscules et les publications sur leur utilisation sont √©galement beaucoup moins.  Pendant ce temps, ce sont les √©crans OLED graphiques qui, en raison de l'absence de liaison aux tables de polices d'un mod√®le pr√©d√©fini, constituent le meilleur moyen d'obtenir des dispositifs d'affichage ergonomiques pour une grande vari√©t√© de besoins.  De plus, il s'est av√©r√© que le mode graphique du contr√¥leur WS0010 est plus facile √† initier et fonctionne plus stable que le mode texte. <br><br>  Avant de passer √† l'examen des affichages graphiques r√©els, nous examinerons le probl√®me persistant des probl√®mes d'activation du mode texte du contr√¥leur WS0010, qui a re√ßu une solution inattendue et √©vidente (oh, o√π √©taient mes yeux!). <br><a name="habracut"></a><br><h3>  R√©solution des probl√®mes du mode texte WS0010 </h3><br>  Il est bien connu que les √©crans de ligne Winstar ont des probl√®mes de stabilit√© lors de l'initialisation.  Soit dit en passant, il s'est av√©r√© que ce n'√©tait pas unique aux ¬´damn√©s chinois¬ª: les √©chantillons de Newhaven Display 16x2, que j'ai obtenus avec grande difficult√©, situ√©s de l'autre c√¥t√© du globe, sont en externe une copie compl√®te de Winstar, √† l'exception de l'emplacement de certaines inscriptions et du nom de la soci√©t√© sur la tache ( la m√™me forme et la m√™me police): <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/5c4/0e4/db8/5c40e4db8577cfcdacad5ecdf2652606.jpg" width="600" alt="image"><br><br>  Contenant, comme il est √©crit dans les fiches techniques, un certain contr√¥leur "LCD comparable", ces √©crans se comportent de mani√®re totalement identique aux chinois et pr√©sentent les m√™mes inconv√©nients.  √âvidemment, vous ne devriez pas passer du temps √† v√©rifier d'autres soci√©t√©s, telles que Midas: √† en juger par cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publication</a> , cela ne pourrait se passer d'une coop√©ration internationale.  L'√©conomie mondialis√©e rulez! <br><br>  Les difficult√©s du mode texte s'expriment dans le fait qu'au d√©marrage (par exemple, lors du red√©marrage ou de la r√©initialisation manuelle du programme du contr√¥leur de contr√¥le), des ordures peuvent appara√Ætre sur les √©crans, et les lignes 0 et 1 changent de place de mani√®re al√©atoire.  Les exp√©riences ont montr√© que cela ne d√©pend pas de la m√©thode d'inclusion (8 bits ou 4 bits).  Ce probl√®me est particuli√®rement aigu lorsque des red√©marrages p√©riodiques du logiciel sont n√©cessaires, par exemple, par Watchdog-timer. <br><br>  Une partie du probl√®me est une attitude soign√©e vis-√†-vis de l'alimentation (√† partir d'une source distincte, et en aucun cas de l'USB Arduino), et un red√©marrage s√©par√© en √©teignant et rallumant l'√©cran apr√®s avoir d√©marr√© le programme de contr√¥le (voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publication pr√©c√©dente de</a> l'auteur).  Il s'est av√©r√© que l'auteur de ces lignes n'√©tait pas le seul √† proposer une solution similaire au probl√®me: l'auteur du module compl√©mentaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LuquidCrystal</a> appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WinstarOLED a</a> √©galement inclus un pw_pin sp√©cial, avec lequel la puissance d'affichage est d√©form√©e au moment du d√©marrage du programme. <br><br>  Mais ce ne sont bien s√ªr que des initiatives et des demi-mesures.  Quelqu'un SeregaB est tomb√© sur un chemin radical (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sa publication</a> sur easyelectronics.ru - merci √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tomasina</a> pour l'astuce).  En fait, il a pos√© une t√¢che compl√®tement diff√©rente: apprendre √† travailler uniquement avec le mode graphique plut√¥t qu'avec le mode texte.  En essayant de basculer entre les modes, il a rapidement d√©couvert que " <i>passer au mode graphique √©tait normal, et du graphique au" texte "- tr√®s maladroit</i> ."  Puis il s'est souvenu qu '¬´ <i>il y a longtemps, lorsque les DSh √©taient encore imprim√©s sur du papier, dans certains DSh du HD44780, j'ai lu que les modes de commutation ne devaient √™tre effectu√©s que lorsque l'√©cran √©tait √©teint</i> ¬ª.  Et √ßa a march√©. <br><br>  √Ä partir de la publication cit√©e, je vais simplement reproduire deux proc√©dures de commutation ici, en les adaptant l√©g√®rement pour une utilisation avec LuquidCrystal (l'instance de classe est appel√©e OLED1 ici). <br><br>  Passer en mode graphique: <br><pre><code class="hljs cmake">OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08);//  OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x1F);//   OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x01);//    (..  clear()) OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08|<span class="hljs-number"><span class="hljs-number">0</span></span>x04);// </code> </pre> <br>  Passer en mode texte: <br><pre> <code class="hljs cmake"> OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08);//  OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x17);//    OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x01);//    (..  clear()) OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x04 | <span class="hljs-number"><span class="hljs-number">0</span></span>x08);// </code> </pre> <br>  Comme nous le verrons plus tard, la premi√®re proc√©dure n'est pas vraiment n√©cessaire: le WS0010 passe en mode graphique √† partir d'un demi-coup, il suffit de lui envoyer la commande 0x1F.  Mais la deuxi√®me s√©quence de commandes √©tait tout √† fait le cas.  Pour l'√©chantillon, il a √©t√© inclus directement dans l'esquisse √† l'aide de LuquidCrystal sous cette forme: <br><pre> <code class="hljs ruby">void reset_textmode() /<span class="hljs-regexp"><span class="hljs-regexp">/     { OLED1.command(0x08);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  OLED1.command(0x17);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    OLED1.command(0x01);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    OLED1.command(0x04 | 0x08);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  }</span></span></code> </pre> <br>  Ensuite, cette fonction a √©t√© appel√©e dans la configuration juste apr√®s le lancement de la biblioth√®que: <br><br><pre> <code class="hljs ruby"> . . . . . OLED1.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">16</span></span>  <span class="hljs-number"><span class="hljs-number">2</span></span>  reset_textmode(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  clear() . . . . .</code> </pre> <br>  Si vous ins√©rez un d√©lai (500) avant cela, la d√©monstration se r√©v√®le tr√®s √©vidente: apr√®s avoir appuy√© sur le bouton de r√©initialisation de la carte Arduino sur l'√©cran, comme d'habitude, des ordures apparaissent, mais seulement pendant un moment: apr√®s le d√©clenchement de la fonction, l'√©cran est effac√© et toutes les lignes sont de retour en place . <br><br>  La fonction fonctionne comme √ßa, mais pour plus de commodit√©, j'ai remplac√© le contenu de la fonction LiquidCrystalRus :: clear () dans le fichier de la biblioth√®que LiquidCrystalRus_OLED.cpp mise √† niveau qui a √©t√© discut√©e pr√©c√©demment avec cette s√©quence de commandes (je vous rappelle que <a href="">vous pouvez la t√©l√©charger</a> depuis le site de l'auteur).  Il n'y a pas d'attente pour que la commande soit ex√©cut√©e dans la biblioth√®que, donc pour la fiabilit√©, apr√®s chaque commande il y a des retards de 100 Œºs ins√©r√©s dans le style g√©n√©ral de la biblioth√®que.  Dans les esquisses utilisant cette variante de LiquidCrystalRus_OLED, au d√©but de la configuration, il est n√©cessaire d'appeler la fonction clear (), et en m√™me temps cela effacera l'√©cran. <br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text">  Il y a un probl√®me avec le nettoyage de l'√©cran: dans la fiche technique du tableau des commandes, il est not√© que la commande 0x01 peut durer aussi longtemps que 6,2 ms ¬´lorsque fsp ou fosc = 250KHz¬ª.  Quel type de "fsp ou fosc" est en fait dans des contr√¥leurs sp√©cifiques, ils √©taient trop paresseux pour √©crire, mais en tout cas, m√™me si c'est m√©gahertz, le d√©lai pour cette commande devrait √™tre important (et l'auteur de LiquidCrystal le mentionne).  Cependant, dans la pratique, il s'av√®re que l'√©quipe de nettoyage travaille pour elle-m√™me s'il n'y a aucun retard.  Je n'ai donc pas compris, mais j'ai agi selon la r√®gle de programmation bien connue: "√ßa marche - ne touchez pas!". <br></div></div><br>  Passons maintenant au mode graphique. <br><br><h3>  Le mode graphique dans le texte affiche WEH001602 </h3><br>  Pour commencer, j'ai essay√© de basculer l'affichage de texte que j'avais WEH001602BG en mode graphique.  Notez que les affichages graphiques 100x16 et texte (configuration 20x2, 16x2 ont juste moins de points horizontaux) ont des matrices identiques, seuls les affichages texte sont s√©par√©s par des intervalles de familiarit√©.  Cela limite consid√©rablement l'utilisation du mode graphique dans les affichages de texte, et encore plus du mode texte dans les graphiques.  Mais pour tester son fonctionnement, vous pouvez utiliser n'importe lequel d'entre eux. <br><br>  L'√©cran avec le DS1307 a √©t√© connect√© √† l'Arduino Nano selon le sch√©ma suivant: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/606/8e2/216/6068e2216b082857a72cd76f322628e3.png" width="600" alt="image"><br><br>  Selon le m√™me sch√©ma, nous connecterons √† l'avenir des affichages graphiques.  La couleur grise dans le diagramme montre la connexion du deuxi√®me √©cran, si n√©cessaire. <br><br>  Pour passer en mode graphique, vous pouvez utiliser la proc√©dure am√©lior√©e de la section pr√©c√©dente, mais une fonction simple √† partir d'une seule commande fonctionne: <br><pre> <code class="hljs cs">. . . . . <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LCD_SETGRAPHICMODE 0x1f LiquidCrystal lcd(9, 4, 8, 7, 6, 5); void setGraphicMode(){ lcd.command(LCD_SETGRAPHICMODE); } . . . . .</span></span></code> </pre> <br>  Nous n'avons pas besoin de table russe ici, par cons√©quent, le LiquidCrystal standard (non redress√©) est utilis√©, qui fonctionne parfaitement en mode graphique.  Afin de ne pas g√¢cher le d√©bogage de toutes les options de biblioth√®que, dans le cas o√π le texte et les affichages graphiques sont inclus en parall√®le, alors pour chacun j'utilise ma propre biblioth√®que (pour le texte mis √† jour Rus_OLED, pour le graphique normal).  Dans ce cas, la connexion peut toujours √™tre √©tablie sur les m√™mes branches du contr√¥leur, √† l'exception des broches de sortie E, conform√©ment au sch√©ma ci-dessus. <br><br>  De plus, j'ai partiellement utilis√© les r√©alisations de l'auteur de la biblioth√®que WinstarOLED mentionn√©e (en soi, ce module compl√©mentaire pour LuquidCrystal est, √† mon avis, incomplet, et il n'est pas pratique de l'utiliser comme).  Il a introduit une fonction pratique pour r√©gler le curseur graphique (l'erreur d'origine concernant la valeur maximale de <i>x a</i> √©t√© corrig√©e ici): <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGraphicCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">99</span></span> ){ lcd.command(LCD_SETDDRAMADDR | x); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ){ lcd.command(LCD_SETCGRAMADDR | y); } }</code> </pre> <br>  La constante LCD_SETDDRAMADDR est d√©finie dans la biblioth√®que LiquidCrystal.  Un affichage 100x16, comme un affichage texte, est divis√© en deux lignes, 0 et 1, car <i>y</i> ne peut prendre que deux valeurs ici.  Et la coordonn√©e horizontale <i>x</i> varie de 0 √† 99. Un octet est envoy√© avec la commande lcd.write (), dont les bits individuels d√©terminent les positions lumineuses de la ligne verticale d'une longueur de 8 points.  La position la plus √† gauche dans la ligne sup√©rieure a les coordonn√©es 0,0, la plus √† droite en bas - 99,1.  De plus, le point le plus bas correspondra au bit le moins significatif et le point le plus bas - le plus haut. <br><br>  Pour la commodit√© de l'encodage des images, j'ai dessin√© une plaque dans laquelle vous pouvez rapidement cr√©er manuellement le code souhait√©.  Pour des tableaux de polices complets, bien s√ªr, il est conseill√© d'utiliser des √©diteurs sp√©ciaux (il existe au moins un million de degr√©s diff√©rents d'activit√© amateur), mais 10 chiffres avec l'ordre de bits souhait√© sont plus rapides √† traiter manuellement, d'autant plus que les polices cr√©√©es automatiquement doivent souvent encore √™tre finies √† la main.  Conform√©ment √† ce qui pr√©c√®de, un glyphe, par exemple, la police num√©ro 2 10x16 sera cod√© comme suit: <br><br><img src="http://revich.lib.ru/AVR/TableCod2.png" width="400" alt="image"><br><br>  Tout cela est √©crit dans un tableau √† deux dimensions de la forme: <br><pre> <code class="hljs markdown">const byte Data2[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">10</span></span>]={{0x06,0x07,0x03,0x03,0x03,0x83,0xc3,0x63,0x3f,0x1e}, {0xf0,0xf8,0xcc,0xc6,0xc3,0xc1,0xc0,0xc0,0xc0,0xc0}};</code> </pre> <br>  Pour chaque chiffre 0-9, un tel tableau distinct est cr√©√©: Data0, Data1, Data2, etc.  Pour les montres, en plus des chiffres, vous aurez √©galement besoin d'un double point.  Il peut √™tre raccourci: <br><pre> <code class="hljs markdown">const byte DataDP[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">2</span></span>]={{0x70,0x70}, {0x1c,0x1c}};// </code> </pre> <br>  √âtant donn√© que le contr√¥leur ne sait pas ¬´clignoter¬ª en mode graphique, il est n√©cessaire de clignoter par programmation les deux-points.  Vous pouvez √©teindre un double point simplement en affichant des z√©ros dans les positions correspondantes, mais pour l'uniformit√© j'ai fait un tableau s√©par√© <br><pre> <code class="hljs markdown">const byte DataDPclr[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">2</span></span>]={{0x00,0x00}, {0x00,0x00}};// . </code> </pre> <br>  Pour afficher chaque chiffre et s√©par√©ment pour un double point, une fonction distincte est √©crite: <br><pre> <code class="hljs powershell">void draw2 (byte x/* */) // ‚Äú<span class="hljs-number"><span class="hljs-number">2</span></span>‚Äù { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">10</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.write(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.write(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]);} }</code> </pre> <br>  Toutes les fonctions sont les m√™mes, mais utilisent des tableaux diff√©rents, et pour un double point, d'autres limites de la boucle sont √©galement utilis√©es.  Il s'est av√©r√© ne pas √™tre trop √©conomique en termes de quantit√© de code (voir plus loin √† ce sujet), mais il est clair et facile de corriger les erreurs.  Les √©carts entre les caract√®res sont pris en compte au niveau de la sortie, indiquant la position correspondante (la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">biblioth√®que RTClib</a> est utilis√©e pour lire l'horloge): <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { DateTime clock = RTC.now(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clock.second()!=old_second) { uint8_t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.hour()/<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.hour()%<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.minute()/<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.minute()%<span class="hljs-number"><span class="hljs-number">10</span></span>; //<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>   drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clock.second()%<span class="hljs-number"><span class="hljs-number">2</span></span>) drawDP(<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drawDPclr(<span class="hljs-number"><span class="hljs-number">24</span></span>); old_second=clock.second(); }//<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> clocksecond }</code> </pre> <br>  Dix chiffres de 20 octets chacun occuperont 200 octets en m√©moire - environ 10% de son volume (et la police large est 16x16, comme dans l'exemple ci-dessous, et tous les 16%).  Une police monolingue compl√®te de cette taille, accompagn√©e de chiffres, sans tenir compte de toutes sortes de signes de ponctuation et sp√©ciaux.  caract√®res, contient de 62 (anglais) √† 74 (russe sans E), la valeur occupera pr√®s de la moiti√© de la RAM ATmega328.  Par cons√©quent, les astuces avec des tableaux et des fonctions de sortie s√©par√©ment pour chaque personnage devront √™tre annul√©es et faire comme pr√©vu.  Autrement dit, les polices doivent √™tre laiss√©es dans la m√©moire du programme et t√©l√©charg√©es via PROGMEM, et tous les mod√®les de glyphes doivent √™tre organis√©s en un seul tableau de polices et charg√©s pour la sortie par num√©ro de symbole dans une seule table.  Sinon, la m√©moire sera insuffisante et le code du programme se gonflera √† un volume incontr√¥lable.  Ici, nous ne nous attarderons pas sur cela, car dans nos exemples simples, tout cela n'est pas n√©cessaire - chaque fois, nous serons limit√©s √† un petit nombre strictement n√©cessaire de caract√®res. <br><br>  En raison de la grande taille du texte int√©gral du croquis GraphicOLED_DC1307, je ne l'apporte pas; vous pouvez le t√©l√©charger <a href="">ici</a> .  La fonction resetOLED est enregistr√©e dans le texte, ce qui fausse la puissance d'affichage lorsque le contr√¥leur red√©marre (via pwrPin D2), mais elle n'a jamais √©t√© n√©cessaire, elle peut donc √™tre supprim√©e en toute s√©curit√©.  Le r√©sultat du programme est montr√© sur la photo: <br><br><img src="http://revich.lib.ru/AVR/WEH1602_clock.jpg" width="600" alt="image"><br><br>  Malheureusement, le s√©jour simultan√© en mode texte et graphique est exclu.Par cons√©quent, si vous souhaitez utiliser l'espace restant, vous devrez dessiner vos propres polices (il reste de la place pour environ 7 caract√®res de police 5x7 dans chaque ligne). <br><br><h3>  Affichage graphique WEG010016A </h3><br>  Lorsque, enfin, les affichages graphiques command√©s WEG010016AL sont arriv√©s, j'ai commenc√© par essayer de les mettre en mode texte afin de voir ce qu'il en √©tait advenu. <br><br>  Pour v√©rifier le mode texte, un programme de simulation d'un affichage de l'horloge calendaire avec un capteur de temp√©rature externe, d√©crit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans une publication pr√©c√©dente, a</a> √©t√© t√©l√©charg√©.  Le r√©sultat m'a rappel√© que diff√©rents affichages Winstar peuvent √™tre orient√©s diff√©remment par rapport au connecteur (dans ce cas, le WEG010016A a un connecteur en haut, pour le texte WEH001602B, que nous avons utilis√© ci-dessus, en bas et pour le type C sur le c√¥t√©): <br><br><img src="http://revich.lib.ru/AVR/WEG10016_test.jpg" width="600" alt="image"><br><br>  Nous traiterons plus loin de l'orientation de l'affichage, mais pour l'instant, nous verrons ce qui s'est pass√©.  Mais cela n'a rien de bon: le mode texte (bien s√ªr, √©quip√© d'une b√©quille, qui a √©t√© discut√© au d√©but de l'article) fonctionne parfaitement, mais en pratique, cela n'a aucun sens en raison du manque d'espaces entre les personnages.  Par cons√©quent, nous ne nous attarderons pas l√†-dessus, mais passons √† l'examen du mode graphique. <br><br>  Les proc√©dures d'installation en mode graphique elles-m√™mes sont les m√™mes que celles d√©crites ci-dessus pour la version texte.  Il reste √† faire face au flip de l'√©cran s'il dispose d'un connecteur en haut de l'√©cran.  Bien s√ªr, vous pouvez simplement retourner l'√©cran, mais la position avec le connecteur orient√© vers le bas me semble plus naturelle et plus pratique.  En outre, lorsque vous utilisez un type avec un connecteur sur le c√¥t√©, vous devrez peut-√™tre orienter le connecteur vers la droite plut√¥t que vers la gauche.  Pour l'orientation ¬´√† l'envers¬ª, il est n√©cessaire de transformer l'image - c'est-√†-dire, d'√©changer les premi√®re et derni√®re positions horizontales, lignes, et √©galement inverser l'ordre des bits dans les octets qui composent le tableau (le bit le moins significatif correspondra au point inf√©rieur). <br><br>  Comme j'avais d√©j√† peint dix chiffres pour le cas pr√©c√©dent, il restait pour la derni√®re t√¢che √† introduire la proc√©dure d'inversion de programme: <br><pre> <code class="hljs matlab">byte reverse(byte x) { byte result=<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>)) { result |= <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">7</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Vous pouvez modifier l'ordre des coordonn√©es horizontales et des lignes verticales en modifiant la fonction setGraphicCursor: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGraphicCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">99</span></span> ){ lcd.command(LCD_SETDDRAMADDR | (<span class="hljs-number"><span class="hljs-number">99</span></span>-x)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ){ lcd.command(LCD_SETCGRAMADDR | (<span class="hljs-number"><span class="hljs-number">1</span></span>-y)); } }</code> </pre> <br>  Les fonctions de sortie du tableau de chaque chiffre restent les m√™mes, seule l'inversion des bits est ajout√©e: <br><pre> <code class="hljs powershell">void draw2 (byte x/* */) // <span class="hljs-number"><span class="hljs-number">2</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">10</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); byte b=reverse(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=reverse(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b);} }</code> </pre> <br>  Le croquis complet de la sortie de la montre GraphicOLED_DC1307_100x16 peut √™tre t√©l√©charg√© √† <a href="">partir d'ici</a> , et le r√©sultat pour l'affichage WEG010016AL est montr√© sur la photo: <br><br><img src="http://revich.lib.ru/AVR/WEG10016_clock.jpg" width="600" alt="image"><br><br>  Mais sur cette photo, une police d'un type diff√©rent (16x16) sur l'√©cran WEG010016CG (l'affichage est √©galement √† l'envers): <br><br><img src="http://revich.lib.ru/AVR/WEG10016CG_clock.jpg" width="600" alt="image"><br><br>  Si vous recr√©ez la police en modifiant manuellement l'ordre des bits, il n'est pas n√©cessaire de faire l'inverse et le programme s'ex√©cutera plus rapidement (bien qu'il n'y ait pas de retards notables dans l'≈ìil).  Mais la proc√©dure de retournement de bits donn√©e est utile dans tous les cas - pour afficher diverses images.  Par exemple, √† partir d'une fl√®che pointant vers le haut et vers la droite, vous pouvez obtenir par programme quatre directions √† la fois. <br><div class="spoiler">  <b class="spoiler_title">Dessin de fl√®che</b> <div class="spoiler_text">  Image et code de fl√®che (les coordonn√©es et les bits dans le tableau sont invers√©s en fonction de la position inf√©rieure du connecteur pour l'affichage WEG010016AL, voir ci-dessus): <br><br><img src="http://revich.lib.ru/AVR/TableCodArray.png" alt="image"><br><pre> <code class="hljs markdown">const byte DataATR[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">8</span></span>]={{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x01,0x02,0x04,0x28,0x30,0x78,0x60,0x80}};</code> </pre> <br>  Fonctions de sortie des fl√®ches multidirectionnelles: <br><pre> <code class="hljs powershell">. . . . . void drawSW (byte x) //   (  ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]);} } void drawNW (byte x) //   (  ) {//   : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); byte b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b);} } void drawNE (byte x) //   (  ) {//  ,    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); byte b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]); lcd.write(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]); lcd.write(b);} } void drawSE (byte x) //   (  ) {//   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]);} } . . . . .</code> </pre> </div></div><br>  La photo ci-dessous montre le r√©sultat d'un programme vierge pour afficher le capteur de vitesse et de direction du vent.  Comme vous pouvez le voir, il s'est av√©r√© tr√®s simple d'impl√©menter des polices de diff√©rentes tailles sur une seule ligne avec des images: <br><br><img src="http://revich.lib.ru/AVR/WEG10016_wind.jpg" width="600" alt="image"><br><br>  En conclusion, j'ajouterai que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici</a> une biblioth√®que tr√®s int√©ressante pour travailler avec WS0010 en modes graphiques et textuels en utilisant SPI.  Dans le texte, il copie principalement Liquid Crystal (et √† quoi d'autre pouvez-vous penser?), Et dans le graphique, il a pour fonctions de dessiner des primitives graphiques, des polices int√©gr√©es (√©paisses, comme la mienne et le 5x7 habituel) et bien plus encore. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr402517/">https://habr.com/ru/post/fr402517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr402505/index.html">La r√©alit√© augment√©e a commenc√© √† √™tre massivement appliqu√©e dans l'industrie am√©ricaine.</a></li>
<li><a href="../fr402507/index.html">La gestion du patrimoine personnel en tant que droit humain fondamental</a></li>
<li><a href="../fr402509/index.html">La navigation par satellite d√©sactive le routage</a></li>
<li><a href="../fr402511/index.html">Comment est n√©e la vie</a></li>
<li><a href="../fr402515/index.html">Braun Oral-B Genius 9000: quand la brosse donne des conseils via un smartphone</a></li>
<li><a href="../fr402521/index.html">Le WiFi infrarouge est 17 fois plus rapide que la normale, mais unidirectionnel</a></li>
<li><a href="../fr402523/index.html">"Monde mince." Chapitre 9</a></li>
<li><a href="../fr402525/index.html">Pourquoi OneDrive a ralenti sous Linux</a></li>
<li><a href="../fr402527/index.html">Quatre √† trente-deux</a></li>
<li><a href="../fr402529/index.html">Pourquoi est-ce mieux avec un t-shirt cardio que sans lui: quelques mots sur les v√™tements chics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>