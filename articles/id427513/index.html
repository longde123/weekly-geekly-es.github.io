<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏼 👨🏿‍💻 ⛏️ Bagaimana cara menganalisis thread dump 📪 🚓 🖌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada beberapa topik tentang internal JVM di program kursus Java Developer . Kami memahami mekanisme kerja pengumpulan, bytecode, pengumpul sampah, dll....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara menganalisis thread dump</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/427513/">  <i>Ada beberapa topik tentang internal JVM di program kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Developer</a> .</i>  <i>Kami memahami mekanisme kerja pengumpulan, bytecode, pengumpul sampah, dll.</i>  <i>Hari ini kami menawarkan perhatian Anda pada terjemahan artikel yang agak menarik tentang thread dump.</i>  <i>Apa itu, bagaimana cara mendapatkannya dan bagaimana menggunakannya.</i> <br><br>  Ingin mempelajari cara menganalisis dump thread?  Pergilah ke bawah kucing untuk mempelajari lebih lanjut tentang cara mendapatkan thread dump di Jawa dan apa yang harus dilakukan nanti. <br><a name="habracut"></a><br>  Sebagian besar aplikasi Java modern multithreaded.  Multithreading secara signifikan dapat memperluas fungsionalitas aplikasi, pada saat yang sama memperkenalkan kompleksitas yang signifikan. <br><br>  Dalam aplikasi single-threaded, semua sumber daya (memori bersama, operasi input / output, dll.) Dapat digunakan tanpa sinkronisasi, karena  pada waktu tertentu, hanya satu utas yang menggunakan sumber daya. <br><br>  Dalam kasus aplikasi multi-utas, perlu untuk menemukan kompromi antara menyulitkan program dan kemungkinan peningkatan kinerja, ketika beberapa utas dapat menggunakan semua prosesor inti (CPU) yang tersedia (seringkali lebih dari satu).  Jika semuanya dilakukan dengan benar, kemudian menggunakan multithreading (diformalkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hukum Amdahl</a> ), Anda dapat mencapai peningkatan kinerja aplikasi yang signifikan.  Namun, kita harus ingat untuk memberikan akses simultan dari beberapa aliran ke sumber daya bersama.  Dalam kebanyakan kasus, kerangka kerja seperti Spring merangkum kerja dengan utas dan menyembunyikan banyak detail teknis dari pengguna.  Namun, dalam hal penggunaan kerangka kerja modern yang kompleks, sesuatu mungkin salah, dan kami, sebagai pengguna, akan menghadapi kesulitan untuk menyelesaikan bug multithreading. <br><br>  Untungnya, Java dilengkapi dengan mekanisme khusus untuk memperoleh informasi tentang keadaan saat ini dari semua utas pada waktu tertentu - ini adalah penumpukan ulir (semacam snapshot).  Pada artikel ini, kita akan belajar cara mendapatkan dump thread untuk aplikasi berukuran realistis dan bagaimana menganalisis dump ini. <br><br>  Diasumsikan bahwa pembaca memiliki informasi dasar tentang pemrograman multithread dan mengetahui masalah sinkronisasi utas dan penggunaan sumber daya bersama.  Meskipun demikian, tidak akan berlebihan untuk menyegarkan beberapa istilah dan konsep dasar. <br><br><h4>  Terminologi dasar </h4><br>  Pada pandangan pertama, dump thread Java mungkin tampak seperti "huruf Cina," konsep berikut adalah kunci untuk memahaminya.  Secara umum, mari kita ulangi istilah dasar multithreading, yang akan kita gunakan untuk menganalisis dump. <br><br><ul><li> <strong>Utas</strong> atau utas adalah unit multithreading diskrit yang dikelola oleh Java Virtual Machine (JVM).  Utas JVM sesuai dengan utas di sistem operasi (OS) - utas asli, yang menerapkan mekanisme eksekusi kode. <br><br>  Setiap utas memiliki pengidentifikasi dan nama yang unik.  Streaming dapat menjadi "setan" dan "bukan setan." <br><br>  Program berakhir ketika semua utas non-daemon berakhir atau metode <i>Runtime.exit dipanggil</i> .  Bekerja "setan" tidak memengaruhi penyelesaian program.  Yaitu  JVM sedang menunggu semua "non-setan" diselesaikan dan dimatikan, mereka tidak memperhatikan "non-setan". <br><br>  Untuk informasi lebih lanjut, lihat dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas Thread</a> . <br>  Aliran mungkin berada di salah satu dari kondisi berikut: <br><br><ul><li>  <strong>Alive thread</strong> atau "live" - ​​utas yang berfungsi (keadaan normal). </li><li>  <strong>Thread yang diblokir</strong> atau "diblokir" - utas yang mencoba masuk ke bagian yang disinkronkan (disinkronkan), tetapi utas lain sudah berhasil memasuki blok ini terlebih dahulu, dan semua utas berikut yang mencoba memasuki blok yang sama diblokir. </li><li>  <strong>Thread menunggu</strong> atau "menunggu" - utas yang disebut metode <i>tunggu</i> (mungkin dengan batas waktu) dan sekarang sedang menunggu metode lain untuk mengeksekusi <i>notify</i> atau <i>nonifyAll</i> pada objek yang sama. <br><br>  Harap dicatat bahwa utas tidak dianggap sebagai "menunggu" jika disebut menunggu dengan batas waktu dan batas waktu ini telah kedaluwarsa. </li><li>  <strong>Thread tidur</strong> atau "tidur" - utas yang saat ini tidak berjalan, karena  melakukan metode Thread.sleep (menunjukkan durasi "tidur"). </li></ul></li><li>  <strong>Monitor</strong> adalah mekanisme yang digunakan oleh JVM untuk menyediakan akses multi-utas ke satu objek.  Mekanisme ini mulai menggunakan <i>kata kunci tersinkronisasi</i> khusus. <br><br>  Setiap objek di Jawa memiliki monitor yang dapat disinkronkan utasnya, mis.  atur kunci, yang menjamin bahwa tidak ada utas lain yang akan mendapatkan akses ke objek ini hingga kunci dilepaskan, mis.  utas - pemilik kunci tidak akan keluar dari blok yang <i>disinkronkan</i> . <br><br>  Lihat bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sinkronisasi (17.1) dari Spesifikasi Java Langauge (JLS) untuk informasi lebih lanjut</a> . <br></li><li>  <strong>Jalan buntu</strong> adalah situasi di mana utas, katakanlah A, memblokir sumber daya, ia membutuhkan sumber daya lain yang diblokir oleh utas lain, misalnya B. Aliran B tidak melepaskan sumber daya ini, karena  Untuk menyelesaikan operasi tertentu, ia membutuhkan sumber daya yang diblokir oleh utas A. Ternyata utas A sedang menunggu sumber daya dibuka oleh utas B, yang sedang menunggu sumber lain dibuka dengan utas A. Dan, dengan demikian, utas sedang menunggu satu sama lain.  Akibatnya, seluruh program hang dan menunggu utas untuk entah bagaimana membuka dan terus bekerja.  Mungkin ada banyak utas di jalan buntu.  Masalah ini dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Problem of Philosophers Makan</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a> <br><br><img src="https://habrastorage.org/webt/8t/ll/jb/8tlljb_n-e80_dk_0uayobgil_s.png"><br></li><li>  <strong>Livelock</strong> adalah situasi di mana ulir A memaksa ulir B untuk melakukan beberapa tindakan, yang pada gilirannya menyebabkan ulir A melakukan tindakan awal, yang sekali lagi menyebabkan aksi ulir B. Ketergantungan siklik diperoleh.  Ini bisa dibayangkan sebagai anjing yang mengejar ekornya.  Demikian pula untuk <i>Deadlock</i> , dalam situasi Livelock, program tidak membuat kemajuan, mis.  tidak melakukan tindakan yang bermanfaat, namun, dalam situasi ini, utas tidak diblokir. <br></li></ul><br>  Terminologi yang disajikan tidak lengkap untuk menggambarkan dunia multithreading, tetapi ini cukup untuk mulai menganalisis dump benang. <br><br>  Informasi lebih rinci dapat ditemukan di sumber-sumber ini: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 17 dari JLS</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Concurrency dalam Praktek</a> <br><br>  Dengan menggunakan konsep sederhana tentang aliran di Jawa, kita dapat membuat aplikasi pengujian.  Untuk aplikasi ini kami akan mengkompilasi dump thread.  Kami akan menganalisis dump dan ekstrak informasi yang berguna tentang arus aplikasi saat ini. <br><br><h4>  Membuat program sampel </h4><br>  Sebelum membuat thread dump, kita perlu mengembangkan aplikasi Java.  Tradisional "halo, dunia!"  terlalu sederhana untuk tujuan kita, dan dump aplikasi ukuran menengah mungkin terlalu rumit untuk ditunjukkan.  Berdasarkan ini, kami akan membuat aplikasi yang cukup sederhana di mana dua utas dibuat.  Dan utas kebuntuan: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceB, resourceA)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Program ini menciptakan dua sumber: resourceA dan resourceB, dan memulai dua utas: utasLockingResourceAFirst dan utasLockingResourceBFirst, yang memblokir sumber daya masing-masing. <br><br>  Penyebab kebuntuan adalah "lintas" pemblokiran sumber daya oleh utas. <br><br>  Alasan terjadinya kebuntuan adalah upaya untuk "saling" merebut sumber daya, mis.  threadLockingResourceAF thread pertama menangkap resourceA sumber daya, threadLockingResourceB thread pertama menangkap resourceB sumber daya.  Setelah itu, threadLockingResourceAFirst, tanpa melepaskan sumber dayanya, mencoba meraih resourceB, dan threadLockingResourceBFirst, tanpa melepaskan sumber dayanya, mencoba meraih resourceA.  Akibatnya, utas diblokir.  Penundaan 1s telah ditambahkan untuk menjamin pemblokiran.  Utas sedang menunggu rilis sumber daya yang diperlukan, tetapi ini tidak akan pernah terjadi. <br><br>  Output dari program akan seperti ini (angka-angka setelah java.lang.Object @ akan berbeda untuk setiap peluncuran): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Thread-0</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">locked</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">resource</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Object</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">149bc794</span></span> Thread-<span class="hljs-number"><span class="hljs-number">1</span></span>: locked resource -&gt; java.lang.Object@<span class="hljs-number"><span class="hljs-number">17</span></span>c10009</code> </pre> <br>  Setelah output dari pesan-pesan ini, program akan terlihat seperti sedang berjalan (proses menjalankan program ini tidak selesai), sementara program tidak melakukan pekerjaan apa pun.  Beginilah jalan buntu dalam praktik.  Untuk menyelesaikan masalah, kita perlu membuat dump tapak dan menganalisis status utas secara manual. <br><br><h4>  Pembuatan Dump Thread </h4><br>  Dalam praktiknya, program Java mungkin macet saat membuat dump thread.  Namun, dalam beberapa kasus (misalnya, dalam kasus deadlock), program tidak berakhir dan thread dump tidak tercipta, hanya hang.  Untuk membuat dump dari program yang digantung seperti itu, pertama-tama, Anda perlu mengetahui pengenal proses program, yaitu  ID Proses (PID).  Untuk melakukan ini, Anda dapat menggunakan utilitas Status Proses JVM (JPS), yang, dimulai dengan versi 7, merupakan bagian dari Java Development Kit (JDK).  Untuk menemukan proses PID dari program kami yang macet, kami cukup menjalankan jps di terminal (Windows atau Linux): <br><br><pre> <code class="hljs ruby">$ jps <span class="hljs-number"><span class="hljs-number">11568</span></span> DeadlockProgram <span class="hljs-number"><span class="hljs-number">15584</span></span> Jps <span class="hljs-number"><span class="hljs-number">15636</span></span></code> </pre> <br>  Kolom pertama adalah pengenal mesin virtual lokal (Local VM ID, mis. Lvmid) untuk proses Java yang sedang berjalan.  Dalam konteks JVM lokal, lvmid menunjuk ke PID dari proses Java. <br><br>  Perlu dicatat bahwa nilai ini cenderung berbeda dari nilai di atas.  Kolom kedua adalah nama aplikasi, yang dapat menunjuk ke nama kelas utama, file jar, atau sama dengan "Tidak Dikenal".  Itu semua tergantung pada bagaimana aplikasi itu diluncurkan. <br><br>  Dalam kasus kami, nama aplikasi DeadlockProgram adalah nama kelas utama yang diluncurkan ketika program dimulai.  Dalam contoh PID program 11568 di atas, informasi ini cukup untuk menghasilkan thread dump.  Untuk menghasilkan dump, kita akan menggunakan utilitas <strong>jstack</strong> , yang merupakan bagian dari JDK, mulai dari versi 7. Untuk mendapatkan dump, kita akan <strong>meneruskan</strong> PID program kita ke <strong>jstack</strong> dan menentukan flag -l (membuat daftar panjang).  Output dari utilitas akan dialihkan ke file teks, mis.  thread_dump.txt: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">jstack</span></span> -l <span class="hljs-number"><span class="hljs-number">11568</span></span> &gt; thread_dump.txt</code> </pre> <br>  File thread_dump.txt yang dihasilkan berisi dump thread dari program kami yang digantung dan berisi informasi penting untuk mendiagnosis penyebab kebuntuan. <br><br>  Jika JDK digunakan hingga versi 7, maka untuk menghasilkan dump, Anda dapat menggunakan utilitas Linux - <strong>kill</strong> dengan flag -3.  Memanggil kill -3 akan mengirimkan program sinyal SIGQUIT. <br><br>  Dalam kasus kami, panggilan akan seperti ini: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">kill</span></span> <span class="hljs-number"><span class="hljs-number">-3</span></span> <span class="hljs-number"><span class="hljs-number">11568</span></span></code> </pre> <br><h4>  Analisis Dump Thread Sederhana </h4><br>  Membuka file thread_dump.txt, kita akan melihat sesuatu seperti berikut: <br><br><pre> 2018-06-19 16:44:44
 Utang penuh Java HotSpot (TM) 64-Bit Server VM (10.0.1 + 10 mode campuran):
 Info SMR utas kelas:
 _java_thread_list = 0x00000250e5488a00, panjang = 13, elemen = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }
 "Handler Referensi" # 2 daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 menunggu dalam kondisi [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     di java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     di java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     di java.lang.ref.Reference.access $ 000 (java.base@10.0.1/Reference.java: 44)
     di java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "Finalizer" # 3 daemon prio = 8 os_prio = 1 tid = 0x00000250e4982800 nid = 0x2a54 di Object.wait () [0x000000b82aaff000]
    java.lang.Thread.State: WAITING (pada monitor objek)
     di java.lang.Object.wait (java.base@10.0.1/Native Method)
     - menunggu &lt;0x0000000089509410&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     di java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - menunggu untuk mengunci kembali wait () &lt;0x0000000089509410&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     di java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 172)
     di java.lang.ref.Finalizer $ FinalizerThread.run (java.base@10.0.1/Finalizer.java: 216)
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "Signal Dispatcher" # 4 daemon prio = 9 os_prio = 2 tid = 0x00000250e52f2800 nid = 0x2184 runnable [0x000000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "Lampirkan Pendengar" # 5 daemon prio = 5 os_prio = 2 tid = 0x00000250e4992800 nid = 0x1624 menunggu dalam kondisi [0x00000000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "C2 CompilerThread0" # 6 daemon prio = 9 os_prio = 2 tid = 0x00000250e4995800 nid = 0x4198 menunggu dalam kondisi [0x000000000000000000]
    java.lang.Thread.State: RUNNABLE
    Tidak ada tugas kompilasi
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "C2 CompilerThread1" # 7 daemon prio = 9 os_prio = 2 tid = 0x00000250e49a5800 nid = 0x3b98 menunggu dalam kondisi [0x000000000000000000]
    java.lang.Thread.State: RUNNABLE
    Tidak ada tugas kompilasi
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "C1 CompilerThread2" # 8 daemon prio = 9 os_prio = 2 tid = 0x00000250e49ae800 nid = 0x1a84 menunggu dalam kondisi [0x000000000000000000]
    java.lang.Thread.State: RUNNABLE
    Tidak ada tugas kompilasi
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "Sweeper thread" # 9 daemon prio = 9 os_prio = 2 tid = 0x00000250e5324000 nid = 0x5f0 runnable [0x000000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "Service Thread" # 10 daemon prio = 9 os_prio = 0 tid = 0x00000250e54cd800 nid = 0x169c runnable [0x000000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "Common-Cleaner" # 11 daemon prio = 8 os_prio = 1 tid = 0x00000250e54cf000 nid = 0x1610 di Object.wait () [0x000000b82b2fe000]
    java.lang.Thread.State: TIMED_WAITING (pada monitor objek)
     di java.lang.Object.wait (java.base@10.0.1/Native Method)
     - menunggu &lt;0x000000008943e600&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     di java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - menunggu untuk mengunci kembali wait () &lt;0x00000000008943e600&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     di jdk.internal.ref.CleanerImpl.run (java.base@10.0.1/CleanerImpl.java: 148)
     di java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
     di jdk.internal.misc.InnocuousThread.run (java.base@10.0.1/InnocuousThread.java: 134)
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec menunggu entri monitor [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (pada objek monitor)
     di DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - menunggu untuk mengunci &lt;0x00000000894465b0&gt; (a java.lang.Object)
     - terkunci &lt;0x00000000894465a0&gt; (a java.lang.Object)
     di java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "Thread-1" # 13 prio = 5 os_prio = 0 tid = 0x00000250e54d2000 nid = 0x415c menunggu entri monitor [0x000000b82b5ff000]
    java.lang.Thread.State: BLOCKED (pada objek monitor)
     di DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - menunggu untuk mengunci &lt;0x00000000894465a0&gt; (a java.lang.Object)
     - terkunci &lt;0x00000000894465b0&gt; (sebuah java.lang.Object)
     di java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "DestroyJavaVM" # 14 prio = 5 os_prio = 0 tid = 0x00000250e54d0800 nid = 0x2b8c menunggu dalam kondisi [0x000000000000000000]
    java.lang.Thread.State: RUNNABLE
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
 "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 runnable  
 "GC Thread # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c runnable  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 runnable  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 runnable  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 runnable  
 "G1 Main Marker" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 runnable  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 runnable  
 "G1 Saring # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c runnable  
 "G1 Saring # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 runnable  
 "G1 Saring # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 dapat dijalankan  
 "G1 Saring # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 dapat dijalankan  
 "G1 Young RemSet Sampling" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 runnable  
 "Utas Tugas Berkala VM" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 menunggu dengan syarat  
 Referensi global JNI: 2
 Menemukan satu kebuntuan tingkat-Jawa:
 ===============================
 "Utas-0":
   menunggu untuk mengunci monitor 0x00000250e4982480 (objek 0x00000000894465b0, sebuah java.lang.Object),
   yang dipegang oleh "Thread-1"
 "Utas-1":
   menunggu untuk mengunci monitor 0x00000250e4982380 (objek 0x00000000894465a0, a java.lang.Object),
   yang dipegang oleh "Thread-0"
 Informasi tumpukan Java untuk utas yang tercantum di atas:
 =================================================== =
 "Utas-0":
     di DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - menunggu untuk mengunci &lt;0x00000000894465b0&gt; (a java.lang.Object)
     - terkunci &lt;0x00000000894465a0&gt; (a java.lang.Object)
     di java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Utas-1":
     di DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - menunggu untuk mengunci &lt;0x00000000894465a0&gt; (a java.lang.Object)
     - terkunci &lt;0x00000000894465b0&gt; (sebuah java.lang.Object)
     di java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 Menemukan 1 kebuntuan.
</pre><br><h3>  Informasi pengantar </h3><br>  Meskipun pada pandangan pertama file ini mungkin tampak terlalu rumit dan membingungkan, pada kenyataannya itu cukup sederhana jika Anda membongkar bagian demi bagian. <br><br>  Baris pertama menunjukkan waktu ketika dump dibentuk, informasi diagnostik kedua tentang JVM, tempat dump diterima: <br><br><pre> <code class="hljs css">2018<span class="hljs-selector-tag"><span class="hljs-selector-tag">-06-19</span></span> 16<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Full</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dump</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Java</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">HotSpot</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TM</span></span>) 64<span class="hljs-selector-tag"><span class="hljs-selector-tag">-Bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Server</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VM</span></span> (10<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span>+10 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mixed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mode</span></span>):</code> </pre> <br>  Tidak ada informasi aliran di bagian ini.  Di sini konteks umum sistem tempat pengumpulan dikumpulkan diatur. <br><br><h4>  Informasi Aliran Umum </h4><br>  Bagian berikut memberikan informasi tentang utas yang sedang berjalan di sistem pada saat pengumpulan sampah: <br><br><pre> Info SMR utas kelas:
 _java_thread_list = 0x00000250e5488a00, panjang = 13, elemen = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }
</pre><br>  Bagian berikut mencantumkan: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Informasi Safe Memory Reclamation (SMR)</a> <br><br>  Ini berisi informasi tentang utas di luar JVM, mis.  ini bukan utas mesin virtual atau utas pengumpulan sampah.  Jika Anda melihat alamat utas ini, Anda akan melihat bahwa mereka sesuai dengan nilai <i>tid</i> - alamat "alami, besi" (asli) dalam sistem operasi, dan bukan Thread ID. <br><br>  Elips digunakan untuk menyembunyikan informasi yang berlebihan: <br><br><pre> "Handler Referensi" # 2 ... tid = 0x00000250e4979000 ...
 "Penyelesaikan" # 3 ... tid = 0x00000250e4982800 ...
 "Pengirim Sinyal" # 4 ... tid = 0x00000250e52f2800 ...
 "Lampirkan Pendengar" # 5 ... tid = 0x00000250e4992800 ...
 "C2 CompilerThread0" # 6 ... tid = 0x00000250e4995800 ...
 "C2 CompilerThread1" # 7 ... tid = 0x00000250e49a5800 ...
 "C1 CompilerThread2" # 8 ... tid = 0x00000250e49ae800 ...
 "Utas penyapu" # 9 ... tid = 0x00000250e5324000 ...
 "Layanan Thread" # 10 ... tid = 0x00000250e54cd800 ...
 "Pembersih Umum" # 11 ... tid = 0x00000250e54cf000 ...
 "Thread-0" # 12 ... tid = 0x00000250e54d1800 ...
 "Thread-1" # 13 ... tid = 0x00000250e54d2000 ...
 "DestroyJavaVM" # 14 ... tid = 0x00000250e54d0800 ...
</pre><br><h3>  Streaming </h3><br>  Tepat setelah blok SMR adalah daftar utas.  Utas pertama pada daftar kami adalah Handler Referensi: <br><br><pre> "Handler Referensi" # 2 daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 menunggu dalam kondisi [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     di java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     di java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     di java.lang.ref.Reference.access $ 000 (java.base@10.0.1/Reference.java: 44)
     di java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
</pre><br><h4>  Deskripsi singkat tentang aliran </h4><br>  Baris pertama untuk setiap utas menyediakan deskripsi umum.  Deskripsi berisi item-item berikut: <br><table><tbody><tr><th width="70">  Bagian </th><th width="100">  Contoh </th><th>  Deskripsi </th></tr><tr><td>  Nama </td><td>  "Handler Referensi" </td><td>  Nama aliran yang dapat dibaca manusia.  Nama dapat ditentukan dengan memanggil metode <i>setName</i> dari objek <i>Thread</i> .  Dan melalui panggilan ke <i>getName</i> </td></tr><tr><td>  ID </td><td>  # 2 </td><td>  ID unik yang ditetapkan untuk setiap objek dari kelas <i>Thread</i> .  ID dihasilkan untuk utas dalam sistem.  Nilai awal adalah 1. Setiap utas yang baru dibuat akan diberi ID-nya sendiri, yang sebelumnya meningkat sebesar 1. Properti utas baca-saja ini dapat diperoleh dengan menggunakan fungsi <i>getId</i> dari objek kelas <i>Thread</i> . </td></tr><tr><td>  Status daemon </td><td>  daemon </td><td>  Bendera adalah tanda bahwa utas adalah setan.  Jika itu adalah iblis, maka bendera akan ditetapkan.  Misalnya, utas <i>-0</i> bukan daemon. </td></tr><tr><td>  Prioritas </td><td>  prio = 10 </td><td>  Prioritas numerik dari aliran Java.  Perhatikan bahwa prioritas ini tidak selalu sesuai dengan prioritas utas terkait di sistem operasi.  Untuk mengatur prioritas, Anda dapat <br>  gunakan metode <i>setPriority</i> dari objek <i>Thread</i> kelas, dan untuk mendapatkannya <br>  metode <i>getPriority</i> . </td></tr><tr><td>  Prioritas Utas OS </td><td>  os_prio = 2 </td><td>  Utas prioritas dalam sistem operasi.  Prioritas ini mungkin berbeda dari yang ditetapkan untuk utas Java tertaut. </td></tr><tr><td>  Alamat </td><td>  tid = 0x00000250e4979000 </td><td>  Alamat aliran Java.  Alamat ini adalah penunjuk ke objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">asli Java Native Interface (JNI)</a> dari kelas <i>Thread</i> (objek C ++ <i>Thread</i> yang terhubung ke utas Java melalui JNI).  Nilai ini diperoleh dengan memberikan pointer ke ini <br>  (objek C ++ yang dikaitkan dengan utas Java ini) ke integer.  Lihat <br>  <a href="">baris 879 di hotspot / share / runtime / thread.cpp</a> : <br><pre> st-&gt; print ("tid =" INTPTR_FORMAT "", p2i (ini));
</pre><br>  Meskipun kunci untuk objek ini ( <i>tid</i> ) mungkin terlihat seperti ID aliran, <br>  sebenarnya, ini adalah alamat objek yang terhubung <i>JNI C ++ Thread</i> , dan ini bukan nilai itu <br>  mengembalikan metode <i>getId</i> dari <i>utas</i> Java. </td></tr><tr><td>  ID Utas OS </td><td>  nid = 0x3c28 </td><td>  Pengidentifikasi unik dari utas sistem operasi yang terikat pada utas Java. <br>  Nilai ini dikeluarkan dengan kode berikut: <br>  <a href="">baris 42 di hotspot / share / runtime / osThread.cpp</a> : <br><pre> st-&gt; print ("nid = 0x% x", thread_id ());
</pre><br></td></tr><tr><td>  Status </td><td>  menunggu dengan syarat </td><td>  Status dapat dibaca manusia dari utas saat ini. <br>  Baris ini menampilkan informasi tambahan tentang status aliran yang sederhana (lihat di bawah), yang bisa jadi <br>  terbiasa memahami apa yang akan dilakukan utas (mis. apakah utas sedang mencoba untuk mendapatkan kunci <br>  atau menunggu kondisi pembukaan kunci terpenuhi). </td></tr><tr><td>  Pointer Java Stack Terakhir Diketahui </td><td>  [0x000000b82a9ff000] </td><td>  Penunjuk tumpukan (SP) terakhir yang diketahui terkait dengan aliran ini. <br>  Nilai ini diperoleh dengan menggunakan kode C ++ asli dicampur dengan kode Java menggunakan JNI.  Nilai dikembalikan oleh fungsi <i>last_Java_sp ()</i> , <br>  <a href="">baris 2886 di hotspot / share / runtime / thread.cpp</a> : <br><pre>   st-&gt; print_cr ("[" INTPTR_FORMAT "]", 
     (intptr_t) last_Java_sp () &amp; ~ right_n_bits (12));
</pre><br>  Untuk dump thread sederhana, informasi ini hampir tidak berguna.  Namun, dalam kasus kompleks, SP mungkin <br>  digunakan untuk melacak kunci. </td></tr></tbody></table><br><h4>  Status aliran </h4><br>  Baris kedua adalah kondisi aliran saat ini.  Status streaming yang mungkin tercantum dalam enum: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Thread.State</a> : <br><br>  BARU <br>  DAPAT DIBERI <br>  DIBLOKIR <br>  MENUNGGU <br>  TIMED_WAITING <br>  TERMINASI <br><br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">dokumentasi untuk</a> lebih jelasnya. <br><br><h4>  Jejak tumpukan ulir </h4><br>  Bagian selanjutnya berisi jejak tumpukan aliran pada saat pembuangan diambil.  Jejak tumpukan ini sangat mirip dengan jejak tumpukan, yang dilemparkan oleh pengecualian tanpa tertangkap.  Dan itu berisi nama-nama kelas dan string yang dieksekusi pada saat dump terbentuk.  Dalam kasus aliran Reference Handler, kami melihat tidak ada yang menarik. <br><br>  Namun, ada sesuatu yang menarik tentang jejak thread-02 yang berbeda dari jejak standar: <br><br><pre> "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec menunggu entri monitor [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (pada objek monitor)
     di DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - menunggu untuk mengunci &lt;0x00000000894465b0&gt; (a java.lang.Object)
     - terkunci &lt;0x00000000894465a0&gt; (a java.lang.Object)
     di java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Sinkronisasi yang dapat dimiliki yang dikunci:
     - Tidak ada
</pre><br>  Dalam penelusuran, kami melihat bahwa informasi tentang kunci telah ditambahkan.  Utas ini mengharapkan kunci pada objek dengan alamat 0x00000000894465b0 (tipe objek java.lang.Object).  Selain itu, utas itu sendiri memegang kunci dengan alamat 0x00000000894465a0 (juga java.lang.Object).  Informasi ini akan berguna bagi kita nanti untuk diagnosis kebuntuan. <br><br><h4>  Primitif sinkronisasi yang diambil (Sinkronisasi yang Dapat Dimiliki) </h4><br>  Bagian terakhir berisi daftar primitif sinkronisasi yang ditangkap oleh aliran.  Ini adalah objek yang dapat digunakan untuk menyinkronkan utas, misalnya, mengunci. <br><br>  Menurut dokumentasi resmi Java, <strong>Ownable Synchronizer</strong> adalah keturunan dari <i>AbstractOwnableSynchronizer</i> (atau subkelasnya), yang dapat secara eksklusif ditangkap oleh stream untuk keperluan sinkronisasi. <br><br>  <i>ReentrantLock</i> dan <i>write-lock</i> , tetapi bukan <i>read-lock</i> dari kelas <i>ReentrantReadWriteLock</i> adalah dua contoh bagus dari "sinkronisasi yang dapat dimiliki" yang ditawarkan oleh platform. <br><br>  Untuk informasi lebih lanjut tentang subjek ini, Anda dapat merujuk ini <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">pos</a> . <br><br><h4>  Utas JVM </h4><br>  Bagian dump berikutnya berisi informasi tentang utas teknis JVM yang bukan bagian dari aplikasi dan dikaitkan dengan utas sistem operasi.  Karena  aliran ini bekerja di luar aplikasi, mereka tidak memiliki pengidentifikasi aliran.  Paling sering, ini adalah pengumpul sampah dan utas JVM teknis lainnya: <br><br><pre> "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 runnable  
 "GC Thread # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c runnable  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 runnable  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 runnable  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 runnable  
 "G1 Main Marker" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 runnable  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 runnable  
 "G1 Saring # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c runnable  
 "G1 Saring # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 runnable  
 "G1 Saring # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 dapat dijalankan  
 "G1 Saring # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 dapat dijalankan  
 "G1 Young RemSet Sampling" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 runnable  
 "Utas Tugas Berkala VM" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 menunggu dengan syarat
</pre><br><h4>  Tautan Global JNI </h4><br>  Bagian ini menunjukkan jumlah referensi global yang digunakan oleh JVM melalui JNI.  Tautan ini tidak dilayani oleh pengumpul sampah dan dapat menyebabkan kebocoran memori dalam keadaan tertentu. <br><br><pre> Referensi global JNI: 2
</pre><br>  Dalam kebanyakan kasus sederhana, informasi ini tidak digunakan.  Namun, pentingnya referensi global harus dipahami.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">posting</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">untuk</a> lebih jelasnya. <br><br><h4>  Utas kebuntuan </h4><br>  Bagian terakhir berisi informasi tentang kebuntuan yang ditemukan. <br>  Jika ini tidak ditemukan, maka bagian itu akan kosong.  Karena  Kami secara khusus mengembangkan aplikasi dengan kunci, dalam kasus kami bagian ini.  Kunci terdeteksi selama dumping dan disajikan dengan pesan berikut: <br><br><pre> Menemukan satu kebuntuan tingkat-Jawa:
 ===============================
 "Utas-0":
   menunggu untuk mengunci monitor 0x00000250e4982480 (objek 0x00000000894465b0, sebuah java.lang.Object),
   yang dipegang oleh "Thread-1"
 "Utas-1":
   menunggu untuk mengunci monitor 0x00000250e4982380 (objek 0x00000000894465a0, a java.lang.Object),
   yang dipegang oleh "Thread-0"
 Informasi tumpukan Java untuk utas yang tercantum di atas:
 =================================================== =
 "Utas-0":
     di DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - menunggu untuk mengunci &lt;0x00000000894465b0&gt; (a java.lang.Object)
     - terkunci &lt;0x00000000894465a0&gt; (a java.lang.Object)
     di java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Utas-1":
     di DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - menunggu untuk mengunci &lt;0x00000000894465a0&gt; (a java.lang.Object)
     - terkunci &lt;0x00000000894465b0&gt; (sebuah java.lang.Object)
     di java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 Menemukan 1 kebuntuan.
</pre><br>  Subbagian pertama menjelaskan skenario kebuntuan: <br><br>  Thread-0 berharap dapat menangkap monitor (ini adalah akses ke blok <i>disinkronkan (secondResource)</i> dalam aplikasi kami), pada saat yang sama thread ini memegang monitor yang mencoba menangkap Thread-1 (ini mengakses fragmen kode yang sama: <i>disinkronkan (secondResource) )</i> dalam aplikasi kita). <br><br>  Kunci bundar ini disebut <strong>deadlock</strong> .  Pada gambar di bawah ini <br>  situasi ini disajikan dalam bentuk grafik: <br><br><img src="https://habrastorage.org/webt/11/yd/kr/11ydkrm0xkbw8aqxb8t71kypskg.png"><br><br>  Di subbagian kedua, tumpukan jejak diberikan untuk kedua utas yang diblokir. <br><br>  Jejak tumpukan ini memungkinkan kami melacak operasi setiap utas hingga terjadi penguncian. <br>  Dalam kasus kami, jika kami melihat garis: <br><br>  <i>di DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)</i> , maka kita akan melihat bagian masalah dari kode: <br><br><pre> printLockedResource (sumber daya kedua);
</pre><br>  Baris ini adalah baris pertama dari blok yang disinkronkan, yang merupakan alasan untuk kunci, dan memberitahu kita bahwa sinkronisasi pada sumber daya kedua adalah alasan untuk kunci bersama.  Untuk memperbaiki situasi, kita harus memastikan bahwa kedua utas memiliki urutan sinkronisasi yang sama pada sumber dayaA dan sumber dayaB.  Jika kami melakukan ini, kami akan datang ke aplikasi berikut: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Aplikasi ini akan berakhir tanpa interlocking, dan sebagai hasilnya kita akan mendapatkan output berikut (perhatikan bahwa alamat kelas Object telah berubah): <br><br><pre> Thread-0: sumber daya terkunci -&gt; java.lang.Object@1ad895d1
 Thread-0: sumber daya terkunci -&gt; java.lang.Object@6e41d7dd
 Thread-1: resource terkunci -&gt; java.lang.Object@1ad895d1
 Thread-1: resource terkunci -&gt; java.lang.Object@6e41d7dd
</pre><br>  ,   ,   thread dump,           .        (     deadlock-).      ,   . <br><br><h3>    Thread Dump- </h3><br>         . <br><br>   JVM       .         (     ,   ). <br><br>         . <br><br>       - — Thread Dump Analyzers (TDAs).    Java thread dump-     - ,     .  ,           . ,        . <br><br>        TDA: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">fastThread</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Spotify TDA</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">IBM Thread and Monitor Dump Analyze for Java</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">irockel TDA</a> </li></ul><br>        .               . <br><br><h4>  Kesimpulan </h4><br> Thread dump- —      Java-,       .     ,           . <br><br>        deadlock,    .         .     ,           — . <br><br>   ,   Java-     thread dump-.     ,             . <br><br> , thread dump —   « »   ,        ,      Java-. <br><br> <i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> Java</a>     .       ,        deadlock- .</i> <br><br> <i>      ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427513/">https://habr.com/ru/post/id427513/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427499/index.html">Apa yang mereka tulis tentang dukungan teknis streamer video?</a></li>
<li><a href="../id427501/index.html">Seymour Papert: Hard Fun</a></li>
<li><a href="../id427505/index.html">Anggapan pikiran</a></li>
<li><a href="../id427507/index.html">Seymour Papert: Penemuan Lezat "Tidak Ada"</a></li>
<li><a href="../id427509/index.html">Server Web: Pengalaman dan Praktek Southbridge</a></li>
<li><a href="../id427517/index.html">Ikhtisar laporan Joker 2018 paling menarik: versi EastBanc Technologies</a></li>
<li><a href="../id427519/index.html">@Kubernetes Meetup di Mail.Ru Group: 29 Oktober dan selalu</a></li>
<li><a href="../id427521/index.html">Hadiah Terobosan 2019. Pemenang Milner, Brin, dan Zuckerberg Science Award diumumkan.</a></li>
<li><a href="../id427523/index.html">Keberhasilan lindung nilai</a></li>
<li><a href="../id427525/index.html">Intel Core 9th Gen dalam jumlah dan tolok ukur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>