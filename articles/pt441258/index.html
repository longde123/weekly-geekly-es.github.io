<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏿 🐔 🔤 Rastreamento dinâmico completo no Linux usando eBPF e bpftrace 🥂 👨🏾‍🚀 🚚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“No modo de rastreamento, o programador vê a sequência de execução do comando e os valores das variáveis ​​nesta etapa da execução do programa, o que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rastreamento dinâmico completo no Linux usando eBPF e bpftrace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/441258/"><img src="https://habrastorage.org/webt/gd/t6/e_/gdt6e_wwaanx1prvqkhdhj5ptss.jpeg"><br><br>  “No modo de rastreamento, o programador vê a sequência de execução do comando e os valores das variáveis ​​nesta etapa da execução do programa, o que facilita a detecção de erros”, conta a Wikipedia.  Como fãs do Linux, regularmente nos deparamos com a questão de quais ferramentas específicas são melhores para implementá-lo.  E queremos compartilhar a tradução de um artigo do programador Hongley Lai, que recomenda o bpftrace.  Olhando para o futuro, direi que o artigo termina de forma sucinta: "bpftrace é o futuro".  Então, por que ele impressionou tanto o colega de Lai?  Uma resposta detalhada sob o corte. <br><a name="habracut"></a><br>  Existem duas ferramentas principais de rastreamento no Linux: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">strace</a> permite ver quais chamadas do sistema estão sendo feitas; <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O ltrace</a> permite ver quais bibliotecas dinâmicas estão sendo chamadas. <br><br>  Apesar de sua utilidade, essas ferramentas são limitadas.  E se você precisar descobrir o que acontece em uma chamada de sistema ou biblioteca?  E se você precisar não apenas compilar uma lista de chamadas, mas também, por exemplo, coletar estatísticas sobre determinado comportamento?  E se você precisar rastrear vários processos e comparar dados de várias fontes? <br><br>  Em 2019, finalmente obtivemos uma resposta decente para essas perguntas no Linux: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bpftrace com</a> base na tecnologia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eBPF</a> .  O Bpftrace permite escrever pequenos programas que são executados toda vez que um evento ocorre. <br><br>  Neste artigo, descreverei como instalar o bpftrace e ensinar sua aplicação básica.  Também revisarei como é o ecossistema de rastreamento (por exemplo, “o que é eBPF?”) E como ele evoluiu para o que temos hoje. <br><br><img src="https://habrastorage.org/webt/v9/vp/di/v9vpdivpv8a6roolw_kiz7wtnfs.png"><br><br><h3>  O que é um traço? </h3><br>  Como mencionado anteriormente, o bpftrace permite escrever pequenos programas que são executados toda vez que um evento ocorre. <br><br>  O que é um evento?  Pode ser uma chamada do sistema, uma chamada de função ou mesmo algo acontecendo dentro de tais solicitações.  Também pode ser um temporizador ou um evento de hardware, por exemplo, “50 ms passaram desde o último dos mesmos eventos”, “ocorreu falha na página”, “ocorreu mudança de contexto” ou “ocorreu o processador de perda de caso”. <br><br>  O que pode ser feito em resposta a um evento?  Você pode prometer algo, coletar estatísticas e executar comandos arbitrários do shell.  Você terá acesso a várias informações contextuais, como o PID atual, rastreamento de pilha, hora, argumentos de chamada, valores de retorno, etc. <br><br>  Quando usar?  Em muitos  Você pode descobrir por que o aplicativo é lento compilando uma lista das chamadas mais lentas.  Você pode determinar se há vazamentos de memória no aplicativo e, em caso afirmativo, onde.  Eu o uso para entender por que Ruby usa tanta memória. <br><br>  A grande vantagem do bpftrace é que você não precisa recompilar o aplicativo.  Não há necessidade de escrever manualmente chamadas de impressão ou qualquer outro código de depuração no código-fonte do aplicativo em estudo.  Não é necessário reiniciar aplicativos.  E tudo isso com sobrecarga muito baixa.  Isso torna o bpftrace especialmente útil para depurar sistemas diretamente no produto ou em outra situação em que há dificuldades com a recompilação. <br><br><h3>  DTrace: pai do rastreamento </h3><br>  Por um longo tempo, a melhor ferramenta de rastreamento foi o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DTrace</a> , uma estrutura completa de rastreamento dinâmico originalmente desenvolvida pela Sun Microsystems (os fabricantes de Java).  Como o bpftrace, o DTrace permite escrever pequenos programas que são executados em resposta a eventos.  De fato, muitos dos elementos-chave do ecossistema são amplamente desenvolvidos por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Brendan Gregg</a> , um renomado especialista em DTrace que atualmente trabalha na Netflix.  O que explica as semelhanças entre o DTrace e o bpftrace. <br><br><img src="https://habrastorage.org/webt/2p/wc/4w/2pwc4wawnfzibvlwt7ia0xibodc.jpeg"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Introdução ao Solaris DTrace (2009)</a> por S. Tripathi, Sun Microsystems</i> <br><br>  Em algum momento, a Sun abriu a fonte do DTrace.  Hoje, o DTrace está disponível no Solaris, FreeBSD e macOS (embora a versão do macOS seja geralmente inoperante porque o System Integrity Protection, SIP, quebrou muitos dos princípios nos quais o DTrace é executado). <br><br>  Sim, você percebeu corretamente ... O Linux não está nesta lista.  Este não é um problema de engenharia, é um problema de licenciamento.  O DTrace foi aberto sob o CDDL em vez da GPL.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A porta Linux DTrace</a> está disponível desde 2011, mas nunca foi suportada pelos principais desenvolvedores de Linux.  No início de 2018, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Oracle reabriu o DTrace sob a GPL</a> , mas já era tarde demais. <br><br><h3>  Ecossistema de rastreamento do Linux </h3><br>  Sem dúvida, o rastreamento é muito útil, e a comunidade Linux procurou desenvolver suas próprias soluções para este tópico.  Porém, diferentemente do Solaris, o Linux não é regulamentado por um fornecedor específico e, portanto, não houve esforço deliberado para desenvolver uma substituição totalmente funcional para o DTrace.  O ecossistema de rastreamento do Linux evoluiu lenta e naturalmente, resolvendo problemas à medida que eles surgem.  E apenas recentemente esse ecossistema cresceu o suficiente para competir seriamente com o DTrace. <br><br>  Devido ao crescimento natural, esse ecossistema pode parecer um pouco caótico, consistindo em muitos componentes diferentes.  Felizmente, Julia Evans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escreveu uma revisão desse ecossistema</a> (atenção, data de publicação - 2017, antes do advento do bpftrace). <br><br><img src="https://habrastorage.org/webt/io/km/zq/iokmzq2fmqyechm1boqeks-w2za.png"><br>  <i>Ecossistema de rastreamento de Linux descrito por Julia Evans</i> <br><br>  Nem todos os elementos são igualmente importantes.  Deixe-me resumir brevemente quais elementos considero mais importantes. <br><br>  <b>Fontes de eventos</b> <br><br>  Os dados do evento podem vir do kernel ou do espaço do usuário (aplicativos e bibliotecas).  Alguns deles estão disponíveis automaticamente, sem esforços adicionais do desenvolvedor, enquanto outros requerem anúncio manual. <br><br><img src="https://habrastorage.org/webt/2t/xm/mm/2txmmm6rz5xfcwcglsxy8zopr6q.jpeg"><br>  <i>Visão geral das fontes mais importantes de eventos rastreados no Linux</i> <br><br>  No lado do kernel, existem os kprobes ( <i>de “probes do kernel”, “sensor do kernel”, aprox. Por.</i> ) - um mecanismo que permite rastrear qualquer chamada de função dentro do kernel.  Com ele, é possível rastrear não apenas as chamadas do sistema, mas também o que acontece dentro delas (porque os pontos de entrada das chamadas do sistema chamam outras funções internas).  Você também pode usar o kprobes para rastrear eventos do kernel que não são chamadas do sistema, por exemplo, “dados em buffer estão sendo gravados no disco”, “pacote TCP é enviado pela rede” ou “troca de contexto em andamento”. <br><br>  Os pontos de rastreio do kernel permitem rastrear eventos não padrão definidos pelos desenvolvedores do kernel.  Esses eventos não estão no nível das chamadas de função.  Para criar esses pontos, os desenvolvedores do kernel colocam manualmente a macro TRACE_EVENT no código do kernel. <br><br>  Ambas as fontes têm prós e contras.  O Kprobes funciona "automaticamente" porque  não requer que os desenvolvedores do kernel codifiquem manualmente o código.  Mas os eventos do kprobe podem mudar arbitrariamente de uma versão do kernel para outra, porque as funções estão mudando constantemente - elas são adicionadas, excluídas e renomeadas. <br><br>  Os pontos de rastreio do kernel geralmente são mais estáveis ​​ao longo do tempo e podem fornecer informações contextuais úteis que podem não estar disponíveis se o kprobes for usado.  Usando o kprobes, você pode acessar argumentos de chamada de função.  Mas com a ajuda de pontos de rastreamento, você pode obter qualquer informação que o desenvolvedor do kernel decida descrever manualmente. <br><br>  No espaço do usuário, há um análogo de kprobes - uprobes.  Ele foi projetado para rastrear chamadas de função no espaço do usuário. <br><br>  Os sensores USDT (“Rastreamentos de espaço do usuário definidos estaticamente”) são um análogo dos pontos de rastreamento do kernel no espaço do usuário.  Os desenvolvedores de aplicativos precisam adicionar manualmente os sensores USDT ao código. <br><br>  Fato interessante: o DTrace há muito tempo fornece a API C para definir seu próprio análogo de sensores USDT (usando a macro DTRACE_PROBE).  Os desenvolvedores de ecossistemas de rastreamento no Linux decidiram deixar o código fonte compatível com esta API, para que quaisquer macros DTRACE_PROBE sejam convertidas automaticamente em sensores USDT! <br><br>  Portanto, em teoria, o strace pode ser implementado usando kprobes, e o ltrace pode ser implementado usando uprobes.  Não tenho certeza se isso já é praticado ou não. <br><br>  <b>Interfaces</b> <br><br>  Interfaces são aplicativos que permitem aos usuários usar facilmente fontes de eventos. <br><br>  Vamos ver como as fontes de eventos funcionam.  O fluxo de trabalho é o seguinte: <br><br><ol><li>  O kernel representa um mecanismo - geralmente um arquivo / proc ou / sys aberto para gravação - que registra a intenção de rastrear o evento e o que deve seguir o evento. </li><li>  Depois de registrado, o kernel localiza o kernel / função na memória no espaço do usuário / pontos de rastreamento / sensores USDT e altera seu código para que algo mais aconteça. </li><li>  O resultado dessa "outra coisa" pode ser coletado posteriormente usando algum mecanismo. </li></ol><br>  Eu não gostaria de fazer tudo isso manualmente!  Portanto, as interfaces são úteis: elas fazem tudo isso por você. <br><br>  Existem interfaces para todos os gostos e cores.  No campo das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interfaces baseadas no eBPF,</a> existem as de baixo nível que exigem um entendimento profundo de como interagir com fontes de eventos e como o bytecode do eBPF funciona.  E são de alto nível e fáceis de operar, embora durante a sua existência não tenham demonstrado grande flexibilidade. <br><br>  É por isso que o bpftrace - a interface mais recente - é o meu favorito.  É amigável e flexível como o DTrace.  Mas é bastante novo e requer polimento. <br><br><h3>  eBPF </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eBPF</a> é a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nova estrela de rastreamento do Linux</a> na qual o bpftrace se baseia.  Ao rastrear um evento, você deseja que algo aconteça no kernel.  Quão flexível é a maneira de determinar o que é isso "alguma coisa"?  Obviamente, usando uma linguagem de programação (ou usando código de máquina). <br><br>  eBPF (versão aprimorada do Berkeley Packet Filter).  Esta é uma máquina virtual de alto desempenho que é executada no kernel e tem as seguintes propriedades / limitações: <br><br><ul><li>  Todas as interações do espaço do usuário ocorrem por meio de "cartões" do eBPF, que são o armazenamento de dados de valor-chave. </li><li>  Não há ciclos para que cada programa eBPF termine em um horário específico. </li><li>  Espere, dissemos Filtro de lote?  Você está certo: eles foram originalmente projetados para filtrar pacotes de rede.  Essa é uma tarefa semelhante: ao encaminhar pacotes (a ocorrência de um evento), é necessário executar alguma ação administrativa (aceitar, descartar, registrar em diário ou redirecionar um pacote, etc.) Uma máquina virtual foi inventada para acelerar essas ações (com capacidade JIT) compilação).  Uma versão "estendida" é considerada devido ao fato de que, comparado à versão original do Berkeley Packet Filter, o eBPF pode ser usado fora do contexto da rede. </li></ul><br>  Lá vai você.  Com o bpftrace, você pode determinar quais eventos rastrear e o que deve acontecer em resposta.  O Bpftrace compila seu programa de alto nível bpftrace no bytecode do eBPF, rastreia eventos e carrega o bytecode no kernel. <br><br><h3>  Dias sombrios antes do eBPF </h3><br>  Antes do eBPF, as opções de solução eram, para dizer o mínimo, estranhas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O SystemTap</a> é um dos predecessores "mais sérios" do bpftrace na família Linux.  Os scripts do SystemTap são traduzidos para o idioma C e carregados no kernel como módulos.  O módulo do kernel resultante é então carregado. <br><br>  Essa abordagem era muito frágil e mal suportada fora do Red Hat Enterprise Linux.  Para mim, nunca funcionou bem no Ubuntu, que tendia a quebrar o SystemTap em todas as atualizações do kernel devido a uma alteração na estrutura de dados do kernel.  Também é dito que, nos primeiros dias de sua existência, o SystemTap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">facilmente levava ao pânico do kernel</a> . <br><br><h3>  Instalação do bpftrace </h3><br>  É hora de arregaçar as mangas!  Neste guia, veremos a instalação do bpftrace no Ubuntu 18.04.  Versões mais recentes da distribuição são indesejáveis, porque  durante a instalação, precisaremos de pacotes que ainda não foram compilados para eles. <br><br>  <b>Instalação de Dependências</b> <br><br>  Primeiro, instale o Clang 5.0, lbclang 5.0 e LLVM 5.0, incluindo todos os arquivos de cabeçalho.  Usaremos os pacotes fornecidos pelo llvm.org, porque os repositórios do Ubuntu são <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problemáticos</a> . <br><br><pre><code class="plaintext hljs">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add - cat &lt;&lt;EOF | sudo tee -a /etc/apt/sources.list deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main EOF sudo apt update sudo apt install clang-5.0 libclang-5.0-dev llvm-5.0 llvm-5.0-dev</code> </pre> <br>  Seguinte: <br><br><pre> <code class="plaintext hljs">sudo apt install bison cmake flex g++ git libelf-dev zlib1g-dev libfl-dev</code> </pre> <br>  E, finalmente, instale o libbfcc-dev a partir do upstream, não do repositório Ubuntu.  Não <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">há arquivos de cabeçalho</a> no pacote que está no Ubuntu.  E esse problema não foi resolvido mesmo às 18h10. <br><br><pre> <code class="plaintext hljs">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD echo "deb https://repo.iovisor.org/apt/$(lsb_release -cs) $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/iovisor.list sudo apt update sudo apt install bcc-tools libbcc-examples linux-headers-$(uname -r)</code> </pre> <br>  <b>Instalação principal do Bpftrace</b> <br><br>  É hora de instalar o bpftrace a partir da fonte!  Vamos cloná-lo, montá-lo e instalá-lo em / usr / local: <br><br><pre> <code class="plaintext hljs">git clone https://github.com/iovisor/bpftrace cd bpftrace mkdir build &amp;&amp; cd build cmake -DCMAKE_BUILD_TYPE=DEBUG .. make -j4 sudo make install</code> </pre> <br>  E pronto!  O executável será instalado em / usr / local / bin / bpftrace.  Você pode alterar o destino usando o argumento cmake, que se parece com isso por padrão: <br><br><pre> <code class="plaintext hljs">DCMAKE_INSTALL_PREFIX=/usr/local.</code> </pre> <br>  <b>Exemplos de uma linha</b> <br><br>  Vamos executar alguns liners únicos do bpftrace para entender nossos recursos.  Eu os peguei no <a href="">guia</a> de <a href="">Brendan Gregg</a> , que tem uma descrição detalhada de cada um deles. <br><br>  # 1. Exiba uma lista de sensores <br><br><pre> <code class="plaintext hljs">bpftrace -l 'tracepoint:syscalls:sys_enter_*'</code> </pre> <br>  # 2. Saudações <br><br><pre> <code class="plaintext hljs">bpftrace -e 'BEGIN { printf("hello world\n"); }'</code> </pre> <br>  # 3. Abrindo um arquivo <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf("%s %s\n", comm, str(args-&gt;filename)); }'</code> </pre> <br>  # 4. O número de chamadas do sistema por processo <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'</code> </pre> <br>  # 5. Distribuição de chamadas read () por número de bytes <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_exit_read /pid == 18644/ { @bytes = hist(args-&gt;retval); }'</code> </pre> <br>  # 6. Rastreio dinâmico de conteúdo read () <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kretprobe:vfs_read { @bytes = lhist(retval, 0, 2000, 200); }'</code> </pre> <br>  # 7. Tempo gasto em chamadas read () <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }'</code> </pre> <br>  # 8. Contando eventos no nível do processo <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched* { @[name] = count(); } interval:s:5 { exit(); }'</code> </pre> <br>  # 9. Criando perfil de pilhas de trabalho do kernel <br><br><pre> <code class="plaintext hljs">bpftrace -e 'profile:hz:99 { @[stack] = count(); }'</code> </pre> <br>  # 10. Planejador de rastreamento <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched_switch { @[stack] = count(); }'</code> </pre> <br>  # 11. Rastreio de E / S de bloqueio <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:block:block_rq_complete { @ = hist(args-&gt;nr_sector * 512); }'</code> </pre> <br>  Confira o site de Brendan Gregg para descobrir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que tipo de saída as equipes acima podem gerar</a> . <br><br>  <b>Sintaxe de script e exemplo de tempo de E / S</b> <br><br>  A sequência passada pela opção '-e' é o conteúdo do script bpftrace.  A sintaxe nesse caso é, condicionalmente, um conjunto de construções: <br><br><pre> <code class="plaintext hljs">&lt;event source&gt; /&lt;optional filter&gt;/ { &lt;program body&gt; }</code> </pre> <br>  Vejamos o sétimo exemplo, sobre o tempo das operações de leitura do sistema de arquivos: <br><br><pre> <code class="plaintext hljs">kprobe:vfs_read { @start[tid] = nsecs; } &lt;- 1 -&gt;&lt;-- 2 -&gt; &lt;---------- 3 ---------&gt;</code> </pre> <br>  Rastreamos o evento a partir do mecanismo <i>kprobe</i> , ou seja, rastreamos o início da função do kernel. <br>  A função do kernel para rastreamento é <i>vfs_read</i> , essa função é chamada quando o kernel executa uma operação de leitura do sistema de arquivos (VFS do “Virtual FileSystem”, abstração do sistema de arquivos dentro do kernel). <br><br>  Quando o <i>vfs_read</i> começa a ser <i>executado</i> (ou seja, antes da função <i>executar</i> qualquer trabalho útil), o programa bpftrace é iniciado.  Ele salva o registro de data e hora atual (em nanossegundos) em um array associativo global chamado <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">st</a> art</i> .  A chave é <i>tid</i> , uma referência ao ID do encadeamento atual. <br><br><pre> <code class="plaintext hljs">kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); } &lt;-- 1 --&gt; &lt;-- 2 -&gt; &lt;---- 3 ----&gt; &lt;----------------------------- 4 -----------------------------&gt;</code> </pre> <br>  1. Rastreamos o evento a partir do mecanismo <i>kretprobe</i> , que é semelhante ao <i>kprobe</i> , exceto que ele é chamado quando a função retorna o resultado de sua execução. <br><br>  2. A função do kernel para rastreamento é <i>vfs_read</i> . <br><br>  3. Este é um filtro opcional.  Ele verifica se a hora de início foi gravada anteriormente.  Sem esse filtro, o programa pode ser iniciado durante a leitura e capturar apenas o final, resultando em um tempo <i>estimado</i> de <i>nsecs - 0</i> , em vez de <i>nsecs - iniciar</i> . <br><br>  4. O corpo do programa. <br><br>  <i>nsecs - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">st</a> art [tid]</i> calcula quanto tempo se passou desde o início da função vfs_read. <br>  <i>@ns [comm] = hist (...)</i> adiciona os dados especificados ao histograma bidimensional armazenado em <i>@ns</i> .  A chave de <i>comunicação</i> refere-se ao nome do aplicativo atual.  Portanto, teremos um histograma comando por comando. <br><br>  <i>delete (...)</i> exclui o horário de início da matriz associativa, porque não precisamos mais dele. <br><br>  Esta é a conclusão final.  Observe que todos os histogramas são exibidos automaticamente.  O uso explícito do comando imprimir histograma não é necessário.  <i>@ns</i> não é uma variável especial; portanto, o histograma não é exibido por causa disso. <br><br><pre> <code class="plaintext hljs">@ns[snmp-pass]: [0, 1] 0 | | [2, 4) 0 | | [4, 8) 0 | | [8, 16) 0 | | [16, 32) 0 | | [32, 64) 0 | | [64, 128) 0 | | [128, 256) 0 | | [256, 512) 27 |@@@@@@@@@ | [512, 1k) 125 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ | [1k, 2k) 22 |@@@@@@@ | [2k, 4k) 1 | | [4k, 8k) 10 |@@@ | [8k, 16k) 1 | | [16k, 32k) 3 |@ | [32k, 64k) 144 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@| [64k, 128k) 7 |@@ | [128k, 256k) 28 |@@@@@@@@@@ | [256k, 512k) 2 | | [512k, 1M) 3 |@ | [1M, 2M) 1 | |</code> </pre> <br><br>  <b>Exemplo de sensor USDT</b> <br><br>  Vamos pegar esse código C e salvá-lo no arquivo <i>tracetest.c</i> : <br><br><pre> <code class="plaintext hljs">#include &lt;sys/sdt.h&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; static long myclock() { struct timeval tv; gettimeofday(&amp;tv, NULL); DTRACE_PROBE1(tracetest, testprobe, tv.tv_sec); return tv.tv_sec; } int main(int argc, char **argv) { while (1) { myclock(); sleep(1); } return 0; }</code> </pre> <br>  Este programa é executado infinitamente chamando <i>myclock ()</i> uma vez por segundo.  <i>myclock ()</i> consulta a hora atual e retorna o número de segundos desde o início da era. <br><br>  A chamada para <i>DTRACE_PROBE1</i> aqui define um ponto de rastreamento USDT estático. <br><br><ul><li>  A macro <i>DTRACE_PROBE1</i> é obtida em <i>sys / sdt.h.</i>  A macro oficial do USDT, que faz o mesmo, é chamada <i>STAP_PROBE1</i> (STAP do SystemTap, que foi o primeiro mecanismo Linux suportado no USDT).  Mas como o USDT é compatível com os sensores de espaço do usuário do DTrace, o <i>DTRACE_PROBE1</i> é apenas uma referência ao <i>STAP_PROBE1</i> . </li><li>  O primeiro parâmetro é o nome do provedor.  Acredito que este é um vestígio que resta do DTrace, porque o bpftrace não parece estar fazendo nada útil com ele.  No entanto, há uma nuance ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que eu descobri ao depurar o problema na solicitação 328</a> ): o nome do provedor deve ser idêntico ao nome do arquivo binário do aplicativo, caso contrário, o bpftrace não conseguirá encontrar o ponto de rastreamento. </li><li>  O segundo parâmetro é o nome do ponto de rastreamento. </li><li>  Quaisquer parâmetros adicionais são o contexto fornecido pelos desenvolvedores.  O número <i>1</i> em <i>DTRACE_PROBE1</i> significa que queremos passar um parâmetro adicional. </li></ul><br>  Vamos garantir que sys / sdt.h esteja disponível para nós e montar o programa: <br><br><pre> <code class="plaintext hljs">sudo apt install systemtap-sdt-dev gcc tracetest.c -o tracetest -Wall -g</code> </pre> <br>  Instruímos o bpftrace a emitir o PID e "time is [number]" sempre que a <i>testprobe for</i> atingida: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/full-path-to/tracetest:testprobe { printf("%d: time is %d\n", pid, arg0); }'</code> </pre> <br>  O Bpftrace continua funcionando enquanto pressionamos Ctrl-C.  Portanto, abra um novo terminal e execute o teste mais <i>rápido</i> lá: <br><br>  # No novo terminal <br>  ./tracetest <br><br>  Volte para o primeiro terminal com bpftrace, lá você deve ver algo como: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... 30909: time is 1549023215 30909: time is 1549023216 30909: time is 1549023217 ... ^C</code> </pre> <br>  <b>Exemplo de alocação de memória usando glibc ptmalloc</b> <br><br>  Eu uso o bpftrace para entender por que o Ruby usa tanta memória.  E como parte de minha pesquisa, preciso entender como o alocador de memória da glibc usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">regiões de memória</a> . <br><br>  Para otimizar o desempenho de vários núcleos, o alocador de memória glibc destaca várias "áreas" do sistema operacional.  Quando o aplicativo solicita alocação de memória, o alocador seleciona uma área que não está em uso e marca parte dessa área como "usada".  Como os encadeamentos usam áreas diferentes, o número de bloqueios é reduzido, o que leva a um melhor desempenho multithread. <br><br>  Mas essa abordagem gera muito lixo e parece que um consumo de memória tão alto no Ruby é justamente por isso.  Para entender melhor a natureza desse lixo, pensei: o que significa “escolher uma área que não é usada”?  Isso pode significar um dos seguintes: <br><br><ul><li>  Cada vez que <i>malloc () é</i> chamado, o alocador itera sobre todas as áreas e localiza aquela que não está bloqueada no momento.  E somente se todos estiverem bloqueados, ele tentará criar um novo. </li><li>  A primeira vez que <i>malloc () é</i> chamado em um encadeamento específico (ou quando o encadeamento é iniciado), o alocador seleciona aquele que não está bloqueado no momento.  E se todos estiverem bloqueados, ele tentará criar um novo. </li><li>  Na primeira vez em que <i>malloc () é</i> chamado em um encadeamento específico (ou quando o encadeamento é iniciado), o alocador tenta criar uma nova região, independentemente de haver regiões desbloqueadas.  Somente se uma nova área não puder ser criada (por exemplo, quando o limite estiver esgotado), ela reutilizará a existente. </li><li>  Provavelmente existem mais opções que eu não considerei. </li></ul><br>  Não há resposta específica na documentação, qual desses recursos permite selecionar uma área que não é usada.  Estudei o código fonte da glibc, que sugeriu a opção 3.  Mas eu queria verificar experimentalmente que interpretei o código fonte corretamente, sem a necessidade de depurar o código no glibc. <br><br>  Aqui está a função de alocador de memória glibc que cria uma nova área.  Mas você pode chamá-lo somente depois de verificar o limite. <br><br><pre> <code class="plaintext hljs">static mstate _int_new_arena(size_t size) { mstate arena; size = calculate_how_much_memory_to_ask_from_os(size); arena = do_some_stuff_to_allocate_memory_from_os(); LIBC_PROBE(memory_arena_new, 2, arena, size); do_more_stuff(); return arena; }</code> </pre> <br>  Posso usar <i>uprobes</i> para rastrear a função <i>_int_new_arena</i> ?  Infelizmente não.  Por alguma razão, este símbolo não está disponível no glibc Ubuntu 18.04.  Mesmo após a instalação dos símbolos de depuração. <br><br>  Felizmente, existe um sensor USDT nesta função.  <i>LIBC_PROBE</i> é um alias de macro para <i>STAP_PROBE</i> . <br>  O nome do provedor é libc. <br>  O nome do sensor é memory_arena_new. <br>  O número 2 significa que existem 2 argumentos adicionais especificados pelo desenvolvedor. <br>  arena é o endereço da área que foi extraída do sistema operacional e tamanho é o seu tamanho. <br><br>  Antes de podermos usar esse sensor, precisamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contornar o problema 328</a> .  Precisamos criar um link simbólico com glibc em algum lugar com o nome <i>libc</i> , porque o bpftrace espera que o nome da biblioteca (que de outra forma seria <i>libc-2.27.so</i> ) seja idêntico ao nome do provedor <i>(libc)</i> . <br><br><pre> <code class="plaintext hljs">ln -s /lib/x86_64-linux-gnu/libc-2.27.so /tmp/libc</code> </pre> <br>  Agora instruímos o bpftrace a conectar o sensor USDT memory_arena_new, cujo nome do fornecedor é <i>libc</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/tmp/libc:memory_arena_new { printf("PID %d: created new arena at %p, size %d\n", pid, arg0, arg1); }'</code> </pre> <br>  Em outro terminal, rodaremos o Ruby, que criará três threads que não fazem nada e terminam em um segundo.  Devido ao bloqueio global do intérprete, Ruby <i>malloc ()</i> não deve ser chamado em paralelo por threads diferentes. <br><br><pre> <code class="plaintext hljs">ruby -e '3.times { Thread.new { } }; sleep 1'</code> </pre> <br>  Voltando ao terminal com bpftrace, veremos: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... PID 431: created new arena at 0x7f40e8000020, size 576 PID 431: created new arena at 0x7f40e0000020, size 576 PID 431: created new arena at 0x7f40e4000020, size 576</code> </pre> <br>  Aqui está a resposta para a nossa pergunta!  Cada vez que você cria um novo thread no Ruby, a glibc destaca uma nova área, independentemente da competitividade. <br><br>  <b>Quais pontos de rastreio estão disponíveis?</b>  <b>O que devo rastrear?</b> <br><br>  Você pode listar todos os pontos de rastreio de hardware, timers, kprobe e estático do kernel executando o comando: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l</code> </pre> <br>  Você pode listar todos os pontos de rastreio da verificação vertical (caracteres de função) de um aplicativo ou biblioteca fazendo: <br><br><pre> <code class="plaintext hljs">nm /path-to-binary</code> </pre> <br>  Você pode listar todos os pontos de rastreio do aplicativo ou biblioteca USDT executando o seguinte comando: <br><br><pre> <code class="plaintext hljs">/usr/share/bcc/tools/tplist -l /path-to/binary</code> </pre> <br>  Com relação a quais pontos de rastreamento usar: não faria mal entender o código fonte do que você vai rastrear.  Eu recomendo que você estude o código fonte. <br><br>  <b>Dica: um formato estrutural para pontos de rastreio no kernel</b> <br><br>  Aqui está uma dica útil sobre os pontos de rastreamento do kernel.  Você pode verificar quais campos de argumento estão disponíveis lendo o arquivo / sys / kernel / debug / tracing / events! <br><br>  Por exemplo, suponha que você deseja rastrear chamadas para <i>madvise (..., MADV_DONTNEED)</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l | grep madvise</code> </pre> <br>  - nos dirá que podemos usar o tracepoint: syscalls: sys_enter_madvise. <br><br><pre> <code class="plaintext hljs">sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_madvise/format</code> </pre> <br>  - nos fornecerá as seguintes informações: <br><br><pre> <code class="plaintext hljs">name: sys_enter_madvise ID: 569 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:unsigned long start; offset:16; size:8; signed:0; field:size_t len_in; offset:24; size:8; signed:0; field:int behavior; offset:32; size:8; signed:0; print fmt: "start: 0x%08lx, len_in: 0x%08lx, behavior: 0x%08lx", ((unsigned long)(REC-&gt;start)), ((unsigned long)(REC-&gt;len_in)), ((unsigned long)(REC-&gt;behavior))</code> </pre> <br>  Assinatura Madvise de acordo com o manual: <i>(void * addr, size_t length, int conselho)</i> .  Os últimos três campos dessa estrutura correspondem a esses parâmetros! <br><br>  Qual é o significado de MADV_DONTNEED?  A julgar pelo grep MADV_DONTNEED / usr / include, é igual a 4: <br><br><pre> <code class="plaintext hljs">/usr/include/x86_64-linux-gnu/bits/mman-linux.h:80:# define MADV_DONTNEED 4 /* Don't need these pages. */</code> </pre> <br>  Portanto, nossa equipe bpftrace se torna: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'tracepoint:syscalls:sys_enter_madvise /args-&gt;behavior == 4/ { printf("madvise DONTNEED called\n"); }'</code> </pre> <br><h3>  Conclusão </h3><br>  Bpftrace é maravilhoso!  Bpftrace é o futuro! <br><br>  Se você quiser saber mais sobre ele, recomendo que você se familiarize com <a href="">a liderança dele</a> , bem como com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro post de 2019</a> no blog de Brendan Gregg. <br><br>  Boa depuração! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441258/">https://habr.com/ru/post/pt441258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441244/index.html">A vulnerabilidade do WinRar, fechada por 19 anos, permite colocar o arquivo descompactado em qualquer lugar</a></li>
<li><a href="../pt441248/index.html">A Rússia ficou em 9º lugar na classificação SSL global, à frente da China, Dinamarca e Suíça</a></li>
<li><a href="../pt441250/index.html">Início rápido: Ir + Apache Kafka + Redis</a></li>
<li><a href="../pt441252/index.html">“Artigo sobre boquete”: cientistas processaram 109 horas de sexo oral para desenvolver uma IA que suga um membro</a></li>
<li><a href="../pt441254/index.html">Seminário “Por que entramos em contato com o Kubernetes e o que obtemos dele”, 28 de fevereiro de Moscou</a></li>
<li><a href="../pt441260/index.html">Como os gráficos de rede neural ajudaram</a></li>
<li><a href="../pt441262/index.html">Tarefas simples e longas eliminam os candidatos melhor do que os curtos e complexos</a></li>
<li><a href="../pt441264/index.html">Guia do Usuário Kibana. Visualização. Parte 2</a></li>
<li><a href="../pt441266/index.html">Como o framework tiOPF para delphi / lazarus funciona. Modelo de visitante</a></li>
<li><a href="../pt441268/index.html">Testes de Ceedling + Eclipse ou de unidade para microcontroladores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>