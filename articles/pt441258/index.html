<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèø üêî üî§ Rastreamento din√¢mico completo no Linux usando eBPF e bpftrace ü•Ç üë®üèæ‚ÄçüöÄ üöö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúNo modo de rastreamento, o programador v√™ a sequ√™ncia de execu√ß√£o do comando e os valores das vari√°veis ‚Äã‚Äãnesta etapa da execu√ß√£o do programa, o que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rastreamento din√¢mico completo no Linux usando eBPF e bpftrace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/441258/"><img src="https://habrastorage.org/webt/gd/t6/e_/gdt6e_wwaanx1prvqkhdhj5ptss.jpeg"><br><br>  ‚ÄúNo modo de rastreamento, o programador v√™ a sequ√™ncia de execu√ß√£o do comando e os valores das vari√°veis ‚Äã‚Äãnesta etapa da execu√ß√£o do programa, o que facilita a detec√ß√£o de erros‚Äù, conta a Wikipedia.  Como f√£s do Linux, regularmente nos deparamos com a quest√£o de quais ferramentas espec√≠ficas s√£o melhores para implement√°-lo.  E queremos compartilhar a tradu√ß√£o de um artigo do programador Hongley Lai, que recomenda o bpftrace.  Olhando para o futuro, direi que o artigo termina de forma sucinta: "bpftrace √© o futuro".  Ent√£o, por que ele impressionou tanto o colega de Lai?  Uma resposta detalhada sob o corte. <br><a name="habracut"></a><br>  Existem duas ferramentas principais de rastreamento no Linux: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">strace</a> permite ver quais chamadas do sistema est√£o sendo feitas; <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O ltrace</a> permite ver quais bibliotecas din√¢micas est√£o sendo chamadas. <br><br>  Apesar de sua utilidade, essas ferramentas s√£o limitadas.  E se voc√™ precisar descobrir o que acontece em uma chamada de sistema ou biblioteca?  E se voc√™ precisar n√£o apenas compilar uma lista de chamadas, mas tamb√©m, por exemplo, coletar estat√≠sticas sobre determinado comportamento?  E se voc√™ precisar rastrear v√°rios processos e comparar dados de v√°rias fontes? <br><br>  Em 2019, finalmente obtivemos uma resposta decente para essas perguntas no Linux: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bpftrace com</a> base na tecnologia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eBPF</a> .  O Bpftrace permite escrever pequenos programas que s√£o executados toda vez que um evento ocorre. <br><br>  Neste artigo, descreverei como instalar o bpftrace e ensinar sua aplica√ß√£o b√°sica.  Tamb√©m revisarei como √© o ecossistema de rastreamento (por exemplo, ‚Äúo que √© eBPF?‚Äù) E como ele evoluiu para o que temos hoje. <br><br><img src="https://habrastorage.org/webt/v9/vp/di/v9vpdivpv8a6roolw_kiz7wtnfs.png"><br><br><h3>  O que √© um tra√ßo? </h3><br>  Como mencionado anteriormente, o bpftrace permite escrever pequenos programas que s√£o executados toda vez que um evento ocorre. <br><br>  O que √© um evento?  Pode ser uma chamada do sistema, uma chamada de fun√ß√£o ou mesmo algo acontecendo dentro de tais solicita√ß√µes.  Tamb√©m pode ser um temporizador ou um evento de hardware, por exemplo, ‚Äú50 ms passaram desde o √∫ltimo dos mesmos eventos‚Äù, ‚Äúocorreu falha na p√°gina‚Äù, ‚Äúocorreu mudan√ßa de contexto‚Äù ou ‚Äúocorreu o processador de perda de caso‚Äù. <br><br>  O que pode ser feito em resposta a um evento?  Voc√™ pode prometer algo, coletar estat√≠sticas e executar comandos arbitr√°rios do shell.  Voc√™ ter√° acesso a v√°rias informa√ß√µes contextuais, como o PID atual, rastreamento de pilha, hora, argumentos de chamada, valores de retorno, etc. <br><br>  Quando usar?  Em muitos  Voc√™ pode descobrir por que o aplicativo √© lento compilando uma lista das chamadas mais lentas.  Voc√™ pode determinar se h√° vazamentos de mem√≥ria no aplicativo e, em caso afirmativo, onde.  Eu o uso para entender por que Ruby usa tanta mem√≥ria. <br><br>  A grande vantagem do bpftrace √© que voc√™ n√£o precisa recompilar o aplicativo.  N√£o h√° necessidade de escrever manualmente chamadas de impress√£o ou qualquer outro c√≥digo de depura√ß√£o no c√≥digo-fonte do aplicativo em estudo.  N√£o √© necess√°rio reiniciar aplicativos.  E tudo isso com sobrecarga muito baixa.  Isso torna o bpftrace especialmente √∫til para depurar sistemas diretamente no produto ou em outra situa√ß√£o em que h√° dificuldades com a recompila√ß√£o. <br><br><h3>  DTrace: pai do rastreamento </h3><br>  Por um longo tempo, a melhor ferramenta de rastreamento foi o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DTrace</a> , uma estrutura completa de rastreamento din√¢mico originalmente desenvolvida pela Sun Microsystems (os fabricantes de Java).  Como o bpftrace, o DTrace permite escrever pequenos programas que s√£o executados em resposta a eventos.  De fato, muitos dos elementos-chave do ecossistema s√£o amplamente desenvolvidos por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Brendan Gregg</a> , um renomado especialista em DTrace que atualmente trabalha na Netflix.  O que explica as semelhan√ßas entre o DTrace e o bpftrace. <br><br><img src="https://habrastorage.org/webt/2p/wc/4w/2pwc4wawnfzibvlwt7ia0xibodc.jpeg"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Introdu√ß√£o ao Solaris DTrace (2009)</a> por S. Tripathi, Sun Microsystems</i> <br><br>  Em algum momento, a Sun abriu a fonte do DTrace.  Hoje, o DTrace est√° dispon√≠vel no Solaris, FreeBSD e macOS (embora a vers√£o do macOS seja geralmente inoperante porque o System Integrity Protection, SIP, quebrou muitos dos princ√≠pios nos quais o DTrace √© executado). <br><br>  Sim, voc√™ percebeu corretamente ... O Linux n√£o est√° nesta lista.  Este n√£o √© um problema de engenharia, √© um problema de licenciamento.  O DTrace foi aberto sob o CDDL em vez da GPL.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A porta Linux DTrace</a> est√° dispon√≠vel desde 2011, mas nunca foi suportada pelos principais desenvolvedores de Linux.  No in√≠cio de 2018, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Oracle reabriu o DTrace sob a GPL</a> , mas j√° era tarde demais. <br><br><h3>  Ecossistema de rastreamento do Linux </h3><br>  Sem d√∫vida, o rastreamento √© muito √∫til, e a comunidade Linux procurou desenvolver suas pr√≥prias solu√ß√µes para este t√≥pico.  Por√©m, diferentemente do Solaris, o Linux n√£o √© regulamentado por um fornecedor espec√≠fico e, portanto, n√£o houve esfor√ßo deliberado para desenvolver uma substitui√ß√£o totalmente funcional para o DTrace.  O ecossistema de rastreamento do Linux evoluiu lenta e naturalmente, resolvendo problemas √† medida que eles surgem.  E apenas recentemente esse ecossistema cresceu o suficiente para competir seriamente com o DTrace. <br><br>  Devido ao crescimento natural, esse ecossistema pode parecer um pouco ca√≥tico, consistindo em muitos componentes diferentes.  Felizmente, Julia Evans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escreveu uma revis√£o desse ecossistema</a> (aten√ß√£o, data de publica√ß√£o - 2017, antes do advento do bpftrace). <br><br><img src="https://habrastorage.org/webt/io/km/zq/iokmzq2fmqyechm1boqeks-w2za.png"><br>  <i>Ecossistema de rastreamento de Linux descrito por Julia Evans</i> <br><br>  Nem todos os elementos s√£o igualmente importantes.  Deixe-me resumir brevemente quais elementos considero mais importantes. <br><br>  <b>Fontes de eventos</b> <br><br>  Os dados do evento podem vir do kernel ou do espa√ßo do usu√°rio (aplicativos e bibliotecas).  Alguns deles est√£o dispon√≠veis automaticamente, sem esfor√ßos adicionais do desenvolvedor, enquanto outros requerem an√∫ncio manual. <br><br><img src="https://habrastorage.org/webt/2t/xm/mm/2txmmm6rz5xfcwcglsxy8zopr6q.jpeg"><br>  <i>Vis√£o geral das fontes mais importantes de eventos rastreados no Linux</i> <br><br>  No lado do kernel, existem os kprobes ( <i>de ‚Äúprobes do kernel‚Äù, ‚Äúsensor do kernel‚Äù, aprox. Por.</i> ) - um mecanismo que permite rastrear qualquer chamada de fun√ß√£o dentro do kernel.  Com ele, √© poss√≠vel rastrear n√£o apenas as chamadas do sistema, mas tamb√©m o que acontece dentro delas (porque os pontos de entrada das chamadas do sistema chamam outras fun√ß√µes internas).  Voc√™ tamb√©m pode usar o kprobes para rastrear eventos do kernel que n√£o s√£o chamadas do sistema, por exemplo, ‚Äúdados em buffer est√£o sendo gravados no disco‚Äù, ‚Äúpacote TCP √© enviado pela rede‚Äù ou ‚Äútroca de contexto em andamento‚Äù. <br><br>  Os pontos de rastreio do kernel permitem rastrear eventos n√£o padr√£o definidos pelos desenvolvedores do kernel.  Esses eventos n√£o est√£o no n√≠vel das chamadas de fun√ß√£o.  Para criar esses pontos, os desenvolvedores do kernel colocam manualmente a macro TRACE_EVENT no c√≥digo do kernel. <br><br>  Ambas as fontes t√™m pr√≥s e contras.  O Kprobes funciona "automaticamente" porque  n√£o requer que os desenvolvedores do kernel codifiquem manualmente o c√≥digo.  Mas os eventos do kprobe podem mudar arbitrariamente de uma vers√£o do kernel para outra, porque as fun√ß√µes est√£o mudando constantemente - elas s√£o adicionadas, exclu√≠das e renomeadas. <br><br>  Os pontos de rastreio do kernel geralmente s√£o mais est√°veis ‚Äã‚Äãao longo do tempo e podem fornecer informa√ß√µes contextuais √∫teis que podem n√£o estar dispon√≠veis se o kprobes for usado.  Usando o kprobes, voc√™ pode acessar argumentos de chamada de fun√ß√£o.  Mas com a ajuda de pontos de rastreamento, voc√™ pode obter qualquer informa√ß√£o que o desenvolvedor do kernel decida descrever manualmente. <br><br>  No espa√ßo do usu√°rio, h√° um an√°logo de kprobes - uprobes.  Ele foi projetado para rastrear chamadas de fun√ß√£o no espa√ßo do usu√°rio. <br><br>  Os sensores USDT (‚ÄúRastreamentos de espa√ßo do usu√°rio definidos estaticamente‚Äù) s√£o um an√°logo dos pontos de rastreamento do kernel no espa√ßo do usu√°rio.  Os desenvolvedores de aplicativos precisam adicionar manualmente os sensores USDT ao c√≥digo. <br><br>  Fato interessante: o DTrace h√° muito tempo fornece a API C para definir seu pr√≥prio an√°logo de sensores USDT (usando a macro DTRACE_PROBE).  Os desenvolvedores de ecossistemas de rastreamento no Linux decidiram deixar o c√≥digo fonte compat√≠vel com esta API, para que quaisquer macros DTRACE_PROBE sejam convertidas automaticamente em sensores USDT! <br><br>  Portanto, em teoria, o strace pode ser implementado usando kprobes, e o ltrace pode ser implementado usando uprobes.  N√£o tenho certeza se isso j√° √© praticado ou n√£o. <br><br>  <b>Interfaces</b> <br><br>  Interfaces s√£o aplicativos que permitem aos usu√°rios usar facilmente fontes de eventos. <br><br>  Vamos ver como as fontes de eventos funcionam.  O fluxo de trabalho √© o seguinte: <br><br><ol><li>  O kernel representa um mecanismo - geralmente um arquivo / proc ou / sys aberto para grava√ß√£o - que registra a inten√ß√£o de rastrear o evento e o que deve seguir o evento. </li><li>  Depois de registrado, o kernel localiza o kernel / fun√ß√£o na mem√≥ria no espa√ßo do usu√°rio / pontos de rastreamento / sensores USDT e altera seu c√≥digo para que algo mais aconte√ßa. </li><li>  O resultado dessa "outra coisa" pode ser coletado posteriormente usando algum mecanismo. </li></ol><br>  Eu n√£o gostaria de fazer tudo isso manualmente!  Portanto, as interfaces s√£o √∫teis: elas fazem tudo isso por voc√™. <br><br>  Existem interfaces para todos os gostos e cores.  No campo das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interfaces baseadas no eBPF,</a> existem as de baixo n√≠vel que exigem um entendimento profundo de como interagir com fontes de eventos e como o bytecode do eBPF funciona.  E s√£o de alto n√≠vel e f√°ceis de operar, embora durante a sua exist√™ncia n√£o tenham demonstrado grande flexibilidade. <br><br>  √â por isso que o bpftrace - a interface mais recente - √© o meu favorito.  √â amig√°vel e flex√≠vel como o DTrace.  Mas √© bastante novo e requer polimento. <br><br><h3>  eBPF </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eBPF</a> √© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nova estrela de rastreamento do Linux</a> na qual o bpftrace se baseia.  Ao rastrear um evento, voc√™ deseja que algo aconte√ßa no kernel.  Qu√£o flex√≠vel √© a maneira de determinar o que √© isso "alguma coisa"?  Obviamente, usando uma linguagem de programa√ß√£o (ou usando c√≥digo de m√°quina). <br><br>  eBPF (vers√£o aprimorada do Berkeley Packet Filter).  Esta √© uma m√°quina virtual de alto desempenho que √© executada no kernel e tem as seguintes propriedades / limita√ß√µes: <br><br><ul><li>  Todas as intera√ß√µes do espa√ßo do usu√°rio ocorrem por meio de "cart√µes" do eBPF, que s√£o o armazenamento de dados de valor-chave. </li><li>  N√£o h√° ciclos para que cada programa eBPF termine em um hor√°rio espec√≠fico. </li><li>  Espere, dissemos Filtro de lote?  Voc√™ est√° certo: eles foram originalmente projetados para filtrar pacotes de rede.  Essa √© uma tarefa semelhante: ao encaminhar pacotes (a ocorr√™ncia de um evento), √© necess√°rio executar alguma a√ß√£o administrativa (aceitar, descartar, registrar em di√°rio ou redirecionar um pacote, etc.) Uma m√°quina virtual foi inventada para acelerar essas a√ß√µes (com capacidade JIT) compila√ß√£o).  Uma vers√£o "estendida" √© considerada devido ao fato de que, comparado √† vers√£o original do Berkeley Packet Filter, o eBPF pode ser usado fora do contexto da rede. </li></ul><br>  L√° vai voc√™.  Com o bpftrace, voc√™ pode determinar quais eventos rastrear e o que deve acontecer em resposta.  O Bpftrace compila seu programa de alto n√≠vel bpftrace no bytecode do eBPF, rastreia eventos e carrega o bytecode no kernel. <br><br><h3>  Dias sombrios antes do eBPF </h3><br>  Antes do eBPF, as op√ß√µes de solu√ß√£o eram, para dizer o m√≠nimo, estranhas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O SystemTap</a> √© um dos predecessores "mais s√©rios" do bpftrace na fam√≠lia Linux.  Os scripts do SystemTap s√£o traduzidos para o idioma C e carregados no kernel como m√≥dulos.  O m√≥dulo do kernel resultante √© ent√£o carregado. <br><br>  Essa abordagem era muito fr√°gil e mal suportada fora do Red Hat Enterprise Linux.  Para mim, nunca funcionou bem no Ubuntu, que tendia a quebrar o SystemTap em todas as atualiza√ß√µes do kernel devido a uma altera√ß√£o na estrutura de dados do kernel.  Tamb√©m √© dito que, nos primeiros dias de sua exist√™ncia, o SystemTap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">facilmente levava ao p√¢nico do kernel</a> . <br><br><h3>  Instala√ß√£o do bpftrace </h3><br>  √â hora de arrega√ßar as mangas!  Neste guia, veremos a instala√ß√£o do bpftrace no Ubuntu 18.04.  Vers√µes mais recentes da distribui√ß√£o s√£o indesej√°veis, porque  durante a instala√ß√£o, precisaremos de pacotes que ainda n√£o foram compilados para eles. <br><br>  <b>Instala√ß√£o de Depend√™ncias</b> <br><br>  Primeiro, instale o Clang 5.0, lbclang 5.0 e LLVM 5.0, incluindo todos os arquivos de cabe√ßalho.  Usaremos os pacotes fornecidos pelo llvm.org, porque os reposit√≥rios do Ubuntu s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problem√°ticos</a> . <br><br><pre><code class="plaintext hljs">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add - cat &lt;&lt;EOF | sudo tee -a /etc/apt/sources.list deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main EOF sudo apt update sudo apt install clang-5.0 libclang-5.0-dev llvm-5.0 llvm-5.0-dev</code> </pre> <br>  Seguinte: <br><br><pre> <code class="plaintext hljs">sudo apt install bison cmake flex g++ git libelf-dev zlib1g-dev libfl-dev</code> </pre> <br>  E, finalmente, instale o libbfcc-dev a partir do upstream, n√£o do reposit√≥rio Ubuntu.  N√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">h√° arquivos de cabe√ßalho</a> no pacote que est√° no Ubuntu.  E esse problema n√£o foi resolvido mesmo √†s 18h10. <br><br><pre> <code class="plaintext hljs">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD echo "deb https://repo.iovisor.org/apt/$(lsb_release -cs) $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/iovisor.list sudo apt update sudo apt install bcc-tools libbcc-examples linux-headers-$(uname -r)</code> </pre> <br>  <b>Instala√ß√£o principal do Bpftrace</b> <br><br>  √â hora de instalar o bpftrace a partir da fonte!  Vamos clon√°-lo, mont√°-lo e instal√°-lo em / usr / local: <br><br><pre> <code class="plaintext hljs">git clone https://github.com/iovisor/bpftrace cd bpftrace mkdir build &amp;&amp; cd build cmake -DCMAKE_BUILD_TYPE=DEBUG .. make -j4 sudo make install</code> </pre> <br>  E pronto!  O execut√°vel ser√° instalado em / usr / local / bin / bpftrace.  Voc√™ pode alterar o destino usando o argumento cmake, que se parece com isso por padr√£o: <br><br><pre> <code class="plaintext hljs">DCMAKE_INSTALL_PREFIX=/usr/local.</code> </pre> <br>  <b>Exemplos de uma linha</b> <br><br>  Vamos executar alguns liners √∫nicos do bpftrace para entender nossos recursos.  Eu os peguei no <a href="">guia</a> de <a href="">Brendan Gregg</a> , que tem uma descri√ß√£o detalhada de cada um deles. <br><br>  # 1. Exiba uma lista de sensores <br><br><pre> <code class="plaintext hljs">bpftrace -l 'tracepoint:syscalls:sys_enter_*'</code> </pre> <br>  # 2. Sauda√ß√µes <br><br><pre> <code class="plaintext hljs">bpftrace -e 'BEGIN { printf("hello world\n"); }'</code> </pre> <br>  # 3. Abrindo um arquivo <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf("%s %s\n", comm, str(args-&gt;filename)); }'</code> </pre> <br>  # 4. O n√∫mero de chamadas do sistema por processo <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'</code> </pre> <br>  # 5. Distribui√ß√£o de chamadas read () por n√∫mero de bytes <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_exit_read /pid == 18644/ { @bytes = hist(args-&gt;retval); }'</code> </pre> <br>  # 6. Rastreio din√¢mico de conte√∫do read () <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kretprobe:vfs_read { @bytes = lhist(retval, 0, 2000, 200); }'</code> </pre> <br>  # 7. Tempo gasto em chamadas read () <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }'</code> </pre> <br>  # 8. Contando eventos no n√≠vel do processo <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched* { @[name] = count(); } interval:s:5 { exit(); }'</code> </pre> <br>  # 9. Criando perfil de pilhas de trabalho do kernel <br><br><pre> <code class="plaintext hljs">bpftrace -e 'profile:hz:99 { @[stack] = count(); }'</code> </pre> <br>  # 10. Planejador de rastreamento <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched_switch { @[stack] = count(); }'</code> </pre> <br>  # 11. Rastreio de E / S de bloqueio <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:block:block_rq_complete { @ = hist(args-&gt;nr_sector * 512); }'</code> </pre> <br>  Confira o site de Brendan Gregg para descobrir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que tipo de sa√≠da as equipes acima podem gerar</a> . <br><br>  <b>Sintaxe de script e exemplo de tempo de E / S</b> <br><br>  A sequ√™ncia passada pela op√ß√£o '-e' √© o conte√∫do do script bpftrace.  A sintaxe nesse caso √©, condicionalmente, um conjunto de constru√ß√µes: <br><br><pre> <code class="plaintext hljs">&lt;event source&gt; /&lt;optional filter&gt;/ { &lt;program body&gt; }</code> </pre> <br>  Vejamos o s√©timo exemplo, sobre o tempo das opera√ß√µes de leitura do sistema de arquivos: <br><br><pre> <code class="plaintext hljs">kprobe:vfs_read { @start[tid] = nsecs; } &lt;- 1 -&gt;&lt;-- 2 -&gt; &lt;---------- 3 ---------&gt;</code> </pre> <br>  Rastreamos o evento a partir do mecanismo <i>kprobe</i> , ou seja, rastreamos o in√≠cio da fun√ß√£o do kernel. <br>  A fun√ß√£o do kernel para rastreamento √© <i>vfs_read</i> , essa fun√ß√£o √© chamada quando o kernel executa uma opera√ß√£o de leitura do sistema de arquivos (VFS do ‚ÄúVirtual FileSystem‚Äù, abstra√ß√£o do sistema de arquivos dentro do kernel). <br><br>  Quando o <i>vfs_read</i> come√ßa a ser <i>executado</i> (ou seja, antes da fun√ß√£o <i>executar</i> qualquer trabalho √∫til), o programa bpftrace √© iniciado.  Ele salva o registro de data e hora atual (em nanossegundos) em um array associativo global chamado <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">st</a> art</i> .  A chave √© <i>tid</i> , uma refer√™ncia ao ID do encadeamento atual. <br><br><pre> <code class="plaintext hljs">kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); } &lt;-- 1 --&gt; &lt;-- 2 -&gt; &lt;---- 3 ----&gt; &lt;----------------------------- 4 -----------------------------&gt;</code> </pre> <br>  1. Rastreamos o evento a partir do mecanismo <i>kretprobe</i> , que √© semelhante ao <i>kprobe</i> , exceto que ele √© chamado quando a fun√ß√£o retorna o resultado de sua execu√ß√£o. <br><br>  2. A fun√ß√£o do kernel para rastreamento √© <i>vfs_read</i> . <br><br>  3. Este √© um filtro opcional.  Ele verifica se a hora de in√≠cio foi gravada anteriormente.  Sem esse filtro, o programa pode ser iniciado durante a leitura e capturar apenas o final, resultando em um tempo <i>estimado</i> de <i>nsecs - 0</i> , em vez de <i>nsecs - iniciar</i> . <br><br>  4. O corpo do programa. <br><br>  <i>nsecs - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">st</a> art [tid]</i> calcula quanto tempo se passou desde o in√≠cio da fun√ß√£o vfs_read. <br>  <i>@ns [comm] = hist (...)</i> adiciona os dados especificados ao histograma bidimensional armazenado em <i>@ns</i> .  A chave de <i>comunica√ß√£o</i> refere-se ao nome do aplicativo atual.  Portanto, teremos um histograma comando por comando. <br><br>  <i>delete (...)</i> exclui o hor√°rio de in√≠cio da matriz associativa, porque n√£o precisamos mais dele. <br><br>  Esta √© a conclus√£o final.  Observe que todos os histogramas s√£o exibidos automaticamente.  O uso expl√≠cito do comando imprimir histograma n√£o √© necess√°rio.  <i>@ns</i> n√£o √© uma vari√°vel especial; portanto, o histograma n√£o √© exibido por causa disso. <br><br><pre> <code class="plaintext hljs">@ns[snmp-pass]: [0, 1] 0 | | [2, 4) 0 | | [4, 8) 0 | | [8, 16) 0 | | [16, 32) 0 | | [32, 64) 0 | | [64, 128) 0 | | [128, 256) 0 | | [256, 512) 27 |@@@@@@@@@ | [512, 1k) 125 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ | [1k, 2k) 22 |@@@@@@@ | [2k, 4k) 1 | | [4k, 8k) 10 |@@@ | [8k, 16k) 1 | | [16k, 32k) 3 |@ | [32k, 64k) 144 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@| [64k, 128k) 7 |@@ | [128k, 256k) 28 |@@@@@@@@@@ | [256k, 512k) 2 | | [512k, 1M) 3 |@ | [1M, 2M) 1 | |</code> </pre> <br><br>  <b>Exemplo de sensor USDT</b> <br><br>  Vamos pegar esse c√≥digo C e salv√°-lo no arquivo <i>tracetest.c</i> : <br><br><pre> <code class="plaintext hljs">#include &lt;sys/sdt.h&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; static long myclock() { struct timeval tv; gettimeofday(&amp;tv, NULL); DTRACE_PROBE1(tracetest, testprobe, tv.tv_sec); return tv.tv_sec; } int main(int argc, char **argv) { while (1) { myclock(); sleep(1); } return 0; }</code> </pre> <br>  Este programa √© executado infinitamente chamando <i>myclock ()</i> uma vez por segundo.  <i>myclock ()</i> consulta a hora atual e retorna o n√∫mero de segundos desde o in√≠cio da era. <br><br>  A chamada para <i>DTRACE_PROBE1</i> aqui define um ponto de rastreamento USDT est√°tico. <br><br><ul><li>  A macro <i>DTRACE_PROBE1</i> √© obtida em <i>sys / sdt.h.</i>  A macro oficial do USDT, que faz o mesmo, √© chamada <i>STAP_PROBE1</i> (STAP do SystemTap, que foi o primeiro mecanismo Linux suportado no USDT).  Mas como o USDT √© compat√≠vel com os sensores de espa√ßo do usu√°rio do DTrace, o <i>DTRACE_PROBE1</i> √© apenas uma refer√™ncia ao <i>STAP_PROBE1</i> . </li><li>  O primeiro par√¢metro √© o nome do provedor.  Acredito que este √© um vest√≠gio que resta do DTrace, porque o bpftrace n√£o parece estar fazendo nada √∫til com ele.  No entanto, h√° uma nuance ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que eu descobri ao depurar o problema na solicita√ß√£o 328</a> ): o nome do provedor deve ser id√™ntico ao nome do arquivo bin√°rio do aplicativo, caso contr√°rio, o bpftrace n√£o conseguir√° encontrar o ponto de rastreamento. </li><li>  O segundo par√¢metro √© o nome do ponto de rastreamento. </li><li>  Quaisquer par√¢metros adicionais s√£o o contexto fornecido pelos desenvolvedores.  O n√∫mero <i>1</i> em <i>DTRACE_PROBE1</i> significa que queremos passar um par√¢metro adicional. </li></ul><br>  Vamos garantir que sys / sdt.h esteja dispon√≠vel para n√≥s e montar o programa: <br><br><pre> <code class="plaintext hljs">sudo apt install systemtap-sdt-dev gcc tracetest.c -o tracetest -Wall -g</code> </pre> <br>  Instru√≠mos o bpftrace a emitir o PID e "time is [number]" sempre que a <i>testprobe for</i> atingida: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/full-path-to/tracetest:testprobe { printf("%d: time is %d\n", pid, arg0); }'</code> </pre> <br>  O Bpftrace continua funcionando enquanto pressionamos Ctrl-C.  Portanto, abra um novo terminal e execute o teste mais <i>r√°pido</i> l√°: <br><br>  # No novo terminal <br>  ./tracetest <br><br>  Volte para o primeiro terminal com bpftrace, l√° voc√™ deve ver algo como: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... 30909: time is 1549023215 30909: time is 1549023216 30909: time is 1549023217 ... ^C</code> </pre> <br>  <b>Exemplo de aloca√ß√£o de mem√≥ria usando glibc ptmalloc</b> <br><br>  Eu uso o bpftrace para entender por que o Ruby usa tanta mem√≥ria.  E como parte de minha pesquisa, preciso entender como o alocador de mem√≥ria da glibc usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">regi√µes de mem√≥ria</a> . <br><br>  Para otimizar o desempenho de v√°rios n√∫cleos, o alocador de mem√≥ria glibc destaca v√°rias "√°reas" do sistema operacional.  Quando o aplicativo solicita aloca√ß√£o de mem√≥ria, o alocador seleciona uma √°rea que n√£o est√° em uso e marca parte dessa √°rea como "usada".  Como os encadeamentos usam √°reas diferentes, o n√∫mero de bloqueios √© reduzido, o que leva a um melhor desempenho multithread. <br><br>  Mas essa abordagem gera muito lixo e parece que um consumo de mem√≥ria t√£o alto no Ruby √© justamente por isso.  Para entender melhor a natureza desse lixo, pensei: o que significa ‚Äúescolher uma √°rea que n√£o √© usada‚Äù?  Isso pode significar um dos seguintes: <br><br><ul><li>  Cada vez que <i>malloc () √©</i> chamado, o alocador itera sobre todas as √°reas e localiza aquela que n√£o est√° bloqueada no momento.  E somente se todos estiverem bloqueados, ele tentar√° criar um novo. </li><li>  A primeira vez que <i>malloc () √©</i> chamado em um encadeamento espec√≠fico (ou quando o encadeamento √© iniciado), o alocador seleciona aquele que n√£o est√° bloqueado no momento.  E se todos estiverem bloqueados, ele tentar√° criar um novo. </li><li>  Na primeira vez em que <i>malloc () √©</i> chamado em um encadeamento espec√≠fico (ou quando o encadeamento √© iniciado), o alocador tenta criar uma nova regi√£o, independentemente de haver regi√µes desbloqueadas.  Somente se uma nova √°rea n√£o puder ser criada (por exemplo, quando o limite estiver esgotado), ela reutilizar√° a existente. </li><li>  Provavelmente existem mais op√ß√µes que eu n√£o considerei. </li></ul><br>  N√£o h√° resposta espec√≠fica na documenta√ß√£o, qual desses recursos permite selecionar uma √°rea que n√£o √© usada.  Estudei o c√≥digo fonte da glibc, que sugeriu a op√ß√£o 3.  Mas eu queria verificar experimentalmente que interpretei o c√≥digo fonte corretamente, sem a necessidade de depurar o c√≥digo no glibc. <br><br>  Aqui est√° a fun√ß√£o de alocador de mem√≥ria glibc que cria uma nova √°rea.  Mas voc√™ pode cham√°-lo somente depois de verificar o limite. <br><br><pre> <code class="plaintext hljs">static mstate _int_new_arena(size_t size) { mstate arena; size = calculate_how_much_memory_to_ask_from_os(size); arena = do_some_stuff_to_allocate_memory_from_os(); LIBC_PROBE(memory_arena_new, 2, arena, size); do_more_stuff(); return arena; }</code> </pre> <br>  Posso usar <i>uprobes</i> para rastrear a fun√ß√£o <i>_int_new_arena</i> ?  Infelizmente n√£o.  Por alguma raz√£o, este s√≠mbolo n√£o est√° dispon√≠vel no glibc Ubuntu 18.04.  Mesmo ap√≥s a instala√ß√£o dos s√≠mbolos de depura√ß√£o. <br><br>  Felizmente, existe um sensor USDT nesta fun√ß√£o.  <i>LIBC_PROBE</i> √© um alias de macro para <i>STAP_PROBE</i> . <br>  O nome do provedor √© libc. <br>  O nome do sensor √© memory_arena_new. <br>  O n√∫mero 2 significa que existem 2 argumentos adicionais especificados pelo desenvolvedor. <br>  arena √© o endere√ßo da √°rea que foi extra√≠da do sistema operacional e tamanho √© o seu tamanho. <br><br>  Antes de podermos usar esse sensor, precisamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contornar o problema 328</a> .  Precisamos criar um link simb√≥lico com glibc em algum lugar com o nome <i>libc</i> , porque o bpftrace espera que o nome da biblioteca (que de outra forma seria <i>libc-2.27.so</i> ) seja id√™ntico ao nome do provedor <i>(libc)</i> . <br><br><pre> <code class="plaintext hljs">ln -s /lib/x86_64-linux-gnu/libc-2.27.so /tmp/libc</code> </pre> <br>  Agora instru√≠mos o bpftrace a conectar o sensor USDT memory_arena_new, cujo nome do fornecedor √© <i>libc</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/tmp/libc:memory_arena_new { printf("PID %d: created new arena at %p, size %d\n", pid, arg0, arg1); }'</code> </pre> <br>  Em outro terminal, rodaremos o Ruby, que criar√° tr√™s threads que n√£o fazem nada e terminam em um segundo.  Devido ao bloqueio global do int√©rprete, Ruby <i>malloc ()</i> n√£o deve ser chamado em paralelo por threads diferentes. <br><br><pre> <code class="plaintext hljs">ruby -e '3.times { Thread.new { } }; sleep 1'</code> </pre> <br>  Voltando ao terminal com bpftrace, veremos: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... PID 431: created new arena at 0x7f40e8000020, size 576 PID 431: created new arena at 0x7f40e0000020, size 576 PID 431: created new arena at 0x7f40e4000020, size 576</code> </pre> <br>  Aqui est√° a resposta para a nossa pergunta!  Cada vez que voc√™ cria um novo thread no Ruby, a glibc destaca uma nova √°rea, independentemente da competitividade. <br><br>  <b>Quais pontos de rastreio est√£o dispon√≠veis?</b>  <b>O que devo rastrear?</b> <br><br>  Voc√™ pode listar todos os pontos de rastreio de hardware, timers, kprobe e est√°tico do kernel executando o comando: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l</code> </pre> <br>  Voc√™ pode listar todos os pontos de rastreio da verifica√ß√£o vertical (caracteres de fun√ß√£o) de um aplicativo ou biblioteca fazendo: <br><br><pre> <code class="plaintext hljs">nm /path-to-binary</code> </pre> <br>  Voc√™ pode listar todos os pontos de rastreio do aplicativo ou biblioteca USDT executando o seguinte comando: <br><br><pre> <code class="plaintext hljs">/usr/share/bcc/tools/tplist -l /path-to/binary</code> </pre> <br>  Com rela√ß√£o a quais pontos de rastreamento usar: n√£o faria mal entender o c√≥digo fonte do que voc√™ vai rastrear.  Eu recomendo que voc√™ estude o c√≥digo fonte. <br><br>  <b>Dica: um formato estrutural para pontos de rastreio no kernel</b> <br><br>  Aqui est√° uma dica √∫til sobre os pontos de rastreamento do kernel.  Voc√™ pode verificar quais campos de argumento est√£o dispon√≠veis lendo o arquivo / sys / kernel / debug / tracing / events! <br><br>  Por exemplo, suponha que voc√™ deseja rastrear chamadas para <i>madvise (..., MADV_DONTNEED)</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l | grep madvise</code> </pre> <br>  - nos dir√° que podemos usar o tracepoint: syscalls: sys_enter_madvise. <br><br><pre> <code class="plaintext hljs">sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_madvise/format</code> </pre> <br>  - nos fornecer√° as seguintes informa√ß√µes: <br><br><pre> <code class="plaintext hljs">name: sys_enter_madvise ID: 569 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:unsigned long start; offset:16; size:8; signed:0; field:size_t len_in; offset:24; size:8; signed:0; field:int behavior; offset:32; size:8; signed:0; print fmt: "start: 0x%08lx, len_in: 0x%08lx, behavior: 0x%08lx", ((unsigned long)(REC-&gt;start)), ((unsigned long)(REC-&gt;len_in)), ((unsigned long)(REC-&gt;behavior))</code> </pre> <br>  Assinatura Madvise de acordo com o manual: <i>(void * addr, size_t length, int conselho)</i> .  Os √∫ltimos tr√™s campos dessa estrutura correspondem a esses par√¢metros! <br><br>  Qual √© o significado de MADV_DONTNEED?  A julgar pelo grep MADV_DONTNEED / usr / include, √© igual a 4: <br><br><pre> <code class="plaintext hljs">/usr/include/x86_64-linux-gnu/bits/mman-linux.h:80:# define MADV_DONTNEED 4 /* Don't need these pages. */</code> </pre> <br>  Portanto, nossa equipe bpftrace se torna: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'tracepoint:syscalls:sys_enter_madvise /args-&gt;behavior == 4/ { printf("madvise DONTNEED called\n"); }'</code> </pre> <br><h3>  Conclus√£o </h3><br>  Bpftrace √© maravilhoso!  Bpftrace √© o futuro! <br><br>  Se voc√™ quiser saber mais sobre ele, recomendo que voc√™ se familiarize com <a href="">a lideran√ßa dele</a> , bem como com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro post de 2019</a> no blog de Brendan Gregg. <br><br>  Boa depura√ß√£o! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441258/">https://habr.com/ru/post/pt441258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441244/index.html">A vulnerabilidade do WinRar, fechada por 19 anos, permite colocar o arquivo descompactado em qualquer lugar</a></li>
<li><a href="../pt441248/index.html">A R√∫ssia ficou em 9¬∫ lugar na classifica√ß√£o SSL global, √† frente da China, Dinamarca e Su√≠√ßa</a></li>
<li><a href="../pt441250/index.html">In√≠cio r√°pido: Ir + Apache Kafka + Redis</a></li>
<li><a href="../pt441252/index.html">‚ÄúArtigo sobre boquete‚Äù: cientistas processaram 109 horas de sexo oral para desenvolver uma IA que suga um membro</a></li>
<li><a href="../pt441254/index.html">Semin√°rio ‚ÄúPor que entramos em contato com o Kubernetes e o que obtemos dele‚Äù, 28 de fevereiro de Moscou</a></li>
<li><a href="../pt441260/index.html">Como os gr√°ficos de rede neural ajudaram</a></li>
<li><a href="../pt441262/index.html">Tarefas simples e longas eliminam os candidatos melhor do que os curtos e complexos</a></li>
<li><a href="../pt441264/index.html">Guia do Usu√°rio Kibana. Visualiza√ß√£o. Parte 2</a></li>
<li><a href="../pt441266/index.html">Como o framework tiOPF para delphi / lazarus funciona. Modelo de visitante</a></li>
<li><a href="../pt441268/index.html">Testes de Ceedling + Eclipse ou de unidade para microcontroladores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>