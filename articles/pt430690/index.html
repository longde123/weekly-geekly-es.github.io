<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëãüèæ üåÖ ü•Å Exce√ß√µes determin√≠sticas e tratamento de erros em "C ++ do futuro" üö≤ üï∞Ô∏è üë©üèø‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√â estranho que em Habrt ainda n√£o tenha sido mencionada uma proposta clamorosa para o padr√£o C ++ chamada "Exce√ß√µes determin√≠sticas de sobrecarga zero...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exce√ß√µes determin√≠sticas e tratamento de erros em "C ++ do futuro"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430690/"><iframe width="560" height="315" src="https://www.youtube.com/embed/cbUTAoHy6Ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  √â estranho que em Habrt ainda n√£o tenha sido mencionada uma proposta clamorosa para o padr√£o C ++ chamada "Exce√ß√µes determin√≠sticas de sobrecarga zero".  Corrigindo essa omiss√£o irritante. </p><br><p>  Se voc√™ est√° preocupado com a sobrecarga de exce√ß√µes, ou teve que compilar o c√≥digo sem suporte a exce√ß√µes, ou apenas se perguntando o que acontecer√° com o tratamento de erros no C ++ 2b (uma refer√™ncia a uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publica√ß√£o recente</a> ), pe√ßo cat.  Voc√™ est√° esperando por um aperto de tudo o que agora pode ser encontrado sobre o t√≥pico, e algumas pesquisas. </p><a name="habracut"></a><br><p>  A discuss√£o abaixo ser√° conduzida n√£o apenas sobre exce√ß√µes est√°ticas, mas tamb√©m sobre propostas relacionadas ao padr√£o e sobre todas as outras formas de lidar com erros.  Se voc√™ foi aqui para olhar a sintaxe, aqui est√°: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_error::divide_by_zero; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> as_double(x) / y; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; safe_divide(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (arithmetic_error e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Se o tipo espec√≠fico de erro n√£o for importante / desconhecido, voc√™ poder√° simplesmente usar <code>throws</code> e <code>catch (std::error e)</code> . </p><br><h2 id="polezno-znat">  Bom saber </h2><br><h3 id="stdoptional-i-stdexpected">  <code>std::optional</code> e <code>std::expected</code> </h3><br><p>  Vamos decidir que o erro que possa surgir na fun√ß√£o n√£o seja "fatal" o suficiente para gerar uma exce√ß√£o a ela.  Tradicionalmente, as informa√ß√µes de erro s√£o retornadas usando um par√¢metro out.  Por exemplo, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filesystem TS</a> oferece v√°rios recursos semelhantes: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p, error_code&amp; ec);</code> </pre> <br><p>  (N√£o lance uma exce√ß√£o devido ao fato de o arquivo n√£o ter sido encontrado?) No entanto, o processamento do c√≥digo de erro √© complicado e propenso a erros.  √â f√°cil esquecer o c√≥digo de erro para verificar.  Os estilos de c√≥digo modernos <a href="">pro√≠bem o</a> uso de par√¢metros de sa√≠da; em vez disso, √© recomend√°vel retornar uma estrutura contendo o resultado inteiro. </p><br><p>  H√° algum tempo, o Boost oferece uma solu√ß√£o elegante para lidar com esses erros "n√£o fatais" que podem ocorrer em determinados cen√°rios no programa correto: </p><br><pre> <code class="cpp hljs">expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span>, error_code&gt; file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p);</code> </pre> <br><p>  O tipo <code>expected</code> √© semelhante √† <code>variant</code> , mas fornece uma interface conveniente para trabalhar com o "resultado" e o "erro".  Por padr√£o, o resultado <code>expected</code> √© armazenado no <code>expected</code> .  A implementa√ß√£o <code>file_size</code> pode ser algo como isto: </p><br><pre> <code class="cpp hljs">file_info* info = read_file_info(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info != null) { <span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> size = info-&gt;size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; <span class="hljs-comment"><span class="hljs-comment">// &lt;== } else { error_code error = get_error(); return std::unexpected(error); // &lt;== }</span></span></code> </pre> <br><p>  Se a causa do erro n√£o for interessante para n√≥s, ou o erro puder consistir apenas na "aus√™ncia" do resultado, o <code>optional</code> poder√° ser usado: </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; parse_int(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s); optional&lt;U&gt; get_or_null(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;T, U&gt; m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; key);</code> </pre> <br><p>  No C ++ 17 do Boost, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">opcional</a> chegou ao padr√£o (sem suporte para <code>optional&lt;T&amp;&gt;</code> );  em C ++ 20, eles podem adicionar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esperado</a> (essa √© apenas a proposta, obrigado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">RamzesXI</a> pela corre√ß√£o). </p><br><h3 id="contracts">  Contratos </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os contratos</a> (que n√£o devem ser confundidos com os conceitos) s√£o uma nova maneira de impor restri√ß√µes aos par√¢metros de fun√ß√£o, adicionados no C ++ 20.  3 anota√ß√µes adicionadas: </p><br><ul><li>  <strong>espera</strong> verifica√ß√µes de par√¢metros de fun√ß√£o </li><li>  <strong>garante a</strong> verifica√ß√£o do valor de retorno da fun√ß√£o (aceita como argumento) </li><li>  <strong>assert</strong> - um substituto civilizado para a macro assert </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> [[expects: i &lt; v.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">]]</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> [[expects: x &gt;</span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>]] [[ensures ret: ret &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-function"><span class="hljs-function">value </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;value&gt; result = fetch(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;key&gt;{e}); [[assert result.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Voc√™ pode configurar por quebra de contrato: </p><br><ul><li>  Comportamento Indefinido Chamado ou </li><li>  Ele verificou e chamou a sa√≠da do usu√°rio, ap√≥s o que <code>std::terminate</code> </li></ul><br><p>  √â imposs√≠vel continuar executando o programa ap√≥s a quebra do contrato, porque os compiladores usam garantias dos contratos para otimizar o c√≥digo de fun√ß√£o.  Se houver a menor d√∫vida de que o contrato ser√° cumprido, vale a pena adicionar uma verifica√ß√£o adicional. </p><br><h3 id="stderror_code">  std :: error_code </h3><br><p>  A biblioteca <code>&lt;system_error&gt;</code> , adicionada no C ++ 11, permite padronizar o tratamento de c√≥digos de erro no seu programa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">std :: error_code</a> consiste em um c√≥digo de erro do tipo <code>int</code> e um ponteiro para o objeto de alguma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe</a> descendente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">std :: error_category</a> .  Esse objeto, de fato, desempenha o papel de uma tabela de fun√ß√µes virtuais e determina o comportamento de um dado <code>std::error_code</code> . </p><br><p>  Para criar seu <code>std::error_code</code> , voc√™ deve definir sua <code>std::error_category</code> descendente <code>std::error_category</code> e implementar m√©todos virtuais, o mais importante dos quais √©: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Voc√™ tamb√©m deve criar uma vari√°vel global para sua <code>std::error_category</code> .  O tratamento de erros usando o error_code + esperado √© algo como isto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = expected&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code&gt;; my::<span class="hljs-function"><span class="hljs-function">file_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_internal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; error)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> -&gt; result&lt;my::file&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> raw_error = <span class="hljs-number"><span class="hljs-number">0</span></span>; my::file_handle maybe_result = open_internal(name, &amp;raw_error); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code error{raw_error, my::filesystem_error}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unexpected{error}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> my::file{maybe_result}; } }</code> </pre> <br><p>  √â importante que em <code>std::error_code</code> valor 0 signifique nenhum erro.  Se esse n√£o for o caso dos seus c√≥digos de erro, antes de converter o c√≥digo de erro do sistema em <code>std::error_code</code> , voc√™ deve substituir o c√≥digo 0 por SUCCESS e vice-versa. </p><br><p>  Todos os c√≥digos de erro do sistema s√£o descritos em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">errc</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">system_category</a> .  Se, em um certo est√°gio, o encaminhamento manual dos c√≥digos de erro se tornar muito sombrio, voc√™ poder√° sempre quebrar o c√≥digo de erro na <code>std::system_error</code> e jog√°-lo fora. </p><br><h3 id="destructive-move--trivially-relocatable">  Movimento destrutivo / Trivialmente reloc√°vel </h3><br><p>  Voc√™ precisa criar outra classe de objetos que possuam alguns recursos.  Provavelmente, voc√™ desejar√° torn√°-lo n√£o copi√°vel, mas m√≥vel, porque os objetos im√≥veis s√£o inconvenientes para trabalhar (antes do C ++ 17, eles n√£o podiam ser retornados de uma fun√ß√£o). </p><br><p>  Mas aqui est√° o problema: em qualquer caso, o objeto movido precisa ser exclu√≠do.  Portanto, √© necess√°rio um estado especial de "movido de", ou seja, um objeto "vazio" que n√£o exclui nada.  Acontece que cada classe C ++ deve ter um estado vazio, ou seja, √© imposs√≠vel criar uma classe com uma invariante (garantia) de corre√ß√£o, do construtor ao destruidor.  Por exemplo, n√£o √© poss√≠vel criar a classe <code>open_file</code> correta de um arquivo aberto durante toda a sua vida √∫til.  √â estranho observar isso em um dos poucos idiomas que usam ativamente o RAII. </p><br><p>  Outro problema √© o zeramento de objetos antigos quando a movimenta√ß√£o adiciona uma sobrecarga: o preenchimento de <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> pode ser at√© duas vezes mais lento que <code>std::vector&lt;T*&gt;</code> devido ao monte de zeragem de ponteiros antigos ao se mover , seguido pela remo√ß√£o de manequins. </p><br><p>  Os desenvolvedores de C ++ h√° muito tempo lambiam o Rust, onde os destruidores n√£o s√£o chamados em objetos realocados.  Esse recurso √© chamado de movimento destrutivo.  Infelizmente, a proposta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trivially relocatable</a> n√£o oferece para adicion√°-lo ao C ++.  Mas o problema de sobrecarga ser√° resolvido. </p><br><p>  Uma classe √© considerada reloc√°vel de maneira trivial se duas opera√ß√µes: mover e excluir o objeto antigo forem equivalentes a memcpy do objeto antigo para o novo.  O objeto antigo n√£o √© exclu√≠do, os autores chamam de "solte-o no ch√£o". </p><br><p>  Um tipo √© Trivialmente reloc√°vel do ponto de vista do compilador se uma das seguintes condi√ß√µes (recursivas) for verdadeira: </p><br><ol><li>  √â trivialmente m√≥vel + trivialmente destrut√≠vel (por exemplo, estrutura <code>int</code> ou POD) </li><li>  Esta √© a classe marcada com o atributo <code>[[trivially_relocatable]]</code> </li><li>  Esta √© uma classe da qual todos os membros s√£o trivialmente reloc√°veis. </li></ol><br><p>  Voc√™ pode usar essas informa√ß√µes com <code>std::uninitialized_relocate</code> , que executa o movimento init + delete da maneira usual ou acelerado, se poss√≠vel.  Sugere-se marcar como <code>[[trivially_relocatable]]</code> maioria dos tipos de biblioteca padr√£o, incluindo <code>std::string</code> , <code>std::vector</code> , <code>std::unique_ptr</code> .  Overhead <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> com isso em mente A proposta desaparecer√°. </p><br><h2 id="chto-ne-tak-s-isklyucheniyami-seychas">  O que h√° de errado com exce√ß√µes agora? </h2><br><p>  O mecanismo de exce√ß√£o C ++ foi desenvolvido em 1992.  V√°rias op√ß√µes de implementa√ß√£o foram propostas.  Desses, foi selecionado um mecanismo de tabela de exce√ß√£o que garante a aus√™ncia de uma sobrecarga para o caminho principal da execu√ß√£o do programa.  Porque, desde o momento de sua cria√ß√£o, assumiu-se que <em>exce√ß√µes deveriam ser lan√ßadas muito raramente</em> . </p><br><p>  Desvantagens de exce√ß√µes din√¢micas (ou seja, regulares): </p><br><ol><li>  No caso da exce√ß√£o lan√ßada, a sobrecarga √© em m√©dia de 10.000 a 100.000 ciclos de CPU e, na pior das hip√≥teses, pode atingir a ordem de milissegundos </li><li>  Tamanho do arquivo bin√°rio aumentado em 15-38% </li><li>  Incompatibilidade com a interface de programa√ß√£o C </li><li>  Exce√ß√£o impl√≠cita ao suporte em todas as fun√ß√µes, exceto <code>noexcept</code> .  Uma exce√ß√£o pode ser lan√ßada quase em qualquer lugar do programa, mesmo quando o autor da fun√ß√£o n√£o espera. </li></ol><br><p>  Devido a essas defici√™ncias, o escopo das exce√ß√µes √© significativamente limitado.  Quando as exce√ß√µes n√£o podem ser aplicadas: </p><br><ol><li>  Onde o determinismo √© importante, ou seja, onde √© inaceit√°vel que o c√≥digo "√†s vezes" funcione 10, 100, 1000 vezes mais lento que o normal </li><li>  Quando eles n√£o s√£o suportados na ABI, por exemplo, em microcontroladores </li><li>  Quando grande parte do c√≥digo √© escrita em C </li><li>  Em empresas com uma grande carga de c√≥digo legado ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google Style Guide</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Qt</a> ).  Se houver pelo menos uma fun√ß√£o n√£o protegida por exce√ß√£o no c√≥digo, de acordo com a lei da maldade, uma exce√ß√£o ser√° lan√ßada mais cedo ou mais tarde e criar√° um bug </li><li>  Nas empresas que contratam programadores que n√£o t√™m id√©ia sobre seguran√ßa de exce√ß√£o </li></ol><br><p>  Segundo pesquisas, nos locais de trabalho de 52% (!) Desenvolvedores, as exce√ß√µes s√£o proibidas pelas regras corporativas. </p><br><p>  Mas as exce√ß√µes s√£o parte integrante do C ++!  Ao incluir o <code>-fno-exceptions</code> , os desenvolvedores perdem a capacidade de usar uma parte significativa da biblioteca padr√£o.  Isso incita ainda mais as empresas a plantar suas pr√≥prias "bibliotecas padr√£o" e, sim, inventar sua pr√≥pria classe de cadeias. </p><br><p>  Mas este n√£o √© o fim.  Exce√ß√µes s√£o a √∫nica maneira padr√£o de cancelar a cria√ß√£o de um objeto no construtor e gerar um erro.  Quando desativados, uma abomina√ß√£o, como a inicializa√ß√£o em duas fases, √© exibida.  Os operadores tamb√©m n√£o podem usar c√≥digos de erro; portanto, eles s√£o substitu√≠dos por fun√ß√µes como <code>assign</code> . </p><br><h2 id="proposal-isklyucheniya-buduschego">  Proposta: exce√ß√µes do futuro </h2><br><h3 id="novyy-mehanizm-peredachi-isklyucheniy">  Novo mecanismo de transfer√™ncia de exce√ß√£o </h3><br><p>  Herb Sutter em P709 descreveu um novo mecanismo de transfer√™ncia de exce√ß√µes.  Em princ√≠pio, a fun√ß√£o retorna <code>std::expected</code> , no entanto, em vez de um discriminador separado do tipo <code>bool</code> , que junto com o alinhamento ocupar√° at√© 8 bytes na pilha, essa informa√ß√£o √© transmitida de maneira mais r√°pida, por exemplo, para Carry Flag. </p><br><p>  As fun√ß√µes que n√£o tocam em CF (a maioria) ter√£o a oportunidade de usar exce√ß√µes est√°ticas gratuitamente - tanto no caso de um retorno normal quanto no caso de lan√ßar uma exce√ß√£o!  As fun√ß√µes for√ßadas a salv√°-lo e restaur√°-lo receber√£o uma sobrecarga m√≠nima e ainda ser√£o mais r√°pidas que o <code>std::expected</code> e qualquer c√≥digo de erro comum. </p><br><p>  As exce√ß√µes est√°ticas s√£o assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::divide_by_zero; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == INT_MIN &amp;&amp; j == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::integer_divide_overflows; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i / j; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i + safe_divide(j, k); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; foo(i, j, k); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (erithmetic_errc e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Na vers√£o alternativa, prop√µe-se obrigar a palavra-chave <code>try</code> na mesma express√£o que a chamada da fun√ß√£o <code>throws</code> : <code>try i + safe_divide(j, k)</code> .  Isso reduzir√° o n√∫mero de casos de uso de fun√ß√µes <code>throws</code> no c√≥digo que n√£o √© seguro para exce√ß√µes quase zero.  De qualquer forma, diferentemente das exce√ß√µes din√¢micas, o IDE poder√°, de alguma forma, destacar express√µes que geram exce√ß√µes. </p><br><p>  O fato de a exce√ß√£o lan√ßada n√£o ser armazenada separadamente, mas ser colocada diretamente no lugar do valor retornado, imp√µe restri√ß√µes ao tipo de exce√ß√£o.  Primeiro, ele deve ser trivialmente realoc√°vel.  Em segundo lugar, seu tamanho n√£o deve ser muito grande (mas pode ser algo como <code>std::unique_ptr</code> ), caso contr√°rio, todas as fun√ß√µes reservar√£o mais espa√ßo na pilha. </p><br><h3 id="status_code">  status_code </h3><br><p>  A biblioteca <code>&lt;system_error2&gt;</code> , desenvolvida por Niall Douglas, conter√° <code>status_code&lt;T&gt;</code> - "novo, melhor" <code>error_code</code> .  As principais diferen√ßas de <code>error_code</code> : </p><br><ol><li>  <code>status_code</code> - um tipo de modelo que pode ser usado para armazenar quase todos os c√≥digos de erro conceb√≠veis (junto com um ponteiro para <code>status_code_category</code> ), sem usar exce√ß√µes est√°ticas </li><li>  <code>T</code> deve ser trivialmente reloc√°vel e copi√°vel (este √∫ltimo, IMHO, n√£o deve ser obrigat√≥rio).  Ao copiar e excluir, as fun√ß√µes virtuais s√£o chamadas de <code>status_code_category</code> </li><li>  <code>status_code</code> pode armazenar n√£o apenas dados de erro, mas tamb√©m informa√ß√µes adicionais sobre uma opera√ß√£o conclu√≠da com √™xito </li><li>  A fun√ß√£o "virtual" <code>code.message()</code> n√£o retorna <code>std::string</code> , mas <code>string_ref</code> √© um tipo de string bastante pesado, que √© um <code>std::string_view</code> "possivelmente propriet√°rio" <code>std::string_view</code> .  L√° voc√™ pode <code>string_view</code> ou <code>string</code> , ou <code>std::shared_ptr&lt;string&gt;</code> , ou alguma outra maneira maluca de possuir uma string.  Niall afirma que <code>#include &lt;string&gt;</code> tornaria o cabe√ßalho <code>&lt;system_error2&gt;</code> inaceitavelmente "pesado" </li></ol><br><p>  Em seguida, <code>errored_status_code&lt;T&gt;</code> √© inserido - um wrapper sobre <code>status_code&lt;T&gt;</code> com o seguinte construtor: </p><br><pre> <code class="cpp hljs">errored_status_code(status_code&lt;T&gt;&amp;&amp; code) [[expects: code.failure() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>]] : code_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(code)) {}</code> </pre> <br><h3 id="error">  erro </h3><br><p>  O tipo de exce√ß√£o padr√£o ( <code>throws</code> sem tipo), bem como o tipo b√°sico de exce√ß√µes para as quais todas as outras s√£o convertidas (como <code>std::exception</code> ), √© <code>error</code> .  √â definido algo como isto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> error = errored_status_code&lt;<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span>&gt;;</code> </pre> <br><p>  Ou seja, <code>error</code> √© um <code>status_code</code> "erro", no qual o valor ( <code>value</code> ) √© colocado em 1 ponteiro.  Como o mecanismo <code>status_code_category</code> garante exclus√£o, movimento e c√≥pia corretos, teoricamente, qualquer estrutura de dados pode ser salva por <code>error</code> .  Na pr√°tica, esta ser√° uma das seguintes op√ß√µes: </p><br><ol><li>  Inteiros (int) </li><li>  <code>std::exception_handle</code> , ou seja, um ponteiro para uma exce√ß√£o din√¢mica lan√ßada </li><li>  <code>status_code_ptr</code> , ou seja, <code>unique_ptr</code> para um <code>status_code&lt;T&gt;</code> arbitr√°rio <code>status_code&lt;T&gt;</code> . </li></ol><br><p>  O problema √© que o caso 3 n√£o est√° planejado para dar a oportunidade de retornar o <code>error</code> ao <code>status_code&lt;T&gt;</code> .  A √∫nica coisa que voc√™ pode fazer √© obter a <code>message()</code> <code>status_code&lt;T&gt;</code> compactado <code>status_code&lt;T&gt;</code> .  Para poder recuperar o valor novamente em <code>error</code> , ative-o como uma exce√ß√£o din√¢mica (!). Em seguida, pegue e envolva-o em <code>error</code> .  Em geral, Niall acredita que apenas c√≥digos de erro e mensagens de string devem ser armazenados com <code>error</code> , o que √© suficiente para qualquer programa. </p><br><p>  Para distinguir entre diferentes tipos de erros, prop√µe-se usar o operador de compara√ß√£o "virtual": </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { open_file(name); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == filesystem_error::already_exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> my_exception(<span class="hljs-string"><span class="hljs-string">"Unknown filesystem error, unable to continue"</span></span>); } }</code> </pre> <br><p>  O uso de v√°rios blocos catch ou <code>dynamic_cast</code> para selecionar o tipo de exce√ß√£o falhar√°! </p><br><h3 id="vzaimodeystvie-s-dinamicheskimi-isklyucheniyami">  Intera√ß√£o com exce√ß√µes din√¢micas </h3><br><p>  Uma fun√ß√£o pode ter uma das seguintes especifica√ß√µes: </p><br><ul><li>  <code>noexcept</code> : n√£o lan√ßa exce√ß√µes </li><li>  <code>throws(E)</code> : lan√ßa apenas exce√ß√µes est√°ticas </li><li>  (nada): lan√ßa apenas exce√ß√µes din√¢micas </li></ul><br><p>  <code>throws</code> implica <code>noexcept</code> .  Se uma exce√ß√£o din√¢mica √© lan√ßada a partir de uma fun√ß√£o "est√°tica", √© envolto em <code>error</code> .  Se uma exce√ß√£o est√°tica for lan√ßada de uma fun√ß√£o "din√¢mica", ela ser√° <code>status_error</code> em uma exce√ß√£o <code>status_error</code> .  Um exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> erithmetic_errc::divide_by_zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> throws </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  arithmetic_errc   intptr_t //     error foo(); } void baz() { // error    status_error bar(); } void qux() throws { // error    status_error baz(); }</span></span></code> </pre> <br><h3 id="isklyucheniya-v-c">  Exce√ß√µes em C ?! </h3><br><p>  A proposta prev√™ a adi√ß√£o de exce√ß√µes a um dos futuros padr√µes C, e essas exce√ß√µes ser√£o compat√≠veis com ABI com exce√ß√µes est√°ticas em C ++.  Uma estrutura semelhante ao <code>std::expected&lt;T, U&gt;</code> , o usu√°rio precisar√° declarar independentemente, embora a redund√¢ncia possa ser removida usando macros.  A sintaxe consiste em (por simplicidade, assumiremos isso) as palavras-chave falham, falham, capturam. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / x; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> failure(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expected_int_float</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> error; }; <span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span> failed; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expected_int_float result = <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(invert(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.failed) { print_error(result.error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } print_success(result.value); }</code> </pre> <br><p>  Ao mesmo tempo, em C ++ tamb√©m ser√° poss√≠vel chamar fun√ß√µes de <code>fails</code> de C, declarando-as em blocos <code>extern C</code> .  Assim, em C ++, haver√° toda uma gal√°xia de palavras-chave para trabalhar com exce√ß√µes: </p><br><ul><li>  <code>throw()</code> - removido em C ++ 20 </li><li>  <code>noexcept</code> - especificador de fun√ß√£o, a fun√ß√£o n√£o lan√ßa exce√ß√µes din√¢micas </li><li>  <code>noexcept(expression)</code> - especificador de fun√ß√£o, a fun√ß√£o n√£o lan√ßa exce√ß√µes din√¢micas fornecidas </li><li>  <code>noexcept(expression)</code> - Uma express√£o <code>noexcept(expression)</code> exce√ß√µes din√¢micas? </li><li>  <code>throws(E)</code> - especificador de fun√ß√£o, a fun√ß√£o lan√ßa exce√ß√µes est√°ticas </li><li>  <code>throws</code> = <code>throws(std::error)</code> </li><li>  <code>fails(E)</code> - uma fun√ß√£o importada de C lan√ßa exce√ß√µes est√°ticas </li></ul><br><p>  Assim, em C ++ eles trouxeram (ou melhor, entregaram) um carrinho de novas ferramentas para tratamento de erros.  Em seguida, surge uma pergunta l√≥gica: </p><br><h2 id="kogda-chto-ispolzovat">  Quando usar o que? </h2><br><h3 id="napravlenie-v-celom">  Dire√ß√£o geral </h3><br><p>  Os erros s√£o divididos em v√°rios n√≠veis: </p><br><ul><li>  Erros do programador.  Processado usando contratos.  Eles levam √† coleta de logs e ao encerramento do programa, de acordo com o conceito de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fail-fast</a> .  Exemplos: ponteiro nulo (quando isso √© inv√°lido);  divis√£o por zero;  erros de aloca√ß√£o de mem√≥ria n√£o previstos pelo programador. </li><li>  Erros fatais fornecidos pelo programador.  Jogado fora um milh√£o de vezes menos que o retorno normal de uma fun√ß√£o, o que justifica o uso de exce√ß√µes din√¢micas.  Normalmente, nesses casos, voc√™ precisa reiniciar todo o subsistema do programa ou cometer um erro ao executar a opera√ß√£o.  Exemplos: perda repentina da conex√£o com o banco de dados;  erros de aloca√ß√£o de mem√≥ria fornecidos pelo programador. </li><li>  Erros recuper√°veis ‚Äã‚Äãquando <em>algo</em> impedia a fun√ß√£o de concluir sua tarefa, mas a fun√ß√£o de chamada pode saber o que fazer com ela.  Manipulado por exce√ß√µes est√°ticas.  Exemplos: trabalhe com o sistema de arquivos;  outros erros de entrada / sa√≠da (IO);  Dados incorretos do usu√°rio  <code>vector::at()</code> . </li><li>  A fun√ß√£o concluiu com √™xito sua tarefa, embora com um resultado inesperado.  <code>std::optional</code> , <code>std::expected</code> , <code>std::variant</code> .  Exemplos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>stoi()</code></a> ;  <code>vector::find()</code> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>map::insert</code></a> . </li></ul><br><p>  Na biblioteca padr√£o, √© mais confi√°vel abandonar completamente o uso de exce√ß√µes din√¢micas para tornar legal a compila√ß√£o "sem exce√ß√µes". </p><br><h3 id="errno">  errno </h3><br><p>  As fun√ß√µes que usam <code>errno</code> para trabalhar r√°pida e facilmente com os c√≥digos de erro C e C ++ devem ser substitu√≠das por <code>throws(std::errc)</code> <code>fails(int)</code> e <code>throws(std::errc)</code> , respectivamente.  Por algum tempo, as vers√µes antiga e nova das fun√ß√µes da biblioteca padr√£o coexistir√£o, e a antiga ser√° declarada obsoleta. </p><br><h3 id="out-of-memory">  Falta de mem√≥ria </h3><br><p>  Os erros de aloca√ß√£o de mem√≥ria s√£o manipulados pelo gancho global <code>new_handler</code> , que pode: </p><br><ol><li>  Elimine a falta de mem√≥ria e continue a execu√ß√£o </li><li>  Lan√ßar uma exce√ß√£o </li><li>  Programa de falha </li></ol><br><p>  Agora <code>std::bad_alloc</code> lan√ßado por padr√£o.  √â recomend√°vel chamar <code>std::terminate()</code> por padr√£o.  Se voc√™ precisar do comportamento antigo, substitua o manipulador pelo que voc√™ precisa no in√≠cio de <code>main()</code> . </p><br><p>  Todas as fun√ß√µes existentes da biblioteca padr√£o n√£o ser√£o <code>noexcept</code> e <code>noexcept</code> o programa quando <code>std::bad_alloc</code> .  Ao mesmo tempo, novas APIs como <code>vector::try_push_back</code> ser√£o adicionadas, o que permite erros de aloca√ß√£o de mem√≥ria. </p><br><h3 id="logic_error"> <code>logic_error</code> </h3> <br><p>  Exce√ß√µes <code>std::logic_error</code> , <code>std::domain_error</code> , <code>std::invalid_argument</code> , <code>std::length_error</code> , <code>std::out_of_range</code> , <code>std::future_error</code> reportam uma viola√ß√£o de uma pr√©-condi√ß√£o de fun√ß√£o.  O novo modelo de erro deve usar contratos.  Os tipos de exce√ß√µes listados <strong>n√£o</strong> ser√£o preteridos, mas quase todos os casos de uso na biblioteca padr√£o ser√£o substitu√≠dos por <code>[[expects: ‚Ä¶]]</code> . </p><br><h2 id="tekuschee-sostoyanie-proposal">  Status atual da proposta </h2><br><p>  A proposta est√° agora em um estado de rascunho.  Ele j√° mudou bastante e ainda pode mudar muito.  Como alguns desenvolvimentos n√£o conseguiram ser publicados, a API proposta <code>&lt;system_error2&gt;</code> n√£o <code>&lt;system_error2&gt;</code> totalmente relevante. </p><br><p>  A proposta est√° descrita em 3 documentos: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P709</a> - documento original do bras√£o de armas da Sutter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1095</a> - Exce√ß√µes determinadas na vis√£o de Niall Douglas, alguns momentos alterados, compatibilidade de idioma C adicionada </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1028</a> - API da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementa√ß√£o de teste de</a> <code>std::error</code> </li></ol><br><p>  Atualmente, n√£o h√° compilador que suporte exce√ß√µes est√°ticas.  Portanto, ainda n√£o √© poss√≠vel fazer seus benchmarks. </p><br><p>           C++23.   , , ,   C++26,    ,  ,  . </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>            ,     ,     .    ,            .   . </p><br><p>  ,   ^^ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430690/">https://habr.com/ru/post/pt430690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430680/index.html">Escrevendo um processador e ambiente simples para ele</a></li>
<li><a href="../pt430682/index.html">Tr√™s anos do projeto de microssat√©lites lunares: est√°gios de crescimento</a></li>
<li><a href="../pt430684/index.html">Digitaliza√ß√£o de contratos do Ethereum ao vivo para erro de envio n√£o verificado. Parte 2</a></li>
<li><a href="../pt430686/index.html">Vis√£o geral: a primeira m√°quina de corte a jato de √°gua da WAZER</a></li>
<li><a href="../pt430688/index.html">Transfer√™ncia de dados via QR animado para Gomobile e GopherJS</a></li>
<li><a href="../pt430692/index.html">Engenharia social com software Universal Windows Platform (APPX)</a></li>
<li><a href="../pt430694/index.html">Um pequeno guia para aprender C ++: o que, quando e sobre o que criar</a></li>
<li><a href="../pt430700/index.html">Um sistema unificado para gravar visualiza√ß√µes de filmes on-line come√ßar√° a funcionar na R√∫ssia</a></li>
<li><a href="../pt430702/index.html">Treinamento muito estranho</a></li>
<li><a href="../pt430704/index.html">Como as tecnologias de intelig√™ncia artificial ajudam a Aviasales a crescer: sete exemplos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>