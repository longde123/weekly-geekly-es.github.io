<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋🏾 🌅 🥁 Exceções determinísticas e tratamento de erros em "C ++ do futuro" 🚲 🕰️ 👩🏿‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="É estranho que em Habrt ainda não tenha sido mencionada uma proposta clamorosa para o padrão C ++ chamada "Exceções determinísticas de sobrecarga zero...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exceções determinísticas e tratamento de erros em "C ++ do futuro"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430690/"><iframe width="560" height="315" src="https://www.youtube.com/embed/cbUTAoHy6Ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  É estranho que em Habrt ainda não tenha sido mencionada uma proposta clamorosa para o padrão C ++ chamada "Exceções determinísticas de sobrecarga zero".  Corrigindo essa omissão irritante. </p><br><p>  Se você está preocupado com a sobrecarga de exceções, ou teve que compilar o código sem suporte a exceções, ou apenas se perguntando o que acontecerá com o tratamento de erros no C ++ 2b (uma referência a uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publicação recente</a> ), peço cat.  Você está esperando por um aperto de tudo o que agora pode ser encontrado sobre o tópico, e algumas pesquisas. </p><a name="habracut"></a><br><p>  A discussão abaixo será conduzida não apenas sobre exceções estáticas, mas também sobre propostas relacionadas ao padrão e sobre todas as outras formas de lidar com erros.  Se você foi aqui para olhar a sintaxe, aqui está: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_error::divide_by_zero; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> as_double(x) / y; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; safe_divide(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (arithmetic_error e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Se o tipo específico de erro não for importante / desconhecido, você poderá simplesmente usar <code>throws</code> e <code>catch (std::error e)</code> . </p><br><h2 id="polezno-znat">  Bom saber </h2><br><h3 id="stdoptional-i-stdexpected">  <code>std::optional</code> e <code>std::expected</code> </h3><br><p>  Vamos decidir que o erro que possa surgir na função não seja "fatal" o suficiente para gerar uma exceção a ela.  Tradicionalmente, as informações de erro são retornadas usando um parâmetro out.  Por exemplo, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filesystem TS</a> oferece vários recursos semelhantes: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p, error_code&amp; ec);</code> </pre> <br><p>  (Não lance uma exceção devido ao fato de o arquivo não ter sido encontrado?) No entanto, o processamento do código de erro é complicado e propenso a erros.  É fácil esquecer o código de erro para verificar.  Os estilos de código modernos <a href="">proíbem o</a> uso de parâmetros de saída; em vez disso, é recomendável retornar uma estrutura contendo o resultado inteiro. </p><br><p>  Há algum tempo, o Boost oferece uma solução elegante para lidar com esses erros "não fatais" que podem ocorrer em determinados cenários no programa correto: </p><br><pre> <code class="cpp hljs">expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span>, error_code&gt; file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p);</code> </pre> <br><p>  O tipo <code>expected</code> é semelhante à <code>variant</code> , mas fornece uma interface conveniente para trabalhar com o "resultado" e o "erro".  Por padrão, o resultado <code>expected</code> é armazenado no <code>expected</code> .  A implementação <code>file_size</code> pode ser algo como isto: </p><br><pre> <code class="cpp hljs">file_info* info = read_file_info(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info != null) { <span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> size = info-&gt;size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; <span class="hljs-comment"><span class="hljs-comment">// &lt;== } else { error_code error = get_error(); return std::unexpected(error); // &lt;== }</span></span></code> </pre> <br><p>  Se a causa do erro não for interessante para nós, ou o erro puder consistir apenas na "ausência" do resultado, o <code>optional</code> poderá ser usado: </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; parse_int(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s); optional&lt;U&gt; get_or_null(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;T, U&gt; m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; key);</code> </pre> <br><p>  No C ++ 17 do Boost, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">opcional</a> chegou ao padrão (sem suporte para <code>optional&lt;T&amp;&gt;</code> );  em C ++ 20, eles podem adicionar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esperado</a> (essa é apenas a proposta, obrigado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">RamzesXI</a> pela correção). </p><br><h3 id="contracts">  Contratos </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os contratos</a> (que não devem ser confundidos com os conceitos) são uma nova maneira de impor restrições aos parâmetros de função, adicionados no C ++ 20.  3 anotações adicionadas: </p><br><ul><li>  <strong>espera</strong> verificações de parâmetros de função </li><li>  <strong>garante a</strong> verificação do valor de retorno da função (aceita como argumento) </li><li>  <strong>assert</strong> - um substituto civilizado para a macro assert </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> [[expects: i &lt; v.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">]]</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> [[expects: x &gt;</span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>]] [[ensures ret: ret &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-function"><span class="hljs-function">value </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;value&gt; result = fetch(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;key&gt;{e}); [[assert result.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Você pode configurar por quebra de contrato: </p><br><ul><li>  Comportamento Indefinido Chamado ou </li><li>  Ele verificou e chamou a saída do usuário, após o que <code>std::terminate</code> </li></ul><br><p>  É impossível continuar executando o programa após a quebra do contrato, porque os compiladores usam garantias dos contratos para otimizar o código de função.  Se houver a menor dúvida de que o contrato será cumprido, vale a pena adicionar uma verificação adicional. </p><br><h3 id="stderror_code">  std :: error_code </h3><br><p>  A biblioteca <code>&lt;system_error&gt;</code> , adicionada no C ++ 11, permite padronizar o tratamento de códigos de erro no seu programa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">std :: error_code</a> consiste em um código de erro do tipo <code>int</code> e um ponteiro para o objeto de alguma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe</a> descendente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">std :: error_category</a> .  Esse objeto, de fato, desempenha o papel de uma tabela de funções virtuais e determina o comportamento de um dado <code>std::error_code</code> . </p><br><p>  Para criar seu <code>std::error_code</code> , você deve definir sua <code>std::error_category</code> descendente <code>std::error_category</code> e implementar métodos virtuais, o mais importante dos quais é: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Você também deve criar uma variável global para sua <code>std::error_category</code> .  O tratamento de erros usando o error_code + esperado é algo como isto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = expected&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code&gt;; my::<span class="hljs-function"><span class="hljs-function">file_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_internal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; error)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> -&gt; result&lt;my::file&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> raw_error = <span class="hljs-number"><span class="hljs-number">0</span></span>; my::file_handle maybe_result = open_internal(name, &amp;raw_error); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code error{raw_error, my::filesystem_error}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unexpected{error}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> my::file{maybe_result}; } }</code> </pre> <br><p>  É importante que em <code>std::error_code</code> valor 0 signifique nenhum erro.  Se esse não for o caso dos seus códigos de erro, antes de converter o código de erro do sistema em <code>std::error_code</code> , você deve substituir o código 0 por SUCCESS e vice-versa. </p><br><p>  Todos os códigos de erro do sistema são descritos em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">errc</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">system_category</a> .  Se, em um certo estágio, o encaminhamento manual dos códigos de erro se tornar muito sombrio, você poderá sempre quebrar o código de erro na <code>std::system_error</code> e jogá-lo fora. </p><br><h3 id="destructive-move--trivially-relocatable">  Movimento destrutivo / Trivialmente relocável </h3><br><p>  Você precisa criar outra classe de objetos que possuam alguns recursos.  Provavelmente, você desejará torná-lo não copiável, mas móvel, porque os objetos imóveis são inconvenientes para trabalhar (antes do C ++ 17, eles não podiam ser retornados de uma função). </p><br><p>  Mas aqui está o problema: em qualquer caso, o objeto movido precisa ser excluído.  Portanto, é necessário um estado especial de "movido de", ou seja, um objeto "vazio" que não exclui nada.  Acontece que cada classe C ++ deve ter um estado vazio, ou seja, é impossível criar uma classe com uma invariante (garantia) de correção, do construtor ao destruidor.  Por exemplo, não é possível criar a classe <code>open_file</code> correta de um arquivo aberto durante toda a sua vida útil.  É estranho observar isso em um dos poucos idiomas que usam ativamente o RAII. </p><br><p>  Outro problema é o zeramento de objetos antigos quando a movimentação adiciona uma sobrecarga: o preenchimento de <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> pode ser até duas vezes mais lento que <code>std::vector&lt;T*&gt;</code> devido ao monte de zeragem de ponteiros antigos ao se mover , seguido pela remoção de manequins. </p><br><p>  Os desenvolvedores de C ++ há muito tempo lambiam o Rust, onde os destruidores não são chamados em objetos realocados.  Esse recurso é chamado de movimento destrutivo.  Infelizmente, a proposta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trivially relocatable</a> não oferece para adicioná-lo ao C ++.  Mas o problema de sobrecarga será resolvido. </p><br><p>  Uma classe é considerada relocável de maneira trivial se duas operações: mover e excluir o objeto antigo forem equivalentes a memcpy do objeto antigo para o novo.  O objeto antigo não é excluído, os autores chamam de "solte-o no chão". </p><br><p>  Um tipo é Trivialmente relocável do ponto de vista do compilador se uma das seguintes condições (recursivas) for verdadeira: </p><br><ol><li>  É trivialmente móvel + trivialmente destrutível (por exemplo, estrutura <code>int</code> ou POD) </li><li>  Esta é a classe marcada com o atributo <code>[[trivially_relocatable]]</code> </li><li>  Esta é uma classe da qual todos os membros são trivialmente relocáveis. </li></ol><br><p>  Você pode usar essas informações com <code>std::uninitialized_relocate</code> , que executa o movimento init + delete da maneira usual ou acelerado, se possível.  Sugere-se marcar como <code>[[trivially_relocatable]]</code> maioria dos tipos de biblioteca padrão, incluindo <code>std::string</code> , <code>std::vector</code> , <code>std::unique_ptr</code> .  Overhead <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> com isso em mente A proposta desaparecerá. </p><br><h2 id="chto-ne-tak-s-isklyucheniyami-seychas">  O que há de errado com exceções agora? </h2><br><p>  O mecanismo de exceção C ++ foi desenvolvido em 1992.  Várias opções de implementação foram propostas.  Desses, foi selecionado um mecanismo de tabela de exceção que garante a ausência de uma sobrecarga para o caminho principal da execução do programa.  Porque, desde o momento de sua criação, assumiu-se que <em>exceções deveriam ser lançadas muito raramente</em> . </p><br><p>  Desvantagens de exceções dinâmicas (ou seja, regulares): </p><br><ol><li>  No caso da exceção lançada, a sobrecarga é em média de 10.000 a 100.000 ciclos de CPU e, na pior das hipóteses, pode atingir a ordem de milissegundos </li><li>  Tamanho do arquivo binário aumentado em 15-38% </li><li>  Incompatibilidade com a interface de programação C </li><li>  Exceção implícita ao suporte em todas as funções, exceto <code>noexcept</code> .  Uma exceção pode ser lançada quase em qualquer lugar do programa, mesmo quando o autor da função não espera. </li></ol><br><p>  Devido a essas deficiências, o escopo das exceções é significativamente limitado.  Quando as exceções não podem ser aplicadas: </p><br><ol><li>  Onde o determinismo é importante, ou seja, onde é inaceitável que o código "às vezes" funcione 10, 100, 1000 vezes mais lento que o normal </li><li>  Quando eles não são suportados na ABI, por exemplo, em microcontroladores </li><li>  Quando grande parte do código é escrita em C </li><li>  Em empresas com uma grande carga de código legado ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google Style Guide</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Qt</a> ).  Se houver pelo menos uma função não protegida por exceção no código, de acordo com a lei da maldade, uma exceção será lançada mais cedo ou mais tarde e criará um bug </li><li>  Nas empresas que contratam programadores que não têm idéia sobre segurança de exceção </li></ol><br><p>  Segundo pesquisas, nos locais de trabalho de 52% (!) Desenvolvedores, as exceções são proibidas pelas regras corporativas. </p><br><p>  Mas as exceções são parte integrante do C ++!  Ao incluir o <code>-fno-exceptions</code> , os desenvolvedores perdem a capacidade de usar uma parte significativa da biblioteca padrão.  Isso incita ainda mais as empresas a plantar suas próprias "bibliotecas padrão" e, sim, inventar sua própria classe de cadeias. </p><br><p>  Mas este não é o fim.  Exceções são a única maneira padrão de cancelar a criação de um objeto no construtor e gerar um erro.  Quando desativados, uma abominação, como a inicialização em duas fases, é exibida.  Os operadores também não podem usar códigos de erro; portanto, eles são substituídos por funções como <code>assign</code> . </p><br><h2 id="proposal-isklyucheniya-buduschego">  Proposta: exceções do futuro </h2><br><h3 id="novyy-mehanizm-peredachi-isklyucheniy">  Novo mecanismo de transferência de exceção </h3><br><p>  Herb Sutter em P709 descreveu um novo mecanismo de transferência de exceções.  Em princípio, a função retorna <code>std::expected</code> , no entanto, em vez de um discriminador separado do tipo <code>bool</code> , que junto com o alinhamento ocupará até 8 bytes na pilha, essa informação é transmitida de maneira mais rápida, por exemplo, para Carry Flag. </p><br><p>  As funções que não tocam em CF (a maioria) terão a oportunidade de usar exceções estáticas gratuitamente - tanto no caso de um retorno normal quanto no caso de lançar uma exceção!  As funções forçadas a salvá-lo e restaurá-lo receberão uma sobrecarga mínima e ainda serão mais rápidas que o <code>std::expected</code> e qualquer código de erro comum. </p><br><p>  As exceções estáticas são assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::divide_by_zero; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == INT_MIN &amp;&amp; j == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::integer_divide_overflows; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i / j; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i + safe_divide(j, k); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; foo(i, j, k); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (erithmetic_errc e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  Na versão alternativa, propõe-se obrigar a palavra-chave <code>try</code> na mesma expressão que a chamada da função <code>throws</code> : <code>try i + safe_divide(j, k)</code> .  Isso reduzirá o número de casos de uso de funções <code>throws</code> no código que não é seguro para exceções quase zero.  De qualquer forma, diferentemente das exceções dinâmicas, o IDE poderá, de alguma forma, destacar expressões que geram exceções. </p><br><p>  O fato de a exceção lançada não ser armazenada separadamente, mas ser colocada diretamente no lugar do valor retornado, impõe restrições ao tipo de exceção.  Primeiro, ele deve ser trivialmente realocável.  Em segundo lugar, seu tamanho não deve ser muito grande (mas pode ser algo como <code>std::unique_ptr</code> ), caso contrário, todas as funções reservarão mais espaço na pilha. </p><br><h3 id="status_code">  status_code </h3><br><p>  A biblioteca <code>&lt;system_error2&gt;</code> , desenvolvida por Niall Douglas, conterá <code>status_code&lt;T&gt;</code> - "novo, melhor" <code>error_code</code> .  As principais diferenças de <code>error_code</code> : </p><br><ol><li>  <code>status_code</code> - um tipo de modelo que pode ser usado para armazenar quase todos os códigos de erro concebíveis (junto com um ponteiro para <code>status_code_category</code> ), sem usar exceções estáticas </li><li>  <code>T</code> deve ser trivialmente relocável e copiável (este último, IMHO, não deve ser obrigatório).  Ao copiar e excluir, as funções virtuais são chamadas de <code>status_code_category</code> </li><li>  <code>status_code</code> pode armazenar não apenas dados de erro, mas também informações adicionais sobre uma operação concluída com êxito </li><li>  A função "virtual" <code>code.message()</code> não retorna <code>std::string</code> , mas <code>string_ref</code> é um tipo de string bastante pesado, que é um <code>std::string_view</code> "possivelmente proprietário" <code>std::string_view</code> .  Lá você pode <code>string_view</code> ou <code>string</code> , ou <code>std::shared_ptr&lt;string&gt;</code> , ou alguma outra maneira maluca de possuir uma string.  Niall afirma que <code>#include &lt;string&gt;</code> tornaria o cabeçalho <code>&lt;system_error2&gt;</code> inaceitavelmente "pesado" </li></ol><br><p>  Em seguida, <code>errored_status_code&lt;T&gt;</code> é inserido - um wrapper sobre <code>status_code&lt;T&gt;</code> com o seguinte construtor: </p><br><pre> <code class="cpp hljs">errored_status_code(status_code&lt;T&gt;&amp;&amp; code) [[expects: code.failure() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>]] : code_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(code)) {}</code> </pre> <br><h3 id="error">  erro </h3><br><p>  O tipo de exceção padrão ( <code>throws</code> sem tipo), bem como o tipo básico de exceções para as quais todas as outras são convertidas (como <code>std::exception</code> ), é <code>error</code> .  É definido algo como isto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> error = errored_status_code&lt;<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span>&gt;;</code> </pre> <br><p>  Ou seja, <code>error</code> é um <code>status_code</code> "erro", no qual o valor ( <code>value</code> ) é colocado em 1 ponteiro.  Como o mecanismo <code>status_code_category</code> garante exclusão, movimento e cópia corretos, teoricamente, qualquer estrutura de dados pode ser salva por <code>error</code> .  Na prática, esta será uma das seguintes opções: </p><br><ol><li>  Inteiros (int) </li><li>  <code>std::exception_handle</code> , ou seja, um ponteiro para uma exceção dinâmica lançada </li><li>  <code>status_code_ptr</code> , ou seja, <code>unique_ptr</code> para um <code>status_code&lt;T&gt;</code> arbitrário <code>status_code&lt;T&gt;</code> . </li></ol><br><p>  O problema é que o caso 3 não está planejado para dar a oportunidade de retornar o <code>error</code> ao <code>status_code&lt;T&gt;</code> .  A única coisa que você pode fazer é obter a <code>message()</code> <code>status_code&lt;T&gt;</code> compactado <code>status_code&lt;T&gt;</code> .  Para poder recuperar o valor novamente em <code>error</code> , ative-o como uma exceção dinâmica (!). Em seguida, pegue e envolva-o em <code>error</code> .  Em geral, Niall acredita que apenas códigos de erro e mensagens de string devem ser armazenados com <code>error</code> , o que é suficiente para qualquer programa. </p><br><p>  Para distinguir entre diferentes tipos de erros, propõe-se usar o operador de comparação "virtual": </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { open_file(name); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == filesystem_error::already_exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> my_exception(<span class="hljs-string"><span class="hljs-string">"Unknown filesystem error, unable to continue"</span></span>); } }</code> </pre> <br><p>  O uso de vários blocos catch ou <code>dynamic_cast</code> para selecionar o tipo de exceção falhará! </p><br><h3 id="vzaimodeystvie-s-dinamicheskimi-isklyucheniyami">  Interação com exceções dinâmicas </h3><br><p>  Uma função pode ter uma das seguintes especificações: </p><br><ul><li>  <code>noexcept</code> : não lança exceções </li><li>  <code>throws(E)</code> : lança apenas exceções estáticas </li><li>  (nada): lança apenas exceções dinâmicas </li></ul><br><p>  <code>throws</code> implica <code>noexcept</code> .  Se uma exceção dinâmica é lançada a partir de uma função "estática", é envolto em <code>error</code> .  Se uma exceção estática for lançada de uma função "dinâmica", ela será <code>status_error</code> em uma exceção <code>status_error</code> .  Um exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> erithmetic_errc::divide_by_zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> throws </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  arithmetic_errc   intptr_t //     error foo(); } void baz() { // error    status_error bar(); } void qux() throws { // error    status_error baz(); }</span></span></code> </pre> <br><h3 id="isklyucheniya-v-c">  Exceções em C ?! </h3><br><p>  A proposta prevê a adição de exceções a um dos futuros padrões C, e essas exceções serão compatíveis com ABI com exceções estáticas em C ++.  Uma estrutura semelhante ao <code>std::expected&lt;T, U&gt;</code> , o usuário precisará declarar independentemente, embora a redundância possa ser removida usando macros.  A sintaxe consiste em (por simplicidade, assumiremos isso) as palavras-chave falham, falham, capturam. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / x; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> failure(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expected_int_float</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> error; }; <span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span> failed; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expected_int_float result = <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(invert(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.failed) { print_error(result.error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } print_success(result.value); }</code> </pre> <br><p>  Ao mesmo tempo, em C ++ também será possível chamar funções de <code>fails</code> de C, declarando-as em blocos <code>extern C</code> .  Assim, em C ++, haverá toda uma galáxia de palavras-chave para trabalhar com exceções: </p><br><ul><li>  <code>throw()</code> - removido em C ++ 20 </li><li>  <code>noexcept</code> - especificador de função, a função não lança exceções dinâmicas </li><li>  <code>noexcept(expression)</code> - especificador de função, a função não lança exceções dinâmicas fornecidas </li><li>  <code>noexcept(expression)</code> - Uma expressão <code>noexcept(expression)</code> exceções dinâmicas? </li><li>  <code>throws(E)</code> - especificador de função, a função lança exceções estáticas </li><li>  <code>throws</code> = <code>throws(std::error)</code> </li><li>  <code>fails(E)</code> - uma função importada de C lança exceções estáticas </li></ul><br><p>  Assim, em C ++ eles trouxeram (ou melhor, entregaram) um carrinho de novas ferramentas para tratamento de erros.  Em seguida, surge uma pergunta lógica: </p><br><h2 id="kogda-chto-ispolzovat">  Quando usar o que? </h2><br><h3 id="napravlenie-v-celom">  Direção geral </h3><br><p>  Os erros são divididos em vários níveis: </p><br><ul><li>  Erros do programador.  Processado usando contratos.  Eles levam à coleta de logs e ao encerramento do programa, de acordo com o conceito de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fail-fast</a> .  Exemplos: ponteiro nulo (quando isso é inválido);  divisão por zero;  erros de alocação de memória não previstos pelo programador. </li><li>  Erros fatais fornecidos pelo programador.  Jogado fora um milhão de vezes menos que o retorno normal de uma função, o que justifica o uso de exceções dinâmicas.  Normalmente, nesses casos, você precisa reiniciar todo o subsistema do programa ou cometer um erro ao executar a operação.  Exemplos: perda repentina da conexão com o banco de dados;  erros de alocação de memória fornecidos pelo programador. </li><li>  Erros recuperáveis ​​quando <em>algo</em> impedia a função de concluir sua tarefa, mas a função de chamada pode saber o que fazer com ela.  Manipulado por exceções estáticas.  Exemplos: trabalhe com o sistema de arquivos;  outros erros de entrada / saída (IO);  Dados incorretos do usuário  <code>vector::at()</code> . </li><li>  A função concluiu com êxito sua tarefa, embora com um resultado inesperado.  <code>std::optional</code> , <code>std::expected</code> , <code>std::variant</code> .  Exemplos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>stoi()</code></a> ;  <code>vector::find()</code> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>map::insert</code></a> . </li></ul><br><p>  Na biblioteca padrão, é mais confiável abandonar completamente o uso de exceções dinâmicas para tornar legal a compilação "sem exceções". </p><br><h3 id="errno">  errno </h3><br><p>  As funções que usam <code>errno</code> para trabalhar rápida e facilmente com os códigos de erro C e C ++ devem ser substituídas por <code>throws(std::errc)</code> <code>fails(int)</code> e <code>throws(std::errc)</code> , respectivamente.  Por algum tempo, as versões antiga e nova das funções da biblioteca padrão coexistirão, e a antiga será declarada obsoleta. </p><br><h3 id="out-of-memory">  Falta de memória </h3><br><p>  Os erros de alocação de memória são manipulados pelo gancho global <code>new_handler</code> , que pode: </p><br><ol><li>  Elimine a falta de memória e continue a execução </li><li>  Lançar uma exceção </li><li>  Programa de falha </li></ol><br><p>  Agora <code>std::bad_alloc</code> lançado por padrão.  É recomendável chamar <code>std::terminate()</code> por padrão.  Se você precisar do comportamento antigo, substitua o manipulador pelo que você precisa no início de <code>main()</code> . </p><br><p>  Todas as funções existentes da biblioteca padrão não serão <code>noexcept</code> e <code>noexcept</code> o programa quando <code>std::bad_alloc</code> .  Ao mesmo tempo, novas APIs como <code>vector::try_push_back</code> serão adicionadas, o que permite erros de alocação de memória. </p><br><h3 id="logic_error"> <code>logic_error</code> </h3> <br><p>  Exceções <code>std::logic_error</code> , <code>std::domain_error</code> , <code>std::invalid_argument</code> , <code>std::length_error</code> , <code>std::out_of_range</code> , <code>std::future_error</code> reportam uma violação de uma pré-condição de função.  O novo modelo de erro deve usar contratos.  Os tipos de exceções listados <strong>não</strong> serão preteridos, mas quase todos os casos de uso na biblioteca padrão serão substituídos por <code>[[expects: …]]</code> . </p><br><h2 id="tekuschee-sostoyanie-proposal">  Status atual da proposta </h2><br><p>  A proposta está agora em um estado de rascunho.  Ele já mudou bastante e ainda pode mudar muito.  Como alguns desenvolvimentos não conseguiram ser publicados, a API proposta <code>&lt;system_error2&gt;</code> não <code>&lt;system_error2&gt;</code> totalmente relevante. </p><br><p>  A proposta está descrita em 3 documentos: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P709</a> - documento original do brasão de armas da Sutter </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1095</a> - Exceções determinadas na visão de Niall Douglas, alguns momentos alterados, compatibilidade de idioma C adicionada </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1028</a> - API da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementação de teste de</a> <code>std::error</code> </li></ol><br><p>  Atualmente, não há compilador que suporte exceções estáticas.  Portanto, ainda não é possível fazer seus benchmarks. </p><br><p>           C++23.   , , ,   C++26,    ,  ,  . </p><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>            ,     ,     .    ,            .   . </p><br><p>  ,   ^^ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430690/">https://habr.com/ru/post/pt430690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430680/index.html">Escrevendo um processador e ambiente simples para ele</a></li>
<li><a href="../pt430682/index.html">Três anos do projeto de microssatélites lunares: estágios de crescimento</a></li>
<li><a href="../pt430684/index.html">Digitalização de contratos do Ethereum ao vivo para erro de envio não verificado. Parte 2</a></li>
<li><a href="../pt430686/index.html">Visão geral: a primeira máquina de corte a jato de água da WAZER</a></li>
<li><a href="../pt430688/index.html">Transferência de dados via QR animado para Gomobile e GopherJS</a></li>
<li><a href="../pt430692/index.html">Engenharia social com software Universal Windows Platform (APPX)</a></li>
<li><a href="../pt430694/index.html">Um pequeno guia para aprender C ++: o que, quando e sobre o que criar</a></li>
<li><a href="../pt430700/index.html">Um sistema unificado para gravar visualizações de filmes on-line começará a funcionar na Rússia</a></li>
<li><a href="../pt430702/index.html">Treinamento muito estranho</a></li>
<li><a href="../pt430704/index.html">Como as tecnologias de inteligência artificial ajudam a Aviasales a crescer: sete exemplos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>