<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚟 🥉 🧡 .NET: Alat untuk bekerja dengan multithreading dan asynchrony. Bagian 2 ⭐️ 🚣🏻 🧓🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya menerbitkan artikel asli tentang Habr, yang terjemahannya diposting di blog Codingsight . 

 Saya terus membuat versi teks dari ceramah saya di p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Alat untuk bekerja dengan multithreading dan asynchrony. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459514/">  <i>Saya menerbitkan artikel asli tentang Habr, yang terjemahannya diposting di blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Codingsight</a> .</i> <br><br>  Saya terus membuat versi teks dari ceramah saya di pertemuan multithreading.  Bagian pertama dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> atau di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , di sana lebih tentang seperangkat alat dasar untuk memulai utas atau Tugas, cara untuk melihat status mereka dan beberapa hal kecil yang manis seperti PLinq.  Pada artikel ini saya ingin lebih fokus pada masalah yang mungkin timbul dalam lingkungan multi-threaded dan beberapa cara untuk menyelesaikannya. <br><br><h2>  Isi </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tentang Sumber Daya yang Dibagikan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kemungkinan masalah saat bekerja di lingkungan multi-utas</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jalan buntu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kondisi balapan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sibuk-tunggu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelaparan benang</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sinkronkan Alat</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saling bertautan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monitor. Masukkan, Monitor. Keluar, kunci</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monitor. Tunggu, Monitor. Tolong [Semua]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ResetEvent Family</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> </li></ul><br><a name="habracut"></a><br><a name="SharedResources"></a><br><h2>  Tentang Sumber Daya yang Dibagikan </h2><br>  Tidak mungkin untuk menulis sebuah program yang akan bekerja di banyak utas, tetapi pada saat yang sama tidak akan memiliki satu sumber daya bersama:  bahkan jika itu berhasil pada tingkat abstraksi Anda, kemudian turun satu atau lebih tingkat di bawahnya ternyata masih ada sumber daya yang sama.  Saya akan memberikan beberapa contoh: <br><br>  <b>Contoh # 1:</b> <br><br>  Khawatir masalah yang mungkin terjadi, Anda membuat utas berfungsi dengan file yang berbeda.  Menurut file untuk streaming.  Tampaknya bagi Anda bahwa program tidak memiliki satu sumber daya tunggal. <br><br>  Setelah turun beberapa tingkat di bawah ini, kami memahami bahwa hanya ada satu hard drive, dan driver atau sistem operasinya harus menyelesaikan masalah untuk memastikan akses ke sana. <br><br>  <b>Contoh # 2:</b> <br><br>  Setelah membaca <i>contoh #</i> 1, Anda memutuskan untuk meletakkan file pada dua mesin jarak jauh yang berbeda dengan dua potong besi dan sistem operasi yang berbeda secara fisik.  Kami menyimpan 2 koneksi berbeda melalui FTP atau NFS. <br><br>  Setelah turun beberapa tingkat di bawah ini, kami memahami bahwa tidak ada yang berubah, dan driver kartu jaringan atau sistem operasi mesin tempat program dijalankan harus menyelesaikan masalah akses kompetitif. <br><br>  <b>Contoh # 3:</b> <br><br>  Setelah kehilangan sebagian besar rambut Anda dalam upaya untuk membuktikan kemungkinan menulis program multi-utas, Anda sepenuhnya menolak file dan menguraikan kalkulasi menjadi dua objek yang berbeda, tautan ke masing-masing yang tersedia hanya untuk satu aliran. <br><br>  Saya paku selusin paku terakhir ke peti mati dari ide ini: satu runtime dan pengumpul sampah, penjadwal thread, secara fisik satu RAM dan memori, satu prosesor masih berbagi sumber daya. <br><br>  Jadi, kami menemukan bahwa tidak mungkin untuk menulis program multi-threaded tanpa sumber daya bersama tunggal di semua tingkat abstraksi di seluruh lebar tumpukan teknologi.  Untungnya, masing-masing tingkat abstraksi, sebagai suatu peraturan, sebagian atau seluruhnya menyelesaikan masalah akses kompetitif atau hanya melarangnya (contoh: kerangka kerja UI apa pun yang melarang bekerja dengan elemen dari berbagai utas), oleh karena itu masalah yang paling sering muncul adalah sumber daya bersama di tingkat abstraksi Anda.  Untuk menyelesaikannya, perkenalkan konsep sinkronisasi. <br><a name="Problems"></a><br><h2>  Kemungkinan masalah saat bekerja di lingkungan multi-utas </h2><br>  Kesalahan dalam perangkat lunak dapat dibagi menjadi beberapa kelompok: <br><br><ol><li>  Program tidak membuahkan hasil.  Gangguan atau macet. </li><li>  Program mengembalikan hasil yang salah. </li><li>  Program menghasilkan hasil yang benar, tetapi tidak memenuhi satu atau beberapa persyaratan non-fungsional lainnya.  Berjalan terlalu lama atau menghabiskan terlalu banyak sumber daya. </li></ol><br>  Dalam lingkungan multi-threaded, dua masalah utama yang menyebabkan kesalahan 1 dan 2 adalah <b>kondisi</b> <b>jalan buntu</b> dan <b>ras</b> . <br><a name="Deadlock"></a><br><h3>  Jalan buntu </h3><br>  Jalan buntu - jalan buntu.  Ada banyak variasi berbeda.  Yang paling umum adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  Sementara <b>Thread # 1 sedang</b> melakukan sesuatu, <b>Thread # 2</b> memblokir sumber <b>B</b> , sedikit kemudian <b>Thread # 1</b> memblokir sumber <b>A</b> dan mencoba untuk mengunci sumber <b>B</b> , sayangnya ini tidak akan pernah terjadi, karena  <b>Thread # 2 akan</b> merilis sumber daya <b>B</b> hanya setelah mengunci sumber daya <b>A.</b> <br><a name="RaceCondition"></a><br><h3>  Kondisi balapan </h3><br>  Race-Condition - kondisi lomba.  Situasi di mana perilaku dan hasil perhitungan yang dilakukan oleh program tergantung pada pekerjaan penjadwal thread run-time. <br>  Ketidaknyamanan dari situasi ini justru terletak pada kenyataan bahwa program Anda mungkin tidak berfungsi hanya sekali dari seratus atau bahkan dari satu juta. <br><br>  Situasi ini diperburuk oleh fakta bahwa masalah dapat berjalan bersamaan, misalnya: dengan perilaku penjadwal ulir tertentu, terjadi kebuntuan. <br><br>  Selain dua masalah yang mengarah ke kesalahan yang jelas dalam program, ada juga yang mungkin tidak mengarah pada hasil perhitungan yang salah, tetapi lebih banyak waktu atau kekuatan pemrosesan akan dihabiskan untuk mendapatkannya.  Dua dari masalah ini adalah: <b>Busy Wait</b> dan <b>Thread Starvation</b> . <br><a name="BusyWait"></a><br><h3>  Sibuk-tunggu </h3><br>  Sibuk-Tunggu adalah masalah di mana program mengkonsumsi sumber daya prosesor bukan untuk perhitungan, tetapi untuk menunggu. <br><br>  Seringkali masalah seperti itu dalam kode terlihat seperti ini: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Ini adalah contoh kode yang sangat buruk sejak itu  Kode seperti itu sepenuhnya menempati satu inti dari prosesor Anda sambil tidak melakukan apa pun yang berguna.  Dapat dibenarkan jika dan hanya jika sangat penting untuk memproses perubahan dalam beberapa nilai di utas lainnya.  Dan berbicara dengan cepat, saya berbicara tentang kasus ketika Anda tidak bisa menunggu beberapa nanodetik.  Dalam kasus lain, yaitu, dalam segala hal yang dapat menghasilkan otak yang sehat, lebih masuk akal untuk menggunakan varietas ResetEvent dan versi Slim-nya.  Tentang mereka di bawah ini. <br><br>  Mungkin salah satu pembaca akan mengusulkan untuk memecahkan masalah memuat satu inti dengan menunggu sia-sia dengan menambahkan konstruksi seperti Thread. Tidur (1) ke loop.  Ini benar-benar akan menyelesaikan masalah, tetapi akan membuat yang lain: waktu respons terhadap perubahan akan rata-rata setengah milidetik, yang mungkin tidak banyak, tetapi secara serempak lebih dari yang Anda dapat gunakan primitif sinkronisasi dari keluarga ResetEvent. <br><a name="ThreadStarvation"></a><br><h3>  Kelaparan benang </h3><br>  Thread-Starvation adalah masalah di mana program memiliki terlalu banyak utas yang bekerja secara bersamaan.  Apa artinya sebenarnya aliran yang sibuk dengan perhitungan, dan tidak hanya menunggu respons dari IO mana pun.  Dengan masalah ini, semua kemungkinan perolehan kinerja dari menggunakan utas hilang, karena  Prosesor menghabiskan banyak waktu untuk mengubah konteks. <br>  Lebih mudah untuk mencari masalah seperti menggunakan berbagai profiler, di bawah ini adalah contoh tangkapan layar dari profiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotTrace</a> diluncurkan dalam mode Timeline. <br><br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(Gambar dapat diklik)</i> <br><br>  Dalam program yang tidak menderita kelaparan streaming, tidak akan ada warna merah muda pada grafik yang mencerminkan aliran.  Selain itu, dalam kategori Subsistem, jelas bahwa 30,6% dari program sedang menunggu CPU. <br><br>  Ketika masalah seperti itu didiagnosis, itu diselesaikan dengan cukup sederhana: Anda memulai terlalu banyak utas pada satu waktu, memulai lebih sedikit atau tidak sekaligus. <br><a name="SyncPrimitives"></a><br><h2>  Sinkronkan Alat </h2><br><a name="Interlocked"></a><br><h3>  Saling bertautan </h3><br>  Ini mungkin cara yang paling ringan untuk melakukan sinkronisasi.  Saling bertautan adalah kumpulan operasi atom sederhana.  Operasi atom disebut operasi pada saat tidak ada yang bisa terjadi.  Dalam .NET, Interlocked diwakili oleh kelas statis dengan nama yang sama dengan sejumlah metode, yang masing-masing mengimplementasikan satu operasi atom. <br><br>  Untuk mewujudkan kengerian operasi non-atom, cobalah menulis sebuah program yang memulai 10 utas, yang masing-masing menghasilkan sejuta peningkatan dari variabel yang sama, dan pada akhir pekerjaan mereka mencetak nilai dari variabel ini - sayangnya itu akan sangat berbeda dari 10 juta, apalagi Setiap kali program dimulai, akan berbeda.  Ini terjadi karena bahkan operasi sederhana seperti kenaikan itu bukan atom, tetapi melibatkan penggalian nilai dari memori, menghitung yang baru, dan menulis kembali.  Dengan demikian, dua utas dapat secara bersamaan melakukan masing-masing operasi ini, dalam hal ini kenaikan akan hilang. <br><br>  Kelas yang saling bertautan menyediakan metode Peningkatan / Penurunan, mudah untuk menebak apa yang mereka lakukan.  Mereka nyaman digunakan jika Anda memproses data dalam banyak utas dan mempertimbangkan sesuatu.  Kode seperti itu akan bekerja lebih cepat daripada kunci klasik.  Jika Saling Bertautan digunakan untuk situasi yang dijelaskan dalam paragraf terakhir, program akan secara stabil memberikan 10 juta dalam situasi apa pun. <br><br>  Metode CompareExchange melakukan, pada pandangan pertama, fungsi yang agak tidak terlihat, tetapi semua kehadirannya memungkinkan Anda untuk mengimplementasikan banyak algoritma yang menarik, terutama keluarga bebas-kunci. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Metode ini mengambil tiga nilai: yang pertama dilewatkan dengan referensi dan ini adalah nilai yang akan diubah ke yang kedua, jika pada saat perbandingan location1 cocok dengan comparand, maka nilai asli location1 akan dikembalikan.  Kedengarannya agak membingungkan, karena lebih mudah untuk menulis kode yang melakukan operasi yang sama dengan CompareExchange: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  Hanya implementasi di kelas Interlocked yang bersifat atomik.  Yaitu, jika kita menulis kode seperti itu sendiri, situasi bisa saja terjadi ketika kondisi location1 == comparand sudah terpenuhi, tetapi pada saat ekspresi location1 = nilai dieksekusi, utas lain telah mengubah nilai location1 dan itu akan hilang. <br><br>  Kita dapat menemukan contoh yang baik menggunakan metode ini dalam kode yang dihasilkan oleh kompiler untuk setiap acara C #. <br><br>  Mari menulis kelas sederhana dengan satu acara MyEvent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mari kita</a> membangun proyek dalam konfigurasi Release dan buka perakitan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dotPeek</a> dengan opsi Show Compiler Generated Code dihidupkan: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Di sini Anda dapat melihat bahwa di balik layar, kompiler menghasilkan algoritma yang agak canggih.  Algoritma ini melindungi terhadap situasi kehilangan langganan acara ketika beberapa utas berlangganan acara ini secara bersamaan.  Mari kita menulis metode add secara lebih detail, mengingat apa yang dilakukan metode CompareExchange di belakang layar <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  Ini sudah sedikit lebih jelas, meskipun mungkin masih perlu penjelasan.  Dengan kata lain, saya akan menggambarkan algoritma ini sebagai berikut: <br><br>  <i>Jika MyEvent masih sama seperti pada saat kami mulai menjalankan Delegate.Combine, kemudian tuliskan Delegate.Combine apa yang akan kembali, dan jika tidak, itu tidak masalah, mari kita coba lagi dan ulangi sampai keluar.</i> <i><br></i> <br><br>  Jadi tidak ada langganan acara yang akan hilang.  Anda harus menyelesaikan masalah serupa jika tiba-tiba ingin menerapkan larik bebas kunci dinamis yang aman.  Jika beberapa aliran terburu-buru untuk menambahkan elemen ke dalamnya, maka penting bahwa mereka semua ditambahkan pada akhirnya. <br><a name="Lock"></a><br><h3>  Monitor. Masukkan, Monitor. Keluar, kunci </h3><br>  Ini adalah desain yang paling umum digunakan untuk sinkronisasi ulir.  Mereka menerapkan gagasan bagian kritis: yaitu, kode yang ditulis antara panggilan ke Monitor. Masukkan, Monitor. Keluar pada satu sumber daya dapat dieksekusi pada satu waktu hanya dalam satu utas.  Pernyataan kunci adalah gula sintaksis di sekitar panggilan Masuk / Keluar yang dibungkus dalam coba-akhirnya.  Fitur yang bagus untuk mengimplementasikan bagian kritis dalam .NET adalah kemampuan untuk memasukkannya kembali ke aliran yang sama.  Ini berarti bahwa kode tersebut akan dijalankan tanpa masalah: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  Tentu saja, tidak mungkin seseorang akan menulis seperti ini, tetapi jika Anda mengoleskan kode ini ke beberapa metode di kedalaman tumpukan-panggilan, fitur ini dapat menghemat beberapa jika.  Untuk membuat trik semacam itu menjadi mungkin, para pengembang .NET harus menambahkan batasan - hanya instance dari tipe referensi yang dapat digunakan sebagai objek sinkronisasi, dan beberapa byte secara implisit ditambahkan ke setiap objek di mana pengenal aliran akan ditulis. <br><br>  Fitur bagian kritis ini dalam c # memberikan satu batasan menarik pada pengoperasian pernyataan kunci: Anda tidak dapat menggunakan pernyataan tunggu di dalam pernyataan kunci.  Pada awalnya, itu mengejutkan saya, karena Monitor yang coba-akhirnya serupa. Masukkan / Keluar mengkompilasi.  Ada apa?  Di sini perlu untuk hati-hati membaca kembali paragraf terakhir sekali lagi, dan kemudian menambahkannya beberapa pengetahuan tentang prinsip async / menunggu: kode setelah menunggu tidak harus dieksekusi pada utas yang sama dengan kode sebelum menunggu, itu tergantung pada konteks sinkronisasi dan keberadaan atau tidak ada panggilan ke ConfigureAwait.  Maka Monitor.Exit dapat mengeksekusi pada utas selain Monitor.Enter, yang akan melempar <b>SynchronizationLockException</b> .  Jika Anda tidak percaya, maka Anda dapat menjalankan kode berikut di aplikasi konsol: itu akan melempar SynchronizationLockException. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Perlu dicatat bahwa dalam WinForms atau aplikasi WPF, kode ini akan berfungsi dengan benar jika dipanggil dari utas utama.  akan ada konteks sinkronisasi yang mengimplementasikan pengembalian ke UI-Thread setelah menunggu.  Bagaimanapun, Anda tidak boleh bermain dengan bagian kritis dalam konteks kode yang berisi operator yang menunggu.  Dalam kasus ini, lebih baik menggunakan primitif sinkronisasi, yang akan dibahas nanti. <br><br>  Berbicara tentang pekerjaan bagian kritis dalam .NET, ada baiknya menyebutkan fitur lain dari implementasinya.  Bagian kritis dalam .NET beroperasi dalam dua mode: mode spin-wait dan mode kernel.  Algoritma spin-wait direpresentasikan sebagai kode pseudo berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Optimalisasi ini ditujukan untuk menangkap bagian kritis tercepat dalam waktu singkat, berdasarkan pada asumsi bahwa jika sumber daya sibuk sekarang, maka akan membebaskan dirinya sendiri.  Jika ini tidak terjadi dalam waktu yang singkat, maka utas berjalan menunggu dalam mode kernel, yang, seperti kembali dari itu, membutuhkan waktu.  Pengembang .NET telah mengoptimalkan skenario kunci singkat sebanyak mungkin, sayangnya, jika banyak utas mulai merobek bagian penting, ini dapat menyebabkan beban CPU yang tinggi dan tiba-tiba. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Karena saya menyebutkan algoritma spin-wait, ada baiknya menyebutkan BCL SpinLock dan struktur SpinWait.  Mereka harus digunakan jika ada alasan untuk percaya bahwa akan selalu ada kesempatan untuk mengambil kunci dengan sangat cepat.  Di sisi lain, sulit untuk mengingat tentang mereka sebelum hasil profil menunjukkan bahwa itu adalah penggunaan primitif sinkronisasi lain yang merupakan hambatan dari program Anda. <br><a name="Pulse"></a><br><h3>  Monitor. Tunggu, Monitor. Tolong [Semua] </h3><br>  Pasangan metode ini harus dipertimbangkan bersama.  Dengan bantuan mereka, berbagai skenario Produsen-Konsumen dapat diimplementasikan. <br><br>  <i>Produser-Konsumen - pola desain multi-proses / multi-utas dengan asumsi adanya satu atau lebih utas / proses yang menghasilkan data dan satu atau lebih proses / utas yang memproses data ini.</i>  <i>Biasanya menggunakan koleksi bersama.</i> <br><br>  Kedua metode ini hanya dapat dipanggil jika utas yang menyebabkannya memiliki kunci saat ini.  Metode Tunggu melepaskan kunci dan menggantung sampai utas lain memanggil Pulse. <br><br>  Untuk menunjukkan karya itu, saya menulis contoh kecil: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(Saya menggunakan gambar, bukan teks, untuk secara visual menunjukkan urutan pelaksanaan instruksi)</i> <br><br>  <u>Parse:</u> Tetapkan penundaan 100ms pada awal aliran kedua, khusus untuk memastikan bahwa eksekusi dimulai nanti. <br>  - T1: Aliran baris # 2 dimulai <br>  - T1: Aliran baris # 3 memasuki bagian kritis <br>  - T1: Baris # 6 aliran tertidur <br>  - T2: Aliran baris # 3 dimulai <br>  - T2: Baris # 4 membeku sambil menunggu bagian kritis <br>  - T1: Jalur # 7 melepaskan bagian kritis dan membeku sambil menunggu Pulsa keluar <br>  - T2: Baris # 8 memasuki bagian kritis <br>  - T2: Baris # 11 memberi tahu T1 menggunakan metode Pulse <br>  - T2: Baris # 14 keluar dari bagian kritis.  Sampai saat itu, T1 tidak dapat melanjutkan eksekusi. <br>  - T1: Baris # 15 bangun <br>  - T1: Baris # 16 meninggalkan bagian kritis <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MSDN</a> memiliki komentar penting mengenai penggunaan metode Pulse / Tunggu, yaitu: Monitor tidak menyimpan informasi status, yang berarti bahwa jika metode Pulse dipanggil sebelum metode Tunggu dipanggil, itu dapat menyebabkan kebuntuan.</i>  <i>Jika situasi ini memungkinkan, maka lebih baik menggunakan salah satu kelas dari keluarga ResetEvent.</i> <br><br>  Contoh sebelumnya dengan jelas menunjukkan bagaimana metode Tunggu / Denyut dari kelas Monitor berfungsi, tetapi masih menyisakan pertanyaan tentang kapan harus digunakan.  Contoh yang baik adalah implementasi BlockingQueue &lt;T&gt;, di sisi lain, implementasi BlockingCollection &lt;T&gt; dari System.Collections.Concurrent menggunakan SemaphoreSlim untuk sinkronisasi. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  Ini adalah primitif sinkronisasi yang saya cintai, diwakili oleh kelas System.Threading namespace dengan nama yang sama.  Menurut saya, banyak program akan bekerja lebih baik jika pengembang mereka menggunakan kelas ini daripada kunci biasa. <br><br>  <i>Ide: banyak utas dapat membaca, hanya satu tulis.</i>  <i>Begitu aliran menyatakan keinginannya untuk menulis, bacaan baru tidak dapat dimulai, tetapi akan menunggu rekaman selesai.</i>  <i>Ada juga konsep upgrade-baca-kunci, yang dapat digunakan jika Anda mengerti selama proses membaca bahwa Anda perlu menulis sesuatu, kunci tersebut akan dikonversi menjadi kunci-tulis dalam satu operasi atom.</i> <br><br>  <i>Ada juga kelas ReadWriteLock di System.Threading namespace, tetapi sangat disarankan untuk pengembangan baru.</i>  <i>Versi ramping akan memungkinkan untuk menghindari sejumlah kasus yang menyebabkan kebuntuan, selain itu memungkinkan Anda untuk dengan cepat menangkap kuncinya, karena</i>  <i>mendukung sinkronisasi dalam mode spin-wait sebelum berangkat ke mode kernel.</i> <br><br>  Jika pada saat membaca artikel ini Anda belum tahu tentang kelas ini, maka saya pikir sekarang Anda telah mengingat beberapa contoh dari kode yang ditulis baru-baru ini, di mana pendekatan penguncian akan memungkinkan program untuk bekerja secara efisien. <br><br>  Antarmuka kelas ReaderWriterLockSlim sederhana dan mudah, tetapi penggunaannya tidak bisa disebut nyaman: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  Saya suka membungkus penggunaannya di kelas, yang membuatnya menggunakannya jauh lebih nyaman. <br>  Ide: untuk membuat metode Baca / TulisLock yang mengembalikan objek dengan metode Buang, maka ini akan memungkinkan mereka untuk digunakan dalam menggunakan dan dengan jumlah garis itu akan sangat berbeda dari kunci biasa. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Trik semacam itu memungkinkan Anda untuk menulis lebih jauh: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  ResetEvent Family </h3><br>  Saya menyertakan kelas ManualResetEvent, ManualResetEventSlim, AutoResetEvent ke keluarga ini. <br>  Kelas ManualResetEvent, versi Slim, dan kelas AutoResetEvent dapat dalam dua status: <br>  - A cocked (non-signaled), dalam keadaan ini, semua utas yang disebut WaitOne membeku hingga acara transisi ke keadaan bersinyal. <br>  - Status diturunkan (ditandai), dalam kondisi ini semua aliran yang tergantung pada panggilan WaitOne dilepaskan.  Semua panggilan WaitOne baru pada acara run-down berlalu secara kondisional. <br><br>  Kelas AutoResetEvent berbeda dari kelas ManualResetEvent di mana secara otomatis memasuki keadaan terkokang setelah melepaskan tepat satu utas.  Jika beberapa utas akan menggantung menunggu AutoResetEvent, maka panggilan Setel akan melepaskan hanya satu sewenang-wenang, tidak seperti ManualResetEvent.  ManualResetEvent akan melepaskan semua utas. <br><br>  Mari kita lihat contoh bagaimana AutoResetEvent bekerja: <br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br><br>  Contoh tersebut menunjukkan bahwa acara tersebut masuk ke kondisi terkokang (non-sinyal) secara otomatis hanya dengan melepaskan utas yang tergantung pada panggilan WaitOne. <br><br>  Kelas ManualResetEvent, tidak seperti ReaderWriterLock, tidak ditandai sebagai usang dan tidak disarankan untuk digunakan setelah penampilan versi Slim-nya.  Versi ramping dari kelas ini secara efisien digunakan untuk harapan pendek, seperti  Ini terjadi dalam mode Spin-Wait, versi reguler cocok untuk yang lama. <br><br>  Selain kelas ManualResetEvent dan AutoResetEvent, kelas CountdownEvent juga ada.  Kelas ini nyaman untuk implementasi algoritma, di mana bagian yang berhasil diparalelkan diikuti oleh bagian yang menyatukan hasil.  Pendekatan ini dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fork-join</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel yang</a> luar biasa dikhususkan untuk karya kelas ini, oleh karena itu saya tidak akan menganalisisnya secara rinci di sini. <br><a name="Conclusions"></a><br><h2>  Kesimpulan </h2><br><ul><li>  Saat bekerja dengan utas, dua masalah yang menghasilkan hasil yang salah atau hilang adalah kondisi balapan dan kebuntuan </li><li>  Masalah-masalah yang menyebabkan program menghabiskan lebih banyak waktu atau sumber daya - utas kelaparan dan kesibukan menunggu </li><li>  .NET kaya akan sinkronisasi utas </li><li>  Ada 2 mode tunggu kunci - Putar Tunggu, Tunggu Inti.  Beberapa primitif sinkronisasi thread .NET menggunakan keduanya </li><li>  Saling bertautan adalah seperangkat operasi atom, yang digunakan dalam algoritma bebas kunci, adalah primitif sinkronisasi tercepat </li><li>  Operator kunci dan Monitor. Masukkan / Keluar menerapkan gagasan bagian kritis - sepotong kode yang hanya dapat dieksekusi oleh satu utas pada satu waktu </li><li>  Metode Monitor.Pulse / Wait mudah digunakan untuk mengimplementasikan skrip Produser-Konsumen </li><li>  ReaderWriterLockSlim mungkin lebih efisien daripada skrip kunci biasa di mana pembacaan paralel dapat diterima </li><li>  Keluarga kelas ResetEvent mungkin berguna untuk sinkronisasi utas. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459514/">https://habr.com/ru/post/id459514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459500/index.html">HTML adalah web</a></li>
<li><a href="../id459502/index.html">Kami terus mengembangkan platform petualangan untuk Rusia: fitur antarmuka dan preferensi musim panas</a></li>
<li><a href="../id459504/index.html">Kursus Desainer Game Muda: Cara Menghitung Keseimbangan Karakter dan Peralatan tanpa Matematika</a></li>
<li><a href="../id459506/index.html">Petualangan Malvari yang Sulit dipahami, Bagian III: Skrip VBA yang rumit untuk Tawa dan Keuntungan</a></li>
<li><a href="../id459508/index.html">5 slide yang diabaikan oleh presenter berpengalaman</a></li>
<li><a href="../id459518/index.html">Penjelasan tugas python dengan wawancara kerja</a></li>
<li><a href="../id459520/index.html">Sebuah model deret angka dan unsur-unsurnya. Belah ketupat</a></li>
<li><a href="../id459528/index.html">Bagaimana cara kami mengajar ekologi Prancis dan mengumpulkan botol</a></li>
<li><a href="../id459530/index.html">Mikrobiota. Sejarah studi dan metode penelitian</a></li>
<li><a href="../id459532/index.html">Cara memilih nomor acak dari 1 hingga 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>