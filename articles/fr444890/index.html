<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏼 🧙🏾 🙀 Douzaine d'astuces avec le shell Linux qui pourraient vous faire gagner du temps 🙍 🔌 🙆🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Tout d'abord, vous pouvez lire cet article en russe ici . 
 Un soir, je lisais les expressions régulières Mastering de Jeffrey Friedl , j'ai réalisé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Douzaine d'astuces avec le shell Linux qui pourraient vous faire gagner du temps</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444890/"><div style="text-align:center;"><img width="90%" src="https://habrastorage.org/webt/fs/43/05/fs4305wjukd5umg71ochqeqxxek.png"></div><br><br><ul><li>  <i>Tout d'abord, vous pouvez lire cet article en russe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .</i> </li></ul><br>  Un soir, je lisais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les expressions régulières Mastering de Jeffrey Friedl</a> , j'ai réalisé que même si vous avez toute la documentation et beaucoup d'expérience, il pourrait y avoir beaucoup de trucs développés par différentes personnes et emprisonnés pour eux-mêmes.  Tout le monde est différent.  Et les techniques qui sont évidentes pour certaines personnes peuvent ne pas être évidentes pour d'autres et ressembler à une sorte de magie étrange pour une troisième personne.  Soit dit en passant, j'ai déjà décrit plusieurs de ces moments <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici (en russe)</a> . <br><br>  Pour l'administrateur ou l'utilisateur, la ligne de commande n'est pas seulement un outil qui peut tout faire, mais aussi un outil hautement personnalisé qui pourrait être développé à jamais.  Récemment, il y a eu un article traduit sur quelques astuces utiles dans CLI.  Mais je pense que le traducteur n'a pas assez d'expérience avec CLI et n'a pas suivi les astuces décrites, donc beaucoup de choses importantes pourraient être manquées ou mal comprises. <br><br>  Under the cut - une douzaine de trucs dans le shell Linux à partir de mon expérience personnelle. <br><a name="habracut"></a><br>  Remarque: Tous les scripts et exemples de l'article ont été spécialement simplifiés autant que possible - donc peut-être que vous pouvez trouver plusieurs astuces qui semblent complètement inutiles - c'est peut-être la raison.  Mais en tout cas, partagez votre esprit dans les commentaires! <br><br><h4>  1. Fractionner la chaîne avec des extensions variables </h4><br>  Les gens utilisent souvent <b>couper</b> ou même <b>awk</b> juste pour soustraire une partie de la chaîne par motif ou avec des séparateurs. <br>  De plus, beaucoup de gens utilisent l'opération bash de sous-chaîne en utilisant $ {VARIABLE: start_position: length}, qui fonctionne très rapidement. <br><br>  Mais bash fournit un moyen puissant de manipuler avec des chaînes de texte en utilisant #, ##,% et %% - il a appelé <i>les extensions de variable bash</i> . <br>  En utilisant cette syntaxe, vous pouvez couper le nécessaire par le modèle sans exécuter de commandes externes, donc cela fonctionnera très rapidement. <br><br>  L'exemple ci-dessous montre comment obtenir la troisième colonne (shell) de la chaîne où les valeurs séparées par deux points "username: homedir: shell" en utilisant <b>cut</b> ou en utilisant des extensions de variable (nous utilisons le masque <u>*:</u> et la commande ##, ce qui signifie: cut tous les caractères à gauche jusqu'au dernier deux-points trouvé): <br><br><pre><code class="bash hljs">$ STRING=<span class="hljs-string"><span class="hljs-string">"username:homedir:shell"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 3 shell $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${STRING##*:}</span></span></span><span class="hljs-string">"</span></span> shell</code> </pre> <br>  La deuxième option ne démarre pas le processus enfant ( <b>couper</b> ) et n'utilise pas du tout de tuyaux, ce qui devrait fonctionner beaucoup plus rapidement.  Et si vous utilisez le sous-système bash sur les fenêtres, où les tuyaux bougent à peine, la différence de vitesse sera <u>importante</u> . <br><br>  Voyons un exemple sur Ubuntu - exécutons notre commande en boucle 1000 fois <br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash STRING="Name:Date:Shell" echo "using cut" time for A in {1..1000} do cut -d ":" -f 3 &gt; /dev/null &lt;&lt;&lt;"$STRING" done echo "using ##" time for A in {1..1000} do echo "${STRING##*:}" &gt; /dev/null done</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Résultats</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./test.sh using cut real 0m0.950s user 0m0.012s sys 0m0.232s using <span class="hljs-comment"><span class="hljs-comment">## real 0m0.011s user 0m0.008s sys 0m0.004s</span></span></code> </pre></div></div><br>  La différence est plusieurs dizaines de fois! <br><br>  Bien sûr, l'exemple ci-dessus est trop artificiel.  Dans un exemple réel, nous ne travaillerons pas avec une chaîne statique, nous voulons lire un vrai fichier.  Et pour la commande ' <b>cut</b> ', nous redirigeons simplement / etc / passwd vers elle.  Dans le cas de ##, nous devons créer une boucle et lire le fichier en utilisant la commande interne ' <b>read</b> '.  Alors, qui gagnera cette affaire? <br><br><pre> <code class="bash hljs">$ cat test.sh <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash echo "using cut" time for count in {1..1000} do cut -d ":" -f 7 &lt;/etc/passwd &gt; /dev/null done echo "using ##" time for count in {1..1000} do while read do echo "${REPLY##*:}" &gt; /dev/null done &lt;/etc/passwd done</span></span></code> </pre><div class="spoiler">  <b class="spoiler_title">Résultat</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./test.sh $ ./test.sh using cut real 0m0.827s user 0m0.004s sys 0m0.208s using <span class="hljs-comment"><span class="hljs-comment">## real 0m0.613s user 0m0.436s sys 0m0.172s</span></span></code> </pre>  Pas de commentaires =) </div></div><br>  Quelques exemples supplémentaires: <br><br>  Extrayez la valeur après un caractère égal: <br><br><pre> <code class="bash hljs">$ VAR=<span class="hljs-string"><span class="hljs-string">"myClassName = helloClass"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">${VAR##*= }</span></span> helloClass</code> </pre><br>  Extraire le texte entre crochets: <br><br><pre> <code class="bash hljs">$ VAR=<span class="hljs-string"><span class="hljs-string">"Hello my friend (enemy)"</span></span> $ TEMP=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${VAR##*\(}</span></span></span><span class="hljs-string">"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${TEMP%\)}</span></span></span><span class="hljs-string">"</span></span> enemy</code> </pre><br><h4>  2. Bash autocompletion with tab </h4><br>  Le paquet bash-complétement fait partie de presque toutes les distributions Linux.  Vous pouvez l'activer dans /etc/bash.bashrc ou /etc/profile.d/bash_completion.sh, mais il est généralement déjà activé par défaut.  En général, la saisie semi-automatique est l'un des premiers moments pratiques sur le shell Linux que rencontre tout d'abord un nouveau venu. <br><br>  Mais le fait que tout le monde n'utilise pas toutes les fonctionnalités de complétion de bash, et à mon avis, est complètement vain.  Par exemple, tout le monde ne sait pas que la saisie semi-automatique fonctionne non seulement avec les noms de fichiers, mais aussi avec les alias, les noms de variables, les noms de fonctions et pour certaines commandes, même avec des arguments.  Si vous creusez dans des scripts de saisie semi-automatique, qui sont en fait des scripts shell, vous pouvez même <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ajouter la saisie semi-automatique</a> pour votre propre application ou script. <br>  Mais revenons aux alias. <br><br>  Vous n'avez pas besoin de modifier la variable PATH ou de créer des fichiers dans le répertoire spécifié pour exécuter l'alias.  Il vous suffit de les ajouter au profil ou au script de démarrage et de les exécuter de n'importe où. <br><br>  Habituellement, nous utilisons des lettres minuscules pour les fichiers et répertoires dans * nix, il peut donc être très confortable de créer des alias majuscules - dans ce cas, bash-complétera <s>devinera</s> votre commande presque avec une seule lettre: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TAsteriskLog=<span class="hljs-string"><span class="hljs-string">"tail -f /var/log/asteriks.log"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TMailLog=<span class="hljs-string"><span class="hljs-string">"tail -f /var/log/mail.log"</span></span> $ TA[tab]steriksLog $ TM[tab]ailLog</code> </pre> <br><h4>  3. Bash autocompletion with tab - partie 2 </h4><br>  Pour les cas plus compliqués, vous aimeriez probablement mettre vos scripts personnels dans $ HOME / bin. <br>  Mais nous avons des fonctions dans bash. <br><br>  Les fonctions ne nécessitent ni chemin ni fichiers séparés.  Et (attention) l'achèvement de bash fonctionne aussi avec les fonctions. <br><br>  Créons la fonction LastLogin dans .profile (n'oubliez pas de recharger .profile): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> LastLogin { STRING=$(last | head -n 1 | tr -s <span class="hljs-string"><span class="hljs-string">" "</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>) USER=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">" "</span></span> -f 1) IP=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$STRING</span></span></span><span class="hljs-string">"</span></span>|cut -d <span class="hljs-string"><span class="hljs-string">" "</span></span> -f 3) SHELL=$( grep <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string">"</span></span> /etc/passwd | cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 7) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"User: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string">, IP: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$IP</span></span></span><span class="hljs-string">, SHELL=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$SHELL</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br>  <i>(En fait, il n'y a pas d'importance à ce que fait cette fonction, c'est juste un exemple de script que nous pouvons mettre dans le script séparé ou même dans l'alias, mais la fonction pourrait être meilleure)</i> . <br><br>  Dans la console (veuillez noter que le nom de la fonction a une première lettre majuscule pour accélérer l'accomplissement de bash): <br><br><pre> <code class="bash hljs">$ L[tab]astLogin User: saboteur, IP: 10.0.2.2, SHELL=/bin/bash</code> </pre> <br><h4>  4.1.  Données sensibles </h4><br>  Si vous mettez de l'espace avant toute commande dans la console, il n'apparaîtra pas dans l'historique des commandes, donc si vous avez besoin de mettre un mot de passe en texte brut dans la commande, c'est une bonne façon d'utiliser cette fonctionnalité - regardez l'exemple ci-dessous, <i>echo "hello 2 "</i> n'apparaîtra pas dans l'historique: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> hello $ <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> 2 2011 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> 2012 <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> 2 $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"my password secretmegakey"</span></span> <span class="hljs-comment"><span class="hljs-comment"># there are two spaces before 'echo' my password secretmegakey $ history 2 2011 echo "hello" 2012 history 2</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">C'est facultatif</b> <div class="spoiler_text">  Il est généralement activé par défaut, mais vous pouvez configurer ce comportement dans la variable suivante: <br><br>  export HISTCONTROL = ignoreboth </div></div><br><br><h4>  4.2.  Données sensibles dans les arguments de ligne de commande </h4><br>  Vous souhaitez stocker certains scripts shell dans git pour les partager entre les serveurs, ou cela peut faire partie du script de démarrage de l'application.  Et vous voulez que ce script se connecte à la base de données ou fasse toute autre chose qui nécessite des informations d'identification. <br><br>  Bien sûr, c'est une mauvaise idée de stocker les informations d'identification dans le script lui-même, car git n'est pas sécurisé. <br><br>  Habituellement, vous pouvez utiliser des variables, qui étaient déjà définies dans les environnements cibles, et votre script ne contiendra pas les mots de passe lui-même. <br><br>  Par exemple, vous pouvez créer un petit script sur chaque environnement avec 700 autorisations et l'appeler à l'aide de la commande <b>source</b> du script principal: <br><br><pre> <code class="bash hljs">secret.sh PASSWORD=LOVESEXGOD</code> </pre><br><pre> <code class="bash hljs">myapp.sh <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ~/secret.sh sqlplus -l user/<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$PASSWORD</span></span></span><span class="hljs-string">"</span></span>@database:port/sid @mysqfile.sql</code> </pre> <br>  Mais ce n'est pas sûr. <br><br>  Si quelqu'un d'autre peut se connecter à votre hôte, il peut simplement exécuter la commande <b>ps</b> et voir votre processus sqlplus avec tous les arguments de la ligne de commande, y compris les mots de passe.  Ainsi, les outils sécurisés devraient généralement pouvoir lire les mots de passe / clés / données sensibles directement à partir des fichiers. <br><br>  Par exemple - <b>ssh</b> sécurisé n'a même aucune option pour fournir un mot de passe en ligne de commande.  Mais il peut lire la clé ssh à partir du fichier (et vous pouvez définir des autorisations sécurisées sur le fichier de clé ssh). <br><br>  Et les wgets non sécurisés ont une option "--password" qui vous permet de fournir un mot de passe en ligne de commande.  Et tout le temps que wget fonctionnera, tout le monde peut exécuter la commande ps et voir le mot de passe que vous avez fourni. <br><br>  De plus, si vous avez beaucoup de données sensibles et que vous souhaitez les contrôler depuis git, le seul moyen est le chiffrement.  Ainsi, vous ne mettez dans chaque environnement cible que le mot de passe principal et toutes les autres données que vous pouvez chiffrer et mettre à git.  Et vous pouvez travailler avec des données chiffrées à partir de la ligne de commande, en utilisant l'interface CLI openssl.  Voici un exemple pour chiffrer et déchiffrer à partir de la ligne de commande: <br><br>  Le fichier secret.key contient la clé principale - une seule ligne: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"secretpassword"</span></span> &gt; secret.key; chmod 600 secret.key</code> </pre> <br>  Permet d'utiliser aes-256-cbc pour crypter une chaîne: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"string_to_encrypt"</span></span> | openssl enc -pass file:secret.key -e -aes-256-cbc -a U2FsdGVkX194R0GmFKCL/krYCugS655yLhf8aQyKNcUnBs30AE5lHN5MXPjjSFML</code> </pre> <br>  Vous pouvez mettre cette chaîne cryptée dans n'importe quel fichier de configuration stocké dans git, ou n'importe quel autre endroit - sans secret.key, il est presque impossible de le décrypter. <br>  Pour décrypter exécuter la même commande, il suffit de remplacer -e par -d: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'U2FsdGVkX194R0GmFKCL/krYCugS655yLhf8aQyKNcUnBs30AE5lHN5MXPjjSFML'</span></span> | openssl enc -pass file:secret.key -d -aes-256-cbc -a string_to_encrypt</code> </pre> <br><h4>  5. La commande grep </h4><br>  Tout le monde devrait connaître la commande grep.  Et soyez amical avec les expressions régulières.  Et souvent, vous pouvez écrire quelque chose comme: <br><br><pre> <code class="bash hljs">tail -f application.log | grep -i error</code> </pre> <br>  Ou même comme ça: <br><br><pre> <code class="bash hljs">tail -f application.log | grep -i -P <span class="hljs-string"><span class="hljs-string">"(error|warning|failure)"</span></span></code> </pre> <br>  Mais n'oubliez pas que grep a beaucoup d'options merveilleuses.  Par exemple -v, qui annule votre recherche et affiche tous les messages sauf "info": <br><br><pre> <code class="bash hljs">tail -f application.log | grep -v -i <span class="hljs-string"><span class="hljs-string">"info"</span></span></code> </pre> <br>  Trucs supplémentaires: <br><br>  L'option -P est très utile, car par défaut grep utilise une "expression régulière de base:" assez obsolète, et -P active PCRE qui ne connaît même pas le regroupement. <br>  -i ignore la casse. <br>  --line-buffered analyse la ligne immédiatement au lieu d'attendre d'atteindre le tampon standard de 4k (utile pour tail -f | grep). <br><br>  Si vous connaissez bien l'expression régulière, avec --only-matching / -o vous pouvez vraiment faire de grandes choses en coupant du texte.  Il suffit de comparer les deux commandes suivantes pour extraire le shell de myuser: <br><br><pre> <code class="bash hljs">$ grep myuser /etc/passwd| cut -d <span class="hljs-string"><span class="hljs-string">":"</span></span> -f 7 $ grep -Po <span class="hljs-string"><span class="hljs-string">"^myuser(:.*){5}:\K.*"</span></span> /etc/passwd</code> </pre> <br>  La deuxième commande semble plus compilée, mais elle n'exécute que <b>grep</b> au lieu de <b>grep</b> et <b>cut</b> , donc son exécution prendra moins de temps. <br><br><h4>  6. Comment réduire la taille du fichier journal </h4><br>  Dans * nix, si vous supprimez le fichier journal, qui est actuellement utilisé par une application, vous ne pouvez pas simplement supprimer tous les journaux, vous pouvez empêcher l'application d'écrire de nouveaux journaux jusqu'au redémarrage. <br><br>  Parce que le descripteur de fichier n'ouvre pas le nom du fichier, mais la structure iNode, et l'application continuera à écrire dans le descripteur de fichier dans le fichier, qui n'a pas d'entrée de répertoire, et ce fichier sera supprimé automatiquement après l'arrêt de l'application par le système de fichiers ( <i>votre application peut ouvrir et fermer le fichier journal à chaque fois qu'il souhaite écrire quelque chose pour éviter un tel problème, mais cela affecte les performances</i> ). <br><br>  Alors, comment effacer le fichier journal sans le supprimer: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> &gt; application.log</code> </pre> <br>  Ou nous pouvons utiliser la commande tronquer: <br><br><pre> <code class="bash hljs">truncate --size=1M application.log</code> </pre> <br>  Mentionnez, cette commande <b>tronquer</b> supprimera le reste du fichier, vous perdrez donc les derniers événements du journal.  Vérifiez un autre exemple comment stocker les 1000 dernières lignes: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(tail -n 1000 application.log)</span></span></span><span class="hljs-string">"</span></span> &gt; application.log</code> </pre> <br>  <i>PS Sous Linux, nous avons un journal de service standard.</i>  <i>Vous pouvez ajouter vos journaux à la troncature / rotation automatisée ou utiliser les bibliothèques de journaux existantes qui peuvent le faire pour vous (comme log4j en java).</i> <br><br><h4>  7. <b>Watch</b> vous attend! </h4><br>  Il y a une situation où vous attendez la fin d'un événement.  Par exemple, pendant qu'un autre utilisateur se connecte au shell (vous exécutez continuellement la commande <b>who</b> ), ou que quelqu'un doit copier le fichier sur votre machine à l'aide de scp ou ftp et que vous attendez l'achèvement (en répétant ls des dizaines de fois). <br><br>  Dans de tels cas, vous pouvez utiliser <br><br><pre> <code class="bash hljs">watch &lt;<span class="hljs-built_in"><span class="hljs-built_in">command</span></span>&gt;</code> </pre> <br>  Par défaut, sera exécuté toutes les 2 secondes avec pré-effacement de l'écran jusqu'à ce que Ctrl + C soit pressé.  Vous pouvez configurer la fréquence d'exécution. <br><br>  Il est très utile lorsque vous souhaitez consulter des journaux en direct. <br><br><h4>  8. Séquence de coup </h4><br>  Il existe une construction très utile pour créer des plages.  Par exemple, au lieu de quelque chose comme ça: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 1 2 3 4 5; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${srv}</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server1 server2 server3 server4 server5</code> </pre> <br>  Vous pouvez écrire ce qui suit: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> server{1..5}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$srv</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server1 server2 server3 server4 server5</code> </pre> <br>  Vous pouvez également utiliser la commande <b>seq</b> pour générer des plages formatées.  Par exemple, nous pouvons utiliser <b>seq</b> pour créer des valeurs qui seront automatiquement ajustées en largeur (00, 01 au lieu de 0, 1): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> srv <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $(seq -w 5 10); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"server</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${srv}</span></span></span><span class="hljs-string">"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">done</span></span> server05 server06 server07 server08 server09 server10</code> </pre> <br>  Un autre exemple avec la substitution de commandes - renommer des fichiers.  Pour obtenir le nom de fichier sans extension, nous <b>utilisons</b> la commande ' <b>basename</b> ': <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> *.txt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> name=$(basename <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$file</span></span></span><span class="hljs-string">"</span></span> .txt);mv <span class="hljs-variable"><span class="hljs-variable">$name</span></span>{.txt,.lst}; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Encore plus court avec '%': <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> *.txt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> mv <span class="hljs-variable"><span class="hljs-variable">${file%.txt}</span></span>{.txt,.lst}; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  PS En fait, pour renommer les fichiers, vous pouvez essayer l'outil « <b>renommer</b> » qui a beaucoup d'options. <br><br>  Un autre exemple - permet de créer une structure pour un nouveau projet java: <br><br><pre> <code class="bash hljs">mkdir -p project/src/{main,<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>}/{java,resources}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Résultat</b> <div class="spoiler_text"><pre> <code class="python hljs">project/ !--- src/ |--- main/ | |-- java/ | !-- resources/ !--- test/ |-- java/ !-- resources/</code> </pre> </div></div><br><h4>  9. queue, plusieurs fichiers, plusieurs utilisateurs ... </h4><br>  J'ai mentionné le <b>multitail</b> pour lire des fichiers et regarder plusieurs journaux en direct.  Mais il n'est pas fourni par défaut, et les autorisations pour installer quelque chose ne sont pas toujours disponibles. <br><br>  Mais la queue standard peut aussi le faire: <br><br><pre> <code class="bash hljs">tail -f /var/logs/*.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span></code> </pre> <br>  Permet également de se souvenir des utilisateurs, qui utilisent des alias «tail -f» pour surveiller les journaux des applications. <br>  Plusieurs utilisateurs peuvent regarder les fichiers journaux simultanément en utilisant «tail -f».  Certains d'entre eux ne sont pas très précis avec leurs sessions.  Ils pourraient laisser «queue -f» en arrière-plan pour une raison quelconque et l'oublier. <br><br>  Si l'application a été redémarrée, il existe ces processus «tail -f» en cours d'exécution qui surveillent un fichier journal inexistant qui peut se bloquer pendant plusieurs jours, voire plusieurs mois. <br><br>  Habituellement, ce n'est pas un gros problème, mais pas proprement. <br><br>  Dans le cas, si vous utilisez un alias pour regarder le journal, vous pouvez modifier cet alias avec l'option --pid: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> TFapplog=<span class="hljs-string"><span class="hljs-string">'tail -f --pid=$(cat /opt/app/tmp/app.pid) /opt/app/logs/app.log'</span></span></code> </pre> <br>  Dans ce cas, toutes les <b>queues</b> seront automatiquement terminées lorsque l'application cible sera redémarrée. <br><br><h4>  10. Créer un fichier avec une taille spécifiée </h4><br>  <b>dd</b> était l'un des outils les plus populaires pour travailler avec des données de blocs et binaires.  Par exemple, créer un fichier de 1 Mo rempli de zéro sera: <br><br><pre> <code class="bash hljs">dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=out.txt bs=1M count=10</code> </pre> <br>  Mais je recommande d'utiliser <b>fallocate</b> : <br><br><pre> <code class="bash hljs">fallocate -l 10M file.txt</code> </pre> <br>  Sur les systèmes de fichiers, qui prennent en charge la fonction d'allocation (xfs, ext4, Btrfs ...), <b>fallocate</b> sera exécuté instantanément, contrairement à l'outil dd.  De plus, allouer signifie une allocation réelle de blocs, pas la création d'un fichier de rechange. <br><br><h4>  11. xargs </h4><br>  Beaucoup de gens connaissent la commande <b>xargs</b> .  Mais tous n'utilisent pas les deux options suivantes, ce qui pourrait grandement améliorer votre script. <br><br>  Premièrement - vous pouvez obtenir une très longue liste d'arguments à traiter, et cela pourrait dépasser la longueur de la ligne de commande (par défaut ~ 4 ko). <br><br>  Mais vous pouvez limiter l'exécution en utilisant l'option -n, donc <b>xargs</b> exécutera la commande plusieurs fois, en envoyant un nombre spécifié d'arguments à la fois: <br><br><pre> <code class="bash hljs">$ <span class="hljs-comment"><span class="hljs-comment"># lets print 5 arguments and send them to echo with xargs: $ echo 1 2 3 4 5 | xargs echo 1 2 3 4 5 $ # now let's repeat, but limit argument processing by 3 per execution $ echo 1 2 3 4 5 | xargs -n 3 echo 1 2 3 4 5</span></span></code> </pre> <br>  Allez-y.  Le traitement d'une longue liste peut prendre beaucoup de temps, car il s'exécute dans un seul thread.  Mais si nous avons plusieurs cœurs, nous pouvons dire à <b>xargs</b> de fonctionner en parallèle: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 2 3 4 5 6 7 8 9 10| xargs -n 2 -P 3 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br>  Dans l'exemple ci-dessus, nous demandons à <b>xargs</b> de traiter la liste en 3 threads;  chaque thread prendra et traitera 2 arguments par exécution.  Si vous ne savez pas combien de cœurs vous avez, optimisons ceci en utilisant " <b>nproc</b> ": <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 2 3 4 5 6 7 8 9 10 | xargs -n 2 -P $(nproc) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span></code> </pre> <br><h4>  12. dormir?  tout?  lisez! </h4><br>  Un certain temps, vous devez attendre plusieurs secondes.  Ou attendez l'entrée utilisateur avec lecture: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -p <span class="hljs-string"><span class="hljs-string">"Press any key to continue "</span></span> -n 1</code> </pre> <br>  Mais vous pouvez simplement ajouter une option de délai d'attente à la commande de <b>lecture</b> , et votre script sera mis en pause pendant un nombre spécifié de secondes, mais en cas d'exécution interactive, l'utilisateur peut facilement ignorer l'attente. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -p <span class="hljs-string"><span class="hljs-string">"Press any key to continue (auto continue in 30 seconds) "</span></span> -t 30 -n 1</code> </pre> <br>  Vous pouvez donc oublier la commande sleep. <br><br>  Je soupçonne que toutes mes astuces ne semblent pas intéressantes, mais il me semble qu'une douzaine sont un bon nombre à remplir. <br><br>  Sur ce, je dis au revoir et je serai reconnaissant d'avoir participé à l'enquête. <br><br>  Bien sûr, n'hésitez pas à discuter de ce qui précède et à partager vos trucs sympas dans les commentaires! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444890/">https://habr.com/ru/post/fr444890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444880/index.html">Une interprétation multi-monde de la mécanique quantique</a></li>
<li><a href="../fr444882/index.html">Les banques ont commencé à bloquer les comptes indépendants</a></li>
<li><a href="../fr444884/index.html">Groovy a quitté Cédric Champeau</a></li>
<li><a href="../fr444886/index.html">Applications d'ingénierie inverse après obscurcissement</a></li>
<li><a href="../fr444888/index.html">Anglais et informatique: Chouette anglaise sur un globe russe?</a></li>
<li><a href="../fr444892/index.html">Un fraudeur américain a gagné des millions de dollars en se faisant passer pour le support technique de Microsoft</a></li>
<li><a href="../fr444894/index.html">Sortie de Zabbix 4.2</a></li>
<li><a href="../fr444896/index.html">Recyclage des disques durs en tant que courrier indésirable électronique - Solution partielle d'iNEMI</a></li>
<li><a href="../fr444898/index.html">Comment choisir un modem à large bande pour un véhicule aérien sans pilote (UAV) ou la robotique</a></li>
<li><a href="../fr444900/index.html">Validation de formulaire dans Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>