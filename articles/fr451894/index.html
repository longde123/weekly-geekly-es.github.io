<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåø üë©‚Äçüíº üí± Un aper√ßu bref et dynamique de l'architecture du compilateur üî± üí£ üïï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La plupart des compilateurs ont l'architecture suivante: 



 Dans cet article, je vais d√©tailler cette architecture en d√©tail, √©l√©ment par √©l√©ment. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un aper√ßu bref et dynamique de l'architecture du compilateur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/451894/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ej/-i/slej-ivpokabgczeqdbgiafc0rw.jpeg"></div><br>  La plupart des compilateurs ont l'architecture suivante: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73e/ff7/c46/73eff7c467213f5de1b9134666f9e569.png"><br><br>  Dans cet article, je vais d√©tailler cette architecture en d√©tail, √©l√©ment par √©l√©ment. <br>  Nous pouvons dire que cet article est un ajout √† l'√©norme quantit√© de ressources existantes sur le sujet des compilateurs.  C'est une source autonome qui vous permettra de comprendre les bases de la conception et de l'impl√©mentation des langages de programmation. <br><br>  Le public cible de l'article est constitu√© de personnes dont l'id√©e du travail des compilateurs est extr√™mement limit√©e (le maximum est qu'ils participent √† la compilation).  Cependant, je m'attends √† ce que le lecteur comprenne les structures de donn√©es et les algorithmes. <br><br>  L'article n'est en aucun cas consacr√© aux compilateurs de production modernes avec des millions de lignes de code - non, il s'agit d'un court cours ¬´compilateurs pour les nuls¬ª pour vous aider √† comprendre ce qu'est un compilateur. <br><a name="habracut"></a><br><h2>  Pr√©sentation </h2><br>  Je travaille actuellement sur le langage du syst√®me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Krug</a> inspir√© de Rust and Go.  Dans l'article, je ferai r√©f√©rence √† Krug comme exemple pour illustrer mes pens√©es.  Krug est en cours de d√©veloppement, mais est d√©j√† disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/krug-lang</a> dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rentiels caasper</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">krug</a> .  Le langage n'est pas tout √† fait typique par rapport √† l'architecture de compilation habituelle, ce qui m'a en partie inspir√© √† √©crire un article - mais plus √† ce sujet plus tard. <br><br>  Je m'empresse de vous informer que je ne suis en aucun cas un sp√©cialiste des compilateurs!  Je n'ai pas de doctorat et je n'ai suivi aucune formation formelle - j'ai moi-m√™me √©tudi√© tout ce qui est d√©crit dans l'article pendant mon temps libre.  Je dois √©galement dire que je ne d√©cris pas la v√©ritable approche, juste pour cr√©er un compilateur, mais plut√¥t, je pr√©sente les m√©thodes de base appropri√©es pour cr√©er un petit compilateur "jouet". <br><br><h2>  Frontend </h2><br>  Revenons au diagramme ci-dessus: les fl√®ches √† gauche dirig√©es vers le champ frontal sont des langages bien connus et aim√©s comme C. Le frontal ressemble √† ceci: analyse lexicale -&gt; analyseur. <br><br><h2>  Analyse lexicale </h2><br>  Quand j'ai commenc√© √† √©tudier les compilateurs et la conception de langages, on m'a dit que l'analyse lexicale √©tait la m√™me que la tokenisation.  Nous utiliserons cette description.  L'analyseur prend les donn√©es d'entr√©e sous la forme de cha√Ænes ou d'un flux de caract√®res et reconna√Æt les mod√®les en eux, qu'il coupe en jetons. <br><br>  Dans le cas d'un compilateur, il re√ßoit un programme √©crit en entr√©e.  Il est lu dans une cha√Æne √† partir d'un fichier et l'analyseur tokenise son code source. <br><br><pre><code class="plaintext hljs">enum TokenType { Identifier, Number, }; struct Token { std::string Lexeme; TokenType type; // ... // It's also handy to store things in here // like the position of the token (start to end row:col) };</code> </pre> <br>  Dans ce fragment, √©crit dans un langage en forme de C, vous pouvez voir la structure contenant le lex√®me susmentionn√©, ainsi que TokenType, qui sert √† reconna√Ætre ce jeton. <br><br>  Remarque: l'article n'est pas une instruction pour cr√©er un langage avec des exemples - mais pour une meilleure compr√©hension, je vais ins√©rer de temps en temps des extraits de code. <br><br>  Les analyseurs sont g√©n√©ralement les composants de compilation les plus simples.  L'ensemble du frontend, en fait, est assez simple par rapport au reste des pi√®ces du puzzle.  Bien que cela d√©pende beaucoup de votre travail. <br><br>  Prenez le morceau de code C suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello world!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Apr√®s l'avoir lu d'un fichier sur une ligne et effectu√© un scan lin√©aire, vous pourrez peut-√™tre d√©couper des jetons.  Nous identifions les jetons de mani√®re naturelle - vu que int est un "mot", et 0 dans la d√©claration de retour est un "nombre".  L'analyseur lexical ex√©cute la m√™me proc√©dure que nous - plus tard, nous examinerons ce processus plus en d√©tail.  Par exemple, analysez les chiffres: <br><br><pre> <code class="plaintext hljs">0xdeadbeef ‚Äî HexNumber ( ) 1231234234 ‚Äî WholeNumber ( ) 3.1412 ‚Äî FloatingNumber (   ) 55.5555 ‚Äî FloatingNumber (   ) 0b0001 ‚Äî BinaryNumber ( )</code> </pre> <br>  D√©finir des mots peut √™tre difficile.  La plupart des langues d√©finissent un mot comme une s√©quence de lettres et de chiffres, et un identifiant doit g√©n√©ralement commencer par une lettre ou un trait de soulignement.  Par exemple: <br><br><pre> <code class="plaintext hljs">123foobar := 3 person-age := 5 fmt.Println(123foobar)</code> </pre> <br>  Dans Go, ce code ne sera pas consid√©r√© comme correct et sera analys√© dans les jetons suivants: <br><br><pre> <code class="plaintext hljs">Number(123), Identifier(foobar), Symbol(:=), Number(3) ...</code> </pre> <br>  La plupart des identifiants rencontr√©s ressemblent √† ceci: <br><br><pre> <code class="plaintext hljs">foo_bar __uint8_t fooBar123</code> </pre> <br>  Les analyseurs devront r√©soudre d'autres probl√®mes, par exemple, avec les espaces, les commentaires multilignes et unifilaires, les identifiants, les nombres, les syst√®mes de num√©rotation et la mise en forme des nombres (par exemple, 1_000_000) et les encodages (par exemple, la prise en charge d'UTF8 au lieu d'ASCII). <br><br>  Et si vous pensez que vous pouvez recourir √† des expressions r√©guli√®res - mieux vaut ne pas la peine.  Il est beaucoup plus facile d'√©crire un analyseur √† partir de z√©ro, mais je recommande fortement de lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> de notre roi et dieu Rob Pike.  Les raisons pour lesquelles Regex ne nous convient pas sont d√©crites dans de nombreux autres articles, je vais donc omettre ce point.  De plus, √©crire un analyseur est beaucoup plus int√©ressant que de vous tourmenter avec de longues expressions verbeuses t√©l√©charg√©es sur regex101.com √† 5 h 24.  Dans ma premi√®re langue, j'utilisais la fonction <code>split(str)</code> pour la tokenisation - et je n'allais pas loin. <br><br><h2>  Analyse </h2><br>  L'analyse est un peu plus compliqu√©e que l'analyse lexicale.  Il existe de nombreux analyseurs et g√©n√©rateurs d'analyseurs - ici, le jeu commence de mani√®re spectaculaire. <br><br>  Les analyseurs dans les compilateurs prennent g√©n√©ralement des entr√©es sous forme de jetons et construisent un arbre sp√©cifique - un arbre de syntaxe abstraite ou un arbre d'analyse.  De par leur nature, ils sont similaires, mais pr√©sentent quelques diff√©rences. <br><br>  Ces √©tapes peuvent √™tre repr√©sent√©es comme des fonctions: <br><br><pre> <code class="plaintext hljs">fn lex(string input) []Token {...} fn parse(tokens []Token) AST {...} let input = "int main() { return 0; }"; let tokens = lex(input); let parse_tree = parse(tokens); // ....</code> </pre> <br>  En r√®gle g√©n√©rale, les compilateurs sont construits √† partir de nombreux petits composants qui prennent des entr√©es, les modifient ou les convertissent en diff√©rentes sorties.  C'est l'une des raisons pour lesquelles les langages fonctionnels sont bien adapt√©s √† la cr√©ation de compilateurs.  D'autres raisons sont une excellente analyse comparative et des biblioth√®ques standard assez √©tendues.  Fait amusant: la premi√®re impl√©mentation du compilateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rust</a> √©tait sur Ocaml. <br><br>  Je vous conseille de garder ces composants aussi simples et autonomes que possible - la modularit√© facilitera grandement le processus.  √Ä mon avis, on peut en dire autant de nombreux autres aspects du d√©veloppement logiciel. <br><br><h2>  Les arbres </h2><br><h4>  Analyser l'arbre </h4><br>  Qu'est-ce que c'est que √ßa?  √âgalement connu sous le nom d'arbre d'analyse, cet arbre √©pais sert √† visualiser le programme source.  Ils contiennent toutes les informations (ou la plupart) sur le programme d'entr√©e, g√©n√©ralement les m√™mes que celles d√©crites dans la grammaire de votre langue.  Chaque n≈ìud d'arbre sera en fin ou non en fin, par exemple, NumberConstant ou StringConstant. <br><br><h4>  Arbre de syntaxe abstraite </h4><br>  Comme son nom l'indique, l'ASD est un arbre de syntaxe <i>abstraite</i> .  L'arbre d'analyse contient beaucoup d'informations (souvent redondantes) sur votre programme, et dans le cas d'un ASD, il n'est pas n√©cessaire.  ASD n'a pas besoin d'informations inutiles sur la structure et la grammaire, ce qui n'affecte pas la s√©mantique du programme. <br><br>  Supposons que votre arbre ait une expression comme ((5 + 5) -3) +2.  Dans l'arbre d'analyse, vous le stockeriez compl√®tement, avec les crochets, les op√©rateurs et les valeurs 5, 5, 3 et 2. Mais vous pouvez simplement vous associer √† l'ASD - nous n'avons besoin que de conna√Ætre les valeurs, les op√©rateurs et leur ordre. <br><br>  L'image ci-dessous montre l'arbre de l'expression a + b / c. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98c/61a/cb3/98c61acb355e7887b53b5c37de0aa34f.png" width="400"></div><br>  L'ASD peut √™tre repr√©sent√© comme suit: <br><br><pre> <code class="plaintext hljs">interface Expression { ... }; struct UnaryExpression { Expression value; char op; }; struct BinaryExpression { Expression lhand, rhand; string op; // string because the op could be more than 1 char. }; interface Node { ... }; // or for something like a variable struct Variable : Node { Token identifier; Expression value; };</code> </pre> <br>  Cette vue est assez limit√©e, mais j'esp√®re que vous pourrez voir comment vos n≈ìuds seront structur√©s.  Pour l'analyse, vous pouvez recourir √† la proc√©dure suivante: <br><br><pre> <code class="plaintext hljs">Node parseNode() { Token current = consume(); switch (current.lexeme) { case "var": return parseVariableNode(); // ... } panic("unrecognized input!"); } Node n = parseNode(); if (n != null) { // append to some list of top level nodes? // or append to a block of nodes! }</code> </pre> <br>  J'esp√®re que vous obtiendrez l'essentiel de la fa√ßon dont l'analyse pas √† pas des n≈ìuds restants se d√©roulera, en commen√ßant par les constructions de langage de haut niveau.  Comment exactement un analyseur avec une descente r√©cursive est mis en ≈ìuvre, vous devez vous √©tudier. <br><br><h2>  La grammaire </h2><br>  L'analyse dans un ADS √† partir d'un ensemble de jetons peut √™tre difficile.  Habituellement, vous devriez commencer par la grammaire de votre langue.  En substance, la grammaire d√©termine la structure de votre langue.  Il existe plusieurs langages pour d√©finir des langages qui peuvent se d√©crire (ou s'analyser) eux-m√™mes. <br><br>  Un exemple de langage pour d√©terminer les langues est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">forme √©tendue de Backus-Naur</a> (RBNF).  Il s'agit d'une variante du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BNF</a> avec moins de supports d'angle.  Voici un exemple RBNF d'un article de Wikipedia: <br><br><pre> <code class="plaintext hljs">digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ; digit = "0" | digit excluding zero ;</code> </pre> <br>  Des r√®gles de production sont d√©finies: elles indiquent quel mod√®le de terminal est ¬´non terminal¬ª.  Les terminaux font partie de l'alphabet, par exemple, le jeton if ou 0 et 1 dans l'exemple ci-dessus sont des terminaux.  Les non-terminaux sont leur contraire, ils sont du c√¥t√© gauche des r√®gles de production, et ils peuvent √™tre consid√©r√©s comme des variables ou des ¬´pointeurs nomm√©s¬ª vers des groupes de terminaux et de non-terminaux. <br><br>  De nombreuses langues ont des sp√©cifications qui contiennent de la grammaire.  Par exemple, pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Go</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rust</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D.</a> <br><br><h2>  Analyseurs de descente r√©cursive </h2><br>  La descente r√©cursive est la plus simple des nombreuses approches d'analyse. <br><br>  Analyseurs de descente r√©cursive - descendants, bas√©s sur des proc√©dures r√©cursives.  Il est beaucoup plus facile d'√©crire un analyseur, car votre grammaire n'a pas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">laiss√© de r√©cursivit√©</a> .  Dans la plupart des langues "jouets", cette technique est suffisante pour l'analyse.  GCC utilise un analyseur descendant manuscrit, bien que YACC ait √©t√© utilis√© auparavant. <br><br>  Cependant, l'analyse de ces langues peut entra√Æner des probl√®mes.  En particulier, C, o√π <br><br><pre> <code class="cpp hljs">foo * bar</code> </pre> <br>  peut √™tre interpr√©t√© comme <br><br><pre> <code class="plaintext hljs">int foo = 3; int bar = 4; foo * bar; // unused expression</code> </pre> <br>  ou comment <br><br><pre> <code class="plaintext hljs">typedef struct { int b; } foo; foo* bar; bar.b = 3;</code> </pre> <br>  L'impl√©mentation Clang utilise √©galement un analyseur de descente r√©cursive: <br><br>  <i>Comme il s'agit de code C ++ normal, une descente r√©cursive permet aux d√©butants de le comprendre facilement.</i>  <i>Il prend en charge des r√®gles personnalis√©es et d'autres choses √©tranges requises par C / C ++ et vous aide √† diagnostiquer et √† corriger facilement les erreurs.</i> <br><br>  Il convient √©galement de pr√™ter attention √† d'autres approches: <br><br><ul><li>  LL d√©croissant, descente r√©cursive </li><li>  ascendant LR, d√©calage, descente ascendante </li></ul><br><h2>  G√©n√©rateurs d'analyseurs </h2><br>  Un autre bon moyen.  Bien s√ªr, il y a aussi des inconv√©nients - mais cela peut √™tre dit de tout autre choix que les programmeurs font lors de la cr√©ation de logiciels. <br><br>  Les g√©n√©rateurs d'analyseurs fonctionnent tr√®s rapidement.  Il est plus facile de les utiliser que d'√©crire votre propre analyseur et d'obtenir un r√©sultat de qualit√© - bien qu'ils ne soient pas tr√®s conviviaux et n'affichent pas toujours des messages d'erreur.  De plus, vous devrez apprendre √† utiliser le g√©n√©rateur d'analyseur et lors de la promotion du compilateur, vous devrez probablement d√©rouler le g√©n√©rateur d'analyseur. <br><br>  Un exemple de g√©n√©rateur d'analyseur est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ANTLR</a> , il y en a beaucoup d'autres. <br><br>  Je pense que cet outil convient √† ceux qui ne veulent pas passer du temps √† √©crire un frontend, et qui pr√©f√®rent √©crire le milieu et le backend du compilateur / interpr√®te et analyser quoi que ce soit. <br><br><h2>  Application d'analyse </h2><br>  Si vous ne vous comprenez toujours pas.  M√™me le frontend du compilateur (lex / parse) peut √™tre utilis√© pour r√©soudre d'autres probl√®mes: <br><br><ul><li>  coloration syntaxique </li><li>  Analyse HTML / CSS pour le moteur de rendu </li><li>  transpilers: TypeScript, CoffeeScript </li><li>  linkers </li><li>  REGEX </li><li>  analyse des donn√©es d'interface </li><li>  Analyse d'URL </li><li>  des outils de formatage comme <i>gofmt</i> </li><li>  Analyse SQL et plus encore. </li></ul><br><h2>  Mid </h2><br>  Analyse s√©mantique!  L'analyse de la s√©mantique du langage est l'une des t√¢ches les plus difficiles lors de la cr√©ation d'un compilateur. <br><br>  Vous devez vous assurer que tous les programmes d'entr√©e fonctionnent correctement.  Dans mon langage Krug, les aspects li√©s √† l'analyse s√©mantique n'ont pas encore √©t√© inclus, et sans cela, le programmeur devra toujours √©crire le bon code.  En r√©alit√©, cela est impossible - et nous √©crivons, compilons, parfois ex√©cutons, corrigeons toujours les erreurs.  Cette spirale est sans fin. <br><br>  De plus, la compilation de programmes est impossible sans une analyse de l'exactitude de la s√©mantique au stade appropri√© de la compilation. <br><br>  Une fois, je suis tomb√© sur un graphique sur le pourcentage de front-end, mid -land et backend.  Ensuite, √ßa ressemblait <br><br><pre> <code class="plaintext hljs">F: 20% M: 20%: B: 60%</code> </pre> <br>  Aujourd'hui, c'est quelque chose comme <br><br><pre> <code class="plaintext hljs">F: 5% M: 60% B: 35%</code> </pre> <br>  L'interface concerne principalement le g√©n√©rateur, et dans les langages sans contexte qui n'ont pas la dualit√© de grammaire, ils peuvent √™tre compl√©t√©s assez rapidement - une descente r√©cursive aidera ici. <br><br>  Avec la technologie LLVM, la plupart des travaux d'optimisation peuvent √™tre t√©l√©charg√©s dans le framework, qui pr√©sente un certain nombre d'optimisations pr√™tes √† l'emploi. <br><br>  L'√©tape suivante est l'analyse s√©mantique, une partie essentielle de la phase de compilation. <br><br>  Par exemple, dans Rust, avec son mod√®le de gestion de la m√©moire, le compilateur agit comme une grande machine puissante qui effectue divers types d'analyses statiques sur les formulaires d'introduction.  Une partie de cette t√¢che consiste √† convertir les donn√©es d'entr√©e sous une forme plus pratique pour l'analyse. <br><br>  Pour cette raison, l'analyse s√©mantique joue un r√¥le important dans l'architecture du compilateur, et le travail pr√©paratoire ext√©nuant comme l'optimisation de l'assemblage g√©n√©r√© ou la lecture des donn√©es d'entr√©e dans l'ASD est fait pour vous. <br><br><h2>  Passages s√©mantiques </h2><br>  Au cours de l'analyse s√©mantique, la plupart des compilateurs effectuent un grand nombre de ¬´passages s√©mantiques¬ª sur le SDA ou une autre forme abstraite d'expression de code.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cet article</a> fournit des d√©tails sur la plupart des passes effectu√©es dans le compilateur .NET C #. <br><br>  Je ne consid√©rerai pas chaque passage, d'autant plus qu'ils varient en fonction de la langue, mais plusieurs √©tapes sont d√©crites ci-dessous dans Krug. <br><br><h2>  Annonce de niveau sup√©rieur </h2><br>  Le compilateur passera par toutes les annonces "de haut niveau" dans les modules et sera conscient de leur existence.  Il n'ira pas plus loin dans les blocs - il d√©clarera simplement quelles structures, fonctions, etc.  sont disponibles dans l'un ou l'autre module. <br><br><h2>  R√©solution du nom / symbole </h2><br>  Le compilateur parcourt tous les blocs de code dans les fonctions, etc.  et les r√©sout - c'est-√†-dire, trouve les personnages qui n√©cessitent une autorisation.  Il s'agit d'un passage commun, et c'est d'ici que l'erreur <i>No such symbol XYZ</i> survient g√©n√©ralement lors de la compilation du code Go. <br><br>  L'ex√©cution de cette passe peut √™tre tr√®s difficile, surtout s'il existe des d√©pendances circulaires dans votre diagramme de d√©pendances.  Certaines langues ne les autorisent pas, par exemple, Go lancera une erreur si l'un de vos packages forme une boucle, comme ma langue Krug.  Les d√©pendances cycliques peuvent √™tre consid√©r√©es comme un effet secondaire d'une mauvaise architecture. <br><br>  Les boucles peuvent √™tre d√©termin√©es en modifiant DFS dans le diagramme de d√©pendance, ou en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme Tarjan</a> (comme l'a fait Krug) pour d√©finir des boucles (multiples). <br><br><h2>  Inf√©rence de type </h2><br>  Le compilateur parcourt toutes les variables et affiche leurs types.  L'inf√©rence de type dans Krug est tr√®s faible; elle g√©n√®re simplement des variables en fonction de leurs valeurs.  Ce n'est en aucun cas un syst√®me bizarre, comme ceux que vous pouvez trouver dans des langages fonctionnels comme Haskell. <br><br>  Les types peuvent √™tre d√©riv√©s en utilisant le processus ¬´unification¬ª ou ¬´unification de type¬ª.  Pour les syst√®mes de type plus simple, une impl√©mentation tr√®s simple peut √™tre utilis√©e. <br><br>  Les types sont impl√©ment√©s dans Krug comme ceci: <br><br><pre> <code class="plaintext hljs">interface Type {}; struct IntegerType : Type { int width; bool signed; }; struct FloatingType : Type { int width; }; struct ArrayType : Type { Type base_type; uint64 length; };</code> </pre> <br>  Vous pouvez √©galement avoir une inf√©rence de type simple, dans laquelle vous affectez un type aux n≈ìuds d'expression, par exemple, <code>IntegerConstantNode</code> peut √™tre de type IntegerType (64).  Et puis vous pouvez obtenir la fonction <code>unify(t1, t2)</code> , qui s√©lectionnera le type le plus large qui peut √™tre utilis√© pour d√©duire le type d'expressions plus complexes, disons, les expressions binaires.  Il s'agit donc d'affecter une variable √† gauche aux valeurs des types donn√©s √† droite. <br><br>  J'ai √©crit une fois un simple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">casting de type</a> sur Go, qui est devenu une impl√©mentation de prototype pour Krug. <br><br><h2>  Pass Mutabilit√© </h2><br>  Krug (comme Rust) est par d√©faut un langage immuable, c'est-√†-dire que les variables restent inchang√©es sauf indication contraire: <br><br><pre> <code class="plaintext hljs">let x = 3; x = 4; // BAD! mut y = 5; y = 6; // OK!</code> </pre> <br>  Le compilateur passe en revue tous les blocs et fonctions et v√©rifie que leurs ¬´variables sont correctes¬ª, c'est-√†-dire que nous ne changeons pas ce qui ne suit pas, et que toutes les variables pass√©es √† certaines fonctions sont constantes ou modifiables si n√©cessaire. <br><br>  Cela se fait √† l'aide d'informations symboliques qui ont √©t√© collect√©es lors des passes pr√©c√©dentes.  Une table de symboles bas√©e sur les r√©sultats de la passe s√©mantique contient des noms de jetons et des signes de variabilit√© variable.  Il peut contenir d'autres donn√©es, par exemple, en C ++, une table peut stocker des informations sur si un symbole est externe ou statique. <br><br><h2>  Tables de caract√®res </h2><br>  Une table de caract√®res, ou ¬´stab¬ª, est une table pour trouver les caract√®res utilis√©s dans votre programme.  Une table est cr√©√©e pour chaque √©tendue, et toutes contiennent des informations sur les caract√®res pr√©sents dans une √©tendue particuli√®re. <br><br>  Ces informations incluent des propri√©t√©s telles que le nom, le type, le signe de mutabilit√© du symbole, la pr√©sence d'une communication externe, l'emplacement dans la m√©moire statique, etc. <br><br><h3>  Port√©e </h3><br>  Il s'agit d'un concept important dans les langages de programmation.  Bien s√ªr, votre langue ne doit pas permettre de cr√©er des √©tendues imbriqu√©es, tout peut √™tre plac√© dans un m√™me espace de noms! <br><br>  Bien que la repr√©sentation de la port√©e soit une t√¢che int√©ressante pour l'architecture du compilateur, dans la plupart des langages de type C, la port√©e se comporte (ou est) comme une structure de donn√©es de pile. <br><br>  Habituellement, nous cr√©ons et d√©truisons des √©tendues, et elles sont g√©n√©ralement utilis√©es pour g√©rer les noms, c'est-√†-dire qu'elles nous permettent de masquer (l'observation) des variables: <br><br><pre> <code class="plaintext hljs">{ // push scope let x = 3; { // push scope let x = 4; // OK! } // pop scope } // pop scope</code> </pre> <br>  Il peut √™tre repr√©sent√© diff√©remment: <br><br><pre> <code class="plaintext hljs">struct Scope { Scope* outer; SymbolTable symbols; }</code> </pre> <br>  Un petit hors-sujet, mais je recommande de lire la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pile de spaghettis</a> .  Il s'agit d'une structure de donn√©es utilis√©e pour stocker des zones de visibilit√© dans les n≈ìuds ASD des blocs oppos√©s. <br><br><h2>  Syst√®mes de typage </h2><br>  Beaucoup des sections suivantes peuvent √™tre d√©velopp√©es dans des articles s√©par√©s, mais il me semble que ce titre m√©rite le plus.  Aujourd'hui, de nombreuses informations sont disponibles sur les syst√®mes de types, ainsi que sur les vari√©t√©s des syst√®mes eux-m√™mes, autour desquelles de nombreuses copies se brisent.  Je ne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m'attarderai</a> pas sur ce sujet, laissez simplement un lien vers l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">excellent article de Steve Klabnik</a> . <br><br>  Un syst√®me de type est ce qui est fourni et d√©fini s√©mantiquement dans le compilateur √† l'aide des repr√©sentations du compilateur et de l'analyse de ces repr√©sentations. <br><br><h2>  Possession </h2><br>  Ce concept est de plus en plus utilis√© dans la programmation.  Les principes de la s√©mantique de la propri√©t√© et du mouvement sont ancr√©s dans la langue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rust</a> , et j'esp√®re qu'ils appara√Ætront dans d'autres langues.  Rust effectue diff√©rents types d'analyses statiques, qui v√©rifient si l'entr√©e satisfait √† un ensemble de r√®gles concernant la m√©moire: qui poss√®de quelle m√©moire, quand la m√©moire est d√©truite et combien de r√©f√©rences (ou emprunts) existent √† ces valeurs ou √† la m√©moire. <br><br>  La beaut√© de Rust r√©side dans le fait que tout cela se fait pendant la compilation, √† l'int√©rieur du compilateur, afin que le programmeur n'ait pas √† g√©rer le garbage collection ou le comptage de liens.  Toutes ces s√©mantiques sont affect√©es au syst√®me de types et peuvent √™tre fournies avant m√™me que le programme ne soit pr√©sent√© sous la forme d'un fichier binaire complet. <br><br>  Je ne peux pas dire comment tout cela fonctionne sous le capot, mais tout cela est le r√©sultat d'une analyse statique et de merveilleuses recherches de l'√©quipe Mozilla et des participants au projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cyclone</a> . <br><br><h2>  Graphiques de flux de contr√¥le </h2><br>  Pour repr√©senter les flux de programme, nous utilisons des graphiques de flux de contr√¥le (CFG), qui contiennent tous les chemins que l'ex√©cution du programme peut suivre.  Ceci est utilis√© dans l'analyse s√©mantique pour exclure les sections de code inactives, c'est-√†-dire les blocs, les fonctions et m√™me les modules qui ne seront jamais atteints pendant l'ex√©cution du programme.  Les graphiques peuvent √©galement √™tre utilis√©s pour identifier les cycles qui ne peuvent pas √™tre interrompus.  Ou pour rechercher un code inaccessible, par exemple, lorsque vous appelez une ¬´panique¬ª (appelez une panique), ou que vous revenez dans une boucle, et que le code en dehors de la boucle ne s'ex√©cute pas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'analyse du flux de donn√©es</a> joue un r√¥le important pendant la phase s√©mantique du compilateur, je vous recommande donc de lire les types d'analyses que vous pouvez effectuer, leur fonctionnement et les optimisations possibles. <br><br><h2>  Backend </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/330/914/1b9/3309141b9d53be1d9e5c8f77fb46d982.jpg"><br>  <i>La derni√®re partie de notre sch√©ma d'architecture.</i> <br><br>  Nous avons fait la plupart du travail de g√©n√©ration de binaires ex√©cutables.  Cela peut √™tre fait de diff√©rentes mani√®res, dont nous discuterons ci-dessous. <br><br>        - ,   . ,     ,    ¬´¬ª. <br><br><h2>     </h2><br>   ,           . ,    ,      .   ,   ,         ,    .        ,      . <br><br>   ,           .  ,   ++ ‚Äî Cfront ‚Äî     C. <br><br>    JavaScript.     TypeScript    ,     ,   ,              ,         . <br><br>    ¬´¬ª ,     ,             ,       ,    ¬´  ¬ª  .        ‚Äî   ,        ,     . <br><br><h2> LLVM </h2><br>          LLVM: Rust, Swift, C/C++ (clang), D, Haskell. <br><br>    ¬´ ¬ª,             ,      .     , LLVM      .   ,       .  ,   ,     , , 1, 4, 8  16-.       ,  ,   -    . <br><br><h2>  - </h2><br>      ‚Äî     , ‚Äî     ,      . <br><br> Go ‚Äî    ,      LLVM (    ). Go     ,    Windows, Linux  MacOS. ,    Krug    -. <br><br>        .  ,     LLVM,     ,   ,        LLVM      ,     . <br><br>   ,        ,       ,        LLVM,      IR,    ,  , ,    (    ). <br><br>     .      ,         ,   ,       .       IR (    )  ¬´¬ª       fprintf   .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8cc</a> . <br><br><h2>   </h2><br>             .   ‚Äî Java:  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JVM</a>        , , Kotlin. <br><br>     ,   Java   .         ,           .            ,       . <br>   , JVM   JIT       ,     JIT-,     . <br><br><h2>  </h2><br>     ,      !      ,     ,   .   -          ,   ,   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Godbolt</a> ‚Äî  ,  ,             .       , ,     . <br><br>      ,         ,       (strip the debug symbols),  ,   GCC.     ,  -  . <br><br>            .       .    ,         .        production-. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>        rwmj ,    8  ,   80%     .        1971-!    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  ,  Rust. <br><br><h2> IR </h2><br>   (intermediate representation, IR)  ,  .      ,        ,     . <br><br>   IR     .      ,  ,    ,    . <br><br>    IR,  ¬´¬ª,       IR   . , SSA ‚Äî Static Single Assignment,   ,        . <br><br>  Go     IR   SSA. IR  LLVM   SSA,    . <br><br>  SSA   ,  ,   (constant propagation),     ( )  . <br><br><h2>   </h2><br>      ,  .  ,    ,   ,      ,    .         (  16  32),     ,      (spill to the stack). <br><br>   ‚Äî             (   ).     ,     ,          . <br><br>     : <br><br><ul><li>   (graph colouring) ‚Äî   (NP- ).      ,     (liveness ranges) . <br></li><li>   ‚Äî       . <br></li></ul><br><h2>     </h2><br>     . ,       .   ,       ,         . <br><br><h2>   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Name Mangling</a> ) </h2><br>    -,            ,        .         ,   . <br><br><pre> <code class="plaintext hljs">fn main() int { let x = 0; { let x = 0; { let x = 0; } } return 0; }</code> </pre> <br> ,    (  -    :) )      ,      .        ,        . <br><br><h2>   </h2><br>   LLDB     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DWARF</a> .     LLVM   ,   DWARF         GNU-. ,     ,     ,   . <br><br><h2>    (Foreign Function Interface, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FFI</a> ) </h2><br>   libc   ,        ,      .       ,        ? <br><br><h2>  </h2><br>   ‚Äî  .     ,      (  .s/.asm)?       ? ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jai</a>        .   ,     . <br><br><h2>    (CaaS) </h2><br>         API-.  ,       Krug-,         .  ,     ,      . <br><br> ,     , ,      .         ,     API-. <br><br>   production-   CaaS.    Microsofts Roslyn,       ,     .    , , ,      ,     API-,     , ,  Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RLS</a> . <br><br>    Krug ‚Äî        ‚Äî   Caasper  CaaS-. <br><br> Caasper      (,  ,  ),      , krug,    .   ,        ,      (bootstrap)   ,     . <br><br>   Krug   JavaScript,       Go*,  , ,   Krug. JavaScript     ,         yarn/npm. <br><br> <i>*      Go   ()  ,    JS.</i> <br><br>    Caasper  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> Github   Krug,    D    LLVM.       YouTube- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>   Krug ()  <a href=""></a> . <br><br><h2>  Liens utiles </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jack Crenshaw</a> ‚Äî        . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Crafting Interpreters</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  LLVM ( Go)</a> ‚Äî ! <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PL/0</a> <br></li><li> The Dragon Book ‚Äî  ,    . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8cc</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451894/">https://habr.com/ru/post/fr451894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451878/index.html">Diffusion en direct de vid√©o st√©r√©o sur des lunettes VR (Oculus Go)</a></li>
<li><a href="../fr451880/index.html">DevPRO'19: vue depuis le stand Wrike</a></li>
<li><a href="../fr451884/index.html">Sept ans de travail en tant que d√©veloppeur: quelles le√ßons ai-je tir√©es</a></li>
<li><a href="../fr451886/index.html">Utilisation de math√©matiques discr√®tes dans les tests</a></li>
<li><a href="../fr451890/index.html">D√©l√©gation d'une zone de sous-r√©seau inverse inf√©rieure √† / 24 dans BIND. Comment √ßa marche</a></li>
<li><a href="../fr451896/index.html">Un eyeDisk ¬´incassable¬ª est prot√©g√© par un balayage d'iris, mais transmet un mot de passe en texte clair</a></li>
<li><a href="../fr451898/index.html">Innovation en russe</a></li>
<li><a href="../fr451900/index.html">Premi√®re contribution √† l'API du navigateur de Facebook</a></li>
<li><a href="../fr451902/index.html">Camp de d√©veloppeurs Microsoft Azure Russie</a></li>
<li><a href="../fr451904/index.html">Parfois, plus c'est moins. Quand une diminution de la charge entra√Æne une augmentation du retard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>