<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚠 🍌 😋 Die ganze Wahrheit über RTOS. Artikel 29. Unterbrechungen in Nucleus SE 🙎🏻 👹 ✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alle modernen Mikroprozessoren und Mikrocontroller enthalten eine Art Interrupt-Mechanismus. Diese Mechanismen sind erforderlich, um die für viele Anw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel 29. Unterbrechungen in Nucleus SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458770/"> Alle modernen Mikroprozessoren und Mikrocontroller enthalten eine Art Interrupt-Mechanismus.  Diese Mechanismen sind erforderlich, um die für viele Anwendungen erforderliche Reaktionsfähigkeit bereitzustellen.  Reaktionsfähigkeit und Vorhersehbarkeit sind natürlich das Hauptziel bei der Verwendung von RTOS, aber gleichzeitig sind sie einander entgegengesetzt.  Die Verwendung von Interrupts kann die Integrität des Echtzeitbetriebssystems beeinträchtigen.  Dieses Problem und seine Lösung wurden in einem der vorherigen Artikel (Nr. 4 und Nr. 6) erwähnt.  In diesem Artikel werden wir uns die Interrupt-Behandlungsstrategie ansehen, die in Nucleus SE verwendet wird.  In allen Fällen werden Interrupts NICHT von Nucleus SE gesteuert: Sie werden verarbeitet, wenn sie gemäß der Priorität und den Vektoren auf die übliche Weise auftreten.  Ihre Ausführungszeit wird einfach aus der verfügbaren Zeit im Code der Hauptanwendung und des Schedulers "gestohlen".  Daraus folgt natürlich, dass alle Interrupt-Handler einfach, kurz und schnell sein sollten. <br><br><img src="https://habrastorage.org/webt/xf/fd/p4/xffdp4n9qbgy9yoqppflrg0a6as.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Frühere Artikel in der Reihe:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software-Timer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemzeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kanäle: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenkanäle: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <br></div></div><br><h2>  Regelmäßige und kontrollierte Interrupts </h2><br>  Nucleus SE bietet zwei Möglichkeiten, um Interrupts zu behandeln: "native" oder "regulär" (native), bei denen Interrupts nichts Besonderes sind und zum Teil nur eine begrenzte Interaktion mit dem Betriebssystem haben (zumindest bei Verwendung des Prioritätsplaners), und Verwaltet, in dem Sie über den Interrupt-Handler auf eine viel größere Anzahl von API-Aufrufen zugreifen können. <br><br>  Mit den E / A-Makros kann der Nucleus SE-Interrupt-Handler entweder im Standardmodus oder im verwalteten Modus verwendet werden. <br><br><h3>  Mitarbeiter unterbricht </h3><br>  Nucleus SE Staff Interrupts sind der Standard-Interrupt-Handler und können als "nicht verwaltet" betrachtet werden.  Sie werden normalerweise verwendet, wenn eine Unterbrechung mit hoher Frequenz auftreten kann und eine Verarbeitung mit geringem Rechenaufwand erfordert.  Ein solcher Handler ist höchstwahrscheinlich in C geschrieben, da viele moderne eingebettete Compiler die Entwicklung von Interrupt-Handlern mithilfe des Interrupt-Schlüsselworts unterstützen.  Es werden nur die Kontextinformationen gespeichert, die der Compiler für erforderlich hält.  Dies führt zu erheblichen Einschränkungen der Standard-Interrupt-Handler, die wir bald sehen werden. <br><br>  Um einen regulären Interrupt-Handler in Nucleus SE zu erstellen, reicht es aus, einfach einen regulären Interrupt-Handler zu schreiben, einschließlich des Aufrufs des <b>Makros NUSE_NISR_Enter ()</b> am Anfang und des Aufrufs von <b>NUSE_NISR_Exit ()</b> am Ende.  Diese Makros sind in der Datei <b>nuse_types</b> definiert <b>.</b>  h und setzen Sie die globale Variable <b>NUSE_Task_State</b> auf <b>NUSE_NISR_CONTEXT</b> . <br><br><h3>  Geführte Interrupts </h3><br>  Wenn Sie mehr Flexibilität für Interrupt-Handler-Vorgänge benötigen, sind möglicherweise von Nucleus SE verwaltete Interrupts die Lösung.  Der Hauptunterschied zum Standard-Interrupt besteht darin, den Kontext beizubehalten.  Anstatt dem Compiler zu erlauben, mehrere Register auf dem Stapel zu speichern, speichert ein verwalteter Interrupt den gesamten Aufgabenkontext (in einem eigenen Kontextblock) an der Eingabe.  Anschließend wird der Kontext der aktuellen Aufgabe aus dem Kontextblock am Ausgang wiederhergestellt.  Dies bietet die Möglichkeit, die aktuelle Aufgabe durch den Interrupt-Handler-Code zu ändern, was bei Verwendung des Prioritätsplaners möglich ist.  Eine vollständige Beschreibung der Kontexterhaltung und -wiederherstellung in Nucleus SE wurde in einem früheren Artikel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 10</a> ) bereitgestellt. <br><br>  Offensichtlich bedeutet die vollständige Erhaltung des Kontexts eine Zunahme des Einsatzes von Rechenressourcen im Vergleich zur Speicherung mehrerer Register auf dem Stapel, die während einer Standardunterbrechung auftritt.  Dieser Preis muss für zusätzliche Flexibilität gezahlt werden, und genau aus diesem Grund wird die Wahl des Interrupt-Handling-Ansatzes getroffen. <br><br>  Ein verwalteter Interrupt wird mit dem in <b>nuse_types.h</b> beschriebenen Makro <b>NUSE_MANAGED_ISR ()</b> <b>erstellt</b> .  Dieses Makro erstellt eine Funktion, die die folgenden Aktionen enthält: <br><br><ul><li>  Aufrechterhaltung des Kontextes der Aufgabe; </li><li>  Zuweisen von <b>NUSE_Task_State zu</b> <b>NUSE_MISR_CONTEXT</b> ; </li><li>  vom Benutzer bereitgestellter Interrupt-Handler-Funktionscode; </li><li>  Wiederherstellen <b>des</b> vorherigen Status von <b>NUSE_Task_State</b> ; </li><li>  Stellen Sie den Kontext der Aufgabe wieder her. </li></ul><br>  Das Makro verwendet zwei Parameter: den Interruptnamen, der als Funktionsname für den generierten Handler verwendet wird, und den Namen der Funktion, die die Benutzerlogik für den Interrupthandler enthält. <br><br><h3>  API-Aufrufe vom Interrupt-Handler </h3><br>  Die Menge der API-Funktionen, die von einem Standard- oder verwalteten Interrupt-Handler aufgerufen werden können, hängt davon ab, welcher Scheduler verwendet wird.  Im Allgemeinen bietet die Verwendung des Prioritätsplaners viele Optionen für den Zugriff auf den Planer über einen API-Funktionsaufruf, was bei Verwendung des Standard-Interrupt-Handlers schwierig ist. <br><br>  <b><i>API-Aufrufe an den Standard-Interrupt-Handler bei Verwendung des Prioritätsplaners</i></b> <br><br>  Bei Verwendung des Prioritätsplaners ist eine begrenzte Anzahl von API-Funktionsaufrufen vom Standard-Interrupt-Handler zulässig.  Diese Einschränkung ist das Ergebnis der Flexibilität der Nucleus SE-API: Viele Aufrufe können dazu führen, dass die Aufgabe bereit ist und der Scheduler vom Standard-Interrupt-Handler nicht aufgerufen werden kann (da der Aufgabenkontext nicht gespeichert wird).  Das Deaktivieren von Task-Sperren bietet noch mehr Flexibilität. <br><br>  Die folgenden API-Aufrufe sind immer zulässig: <br><br><pre><code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Es ist jedoch nur <b>NUSE_Signals_Send ()</b> nützlich, da es eine bequeme Möglichkeit bietet, der Aufgabe anzuzeigen, dass eine Aktion erforderlich ist. <br><br>  Wenn die Sperre deaktiviert ist, dh Aufgaben von vielen API-Aufrufen nicht in den Bereitschaftszustand versetzt werden können, werden zusätzliche API-Aufrufe verfügbar: <br><br><pre> <code class="plaintext hljs">NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve()</code> </pre> <br>  Einige API-Aufrufe sind für Standard-Interrupt-Handler immer nicht zugänglich, da sie zwangsläufig die Arbeit eines Schedulers erfordern: <br><pre> <code class="plaintext hljs">NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Sleep() NUSE_Task_Relinquish() NUSE_Task_Reset() NUSE_Signals_Receive()</code> </pre> <br>  <b><i>API-Aufrufe an den verwalteten Interrupt-Handler oder den Standard-Interrupt-Handler, wenn ein anderer Scheduler als der Prioritätsplaner verwendet wird</i></b> <br><br>  Viele weitere API-Funktionen können vom Interrupt-Handler aufgerufen werden, wenn die Scheduler "Run to Completion", "Round Robin" oder "Time Slice" verwendet werden.  Wenn ein Prioritätsplaner verwendet wird, haben verwaltete Interrupt-Handler ähnliche Funktionen.  Dies liegt daran, dass Anrufe zulässig sind, was dazu führen kann, dass eine andere Aufgabe geplant wird.  Diese Funktion wird durch den Code <b>NUSE_Reschedule ()</b> bereitgestellt, der den Aufrufkontext im Interrupt-Handler erkennt und die <b>Kontextänderung</b> unterdrückt (dies kann am Ende des Interrupt-Handlers geschehen).  Eine vollständige Analyse der Arbeit des Planers wurde in einem der vorherigen Artikel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 9</a> ) gegeben. <br><br>  Die Hauptanforderung besteht darin, dass API-Aufrufe im Interrupt-Handler nicht zu einer Unterbrechung der aktuellen Aufgabe führen dürfen, z. B. das Warten auf die Freigabe einer Ressource. <br><br>  Mit anderen Worten, solche Aufrufe müssen mit der <b>Pausenoption NUSE_NO_SUSPEND erfolgen</b> . <br><br>  In diesem Sinne können die folgenden API-Aufrufe verwendet werden: <br><br><pre> <code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Reset() NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Einige Anrufe sind immer gesperrt, da sie sich direkt auf die aktuelle Aufgabe beziehen: <br><pre> <code class="plaintext hljs">NUSE_Task_Relinquish() NUSE_Signals_Receive() NUSE_Task_Sleep()</code> </pre> <br><h2>  Echtzeituhr-Interrupt-Handler </h2><br>  Der RTC-Interrupt-Handler (Real Time Clock) ist der einzige vollständige Interrupt-Handler in Nucleus SE.  Neben der Bereitstellung aller erforderlichen Funktionen für das Zeitmanagement in Nucleus SE dient es auch als Beispiel für das Schreiben eines verwalteten Interrupt-Handlers. <br><br><h3>  RTC-Interrupt-Handler-Betrieb </h3><br>  Die vom RTC-Interrupt-Handler bereitgestellten Funktionen wurden in einem der vorherigen Artikel aufgeführt, die sich mit dem allgemeinen Thema der Systemzeit in Nucleus SE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 27</a> ) befassten.  Die beschriebene Funktionalität ist je nach Konfiguration der Anwendung optional. <br><br><div class="spoiler">  <b class="spoiler_title">Das Folgende ist der vollständige RTC-Interrupt-Handler-Code.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#if NUSE_TIMER_NUMBER != 0 { U8 timer; for (timer=0; timer&lt;NUSE_TIMER_NUMBER; timer++) { if (NUSE_Timer_Status[timer]) { if (--NUSE_Timer_Value[timer] == 0) { NUSE_Timer_Expirations_Counter[timer]++; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING if (NUSE_Timer_Expiration_Routine_Address[timer] != NULL) { ((PF1)NUSE_Timer_Expiration_Routine_Address[timer]) NUSE_Timer_Expiration_Routine_Parameter[timer]); } #endif /* reschedule? */ if (NUSE_Timer_Reschedule_Time[timer] != 0) { /* yes: set up time */ NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } else { /* no: disable */ NUSE_Timer_Status[timer] = FALSE; } } } } } #endif #if NUSE_SYSTEM_TIME_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Tick_Clock++; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING { U8 task; for (task=0; task&lt;NUSE_TASK_NUMBER; task++) { if (NUSE_Task_Timeout_Counter[task] != 0) { NUSE_Task_Timeout_Counter[task]--; if (NUSE_Task_Timeout_Counter[task] == 0) { NUSE_Wake_Task(task); } } } } #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER if (--NUSE_Time_Slice_Ticks == 0) { NUSE_Reschedule(); } #endif</code> </pre><br></div></div><br>  Als nächstes betrachten wir vier Hauptfunktionsbereiche für den RTC-Interrupt-Handler. <br><br>  <b><i>Timer</i></b> <br>  Wenn Anwendungszeitgeber konfiguriert sind, geht der Interrupt-Handler in eine Schleife, um jeden Zeitgeber zu verarbeiten, indem sein Zähler um 1 verringert wird. Wenn der Zeitgeber die Zählung beendet (d. H. Der Zähler erreicht 0), sind zwei Aktionen möglich: <br><br><ul><li>  Wenn der Timer-Abschluss-Handler konfiguriert ist und der Timer über einen korrekten (nicht <b>NULL</b> ) Funktionszeiger verfügt (in <b>NUSE_Timer_Expiration_Routine_Address []</b> ), wird der Handler ausgeführt, indem ein Parameter aus <b>NUSE_Timer_Expiration_Routine_Parameter [] übernommen wird</b> . </li><li>  Wenn der Timer so konfiguriert ist, dass er nach Abschluss initialisiert wird ( <b>dh NUSE_Timer_Reschedule_Time []</b> hat einen Wert ungleich Null), wird der Timer mit diesem Wert neu <b>geladen</b> . </li></ul><br>  Anwendungszeitgeber wurden in einem früheren Artikel (Nr. 28) ausführlich beschrieben. <br><br>  <b><i>Systemuhr</i></b> <br>  Wenn ein System-Timer konfiguriert ist, erhöht sich der Wert von <b>NUSE_Tick_Cloc</b> k einfach um 1. Weitere Informationen finden Sie in Artikel 28. <br><br>  <b><i>Unterbrechen einer Aufgabe (Task Sleep)</i></b> <br>  Wenn die Unterstützung für das Anhalten von Aufgaben aktiviert ist ( <b>dh der</b> API-Aufruf <b>NUSE_Task_Sleep ()</b> konfiguriert ist), wird der Zeitüberschreitungszähler jeder Aufgabe (der Wert in <b>NUSE_Task_Timeout_Counter []</b> ) überprüft, und wenn er ungleich Null ist, wird er um 1 verringert. Wenn er Null erreicht, wird die entsprechende Aufgabe fortgesetzt . <br><br>  <b><i>Zeitscheibenplanung</i></b> <br>  Wenn ein Time Slice-Scheduler verwendet wird, wird der Scheduler-Zähler ( <b>NUSE_Time_Slice_Ticks</b> ) dekrementiert.  Wenn es Null erreicht, wird der Scheduler aufgerufen.  Der Aufruf von <b>NUSE_Reschedule ()</b> ist für das Zurücksetzen des Zählers verantwortlich. <br><br><h3>  Kontrollierte Unterbrechung </h3><br>  Es muss erklärt werden, warum der RTC-Interrupt-Handler steuerbar ist, da der Benutzer unter bestimmten Umständen beschließen kann, ihn als Standard-Interrupt neu zu schreiben, um den Einsatz von Rechenressourcen zu reduzieren.  Wenn beispielsweise nur eine Systemzeitfunktion verwendet wird (d. H. Es gibt keine Anwendungszeitgeber, keine Aufgabensperrungen und keinen Zeitscheibenplaner), funktioniert eine regelmäßige Unterbrechung.  In folgenden Fällen ist eine geführte Unterbrechung erforderlich: <br><br><ul><li>  Wenn Timer verwendet werden und Handler für deren Abschluss konfiguriert sind, können diese Handler API-Aufrufe (aus dem Interrupt-Kontext) ausführen, was zu einer neuen Planung führt.  Sie haben dieselben Einschränkungen wie API-Aufrufe von Interrupt-Handlern (siehe weiter oben in diesem Artikel). </li><li>  Wenn ein Prioritätsplaner verwendet wird, kann das Abschließen einer Aufgabensperre das Aufwecken einer Aufgabe mit einer höheren Priorität erfordern. </li><li>  Wenn der Time Slice-Scheduler verwendet wird, wird er vom RTC-Interrupt-Handler aufgerufen. Daher ist ein gesteuerter Interrupt erforderlich. </li></ul><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Da sich die Implementierung von Nucleus SE-Interrupts stark von Nucleus RTOS unterscheidet, sollten Sie diesbezüglich keine Kompatibilität erwarten.  Nucleus RTOS verfügt über ein Standard- / Low-Level- / High-Level-Interrupt-Schema, das dem Standard- / gesteuerten Interrupt-Schema in Nucleus SE ähnelt. <br><br><h3>  Interrupt-Handler auf niedriger und hoher Ebene </h3><br>  <b><i>Low Level Interrupt Handler</i></b> <br>  Ein Low-Level Interrupt Service Routin (LISR) wird auf die gleiche Weise wie ein regulärer Handler ausgeführt, einschließlich der Verwendung des aktuellen Stapels.  Nucleus RTOS behält den Kontext bei, bis der Interrupt-Handler auf niedriger Ebene aufgerufen wird, und stellt den Kontext nach Abschluss des Handlers wieder her.  Daher kann ein Interrupt-Handler auf niedriger Ebene in C geschrieben werden und andere Handler in C aufrufen. Dem Handler auf niedriger Ebene stehen jedoch nur wenige Nucleus RTOS-Dienste zur Verfügung.  Wenn für die Interrupt-Behandlung zusätzliche Nucleus RTOS-Dienste erforderlich sind, müssen Sie einen Interrupt-Handler auf hoher Ebene aktivieren.  Nucleus RTOS unterstützt die Verwendung mehrerer Interrupt-Handler auf niedriger Ebene. <br><br>  <b><i>High Level Interrupt Handler</i></b> <br>  High-Level Interrupt Service Routin (HISR) werden dynamisch erstellt und gelöscht.  Jeder High-Level-Prozessor verfügt über einen eigenen Stapelspeicher und eine eigene Steuereinheit.  Der Speicher wird von der Anwendung zugewiesen.  Und natürlich muss ein Interrupt-Handler auf hoher Ebene erstellt werden, bevor ein Interrupt-Handler auf niedriger Ebene ihn aktivieren kann. <br><br>  Da der Interrupt-Handler auf hoher Ebene über einen eigenen Stapel und eine eigene Steuereinheit verfügt, kann er vorübergehend blockiert werden, wenn versucht wird, auf die derzeit verwendete Nucleus RTOS-Datenstruktur zuzugreifen. <br><br>  Für einen Interrupt-Handler auf hoher Ebene stehen drei Prioritätsstufen zur Verfügung.  Wenn während der Arbeit eines Handlers mit niedrigerer Priorität ein übergeordneter Handler mit höherer Priorität aktiviert wird, wird nach Abschluss der Aufgabe ein Handler mit niedrigerer Priorität ausgeführt.  Übergeordnete Interrupt-Handler mit derselben Priorität werden in der Reihenfolge ausgeführt, in der sie aktiviert sind.  Alle aktivierten Interrupt-Handler auf hoher Ebene müssen abgeschlossen sein, bevor weitere Aufgaben im normalen Modus geplant werden können. <br><br><h3>  Das Nucleus RTOS API-Dienstprogramm fordert eine Unterbrechung an </h3><br>  Nucleus RTOS verfügt über mehrere API-Aufrufe zur Unterstützung von Interrupts.  Keiner von ihnen ist in Nucleus SE implementiert. <br><br>  Für Standard-Interrupts bieten API-Aufrufe die folgenden Funktionen: <br><br><ul><li>  Kontrolle (Aktivierung / Deaktivierung) der Unterbrechung (lokal und global); </li><li>  Einstellen des Interrupt-Vektors. </li></ul><br>  Für Low-Level-Interrupts: <br><br><ul><li>  Registrieren eines Interrupt-Handlers auf niedriger Ebene im Kernel. </li></ul><br>  Für Interrupts auf hoher Ebene: <br><br><ul><li>  Schaffung / Beseitigung von Unterbrechungen auf hoher Ebene; </li><li>  Interrupt-Aktivierung auf hoher Ebene; </li><li>  Abrufen der Anzahl der Interrupts auf hoher Ebene in der Anwendung (im Moment); </li><li>  Erhalten von Zeigern auf Steuereinheiten aller Interrupts auf hoher Ebene; </li><li>  Erhalten von Zeigern auf Steuereinheiten des aktuellen Interrupts auf hoher Ebene; </li><li>  Abrufen von Interrupt-Informationen auf hoher Ebene. </li></ul><br>  <b><i>Globale Interrupt-Steuerung</i></b> <br><br>  Dieser Aufruf aktiviert oder deaktiviert Interrupts unabhängig von der Aufgabe.  Daher bleibt der durch diesen Anruf deaktivierte Interrupt so lange bestehen, bis er durch Wiederverwendung dieses Anrufs aktiviert wird. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">INT NU_Control_Interrupts (INT new_level);</code> </pre> <br>  Parameter: <br><br>  <b>new_level</b> - eine neue Interrupt-Ebene für das System.  Es kann immer die Werte <b>NU_DISABLE_INTERRUPTS</b> (deaktiviert alle Interrupts) und <b>NU_ENABLE_INTERRUPTS</b> (aktiviert alle Interrupts) <b>annehmen</b> .  Abhängig von der Architektur sind möglicherweise andere Werte verfügbar. <br><br>  Rückgabewert: <br><br>  Dieser Serviceabruf gibt die vorherige Ebene der aktivierten Interrupts zurück. <br><br>  <b><i>Lokale Interrupt-Steuerung</i></b> <br><br>  Mit diesem Serviceabruf können Sie Interrupts je nach Aufgabe aktivieren oder deaktivieren.  Dieser Aufruf ändert das Statusregister auf den angegebenen Wert.  Das Statusregister wird auf den Wert zurückgesetzt, der beim letzten Aufruf von <b>NU_Control_Interrupts ()</b> angegeben wurde, <b>wenn</b> der Kontext <b>das</b> nächste Mal geändert wird. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">INT NU_Local_Control_Interrupts (INT new_level);</code> </pre> <br>  Parameter: <br><br>  <b>new_level</b> - eine neue Interrupt-Ebene für die aktuelle Aufgabe.  Es kann immer die Werte <b>NU_DISABLE_INTERRUPTS</b> (deaktiviert alle Interrupts) und <b>NU_ENABLE_INTERRUPTS</b> (aktiviert alle Interrupts) <b>annehmen</b> .  Abhängig von der Architektur sind möglicherweise andere Werte verfügbar. <br><br>  Rückgabewert: <br>  Dieser Serviceabruf gibt die vorherige Ebene der aktivierten Interrupts zurück. <br><br>  <b><i>Einstellen des Interrupt-Vektors</i></b> <br><br>  Dieser Overhead ersetzt den Interrupt-Vektor, der durch den vom Interrupt-Handler gesteuerten Vektor angegeben wird. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">VOID *NU_Setup_Vector (INT vector, VOID *new);</code> </pre> <br>  Parameter: <br><br>  <b>Vektor</b> - Interrupt-Vektor, für den der Interrupt registriert wird; <br>  <b>Neu</b> ist der Interrupt-Handler, der für den Vektor geschrieben wurde. <br><br>  Rückgabewert: <br><br>  Dieser Dienstprogrammaufruf gibt einen Zeiger auf den Interrupt-Handler zurück, der zuvor für den Interrupt-Vektor registriert wurde. <br><br>  <b><i>Low Level Interrupt Logging</i></b> <br><br>  Dieser Overhead ruft die Funktion des Low-Level-Interrupt-Handlers mit dem Interrupt-Vektor auf.  Der Systemkontext wird automatisch gespeichert, bevor der angegebene Interrupt-Handler auf niedriger Ebene aufgerufen und nach Abschluss des Interrupt-Handlers wiederhergestellt wird. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">STATUS NU_Register_LISR (INT vector, VOID (*lisr_entry) (INT), VOID (**old_lisr) (INT);</code> </pre> <br>  Parameter: <br><br>  <b>Vektor</b> - Interrupt-Vektor, für den der Interrupt registriert wird; <br>  <b>lisr_entry</b> - die Funktion, die für den Vektor registriert wird. Der Wert <b>NU_NULL löscht</b> den Vektor. <br>  <b>old_lisr</b> ist eine Funktion, die zuvor für den angegebenen Vektor registriert wurde. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_VECTOR</b> - ungültiger Vektor; <br>  <b>NU_NOT_Rector</b> - Im Moment ist der Vektor nicht registriert, da die Abmeldung in l <b>isr_entry angegeben wurde</b> . <br>  <b>NO_MORE_LISRS</b> - Die maximale Anzahl registrierter Interrupt-Handler auf niedriger Ebene wurde erreicht. <br><br>  <b><i>Erstellen eines Interrupt-Handlers auf hoher Ebene</i></b> <br>  Dieser Dienstprogrammaufruf erstellt einen Interrupt-Handler auf hoher Ebene. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">STATUS NU_Create_HISR (NU_HISR *hisr, CHAR *name, VOID (*hisr_entry) (VOID), OPTION priority, VOID *stack_pointer, UNSIGNED stack_size);</code> </pre> <br>  Parameter: <br><br>  <b>hisr</b> - ein Zeiger auf einen vom Benutzer bereitgestellten Steuerblock für einen Interrupt-Handler auf hoher Ebene; <br>  <b>name</b> - Zeiger auf einen 7-stelligen Namen für einen Interrupt-Handler auf hoher Ebene mit einer abschließenden Null; <br>  <b>hisr_entry</b> - der Einstiegspunkt der Interrupt-Handler-Funktion auf hoher Ebene; <br>  <b>Priorität</b> - Es gibt drei Prioritäten für Interrupt-Handler auf hoher Ebene (0-2).  Priorität 0 ist die höchste; <br>  <b>stack_pointer</b> - Zeiger auf den <b>Stapelbereich</b> des High-Level-Interrupt-Handlers; <br>  <b>stack_size</b> - Die Anzahl der Bytes im Stapel des Interrupt- <b>Handlers auf</b> hoher Ebene. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_HISR</b> - Ein Nullzeiger auf die Steuereinheit des High-Level-Interrupt-Handlers ( <b>NULL</b> ) oder die Steuereinheit wird bereits verwendet. <br>  <b>NU_INVALID_ENTRY</b> - ein Nullzeiger auf den Einstiegspunkt eines Interrupt- <b>Handlers auf</b> hoher Ebene ( <b>NULL</b> ); <br>  <b>NU_INVALID_PRIORITY</b> - falsche Priorität für einen Interrupt-Handler auf hoher Ebene; <br>  <b>NU_INVALID_MEMORY</b> - ungültiger Stapelzeiger; <br>  <b>NU_INVALID_SIZE</b> - Die <b>Stapelgröße</b> ist zu klein. <br><br>  <b><i>Entfernen eines Interrupt-Handlers auf hoher Ebene</i></b> <br>  Dieser Dienstprogrammaufruf entfernt den zuvor erstellten Interrupt-Handler auf hoher Ebene. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">STATUS NU_Delete_HISR (NU_HISR *hisr);</code> </pre> <br>  Parameter: <br><br>  <b>hisr</b> ist ein Zeiger auf den vom Benutzer bereitgestellten Steuerblock des Interrupt- <b>Handlers auf</b> hoher Ebene. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_HISR</b> - <b>Ungültiger</b> Zeiger auf einen Interrupt-Handler auf hoher Ebene. <br><br>  <b><i>Aktivieren eines Interrupt-Handlers auf hoher Ebene</i></b> <br><br>  Dieser Dienstprogrammaufruf aktiviert einen Interrupt-Handler auf hoher Ebene.  Wenn der angegebene High-Level-Interrupt-Handler gerade ausgeführt wird, wird die Aktivierungsanforderung erst ausgeführt, wenn der Handler nicht mehr funktioniert.  Ein Interrupt-Handler auf hoher Ebene wird für jede Aktivierungsanforderung einmal ausgeführt. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">STATUS NU_Activate_HISR (NU_HISR *hisr);</code> </pre> <br>  Parameter: <br><br>  <b>hisr</b> ist ein Zeiger auf den Steuerblock eines Interrupt- <b>Handlers auf</b> hoher Ebene. <br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_HISR</b> - ungültiger Zeiger auf die Steuereinheit eines Interrupt- <b>Handlers auf</b> hoher Ebene. <br><br>  <b><i>Abrufen der Anzahl der Interrupt-Handler auf hoher Ebene in einem System</i></b> <br>  Dieser Dienstprogrammaufruf gibt die Anzahl der installierten Interrupt-Handler auf hoher Ebene zurück.  Alle erstellten Interrupt-Handler auf hoher Ebene gelten als installiert.  Remote-Interrupt-Handler auf hoher Ebene gelten nicht als installiert. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_Established_HISRs(VOID);</code> </pre> <br>  Parameter: <br>  Sind abwesend. <br><br>  Rückgabewert: <br>  Dieser Dienstprogrammaufruf gibt die Anzahl der im System installierten Interrupt-Handler auf hoher Ebene zurück. <br><br>  <b><i>Abrufen von Zeigern zum Steuern von Blöcken von Interrupt-Handlern auf hoher Ebene</i></b> <br><br>  Dieser Serviceabruf bildet eine sequentielle Liste von Zeigern auf alle im System installierten Interrupt-Handler auf hoher Ebene. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_HISR_Pointers(NU_HISR **pointer_list, UNSIGNED maximum_pointers);</code> </pre> <br>  Parameter: <br><br>  <b>pointer_list</b> - Zeiger auf ein Array von Zeigern <b>NU_HISR</b> ;  Dieses Array wird mit Zeigern auf die im System installierten Interrupt-Handler auf hoher Ebene gefüllt. <br>  <b>Maximum_Pointers</b> - Die maximale Anzahl von <b>NU_HISR-</b> Zeigern, die im Array platziert werden können.  Sie entspricht normalerweise der Größe des Arrays <b>pointer_list</b> . <br><br>  Rückgabewert: <br>  Dieser Dienstprogrammaufruf gibt die Anzahl der aktiven Interrupt-Handler auf hoher Ebene im System zurück. <br><br>  <b><i>Abrufen eines Zeigers auf den aktuellen Interrupt-Handler auf hoher Ebene</i></b> <br>  Dieser Dienstprogrammaufruf gibt einen Zeiger auf den aktuell ausgeführten Interrupt-Handler auf hoher Ebene zurück. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">NU_HISR *NU_Current_HISR_Pointer(VOID);</code> </pre> <br>  Parameter: <br>  Sind abwesend. <br><br>  Rückgabewert: <br>  Dieser Serviceabruf gibt einen Zeiger auf die Steuereinheit des aktuell ausgeführten Interrupt-Handlers auf hoher Ebene zurück.  Wenn ein Interrupt-Handler auf nicht hoher Ebene diese Funktion <b>aufruft</b> , wird <b>NU_NULL</b> zurückgegeben. <br><br>  <b><i>Abrufen von Informationen zu einem Interrupt-Handler auf hoher Ebene</i></b> <br>  Dieser Dienstprogrammaufruf gibt verschiedene Informationen zum angegebenen Interrupt-Handler auf hoher Ebene zurück. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">STATUS NU_HISR_Information(NU_HISR *hisr, char *name, UNSIGNED *scheduled_count, DATA_ELEMENT *priority, VOID **stack_base, UNSIGNED *stack_size, UNSIGNED *minimum_stack);</code> </pre> <br>  Parameter: <br><br>  <b>hisr</b> - ein Zeiger auf einen Interrupt-Handler auf hoher Ebene; <br>  <b>name</b> - Zeiger auf den 8-stelligen Bereich für den Namen des Interrupt-Handlers auf hoher Ebene, einschließlich der abschließenden Null; <br>  <b>Scheduled_Count</b> - Zeiger auf eine Variable für die Gesamtzahl der geplanten Interrupt-Handler auf hoher Ebene. <br>  <b>Priorität</b> - ein Zeiger auf eine Variable zum Speichern der Priorität eines Interrupt-Handlers auf hoher Ebene; <br>  <b>stack_base</b> - Zeiger auf einen Zeiger zum Speichern des ursprünglichen Zeigers auf den Stapel;  Dies ist derselbe Zeiger, der beim Erstellen des Interrupt-Handlers auf hoher Ebene übergeben wurde. <br>  <b>stack_size</b> - ein Zeiger auf eine Variable zum Speichern der gesamten <b>Stapelgröße</b> eines <b>Interrupt-Handlers auf</b> hoher Ebene; <br>  <b>Minimum_stack</b> - Ein Zeiger auf eine Variable zum Speichern der minimalen Menge an verfügbarem Stapelspeicher, die während der Ausführung eines Interrupt-Handlers auf hoher Ebene erkannt wurde. <br><br>  Rückgabewert: <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_SUCCESS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Der Anruf wurde erfolgreich abgeschlossen. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_INVALID_HISR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ungültiger Zeiger auf einen Interrupt-Handler auf hoher Ebene.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API-Aufrufe von Interrupt-Handlern </font></font></h3><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API-Aufruf von Interrupt-Handlern auf niedriger Ebene Ein Interrupt-Handler auf niedriger Ebene</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann nur die folgenden Nucleus RTOS-Funktionen verwenden:</font></font><br><br><pre> <code class="plaintext hljs">NU_Activate_HISR() NU_Local_Control_Interrupts() NU_Current_HISR_Pointer() NU_Current_Task_Pointer() NU_Retrieve_Clock()</code> </pre> <br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API-Serviceaufrufe von Interrupt-Handlern auf</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hoher</font><b><i><font style="vertical-align: inherit;"> Ebene Interrupt-Handler auf</font></i></b><font style="vertical-align: inherit;"> hoher Ebene haben Zugriff auf die meisten Nucleus RTOS-Funktionen, mit Ausnahme von selbst pausierenden Funktionen. Da ein Interrupt-Handler auf hoher Ebene die Nucleus RTOS-Funktion nicht aussetzen kann, muss der Parameter immer</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NU_NO_SUSPEND sein</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der nächste Artikel in dieser Reihe behandelt die Initialisierungs- und Startverfahren von Nucleus SE.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Über den Autor:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und verbringt die meiste Zeit mit Firmware. </font><font style="vertical-align: inherit;">Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware. </font><font style="vertical-align: inherit;">Lebt in Großbritannien. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colins</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> professioneller </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Blog</font></a><font style="vertical-align: inherit;"> , E-Mail: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458770/">https://habr.com/ru/post/de458770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458758/index.html">Die Pracht und Armut der übersetzten Literatur</a></li>
<li><a href="../de458760/index.html">Die Ausstellung in Las Vegas richtet sich an Elektronikentwickler und nicht an Verbraucher. Ein Bericht von der Design Automation Conference</a></li>
<li><a href="../de458764/index.html">Grundlegende agile Praktiken für technische und nichttechnische Teams im Jahr 2019</a></li>
<li><a href="../de458766/index.html">IronPython auf der Seite des Bösen: Wie wir einen Cyberangriff auf öffentliche Dienste in einem europäischen Land aufgedeckt haben</a></li>
<li><a href="../de458768/index.html">5-6 Gründe, zu GolangConf zu kommen</a></li>
<li><a href="../de458774/index.html">Funktionales DBMS</a></li>
<li><a href="../de458778/index.html">Satellite 6.5 Reporting Engine: Was und warum</a></li>
<li><a href="../de458782/index.html">Anpassung von Programmen für ZX Spectrum an TR-DOS mit modernen Mitteln. Teil 3</a></li>
<li><a href="../de458784/index.html">Übertragen Sie Projekte und Bibliotheken von Altium Designer an PADS Professional</a></li>
<li><a href="../de458786/index.html">Videospiel-Keeper halten die Spielkultur Schritt für Schritt aufrecht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>