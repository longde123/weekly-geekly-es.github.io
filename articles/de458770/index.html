<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö† üçå üòã Die ganze Wahrheit √ºber RTOS. Artikel 29. Unterbrechungen in Nucleus SE üôéüèª üëπ ‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alle modernen Mikroprozessoren und Mikrocontroller enthalten eine Art Interrupt-Mechanismus. Diese Mechanismen sind erforderlich, um die f√ºr viele Anw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel 29. Unterbrechungen in Nucleus SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458770/"> Alle modernen Mikroprozessoren und Mikrocontroller enthalten eine Art Interrupt-Mechanismus.  Diese Mechanismen sind erforderlich, um die f√ºr viele Anwendungen erforderliche Reaktionsf√§higkeit bereitzustellen.  Reaktionsf√§higkeit und Vorhersehbarkeit sind nat√ºrlich das Hauptziel bei der Verwendung von RTOS, aber gleichzeitig sind sie einander entgegengesetzt.  Die Verwendung von Interrupts kann die Integrit√§t des Echtzeitbetriebssystems beeintr√§chtigen.  Dieses Problem und seine L√∂sung wurden in einem der vorherigen Artikel (Nr. 4 und Nr. 6) erw√§hnt.  In diesem Artikel werden wir uns die Interrupt-Behandlungsstrategie ansehen, die in Nucleus SE verwendet wird.  In allen F√§llen werden Interrupts NICHT von Nucleus SE gesteuert: Sie werden verarbeitet, wenn sie gem√§√ü der Priorit√§t und den Vektoren auf die √ºbliche Weise auftreten.  Ihre Ausf√ºhrungszeit wird einfach aus der verf√ºgbaren Zeit im Code der Hauptanwendung und des Schedulers "gestohlen".  Daraus folgt nat√ºrlich, dass alle Interrupt-Handler einfach, kurz und schnell sein sollten. <br><br><img src="https://habrastorage.org/webt/xf/fd/p4/xffdp4n9qbgy9yoqppflrg0a6as.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Fr√ºhere Artikel in der Reihe:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software-Timer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemzeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kan√§le: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenkan√§le: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <br></div></div><br><h2>  Regelm√§√üige und kontrollierte Interrupts </h2><br>  Nucleus SE bietet zwei M√∂glichkeiten, um Interrupts zu behandeln: "native" oder "regul√§r" (native), bei denen Interrupts nichts Besonderes sind und zum Teil nur eine begrenzte Interaktion mit dem Betriebssystem haben (zumindest bei Verwendung des Priorit√§tsplaners), und Verwaltet, in dem Sie √ºber den Interrupt-Handler auf eine viel gr√∂√üere Anzahl von API-Aufrufen zugreifen k√∂nnen. <br><br>  Mit den E / A-Makros kann der Nucleus SE-Interrupt-Handler entweder im Standardmodus oder im verwalteten Modus verwendet werden. <br><br><h3>  Mitarbeiter unterbricht </h3><br>  Nucleus SE Staff Interrupts sind der Standard-Interrupt-Handler und k√∂nnen als "nicht verwaltet" betrachtet werden.  Sie werden normalerweise verwendet, wenn eine Unterbrechung mit hoher Frequenz auftreten kann und eine Verarbeitung mit geringem Rechenaufwand erfordert.  Ein solcher Handler ist h√∂chstwahrscheinlich in C geschrieben, da viele moderne eingebettete Compiler die Entwicklung von Interrupt-Handlern mithilfe des Interrupt-Schl√ºsselworts unterst√ºtzen.  Es werden nur die Kontextinformationen gespeichert, die der Compiler f√ºr erforderlich h√§lt.  Dies f√ºhrt zu erheblichen Einschr√§nkungen der Standard-Interrupt-Handler, die wir bald sehen werden. <br><br>  Um einen regul√§ren Interrupt-Handler in Nucleus SE zu erstellen, reicht es aus, einfach einen regul√§ren Interrupt-Handler zu schreiben, einschlie√ülich des Aufrufs des <b>Makros NUSE_NISR_Enter ()</b> am Anfang und des Aufrufs von <b>NUSE_NISR_Exit ()</b> am Ende.  Diese Makros sind in der Datei <b>nuse_types</b> definiert <b>.</b>  h und setzen Sie die globale Variable <b>NUSE_Task_State</b> auf <b>NUSE_NISR_CONTEXT</b> . <br><br><h3>  Gef√ºhrte Interrupts </h3><br>  Wenn Sie mehr Flexibilit√§t f√ºr Interrupt-Handler-Vorg√§nge ben√∂tigen, sind m√∂glicherweise von Nucleus SE verwaltete Interrupts die L√∂sung.  Der Hauptunterschied zum Standard-Interrupt besteht darin, den Kontext beizubehalten.  Anstatt dem Compiler zu erlauben, mehrere Register auf dem Stapel zu speichern, speichert ein verwalteter Interrupt den gesamten Aufgabenkontext (in einem eigenen Kontextblock) an der Eingabe.  Anschlie√üend wird der Kontext der aktuellen Aufgabe aus dem Kontextblock am Ausgang wiederhergestellt.  Dies bietet die M√∂glichkeit, die aktuelle Aufgabe durch den Interrupt-Handler-Code zu √§ndern, was bei Verwendung des Priorit√§tsplaners m√∂glich ist.  Eine vollst√§ndige Beschreibung der Kontexterhaltung und -wiederherstellung in Nucleus SE wurde in einem fr√ºheren Artikel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 10</a> ) bereitgestellt. <br><br>  Offensichtlich bedeutet die vollst√§ndige Erhaltung des Kontexts eine Zunahme des Einsatzes von Rechenressourcen im Vergleich zur Speicherung mehrerer Register auf dem Stapel, die w√§hrend einer Standardunterbrechung auftritt.  Dieser Preis muss f√ºr zus√§tzliche Flexibilit√§t gezahlt werden, und genau aus diesem Grund wird die Wahl des Interrupt-Handling-Ansatzes getroffen. <br><br>  Ein verwalteter Interrupt wird mit dem in <b>nuse_types.h</b> beschriebenen Makro <b>NUSE_MANAGED_ISR ()</b> <b>erstellt</b> .  Dieses Makro erstellt eine Funktion, die die folgenden Aktionen enth√§lt: <br><br><ul><li>  Aufrechterhaltung des Kontextes der Aufgabe; </li><li>  Zuweisen von <b>NUSE_Task_State zu</b> <b>NUSE_MISR_CONTEXT</b> ; </li><li>  vom Benutzer bereitgestellter Interrupt-Handler-Funktionscode; </li><li>  Wiederherstellen <b>des</b> vorherigen Status von <b>NUSE_Task_State</b> ; </li><li>  Stellen Sie den Kontext der Aufgabe wieder her. </li></ul><br>  Das Makro verwendet zwei Parameter: den Interruptnamen, der als Funktionsname f√ºr den generierten Handler verwendet wird, und den Namen der Funktion, die die Benutzerlogik f√ºr den Interrupthandler enth√§lt. <br><br><h3>  API-Aufrufe vom Interrupt-Handler </h3><br>  Die Menge der API-Funktionen, die von einem Standard- oder verwalteten Interrupt-Handler aufgerufen werden k√∂nnen, h√§ngt davon ab, welcher Scheduler verwendet wird.  Im Allgemeinen bietet die Verwendung des Priorit√§tsplaners viele Optionen f√ºr den Zugriff auf den Planer √ºber einen API-Funktionsaufruf, was bei Verwendung des Standard-Interrupt-Handlers schwierig ist. <br><br>  <b><i>API-Aufrufe an den Standard-Interrupt-Handler bei Verwendung des Priorit√§tsplaners</i></b> <br><br>  Bei Verwendung des Priorit√§tsplaners ist eine begrenzte Anzahl von API-Funktionsaufrufen vom Standard-Interrupt-Handler zul√§ssig.  Diese Einschr√§nkung ist das Ergebnis der Flexibilit√§t der Nucleus SE-API: Viele Aufrufe k√∂nnen dazu f√ºhren, dass die Aufgabe bereit ist und der Scheduler vom Standard-Interrupt-Handler nicht aufgerufen werden kann (da der Aufgabenkontext nicht gespeichert wird).  Das Deaktivieren von Task-Sperren bietet noch mehr Flexibilit√§t. <br><br>  Die folgenden API-Aufrufe sind immer zul√§ssig: <br><br><pre><code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Es ist jedoch nur <b>NUSE_Signals_Send ()</b> n√ºtzlich, da es eine bequeme M√∂glichkeit bietet, der Aufgabe anzuzeigen, dass eine Aktion erforderlich ist. <br><br>  Wenn die Sperre deaktiviert ist, dh Aufgaben von vielen API-Aufrufen nicht in den Bereitschaftszustand versetzt werden k√∂nnen, werden zus√§tzliche API-Aufrufe verf√ºgbar: <br><br><pre> <code class="plaintext hljs">NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve()</code> </pre> <br>  Einige API-Aufrufe sind f√ºr Standard-Interrupt-Handler immer nicht zug√§nglich, da sie zwangsl√§ufig die Arbeit eines Schedulers erfordern: <br><pre> <code class="plaintext hljs">NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Sleep() NUSE_Task_Relinquish() NUSE_Task_Reset() NUSE_Signals_Receive()</code> </pre> <br>  <b><i>API-Aufrufe an den verwalteten Interrupt-Handler oder den Standard-Interrupt-Handler, wenn ein anderer Scheduler als der Priorit√§tsplaner verwendet wird</i></b> <br><br>  Viele weitere API-Funktionen k√∂nnen vom Interrupt-Handler aufgerufen werden, wenn die Scheduler "Run to Completion", "Round Robin" oder "Time Slice" verwendet werden.  Wenn ein Priorit√§tsplaner verwendet wird, haben verwaltete Interrupt-Handler √§hnliche Funktionen.  Dies liegt daran, dass Anrufe zul√§ssig sind, was dazu f√ºhren kann, dass eine andere Aufgabe geplant wird.  Diese Funktion wird durch den Code <b>NUSE_Reschedule ()</b> bereitgestellt, der den Aufrufkontext im Interrupt-Handler erkennt und die <b>Kontext√§nderung</b> unterdr√ºckt (dies kann am Ende des Interrupt-Handlers geschehen).  Eine vollst√§ndige Analyse der Arbeit des Planers wurde in einem der vorherigen Artikel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 9</a> ) gegeben. <br><br>  Die Hauptanforderung besteht darin, dass API-Aufrufe im Interrupt-Handler nicht zu einer Unterbrechung der aktuellen Aufgabe f√ºhren d√ºrfen, z. B. das Warten auf die Freigabe einer Ressource. <br><br>  Mit anderen Worten, solche Aufrufe m√ºssen mit der <b>Pausenoption NUSE_NO_SUSPEND erfolgen</b> . <br><br>  In diesem Sinne k√∂nnen die folgenden API-Aufrufe verwendet werden: <br><br><pre> <code class="plaintext hljs">NUSE_Task_Current() NUSE_Task_Check_Stack() NUSE_Task_Information() NUSE_Task_Count() NUSE_Task_Suspend() NUSE_Task_Resume() NUSE_Task_Reset() NUSE_Partition_Allocate() NUSE_Partition_Deallocate() NUSE_Partition_Pool_Information() NUSE_Partition_Pool_Count() NUSE_Mailbox_Send() NUSE_Mailbox_Receive() NUSE_Mailbox_Reset() NUSE_Mailbox_Information() NUSE_Mailbox_Count() NUSE_Queue_Send() NUSE_Queue_Receive() NUSE_Queue_Jam() NUSE_Queue_Reset() NUSE_Queue_Information() NUSE_Queue_Count() NUSE_Pipe_Send() NUSE_Pipe_Receive() NUSE_Pipe_Jam() NUSE_Pipe_Reset() NUSE_Pipe_Information() NUSE_Pipe_Count() NUSE_Semaphore_Obtain() NUSE_Semaphore_Release() NUSE_Semaphore_Reset() NUSE_Semaphore_Information() NUSE_Semaphore_Count() NUSE_Event_Group_Set() NUSE_Event_Group_Retrieve() NUSE_Event_Group_Information() NUSE_Event_Group_Count() NUSE_Signals_Send() NUSE_Timer_Control() NUSE_Timer_Get_Remaining() NUSE_Timer_Reset() NUSE_Timer_Information() NUSE_Timer_Count() NUSE_Clock_Set() NUSE_Clock_Retrieve() NUSE_Release_Information()</code> </pre> <br>  Einige Anrufe sind immer gesperrt, da sie sich direkt auf die aktuelle Aufgabe beziehen: <br><pre> <code class="plaintext hljs">NUSE_Task_Relinquish() NUSE_Signals_Receive() NUSE_Task_Sleep()</code> </pre> <br><h2>  Echtzeituhr-Interrupt-Handler </h2><br>  Der RTC-Interrupt-Handler (Real Time Clock) ist der einzige vollst√§ndige Interrupt-Handler in Nucleus SE.  Neben der Bereitstellung aller erforderlichen Funktionen f√ºr das Zeitmanagement in Nucleus SE dient es auch als Beispiel f√ºr das Schreiben eines verwalteten Interrupt-Handlers. <br><br><h3>  RTC-Interrupt-Handler-Betrieb </h3><br>  Die vom RTC-Interrupt-Handler bereitgestellten Funktionen wurden in einem der vorherigen Artikel aufgef√ºhrt, die sich mit dem allgemeinen Thema der Systemzeit in Nucleus SE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 27</a> ) befassten.  Die beschriebene Funktionalit√§t ist je nach Konfiguration der Anwendung optional. <br><br><div class="spoiler">  <b class="spoiler_title">Das Folgende ist der vollst√§ndige RTC-Interrupt-Handler-Code.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#if NUSE_TIMER_NUMBER != 0 { U8 timer; for (timer=0; timer&lt;NUSE_TIMER_NUMBER; timer++) { if (NUSE_Timer_Status[timer]) { if (--NUSE_Timer_Value[timer] == 0) { NUSE_Timer_Expirations_Counter[timer]++; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING if (NUSE_Timer_Expiration_Routine_Address[timer] != NULL) { ((PF1)NUSE_Timer_Expiration_Routine_Address[timer]) NUSE_Timer_Expiration_Routine_Parameter[timer]); } #endif /* reschedule? */ if (NUSE_Timer_Reschedule_Time[timer] != 0) { /* yes: set up time */ NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } else { /* no: disable */ NUSE_Timer_Status[timer] = FALSE; } } } } } #endif #if NUSE_SYSTEM_TIME_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Tick_Clock++; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING { U8 task; for (task=0; task&lt;NUSE_TASK_NUMBER; task++) { if (NUSE_Task_Timeout_Counter[task] != 0) { NUSE_Task_Timeout_Counter[task]--; if (NUSE_Task_Timeout_Counter[task] == 0) { NUSE_Wake_Task(task); } } } } #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER if (--NUSE_Time_Slice_Ticks == 0) { NUSE_Reschedule(); } #endif</code> </pre><br></div></div><br>  Als n√§chstes betrachten wir vier Hauptfunktionsbereiche f√ºr den RTC-Interrupt-Handler. <br><br>  <b><i>Timer</i></b> <br>  Wenn Anwendungszeitgeber konfiguriert sind, geht der Interrupt-Handler in eine Schleife, um jeden Zeitgeber zu verarbeiten, indem sein Z√§hler um 1 verringert wird. Wenn der Zeitgeber die Z√§hlung beendet (d. H. Der Z√§hler erreicht 0), sind zwei Aktionen m√∂glich: <br><br><ul><li>  Wenn der Timer-Abschluss-Handler konfiguriert ist und der Timer √ºber einen korrekten (nicht <b>NULL</b> ) Funktionszeiger verf√ºgt (in <b>NUSE_Timer_Expiration_Routine_Address []</b> ), wird der Handler ausgef√ºhrt, indem ein Parameter aus <b>NUSE_Timer_Expiration_Routine_Parameter [] √ºbernommen wird</b> . </li><li>  Wenn der Timer so konfiguriert ist, dass er nach Abschluss initialisiert wird ( <b>dh NUSE_Timer_Reschedule_Time []</b> hat einen Wert ungleich Null), wird der Timer mit diesem Wert neu <b>geladen</b> . </li></ul><br>  Anwendungszeitgeber wurden in einem fr√ºheren Artikel (Nr. 28) ausf√ºhrlich beschrieben. <br><br>  <b><i>Systemuhr</i></b> <br>  Wenn ein System-Timer konfiguriert ist, erh√∂ht sich der Wert von <b>NUSE_Tick_Cloc</b> k einfach um 1. Weitere Informationen finden Sie in Artikel 28. <br><br>  <b><i>Unterbrechen einer Aufgabe (Task Sleep)</i></b> <br>  Wenn die Unterst√ºtzung f√ºr das Anhalten von Aufgaben aktiviert ist ( <b>dh der</b> API-Aufruf <b>NUSE_Task_Sleep ()</b> konfiguriert ist), wird der Zeit√ºberschreitungsz√§hler jeder Aufgabe (der Wert in <b>NUSE_Task_Timeout_Counter []</b> ) √ºberpr√ºft, und wenn er ungleich Null ist, wird er um 1 verringert. Wenn er Null erreicht, wird die entsprechende Aufgabe fortgesetzt . <br><br>  <b><i>Zeitscheibenplanung</i></b> <br>  Wenn ein Time Slice-Scheduler verwendet wird, wird der Scheduler-Z√§hler ( <b>NUSE_Time_Slice_Ticks</b> ) dekrementiert.  Wenn es Null erreicht, wird der Scheduler aufgerufen.  Der Aufruf von <b>NUSE_Reschedule ()</b> ist f√ºr das Zur√ºcksetzen des Z√§hlers verantwortlich. <br><br><h3>  Kontrollierte Unterbrechung </h3><br>  Es muss erkl√§rt werden, warum der RTC-Interrupt-Handler steuerbar ist, da der Benutzer unter bestimmten Umst√§nden beschlie√üen kann, ihn als Standard-Interrupt neu zu schreiben, um den Einsatz von Rechenressourcen zu reduzieren.  Wenn beispielsweise nur eine Systemzeitfunktion verwendet wird (d. H. Es gibt keine Anwendungszeitgeber, keine Aufgabensperrungen und keinen Zeitscheibenplaner), funktioniert eine regelm√§√üige Unterbrechung.  In folgenden F√§llen ist eine gef√ºhrte Unterbrechung erforderlich: <br><br><ul><li>  Wenn Timer verwendet werden und Handler f√ºr deren Abschluss konfiguriert sind, k√∂nnen diese Handler API-Aufrufe (aus dem Interrupt-Kontext) ausf√ºhren, was zu einer neuen Planung f√ºhrt.  Sie haben dieselben Einschr√§nkungen wie API-Aufrufe von Interrupt-Handlern (siehe weiter oben in diesem Artikel). </li><li>  Wenn ein Priorit√§tsplaner verwendet wird, kann das Abschlie√üen einer Aufgabensperre das Aufwecken einer Aufgabe mit einer h√∂heren Priorit√§t erfordern. </li><li>  Wenn der Time Slice-Scheduler verwendet wird, wird er vom RTC-Interrupt-Handler aufgerufen. Daher ist ein gesteuerter Interrupt erforderlich. </li></ul><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Da sich die Implementierung von Nucleus SE-Interrupts stark von Nucleus RTOS unterscheidet, sollten Sie diesbez√ºglich keine Kompatibilit√§t erwarten.  Nucleus RTOS verf√ºgt √ºber ein Standard- / Low-Level- / High-Level-Interrupt-Schema, das dem Standard- / gesteuerten Interrupt-Schema in Nucleus SE √§hnelt. <br><br><h3>  Interrupt-Handler auf niedriger und hoher Ebene </h3><br>  <b><i>Low Level Interrupt Handler</i></b> <br>  Ein Low-Level Interrupt Service Routin (LISR) wird auf die gleiche Weise wie ein regul√§rer Handler ausgef√ºhrt, einschlie√ülich der Verwendung des aktuellen Stapels.  Nucleus RTOS beh√§lt den Kontext bei, bis der Interrupt-Handler auf niedriger Ebene aufgerufen wird, und stellt den Kontext nach Abschluss des Handlers wieder her.  Daher kann ein Interrupt-Handler auf niedriger Ebene in C geschrieben werden und andere Handler in C aufrufen. Dem Handler auf niedriger Ebene stehen jedoch nur wenige Nucleus RTOS-Dienste zur Verf√ºgung.  Wenn f√ºr die Interrupt-Behandlung zus√§tzliche Nucleus RTOS-Dienste erforderlich sind, m√ºssen Sie einen Interrupt-Handler auf hoher Ebene aktivieren.  Nucleus RTOS unterst√ºtzt die Verwendung mehrerer Interrupt-Handler auf niedriger Ebene. <br><br>  <b><i>High Level Interrupt Handler</i></b> <br>  High-Level Interrupt Service Routin (HISR) werden dynamisch erstellt und gel√∂scht.  Jeder High-Level-Prozessor verf√ºgt √ºber einen eigenen Stapelspeicher und eine eigene Steuereinheit.  Der Speicher wird von der Anwendung zugewiesen.  Und nat√ºrlich muss ein Interrupt-Handler auf hoher Ebene erstellt werden, bevor ein Interrupt-Handler auf niedriger Ebene ihn aktivieren kann. <br><br>  Da der Interrupt-Handler auf hoher Ebene √ºber einen eigenen Stapel und eine eigene Steuereinheit verf√ºgt, kann er vor√ºbergehend blockiert werden, wenn versucht wird, auf die derzeit verwendete Nucleus RTOS-Datenstruktur zuzugreifen. <br><br>  F√ºr einen Interrupt-Handler auf hoher Ebene stehen drei Priorit√§tsstufen zur Verf√ºgung.  Wenn w√§hrend der Arbeit eines Handlers mit niedrigerer Priorit√§t ein √ºbergeordneter Handler mit h√∂herer Priorit√§t aktiviert wird, wird nach Abschluss der Aufgabe ein Handler mit niedrigerer Priorit√§t ausgef√ºhrt.  √úbergeordnete Interrupt-Handler mit derselben Priorit√§t werden in der Reihenfolge ausgef√ºhrt, in der sie aktiviert sind.  Alle aktivierten Interrupt-Handler auf hoher Ebene m√ºssen abgeschlossen sein, bevor weitere Aufgaben im normalen Modus geplant werden k√∂nnen. <br><br><h3>  Das Nucleus RTOS API-Dienstprogramm fordert eine Unterbrechung an </h3><br>  Nucleus RTOS verf√ºgt √ºber mehrere API-Aufrufe zur Unterst√ºtzung von Interrupts.  Keiner von ihnen ist in Nucleus SE implementiert. <br><br>  F√ºr Standard-Interrupts bieten API-Aufrufe die folgenden Funktionen: <br><br><ul><li>  Kontrolle (Aktivierung / Deaktivierung) der Unterbrechung (lokal und global); </li><li>  Einstellen des Interrupt-Vektors. </li></ul><br>  F√ºr Low-Level-Interrupts: <br><br><ul><li>  Registrieren eines Interrupt-Handlers auf niedriger Ebene im Kernel. </li></ul><br>  F√ºr Interrupts auf hoher Ebene: <br><br><ul><li>  Schaffung / Beseitigung von Unterbrechungen auf hoher Ebene; </li><li>  Interrupt-Aktivierung auf hoher Ebene; </li><li>  Abrufen der Anzahl der Interrupts auf hoher Ebene in der Anwendung (im Moment); </li><li>  Erhalten von Zeigern auf Steuereinheiten aller Interrupts auf hoher Ebene; </li><li>  Erhalten von Zeigern auf Steuereinheiten des aktuellen Interrupts auf hoher Ebene; </li><li>  Abrufen von Interrupt-Informationen auf hoher Ebene. </li></ul><br>  <b><i>Globale Interrupt-Steuerung</i></b> <br><br>  Dieser Aufruf aktiviert oder deaktiviert Interrupts unabh√§ngig von der Aufgabe.  Daher bleibt der durch diesen Anruf deaktivierte Interrupt so lange bestehen, bis er durch Wiederverwendung dieses Anrufs aktiviert wird. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">INT NU_Control_Interrupts (INT new_level);</code> </pre> <br>  Parameter: <br><br>  <b>new_level</b> - eine neue Interrupt-Ebene f√ºr das System.  Es kann immer die Werte <b>NU_DISABLE_INTERRUPTS</b> (deaktiviert alle Interrupts) und <b>NU_ENABLE_INTERRUPTS</b> (aktiviert alle Interrupts) <b>annehmen</b> .  Abh√§ngig von der Architektur sind m√∂glicherweise andere Werte verf√ºgbar. <br><br>  R√ºckgabewert: <br><br>  Dieser Serviceabruf gibt die vorherige Ebene der aktivierten Interrupts zur√ºck. <br><br>  <b><i>Lokale Interrupt-Steuerung</i></b> <br><br>  Mit diesem Serviceabruf k√∂nnen Sie Interrupts je nach Aufgabe aktivieren oder deaktivieren.  Dieser Aufruf √§ndert das Statusregister auf den angegebenen Wert.  Das Statusregister wird auf den Wert zur√ºckgesetzt, der beim letzten Aufruf von <b>NU_Control_Interrupts ()</b> angegeben wurde, <b>wenn</b> der Kontext <b>das</b> n√§chste Mal ge√§ndert wird. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">INT NU_Local_Control_Interrupts (INT new_level);</code> </pre> <br>  Parameter: <br><br>  <b>new_level</b> - eine neue Interrupt-Ebene f√ºr die aktuelle Aufgabe.  Es kann immer die Werte <b>NU_DISABLE_INTERRUPTS</b> (deaktiviert alle Interrupts) und <b>NU_ENABLE_INTERRUPTS</b> (aktiviert alle Interrupts) <b>annehmen</b> .  Abh√§ngig von der Architektur sind m√∂glicherweise andere Werte verf√ºgbar. <br><br>  R√ºckgabewert: <br>  Dieser Serviceabruf gibt die vorherige Ebene der aktivierten Interrupts zur√ºck. <br><br>  <b><i>Einstellen des Interrupt-Vektors</i></b> <br><br>  Dieser Overhead ersetzt den Interrupt-Vektor, der durch den vom Interrupt-Handler gesteuerten Vektor angegeben wird. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">VOID *NU_Setup_Vector (INT vector, VOID *new);</code> </pre> <br>  Parameter: <br><br>  <b>Vektor</b> - Interrupt-Vektor, f√ºr den der Interrupt registriert wird; <br>  <b>Neu</b> ist der Interrupt-Handler, der f√ºr den Vektor geschrieben wurde. <br><br>  R√ºckgabewert: <br><br>  Dieser Dienstprogrammaufruf gibt einen Zeiger auf den Interrupt-Handler zur√ºck, der zuvor f√ºr den Interrupt-Vektor registriert wurde. <br><br>  <b><i>Low Level Interrupt Logging</i></b> <br><br>  Dieser Overhead ruft die Funktion des Low-Level-Interrupt-Handlers mit dem Interrupt-Vektor auf.  Der Systemkontext wird automatisch gespeichert, bevor der angegebene Interrupt-Handler auf niedriger Ebene aufgerufen und nach Abschluss des Interrupt-Handlers wiederhergestellt wird. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">STATUS NU_Register_LISR (INT vector, VOID (*lisr_entry) (INT), VOID (**old_lisr) (INT);</code> </pre> <br>  Parameter: <br><br>  <b>Vektor</b> - Interrupt-Vektor, f√ºr den der Interrupt registriert wird; <br>  <b>lisr_entry</b> - die Funktion, die f√ºr den Vektor registriert wird. Der Wert <b>NU_NULL l√∂scht</b> den Vektor. <br>  <b>old_lisr</b> ist eine Funktion, die zuvor f√ºr den angegebenen Vektor registriert wurde. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_VECTOR</b> - ung√ºltiger Vektor; <br>  <b>NU_NOT_Rector</b> - Im Moment ist der Vektor nicht registriert, da die Abmeldung in l <b>isr_entry angegeben wurde</b> . <br>  <b>NO_MORE_LISRS</b> - Die maximale Anzahl registrierter Interrupt-Handler auf niedriger Ebene wurde erreicht. <br><br>  <b><i>Erstellen eines Interrupt-Handlers auf hoher Ebene</i></b> <br>  Dieser Dienstprogrammaufruf erstellt einen Interrupt-Handler auf hoher Ebene. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">STATUS NU_Create_HISR (NU_HISR *hisr, CHAR *name, VOID (*hisr_entry) (VOID), OPTION priority, VOID *stack_pointer, UNSIGNED stack_size);</code> </pre> <br>  Parameter: <br><br>  <b>hisr</b> - ein Zeiger auf einen vom Benutzer bereitgestellten Steuerblock f√ºr einen Interrupt-Handler auf hoher Ebene; <br>  <b>name</b> - Zeiger auf einen 7-stelligen Namen f√ºr einen Interrupt-Handler auf hoher Ebene mit einer abschlie√üenden Null; <br>  <b>hisr_entry</b> - der Einstiegspunkt der Interrupt-Handler-Funktion auf hoher Ebene; <br>  <b>Priorit√§t</b> - Es gibt drei Priorit√§ten f√ºr Interrupt-Handler auf hoher Ebene (0-2).  Priorit√§t 0 ist die h√∂chste; <br>  <b>stack_pointer</b> - Zeiger auf den <b>Stapelbereich</b> des High-Level-Interrupt-Handlers; <br>  <b>stack_size</b> - Die Anzahl der Bytes im Stapel des Interrupt- <b>Handlers auf</b> hoher Ebene. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_HISR</b> - Ein Nullzeiger auf die Steuereinheit des High-Level-Interrupt-Handlers ( <b>NULL</b> ) oder die Steuereinheit wird bereits verwendet. <br>  <b>NU_INVALID_ENTRY</b> - ein Nullzeiger auf den Einstiegspunkt eines Interrupt- <b>Handlers auf</b> hoher Ebene ( <b>NULL</b> ); <br>  <b>NU_INVALID_PRIORITY</b> - falsche Priorit√§t f√ºr einen Interrupt-Handler auf hoher Ebene; <br>  <b>NU_INVALID_MEMORY</b> - ung√ºltiger Stapelzeiger; <br>  <b>NU_INVALID_SIZE</b> - Die <b>Stapelgr√∂√üe</b> ist zu klein. <br><br>  <b><i>Entfernen eines Interrupt-Handlers auf hoher Ebene</i></b> <br>  Dieser Dienstprogrammaufruf entfernt den zuvor erstellten Interrupt-Handler auf hoher Ebene. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">STATUS NU_Delete_HISR (NU_HISR *hisr);</code> </pre> <br>  Parameter: <br><br>  <b>hisr</b> ist ein Zeiger auf den vom Benutzer bereitgestellten Steuerblock des Interrupt- <b>Handlers auf</b> hoher Ebene. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_HISR</b> - <b>Ung√ºltiger</b> Zeiger auf einen Interrupt-Handler auf hoher Ebene. <br><br>  <b><i>Aktivieren eines Interrupt-Handlers auf hoher Ebene</i></b> <br><br>  Dieser Dienstprogrammaufruf aktiviert einen Interrupt-Handler auf hoher Ebene.  Wenn der angegebene High-Level-Interrupt-Handler gerade ausgef√ºhrt wird, wird die Aktivierungsanforderung erst ausgef√ºhrt, wenn der Handler nicht mehr funktioniert.  Ein Interrupt-Handler auf hoher Ebene wird f√ºr jede Aktivierungsanforderung einmal ausgef√ºhrt. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">STATUS NU_Activate_HISR (NU_HISR *hisr);</code> </pre> <br>  Parameter: <br><br>  <b>hisr</b> ist ein Zeiger auf den Steuerblock eines Interrupt- <b>Handlers auf</b> hoher Ebene. <br>  R√ºckgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_HISR</b> - ung√ºltiger Zeiger auf die Steuereinheit eines Interrupt- <b>Handlers auf</b> hoher Ebene. <br><br>  <b><i>Abrufen der Anzahl der Interrupt-Handler auf hoher Ebene in einem System</i></b> <br>  Dieser Dienstprogrammaufruf gibt die Anzahl der installierten Interrupt-Handler auf hoher Ebene zur√ºck.  Alle erstellten Interrupt-Handler auf hoher Ebene gelten als installiert.  Remote-Interrupt-Handler auf hoher Ebene gelten nicht als installiert. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_Established_HISRs(VOID);</code> </pre> <br>  Parameter: <br>  Sind abwesend. <br><br>  R√ºckgabewert: <br>  Dieser Dienstprogrammaufruf gibt die Anzahl der im System installierten Interrupt-Handler auf hoher Ebene zur√ºck. <br><br>  <b><i>Abrufen von Zeigern zum Steuern von Bl√∂cken von Interrupt-Handlern auf hoher Ebene</i></b> <br><br>  Dieser Serviceabruf bildet eine sequentielle Liste von Zeigern auf alle im System installierten Interrupt-Handler auf hoher Ebene. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">UNSIGNED NU_HISR_Pointers(NU_HISR **pointer_list, UNSIGNED maximum_pointers);</code> </pre> <br>  Parameter: <br><br>  <b>pointer_list</b> - Zeiger auf ein Array von Zeigern <b>NU_HISR</b> ;  Dieses Array wird mit Zeigern auf die im System installierten Interrupt-Handler auf hoher Ebene gef√ºllt. <br>  <b>Maximum_Pointers</b> - Die maximale Anzahl von <b>NU_HISR-</b> Zeigern, die im Array platziert werden k√∂nnen.  Sie entspricht normalerweise der Gr√∂√üe des Arrays <b>pointer_list</b> . <br><br>  R√ºckgabewert: <br>  Dieser Dienstprogrammaufruf gibt die Anzahl der aktiven Interrupt-Handler auf hoher Ebene im System zur√ºck. <br><br>  <b><i>Abrufen eines Zeigers auf den aktuellen Interrupt-Handler auf hoher Ebene</i></b> <br>  Dieser Dienstprogrammaufruf gibt einen Zeiger auf den aktuell ausgef√ºhrten Interrupt-Handler auf hoher Ebene zur√ºck. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">NU_HISR *NU_Current_HISR_Pointer(VOID);</code> </pre> <br>  Parameter: <br>  Sind abwesend. <br><br>  R√ºckgabewert: <br>  Dieser Serviceabruf gibt einen Zeiger auf die Steuereinheit des aktuell ausgef√ºhrten Interrupt-Handlers auf hoher Ebene zur√ºck.  Wenn ein Interrupt-Handler auf nicht hoher Ebene diese Funktion <b>aufruft</b> , wird <b>NU_NULL</b> zur√ºckgegeben. <br><br>  <b><i>Abrufen von Informationen zu einem Interrupt-Handler auf hoher Ebene</i></b> <br>  Dieser Dienstprogrammaufruf gibt verschiedene Informationen zum angegebenen Interrupt-Handler auf hoher Ebene zur√ºck. <br><br>  Prototyp eines Serviceabrufs: <br><br><pre> <code class="plaintext hljs">STATUS NU_HISR_Information(NU_HISR *hisr, char *name, UNSIGNED *scheduled_count, DATA_ELEMENT *priority, VOID **stack_base, UNSIGNED *stack_size, UNSIGNED *minimum_stack);</code> </pre> <br>  Parameter: <br><br>  <b>hisr</b> - ein Zeiger auf einen Interrupt-Handler auf hoher Ebene; <br>  <b>name</b> - Zeiger auf den 8-stelligen Bereich f√ºr den Namen des Interrupt-Handlers auf hoher Ebene, einschlie√ülich der abschlie√üenden Null; <br>  <b>Scheduled_Count</b> - Zeiger auf eine Variable f√ºr die Gesamtzahl der geplanten Interrupt-Handler auf hoher Ebene. <br>  <b>Priorit√§t</b> - ein Zeiger auf eine Variable zum Speichern der Priorit√§t eines Interrupt-Handlers auf hoher Ebene; <br>  <b>stack_base</b> - Zeiger auf einen Zeiger zum Speichern des urspr√ºnglichen Zeigers auf den Stapel;  Dies ist derselbe Zeiger, der beim Erstellen des Interrupt-Handlers auf hoher Ebene √ºbergeben wurde. <br>  <b>stack_size</b> - ein Zeiger auf eine Variable zum Speichern der gesamten <b>Stapelgr√∂√üe</b> eines <b>Interrupt-Handlers auf</b> hoher Ebene; <br>  <b>Minimum_stack</b> - Ein Zeiger auf eine Variable zum Speichern der minimalen Menge an verf√ºgbarem Stapelspeicher, die w√§hrend der Ausf√ºhrung eines Interrupt-Handlers auf hoher Ebene erkannt wurde. <br><br>  R√ºckgabewert: <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_SUCCESS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Der Anruf wurde erfolgreich abgeschlossen. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NU_INVALID_HISR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ung√ºltiger Zeiger auf einen Interrupt-Handler auf hoher Ebene.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API-Aufrufe von Interrupt-Handlern </font></font></h3><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API-Aufruf von Interrupt-Handlern auf niedriger Ebene Ein Interrupt-Handler auf niedriger Ebene</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann nur die folgenden Nucleus RTOS-Funktionen verwenden:</font></font><br><br><pre> <code class="plaintext hljs">NU_Activate_HISR() NU_Local_Control_Interrupts() NU_Current_HISR_Pointer() NU_Current_Task_Pointer() NU_Retrieve_Clock()</code> </pre> <br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API-Serviceaufrufe von Interrupt-Handlern auf</font></font></i></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hoher</font><b><i><font style="vertical-align: inherit;"> Ebene Interrupt-Handler auf</font></i></b><font style="vertical-align: inherit;"> hoher Ebene haben Zugriff auf die meisten Nucleus RTOS-Funktionen, mit Ausnahme von selbst pausierenden Funktionen. Da ein Interrupt-Handler auf hoher Ebene die Nucleus RTOS-Funktion nicht aussetzen kann, muss der Parameter immer</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NU_NO_SUSPEND sein</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der n√§chste Artikel in dieser Reihe behandelt die Initialisierungs- und Startverfahren von Nucleus SE.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úber den Autor:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und verbringt die meiste Zeit mit Firmware. </font><font style="vertical-align: inherit;">Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware. </font><font style="vertical-align: inherit;">Lebt in Gro√übritannien. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colins</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> professioneller </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Blog</font></a><font style="vertical-align: inherit;"> , E-Mail: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458770/">https://habr.com/ru/post/de458770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458758/index.html">Die Pracht und Armut der √ºbersetzten Literatur</a></li>
<li><a href="../de458760/index.html">Die Ausstellung in Las Vegas richtet sich an Elektronikentwickler und nicht an Verbraucher. Ein Bericht von der Design Automation Conference</a></li>
<li><a href="../de458764/index.html">Grundlegende agile Praktiken f√ºr technische und nichttechnische Teams im Jahr 2019</a></li>
<li><a href="../de458766/index.html">IronPython auf der Seite des B√∂sen: Wie wir einen Cyberangriff auf √∂ffentliche Dienste in einem europ√§ischen Land aufgedeckt haben</a></li>
<li><a href="../de458768/index.html">5-6 Gr√ºnde, zu GolangConf zu kommen</a></li>
<li><a href="../de458774/index.html">Funktionales DBMS</a></li>
<li><a href="../de458778/index.html">Satellite 6.5 Reporting Engine: Was und warum</a></li>
<li><a href="../de458782/index.html">Anpassung von Programmen f√ºr ZX Spectrum an TR-DOS mit modernen Mitteln. Teil 3</a></li>
<li><a href="../de458784/index.html">√úbertragen Sie Projekte und Bibliotheken von Altium Designer an PADS Professional</a></li>
<li><a href="../de458786/index.html">Videospiel-Keeper halten die Spielkultur Schritt f√ºr Schritt aufrecht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>