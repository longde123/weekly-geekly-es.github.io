<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👞 🔻 👦🏽 Centrifugo v2 - masa depan server dan perpustakaan perpesanan waktu nyata untuk Go 🤛🏼 👨🏽‍🎓 🚖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa pembaca mungkin pernah mendengar tentang Centrifugo sebelumnya. Artikel ini akan fokus pada pengembangan versi kedua server dan pustaka waktu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Centrifugo v2 - masa depan server dan perpustakaan perpesanan waktu nyata untuk Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/416915/"><p>  Beberapa pembaca mungkin pernah mendengar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Centrifugo</a> sebelumnya.  Artikel ini akan fokus pada pengembangan versi kedua server dan pustaka waktu-nyata baru untuk bahasa Go yang mendasari itu. </p><br><p>  Nama saya Alexander Emelin.  Musim panas lalu, saya bergabung dengan tim Avito, di mana saya sekarang membantu mengembangkan backend messenger Avito.  Pekerjaan baru, yang terkait langsung dengan pengiriman cepat pesan kepada pengguna, dan kolega baru menginspirasi saya untuk terus bekerja pada proyek Centrifugo open-source. </p><br><p><img src="https://habrastorage.org/webt/cl/mo/yt/clmoytonrzc4exvj6eeky8j-zw4.jpeg"></p><a name="habracut"></a><br><p>  Singkatnya - ini adalah server yang bertugas menjaga koneksi konstan dari pengguna aplikasi Anda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Websocket</a> atau SockJS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">polyfill</a> digunakan sebagai transportasi, dapat, jika tidak mungkin untuk membuat koneksi Websocket, bekerja melalui Eventsource, streaming XHR, polling panjang dan transportasi berbasis HTTP lainnya.  Klien berlangganan saluran di mana backend melalui Centrifuge API menerbitkan pesan baru saat mereka muncul - setelah itu pesan dikirimkan kepada pengguna yang berlangganan saluran tersebut.  Dengan kata lain, ini adalah server PUB / SUB. </p><br><p><img src="https://habrastorage.org/webt/-c/ws/k-/-cwsk-n9eulxk4cd7v9berdltzy.png"></p><br><p> Saat ini, server digunakan dalam sejumlah besar proyek.  Di antara mereka, misalnya, adalah beberapa proyek Mail.Ru (intranet, platform pelatihan Technopark / Technosphere, Pusat Sertifikasi, dll.), Dengan Centrifugo, sebuah karya dashboard yang indah di resepsi di kantor Moskow Badoo, dan 350 ribu pengguna secara bersamaan terhubung ke layanan spot.im ke centrifuge. </p><br><p>  Beberapa tautan ke artikel sebelumnya di server dan aplikasinya bagi mereka yang pertama kali mendengar tentang proyek: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Selami Centrifugo</a> , </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Centrifugo - 3,5 juta rpm</a> , </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Serta artikel dalam bahasa Inggris yang menceritakan tentang sejarah proyek dan motivasi untuk penampilannya</a> . </li></ul><br><p>  Saya mulai mengerjakan versi kedua pada Desember tahun lalu dan berlanjut hingga hari ini.  Mari kita lihat apa yang terjadi.  Saya menulis artikel ini tidak hanya untuk mempopulerkan proyek, tetapi juga untuk mendapatkan umpan balik yang lebih konstruktif sebelum rilis Centrifugo v2 - sekarang ada ruang untuk bermanuver dan perubahan mundur yang tidak kompatibel. </p><br><h1 id="real-time-biblioteka-dlya-go">  Pustaka waktu nyata untuk Go </h1><br><p>  Di komunitas Go, pertanyaan muncul dari waktu ke waktu - apakah ada alternatif selain socket.io on Go?  Terkadang saya perhatikan bagaimana pengembang dalam menanggapi hal ini disarankan untuk melihat ke arah Centrifugo.  Namun, Centrifugo adalah server yang di-host-sendiri, bukan perpustakaan - perbandingannya tidak adil.  Saya juga telah ditanya beberapa kali apakah kode Centrifugo dapat digunakan kembali untuk menulis aplikasi real-time di Go.  Dan jawabannya adalah: secara teori memungkinkan, tetapi saya tidak dapat menjamin kompatibilitas mundur API paket internal dengan risiko saya sendiri.  Sudah jelas bahwa tidak ada alasan bagi siapa pun untuk mengambil risiko, dan forking juga merupakan opsi begitu-begitu.  Plus, saya tidak akan mengatakan bahwa API untuk paket internal umumnya disiapkan untuk penggunaan seperti itu. </p><br><p>  Oleh karena itu, salah satu tugas ambisius yang ingin saya selesaikan dalam proses mengerjakan versi kedua server adalah mencoba memisahkan inti server menjadi pustaka terpisah di Go.  Saya percaya ini masuk akal, mengingat berapa banyak fitur yang dimiliki Centrifuge untuk disesuaikan dengan produksi.  Ada banyak fitur yang tersedia di luar kotak untuk membantu membangun aplikasi real-time yang dapat diskalakan, menghilangkan kebutuhan pengembang untuk menulis solusi mereka sendiri.  Saya menulis tentang fitur-fitur ini sebelumnya dan saya juga akan menguraikan beberapa dari mereka di bawah ini. </p><br><p>  Saya akan mencoba untuk membenarkan satu lagi plus keberadaan perpustakaan seperti itu.  Sebagian besar pengguna Centrifugo adalah pengembang yang menulis backend dalam bahasa / kerangka kerja dengan dukungan konkurensi yang buruk (mis. Django / Flask / Laravel / ...): bekerja dengan banyak koneksi yang gigih jika mungkin, dengan cara yang tidak jelas atau tidak efisien.  Karenanya, tidak semua pengguna dapat membantu pengembangan server yang ditulis dalam Go (klise karena kurangnya pengetahuan bahasa).  Oleh karena itu, bahkan komunitas pengembang Go yang sangat kecil di sekitar perpustakaan akan dapat membantu mengembangkan server Centrifugo yang menggunakannya. </p><br><p>  Hasilnya adalah perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Centrifuge</a> .  Ini masih WIP, tetapi benar-benar semua fitur yang disebutkan dalam deskripsi tentang Github diimplementasikan dan berfungsi.  Karena perpustakaan menyediakan API yang cukup kaya, sebelum menjamin kompatibilitas ke belakang, saya ingin mendengar tentang beberapa contoh sukses penggunaan dalam proyek nyata di Go.  Belum ada.  Serta tidak berhasil :).  Tidak ada </p><br><p>  Saya mengerti bahwa dengan memberi nama perpustakaan dengan cara yang sama seperti server, saya akan selalu menghadapi kebingungan.  Tapi saya pikir ini adalah pilihan yang tepat, karena klien (seperti centrifuge-js, centrifuge-go) bekerja dengan perpustakaan Centrifuge dan server Centrifugo.  Plus, nama tersebut sudah tertanam kuat di benak pengguna, dan saya tidak ingin kehilangan asosiasi ini.  Namun, untuk sedikit lebih jelas, saya akan mengklarifikasi lagi: </p><br><ul><li>  Centrifuge - perpustakaan untuk bahasa Go, </li><li>  Centrifugo adalah solusi turnkey, layanan terpisah, yang dalam versi 2 akan dibangun di perpustakaan Centrifuge. </li></ul><br><p>  Karena desainnya, Centrifugo (layanan yang berdiri sendiri yang tidak tahu apa-apa tentang backend Anda) mengasumsikan bahwa aliran pesan melalui transportasi real-time akan pergi dari server ke klien.  Apa maksudmu  Jika, misalnya, pengguna menulis pesan ke obrolan, maka pesan ini terlebih dahulu harus dikirim ke aplikasi backend (misalnya, AJAX di browser), divalidasi di sisi backend, disimpan ke database jika perlu, dan kemudian dikirim ke API Centrifuge.  Perpustakaan menghapus batasan ini, memungkinkan Anda untuk mengatur pertukaran dua arah pesan asinkron antara server dan klien, serta panggilan RPC. </p><br><p><img src="https://habrastorage.org/webt/jf/_d/er/jf_dervpzmkl2fuprcse34ayoke.png"></p><br><p>  Mari kita lihat contoh sederhana: kita mengimplementasikan server kecil di Go menggunakan perpustakaan Centrifuge.  Server akan menerima pesan dari klien browser melalui Websocket, klien akan memiliki bidang teks di mana Anda dapat mengarahkan pesan, tekan Enter - dan pesan akan dikirim ke semua pengguna yang berlangganan saluran.  Yaitu, versi obrolan yang paling disederhanakan.  Bagiku terasa lebih mudah untuk menempatkan ini dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inti</a> . </p><br><p>  Anda dapat berjalan seperti biasa: </p><br><pre><code class="go hljs">git clone https:<span class="hljs-comment"><span class="hljs-comment">//gist.github.com/2f1a38ae2dcb21e2c5937328253c29bf.git cd 2f1a38ae2dcb21e2c5937328253c29bf go get -u github.com/centrifugal/centrifuge go run main.go</span></span></code> </pre> <br><p>  Lalu buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 8000</a> , buka beberapa tab browser. </p><br><p>  Seperti yang Anda lihat, titik masuk ke logika bisnis aplikasi terjadi ketika menggantung fungsi <code>On().Connect()</code> : </p><br><pre> <code class="go hljs">node.On().Connect(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, client *centrifuge.Client, e centrifuge.ConnectEvent)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">centrifuge</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConnectReply</span></span></span></span> { client.On().Disconnect(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e centrifuge.DisconnectEvent)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">centrifuge</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisconnectReply</span></span></span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"client disconnected"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centrifuge.DisconnectReply{} }) log.Printf(<span class="hljs-string"><span class="hljs-string">"client connected via %s"</span></span>, client.Transport().Name()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centrifuge.ConnectReply{} })</code> </pre> <br><p>  Pendekatan berbasis panggilan balik bagi saya terasa paling nyaman untuk berinteraksi dengan perpustakaan.  Plus, pendekatan yang serupa, hanya diketik dengan lemah, digunakan dalam implementasi <a href="">server socket-io di Go</a> .  Jika tiba-tiba Anda memiliki pemikiran tentang bagaimana API dapat dilakukan dengan lebih idiomatis - Saya akan senang mendengarnya. </p><br><p>  Ini adalah contoh yang sangat sederhana yang tidak menunjukkan semua fitur perpustakaan.  Seseorang mungkin mencatat bahwa untuk keperluan seperti itu lebih mudah untuk mengambil perpustakaan untuk bekerja dengan Websocket.  Misalnya, Gorilla Websocket.  Ini sebenarnya begitu.  Namun, bahkan dalam kasus ini, Anda harus menyalin sepotong kode server yang layak dari contoh di repositori Gorilla Websocket.  Bagaimana jika: </p><br><ul><li>  Anda perlu mengatur skala aplikasi ke beberapa mesin, </li><li>  atau Anda tidak perlu satu saluran umum, tetapi beberapa - dan pengguna dapat berlangganan dan berhenti berlangganan secara dinamis saat Anda menavigasi aplikasi Anda, </li><li>  atau Anda harus bekerja ketika koneksi Websocket tidak dapat dibangun (tidak ada dukungan di browser klien, ada ekstensi browser, semacam proxy di jalan antara klien dan server memotong koneksi), </li><li>  atau Anda perlu mengembalikan pesan yang terlewatkan oleh klien selama jeda singkat dalam koneksi Internet tanpa memuat basis data utama, </li><li>  atau Anda perlu mengontrol otorisasi pengguna di saluran, </li><li>  atau Anda perlu memutuskan koneksi permanen dari pengguna yang dinonaktifkan dalam aplikasi, </li><li>  atau Anda memerlukan informasi tentang siapa yang saat ini berada di saluran atau acara yang telah dilanggani / langganan seseorang dari saluran tersebut, </li><li>  atau apakah Anda memerlukan metrik dan pemantauan? </li></ul><br><p>  Pustaka Centrifuge dapat membantu Anda dengan ini - pada kenyataannya, itu mewarisi semua fitur dasar yang sebelumnya tersedia di Centrifugo.  Contoh lainnya yang menunjukkan poin yang disebutkan di atas dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> . </p><br><p>  Warisan kuat Centrifugo bisa menjadi minus, karena perpustakaan telah mengadopsi semua mekanisme server, yang cukup orisinal dan, mungkin, mungkin tampak tidak jelas atau kelebihan beban dengan fitur yang tidak perlu bagi seseorang.  Saya mencoba mengatur kode sedemikian rupa sehingga fitur yang tidak digunakan tidak mempengaruhi kinerja keseluruhan. </p><br><p>  Ada beberapa optimasi di perpustakaan yang memungkinkan penggunaan sumber daya yang lebih efisien.  Ini menggabungkan beberapa pesan ke dalam satu bingkai Websocket untuk menghemat panggilan sistem Tulis atau, misalnya, menggunakan Gogoprotobuf untuk membuat serialisasi pesan Protobuf dan lainnya.  Berbicara tentang Protobuf. </p><br><h1 id="binarnyy-protobuf-protokol">  Protokol Binary Protobuf </h1><br><p>  Saya benar-benar ingin Centrifugo bekerja dengan data biner ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dan bukan hanya saya</a> ), jadi di versi baru saya ingin menambahkan protokol biner selain yang sudah ada berdasarkan JSON.  Sekarang seluruh protokol digambarkan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema Protobuf</a> .  Ini memungkinkan kami untuk membuatnya lebih terstruktur, untuk memikirkan kembali beberapa keputusan yang tidak jelas dalam protokol versi pertama. </p><br><p>  Saya pikir Anda tidak perlu mengatakan untuk waktu yang lama apa keuntungan Protobuf atas JSON - kekompakan, kecepatan serialisasi, skema yang ketat.  Ada kelemahan dalam bentuk keterbacaan, tetapi sekarang pengguna memiliki kesempatan untuk memutuskan apa yang lebih penting bagi mereka dalam situasi tertentu. </p><br><p>  Secara umum, lalu lintas yang dihasilkan oleh protokol Centrifugo saat menggunakan Protobuf dan bukan JSON akan berkurang ~ 2 kali (tidak termasuk data aplikasi).  Konsumsi CPU dalam tes beban sintetis saya menurun sama ~ 2 kali dibandingkan dengan JSON.  Angka-angka ini sebenarnya berbicara sedikit tentang apa, dalam praktiknya, semuanya akan tergantung pada profil beban aplikasi tertentu. </p><br><p>  Demi kepentingan, saya meluncurkan pada mesin dengan Debian 9.4 dan 32 Intel® Xeon® Platinum 8168 CPU @ 2.70GHz benchmark vCPU, yang memungkinkan kami untuk membandingkan bandwidth interaksi klien-server jika menggunakan protokol JSON dan protokol Protobuf.  Ada 1.000 pelanggan untuk 1 saluran.  Di saluran ini, pesan diterbitkan dalam 4 aliran dan dikirim ke semua pelanggan.  Ukuran setiap pesan adalah 128 byte. </p><br><p>  Hasil untuk JSON: </p><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -s ws:<span class="hljs-comment"><span class="hljs-comment">//localhost:8000/connection/websocket -n 1000 -ns 1000 -np 4 channel Starting benchmark [msgs=1000, msgsize=128, pubs=4, subs=1000] Centrifuge Pub/Sub stats: 265,900 msgs/sec ~ 32.46 MB/sec Pub stats: 278 msgs/sec ~ 34.85 KB/sec [1] 73 msgs/sec ~ 9.22 KB/sec (250 msgs) [2] 71 msgs/sec ~ 9.00 KB/sec (250 msgs) [3] 71 msgs/sec ~ 8.90 KB/sec (250 msgs) [4] 69 msgs/sec ~ 8.71 KB/sec (250 msgs) min 69 | avg 71 | max 73 | stddev 1 msgs Sub stats: 265,635 msgs/sec ~ 32.43 MB/sec [1] 273 msgs/sec ~ 34.16 KB/sec (1000 msgs) ... [1000] 277 msgs/sec ~ 34.67 KB/sec (1000 msgs) min 265 | avg 275 | max 278 | stddev 2 msgs</span></span></code> </pre> <br><p>  Hasil untuk kasus Protobuf: </p><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> -s ws:<span class="hljs-comment"><span class="hljs-comment">//localhost:8000/connection/websocket?format=protobuf -n 100000 -ns 1000 -np 4 channel Starting benchmark [msgs=100000, msgsize=128, pubs=4, subs=1000] Centrifuge Pub/Sub stats: 681,212 msgs/sec ~ 83.16 MB/sec Pub stats: 685 msgs/sec ~ 85.69 KB/sec [1] 172 msgs/sec ~ 21.57 KB/sec (25000 msgs) [2] 171 msgs/sec ~ 21.47 KB/sec (25000 msgs) [3] 171 msgs/sec ~ 21.42 KB/sec (25000 msgs) [4] 171 msgs/sec ~ 21.42 KB/sec (25000 msgs) min 171 | avg 171 | max 172 | stddev 0 msgs Sub stats: 680,531 msgs/sec ~ 83.07 MB/sec [1] 681 msgs/sec ~ 85.14 KB/sec (100000 msgs) ... [1000] 681 msgs/sec ~ 85.13 KB/sec (100000 msgs) min 680 | avg 680 | max 685 | stddev 1 msgs</span></span></code> </pre><br><p>  Anda mungkin memperhatikan bahwa throughput instalasi semacam itu lebih dari 2 kali lebih besar dalam hal Protobuf.  Skrip klien dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> - ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip benchmark Nats yang disesuaikan dengan realitas Centrifuge</a> . </p><br><p>  Perlu juga dicatat bahwa kinerja serialisasi JSON di server dapat "dipompa" menggunakan pendekatan yang sama seperti di gogoprotobuf - kumpulan buffer dan pembuatan kode - saat ini JSON diserialisasi dengan paket dari pustaka standar Go yang dibangun berdasarkan refleksi.  Sebagai contoh, di Centrifugo, versi pertama JSON diserialisasi secara manual menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan</a> yang menyediakan <a href="">kumpulan buffer</a> .  Hal serupa dapat dilakukan di masa depan sebagai bagian dari versi kedua. </p><br><p>  Perlu ditekankan bahwa protobuf juga dapat digunakan saat berkomunikasi dengan server dari browser.  Klien javascript menggunakan pustaka protobuf.js untuk ini.  Karena pustaka protobuf cukup berat, dan jumlah pengguna dalam format biner akan kecil, menggunakan webpack dan algoritme pengguncangnya, kami menghasilkan dua versi klien - satu dengan dukungan protokol JSON saja, dan yang lainnya dengan dukungan JSON dan protobuf.  Untuk lingkungan lain di mana ukuran sumber daya tidak memainkan peran yang sangat penting, klien tidak dapat khawatir tentang pemisahan ini. </p><br><h1 id="json-web-token-jwt">  Token Web JSON (JWT) </h1><br><p>  Salah satu masalah dengan menggunakan server mandiri seperti Centrifugo adalah bahwa ia tidak tahu apa-apa tentang pengguna Anda dan metode otentikasi mereka, dan mekanisme sesi seperti apa yang digunakan backend Anda.  Dan Anda perlu mengautentikasi koneksi entah bagaimana. </p><br><p>  Untuk melakukan ini, dalam versi pertama Centrifuge, saat menghubungkan, tanda tangan SHA-256 HMAC digunakan, berdasarkan kunci rahasia yang hanya diketahui oleh backend dan Centrifuge.  Ini memastikan bahwa ID Pengguna yang dikirimkan oleh klien benar-benar miliknya. </p><br><p>  Mungkin transfer parameter koneksi yang benar dan pembuatan token adalah salah satu kesulitan utama dalam mengintegrasikan Centrifugo ke dalam proyek. </p><br><p>  Ketika Centrifuge muncul, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">standar JWT</a> belum begitu populer.  Sekarang, beberapa tahun kemudian, perpustakaan untuk generasi JWT tersedia untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebagian besar bahasa populer</a> .  Ide utama JWT adalah apa yang dibutuhkan Centrifuge: konfirmasi keaslian data yang dikirimkan.  Dalam HMAC versi kedua, tanda tangan yang dibuat secara manual memberi jalan bagi penggunaan JWT.  Ini memungkinkan untuk menghapus kebutuhan akan dukungan untuk fungsi pembantu untuk pembuatan token yang benar di perpustakaan untuk berbagai bahasa. </p><br><p>  Misalnya, dalam Python, token untuk menghubungkan ke Centrifugo dapat dihasilkan sebagai berikut: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time token = jwt.encode({<span class="hljs-string"><span class="hljs-string">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"42"</span></span>, <span class="hljs-string"><span class="hljs-string">"exp"</span></span>: int(time.time()) + <span class="hljs-number"><span class="hljs-number">10</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>}, <span class="hljs-string"><span class="hljs-string">"secret"</span></span>).decode() print(token)</code> </pre> <br><p>  Penting untuk dicatat bahwa jika Anda menggunakan perpustakaan Centrifuge, Anda dapat mengotentikasi pengguna menggunakan metode Go asli - di dalam middleware.  Contohnya ada di repositori. </p><br><h1 id="grpc">  GRPC </h1><br><p>  Selama pengembangan, saya mencoba GRPC streaming dua arah sebagai transportasi untuk komunikasi antara klien dan server (selain Websocket dan fallback SockJS berbasis HTTP).  Apa yang bisa saya katakan?  Dia bekerja.  Namun, saya tidak menemukan skenario tunggal di mana streaming GRPC dua arah akan lebih baik daripada Websocket.  Saya melihat terutama pada metrik server: lalu lintas yang dihasilkan melalui antarmuka jaringan, konsumsi CPU oleh server dengan sejumlah besar koneksi masuk, konsumsi memori per koneksi. </p><br><p>  GRPC hilang dari Websocket dalam segala hal: </p><br><ul><li>  GRPC menghasilkan 20% lebih banyak lalu lintas dalam skenario yang sama, </li><li>  GRPC mengkonsumsi 2-3 kali lebih banyak CPU (tergantung pada konfigurasi koneksi - semua berlangganan saluran yang berbeda atau semua berlangganan satu saluran), </li><li>  GRPC mengkonsumsi 4 kali lebih banyak RAM per koneksi.  Misalnya, pada koneksi 10k, server Websocket memakan 500 MB memori, dan GRPC - 2Gb. </li></ul><br><p>  Hasilnya cukup ... diharapkan.  Secara umum, dalam GRPC, sebagai transportasi klien, saya tidak melihat banyak akal - dan menghapus kode dengan hati nurani yang jelas sampai, mungkin, waktu yang lebih baik. </p><br><p>  Namun, GRPC sangat bagus untuk tujuan utamanya - untuk menghasilkan kode yang memungkinkan Anda melakukan panggilan RPC antar layanan menggunakan skema yang telah ditentukan.  Oleh karena itu, selain API HTTP, Centrifuge sekarang juga akan memiliki dukungan API berbasis GRPC, misalnya, untuk menerbitkan pesan baru ke saluran dan metode API server lain yang tersedia. </p><br><h1 id="slozhnosti-s-klientami">  Kesulitan dengan pelanggan </h1><br><p>  Perubahan yang dibuat dalam versi kedua, saya menghapus dukungan wajib perpustakaan untuk server API - menjadi lebih mudah untuk diintegrasikan di sisi server, namun, protokol klien dalam proyek diubah dan memiliki sejumlah fitur yang cukup.  Ini membuat implementasi pelanggan cukup sulit.  Untuk versi kedua, kami sekarang memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klien untuk Javascript</a> yang berfungsi di browser, harus bekerja dengan NodeJS dan React-Native.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klien di Go</a> dan dibangun berdasarkan dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengikat proyek gomobile</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk iOS dan Android</a> . </p><br><p>  Untuk kebahagiaan total, tidak ada cukup perpustakaan asli untuk iOS dan Android.  Untuk versi pertama Centrifugo, mereka dibeli oleh orang-orang dari komunitas open-source.  Saya ingin percaya hal seperti ini akan terjadi sekarang. </p><br><p>  Baru-baru ini saya mencoba keberuntungan saya dengan mengirimkan aplikasi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hibah MOSS dari Mozilla</a> , bermaksud untuk berinvestasi dalam pengembangan klien, tetapi ditolak.  Alasannya adalah komunitas yang kurang aktif di Github.  Sayangnya, ini benar, tetapi seperti yang Anda lihat, saya mengambil beberapa langkah untuk memperbaiki situasi. </p><br><p><img src="https://habrastorage.org/webt/y4/3q/kc/y43qkcl_yp7fjdgalrqvuzw5hl0.jpeg"></p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Saya tidak mengumumkan semua fitur yang akan muncul di Centrifugo v2 - sedikit lebih banyak informasi dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah di Github</a> .  Rilis server belum terjadi, tetapi akan segera terjadi.  Masih ada saat-saat yang belum selesai, termasuk kebutuhan untuk melengkapi dokumentasi.  Prototipe dokumentasi dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Jika Anda adalah pengguna Centrifugo, sekarang adalah waktu yang tepat untuk memengaruhi server versi kedua.  Suatu saat ketika tidak begitu menakutkan untuk memecahkan sesuatu, untuk kemudian berbuat lebih baik.  Bagi yang berminat: pengembangan terkonsentrasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di cabang c2</a> . </p><br><p>  Sulit bagi saya untuk menilai berapa banyak permintaan perpustakaan Centrifuge yang mendasari Centrifugo v2 akan diminati.  Saat ini, saya senang bahwa saya dapat membawanya ke keadaan saat ini.  Indikator terpenting bagi saya sekarang adalah jawaban atas pertanyaan "apakah saya sendiri akan menggunakan perpustakaan ini dalam proyek pribadi saya?"  Jawaban saya adalah ya.  Sedang bekerja?  Ya  Oleh karena itu, saya percaya bahwa pengembang lain akan menghargainya. </p><br><p>  PS Saya ingin mengucapkan terima kasih kepada orang-orang yang membantu pekerjaan dan saran - Dmitry Korolkov, Artemy Ryabinkov, Oleg Kuzmin.  Akan ketat tanpa Anda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416915/">https://habr.com/ru/post/id416915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416905/index.html">Presentasi Boston Dynamics SpotMini</a></li>
<li><a href="../id416907/index.html">Teori kebahagiaan. Hukum antrian zebra dan alien</a></li>
<li><a href="../id416909/index.html">PostgreSQL riwayat sesi aktif - ekstensi pgsentinel baru</a></li>
<li><a href="../id416911/index.html">Chatbots seharusnya menjadi terobosan berikutnya: apa yang salah?</a></li>
<li><a href="../id416913/index.html">Apa yang harus dilupakan administrator ketika beralih ke cloud - dan apa yang harus dipelajari</a></li>
<li><a href="../id416917/index.html">Kesedihan ketujuh</a></li>
<li><a href="../id416919/index.html">Burger King dan perekaman layar terselubung dari ponsel Anda</a></li>
<li><a href="../id416921/index.html">Bagaimana ratusan ribu antena bersatu dalam satu teleskop</a></li>
<li><a href="../id416925/index.html">Apa yang kita ketahui tentang Desain Ant</a></li>
<li><a href="../id416927/index.html">Startup sepatu - dan mengapa Silicon Valley sangat menyukainya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>