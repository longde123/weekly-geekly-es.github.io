<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤– ğŸ˜µ ğŸ“ƒ DevCoreï¼šDevBoyé¡¹ç›®çš„è½¯ä»¶éƒ¨åˆ† ğŸ“¥ ğŸ’œ âœğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="æœ‹å‹æ‚¨å¥½ï¼ 

 Nikolayå†æ¬¡ä¸æ‚¨åœ¨ä¸€èµ·ï¼Œåœ¨ä¸Šä¸€ç¯‡æ–‡ç« â€œ DevBoy-æˆ‘å¦‚ä½•åˆ›å»ºå¼€æºè®¾å¤‡é¡¹ç›®å¹¶åœ¨Kickstarterä¸Šå¯åŠ¨é¡¹ç›® â€ä¸­ï¼Œé‡ç‚¹æ›´å¤šåœ°æ”¾åœ¨å¤–è§‚å’Œç¡¬ä»¶ä¸Šï¼Œä»Šå¤©æˆ‘ä»¬å°†è®¨è®ºå¦‚ä½•åœ¨â€œ å†…éƒ¨ â€å®Œæˆå¹¶åˆ†æè½¯ä»¶éƒ¨åˆ†ã€‚ 



 è°åœ¨ä¹-æˆ‘è¦çŒ«ã€‚ 

 å¦‚å‰æ‰€è¿°ï¼Œè¯¥é¡¹ç›®åŸºäºARM Cortex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DevCoreï¼šDevBoyé¡¹ç›®çš„è½¯ä»¶éƒ¨åˆ†</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424309/">  <b>æœ‹å‹æ‚¨å¥½ï¼</b> <br><br>  Nikolayå†æ¬¡ä¸æ‚¨åœ¨ä¸€èµ·ï¼Œåœ¨ä¸Šä¸€ç¯‡æ–‡ç« â€œ <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DevBoy-æˆ‘å¦‚ä½•åˆ›å»ºå¼€æºè®¾å¤‡é¡¹ç›®å¹¶åœ¨Kickstarterä¸Šå¯åŠ¨é¡¹ç›®</a></i> â€ä¸­ï¼Œé‡ç‚¹æ›´å¤šåœ°æ”¾åœ¨å¤–è§‚å’Œç¡¬ä»¶ä¸Šï¼Œä»Šå¤©æˆ‘ä»¬å°†è®¨è®ºå¦‚ä½•åœ¨â€œ <i>å†…éƒ¨</i> â€å®Œæˆå¹¶åˆ†æè½¯ä»¶éƒ¨åˆ†ã€‚ <br><br><img src="https://habrastorage.org/webt/6r/n4/u8/6rn4u8jvzpd-c9_oykzqia4l8fk.jpeg"><br><br> è°åœ¨ä¹-æˆ‘è¦çŒ«ã€‚ <br><a name="habracut"></a><br> å¦‚å‰æ‰€è¿°ï¼Œè¯¥é¡¹ç›®åŸºäºARM Cortex-M4å†…æ ¸ä¸Šæ„æ³•åŠå¯¼ä½“çš„<b>STM32F415RG</b>å¾®æ§åˆ¶å™¨ã€‚ æœ‰å¤šç§ä¸åŒçš„IDEç”¨äºä¸ºè¿™äº›å¾®æ§åˆ¶å™¨å¼€å‘å¾®æ§åˆ¶å™¨ï¼Œä½†æ˜¯ï¼Œå¯¹äºä¸€ä¸ªå¼€æºé¡¹ç›®ï¼Œæ‚¨è‡³å°‘éœ€è¦ä¸€ä¸ªå…è´¹çš„IDEï¼Œæœ€å¥½æ˜¯å¼€æºçš„ã€‚ æ­¤å¤–ï¼Œ <b>STM32CubeMX</b>ä»å¿…é¡»æ”¯æŒIDEã€‚ åœ¨æˆ‘å¼€å§‹ä»äº‹è¿™ä¸ªé¡¹ç›®æ—¶ï¼Œåªæœ‰ä¸€ä¸ªIDEå¯ä»¥æ»¡è¶³æ‰€æœ‰è¿™äº›è¦æ±‚<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-STM32çš„System Workbench</a></b> ã€‚ <br><br><img src="https://habrastorage.org/webt/v7/pz/vi/v7pzviufspf40flvruysuro_ex0.png">  <i>ç›®å‰ï¼Œæœ‰Atollic TrueStudioï¼Œåœ¨æ„æ³•åŠå¯¼ä½“è´­ä¹°å®ƒä»¬åå…è´¹æä¾›ã€‚</i> <i><br></i> <br> ä¸‹ä¸€ä¸ªä½¿ç”¨çš„ç¨‹åºæ˜¯<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STM32CubeMX</a></b> ã€‚ è¯¥ç¨‹åºæ˜¯ç”¨äºä½¿ç”¨å›¾å½¢ç•Œé¢é…ç½®å¾®æ§åˆ¶å™¨å¤–å›´è®¾å¤‡çš„å®ç”¨ç¨‹åºã€‚ <br><img src="https://habrastorage.org/webt/i4/ym/3u/i4ym3unkrgskza2fmumqmmfzs1o.png"><br> ç»“æœæ˜¯åŒ…å«ç¡¬ä»¶æŠ½è±¡å±‚ï¼ˆHALï¼‰çš„ä»£ç ã€‚ è®¸å¤šç¨‹åºå‘˜å¹¶ä¸çœŸæ­£å–œæ¬¢è¿™ç§â€œ <i>åˆ›é€ </i> â€ï¼Œå®ƒå¹¶éæ²¡æœ‰é”™è¯¯ï¼Œä½†æ˜¯ï¼Œå®ƒæå¤§åœ°ç®€åŒ–äº†å¼€å‘å¹¶æé«˜äº†æ„æ³•åŠå¯¼ä½“ä¸åŒå¾®æ§åˆ¶å™¨ä¹‹é—´ç¨‹åºçš„å¯ç§»æ¤æ€§ã€‚ <br><br> å¦å¤–ï¼Œåœ¨é…ç½®è¿‡ç¨‹ä¸­ï¼Œæ‚¨å¯ä»¥æŒ‡å®šä½¿ç”¨æŸäº›ç¬¬ä¸‰<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">æ–¹å¼€æº</a></b>è½¯ä»¶ï¼Œä¾‹å¦‚<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FreeRTOS</a></b> ï¼Œ <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FatFS</a></b>å’Œå…¶ä»–ä¸€äº›å¼€æºè½¯ä»¶ã€‚ <br><br>  <b>æˆ‘ä»¬å·²ç»</b>å®Œæˆäº†æ‰€ç”¨è½¯ä»¶çš„æè¿°ï¼Œç°åœ¨è®©æˆ‘ä»¬ç»§ç»­è¿›è¡Œæœ€æœ‰è¶£çš„éƒ¨åˆ†<b>-DevCore</b> ã€‚ è¯¥åç§°æ¥è‡ªâ€œ <i>æ ¸å¿ƒå¼€å‘</i> â€ï¼Œè®©æˆ‘ä»¬æŒ‰é¡ºåºè¿›è¡Œã€‚ <br><br> é¦–å…ˆï¼Œå®ƒæ˜¯<b>C ++ RTOSåŒ…è£…å™¨</b> ï¼ˆ <i>åœ¨è¿™ç§æƒ…å†µä¸‹ä¸ºFreeRTOS</i> ï¼‰ã€‚ éœ€è¦Vrapperçš„åŸå› æœ‰ä¸¤ä¸ªï¼š <br><br><ul><li> åˆ›å»ºä¸€ä¸ªå¯¹è±¡ç„¶åè°ƒç”¨äº’æ–¥é”è¦å¥½å¾—å¤šï¼Œä¾‹å¦‚ï¼Œä»¥ï¼ˆï¼‰ä¸ºä¾‹ï¼Œæ¯”åˆ›å»ºä¸€ä¸ªå¥æŸ„ï¼Œè°ƒç”¨createå‡½æ•°ï¼Œç„¶åå°†æ­¤å¥æŸ„ä¼ é€’ç»™æ‰€æœ‰äº’æ–¥é”å‡½æ•°è¦å¥½å¾—å¤š </li><li> å¦‚æœæœ‰å¿…è¦æ›¿æ¢RTOSï¼Œåˆ™åªéœ€æ›¿æ¢åŒ…è£…å™¨å°±è¶³å¤Ÿäº†ï¼Œå¹¶ä¸”ä¸æ˜¯ä»ä»£ç ä¸­å¯¹RTOSå‡½æ•°çš„æ‰€æœ‰è°ƒç”¨ </li></ul><br> è°åœ¨ä¹ï¼ŒæŠŠåŒ…è£…å™¨ä»£ç å¸¦åˆ°è¿™é‡Œï¼Œè°åœ¨ä¹- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">æˆ‘ä»¬çœ‹ä¸€ä¸‹GitHub</a> ï¼Œç„¶åç»§ç»­ã€‚ <br><br> ä¸‹ä¸€éƒ¨åˆ†æ˜¯<b>åº”ç”¨ç¨‹åºæ¡†æ¶</b> ã€‚ è¿™æ˜¯æ‰€æœ‰ä»»åŠ¡çš„åŸºç±»ã€‚ ç”±äºè¿™äº›åªæ˜¯ä¸¤ä¸ªç›¸å¯¹è¾ƒå°çš„æ–‡ä»¶ï¼Œå› æ­¤å®Œæ•´åˆ—å‡ºå®ƒä»¬æ˜¯æœ‰æ„ä¹‰çš„ï¼š <br><br><div class="spoiler">  <b class="spoiler_title">æ ‡å¤´</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file AppTask.h // @author Nicolai Shlapunov // // @details DevCore: Application Task Base Class, header // // @section LICENSE // // Software License Agreement (Modified BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // 4. Redistribution and use of this software other than as permitted under // this license is void and will automatically terminate your rights under // this license. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** #ifndef AppTask_h #define AppTask_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" // ***************************************************************************** // * AppTask class. This class is wrapper for call C++ function from class. **** // ***************************************************************************** class AppTask { public: // ************************************************************************* // *** Init Task ******************************************************* // ************************************************************************* virtual void InitTask(void) {CreateTask();} protected: // ************************************************************************* // *** Constructor ***************************************************** // ************************************************************************* AppTask(uint16_t stk_size, uint8_t task_prio, const char name[], uint16_t queue_len = 0U, uint16_t queue_msg_size = 0U, void* task_msg_p = nullptr, uint32_t task_interval_ms = 0U) : ctrl_queue((queue_len + 2U), sizeof(CtrlQueueMsg)), task_queue(queue_len, queue_msg_size), task_msg_ptr(task_msg_p), timer(task_interval_ms, RtosTimer::REPEATING, TimerCallback, (void*)this), stack_size(stk_size), task_priority(task_prio), task_name(name) {}; // ************************************************************************* // *** Virtual destructor - prevent warning **************************** // ************************************************************************* virtual ~AppTask() {}; // ************************************************************************* // *** Create task function ******************************************** // ************************************************************************* // * This function creates new task in FreeRTOS, provide pointer to function // * and pointer to class as parameter. When TaskFunctionCallback() called // * from FreeRTOS, it use pointer to class from parameter to call virtual // * functions. void CreateTask(); // ************************************************************************* // *** Setup function ************************************************** // ************************************************************************* // * * virtual function - some tasks may not have Setup() actions virtual Result Setup() {return Result::RESULT_OK;} // ************************************************************************* // *** IntervalTimerExpired function *********************************** // ************************************************************************* // * Empty virtual function - some tasks may not have TimerExpired() actions virtual Result TimerExpired() {return Result::RESULT_OK;} // ************************************************************************* // *** ProcessMessage function ***************************************** // ************************************************************************* // * Empty virtual function - some tasks may not have ProcessMessage() actions virtual Result ProcessMessage() {return Result::RESULT_OK;} // ************************************************************************* // *** Loop function *************************************************** // ************************************************************************* // * Empty virtual function - some tasks may not have Loop() actions virtual Result Loop() {return Result::RESULT_OK;} // ************************************************************************* // *** SendTaskMessage function **************************************** // ************************************************************************* Result SendTaskMessage(const void* task_msg, bool is_priority = false); private: // Task control queue message types enum CtrlQueueMsgType { CTRL_TIMER_MSG, CTRL_TASK_QUEUE_MSG }; // Task control queue message struct struct CtrlQueueMsg { CtrlQueueMsgType type; }; // Task control queue RtosQueue ctrl_queue; // Task queue RtosQueue task_queue; // Pointer to receive message buffer void* task_msg_ptr; // Timer object RtosTimer timer; // Task stack size uint16_t stack_size; // Task priority uint8_t task_priority; // Pointer to the task name const char* task_name; // ************************************************************************* // *** IntLoop function ************************************************ // ************************************************************************* Result IntLoop(); // ************************************************************************* // *** TaskFunctionCallback ******************************************** // ************************************************************************* static void TaskFunctionCallback(void* ptr); // ************************************************************************* // *** IntervalTimerCallback function ********************************** // ************************************************************************* static void TimerCallback(void* ptr); // ************************************************************************* // *** SendControlMessage function ************************************* // ************************************************************************* Result SendControlMessage(const CtrlQueueMsg&amp; ctrl_msg, bool is_priority = false); // ************************************************************************* // *** Change counter ************************************************** // ************************************************************************* static void ChangeCnt(bool is_up); // ************************************************************************* // *** Private constructor and assign operator - prevent copying ******* // ************************************************************************* AppTask(); AppTask(const AppTask&amp;); AppTask&amp; operator=(const AppTask&amp;); }; #endif</span></span></code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">ä»£å·</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file AppTask.cpp // @author Nicolai Shlapunov // // @details DevCore: Application Task Base Class, implementation // // @copyright Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "AppTask.h" #include "RtosMutex.h" // ***************************************************************************** // *** Static variables **************************************************** // ***************************************************************************** static RtosMutex startup_mutex; static uint32_t startup_cnt = 0U; // ***************************************************************************** // *** Create task function ************************************************ // ***************************************************************************** void AppTask::CreateTask() { Result result = Result::RESULT_OK; // If interval timer period isn't zero or task queue present if((timer.GetTimerPeriod() != 0U) || (task_queue.GetQueueLen() != 0U)) { // Set Control Queue name ctrl_queue.SetName(task_name, "Ctrl"); // Create control queue result = ctrl_queue.Create(); } // If task queue present if(task_queue.GetQueueLen() != 0U) { // Set Task Queue name task_queue.SetName(task_name, "Task"); // Create task queue result |= task_queue.Create(); } // If interval timer period isn't zero if(timer.GetTimerPeriod() != 0U) { // Create timer result |= timer.Create(); } // Create task: function - TaskFunctionCallback(), parameter - pointer to "this" result |= Rtos::TaskCreate(TaskFunctionCallback, task_name, stack_size, this, task_priority); // Check result if(result.IsBad()) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement error handling Break(); } } // ***************************************************************************** // *** SendTaskMessage function ******************************************** // ***************************************************************************** Result AppTask::SendTaskMessage(const void* task_msg, bool is_priority) { Result result = Result::RESULT_OK; // Send task message to front or back of task queue if(is_priority == true) { result = task_queue.SendToFront(task_msg); } else { result = task_queue.SendToBack(task_msg); } // If successful - send message to the control queue if(result.IsGood()) { CtrlQueueMsg ctrl_msg; ctrl_msg.type = CTRL_TASK_QUEUE_MSG; result = SendControlMessage(ctrl_msg, is_priority); } return result; } // ***************************************************************************** // *** IntLoop function **************************************************** // ***************************************************************************** Result AppTask::IntLoop() { Result result = Result::RESULT_OK; while(result.IsGood()) { // Buffer for control message CtrlQueueMsg ctrl_msg; // Read on the control queue result = ctrl_queue.Receive(&amp;ctrl_msg, timer.GetTimerPeriod() * 2U); // If successful if(result.IsGood()) { // Check message type switch(ctrl_msg.type) { case CTRL_TIMER_MSG: result = TimerExpired(); break; case CTRL_TASK_QUEUE_MSG: { // Non blocking read from the task queue result = task_queue.Receive(task_msg_ptr, 0U); // If successful if(result.IsGood()) { // Process it! result = ProcessMessage(); } break; } default: result = Result::ERR_INVALID_ITEM; break; } } } return result; } // ***************************************************************************** // *** TaskFunctionCallback ************************************************ // ***************************************************************************** void AppTask::TaskFunctionCallback(void* ptr) { Result result = Result::ERR_NULL_PTR; if(ptr != nullptr) { // Set good result result = Result::RESULT_OK; // Get reference to the task object AppTask&amp; app_task = *(static_cast&lt;AppTask*&gt;(ptr)); // Increment counter before call Setup() ChangeCnt(true); // Call virtual Setup() function from AppTask class app_task.Setup(); // Decrement counter after call Setup() ChangeCnt(false); // Pause for give other tasks run Setup() RtosTick::DelayTicks(1U); // Pause while other tasks run Setup() before executing any Loop() while(startup_cnt) RtosTick::DelayTicks(1U); // If no timer or queue - just call Loop() function if((app_task.timer.GetTimerPeriod() == 0U) &amp;&amp; (app_task.task_queue.GetQueueLen() == 0U)) { // Call virtual Loop() function from AppTask class while(app_task.Loop() == Result::RESULT_OK); } else { // Start task timer if needed if(app_task.timer.GetTimerPeriod() != 0U) { result = app_task.timer.Start(); } // Check result if(result.IsGood()) { // Call internal AppTask function result = app_task.IntLoop(); } // Stop task timer if needed if(app_task.timer.GetTimerPeriod() != 0U) { result |= app_task.timer.Stop(); } } } // Check result if(result.IsBad()) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement error handling Break(); } // Delete task after exit Rtos::TaskDelete(); } // ***************************************************************************** // *** TimerCallback function ********************************************** // ***************************************************************************** void AppTask::TimerCallback(void* ptr) { Result result = Result::ERR_NULL_PTR; if(ptr != nullptr) { // Get reference to the task object AppTask&amp; task = *((AppTask*)ptr); // Create control timer message CtrlQueueMsg timer_msg; timer_msg.type = CTRL_TIMER_MSG; // Send message to the control queue result = task.SendControlMessage(timer_msg); } // Check result if(result.IsBad()) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement error handling Break(); } } // ***************************************************************************** // *** SendControlMessage function ***************************************** // ***************************************************************************** Result AppTask::SendControlMessage(const CtrlQueueMsg&amp; ctrl_msg, bool is_priority) { Result result; if(is_priority == true) { result = ctrl_queue.SendToFront(&amp;ctrl_msg); } else { result = ctrl_queue.SendToBack(&amp;ctrl_msg); } return result; } // ***************************************************************************** // *** Change counter ****************************************************** // ***************************************************************************** void AppTask::ChangeCnt(bool is_up) { // Take semaphore before change counter startup_mutex.Lock(); // Check direction if(is_up == true) { // Increment counter startup_cnt++; } else { // Decrement counter startup_cnt--; } // Give semaphore after changes startup_mutex.Release(); }</span></span></code> </pre></div></div><br> ç»§æ‰¿çš„ç±»å¯ä»¥è¦†ç›–4ä¸ªè™šå‡½æ•°ï¼š <br><br><ul><li>  <b>Setupï¼ˆï¼‰</b>æ˜¯å¼€å§‹ä»»åŠ¡ä¹‹å‰è°ƒç”¨çš„å‡½æ•°ã€‚ åœ¨æ‰§è¡Œä¸»å¾ªç¯ä¹‹å‰ï¼Œå¯ä»¥ç¡®ä¿æ‰€æœ‰ä»»åŠ¡çš„æ‰€æœ‰è¿™äº›åŠŸèƒ½çš„ä»£ç å®Œæˆã€‚ </li><li>  <b>Loopï¼ˆï¼‰</b> -ä¸»ä»»åŠ¡å‘¨æœŸï¼Œä»»åŠ¡æœ¬èº«åœ¨å…¶ä¸­ç»„ç»‡æ‰€éœ€çš„å†…å®¹ã€‚ ä¸èƒ½ä¸ä»¥ä¸‹ä¸¤ä¸ªåŠŸèƒ½ä¸€èµ·ä½¿ç”¨ã€‚ </li><li>  <b>TimerExpiredï¼ˆï¼‰</b> -ä»¥ç»™å®šé—´éš”å®šæœŸè°ƒç”¨çš„å‡½æ•°ã€‚ ä¾‹å¦‚ï¼Œæ–¹ä¾¿å®ç°è½®è¯¢ä¼ æ„Ÿå™¨ã€‚ </li><li>  <b>ProcessMessageï¼ˆï¼‰</b> -å¤„ç†æ¥è‡ªå…¶ä»–ä»»åŠ¡çš„æ¶ˆæ¯çš„åŠŸèƒ½ã€‚ </li></ul><br> å‰ä¸¤ä¸ªå‡½æ•°ä¸ºä»»åŠ¡å®ç°â€œ <i>Arduinoé£æ ¼</i> â€ã€‚ <br><br> æ¥ä¸‹æ¥çš„ä¸¤ä¸ªå®ç°äº†â€œ <i>äº‹ä»¶</i> â€ç³»ç»Ÿï¼Œç®€åŒ–äº†ä»»åŠ¡ä¹‹é—´çš„äº¤äº’ã€‚ é€šè¿‡è¿™ç§æ–¹æ³•ï¼Œä»»åŠ¡ä»¥å‡½æ•°çš„å½¢å¼å®ç°äº†å¤–éƒ¨æ¥å£ï¼Œè¯¥å‡½æ•°é€šè¿‡å†…éƒ¨é‚®ç®±å°†å‘é€æ•°æ®å‘é€åˆ°ä»»åŠ¡ã€‚ é€šè¿‡è¿™ç§æ–¹æ³•ï¼Œä½¿ç”¨è¯¥ç•Œé¢çš„ç”¨æˆ·æ— éœ€æ‹…å¿ƒåœ¨ä»€ä¹ˆä¸Šä¸‹æ–‡ä¸­æ‰§è¡ŒåŠ¨ä½œã€‚ æ²¡é”™ï¼Œè¿™ä»…é€‚ç”¨äºäºŒä¼ æ‰‹æˆ–å›¢é˜Ÿã€‚ å¯¹äºå¸æ°”å‰‚ï¼Œæœ€å¥½ä½¿ç”¨äº’æ–¥é”å’Œæ•°æ®å¤åˆ¶ä»¥é˜²æ­¢é•¿æ—¶é—´æ•è·äº’æ–¥é”ã€‚ <br><br> åœ¨æˆ‘å¼€å‘åŒ»ç–—è®¾å¤‡è½¯ä»¶æ—¶å‘ç°äº†è¿™ç§æ–¹æ³•ã€‚ å¾®æ§åˆ¶å™¨åªæœ‰ä¸€ä¸ª<i>çœ‹é—¨ç‹—ï¼Œ</i>å¦‚æœæœ‰å¾ˆå¤šä»»åŠ¡ï¼Œåˆ™éœ€è¦å…¨éƒ¨è·Ÿè¸ªã€‚ ä¸ºæ­¤ï¼Œæœ‰ä¸€ä¸ªå•ç‹¬çš„ä»»åŠ¡æœåŠ¡çœ‹é—¨ç‹—ï¼Œå¹¶ä»TimerExpiredï¼ˆï¼‰å‡½æ•°å‘é€çš„å…¶ä»–ä»»åŠ¡ä¸­æ¥æ”¶æ¶ˆæ¯ã€‚ å¦‚æœåœ¨ä»»åŠ¡* nçš„è®¡æ—¶æœŸå†…æ²¡æœ‰æ¶ˆæ¯ï¼Œåˆ™ä»»åŠ¡æ­»äº†ï¼Œæˆ‘ä»¬<s>ç†„ç­ç¯å¹¶</s>é‡‡å–æªæ–½å…³é—­æ‰€æœ‰å½±å“æ‚£è€…çš„è…ºä½“ã€‚ <br><br> æ‰€æœ‰ä»»åŠ¡éƒ½æ˜¯å•ä¾‹ï¼Œæ‚¨ä¸èƒ½ç›´æ¥åˆ›å»ºå®ƒä»¬ï¼Œä½†æ˜¯å¯ä»¥è·å–ä»»åŠ¡çš„é“¾æ¥ã€‚ ä¸ºæ­¤ï¼Œæ¯ä¸ªä»»åŠ¡éƒ½å®ç°é™æ€çš„<b>GetInstanceï¼ˆï¼‰</b>æ–¹æ³•ï¼š <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ***************************************************************************** // *** Get Instance ******************************************************** // ***************************************************************************** Application&amp; Application::GetInstance(void) { static Application application; return application; }</span></span></code> </pre> <br> è¿˜åŒ…æ‹¬<b>éŸ³é¢‘è¾“å‡º</b> ï¼Œ <b>è¾“å…¥æ¨¡å—</b>å’Œ<b>å±å¹•ç»´æŠ¤çš„ä»»åŠ¡ã€‚</b> <br><br>  <b>å£°éŸ³è¾“å‡º</b>çš„ä»»åŠ¡éå¸¸ç®€å•-å®ƒæ¥æ”¶é¢‘ç‡å’ŒæŒç»­æ—¶é—´çš„æ•°ç»„ï¼Œå¹¶ç®€å•åœ°å®šæœŸæ›´æ”¹è®¡æ—¶å™¨è®¾ç½®ä»¥ç”Ÿæˆç‰¹å®šé¢‘ç‡çš„çŸ©å½¢è„‰å†²ã€‚ <br><br><div class="spoiler">  <b class="spoiler_title">æ ‡å¤´</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file SoundDrv.h // @author Nicolai Shlapunov // // @details DevCore: Sound Driver Class, header // // @section LICENSE // // Software License Agreement (Modified BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // 4. Redistribution and use of this software other than as permitted under // this license is void and will automatically terminate your rights under // this license. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** #ifndef SoundDrv_h #define SoundDrv_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" #include "AppTask.h" #include "RtosMutex.h" #include "RtosSemaphore.h" // ***************************************************************************** // *** Sound Driver Class. This class implement work with sound. *********** // ***************************************************************************** class SoundDrv : public AppTask { public: // ************************************************************************* // *** Get Instance **************************************************** // ************************************************************************* // * This class is singleton. For use this class you must call GetInstance() // * to receive reference to Sound Driver class static SoundDrv&amp; GetInstance(void); // ************************************************************************* // *** Init Sound Driver Task ****************************************** // ************************************************************************* virtual void InitTask(TIM_HandleTypeDef *htm); // ************************************************************************* // *** Sound Driver Setup ********************************************** // ************************************************************************* virtual Result Setup(); // ************************************************************************* // *** Sound Driver Loop *********************************************** // ************************************************************************* virtual Result Loop(); // ************************************************************************* // *** Beep function *************************************************** // ************************************************************************* void Beep(uint16_t freq, uint16_t del, bool pause_after_play = false); // ************************************************************************* // *** Play sound function ********************************************* // ************************************************************************* void PlaySound(const uint16_t* melody, uint16_t size, uint16_t temp_ms = 100U, bool rep = false); // ************************************************************************* // *** Stop sound function ********************************************* // ************************************************************************* void StopSound(void); // ************************************************************************* // *** Mute sound function ********************************************* // ************************************************************************* void Mute(bool mute_flag); // ************************************************************************* // *** Is sound played function **************************************** // ************************************************************************* bool IsSoundPlayed(void); private: // Timer handle TIM_HandleTypeDef* htim = SOUND_HTIM; // Timer channel uint32_t channel = SOUND_CHANNEL; // Ticks variable uint32_t last_wake_ticks = 0U; // Pointer to table contains melody const uint16_t* sound_table = nullptr; // Size of table uint16_t sound_table_size = 0U; // Current position uint16_t sound_table_position = 0U; // Current frequency delay uint16_t current_delay = 0U; // Time for one frequency in ms uint32_t delay_ms = 100U; // Repeat flag bool repeat = false; // Mute flag bool mute = false; // Mutex to synchronize when playing melody frames RtosMutex melody_mutex; // Semaphore for start play sound RtosSemaphore sound_update; // ************************************************************************* // *** Process Button Input function *********************************** // ************************************************************************* void Tone(uint16_t freq); // ************************************************************************* // ** Private constructor. Only GetInstance() allow to access this class. ** // ************************************************************************* SoundDrv() : AppTask(SOUND_DRV_TASK_STACK_SIZE, SOUND_DRV_TASK_PRIORITY, "SoundDrv") {}; }; #endif</span></span></code> </pre> <br></div></div><br> ç»´ä¿®<b>æ°´æ¨¡å—</b>çš„ä»»åŠ¡ä¹Ÿå¾ˆç®€å•ã€‚ åœ¨æœ‰è¶£çš„ç‚¹ä¸­ï¼Œå°†è‡ªåŠ¨æ£€æµ‹æ¨¡å—ï¼šé¦–å…ˆï¼Œä½¿ç”¨ADCæµ‹é‡ç”µå‹ï¼Œå¦‚æœç”µå‹åœ¨ç”µæºç”µå‹çš„25ï¼…åˆ°75ï¼…çš„èŒƒå›´å†…ï¼Œåˆ™æ’å…¥æ¨¡æ‹Ÿæ“çºµæ†ï¼Œå¦åˆ™æ’å…¥æŒ‰é’®æˆ–ç¼–ç å™¨ã€‚ å¦‚æœä¸æ˜¯æ“çºµæ†ï¼Œè¯·æ£€æŸ¥I / Oæ¨¡å—çš„ç¬¬å››è¡Œï¼šå¦‚æœå¤„äºé«˜ç”µå¹³ï¼Œåˆ™ä¸ºæŒ‰é’®ï¼ˆå°†<i>æ‰€æœ‰æŒ‰é’®ä¸Šæ‹‰è‡³ç”µæºï¼Œå¹¶ä¸”åœ¨æŒ‰ä¸‹æŒ‰é’®æ—¶å°†å…¶å…³é—­åœ¨åœ°é¢ä¸Š</i> ï¼‰ï¼›å¦‚æœè¯¥<i>æŒ‰é’®</i>è¾ƒä½ï¼Œåˆ™ä¸ºç¼–ç å™¨ï¼ˆå°†ä¸€ä¸ª<i>å°æŒ‰é’®â€œæ‹‰èµ·â€ï¼‰æ¥åœ°å¹¶åœ¨æŒ‰ä¸‹æ—¶å…³é—­ç”µæº</i> ï¼‰ã€‚ <br><br><div class="spoiler">  <b class="spoiler_title">æ ‡å¤´</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file InputDrv.h // @author Nicolai Shlapunov // // @details DevCore: Input Driver Class, header // // @section LICENSE // // Software License Agreement (Modified BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // 4. Redistribution and use of this software other than as permitted under // this license is void and will automatically terminate your rights under // this license. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** #ifndef InputDrv_h #define InputDrv_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" #include "AppTask.h" // ***************************************************************************** // * Input Driver Class. This class implement work with user input elements like // * buttons and encoders. class InputDrv : public AppTask { public: // ************************************************************************* // *** Enum with all buttons ******************************************* // ************************************************************************* typedef enum { EXT_LEFT, // Left ext port EXT_RIGHT, // Right ext port EXT_MAX // Ext port count } PortType; // ************************************************************************* // *** Enum with all devices types ************************************* // ************************************************************************* typedef enum { EXT_DEV_NONE, // No device EXT_DEV_BTN, // Buttons(cross) EXT_DEV_ENC, // Encoder EXT_DEV_JOY, // Joystick EXT_DEV_MAX // Device types count } ExtDeviceType; // ************************************************************************* // *** Enum with all buttons ******************************************* // ************************************************************************* typedef enum { BTN_UP, // Up button BTN_LEFT, // Left button BTN_DOWN, // Down button BTN_RIGHT, // Right button BTN_MAX // Buttons count } ButtonType; // ************************************************************************* // *** Enum with all encoder buttons *********************************** // ************************************************************************* typedef enum { ENC_BTN_ENT, // Press on the knob ENC_BTN_BACK, // Small button ENC_BTN_MAX // Buttons count } EncButtonType; // ************************************************************************* // *** Get Instance **************************************************** // ************************************************************************* // * This class is singleton. For use this class you must call GetInstance() // * to receive reference to Input Driver class static InputDrv&amp; GetInstance(void); // ************************************************************************* // *** Init Input Driver Task ****************************************** // ************************************************************************* // * This function initialize Input Driver class. If htim provided, this // * timer will be used instead FreeRTOS task. virtual void InitTask(TIM_HandleTypeDef* htm, ADC_HandleTypeDef* had); // ************************************************************************* // *** Input Driver Setup ********************************************** // ************************************************************************* virtual Result Setup(); // ************************************************************************* // *** Input Driver Loop *********************************************** // ************************************************************************* // * If FreeRTOS task used, this function just call ProcessInput() with 1 ms // * period. If FreeRTOS tick is 1 ms - this task must have highest priority virtual Result Loop(); // ************************************************************************* // *** Process Input function ****************************************** // ************************************************************************* // * Main class function - must call periodically for process user input. // * If timer used, this function must be called from interrupt handler. void ProcessInput(void); // ************************************************************************* // *** Process Encoders Input function ********************************* // ************************************************************************* void ProcessEncodersInput(void); // ************************************************************************* // *** Get device type ************************************************* // ************************************************************************* ExtDeviceType GetDeviceType(PortType port); // ************************************************************************* // *** Get button state ************************************************ // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetButtonState(PortType port, ButtonType button); // ************************************************************************* // *** Get button state ************************************************ // ************************************************************************* // Return button state change flag: true - changed, false - not changed bool GetButtonState(PortType port, ButtonType button, bool&amp; btn_state); // ************************************************************************* // *** Get encoder counts from last call ******************************* // ************************************************************************* // * Return state of encoder. Class counts encoder clicks and stored inside. // * This function substract from current encoder counter last_enc_val and // * return it to user. Before return last_enc_val will be assigned to // * current encoder counter. int32_t GetEncoderState(PortType port, int32_t&amp; last_enc_val); // ************************************************************************* // *** Get button state ************************************************ // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetEncoderButtonState(PortType port, EncButtonType button); // ************************************************************************* // *** Get encoder button state **************************************** // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetEncoderButtonState(PortType port, EncButtonType button, bool&amp; btn_state); // ************************************************************************* // *** Get joystick counts from last call ****************************** // ************************************************************************* void GetJoystickState(PortType port, int32_t&amp; x, int32_t&amp; y); // ************************************************************************* // *** SetJoystickCalibrationConsts ************************************ // ************************************************************************* // * Set calibration constants. Must be call for calibration joystick. void SetJoystickCalibrationConsts(PortType port, int32_t x_mid, int32_t x_kmin, int32_t x_kmax, int32_t y_mid, int32_t y_kmin, int32_t y_kmax); // ************************************************************************* // *** Get joystick button state *************************************** // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetJoystickButtonState(PortType port); // ************************************************************************* // *** Get joystick button state *************************************** // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetJoystickButtonState(PortType port, bool&amp; btn_state); private: // How many cycles button must change state before state will be changed in // result returned by GetButtonState() function. For reduce debouncing const static uint32_t BUTTON_READ_DELAY = 4U; // Coefficient for calibration const static int32_t COEF = 100; // ADC max value - 12 bit const static int32_t ADC_MAX_VAL = 0xFFF; // Joystich threshold const static int32_t JOY_THRESHOLD = 1000; // Ticks variable uint32_t last_wake_ticks = 0U; // ************************************************************************* // *** Structure to describe button ************************************ // ************************************************************************* typedef struct { bool btn_state; // Button state returned by GetButtonState() function bool btn_state_tmp; // Temporary button state for reduce debouncing uint8_t btn_state_cnt; // Counter for reduce debouncing GPIO_TypeDef* button_port;// Button port uint16_t button_pin; // Button pin GPIO_PinState pin_state; // High/low on input treated as pressed } ButtonProfile; // ************************************************************************* // *** Structure to describe encoder *********************************** // ************************************************************************* typedef struct { // Encoder rotation int32_t enc_cnt; // Encoder counter uint8_t enc_state; // Current state of encder clock &amp; data pins GPIO_TypeDef* enc_clk_port; // Encoder clock port uint16_t enc_clk_pin; // Encoder clock pin GPIO_TypeDef* enc_data_port;// Encoder data port uint16_t enc_data_pin; // Encoder data pin } EncoderProfile; // ************************************************************************* // *** Structure to describe joysticks ********************************* // ************************************************************************* typedef struct { int32_t x_ch_val; // Joystick X axis value uint32_t x_channel; // Joystick X axis ADC channel GPIO_TypeDef* x_port; // Joystick X axis port uint16_t x_pin; // Joystick X axis pin int32_t bx; // Joystick X offset int32_t kxmin; // Joystick X coefficient int32_t kxmax; // Joystick X coefficient bool x_inverted; // Joystick X inverted flag int32_t y_ch_val; // Joystick Y axis value uint32_t y_channel; // Joystick Y axis ADC channel GPIO_TypeDef* y_port; // Joystick Y axis port uint16_t y_pin; // Joystick Y axis pin int32_t by; // Joystick Y offset int32_t kymin; // Joystick Y coefficient int32_t kymax; // Joystick Y coefficient bool y_inverted; // Joystick Y inverted flag } JoystickProfile; // ************************************************************************* // *** Structure to describe encoders ********************************** // ************************************************************************* typedef struct { EncoderProfile enc; ButtonProfile btn[ENC_BTN_MAX]; } DevEncoders; // ************************************************************************* // *** Structure to describe encoders ********************************** // ************************************************************************* typedef struct { JoystickProfile joy; ButtonProfile btn; } DevJoysticks; // ************************************************************************* // *** Structure to describe buttons *********************************** // ************************************************************************* typedef struct { ButtonProfile button[BTN_MAX]; } DevButtons; // *** Array describes types of connected devices *********************** ExtDeviceType devices[EXT_MAX]; // *** Structures array for describe buttons inputs ********************* DevButtons buttons[EXT_MAX] = { // Left device {{{false, false, 0, EXT_L1_GPIO_Port, EXT_L1_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_L2_GPIO_Port, EXT_L2_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_L3_GPIO_Port, EXT_L3_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_L4_GPIO_Port, EXT_L4_Pin, GPIO_PIN_RESET}}}, // Right device {{{false, false, 0, EXT_R1_GPIO_Port, EXT_R1_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_R2_GPIO_Port, EXT_R2_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_R3_GPIO_Port, EXT_R3_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_R4_GPIO_Port, EXT_R4_Pin, GPIO_PIN_RESET}}} }; // *** Structures array for describe encoders inputs ******************** DevEncoders encoders[EXT_MAX] = { // Left device {{0, 0, EXT_L1_GPIO_Port, EXT_L1_Pin, EXT_L2_GPIO_Port, EXT_L2_Pin}, // Encoder {{false, false, 0, EXT_L3_GPIO_Port, EXT_L3_Pin, GPIO_PIN_RESET}, // Button Enter {false, false, 0, EXT_L4_GPIO_Port, EXT_L4_Pin, GPIO_PIN_SET}}}, // Button Back // Right device {{0, 0, EXT_R1_GPIO_Port, EXT_R1_Pin, EXT_R2_GPIO_Port, EXT_R2_Pin}, // Encoder {{false, false, 0, EXT_R3_GPIO_Port, EXT_R3_Pin, GPIO_PIN_RESET}, // Button Enter {false, false, 0, EXT_R4_GPIO_Port, EXT_R4_Pin, GPIO_PIN_SET}}} // Button Back }; // *** Structures array for describe encoders inputs ******************** DevJoysticks joysticks[EXT_MAX] = { // Left device {{0, ADC_CHANNEL_11, EXT_L2_GPIO_Port, EXT_L2_Pin, 0, COEF, COEF, false, // Joystick 0, ADC_CHANNEL_10, EXT_L1_GPIO_Port, EXT_L1_Pin, 0, COEF, COEF, true}, {false, false, 0, EXT_L3_GPIO_Port, EXT_L3_Pin, GPIO_PIN_RESET}}, // Button // Right device {{0, ADC_CHANNEL_13, EXT_R2_GPIO_Port, EXT_R2_Pin, 0, COEF, COEF, false, // Joystick 0, ADC_CHANNEL_12, EXT_R1_GPIO_Port, EXT_R1_Pin, 0, COEF, COEF, true}, {false, false, 0, EXT_R3_GPIO_Port, EXT_R3_Pin, GPIO_PIN_RESET}} // Button }; // Handle to timer used for process encoders input TIM_HandleTypeDef* htim = nullptr; // Handle to timer used for process encoders input ADC_HandleTypeDef* hadc = nullptr; // ************************************************************************* // *** Process Button Input function *********************************** // ************************************************************************* void ProcessButtonInput(ButtonProfile&amp; button); // ************************************************************************* // *** Process Encoder Input function ********************************** // ************************************************************************* void ProcessEncoderInput(EncoderProfile&amp; encoder); // ************************************************************************* // *** Process Joystick Input function ********************************* // ************************************************************************* void ProcessJoystickInput(JoystickProfile&amp; joysticks, PortType port); // ************************************************************************* // *** Emulate buttons using joystick function ************************* // ************************************************************************* void EmulateButtonsByJoystick(PortType port); // ************************************************************************* // *** Emulate encoders using buttons function ************************* // ************************************************************************* void EmulateEncodersByButtons(PortType port); // ************************************************************************* // *** Configure inputs devices types ********************************** // ************************************************************************* ExtDeviceType DetectDeviceType(PortType port); // ************************************************************************* // *** Configure ADC *************************************************** // ************************************************************************* void ConfigADC(ExtDeviceType dev_left, ExtDeviceType dev_right); // ************************************************************************* // *** Configure inputs for read digital/analog data ******************* // ************************************************************************* void ConfigInputIO(bool is_digital, PortType port); // ************************************************************************* // ** Private constructor. Only GetInstance() allow to access this class. ** // ************************************************************************* InputDrv() : AppTask(INPUT_DRV_TASK_STACK_SIZE, INPUT_DRV_TASK_PRIORITY, "InputDrv") {}; }; #endif</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">å±å¹•ç»´æŠ¤</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ä»»åŠ¡</font><font style="vertical-align: inherit;">æ˜¯æœ€æœ‰è¶£çš„ä»»åŠ¡ã€‚é¦–å…ˆï¼Œå±å¹•ä¸º320x240x16bitï¼Œå› æ­¤</font><font style="vertical-align: inherit;">å¸§ç¼“å†²åŒº</font><font style="vertical-align: inherit;">éœ€è¦</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">153600å­—èŠ‚</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ã€‚è¿™ä¸åªæ˜¯å¾ˆå¤šï¼Œè€Œä¸”æ˜¯å·¨å¤§çš„-åœ¨æ­¤å¾®æ§åˆ¶å™¨ä¸­åªæœ‰192kçš„RAMï¼Œè€Œåœ¨å¾®æ§åˆ¶å™¨ä¸­æ ¹æœ¬æ²¡æœ‰åˆé€‚çš„å¤§å°å¯èƒ½ä¼šæ›´å®¹æ˜“ã€‚æ€ä¹ˆæ ·ç­”æ¡ˆå¾ˆç®€å•ï¼šå°†å±å¹•åˆ†æˆå‡ éƒ¨åˆ†ï¼ä½†æ˜¯æ‚¨å¯ä»¥ç”¨ä¸åŒçš„æ–¹å¼ç”»äº›ä¸œè¥¿ã€‚ã€‚ã€‚</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">æˆ‘ä¸ºè¿™é¡¹ä»»åŠ¡ç”³è¯·çš„è§£å†³æ–¹æ¡ˆå°±åƒæ‰€æœ‰å·§å¦™çš„æ–¹æ³•ä¸€æ ·ã€‚å®ƒåœ¨ä¸¤ä¸ªå±å¹•è¡Œä¸Šéƒ½æœ‰ä¸€ä¸ªç¼“å†²åŒºã€‚æˆ‘ä»¬ç»˜åˆ¶æ‰€æœ‰åº”åœ¨ä¸€è¡Œä¸­çš„å†…å®¹ï¼Œç„¶åé€šè¿‡DMAæ¨¡å¼ä¸‹çš„SPIå°†å…¶å‘é€åˆ°å±å¹•ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥å‡†å¤‡å¦ä¸€è¡Œã€‚</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ä»»åŠ¡å¦‚ä½•çŸ¥é“è¡Œä¸­åº”è¯¥åŒ…å«ä»€ä¹ˆä»¥åŠå¦‚ä½•ç»˜åˆ¶ï¼Ÿä½†æ˜¯å¥¹</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ä¸çŸ¥é“ï¼</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ä½†æ˜¯å¥¹æœ‰ä¸€ç³»åˆ—çŸ¥é“å¦‚ä½•ç»˜ç”»çš„å¯¹è±¡ã€‚</font><font style="vertical-align: inherit;">æ¯ä¸ªæ­¤ç±»å¯¹è±¡å‡ä»</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VisObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ç±»ç»§æ‰¿</font><font style="vertical-align: inherit;">ã€‚</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">æ ‡å¤´</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file VisObject.h // @author Nicolai Shlapunov // // @details DevCore: Visual Object Base Class, header // // @section LICENSE // // Software License Agreement (BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // //****************************************************************************** #ifndef VisObject_h #define VisObject_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" // ***************************************************************************** // * VisObject class. This class implements base Visual Objects properties. class VisObject { public: // ************************************************************************* // *** Action ********************************************************** // ************************************************************************* typedef enum { ACT_TOUCH, // When object touched ACT_UNTOUCH, // When object detouched ACT_MOVE, // When object moved on object ACT_MOVEIN, // When object moved in to object ACT_MOVEOUT, // When object moved out of object ACT_MAX // Total possible actions } ActionType; // ************************************************************************* // *** VisObject ******************************************************* // ************************************************************************* VisObject() {}; // ************************************************************************* // *** ~VisObject ****************************************************** // ************************************************************************* // * Destructor. Call DelVisObjectFromList() from DisplayDrv class for // * remove from list before delete and delete semaphore. virtual ~VisObject(); // ************************************************************************* // *** LockVisObject *************************************************** // ************************************************************************* void LockVisObject(); // ************************************************************************* // *** UnlockVisObject ************************************************* // ************************************************************************* void UnlockVisObject(); // ************************************************************************* // *** Show ************************************************************ // ************************************************************************* // * Show VisObject on screen. This function call AddVisObjectToList() from // * DisplayDrv class. When this function calls first time, user must // * provide Z level. In future user can call this function without // * parameters - previously set Z will be used. virtual void Show(uint32_t z_pos = 0); // ************************************************************************* // *** Hide ************************************************************ // ************************************************************************* // * Hide VisObject from screen. This function call DelVisObjectFromList() // * from DisplayDrv class. virtual void Hide(void); // ************************************************************************* // *** IsShow ********************************************************** // ************************************************************************* // * Check status of Show Visual Object. Return true if object in DisplayDrv list. virtual bool IsShow(void); // ************************************************************************* // *** Move ************************************************************ // ************************************************************************* // * Move object on screen. Set new x and y coordinates. If flag is set - // * move is relative, not absolute. virtual void Move(int32_t x, int32_t y, bool is_delta = false); // ************************************************************************* // *** DrawInBufH ****************************************************** // ************************************************************************* // * Draw one horizontal line of object in specified buffer. // * Each derived class must implement this function. virtual void DrawInBufH(uint16_t* buf, int32_t n, int32_t row, int32_t start_y = 0) = 0; // ************************************************************************* // *** DrawInBufW ****************************************************** // ************************************************************************* // * Draw one vertical line of object in specified buffer. // * Each derived class must implement this function. virtual void DrawInBufW(uint16_t* buf, int32_t n, int32_t line, int32_t start_x = 0) = 0; // ************************************************************************* // *** Action ********************************************************** // ************************************************************************* virtual void Action(ActionType action, int32_t tx, int32_t ty); // ************************************************************************* // *** Return Start X coordinate *************************************** // ************************************************************************* virtual int32_t GetStartX(void) {return x_start;}; // ************************************************************************* // *** Return Start Y coordinate *************************************** // ************************************************************************* virtual int32_t GetStartY(void) {return y_start;}; // ************************************************************************* // *** Return End X coordinate ***************************************** // ************************************************************************* virtual int32_t GetEndX(void) {return x_end;}; // ************************************************************************* // *** Return End Y coordinate ***************************************** // ************************************************************************* virtual int32_t GetEndY(void) {return y_end;}; // ************************************************************************* // *** Return Width of object ****************************************** // ************************************************************************* virtual int32_t GetWidth(void) {return width;}; // ************************************************************************* // *** Return Height of object ***************************************** // ************************************************************************* virtual int32_t GetHeight(void) {return height;}; protected: // ************************************************************************* // *** Object parameters *********************************************** // ************************************************************************* // X and Y start coordinates of object int16_t x_start = 0, y_start = 0; // X and Y end coordinates of object int16_t x_end = 0, y_end = 0; // Width and Height of object int16_t width = 0, height = 0; // Rotation of object int8_t rotation = 0; // Object active bool active = false; private: // ************************************************************************* // *** Object parameters *********************************************** // ************************************************************************* // * Only base class and DisplayDrv have access to this parameters // Z position of object uint16_t z = 0; // Pointer to next object. This pointer need to maker object list. Object // can be added only to one list. VisObject* p_next = nullptr; // Pointer to next object. This pointer need to maker object list. Object // can be added only to one list. VisObject* p_prev = nullptr; // DisplayDrv is friend for access to pointers and Z friend class DisplayDrv; }; #endif</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">æ¯è¡Œçš„å±å¹•ç»´æŠ¤ä»»åŠ¡éƒ½ä¼šéå†å¯¹è±¡åˆ—è¡¨ï¼Œå¹¶è°ƒç”¨DrawInBufWï¼ˆï¼‰å‡½æ•°ï¼Œå¹¶å‘å…¶ä¼ é€’æŒ‡å‘ç¼“å†²åŒºçš„æŒ‡é’ˆï¼Œç‚¹æ•°ï¼Œè¦ç»˜åˆ¶çš„çº¿å’Œèµ·å§‹ä½ç½®ï¼ˆ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ç›´åˆ°ä½¿ç”¨äº†ä½¿ç”¨å±å¹•æ§åˆ¶å™¨æ¨¡å¼æ›´æ–°â€œçª—å£â€çš„æƒ³æ³•</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ï¼‰ã€‚å®é™…ä¸Šï¼Œæ¯ä¸ªå¯¹è±¡éƒ½åœ¨å·²ç»˜åˆ¶çš„å…¶ä»–å¯¹è±¡ä¹‹ä¸Šç»˜åˆ¶è‡ªèº«ï¼Œå¹¶ä¸”åªéœ€å°†å®ƒä»¬æ”¾ç½®åœ¨åˆ—è¡¨ä¸­çš„æ‰€éœ€ä½ç½®å³å¯è½»æ¾æŒ‰æ‰€éœ€é¡ºåºæ’åˆ—å¯¹è±¡ã€‚</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">å¦å¤–ï¼Œè¿™ç§æ–¹æ³•ä½¿é›†æˆæ´»åŠ¨å¯¹è±¡çš„å¤„ç†å˜å¾—å®¹æ˜“-åœ¨ä»è§¦æ‘¸å±æ§åˆ¶å™¨æ¥æ”¶åæ ‡ä¹‹åï¼Œå±å¹•ç»´æŠ¤ä»»åŠ¡å¯ä»¥ä»å¤´å¼€å§‹éå†å·¥ä½œè¡¨ï¼Œä»¥æœç´¢è½å…¥æŒ‰å‹åæ ‡çš„æ´»åŠ¨å¯¹è±¡ã€‚å¦‚æœæ‰¾åˆ°è¿™æ ·çš„å¯¹è±¡ï¼Œåˆ™ä¸ºæ­¤å¯¹è±¡è°ƒç”¨è™šæ‹Ÿå‡½æ•°Actionï¼ˆï¼‰ã€‚</font></font><br><br>       , ( <i>, , </i> ),    ( <i>  </i> ). <br><br>    <b>DevCore</b>       UI( <i> </i> ),    I2C,  I2C       BME280  EEPROM 24256,           â€”     . <br><br>    <s>   </s>  <b>GitHub</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/nickshl/devboy</a> <br><br> <b>PS</b>   ,    Epic Fail'.      ,     - " <i> </i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">â€œï¼Œä»ä¸€ä¸ªå¯èƒ½ä»æœ‰å…³HabrÃ©çš„æ–‡ç« ä¸­äº†è§£äº†è¿™ä¸ªé¡¹ç›®çš„äººé‚£é‡Œå¾—åˆ°çš„180ç¾å…ƒï¼ˆ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">è°¢è°¢æ‚¨ï¼ŒAndreyï¼</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ï¼‰ï¼Œå…¶ä½™çš„åˆ™æ¥è‡ªæˆ‘çš„åŒäº‹ä»ä¸€ä¸ªç›¸é‚»çš„ç«‹æ–¹ä½“ä¸­å¾—åˆ°çš„ã€‚</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ä¸æ”¶é’±ä¸æ˜¯é—®é¢˜ã€‚é—®é¢˜æ˜¯å¯¹è¯¥é¡¹ç›®ç¼ºä¹å…´è¶£...</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424309/">https://habr.com/ru/post/zh-CN424309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424295/index.html">éº»çœç†å·¥å­¦é™¢çš„è¯¾ç¨‹â€œè®¡ç®—æœºç³»ç»Ÿå®‰å…¨â€ã€‚ è®²åº§9ï¼šâ€œ Webåº”ç”¨ç¨‹åºå®‰å…¨æ€§â€ï¼Œç¬¬2éƒ¨åˆ†</a></li>
<li><a href="../zh-CN424297/index.html">éº»çœç†å·¥å­¦é™¢çš„è¯¾ç¨‹â€œè®¡ç®—æœºç³»ç»Ÿå®‰å…¨â€ã€‚ è®²åº§9ï¼šWebåº”ç”¨ç¨‹åºå®‰å…¨æ€§ï¼Œç¬¬3éƒ¨åˆ†</a></li>
<li><a href="../zh-CN424301/index.html">è‡ªé€‚åº”ç¥ç»ç½‘ç»œå›¾åƒæ»¤æ³¢ç®—æ³•</a></li>
<li><a href="../zh-CN424305/index.html">Uberè·¨å¹³å°ç§»åŠ¨æ¶æ„RIB</a></li>
<li><a href="../zh-CN424307/index.html">GitLab 11.3ä¸Mavenå­˜å‚¨åº“å’Œå®‰å…¨ç¯å¢ƒä¸€èµ·å‘å¸ƒ</a></li>
<li><a href="../zh-CN424311/index.html">è¿™äº›å¤©çš„å¼‚æ­¥ä¸šåŠ¡é€»è¾‘</a></li>
<li><a href="../zh-CN424313/index.html">EveryLangæ˜¯ä¸€ä¸ªå‡ ä¹å¯ä»¥åšæ‰€æœ‰äº‹æƒ…çš„ç¨‹åº</a></li>
<li><a href="../zh-CN424315/index.html">æ–°ä¸€è½®è¿›å£æ›¿ä»£ã€‚ åœ¨å“ªé‡Œè·‘æ­¥ï¼Œæ€ä¹ˆåŠï¼Ÿ</a></li>
<li><a href="../zh-CN424319/index.html">ç½‘ä¸Šå•†åº—çš„ç»“æ„ã€‚ ç¬¬äºŒéƒ¨åˆ†</a></li>
<li><a href="../zh-CN424321/index.html">è®©NetFlowä¾¿å®œåˆç”Ÿæ°”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>