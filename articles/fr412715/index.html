<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏽 👲🏻 💇🏻 Apprendre la programmation Go multithread avec des images 🙂 🚲 😷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Très probablement, vous avez déjà entendu parler du langage de programmation Go, sa popularité ne cesse de croître, ce qui est tout à fait raisonnable...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apprendre la programmation Go multithread avec des images</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412715/"><img src="https://habrastorage.org/webt/qk/hi/im/qkhiimd_phctfhx4kka_rhpkepq.png"><br>  Très probablement, vous avez déjà entendu parler du langage de programmation Go, sa popularité ne cesse de croître, ce qui est tout à fait raisonnable.  Cette langue est simple, rapide et repose sur une grande communauté.  L'un des aspects les plus curieux du langage est le modèle de programmation multi-thread.  Les primitives sous-jacentes vous permettent de créer facilement et simplement des programmes multithreads.  Cet article est destiné à ceux qui veulent apprendre ces primitives: les goroutines et les canaux.  Et, à travers les illustrations, je montrerai comment travailler avec eux.  J'espère que cela vous sera d'une grande aide dans votre étude future. <br><a name="habracut"></a><br><h4>  Programmes simples et multithreads </h4><br>  Vous avez probablement déjà écrit des programmes à un seul thread.  Habituellement, cela ressemble à ceci: il existe un ensemble de fonctions pour effectuer diverses tâches, chaque fonction n'est appelée que lorsque la précédente a préparé des données pour elle.  Ainsi, le programme s'exécute séquentiellement. <br><br>  Ce sera notre premier exemple - le programme d'extraction de minerai.  Nos fonctions rechercheront, extrairont et traiteront le minerai.  Le minerai dans la mine dans notre exemple est représenté par des listes de chaînes, les fonctions les prennent comme paramètres et renvoient une liste de chaînes «traitées».  Pour un programme monothread, notre application sera conçue comme suit: <br><br><img src="https://habrastorage.org/webt/c5/ua/ja/c5uajayyncivzzj9_orh-u_sw34.png"><br><br>  Dans cet exemple, tout le travail est effectué par un seul thread (le gopher de Gary).  Trois fonctions principales: la recherche, la production et le traitement sont exécutées séquentiellement les unes après les autres. <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} foundOre := finder(theMine) minedOre := miner(foundOre) smelter(minedOre) }</code> </pre> <br>  Si nous imprimons le résultat de chaque fonction, nous obtenons ce qui suit: <br><br><pre> <code class="hljs powershell">From Finder: [<span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span>] From Miner: [<span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span>] From Smelter: [<span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span>]</code> </pre><br>  La conception et la mise en œuvre simples sont un plus d'une approche à fil unique.  Mais que faire si vous souhaitez exécuter et exécuter des fonctions indépendamment les unes des autres?  Ici, la programmation multithread vous est utile. <br><br><img src="https://habrastorage.org/webt/om/x1/mq/omx1mqphfsqqs57lab9bngsnggi.png"><br>  Cette approche de l'extraction du minerai est beaucoup plus efficace.  Maintenant, plusieurs threads (gophers) fonctionnent indépendamment, et Gary ne fait qu'une partie du travail.  Un gopher cherche du minerai, l'autre produit et le troisième fond, et tout cela est potentiellement simultané.  Pour implémenter cette approche, nous avons besoin de deux choses dans le code: créer des processeurs gopher indépendamment les uns des autres et transférer le minerai entre eux.  Go a des goroutines et des canaux pour cela. <br><br><h4>  Gorutins </h4><br>  Les goroutines peuvent être considérées comme des "threads légers", pour créer des goroutines il vous suffit de mettre le mot <b>-</b> clé <b>go</b> avant le code d'appel de la fonction.  Pour montrer à quel point c'est simple, créons deux fonctions de recherche, appelons-les avec le mot <b>-</b> clé <b>go</b> et imprimons un message chaque fois qu'ils trouvent le «minerai» dans leur mine. <br><img src="https://habrastorage.org/webt/jz/wx/nb/jzwxnbgxocr-a0rq7kmdoujt_gg.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder1(theMine) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder2(theMine) &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//       }</span></span></code> </pre><br>  Le résultat de notre programme sera le suivant: <br><br><pre> <code class="hljs pgsql">Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore!</code> </pre><br>  Comme vous pouvez le voir, il n'y a pas d'ordre dans lequel la fonction «trouve le minerai» en premier;  les fonctions de recherche fonctionnent simultanément.  Si vous exécutez l'exemple plusieurs fois, la commande sera différente.  Nous pouvons maintenant exécuter des programmes multithread (multisphère), ce qui représente un progrès sérieux.  Mais que faire lorsque nous devons établir une connexion entre des goroutins indépendants?  Le moment est venu pour la magie des chaînes. <br><br><h4>  Chaînes </h4><br><img src="https://habrastorage.org/webt/pa/a-/5r/paa-5r_dtecx3fzem9r0dsv42jo.png"><br>  Les canaux permettent aux goroutins d'échanger des données.  C'est une sorte de pipe à travers laquelle les goroutins peuvent envoyer et recevoir des informations d'autres goroutines. <br><img src="https://habrastorage.org/webt/-d/vp/fz/-dvpfzbpaa65exwi7l4pgerte48.png"><br>  La lecture et l'écriture sur le canal sont effectuées à l'aide de l'opérateur fléché (&lt;-), qui indique la direction du mouvement des données. <br><img src="https://habrastorage.org/webt/wd/1j/qp/wd1jqp8ipkwvcdgc5xbuoyy6wey.png"><br><pre> <code class="go hljs">myFirstChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) myFirstChannel &lt;- <span class="hljs-string"><span class="hljs-string">"hello"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    myVariable := &lt;- myFirstChannel //   </span></span></code> </pre><br>  Maintenant, notre gopher-scout n'a plus besoin d'accumuler de minerai, il peut immédiatement le transférer davantage en utilisant des canaux. <br><img src="https://habrastorage.org/webt/60/yx/_j/60yx_jlczbwcy2tfmsqgvzwp4dg.png"><br>  J'ai mis à jour l'exemple, maintenant le code du chercheur de minerai et du mineur est des fonctions anonymes.  Ne vous embêtez pas trop si vous ne les avez pas rencontrés auparavant, gardez juste à l'esprit que chacun d'eux est appelé avec le mot clé <b>go</b> , donc, il sera exécuté dans son propre goroutine.  La chose la plus importante ici est que les goroutins transmettent des données entre eux en utilisant le canal <b>oreChan</b> .  Et nous traiterons les fonctions anonymes plus près de la fin. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{“ore1”, “ore2”, “ore3”} oreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   go func(mine [5]string) { for _, item := range mine { oreChan &lt;- item // } }(theMine) //   go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChan // fmt.Println(“Miner: Received “ + foundOre + “ from finder”) } }() &lt;-time.After(time.Second * 5) //     }</span></span></code> </pre><br>  La conclusion ci-dessous démontre clairement que notre mineur reçoit trois fois du canal du minerai une portion à la fois. <br><br><pre> <code class="hljs cs">Miner: Received ore1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore3 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder</code> </pre><br>  Donc, maintenant nous pouvons transférer des données entre différents goroutines (gophers), mais avant de commencer à écrire un programme complexe, regardons quelques propriétés importantes des canaux. <br><br><h4>  Serrures </h4><br>  Dans certaines situations, lorsque vous travaillez avec des canaux, le goroutin peut être bloqué.  Cela est nécessaire pour que les goroutines puissent se synchroniser avant de commencer ou de continuer à travailler. <br><br><h4>  Verrouillage en écriture </h4><br><img src="https://habrastorage.org/webt/ir/vv/zi/irvvziqxuk3opysywirescrn40e.png"><br><br>  Lorsque le goroutin (gopher) envoie des données à un canal, il est bloqué jusqu'à ce qu'un autre goroutine lise les données du canal. <br><br><h4>  Verrou de lecture </h4><br><img src="https://habrastorage.org/webt/eq/e5/k8/eqe5k854n39oia6xwaavj5xfk-q.png"><br><br>  Semblable au verrouillage lors de l'écriture sur un canal, goroutin peut être verrouillé lors de la lecture à partir d'un canal jusqu'à ce que rien n'y soit écrit. <br>  Si les écluses, à première vue, vous semblent compliquées, vous pouvez les imaginer comme un «transfert d'argent» entre deux goroutins (gophers).  Lorsqu'un gopher veut transférer ou recevoir de l'argent, il doit attendre le deuxième participant à la transaction. <br><br>  Après avoir traité des verrous goroutine sur les canaux, discutons de deux types de canaux différents: tamponnés et non tamponnés.  En choisissant tel ou tel type, nous déterminons largement le comportement du programme. <br><br><h4>  Chaînes sans tampon </h4><br><img src="https://habrastorage.org/webt/hv/k0/ba/hvk0badnrvqhncjqf9uwyrlowq8.png"><br><br>  Dans tous les exemples précédents, nous avons utilisé uniquement ces canaux.  Sur ces canaux, une seule donnée peut être transmise à la fois (avec blocage, comme décrit ci-dessus). <br><br><h4>  Canaux tamponnés </h4><br><img src="https://habrastorage.org/webt/zs/zg/b1/zszgb15grrrjjiyaqs6gwtfkkye.png"><br><br>  Les flux d'un programme ne peuvent pas toujours être parfaitement synchronisés.  Supposons, dans notre exemple, qu'il se soit produit qu'un gopher-scout a trouvé trois parties de minerai, tandis qu'un gopher-miner n'a réussi à extraire qu'une partie des réserves trouvées en même temps.  Ici, pour que la reconnaissance du gopher ne passe pas la majeure partie de son temps à attendre que le mineur termine son travail, nous utiliserons des canaux tamponnés.  Commençons par créer un canal d'une capacité de 3. <br><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Nous pouvons envoyer plusieurs données sur le canal tamponné, sans avoir besoin de les lire avec un autre goroutine.  C'est la principale différence avec les canaux sans tampon. <br><br><img src="https://habrastorage.org/webt/sh/ok/f2/shokf2oswaiw1yk6i-uwplypezi.png"><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"first"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 1st"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"second"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 2nd"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"third"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 3rd"</span></span>) }() &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { firstRead := &lt;- bufferedChan fmt.Println(<span class="hljs-string"><span class="hljs-string">"Receiving.."</span></span>) fmt.Println(firstRead) secondRead := &lt;- bufferedChan fmt.Println(secondRead) thirdRead := &lt;- bufferedChan fmt.Println(thirdRead) }()</code> </pre><br>  L'ordre de sortie dans un tel programme sera le suivant: <br><br><pre> <code class="hljs dos">Sent <span class="hljs-number"><span class="hljs-number">1</span></span>st Sent <span class="hljs-number"><span class="hljs-number">2</span></span>nd Sent <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-built_in"><span class="hljs-built_in">rd</span></span> Receiving.. first second third</code> </pre><br>  Pour éviter des complications inutiles, nous n'utiliserons pas de canaux tamponnés dans notre programme.  Mais il est important de se rappeler que ces types de chaînes sont également disponibles. <br>  Il est également important de noter que les canaux en mémoire tampon ne vous empêchent pas toujours de bloquer.  Par exemple, si un scout gopher est dix fois plus rapide qu'un mineur gopher et qu'ils sont connectés via un canal tamponné d'une capacité de 2, le scout gopher sera bloqué chaque fois qu'il est envoyé, s'il y a déjà deux éléments de données dans le canal. <br><br><h4>  Tout mettre ensemble </h4><br>  Ainsi, armés de goroutines et de canaux, nous pouvons écrire un programme en utilisant tous les avantages de la programmation multithread dans Go. <br><br><img src="https://habrastorage.org/webt/cq/xa/h7/cqxah7wnmg1wbcjqwhd13gyejaw.png"><br><pre> <code class="go hljs">theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} oreChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) minedOreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  go func(mine [5]string) { for _, item := range mine { if item == "ore" { oreChannel &lt;- item //   oreChannel } } }(theMine) //  go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChannel //   oreChannel fmt.Println("From Finder: ", foundOre) minedOreChan &lt;- "minedOre" //   minedOreChan } }() //  go func() { for i := 0; i &lt; 3; i++ { minedOre := &lt;-minedOreChan //   minedOreChan fmt.Println("From Miner: ", minedOre) fmt.Println("From Smelter: Ore is smelted") } }() &lt;-time.After(time.Second * 5) //    </span></span></code> </pre><br>  Un tel programme produira les éléments suivants: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted</code> </pre><br>  Par rapport à notre premier exemple, il s'agit d'une amélioration majeure, maintenant toutes les fonctions sont exécutées indépendamment, chacune dans son propre goroutine.  Et nous avons également obtenu un convoyeur à partir de canaux, à travers lequel le minerai est transféré immédiatement après le traitement.  Pour rester concentré sur une compréhension de base du fonctionnement des chaînes et des goroutines, j'ai omis certains points, ce qui peut entraîner des difficultés de lancement du programme.  En conclusion, je veux m'attarder sur ces caractéristiques de la langue, car elles aident à travailler avec les goroutines et les canaux. <br><br><h4>  Gorutins anonymes </h4><br><img src="https://habrastorage.org/webt/ko/t5/y6/kot5y6lv7cf-3h2zbyghvqwf1is.png"><br><br>  Tout comme nous exécutons une fonction régulière dans goroutine, nous pouvons déclarer une fonction anonyme immédiatement après le mot clé <b>go</b> et l'appeler en utilisant la syntaxe suivante: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   go func() { fmt.Println("I'm running in my own go routine") }()</span></span></code> </pre><br>  Ainsi, si nous avons besoin d'appeler une fonction à un seul endroit, nous pouvons l'exécuter dans un goroutine séparé sans se soucier de sa déclaration à l'avance. <br><br><h4>  La fonction principale est la goroutine. </h4><br><img src="https://habrastorage.org/webt/c_/bo/y7/c_boy7hpqt3y3krcd1utthdjy3s.png"><br><br>  Oui, la fonction <b>principale</b> fonctionne dans son propre goroutine.  Et, plus important encore, après son achèvement, tous les autres goroutines se terminent également.  C'est pour cette raison que nous avons placé un appel de temporisation à la fin de notre fonction <b>principale</b> .  Cet appel crée un canal et lui envoie des données après 5 secondes. <br><br><pre> <code class="go hljs">&lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre><br>  Rappelez-vous que goroutine sera bloqué lors de la lecture de la chaîne jusqu'à ce que quelque chose lui soit envoyé?  C'est exactement ce qui se produit lorsque le code spécifié est ajouté.  Le goroutine principal sera bloqué, ce qui donnera aux autres goroutias 5 secondes de temps pour travailler.  Cette méthode fonctionne bien, mais généralement une approche différente est utilisée pour vérifier que tous les goroutins ont terminé leur travail.  Pour transmettre un signal de fin de travail, un canal spécial est créé, le goroutine principal est bloqué de lecture et, dès que le goroutin fille termine son travail, il écrit sur ce canal;  Le goroutine principal est déverrouillé et le programme se termine. <br><br><img src="https://habrastorage.org/webt/vi/4e/zv/vi4ezv-tyvzugvamrwi3z9xod8a.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { doneChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  -  doneChan &lt;- “I'm all done!” }() &lt;-doneChan //        }</span></span></code> </pre><br><h4>  Lire à partir d'un tuyau dans une boucle pour plage </h4><br>  Dans notre exemple, dans la fonction du goffer-getter, nous avons utilisé la boucle <b>for</b> pour sélectionner trois éléments dans le canal.  Mais que faire si on ne sait pas à l'avance combien de données peuvent être dans le canal?  Dans de tels cas, vous pouvez utiliser le canal comme argument de la boucle <b>for-range</b> , tout comme avec les collections.  La fonction mise à jour peut ressembler à ceci: <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//  go func() { for foundOre := range oreChan { fmt.Println(“Miner: Received “ + foundOre + “ from finder”) } }()</span></span></code> </pre><br>  Ainsi, le minerai lira tout ce que le scout lui envoie; l'utilisation du canal dans le cycle le garantira.  Veuillez noter qu'après que toutes les données du canal ont été traitées, le cycle se verrouille à la lecture;  pour éviter le blocage, vous devez fermer le canal en appelant <b>close (channel)</b> . <br><br><h4>  Lecture de canaux non bloquants </h4><br>  En utilisant la construction <b>select-case</b> , le blocage des lectures du tuyau peut être évité.  Voici un exemple d'utilisation de cette construction: goroutine lira les données du canal, si seulement elles s'y trouvent, sinon le bloc <b>par défaut</b> est exécuté: <br><br><pre> <code class="go hljs">myChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ myChan &lt;- “Message!” }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(“No Msg”) } &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(“No Msg”) }</code> </pre><br>  Une fois lancé, ce code affichera les éléments suivants: <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-type"><span class="hljs-type">Msg</span></span> <span class="hljs-type"><span class="hljs-type">Message!</span></span></code> </pre><br><h4>  Enregistrement de canaux non bloquants </h4><br>  Les verrous lors de l'écriture sur un canal peuvent être évités en utilisant la même construction de <b>sélection de cas</b> .  Faisons une petite modification de l'exemple précédent: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> myChan &lt;- “message”: fmt.Println(“sent the message”) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(“no message sent”) }</code> </pre><br><h4>  Quoi étudier davantage </h4><br><img src="https://habrastorage.org/webt/d6/69/yd/d669ydnx51qv_h0tf-p-lbo8xyu.png"><br><br>  Il existe un grand nombre d'articles et de rapports qui couvrent le travail avec les chaînes et les goroutines de manière beaucoup plus détaillée.  Et maintenant, avec le code, vous avez une idée claire de pourquoi et comment ces outils sont utilisés, vous pouvez tirer le meilleur parti des matériaux suivants: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Google I / O 2012 - Modèles de concurrence d'accès Go</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rob Pike - «La concurrence n'est pas le parallélisme»</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GopherCon 2017: Edward Muller - Go Anti-Patterns</a> </li></ul><br><br>  Merci d'avoir pris le temps de lire.  J'espère que je vous ai aidé à comprendre les chaînes, les goroutines et les avantages que les programmes multithread vous procurent. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412715/">https://habr.com/ru/post/fr412715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412703/index.html">Lors d'une conférence avec Veeam: bilan de VeeamON 2018 et invitation au VeeamON Forum à Moscou</a></li>
<li><a href="../fr412705/index.html">Piratage du système: comment nous avons changé la sélection et l'adaptation des développeurs</a></li>
<li><a href="../fr412709/index.html">Oh, mon code: apprentissage automatique et analyse chez les camarades de classe</a></li>
<li><a href="../fr412711/index.html">Pour vérifier les équations d'Einstein, vous devez frapper un trou noir</a></li>
<li><a href="../fr412713/index.html">Un aperçu des innovations les plus intéressantes de la mise à jour de May Power BI</a></li>
<li><a href="../fr412717/index.html">Bonjour les étrangers; s'il te plait ne nous tue pas</a></li>
<li><a href="../fr412719/index.html">MDG annonce un concours de synthèse vocale</a></li>
<li><a href="../fr412721/index.html">Trois espoirs de l'humanité pour la découverte des extraterrestres</a></li>
<li><a href="../fr412723/index.html">À la recherche d'une nouvelle couleur d'un milliard de dollars</a></li>
<li><a href="../fr412725/index.html">Comment rendre votre infrastructure informatique ennuyeuse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>