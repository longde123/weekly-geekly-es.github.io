<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚑 🤘🏼 🔞 [CppCon 2018] Herb Sutter: Auf dem Weg zu einem einfacheren und leistungsstärkeren C ++ 🖕🏼 🧙🏾 🤳🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In seiner Rede auf der CppCon 2018 präsentierte Herb Sutter der Öffentlichkeit seine Leistungen in zwei Richtungen. Zuallererst ist es die Steuerung d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[CppCon 2018] Herb Sutter: Auf dem Weg zu einem einfacheren und leistungsstärkeren C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425873/"><iframe width="560" height="315" src="https://www.youtube.com/embed/80BZxujhY38" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> In seiner Rede auf der CppCon 2018 präsentierte Herb Sutter der Öffentlichkeit seine Leistungen in zwei Richtungen.  Zuallererst ist es die <strong>Steuerung der Lebensdauer von</strong> Variablen (Lifetime), die es ermöglicht, ganze Fehlerklassen in der Kompilierungsphase zu erkennen.  Zweitens handelt es sich um einen aktualisierten Vorschlag für <strong>Metaklassen</strong> , mit dem Code-Duplikationen vermieden werden können, sobald das Verhalten einer Klassenkategorie beschrieben und dann mit einer Zeile mit bestimmten Klassen verbunden wird. </p><a name="habracut"></a><br><h2 id="predislovie-bolshe--prosche">  Vorwort: mehr = einfacher ?! </h2><br><p>  C ++ Vorwürfe sind zu hören, dass der Standard sinnlos und gnadenlos wächst.  Aber selbst die leidenschaftlichsten Konservativen werden nicht argumentieren, dass neue Konstruktionen wie Range-for (Erfassungszyklus) und Auto (zumindest für Iteratoren) den Code einfacher machen.  Sie können ungefähre Kriterien entwickeln, die (mindestens eine, im Idealfall alle) neuen Spracherweiterungen erfüllen müssen, um den Code in der Praxis zu vereinfachen: </p><br><ol><li>  Code reduzieren, vereinfachen, doppelten Code entfernen (range-for, auto, lambda, Metaclasses) </li><li>  Erleichtern Sie das Schreiben von sicherem Code, vermeiden Sie Fehler und Sonderfälle (intelligente Zeiger, Lebensdauern). </li><li>  Ersetzen Sie alte, weniger funktionale Funktionen vollständig (typedef → using) </li></ol><br><p>  Herb Sutter identifiziert "modernes C ++" - eine Teilmenge von Funktionen, die modernen Codierungsstandards (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Core Guidelines</a> ) entsprechen, und betrachtet den vollständigen Standard als "Kompatibilitätsmodus", den nicht jeder kennen muss.  Dementsprechend ist alles in Ordnung, wenn "modernes C ++" nicht wächst. </p><br><h2 id="proverki-vremeni-zhizni-peremennyh-lifetime">  Überprüfen der Lebensdauer von Variablen (Lebensdauer) </h2><br><p>  Die neue Lifetime Verification Group ist jetzt als Teil des Core Guidelines Checker für Clang und Visual C ++ verfügbar.  Ziel ist es nicht, wie bei Rust absolute Genauigkeit und Genauigkeit zu erreichen, sondern einfache und schnelle Überprüfungen innerhalb einzelner Funktionen durchzuführen. </p><br><h3 id="osnovnye-principy-proverki">  Grundprinzipien der Verifikation </h3><br><p>  Unter dem Gesichtspunkt der Lebenszeitanalyse werden Typen in drei Kategorien unterteilt: </p><br><ul><li>  Der Wert ist das, worauf ein Zeiger zeigen kann. </li><li> Zeiger - bezieht sich auf den Wert, steuert jedoch nicht dessen Lebensdauer.  Kann hängen (baumelnder Zeiger).  Beispiele: <code>T*</code> , <code>T&amp;</code> , Iteratoren, <code>std::observer_ptr&lt;T&gt;</code> , <code>std::string_view</code> , <code>gsl::span&lt;T&gt;</code> </li><li>  Eigentümer - steuert die Lebensdauer des Werts.  Normalerweise kann der Wert vorzeitig gelöscht werden.  Beispiele: <code>std::unique_ptr&lt;T&gt;</code> , <code>std::shared_ptr&lt;T&gt;</code> , <code>std::vector&lt;T&gt;</code> , <code>std::string</code> , <code>gsl::owner&lt;T*&gt;</code> </li></ul><br><p>  Ein Zeiger kann sich in einem der folgenden Zustände befinden: </p><br><ul><li>  Zeigen Sie auf einen Wert, der auf dem Stapel gespeichert ist </li><li>  Zeigen Sie auf einen Wert, der von einem Eigentümer "innen" enthalten ist </li><li>  Sei leer (null) </li><li>  Hang (ungültig) </li></ul><br><h3 id="ukazateli-i-znacheniya">  Zeiger und Werte </h3><br><p>  Für jeden Zeiger <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.259ex" height="1.817ex" viewBox="-38.5 -520.7 542 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-70" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> p </script>  wird verfolgt <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.251ex" height="2.66ex" viewBox="-38.5 -832 3122 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex; margin-left: -0.089ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-70" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-73" x="503" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-65" x="973" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-74" x="1439" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMAIN-28" x="1801" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-70" x="2190" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMAIN-29" x="2694" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> pset (p) </script>  - die Menge von Werten, auf die es hinweisen kann.  Wenn ein Wert gelöscht wird, tritt er insgesamt auf <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.272ex" height="2.298ex" viewBox="-38.5 -728.2 1839.5 989.6" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-70" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-73" x="503" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-65" x="973" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-74" x="1439" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> pset </script>  ersetzt durch <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-16"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">g</span><span class="MJXp-mrow" id="MJXp-Span-20"><span class="MJXp-mo" id="MJXp-Span-21" style="margin-left: 0em; margin-right: 0em;">ü</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">g</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.256ex" height="2.419ex" viewBox="0 -780.1 3554.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-75" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-6E" x="572" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-67" x="1173" y="0"></use><g transform="translate(1653,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">ü</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-6C" x="2068" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-74" x="2366" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-69" x="2728" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-67" x="3073" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> ungültig </script>  .  Beim Zugriff auf einen Zeigerwert <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.259ex" height="1.817ex" viewBox="-38.5 -520.7 542 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-70" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> p </script>  so dass <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-28"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">g</span><span class="MJXp-mrow" id="MJXp-Span-32"><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0em; margin-right: 0em;">ü</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">g</span><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0.333em; margin-right: 0.333em;">∈</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">t</span><span class="MJXp-mo" id="MJXp-Span-43" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44">p</span><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.258ex" height="2.66ex" viewBox="0 -832 7861 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-75" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-6E" x="572" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-67" x="1173" y="0"></use><g transform="translate(1653,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">ü</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-6C" x="2068" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-74" x="2366" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-69" x="2728" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-67" x="3073" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMAIN-2208" x="3832" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-70" x="4777" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-73" x="5281" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-65" x="5750" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-74" x="6217" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMAIN-28" x="6578" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-70" x="6968" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMAIN-29" x="7471" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> ungültig ∈ pset (p) </script>  einen Fehler ausgeben. </p><br><pre> <code class="cpp hljs">string_view s; <span class="hljs-comment"><span class="hljs-comment">// pset(s) = {null} { char a[100]; s = a; // pset(s) = {a} cout &lt;&lt; s[0]; // OK } // pset(s) = {invalid} cout &lt;&lt; s[0]; // ERROR: invalid ∈ pset(s)</span></span></code> </pre> <br><p>  Mithilfe von Anmerkungen können Sie konfigurieren, welche Vorgänge als Vorgänge für den Zugriff auf den Wert betrachtet werden.  Standardmäßig: <code>*</code> , <code>-&gt;</code> , <code>[]</code> , <code>begin()</code> , <code>end()</code> . </p><br><p>  Bitte beachten Sie, dass die Warnung nur zum Zeitpunkt des <em>Zugriffs</em> auf den ungültigen Index ausgegeben wird.  Wenn der Wert gelöscht wird, aber niemand jemals auf diesen Zeiger zugreift, ist alles in Ordnung. </p><br><h3 id="ukazateli-i-vladelcy">  Wegweiser und Eigentümer </h3><br><p>  Wenn Zeiger <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-46"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.259ex" height="1.817ex" viewBox="-38.5 -520.7 542 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/425873/&amp;usg=ALkJrhipWYTrBLqcwtE6HnxiPT3eSOzKDg#MJMATHI-70" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> p </script>  Gibt einen Wert an, der im Eigentümer enthalten ist <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">o</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> o </script>  dann das hier <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-50"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">t</span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">p</span><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-59"><span class="MJXp-msup" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61" style="margin-right: 0.05em;">o</span><span class="MJXp-mo MJXp-script" id="MJXp-Span-62" style="vertical-align: 0.5em;">′</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> pset (p) = {o '} </script>  . </p><br><p>  Methoden und Funktionen, die Eigentümer übernehmen, sind unterteilt in: </p><br><ul><li>  Owner Value Access-Vorgänge.  Standard: <code>*</code> , <code>-&gt;</code> , <code>[]</code> , <code>begin()</code> , <code>end()</code> </li><li>  Zugriff auf Vorgänge auf den Eigentümer selbst, <code>v.clear()</code> Zeiger wie <code>v.clear()</code> .  Standardmäßig sind dies alle anderen nicht konstanten Operationen </li><li>  Zugriff auf Vorgänge auf den Eigentümer selbst, nicht ungültig <code>v.empty()</code> Zeiger wie <code>v.empty()</code> .  Standardmäßig sind dies alles const-Operationen. </li></ul><br><p>  Alter Inhaltseigentümer angekündigt <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-63"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">g</span><span class="MJXp-mrow" id="MJXp-Span-67"><span class="MJXp-mo" id="MJXp-Span-68" style="margin-left: 0em; margin-right: 0em;">ü</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-71">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">g</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> ungültig </script>  bei Entfernung des Eigentümers oder bei Anwendung ungültiger Vorgänge. </p><br><p>  Diese Regeln reichen aus, um viele typische Fehler im C ++ - Code zu erkennen: </p><br><pre> <code class="cpp hljs">string_view s; <span class="hljs-comment"><span class="hljs-comment">// pset(s) = {null} string name = "foo"; s = name; // pset(s) = {name'} cout &lt;&lt; s[0]; // OK name = "bar"; // pset(s) = {invalid} cout &lt;&lt; s[0]; // ERROR</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v = get_ints(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p = &amp;v[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// pset(p) = {v'} v.push_back(42); // pset(p) = {invalid} cout &lt;&lt; *p; // ERROR</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view s = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>s; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; s[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// ERROR // :       std::string_view s = "foo"s // pset(s) = {"foo"s '} ; // pset(s) = {invalid}</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v = get_ints(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(); i != v.end(); ++i) { <span class="hljs-comment"><span class="hljs-comment">// pset(i) = {v'} if (*i == 2) { v.erase(i); // pset(i) = {invalid} } // pset(i) = {v', invalid} } // ERROR: ++i for (auto i = v.begin(); i != v.end(); ) { if (*i == 2) i = v.erase(i); // OK else ++i; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; get_data(); <span class="hljs-comment"><span class="hljs-comment">//   ,  get_data() != nullopt for (int value : *get_data()) // ERROR cout &lt;&lt; value; // *get_data() —     for (int value : std::vector&lt;int&gt;(*get_data())) // OK cout &lt;&lt; value;</span></span></code> </pre> <br><h3 id="otslezhivanie-vremeni-zhizni-parametrov-funkciy">  Verfolgung der Lebensdauer von Funktionsparametern </h3><br><p>  Wenn wir uns mit Funktionen in C ++ befassen, die Zeiger zurückgeben, können wir nur die Beziehung zwischen der Lebensdauer der Parameter und dem Rückgabewert erraten.  Wenn eine Funktion Zeiger desselben Typs akzeptiert und zurückgibt, wird angenommen, dass die Funktion den Rückgabewert von einem der Eingabeparameter "erhält": </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* q)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">*</span></span>; <span class="hljs-comment"><span class="hljs-comment">// pset(ret) = {p', q'} auto g(std::string&amp; s) -&gt; char*; // pset(ret) = {s'}</span></span></code> </pre> <br><p>  Verdächtige Funktionen, die das Ergebnis aus dem Nichts erhalten, sind leicht zu erkennen: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::reference_wrapper&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; get_data() { <span class="hljs-comment"><span class="hljs-comment">//    int i = 3; return {i}; // pset(ret) = {i'} } // pset(ret) = {invalid}</span></span></code> </pre> <br><p>  Da es möglich ist, einen temporären Wert an die Parameter <code>const T&amp;</code> , werden diese nicht berücksichtigt, es sei denn, das Ergebnis ist nirgendwo anders zu berücksichtigen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; y)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// pset(ret) = {x', y'} //    const T&amp;- //        auto x = 10, y = 2; auto&amp; bad = min(x, y + 1); // pset(bad) = {x, temp} // pset(bad) = {x, invalid} cout &lt;&lt; bad; // ERROR</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> K = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> V = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> V&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_or_default</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;K, V&gt;&amp; m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> K&amp; key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> V&amp; def)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// pset(ret) = {m', key', def'} std::map&lt;K, V&gt; map; K key = "foo"; const V&amp; s = find_or_default(map, key, "none"); // pset(s) = {map', key', temp} ⇒ pset(s) = {map', key', invalid} cout &lt;&lt; s; // ERROR</span></span></code> </pre> <br><p>  Es wird auch angenommen, dass eine Funktion, die einen Zeiger (anstelle einer Referenz) akzeptiert, nullptr sein kann und dieser Zeiger nicht vor dem Vergleich mit nullptr verwendet werden kann. </p><br><h3 id="zaklyuchenie-po-kontrolyu-vremeni-zhizni">  Schlussfolgerung zur Lebenszeitkontrolle </h3><br><p>  Ich wiederhole, dass Lifetime noch kein Vorschlag für den C ++ - Standard ist, sondern ein mutiger Versuch, Lebensdauerkontrollen in C ++ zu implementieren, wo es im Gegensatz zu Rust beispielsweise nie entsprechende Anmerkungen gegeben hat.  Zuerst wird es viele Fehlalarme geben, aber im Laufe der Zeit werden sich die Heuristiken verbessern. </p><br><h3 id="voprosy-iz-zala">  Fragen aus dem Publikum </h3><br><p>  <strong>Bieten lebenslange Gruppenprüfungen eine mathematisch genaue Garantie für das Fehlen baumelnder Zeiger?</strong> </p><br><p>  Theoretisch wäre es möglich (im neuen Code), eine Reihe von Anmerkungen an Klassen und Funktionen zu hängen, und im Gegenzug würde der Compiler solche Garantien geben.  Diese Überprüfungen wurden jedoch nach dem 80: 20-Prinzip entwickelt. Das heißt, Sie können die meisten Fehler mit einer kleinen Anzahl von Regeln und einem Minimum an Anmerkungen abfangen. </p><br><h2 id="metaklassy">  Metaklassen </h2><br><p>  Die Metaklasse ergänzt in gewisser Weise den Code der Klasse, auf die sie angewendet wird, und dient auch als Name für eine Gruppe von Klassen, die bestimmte Bedingungen erfüllen.  Wie unten gezeigt, macht die <code>interface</code> Metaklasse beispielsweise alle Funktionen für Sie öffentlich und rein virtuell. </p><br><p>  Letztes Jahr hat Herb Sutter sein erstes Metaklassenprojekt gemacht ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe hier</a> ).  Seitdem hat sich die derzeit vorgeschlagene Syntax geändert. </p><br><p>  Für den Anfang hat sich die Syntax für die Verwendung von Metaklassen geändert: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  interface Shape { int area() const; void scale_by(double factor); }; //  class(interface) Shape { … }</span></span></code> </pre> <br><p>  Es ist länger geworden, aber jetzt gibt es eine natürliche Syntax zum gleichzeitigen Anwenden mehrerer Metaklassen: <code>class(meta1, meta2)</code> . </p><br><h3 id="opisanie-metaklassa">  Beschreibung der Metaklasse </h3><br><p>  Bisher war eine Metaklasse ein Regelwerk zum Ändern einer Klasse.  Jetzt ist eine Metaklasse eine constexpr-Funktion, die eine alte Klasse (im Code deklariert) verwendet und eine neue erstellt. </p><br><p>  Die Funktion verwendet nämlich einen Parameter - Metainformationen über die alte Klasse (der Parametertyp hängt von der Implementierung ab), erstellt Klassenelemente (Fragmente) und fügt sie dann mit der Anweisung <code>__generate</code> dem Hauptteil der neuen Klasse <code>__generate</code> . </p><br><p>  Fragmente können mit den <code>__fragment</code> , <code>__inject</code> , <code>idexpr(…)</code> werden.  Der Redner zog es vor, sich nicht auf seinen Zweck zu konzentrieren, da sich dieser Teil noch ändern wird, bevor er dem Normungsausschuss vorgelegt wird.  Die Namen selbst werden garantiert geändert, um dies zu verdeutlichen, wurde eine doppelte Unterstreichung hinzugefügt.  Der Schwerpunkt des Berichts lag auf Beispielen, die weiter gehen. </p><br><h3 id="interface">  Schnittstelle </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T source)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// source    //     .     //  ~X,  X —   . __generate __fragment struct X { virtual ~X noexcept {} }; //    static_assert, compiler.require   //   constexpr-. //      . compiler.require(source.variables().empty(), "interfaces may not contain data members"); // member_functions(), ,  tuple&lt;…&gt;,   for... for... (auto f : source.member_functions()) { // ,   —   / compiler.require(!f.is_copy() &amp;&amp; !f.is_move(), "interfaces may not copy or move; consider a virtual clone()"); //   public   if (!f.has_default_access()) f.make_public(); // (1) // ,       protected/private compiler.require(f.is_public(), "interface functions must be public"); //     f.make_pure_virtual(); // (2) //   f     __generate f; } }</span></span></code> </pre> <br><p>  Sie könnten denken, dass wir in den Zeilen (1) und (2) die ursprüngliche Klasse ändern, aber nein.  Bitte beachten Sie, dass wir beim Kopieren die Funktionen der ursprünglichen Klasse durchlaufen, diese Funktionen ändern und sie dann in eine neue Klasse einfügen. </p><br><p>  Metaklassenanwendung: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale_by</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> factor)</span></span></span></span>; }; <span class="hljs-comment"><span class="hljs-comment">//  : class Shape { public: virtual ~Shape noexcept {} public: virtual int area() const = 0; public: virtual void scale_by(double factor) = 0; };</span></span></code> </pre> <br><h3 id="otladka-myuteksa">  Mutex-Debugging </h3><br><p>  Angenommen, wir haben nicht threadsichere Daten, die durch einen Mutex geschützt sind.  Das Debuggen kann erleichtert werden, wenn in einer Debug-Assembly bei jedem Aufruf überprüft wird, ob der aktuelle Prozess diesen Mutex gesperrt hat.  Zu diesem Zweck wurde eine einfache TestableMutex-Klasse geschrieben: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestableMutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m.lock(); id = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ id = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id{}; m.unlock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_held</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id&gt; id; };</code> </pre> <br><p>  Außerdem möchten wir in unserer MyData-Klasse jedes öffentliche Feld mögen </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v;</code> </pre> <br><p>  Durch + Getter ersetzen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; v() { assert(m_.is_held()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v_; }</code> </pre> <br><p>  Für Funktionen kann man auch ähnliche Transformationen durchführen. </p><br><p>  Solche Aufgaben werden mithilfe von Makros und Codegenerierung gelöst.  Herb Sutter erklärte Makros den Krieg: Sie sind unsicher, ignorieren Semantik, Namespaces usw.  Wie sieht die Lösung bei Metaklassen aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">guarded_with_mutex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ __generate __fragment <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> {</span></span> TestableMutex m_; <span class="hljs-comment"><span class="hljs-comment">// lock, unlock } } template &lt;typename T, typename U&gt; constexpr void guarded_member(T type, U name) { auto field = …; __generate field; auto getter = …; __generate getter; } template &lt;typename T&gt; constexpr void guarded(T source) { guarded_with_mutex(); for... (auto o : source.member_variables()) { guarded_member(o.type(), o.name()); } }</span></span></code> </pre> <br><p>  Wie man es benutzt: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">guarded</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; Widget* w; }; MyData&amp; x = findData(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); xv().clear(); <span class="hljs-comment"><span class="hljs-comment">// assertion failed: m_.is_held()</span></span></code> </pre> <br><h3 id="actor">  Schauspieler </h3><br><p>  Nun, selbst wenn wir ein Objekt mit einem Mutex geschützt haben, ist jetzt alles threadsicher, es gibt keinen Anspruch auf Richtigkeit.  Wenn jedoch häufig von vielen Threads gleichzeitig auf ein Objekt zugegriffen werden kann, wird der Mutex überlastet, und es ist ein großer Aufwand erforderlich, ihn zu übernehmen. </p><br><p>  Die grundlegende Lösung für das Problem der fehlerhaften Mutexe ist das Konzept der Akteure. Wenn ein Objekt eine Anforderungswarteschlange hat, werden alle Aufrufe des Objekts nacheinander in einem speziellen Thread in die Warteschlange gestellt und ausgeführt. </p><br><p>  Lassen Sie die Active-Klasse eine Implementierung von all dem enthalten - tatsächlich einen Thread-Pool / Executor mit einem einzelnen Thread.  Nun, Metaklassen helfen dabei, doppelten Code zu entfernen und alle Vorgänge in die Warteschlange zu stellen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">active</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageFilter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ImageFilter(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Buffer*)&gt; w) : work(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(w)) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Buffer* b)</span></span></span><span class="hljs-function"> </span></span>{ work(b); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Buffer*)&gt; work; } <span class="hljs-comment"><span class="hljs-comment">//  : class ImageFilter { public: ImageFilter(std::function&lt;void(Buffer*)&gt; w) : work(std::move(w)) {} void apply(Buffer* b) { a.send([=] { work(b); }).join(); } private: std::function&lt;void(Buffer*)&gt; work; Active a; //   ,     work }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">active</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">log</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fstream f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(…)</span></span></span><span class="hljs-function"> </span></span>{ f &lt;&lt; …; } };</code> </pre> <br><h3 id="property">  Eigentum </h3><br><p>  Es gibt Eigenschaften in fast allen modernen Programmiersprachen, und wer sie einfach nicht auf der Basis von C ++ implementiert hat: Qt, C ++ / CLI, alle möglichen hässlichen Makros.  Sie werden jedoch niemals zum C ++ - Standard hinzugefügt, da sie selbst als zu enge Funktionen angesehen werden und immer die Hoffnung bestand, dass ein Vorschlag sie als Sonderfall implementieren würde.  Nun, sie können auf Metaklassen implementiert werden! </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  class X { public: class(property&lt;int&gt;) WidthClass { } width; }; //  class X { public: class WidthClass { int value; int get() const; void set(const int&amp; v); void set(int&amp;&amp; v); public: WidthClass(); WidthClass(const int&amp; v); WidthClass&amp; operator=(const int&amp; v); operator int() const; //   move! WidthClass(int&amp;&amp; v); WidthClass&amp; operator=(int&amp;&amp; v); } width; };</span></span></code> </pre> <br><p>  Sie können Ihren eigenen Getter und Setter einstellen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class">&lt;int&gt;) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonthClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> month; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> month; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m)</span></span></span><span class="hljs-function"> </span></span>{ assert(m &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; m &lt; <span class="hljs-number"><span class="hljs-number">13</span></span>); month = m; } } month; }; Date date; date.month = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-comment"><span class="hljs-comment">// assertion failed</span></span></code> </pre> <br><p>  Idealerweise möchte ich die <code>property int month { … }</code> schreiben, aber selbst eine solche Implementierung ersetzt den Zoo von C ++ - Erweiterungen, die Eigenschaften erfinden. </p><br><h3 id="zaklyuchenie-po-metaklassam">  Metaclass Fazit </h3><br><p>  Metaklassen sind eine große Neuerung für eine bereits komplexe Sprache.  Lohnt es sich?  Hier sind einige ihrer Vorteile: </p><br><ul><li>  Lassen Sie Programmierer ihre Absichten klarer ausdrücken (ich möchte Schauspieler schreiben) </li><li>  Reduzieren Sie die Codeduplizierung und vereinfachen Sie die Entwicklung und Wartung von Code, der bestimmten Mustern folgt </li><li>  Beseitigen Sie einige Gruppen häufiger Fehler (es reicht aus, alle Feinheiten einmal zu erledigen). </li><li>  Makros entfernen lassen?  (Herb Sutter ist sehr kriegerisch) </li></ul><br><h3 id="voprosy-iz-zala-1">  Fragen aus dem Publikum </h3><br><p>  <strong>Wie kann man Metaklassen debuggen?</strong> </p><br><p>  Zumindest für Clang gibt es eine intrinsische Funktion, die, wenn sie aufgerufen wird, den tatsächlichen Inhalt der Klasse während der Kompilierung druckt, dh was nach dem Anwenden aller Metaklassen erhalten wird. </p><br><p>  <strong>Früher hieß es, Nichtmitglieder wie Swap und Hash in Metaklassen deklarieren zu können.</strong>  <strong>Wo ist sie hingegangen?</strong> </p><br><p>  Die Syntax wird weiterentwickelt. </p><br><p>  <strong>Warum brauchen wir Metaklassen, wenn bereits Konzepte zur Standardisierung übernommen wurden?</strong> </p><br><p>  Das sind verschiedene Dinge.  Metaklassen werden benötigt, um Teile einer Klasse zu definieren, und Konzepte überprüfen anhand von Klassenbeispielen, ob eine Klasse einem bestimmten Muster entspricht.  In der Tat arbeiten Metaklassen und Konzepte gut zusammen.  Beispielsweise können Sie das Konzept eines Iterators und die Metaklasse eines „typischen Iterators“ definieren, der im Übrigen einige redundante Operationen definiert. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425873/">https://habr.com/ru/post/de425873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425859/index.html">Regionale Betreiber lehnen die Aufhebung des Roamings ab</a></li>
<li><a href="../de425861/index.html">Testen Sie sich selbst: Können Sie das Unternehmen vor Cyber-Angriffen schützen?</a></li>
<li><a href="../de425867/index.html">Testen der Webdienstleistung im Rahmen der kontinuierlichen Integration. Yandex Erfahrung</a></li>
<li><a href="../de425869/index.html">iFixit: Apple hat das Blockieren von überholten MacBooks noch nicht aktiviert</a></li>
<li><a href="../de425871/index.html">Jekaterinburg, 11. Oktober - Atlassian trifft Hafenarbeiter</a></li>
<li><a href="../de425875/index.html">Notebook-Matrix-Upgrade TN-> IPS oder wie man einen fortgeschritteneren Laptop von einem Budget-Laptop bekommt</a></li>
<li><a href="../de425877/index.html">Laut Apple-CEO sind chinesische Spionagechips in Supermicro-Servern Fiktion</a></li>
<li><a href="../de425879/index.html">Was Google bei seiner Präsentation gezeigt hat</a></li>
<li><a href="../de425881/index.html">Alles, was Sie über die Ausrichtung in Flexbox wissen müssen</a></li>
<li><a href="../de425883/index.html">Vollzeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>