<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•‘ ğŸ‘¨â€ğŸ“ ğŸ‘ğŸ¾ Bagaimana saya sampai pada spesifikasi formal prosesor RISC-V di F # ğŸ™ğŸ» ğŸ“¨ ğŸ‘©ğŸ¾â€ğŸŒ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada malam musim dingin yang tenang, ketika matahari dengan malas melewati tabir hari, saya menemukan kekuatan untuk mengatasi realisasi dari mimpi ya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya sampai pada spesifikasi formal prosesor RISC-V di F #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473714/"><p>  Pada malam musim dingin yang tenang, ketika matahari dengan malas melewati tabir hari, saya menemukan kekuatan untuk mengatasi realisasi dari mimpi yang telah lama dipegang: untuk mencari tahu bagaimana prosesor diatur.  Mimpi ini membuat saya menulis spesifikasi prosesor RISC-V formal.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek Github</a> </p><br><p><img src="https://habrastorage.org/webt/03/pg/3p/03pg3piapm7id4gahgq28ramnyc.png" alt="gambar"><a name="habracut"></a></p><br><h2 id="kak-eto-bylo">  Bagaimana itu? </h2><br><p> Saya memiliki keinginan yang sangat lama, ketika 20 tahun yang lalu saya mulai terlibat dalam proyek pertama saya.  Sebagian besar, ini adalah penelitian ilmiah, pemodelan matematika dalam kerangka makalah dan artikel ilmiah.  Ini adalah zaman Pascal dan Delphi.  Namun, bahkan kemudian, Haskell dan pemrograman fungsional menarik minat saya.  Waktu berlalu, bahasa proyek dan teknologi tempat saya terlibat berubah.  Tetapi sejak itu minat dalam bahasa pemrograman fungsional telah menjadi benang merah, dan mereka telah menjadi: Haskell, Idris, Agda.  Namun, baru-baru ini, proyek saya ada di Rust.  Perendaman yang lebih dalam di Rust membuat saya mempelajari perangkat Embedded. </p><br><h3 id="ot-rust-k-embedded">  Dari Karat ke Tertanam </h3><br><p>  Kemampuan Rust sangat luas, dan komunitasnya sangat aktif sehingga pengembangan Embedded telah mulai mendukung berbagai perangkat.  Dan ini adalah langkah pertama saya ke tingkat pemahaman prosesor yang lebih rendah. </p><br><p>  Papan pertama saya adalah: <strong>STM32F407VET6</strong> .  Itu adalah perendaman dalam dunia mikrokontroler, yang saat itu saya sangat jauh, dan cukup memahami bagaimana pekerjaan itu dilakukan pada tingkat rendah. </p><br><p>  Secara bertahap, <strong>esp32</strong> , papan <strong>ATmega328</strong> (diwakili oleh papan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ukraino UNO</a> ) ditambahkan di sini.  Perendaman dalam FM32 ternyata cukup menyakitkan - informasinya berlimpah dan seringkali bukan yang saya butuhkan.  Dan ternyata mengembangkan, misalnya, di Assembler adalah tugas yang agak rutin dan tidak berterima kasih, dengan subset mereka lebih dari 1000 instruksi.  Namun, Rust mengatasi hal ini dengan riang, meskipun kadang-kadang ada kesulitan dengan integrasi untuk papan Cina tertentu. </p><br><p>  Arsitektur AVR ternyata lebih sederhana dan lebih transparan.  Buku pedoman yang melimpah memberi saya pemahaman yang cukup tentang cara bekerja dengan seperangkat instruksi yang cukup terbatas, dan bagaimanapun dapat membuat solusi yang sangat menarik.  Meskipun demikian, jalur Arduino tidak menyenangkan saya sama sekali, tetapi menulis dalam Asm / C / Rust ternyata jauh lebih menarik. </p><br><h2 id="a-gde-zhe-risc-v">  Di mana RISC-V? </h2><br><p>  Dan pada saat itu muncul pertanyaan logis - di mana <strong>CPU RISC-V</strong> ? <br>  Ini adalah sifat minimalis AVR dan dokumentasinya yang memadai yang membawa saya kembali ke mimpi saya sebelumnya untuk mencari tahu bagaimana prosesor bekerja.  Pada saat ini, saya memiliki papan FPGA dan implementasi pertama untuk itu dalam bentuk interaksi dengan perangkat VGA, output grafis, interaksi dengan periferal. </p><br><p>  Buku adalah panduan saya untuk arsitektur prosesor: </p><br><ul><li>  John L. Hennessy dan David A. Patterson - Arsitektur Komputer: Pendekatan Kuantitatif (Seri Morgan Kaufmann dalam Arsitektur dan Desain Komputer) </li><li>  John L. Hennessy dan David A. Patterson - Organisasi dan Desain Komputer.  Antarmuka Perangkat Keras / Perangkat Lunak: Edisi RISC-V </li><li>  David M. Harris dan Sarah L. Harris - Sirkuit digital dan arsitektur komputer </li><li>  Manual Set Instruksi RISC-V </li></ul><br><h3 id="zachem-eto-nuzhno">  Mengapa itu perlu? </h3><br><p>  Tampaknya - semuanya sudah ditulis dan diimplementasikan untuk waktu yang lama. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ikhtisar RISC-V Core dan SoC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Verifikasi Resmi RISC-V</a> </li></ul><br><p>  berbagai implementasi dalam HDL, dan bahasa pemrograman.  Omong-omong, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi RISC-V pada Rust</a> cukup menarik. </p><br><p>  Namun, apa yang bisa lebih menarik daripada mencari tahu sendiri dan membuatnya sendiri.  <em>Sepeda</em> Anda?  Atau berkontribusi pada <em>pembangunan sepeda</em> ?  Selain minat pribadi yang mendalam, saya punya ide - bagaimana mencoba mempopulerkan, menarik.  Dan temukan formulir Anda, pendekatan Anda.  Dan itu berarti menghadirkan dokumentasi <strong>RISC-V ISA yang</strong> agak membosankan dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi resmi</a> dalam bentuk yang berbeda.  Dan menurut saya jalan <em>formalisasi</em> dalam pengertian ini cukup menarik. </p><br><p>  Apa yang saya maksud dengan formalisasi?  Konsep yang cukup luas.  Representasi dari set data spesifik dalam bentuk formal.  Dalam hal ini, melalui deskripsi struktur dan deskripsi fungsional.  Dan dalam pengertian ini, bahasa pemrograman fungsional memiliki daya tarik tersendiri.  Juga, tugasnya adalah bahwa seseorang yang tidak terlalu tenggelam dalam pemrograman dapat membaca kode sebagai spesifikasi, jika mungkin minimal memahami secara spesifik bahasa yang dijelaskan. <br>  Pendekatan deklaratif, bisa dikatakan.  Ada pernyataan, tetapi bagaimana tepatnya itu bekerja tidak lagi penting.  Yang utama adalah keterbacaan, visibilitas, dan tentu saja kebenaran.  Korespondensi <em>pernyataan formal</em> dengan makna yang tertanam di dalamnya. <br><img src="https://habrastorage.org/webt/px/1j/ng/px1jngd3zy0gq3vtpknqxut5y1q.png" alt="gambar"><br>  Total - Saya benar-benar ingin menyampaikan minat saya kepada orang lain.  Ada ilusi tertentu bahwa bunga adalah kekuatan pendorong untuk bertindak.  Melalui mana individualitas menjadi dan memanifestasikan.  Dan ini adalah bagian dari realisasi diri, perwujudan kreativitas. <br>  Ambisius dan sedikit lirik.  Apa selanjutnya </p><br><h3 id="suschestvuyuschie-realizacii">  Implementasi yang Ada </h3><br><p>  Mereka ada dan saat ini sedang dikumpulkan oleh proyek: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Verifikasi Formal RISC-V</a> . <br>  Daftar spesifikasi formal (termasuk pekerjaan saya): <a href="">https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/references.md</a> </p><br><p>  Seperti yang Anda lihat - sebagian besar ini adalah formalisasi dalam bahasa Haskell.  Ini adalah titik awal dalam memilih bahasa fungsional yang berbeda.  Dan pilihan saya jatuh pada <strong>F #</strong> . </p><br>
<h3 id="pochemu-f">  Mengapa <code>F#</code> </h3><br><p>  Kebetulan saya sudah tahu tentang <strong>F #</strong> untuk waktu yang lama, tapi entah bagaimana dalam hiruk pikuk kehidupan sehari-hari saya tidak memiliki kesempatan untuk mengenal satu sama lain dengan lebih baik.  Faktor lain adalah platform <strong>.NET</strong> .  Mempertimbangkan bahwa saya berada di Linux, untuk waktu yang lama saya tidak senang dengan IDE, dan <code>mono</code> terlihat cukup mentah.  Dan kembali ke Windows hanya demi MS Visual Studio adalah ide yang agak meragukan. </p><br><p>  Namun, waktu tidak berhenti, dan bintang-bintang di langit tidak terburu-buru untuk berubah.  Tetapi pada saat ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jetbrains Rider telah</a> berevolusi menjadi alat yang lengkap dan nyaman, dan <code>.NET Core</code> untuk Linux tidak membawa rasa sakit sekilas melihatnya. </p><br><p>  Pertanyaannya adalah - bahasa fungsional mana yang harus dipilih.  Fakta bahwa itu seharusnya hanya bahasa fungsional - dalam bentuk yang agak menyedihkan, saya berpendapat di atas. <br>  <code>Haskell, Idris, Agda</code> ?  <code>F#</code> - Saya tidak terbiasa dengannya.  Kesempatan yang bagus untuk mempelajari warna-warna baru dunia bahasa fungsional. </p><br><p>  Ya, <code>F#</code> tidak sepenuhnya berfungsi.  Tetapi apa yang mencegah untuk mematuhi " <em>kemurnian</em> "?  Dan kemudian ternyata - bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi F #</a> cukup rinci dan lengkap.  Dapat dibaca, dan saya bahkan akan mengatakan menarik. </p><br><p>  Apa <code>F#</code> untuk saya sekarang?  Bahasa yang cukup fleksibel, dengan IDE yang sangat nyaman (Rider, Visual Studio).  Jenis yang sepenuhnya dikembangkan (walaupun tentu saja <code>Idris</code> sangat jauh).  Dan secara keseluruhan cukup <em>manis</em> dalam hal keterbacaan.  Namun, ternyata, " <em>non-kemurnian</em> " fungsionalnya - dapat membawa kode ke bentuk yang benar-benar gila, baik dari segi keterbacaan dan logika.  Analisis paket di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nuget</a> menunjukkan hal ini. </p><br><p>  Fitur lain yang menarik dan misterius bagi saya adalah penemuan bahwa tidak ada yang tertarik untuk menulis formalisasi <strong>RISC-V ISA</strong> di <strong>F #</strong> sebelumnya (secara resmi atau dalam bentuk yang dapat dicari).  Dan ini berarti saya memiliki kesempatan untuk memperkenalkan aliran baru ke komunitas, bahasa, dan â€œ <em>ekosistem</em> â€ ini. </p><br><h3 id="podvodnye-kamni-s-kotorymi-ya-stolknulsya">  Perangkap yang saya temui </h3><br><p>  Bagian yang paling sulit adalah pelaksanaan aliran Eksekusi.  Sering kali ternyata tidak sepenuhnya jelas bagaimana instruksi harus bekerja.  Sayangnya, saya tidak bisa bertanya pada kawan yang bisa menelepon pada jam 3 pagi dengan suara penuh aspirasi: "Anda tahu, instruksi <code>BLTU</code> mungkin berbeda dalam signextend ..."  Dalam hal ini, memiliki kawan-kawan yang memenuhi syarat yang akan membantu dengan kata-kata yang baik dan saran yang memenuhi syarat sangat disambut. </p><br><p>  Apa kesulitan dan jebakannya.  Saya akan mencoba tesis: </p><br><ul><li>  ELF - tugas yang aneh adalah untuk mengetahui bagaimana bekerja dengannya, membaca bagian, instruksi.  Kemungkinan besar cerita ini dalam kerangka proyek saat ini belum selesai. </li><li>  instruksi yang tidak ditandatangani secara berkala menyebabkan kesalahan yang saya deteksi selama pengujian unit </li><li>  implementasi kerja dengan memori diperlukan untuk memikirkan algoritma komposisi byte yang indah dan mudah dibaca. </li><li>  tidak ada paket yang cocok untuk bekerja dengan bit di bawah <code>int32, int64</code> .  Butuh waktu untuk menulis paket saya dan mengujinya. <br>  <em>Di sini saya ingin mencatat bahwa bekerja dengan bit dalam F # jauh lebih nyaman daripada di Haskell dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">datanya. Bit</a></em> </li><li>  dukungan yang tepat untuk bit register, dengan kemampuan untuk mendukung <code>x32</code> dan <code>x64</code> bersamaan.  Ketidakpedulian membuat saya menggunakan <code>int64</code> di beberapa tempat.  Tes unit membantu saya mengidentifikasi ini.  Tapi butuh beberapa saat. </li><li>  Saya tidak menemukan paket CLI F # sederhana, ringkas, mudah untuk saya pribadi.  Efek sampingnya adalah menulis versi minimalis dengan gaya fungsional. </li><li>  Saat ini, masih menjadi misteri bagaimana menerapkan Instruksi Sistem dengan benar: FENCE, ECALL, BREAK </li><li>  jauh dari seluruh rangkaian ekstensi (ekstensi ISA) dari daftar: <code>[A, M, C, F, D]</code> saat ini jelas.  Secara khusus, implementasi <code>[F,D]</code> tidak melalui <code>soft float</code> . </li><li>  saat ini, tidak ada pemahaman yang jelas tentang Instruksi Privileged, Mod Pengguna, bekerja dengan periferal - sayangnya.  Dan ini adalah cara penelitian, coba-coba. </li><li>  Tidak ada <em>sabuk hitam</em> untuk menulis program Assembler di <strong>bawah RISC-V.</strong>  Mungkin jauh dari sering ini akan menjadi kebutuhan, mengingat berapa banyak bahasa yang telah porting untuk ditulis di bawah RISC-V. </li><li>  faktor waktu juga signifikan - cukup kecil dalam pusaran pekerjaan dasar, kebutuhan sehari-hari dan lautan kehidupan di sekitar.  Dan ada banyak pekerjaan, dan sebagian besar tidak begitu banyak dalam " <em>pengkodean</em> " - menulis kode itu sendiri, tetapi dalam belajar, menguasai materi. </li></ul><br><h3 id="kak-eto-rabotaet-i-kakie-vozmozhnosti">  Cara kerjanya dan fitur apa </h3><br><p>  Sekarang mungkin bagian yang paling <em>teknis</em> .  Apa saja fitur saat ini: </p><br><ul><li>  set instruksi <code>rv32i</code> </li><li>  kemampuan untuk menjalankan program sebagai simulator RISC-V - eksekusi file ELF. </li><li>  command line support (CLI) - pemilihan arsitektur yang dapat dieksekusi, sekumpulan instruksi, file ELF yang dapat dieksekusi, mode logging, bantuan baris perintah. </li><li>  kemampuan untuk menampilkan log instruksi yang dapat dieksekusi, dekat dengan tampilan <code>objdump</code> ketika dibongkar. </li><li>  kemampuan untuk menjalankan tes yang mencakup seluruh rangkaian instruksi yang diterapkan. </li></ul><br><p>  Program ini dibagi menjadi beberapa tahapan dan siklus: </p><br><ul><li>  baca baris perintah </li><li>  membaca instruksi dari file ELF </li><li>  membaca instruksi spesifik sesuai dengan penghitung PC (Program Counter) saat ini </li><li>  instruksi decoding </li><li>  eksekusi instruksi </li><li>  jika terjadi situasi yang tidak terduga, jebakan diatur, memungkinkan Anda untuk menyelesaikan proses eksekusi, menandakan masalah, dan memberikan data yang diperlukan </li><li>  jika program tidak dalam loop yang tak terbatas - tampilkan status register dan akhiri program simulasi </li></ul><br><p>  Apa yang termasuk dalam rencana: </p><br><ul><li>  Basis standar 64i (hampir selesai) </li><li>  Ekstensi standar M (bilangan integer / bagi) </li><li>  Ekstensi standar A (operasi memori atom) </li><li>  Ekstensi standar C (Instruksi 16-bit terkompresi) </li><li>  Ekstensi standar F (Titik apung presisi tunggal) </li><li>  Ekstensi standar D (Titik mengambang presisi ganda * Privilege Level M (Mesin) </li><li>  Privilege Level U (Pengguna) </li><li>  Privilege Level S (Supervisor) </li><li>  Skema Memori Virtual SV32, SV39 dan SV48 </li><li>  program tuan rumah </li><li>  GPIO - bekerja dengan periferal </li></ul><br><h3 id="kak-zapustit">  Bagaimana cara menjalankannya </h3><br><p>  Untuk menjalankan program, Anda harus memiliki <code>.NET Core</code> .  Jika Anda tidak menginstalnya, maka, misalnya, di bawah <code>Ubuntu 16.04</code> Anda perlu menjalankan serangkaian perintah berikut: </p><br><pre> <code class="plaintext hljs">$ wget -q https://packages.microsoft.com/config/ubuntu/16.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb $ sudo dpkg -i packages-microsoft-prod.deb $ sudo apt-get update $ sudo apt-get install apt-transport-https $ sudo apt-get update $ sudo apt-get install dotnet-sdk-3.0</code> </pre> <br><p>  Untuk memverifikasi bahwa sesuatu dalam hidup telah berubah, jalankan: </p><br><pre> <code class="plaintext hljs">$ dotnet --version</code> </pre> <br><p>  Dan hidup harus bersinar dengan warna-warna baru! </p><br><p>  Sekarang coba lari.  Untuk melakukan ini, persediaan teh atau kopi favorit Anda, cokelat dengan roti, nyalakan musik favorit Anda dan ikuti serangkaian perintah ini: </p><br><pre> <code class="plaintext hljs">$ cd some/my/dev/dir $ git clone https://github.com/mrLSD/riscv-fs $ cd riscv-fs $ dotnet build $ dotnet run -- --help</code> </pre> <br><p>  dan konsol Anda akan mengedipkan mata pada Anda dengan pesan bantuan. <br>  Peluncurannya adalah: </p><br><pre> <code class="plaintext hljs">$ dotnet run</code> </pre> <br><p>  Dengan nada tegas dia akan mengatakan bahwa parameter diperlukan.  Karena itu, jalankan: </p><br><pre> <code class="plaintext hljs">$ dotnet run -- -A rv32i -v myapp.elf</code> </pre> <br><p>  Ini adalah momen canggung yang sama ketika ternyata kita masih membutuhkan program siap <em>pakai untuk eksekusi</em> untuk RISC-V.  Dan ada sesuatu untuk saya bantu.  Namun, Anda membutuhkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GNU toolchain untuk RISC-V</a> .  Biarkan diinstal pekerjaan rumah - deskripsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> menjelaskan secara cukup rinci bagaimana melakukan ini. </p><br><p>  Selanjutnya, untuk mendapatkan file ELF tes yang didambakan, kami melakukan tindakan berikut: </p><br><pre> <code class="plaintext hljs">$ cd Tests/asm/ $ make build32</code> </pre> <br><p>  jika Anda memiliki <em>toolchain RISC-V</em> maka semuanya akan berjalan lancar.  Dan file-file tersebut harus dipamerkan di direktori: </p><br><pre> <code class="plaintext hljs">$ ls Tests/asm/build/ add32 alu32 alui32 br32 j32 mem32 sys32 ui32</code> </pre> <br><p>  dan sekarang dengan berani, tanpa melihat ke belakang, kami mencoba perintah: </p><br><pre> <code class="plaintext hljs">$ dotnet run -- -A rv32i -v Tests/asm/build/ui32</code> </pre> <br><p>  <strong>Penting untuk dicatat</strong> bahwa <code>Tests/asm</code> bukan program uji, tetapi tujuan utama mereka adalah instruksi tes dan kode mereka untuk tes menulis.  Oleh karena itu, jika Anda menyukai sesuatu yang lebih besar dan lebih heroik, maka mengubah dunia dalam keinginan Anda adalah menemukan file ELF 32-bit yang dapat dieksekusi secara independen yang hanya mendukung instruksi <code>rv32i</code> . </p><br><p>  Namun, set instruksi dan ekstensi akan diisi ulang, menambah momentum dan menambah berat badan. </p><br><h2 id="rezyume-i-ssylki">  Ringkasan dan tautan </h2><br><p>  Ternyata itu adalah narasi menyedihkan yang dibumbui oleh sejarah pribadi.  Terkadang teknis, kadang subjektif.  Namun antusias dan dengan sentuhan antusiasme. </p><br><p>  Bagi saya, saya tertarik untuk mendengar dari Anda: ulasan, kesan, kata perpisahan yang baik.  Dan untuk yang paling berani - bantuan dalam mendukung proyek ini. </p><br><p>  Apakah Anda tertarik dengan format naratif seperti itu dan apakah Anda ingin melanjutkan? </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek itu sendiri</a> </li><li>  <a href="">Daftar spesifikasi formal RISC-V (termasuk proyek saya)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi RISC-V</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RISC-V toolchain</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keren F # (proyek saya juga termasuk)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ariane - CPU RISC-V 6-tahap berdasarkan Verilog</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473714/">https://habr.com/ru/post/id473714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473702/index.html">Apa yang sharding di blockchain terahash</a></li>
<li><a href="../id473704/index.html">Kawan vs. bukan bro</a></li>
<li><a href="../id473706/index.html">Zoia: CMS reaktif ringan untuk pengembangan situs web yang cepat</a></li>
<li><a href="../id473708/index.html">Mobil listrik buatan rumah - semuanya tidak seperti yang Anda pikirkan</a></li>
<li><a href="../id473710/index.html">Prinsip-prinsip dokumentasi dan lokalisasi, atau cara mendapatkan lokalisasi yang baik dengan biaya minimal</a></li>
<li><a href="../id473716/index.html">Widget yang digerakkan mouse. Seret dan letakkan di dalam jendela</a></li>
<li><a href="../id473718/index.html">Cara menambahkan cek ke NoVerify tanpa menulis satu baris kode Go</a></li>
<li><a href="../id473720/index.html">Dua cara untuk membuat unit test yang andal</a></li>
<li><a href="../id473722/index.html">Isolasi jarak jauh, kecemasan dan depresi</a></li>
<li><a href="../id473726/index.html">Tidak cukup hanya tahu apa itu Mutex, Semaphore, dan async / tunggu. Anda perlu tahu segalanya dari kuanta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>