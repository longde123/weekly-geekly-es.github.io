<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ò „Ä∞Ô∏è üë®üèæ‚Äçüîß Grundlegendes zu C #: Zuweisen von Speicher f√ºr einen Referenztyp auf dem Stapel üëºüèæ üë®üèæ‚Äçüç≥ üßëüèø‚Äçü§ù‚Äçüßëüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden die Grundlagen des internen Ger√§tetyps sowie ein Beispiel gegeben, in dem der Speicher f√ºr den Referenztyp vollst√§ndig auf de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlegendes zu C #: Zuweisen von Speicher f√ºr einen Referenztyp auf dem Stapel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428676/">  In diesem Artikel werden die Grundlagen des internen Ger√§tetyps sowie ein Beispiel gegeben, in dem der Speicher f√ºr den Referenztyp vollst√§ndig auf dem Stapel zugewiesen wird (dies liegt daran, dass ich ein Full-Stack-Programmierer bin). <br><br><img src="https://habrastorage.org/webt/xn/xh/rl/xnxhrlrmdifxe8o2pwopy-y-xhw.jpeg"><br><br><h3>  Haftungsausschluss </h3><br>  Dieser Artikel enth√§lt kein Material, das in realen Projekten verwendet werden sollte.  Es ist einfach eine Erweiterung der Grenzen, in denen eine Programmiersprache wahrgenommen wird. <br><br>  Bevor Sie mit der Geschichte beginnen, empfehle ich dringend, dass Sie den ersten Beitrag √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StructLayout lesen</a> , weil  Dort wird ein Beispiel analysiert, das in diesem Artikel verwendet wird (jedoch wie immer). <br><a name="habracut"></a><br><h3>  Hintergrund </h3><br>  Als ich anfing, den Code f√ºr diesen Artikel zu schreiben, wollte ich mit der Assemblersprache etwas Interessantes machen.  Ich wollte irgendwie das Standard-Ausf√ºhrungsmodell brechen und ein wirklich ungew√∂hnliches Ergebnis erzielen.  Und als ich mich daran erinnerte, wie oft Leute sagen, dass sich der Referenztyp von dem signifikanten darin unterscheidet, dass sich der erste auf dem Heap und der zweite auf dem Stapel befindet, entschied ich mich, Assembler zu verwenden, um zu zeigen, dass der Referenztyp auf dem Stapel leben kann.  Es traten jedoch alle m√∂glichen Probleme auf, z. B. die R√ºckgabe der gew√ºnschten Adresse und die Darstellung als verwalteter Link (ich arbeite noch daran).  Also fing ich an zu tricksen und zu tun, was in Assembler in C # nicht funktioniert.  Und am Ende blieb der Assembler √ºberhaupt nicht. <br>  Auch eine Empfehlung zum Lesen - wenn Sie mit dem Ger√§t der Referenztypen vertraut sind, empfehle ich, dass Sie die Theorie √ºber sie √ºberspringen (nur die Grundlagen werden gegeben, nichts Interessantes). <br><br><h3>  Ein bisschen √ºber die interne Struktur von Typen </h3><br>  Ich m√∂chte Sie daran erinnern, dass die Trennung von Speicher auf dem Stapel und dem Heap auf .NET-Ebene erfolgt und diese Aufteilung rein logisch ist. Physikalisch gibt es keinen Unterschied zwischen den Speicherbereichen unter dem Heap und unter dem Stapel.  Der Produktivit√§tsunterschied wird bereits durch die Arbeit mit diesen Bereichen deutlich. <br><br>  Wie ordne ich dann Speicher auf dem Stapel zu?  Lassen Sie uns zun√§chst sehen, wie dieser mysteri√∂se Referenztyp strukturiert ist und was darin enthalten ist, was nicht signifikant ist. <br><br>  Betrachten Sie also das einfachste Beispiel mit der Employee-Klasse. <br><br><div class="spoiler">  <b class="spoiler_title">Mitarbeitercode</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Employee</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Work</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(‚ÄúZzzz...‚Äù); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TakeVacation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> days</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(‚ÄúZzzz...‚Äù); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCompanyPolicy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CompanyPolicy policy</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Zzzz..."</span></span>); } }</code> </pre> <br></div></div><br>  Und schauen Sie sich an, wie es im Ged√§chtnis dargestellt wird. <br>  UPD: Diese Klasse wird am Beispiel eines 32-Bit-Systems betrachtet. <br><br><img src="https://habrastorage.org/webt/xy/b-/dv/xyb-dvprkg9b1dmdqgjlabkss7c.jpeg"><br><br>  Somit haben wir zus√§tzlich zum Speicher f√ºr die Felder zwei weitere versteckte Felder - den Index des Synchronisationsblocks (das Titelwort des Objekts im Bild) und die Adresse der Methodentabelle. <br><br>  Das erste Feld, es ist der Index des Synchronisationsblocks, interessiert uns nicht besonders.  Beim Platzieren des Typs habe ich beschlossen, ihn wegzulassen.  Ich habe das aus zwei Gr√ºnden getan: <br><br><ol><li>  Ich bin sehr faul (ich habe nicht gesagt, dass die Gr√ºnde vern√ºnftig sein werden) </li><li>  Dieses Feld ist f√ºr die Grundfunktion des Objekts optional. </li></ol><br>  Aber da wir bereits gesprochen haben, halte ich es f√ºr richtig, ein paar Worte zu diesem Bereich zu sagen.  Es wird f√ºr verschiedene Zwecke verwendet (Hash-Code, Synchronisation).  Das Feld selbst ist vielmehr einfach der Index eines der diesem Objekt zugeordneten Synchronisationsbl√∂cke.  Die Bl√∂cke selbst befinden sich in der Tabelle der Synchronisationsbl√∂cke (a la global array).  Das Erstellen eines solchen Blocks ist eine ziemlich gro√üe Operation, daher wird er nicht erstellt, wenn er nicht ben√∂tigt wird.  Wenn Sie d√ºnne Sperren verwenden, wird dort au√üerdem die Kennung des Threads geschrieben, der die Sperre erhalten hat (anstelle des Index). <br><br>  Das zweite Feld ist f√ºr uns viel wichtiger.  Dank der Tabelle der Typmethoden ist ein so m√§chtiges Werkzeug wie Polymorphismus m√∂glich (das √ºbrigens nicht von der Struktur, den K√∂nigen des Stapels, besessen wird).  Angenommen, die Employee-Klasse implementiert zus√§tzlich drei Schnittstellen: IComparable, IDisposable und ICloneable. <br><br>  Dann sieht die Methodentabelle ungef√§hr so ‚Äã‚Äãaus <br><br><img src="https://habrastorage.org/webt/ed/wn/bd/edwnbdjat20da-ij868sfkgwapg.jpeg"><br><br>  Das Bild ist sehr cool, da im Prinzip alles gemalt und verst√§ndlich ist.  Wenn es an den Fingern kurz ist, wird die virtuelle Methode nicht direkt an der Adresse aufgerufen, sondern durch den Versatz in der Methodentabelle.  In der Hierarchie befinden sich dieselben virtuellen Methoden am selben Versatz in der Methodentabelle.  Das hei√üt, in der Basisklasse rufen wir die Methode gem√§√ü dem Offset auf, ohne zu wissen, welche Typentabelle von Methoden verwendet wird, aber zu wissen, dass dieser Offset die relevanteste Methode f√ºr den Laufzeittyp ist. <br><br>  Es ist auch zu beachten, dass der Verweis auf das Objekt auf die Methodentabelle verweist. <br><br><h3>  Das lang erwartete Beispiel </h3><br>  Beginnen wir mit Kursen, die uns bei unserem Ziel helfen.  Mit StructLayout (ich habe es wirklich ohne versucht, aber es hat nicht geklappt) habe ich die einfachsten Zeiger-Mapper f√ºr verwaltete Typen geschrieben und umgekehrt.  Es ist ziemlich einfach, einen Zeiger von einem verwalteten Link zu erhalten, aber die inverse Transformation hat mir Schwierigkeiten bereitet, und ohne nachzudenken, habe ich mein Lieblingsattribut angewendet.  Um den Code in einem Schl√ºssel zu halten, habe ich ihn auf eine Weise in zwei Richtungen ausgef√ºhrt. <br><br><div class="spoiler">  <b class="spoiler_title">Code hier</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">//     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PointerCasterFacade { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual unsafe T GetManagedReferenceByPointer&lt;T&gt;(<span class="hljs-type"><span class="hljs-type">int</span></span>* pointer) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual unsafe <span class="hljs-type"><span class="hljs-type">int</span></span>* GetPointerByManagedReference&lt;T&gt;(T managedReference) =&gt; (<span class="hljs-type"><span class="hljs-type">int</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span>; } //     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PointerCasterUnderground { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual T GetManagedReferenceByPointer&lt;T&gt;(T reference) =&gt; reference; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual unsafe <span class="hljs-type"><span class="hljs-type">int</span></span>* GetPointerByManagedReference&lt;T&gt;(<span class="hljs-type"><span class="hljs-type">int</span></span>* pointer) =&gt; pointer; } [StructLayout(LayoutKind.Explicit)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PointerCaster { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PointerCaster() { pointerCaster= <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PointerCasterUnderground(); } [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] private PointerCasterUnderground pointerCaster; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PointerCasterFacade Caster; }</code> </pre><br></div></div><br>  Schreiben Sie zun√§chst eine Methode, die einen Zeiger auf einen Speicher (√ºbrigens nicht unbedingt auf dem Stapel) verwendet und den Typ konfiguriert. <br><br>  Um das Auffinden der Adresse der Methodentabelle zu erleichtern, erstelle ich einen Typ auf dem Heap.  Ich bin sicher, dass die Methodentabelle auf andere Weise gefunden werden kann, aber ich habe mir nicht das Ziel gesetzt, diesen Code zu optimieren. Es war f√ºr mich interessanter, ihn verst√§ndlich zu machen.  Als n√§chstes erhalten wir unter Verwendung der zuvor beschriebenen Konverter einen Zeiger auf den erstellten Typ. <br><br>  Dieser Zeiger zeigt genau auf die Methodentabelle.  Daher reicht es aus, den Inhalt einfach aus dem Speicher abzurufen, auf den er verweist.  Dies ist die Adresse der Methodentabelle. <br>  Und da der an uns √ºbergebene Zeiger eine Art Verweis auf das Objekt ist, m√ºssen wir die Adresse der Methodentabelle genau dort notieren, wo sie zeigt. <br><br>  Das ist eigentlich alles.  Unerwartet, richtig?  Jetzt ist unser Typ fertig.  Pinocchio, der uns den Speicher zugewiesen hat, k√ºmmert sich um die Initialisierung der Felder. <br><br>  Es bleibt nur die Verwendung des Grandcasters, um den Zeiger in einen verwalteten Link umzuwandeln. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StackInitializer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> T InitializeOnStack&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* pointer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>() { T r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> caster = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PointerCaster().Caster; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = caster.GetPointerByManagedReference(r); pointer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = ptr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; T reference = caster.GetManagedReferenceByPointer&lt;T&gt;(pointer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference; } }</code> </pre><br>  Jetzt haben wir einen Link auf dem Stapel, der auf denselben Stapel verweist, in dem nach allen Gesetzen der Referenztypen (na ja, fast) ein Objekt aus schwarzem Boden und St√∂cken liegt.  Polymorphismus ist verf√ºgbar. <br><br>  Es versteht sich, dass wir, wenn Sie diesen Link au√üerhalb der Methode √ºbergeben, nach der R√ºckkehr etwas Unklares erhalten.  Es kann nicht von Aufrufen virtueller Methoden gesprochen werden. Lassen Sie uns ausnahmsweise fliegen.  Regul√§re Methoden werden direkt aufgerufen, im Code gibt es einfach Adressen f√ºr echte Methoden, damit sie funktionieren.  Und an der Stelle der Felder wird ... aber niemand wei√ü, was da sein wird. <br><br>  Da es unm√∂glich ist, eine separate Methode f√ºr die Initialisierung auf dem Stapel zu verwenden (da der Stapelrahmen nach der R√ºckkehr von der Methode gel√∂scht wird), sollte der Speicher von der Methode zugewiesen werden, die den Typ auf dem Stapel verwenden m√∂chte.  Genau genommen gibt es keinen Weg, dies zu tun.  Am besten f√ºr uns geeignet ist jedoch stackalloc.  Genau das richtige Keyword f√ºr unsere Zwecke.  Leider war es das, was Unkontrollierbarkeit in den Code einf√ºhrte.  Zuvor gab es die Idee, Span f√ºr diese Zwecke zu verwenden und auf unsicheren Code zu verzichten.  An unsicherem Code ist nichts auszusetzen, aber wie √ºberall ist er kein Wundermittel und hat seine eigenen Anwendungsbereiche. <br><br>  Nachdem wir einen Zeiger auf den Speicher des aktuellen Stapels erhalten haben, √ºbergeben wir diesen Zeiger an eine Methode, aus der der Typ in Teilen besteht.  Das ist alles, was zugeh√∂rt hat - gut gemacht. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* pointer = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = StackInitializer.InitializeOnStack&lt;StackReferenceType&gt;(pointer); a.StubMethod(); Console.WriteLine(a.Field); Console.WriteLine(a); Console.Read(); } }</code> </pre><br>  Sie sollten dies nicht in realen Projekten verwenden. Die Methode, die Speicher auf dem Stapel zuweist, verwendet neues T (), das wiederum Reflektion verwendet, um den Typ auf dem Heap zu erstellen!  Diese Methode ist also langsamer als die √ºbliche Erstellung des Typs einmal, also 40-50. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier sehen</a> Sie das gesamte Projekt. <br><br>  Quelle: In einem theoretischen Exkurs wurden Beispiele aus dem Buch Sasha Goldstein - Pro .NET Performace verwendet </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428676/">https://habr.com/ru/post/de428676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428664/index.html">Linux-Kernel-Boot. Teil 1</a></li>
<li><a href="../de428666/index.html">Wie ich mit CSS-Masken stimmungsver√§ndernde Animationen erstellt habe</a></li>
<li><a href="../de428668/index.html">Blizzard k√ºndigte die Ver√∂ffentlichung der Neuver√∂ffentlichung von WarCraft III im Jahr 2019 an. Vorbestellung √∂ffnen</a></li>
<li><a href="../de428672/index.html">QuietOn Active Squelch √úbersicht</a></li>
<li><a href="../de428674/index.html">Erstellen von Client-Routing / semantischer Suche bei Profi.ru.</a></li>
<li><a href="../de428680/index.html">Erstellen und Integrieren eines VK-Bots in eine Gruppe √ºber VkBotLongPoll [Python]</a></li>
<li><a href="../de428682/index.html">Selbstzerst√∂render Beta-Fallout 76</a></li>
<li><a href="../de428688/index.html">Einrichten der Arbeitsumgebung in Docker f√ºr die yii-Framework-Anwendung</a></li>
<li><a href="../de428690/index.html">Wie Sie Ihrer Freundin das Programmieren beibringen, wenn Sie kein Lehrer sind, aber sie an Sie glaubt</a></li>
<li><a href="../de428694/index.html">Die Geschichte eines einzelnen Spiels oder einer 4x-Strategie, die vor 20 Jahren begann und noch lebt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>