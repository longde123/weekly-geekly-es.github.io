<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘 〰️ 👨🏾‍🔧 Grundlegendes zu C #: Zuweisen von Speicher für einen Referenztyp auf dem Stapel 👼🏾 👨🏾‍🍳 🧑🏿‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden die Grundlagen des internen Gerätetyps sowie ein Beispiel gegeben, in dem der Speicher für den Referenztyp vollständig auf de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlegendes zu C #: Zuweisen von Speicher für einen Referenztyp auf dem Stapel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428676/">  In diesem Artikel werden die Grundlagen des internen Gerätetyps sowie ein Beispiel gegeben, in dem der Speicher für den Referenztyp vollständig auf dem Stapel zugewiesen wird (dies liegt daran, dass ich ein Full-Stack-Programmierer bin). <br><br><img src="https://habrastorage.org/webt/xn/xh/rl/xnxhrlrmdifxe8o2pwopy-y-xhw.jpeg"><br><br><h3>  Haftungsausschluss </h3><br>  Dieser Artikel enthält kein Material, das in realen Projekten verwendet werden sollte.  Es ist einfach eine Erweiterung der Grenzen, in denen eine Programmiersprache wahrgenommen wird. <br><br>  Bevor Sie mit der Geschichte beginnen, empfehle ich dringend, dass Sie den ersten Beitrag über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StructLayout lesen</a> , weil  Dort wird ein Beispiel analysiert, das in diesem Artikel verwendet wird (jedoch wie immer). <br><a name="habracut"></a><br><h3>  Hintergrund </h3><br>  Als ich anfing, den Code für diesen Artikel zu schreiben, wollte ich mit der Assemblersprache etwas Interessantes machen.  Ich wollte irgendwie das Standard-Ausführungsmodell brechen und ein wirklich ungewöhnliches Ergebnis erzielen.  Und als ich mich daran erinnerte, wie oft Leute sagen, dass sich der Referenztyp von dem signifikanten darin unterscheidet, dass sich der erste auf dem Heap und der zweite auf dem Stapel befindet, entschied ich mich, Assembler zu verwenden, um zu zeigen, dass der Referenztyp auf dem Stapel leben kann.  Es traten jedoch alle möglichen Probleme auf, z. B. die Rückgabe der gewünschten Adresse und die Darstellung als verwalteter Link (ich arbeite noch daran).  Also fing ich an zu tricksen und zu tun, was in Assembler in C # nicht funktioniert.  Und am Ende blieb der Assembler überhaupt nicht. <br>  Auch eine Empfehlung zum Lesen - wenn Sie mit dem Gerät der Referenztypen vertraut sind, empfehle ich, dass Sie die Theorie über sie überspringen (nur die Grundlagen werden gegeben, nichts Interessantes). <br><br><h3>  Ein bisschen über die interne Struktur von Typen </h3><br>  Ich möchte Sie daran erinnern, dass die Trennung von Speicher auf dem Stapel und dem Heap auf .NET-Ebene erfolgt und diese Aufteilung rein logisch ist. Physikalisch gibt es keinen Unterschied zwischen den Speicherbereichen unter dem Heap und unter dem Stapel.  Der Produktivitätsunterschied wird bereits durch die Arbeit mit diesen Bereichen deutlich. <br><br>  Wie ordne ich dann Speicher auf dem Stapel zu?  Lassen Sie uns zunächst sehen, wie dieser mysteriöse Referenztyp strukturiert ist und was darin enthalten ist, was nicht signifikant ist. <br><br>  Betrachten Sie also das einfachste Beispiel mit der Employee-Klasse. <br><br><div class="spoiler">  <b class="spoiler_title">Mitarbeitercode</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Employee</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Work</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(“Zzzz...”); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TakeVacation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> days</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(“Zzzz...”); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCompanyPolicy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CompanyPolicy policy</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Zzzz..."</span></span>); } }</code> </pre> <br></div></div><br>  Und schauen Sie sich an, wie es im Gedächtnis dargestellt wird. <br>  UPD: Diese Klasse wird am Beispiel eines 32-Bit-Systems betrachtet. <br><br><img src="https://habrastorage.org/webt/xy/b-/dv/xyb-dvprkg9b1dmdqgjlabkss7c.jpeg"><br><br>  Somit haben wir zusätzlich zum Speicher für die Felder zwei weitere versteckte Felder - den Index des Synchronisationsblocks (das Titelwort des Objekts im Bild) und die Adresse der Methodentabelle. <br><br>  Das erste Feld, es ist der Index des Synchronisationsblocks, interessiert uns nicht besonders.  Beim Platzieren des Typs habe ich beschlossen, ihn wegzulassen.  Ich habe das aus zwei Gründen getan: <br><br><ol><li>  Ich bin sehr faul (ich habe nicht gesagt, dass die Gründe vernünftig sein werden) </li><li>  Dieses Feld ist für die Grundfunktion des Objekts optional. </li></ol><br>  Aber da wir bereits gesprochen haben, halte ich es für richtig, ein paar Worte zu diesem Bereich zu sagen.  Es wird für verschiedene Zwecke verwendet (Hash-Code, Synchronisation).  Das Feld selbst ist vielmehr einfach der Index eines der diesem Objekt zugeordneten Synchronisationsblöcke.  Die Blöcke selbst befinden sich in der Tabelle der Synchronisationsblöcke (a la global array).  Das Erstellen eines solchen Blocks ist eine ziemlich große Operation, daher wird er nicht erstellt, wenn er nicht benötigt wird.  Wenn Sie dünne Sperren verwenden, wird dort außerdem die Kennung des Threads geschrieben, der die Sperre erhalten hat (anstelle des Index). <br><br>  Das zweite Feld ist für uns viel wichtiger.  Dank der Tabelle der Typmethoden ist ein so mächtiges Werkzeug wie Polymorphismus möglich (das übrigens nicht von der Struktur, den Königen des Stapels, besessen wird).  Angenommen, die Employee-Klasse implementiert zusätzlich drei Schnittstellen: IComparable, IDisposable und ICloneable. <br><br>  Dann sieht die Methodentabelle ungefähr so ​​aus <br><br><img src="https://habrastorage.org/webt/ed/wn/bd/edwnbdjat20da-ij868sfkgwapg.jpeg"><br><br>  Das Bild ist sehr cool, da im Prinzip alles gemalt und verständlich ist.  Wenn es an den Fingern kurz ist, wird die virtuelle Methode nicht direkt an der Adresse aufgerufen, sondern durch den Versatz in der Methodentabelle.  In der Hierarchie befinden sich dieselben virtuellen Methoden am selben Versatz in der Methodentabelle.  Das heißt, in der Basisklasse rufen wir die Methode gemäß dem Offset auf, ohne zu wissen, welche Typentabelle von Methoden verwendet wird, aber zu wissen, dass dieser Offset die relevanteste Methode für den Laufzeittyp ist. <br><br>  Es ist auch zu beachten, dass der Verweis auf das Objekt auf die Methodentabelle verweist. <br><br><h3>  Das lang erwartete Beispiel </h3><br>  Beginnen wir mit Kursen, die uns bei unserem Ziel helfen.  Mit StructLayout (ich habe es wirklich ohne versucht, aber es hat nicht geklappt) habe ich die einfachsten Zeiger-Mapper für verwaltete Typen geschrieben und umgekehrt.  Es ist ziemlich einfach, einen Zeiger von einem verwalteten Link zu erhalten, aber die inverse Transformation hat mir Schwierigkeiten bereitet, und ohne nachzudenken, habe ich mein Lieblingsattribut angewendet.  Um den Code in einem Schlüssel zu halten, habe ich ihn auf eine Weise in zwei Richtungen ausgeführt. <br><br><div class="spoiler">  <b class="spoiler_title">Code hier</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">//     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PointerCasterFacade { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual unsafe T GetManagedReferenceByPointer&lt;T&gt;(<span class="hljs-type"><span class="hljs-type">int</span></span>* pointer) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual unsafe <span class="hljs-type"><span class="hljs-type">int</span></span>* GetPointerByManagedReference&lt;T&gt;(T managedReference) =&gt; (<span class="hljs-type"><span class="hljs-type">int</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span>; } //     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PointerCasterUnderground { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual T GetManagedReferenceByPointer&lt;T&gt;(T reference) =&gt; reference; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual unsafe <span class="hljs-type"><span class="hljs-type">int</span></span>* GetPointerByManagedReference&lt;T&gt;(<span class="hljs-type"><span class="hljs-type">int</span></span>* pointer) =&gt; pointer; } [StructLayout(LayoutKind.Explicit)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PointerCaster { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PointerCaster() { pointerCaster= <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PointerCasterUnderground(); } [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] private PointerCasterUnderground pointerCaster; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PointerCasterFacade Caster; }</code> </pre><br></div></div><br>  Schreiben Sie zunächst eine Methode, die einen Zeiger auf einen Speicher (übrigens nicht unbedingt auf dem Stapel) verwendet und den Typ konfiguriert. <br><br>  Um das Auffinden der Adresse der Methodentabelle zu erleichtern, erstelle ich einen Typ auf dem Heap.  Ich bin sicher, dass die Methodentabelle auf andere Weise gefunden werden kann, aber ich habe mir nicht das Ziel gesetzt, diesen Code zu optimieren. Es war für mich interessanter, ihn verständlich zu machen.  Als nächstes erhalten wir unter Verwendung der zuvor beschriebenen Konverter einen Zeiger auf den erstellten Typ. <br><br>  Dieser Zeiger zeigt genau auf die Methodentabelle.  Daher reicht es aus, den Inhalt einfach aus dem Speicher abzurufen, auf den er verweist.  Dies ist die Adresse der Methodentabelle. <br>  Und da der an uns übergebene Zeiger eine Art Verweis auf das Objekt ist, müssen wir die Adresse der Methodentabelle genau dort notieren, wo sie zeigt. <br><br>  Das ist eigentlich alles.  Unerwartet, richtig?  Jetzt ist unser Typ fertig.  Pinocchio, der uns den Speicher zugewiesen hat, kümmert sich um die Initialisierung der Felder. <br><br>  Es bleibt nur die Verwendung des Grandcasters, um den Zeiger in einen verwalteten Link umzuwandeln. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StackInitializer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> T InitializeOnStack&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* pointer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>() { T r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> caster = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PointerCaster().Caster; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = caster.GetPointerByManagedReference(r); pointer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = ptr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; T reference = caster.GetManagedReferenceByPointer&lt;T&gt;(pointer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference; } }</code> </pre><br>  Jetzt haben wir einen Link auf dem Stapel, der auf denselben Stapel verweist, in dem nach allen Gesetzen der Referenztypen (na ja, fast) ein Objekt aus schwarzem Boden und Stöcken liegt.  Polymorphismus ist verfügbar. <br><br>  Es versteht sich, dass wir, wenn Sie diesen Link außerhalb der Methode übergeben, nach der Rückkehr etwas Unklares erhalten.  Es kann nicht von Aufrufen virtueller Methoden gesprochen werden. Lassen Sie uns ausnahmsweise fliegen.  Reguläre Methoden werden direkt aufgerufen, im Code gibt es einfach Adressen für echte Methoden, damit sie funktionieren.  Und an der Stelle der Felder wird ... aber niemand weiß, was da sein wird. <br><br>  Da es unmöglich ist, eine separate Methode für die Initialisierung auf dem Stapel zu verwenden (da der Stapelrahmen nach der Rückkehr von der Methode gelöscht wird), sollte der Speicher von der Methode zugewiesen werden, die den Typ auf dem Stapel verwenden möchte.  Genau genommen gibt es keinen Weg, dies zu tun.  Am besten für uns geeignet ist jedoch stackalloc.  Genau das richtige Keyword für unsere Zwecke.  Leider war es das, was Unkontrollierbarkeit in den Code einführte.  Zuvor gab es die Idee, Span für diese Zwecke zu verwenden und auf unsicheren Code zu verzichten.  An unsicherem Code ist nichts auszusetzen, aber wie überall ist er kein Wundermittel und hat seine eigenen Anwendungsbereiche. <br><br>  Nachdem wir einen Zeiger auf den Speicher des aktuellen Stapels erhalten haben, übergeben wir diesen Zeiger an eine Methode, aus der der Typ in Teilen besteht.  Das ist alles, was zugehört hat - gut gemacht. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* pointer = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = StackInitializer.InitializeOnStack&lt;StackReferenceType&gt;(pointer); a.StubMethod(); Console.WriteLine(a.Field); Console.WriteLine(a); Console.Read(); } }</code> </pre><br>  Sie sollten dies nicht in realen Projekten verwenden. Die Methode, die Speicher auf dem Stapel zuweist, verwendet neues T (), das wiederum Reflektion verwendet, um den Typ auf dem Heap zu erstellen!  Diese Methode ist also langsamer als die übliche Erstellung des Typs einmal, also 40-50. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier sehen</a> Sie das gesamte Projekt. <br><br>  Quelle: In einem theoretischen Exkurs wurden Beispiele aus dem Buch Sasha Goldstein - Pro .NET Performace verwendet </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428676/">https://habr.com/ru/post/de428676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428664/index.html">Linux-Kernel-Boot. Teil 1</a></li>
<li><a href="../de428666/index.html">Wie ich mit CSS-Masken stimmungsverändernde Animationen erstellt habe</a></li>
<li><a href="../de428668/index.html">Blizzard kündigte die Veröffentlichung der Neuveröffentlichung von WarCraft III im Jahr 2019 an. Vorbestellung öffnen</a></li>
<li><a href="../de428672/index.html">QuietOn Active Squelch Übersicht</a></li>
<li><a href="../de428674/index.html">Erstellen von Client-Routing / semantischer Suche bei Profi.ru.</a></li>
<li><a href="../de428680/index.html">Erstellen und Integrieren eines VK-Bots in eine Gruppe über VkBotLongPoll [Python]</a></li>
<li><a href="../de428682/index.html">Selbstzerstörender Beta-Fallout 76</a></li>
<li><a href="../de428688/index.html">Einrichten der Arbeitsumgebung in Docker für die yii-Framework-Anwendung</a></li>
<li><a href="../de428690/index.html">Wie Sie Ihrer Freundin das Programmieren beibringen, wenn Sie kein Lehrer sind, aber sie an Sie glaubt</a></li>
<li><a href="../de428694/index.html">Die Geschichte eines einzelnen Spiels oder einer 4x-Strategie, die vor 20 Jahren begann und noch lebt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>