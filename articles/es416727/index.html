<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèùÔ∏è üññüèø üë®üèΩ‚Äçüç≥ Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 2: "Control de ataques de hackers", parte 3 üë®üèø‚Äçüåæ üçè üëÇüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnolog√≠a de Massachusetts. Conferencia Curso # 6.858. "Seguridad de los sistemas inform√°ticos". Nikolai Zeldovich, James Mickens. A√±o 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 2: "Control de ataques de hackers", parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416727/"><h3>  Instituto de Tecnolog√≠a de Massachusetts.  Conferencia Curso # 6.858.  "Seguridad de los sistemas inform√°ticos".  Nikolai Zeldovich, James Mickens.  A√±o 2014 </h3><br>  Computer Systems Security es un curso sobre el desarrollo e implementaci√≥n de sistemas inform√°ticos seguros.  Las conferencias cubren modelos de amenazas, ataques que comprometen la seguridad y t√©cnicas de seguridad basadas en trabajos cient√≠ficos recientes.  Los temas incluyen seguridad del sistema operativo (SO), caracter√≠sticas, gesti√≥n del flujo de informaci√≥n, seguridad del idioma, protocolos de red, seguridad de hardware y seguridad de aplicaciones web. <br><br>  Lecci√≥n 1: "Introducci√≥n: modelos de amenaza" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lecci√≥n 2: "Control de ataques de hackers" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  ¬øMe puede decir cu√°l es la falta de un enfoque de seguridad que utiliza una <b>p√°gina de guardia</b> ? <br><br>  <b>Audiencia: ¬°</b> lleva m√°s tiempo! <br><br>  <b>Profesor:</b> exactamente!  Entonces, imagine que este mont√≥n es muy, muy peque√±o, pero seleccion√© una p√°gina completa para asegurarme de que esta peque√±a cosa no fuera atacada por un puntero.  Este es un proceso espacialmente intensivo, y las personas en realidad no implementan algo como esto en un entorno de trabajo.  Esto puede ser √∫til para probar "errores", pero nunca lo har√≠a para un programa real.  Creo que ahora entiendes lo que es un depurador de memoria de <b>cerca el√©ctrica</b> . <br><br>  <b>Audiencia:</b> ¬øPor qu√© la <b>p√°gina de protecci√≥n</b> debe ser tan grande? <br><br>  <b>Profesor: La</b> raz√≥n es que generalmente dependen del hardware, como la protecci√≥n a nivel de p√°gina, para determinar los tama√±os de p√°gina.  Para la mayor√≠a de las computadoras, se asignan 2 p√°ginas de 4 KB de tama√±o para cada b√∫fer asignado, totalizando 8 KB.  Como el mont√≥n consiste en objetos, se asigna una p√°gina separada para cada funci√≥n <b>malloc</b> .  En algunos modos, este depurador no devuelve el espacio reservado al programa, por lo que la <b>cerca el√©ctrica es</b> muy voraz en t√©rminos de memoria y no debe compilarse con c√≥digo de trabajo. <br><br><img src="https://habrastorage.org/webt/cm/l6/oh/cml6ohlrz3im72yoa5u_6n9pomg.jpeg"><br><br>  Otro enfoque de seguridad que vale la pena observar se llama <b>Fat Pointers</b> , o "indicadores gruesos".  En este caso, el t√©rmino "grueso" significa que se adjunta una gran cantidad de datos al puntero.  En este caso, la idea es que queremos cambiar la representaci√≥n misma del puntero para incluir informaci√≥n sobre los l√≠mites en su composici√≥n. <br><br>  Un puntero normal de 32 bits consta de 32 bits, y las direcciones se encuentran dentro de √©l.  Si consideramos el "puntero grueso", entonces consta de 3 partes.  La primera parte es una base de 4 bytes, a la que tambi√©n se adjunta un final de 4 bytes.  En la primera parte, el objeto comienza, en la segunda termina, y en la tercera, tambi√©n de 4 bytes, <b>se</b> encierra la direcci√≥n <b>cur</b> .  Y dentro de estos l√≠mites comunes hay un puntero. <br><br><img src="https://habrastorage.org/webt/jd/2o/83/jd2o83flkobiu3caqetom5wpwj8.jpeg"><br><br>  Por lo tanto, cuando el compilador genera un c√≥digo de acceso para este "puntero grueso", actualiza el contenido de la √∫ltima parte de la <b>direcci√≥n cur</b> y simult√°neamente verifica el contenido de las dos primeras partes para asegurarse de que no pas√≥ nada malo con el puntero durante el proceso de actualizaci√≥n. <br><br>  Imagine que tengo este c√≥digo: <b>int * ptr = malloc (8)</b> , este es un puntero para el que se asignan 8 bytes.  A continuaci√≥n, tengo un <b>ciclo while</b> que est√° a punto de asignar alg√∫n valor al puntero y luego sigue el incremento del puntero <b>ptr ++</b> .  Cada vez que este c√≥digo se ejecuta en la direcci√≥n actual del puntero de <b>direcci√≥n cur</b> , verifica si el puntero se encuentra dentro de los l√≠mites especificados en la primera y segunda parte. <br><br>  Este es el caso en el nuevo c√≥digo que genera el compilador.  Un grupo en l√≠nea a menudo plantea la pregunta de qu√© es el "c√≥digo de herramienta".  Este es el c√≥digo que genera el compilador.  Usted, como programador, solo ve lo que se muestra a la derecha: estas 4 l√≠neas.  Pero antes de esta operaci√≥n, el compilador inserta un c√≥digo C nuevo en la <b>direcci√≥n cur</b> , asigna un valor al puntero y comprueba los l√≠mites cada vez. <br><br><img src="https://habrastorage.org/webt/w7/am/vx/w7amvxvkol7dhdi3qdrpkupsgga.jpeg"><br><br>  Y si, al usar el nuevo c√≥digo, el valor va m√°s all√° de los l√≠mites, la funci√≥n se interrumpe.  Esto se llama el "c√≥digo de herramienta".  Esto significa que toma el c√≥digo fuente usando un programa C, luego agrega el nuevo c√≥digo fuente C y luego compila el nuevo programa.  Entonces, la idea b√°sica detr√°s de <b>Fat Pointers</b> es bastante simple. <br><br>  Hay algunas desventajas en este enfoque.  El mayor inconveniente es el gran tama√±o del puntero.  Y esto significa que no puede simplemente tomar el "puntero grueso" y pasarlo sin cambios, fuera de la biblioteca de shell.  Debido a que puede haber una expectativa de que el puntero tiene un tama√±o est√°ndar, y el programa le proporcionar√° este tama√±o, que "no encajar√°", por lo que todo explotar√°.  Tambi√©n hay problemas si desea incluir punteros de este tipo en una <b>estructura</b> o algo similar, ya que pueden cambiar el tama√±o de la <b>estructura</b> . <br><br>  Por lo tanto, una cosa muy popular en el c√≥digo C es tomar algo del tama√±o de una <b>estructura</b> y luego hacer algo basado en este tama√±o: reservar espacio en disco para estructuras de este tama√±o, y as√≠ sucesivamente. <br><br>  Y una cosa m√°s delicada es que estos punteros, por regla general, no pueden actualizarse de manera at√≥mica.  Para arquitecturas de 32 bits, es t√≠pico escribir una variable de 32 bits que sea at√≥mica.  Pero los "punteros gruesos" contienen 3 tama√±os <b>enteros</b> , por lo que si tiene un c√≥digo que espera que el puntero tenga un valor at√≥mico, podr√≠a tener problemas.  Porque para hacer algunas de estas verificaciones, debe mirar la direcci√≥n actual y luego ver los tama√±os, y luego puede que tenga que aumentarlos, y as√≠ sucesivamente.  Por lo tanto, esto puede causar errores muy sutiles si usa c√≥digo que intenta establecer paralelos entre punteros regulares y gruesos.  Por lo tanto, puede usar <b>punteros de grasa</b> en algunos casos, como las <b>cercas Electroc</b> , pero los efectos secundarios de su uso son tan significativos que en la pr√°ctica normal estos enfoques no se usan. <br><br>  Y ahora hablaremos sobre la verificaci√≥n de l√≠mites en relaci√≥n con la estructura de los datos en la sombra.  La idea principal de la estructura es que sepa qu√© tan grande es cada objeto que va a colocar, es decir, sabe el tama√±o que necesita reservar para este objeto.  Entonces, por ejemplo, si tiene un puntero al que llama con la funci√≥n <b>malloc</b> , debe especificar el tama√±o del objeto: <b>char xp = malloc (tama√±o)</b> . <br><br><img src="https://habrastorage.org/webt/40/5x/vq/405xvqrcdftphffsqkxgqxprhfo.jpeg"><br><br>  Si tiene algo as√≠ como una variable est√°tica como esta <b>char p [256]</b> , el compilador puede determinar autom√°ticamente cu√°les deber√≠an ser los l√≠mites para su ubicaci√≥n. <br><br>  Por lo tanto, para cada uno de estos punteros, debe insertar de alguna manera dos operaciones.  Esto es principalmente aritm√©tico, como <b>q = p + 7</b> , o algo similar.  Esta inserci√≥n se realiza desreferenciando un enlace de tipo <b>deref * q = 'q'</b> .  Quiz√°s se pregunte por qu√© no puede confiar en el enlace al pegar.  ¬øPor qu√© necesitamos hacer estas operaciones aritm√©ticas?  El hecho es que cuando usa C y c ++, tiene un puntero que apunta a una pasada al extremo v√°lido del objeto a la derecha, despu√©s de lo cual lo usa como una condici√≥n de detenci√≥n.  Entonces, vas al objeto y tan pronto como alcanzas este puntero final, realmente detienes el ciclo o anulas la operaci√≥n. <br><br>  Entonces, si ignoramos la aritm√©tica, siempre causamos un error grave, en el que el puntero va m√°s all√° de los l√≠mites, lo que en realidad puede interrumpir el trabajo de muchas aplicaciones.  Entonces, no podemos simplemente insertar el enlace, porque ¬øc√≥mo sabes que esto sucede fuera de los l√≠mites establecidos?  La aritm√©tica nos permite decir si es as√≠ o no, y aqu√≠ todo ser√° legal y correcto.  Debido a que esta combinaci√≥n con aritm√©tica le permite rastrear d√≥nde se encuentra el puntero en relaci√≥n con su l√≠nea base original. <br><br>  Entonces, la siguiente pregunta es: ¬øc√≥mo implementamos realmente la validaci√≥n de fronteras?  Porque necesitamos de alguna manera hacer coincidir la direcci√≥n espec√≠fica del puntero con alg√∫n tipo de informaci√≥n de l√≠mite para ese puntero.  Y, por lo tanto, muchas de sus decisiones anteriores usan cosas como, por ejemplo, una tabla hash o un √°rbol, lo que le permite realizar la b√∫squeda correcta.  Entonces, dada la direcci√≥n del puntero, busco en esta estructura de datos y descubro qu√© l√≠mites tiene.  Dados estos l√≠mites, decido si puedo dejar que la acci√≥n suceda o no.  El problema es que esta es una b√∫squeda lenta, porque estas estructuras de datos se ramifican, y al examinar un √°rbol, debe examinar un mont√≥n de tales ramas hasta encontrar el valor correcto.  E incluso si se trata de una tabla hash, debe seguir las cadenas de c√≥digo, etc.  Por lo tanto, necesitamos definir una estructura de datos muy efectiva que rastree sus l√≠mites, una que haga que esta verificaci√≥n sea muy simple y clara.  As√≠ que vamos a hacerlo ahora mismo. <br><br>  Pero antes de hacer eso, perm√≠teme contarte brevemente c√≥mo funciona el enfoque de <b>asignaci√≥n de memoria de amigos</b> .  Porque esta es una de las cosas que a menudo se pregunta. <br>  <b>La asignaci√≥n de memoria de amigos</b> divide la memoria en particiones que son m√∫ltiplos de potencia de 2, e intenta asignar solicitudes de memoria en ellas.  Veamos como funciona.  Al principio, la <b>asignaci√≥n de amigos</b> trata la memoria no asignada como un gran bloque: este es el rect√°ngulo superior de 128 bits.  Luego, cuando solicita un bloque m√°s peque√±o para la asignaci√≥n din√°mica, intenta dividir este espacio de direcciones en partes en incrementos de 2 hasta que encuentre un bloque suficiente para sus necesidades. <br><br>  Supongamos que llega una solicitud del tipo <b>a = malloc (28)</b> , es decir, una solicitud para asignar 28 bytes.  Tenemos un bloque de 128 bytes que es demasiado derrochador para asignarlo a esta solicitud.  Por lo tanto, nuestro bloque se divide en dos bloques de 64 bytes: de 0 a 64 bytes y de 64 a 128 bytes.  Y este tama√±o tambi√©n es grande para nuestra solicitud, por lo que <b>amigo</b> nuevamente divide un bloque de 64 bytes en 2 partes y recibe 2 bloques de 32 bytes. <br><br><img src="https://habrastorage.org/webt/uj/mt/er/ujmter8tqrakf5gu4pel0v8eawc.jpeg"><br><br>  Menos es imposible, porque 28 bytes no caben, y 32 es el tama√±o m√≠nimo m√°s adecuado.  Entonces, este bloque de 32 bytes se asignar√° a nuestra direcci√≥n a.  Supongamos que tenemos otra consulta para <b>b = malloc (50)</b> .  <b>Buddy</b> verifica los bloques seleccionados, y dado que 50 es mayor que la mitad de 64, pero menor que 64, coloca el valor b en el bloque de la derecha. <br><br>  Finalmente, tenemos otra solicitud de 20 bytes: <b>c = malloc (20)</b> , este valor se coloca en el bloque del medio. <br><br><img src="https://habrastorage.org/webt/mu/zh/cm/muzhcmr1dbp7u7fhz6myj4d1iom.jpeg"><br><br>  <b>Buddy</b> tiene una propiedad interesante: cuando liberas memoria en un bloque y al lado hay un bloque del mismo tama√±o, despu√©s de liberar ambos bloques, <b>buddy</b> combina dos bloques vecinos vac√≠os en uno. <br><br><img src="https://habrastorage.org/webt/72/0z/9t/720z9tqbxfmo-umch8rnd9uffry.jpeg"><br><br>  Por ejemplo, cuando damos el comando <b>free ¬©</b> , <b>liberaremos el</b> bloque <b>del</b> medio, pero la uni√≥n no suceder√°, por lo que el bloque al lado seguir√° ocupado.  Pero despu√©s de liberar el primer bloque usando el comando <b>free (a)</b> , ambos bloques se fusionar√°n en uno.  Luego, si liberamos el valor de b, los bloques vecinos se combinan nuevamente y obtenemos un bloque completo de 128 bytes de tama√±o, como era al principio.  La ventaja de este enfoque es que puede encontrar f√°cilmente d√≥nde est√° su amigo mediante la simple aritm√©tica y determinar los l√≠mites de la memoria.  As√≠ es como funciona la asignaci√≥n de memoria con el enfoque de <b>asignaci√≥n de memoria de Buddy</b> . <br><br>  Todas mis conferencias a menudo se hacen la pregunta, ¬øno es un enfoque tan derrochador?  Imagine que al principio ten√≠a una solicitud de 65 bytes, tendr√≠a que asignarle el bloque completo de 128 bytes.  S√≠, esto es un desperdicio, de hecho, no tiene memoria din√°mica y ya no puede asignar recursos en el mismo bloque.  Pero, de nuevo, esto es un compromiso, porque es muy f√°cil hacer un c√°lculo, c√≥mo hacer una fusi√≥n y cosas por el estilo.  Entonces, si desea una asignaci√≥n de memoria m√°s precisa, debe utilizar un enfoque diferente. <br><br>  Entonces, ¬øqu√© hace el sistema <b>Buggy Bounce Checking (BBC)</b> ? <br><br><img src="https://habrastorage.org/webt/bw/ps/a9/bwpsa9a28xloyxprpcco0vw79ca.jpeg"><br><br>  Ella realiza varios trucos, uno de los cuales es la separaci√≥n del bloque de memoria en 2 partes, uno de los cuales contiene un objeto, y el segundo es una adici√≥n a √©l.  Por lo tanto, tenemos 2 tipos de l√≠mites: los l√≠mites del objeto y los l√≠mites de la distribuci√≥n de la memoria.  La ventaja es que no es necesario almacenar la direcci√≥n base, y es posible una b√∫squeda r√°pida usando una tabla de l√≠neas. <br><br>  Todos nuestros tama√±os de distribuci√≥n son 2 a la potencia de <b>n</b> , donde <b>n</b> es un n√∫mero entero.  Este principio <b>2n</b> se llama <b>poder de dos</b> .  Por lo tanto, no necesitamos muchos bits para imaginar cu√°n grande es un tama√±o de distribuci√≥n particular.  Por ejemplo, si el tama√±o del cl√∫ster es 16, solo necesita seleccionar 4 bits: este es el concepto de un logaritmo, es decir, 4 es un exponente de <b>n</b> , en el que necesita elevar el n√∫mero 2 para obtener 16. <br><br>  Este es un enfoque bastante econ√≥mico para la asignaci√≥n de memoria, porque se usa el n√∫mero m√≠nimo de bytes, pero debe ser un m√∫ltiplo de 2, es decir, puede tener 16 o 32, pero no 33 bytes.  Adem√°s, la <b>comprobaci√≥n de rebote de Buggy le</b> permite almacenar informaci√≥n sobre valores l√≠mite en una matriz lineal (1 byte por registro) y le permite asignar memoria en 1 ranura con un tama√±o de 16 bytes.  asignar memoria con granularidad de ranura.  ¬øQu√© significa esto? <br><br><img src="https://habrastorage.org/webt/3w/26/nm/3w26nmli9ja80jxthanvcktdhqq.jpeg"><br><br>  Si tenemos una ranura de 16 bytes donde vamos a poner el valor <b>p = malloc (16)</b> , entonces el valor en la tabla se ver√° como <b>table [p / slot.size] = 4</b> . <br><br><img src="https://habrastorage.org/webt/al/x7/vj/alx7vjrhny1zzkkjusqvt3iuv3c.jpeg"><br><br>  Supongamos que ahora necesitamos colocar un valor de 32 bytes en tama√±o <b>p = malloc (32)</b> .  Necesitamos actualizar la tabla de bordes para que coincida con el nuevo tama√±o.  Y esto se hace dos veces: primero como <b>tabla [p / slot.size] = 5</b> , y luego como <b>tabla [(p / slot.size) + 1] = 5</b> - la primera vez para la primera ranura, que se asigna para esta memoria, y la segunda veces - para la segunda ranura.  As√≠ asignamos 32 bytes de memoria.  As√≠ es como se ve el registro de distribuci√≥n de tama√±os.  Por lo tanto, para dos ranuras de asignaci√≥n de memoria, la tabla de l√≠mites se actualiza dos veces.  ¬øEso est√° claro?  Este ejemplo est√° destinado a personas que dudan si los registros y las tablas tienen un significado o no.  Porque las tablas se multiplican cada vez que ocurre la asignaci√≥n de memoria. <br><br>  Veamos qu√© pasa con la tabla de borde.  Supongamos que tenemos un c√≥digo C que se ve as√≠: <b>p '= p + i</b> , es decir, el puntero <b>p' se</b> obtiene de <b>p</b> agregando alguna variable <b>i</b> .  Entonces, ¬øc√≥mo obtenemos el tama√±o de memoria asignado para <b>p</b> ?  Para hacer esto, mira la tabla usando las siguientes condiciones l√≥gicas: <br><br>  <b>size = 1 &lt;&lt; table [p &gt;&gt; log of slot_size]</b> <br><br><img src="https://habrastorage.org/webt/bo/pw/nv/bopwnvj0ek93xhrzu4vqwhcqcf8.jpeg"><br><br>  A la derecha tenemos el tama√±o de los datos asignados para <b>p</b> , que deber√≠a ser 1. Luego lo mueve hacia la izquierda y mira la tabla, toma este tama√±o de puntero, luego se mueve hacia la derecha, donde se encuentra el registro de la tabla de tama√±o de ranura.  Si la aritm√©tica funciona, entonces vinculamos correctamente el puntero a la tabla de borde.  Es decir, el tama√±o del puntero debe ser mayor que 1, pero menor que el tama√±o de la ranura.  A la izquierda tenemos el valor, y a la derecha, el tama√±o de la ranura y el valor del puntero se encuentra entre ellos. <br><br>  Supongamos que el tama√±o del puntero es de 32 bytes, luego en la tabla, dentro de los corchetes, tendremos el n√∫mero 5. <br><br>  Supongamos que queremos encontrar la palabra clave base de este puntero: <b>base = p &amp; n (tama√±o - 1)</b> .  Lo que vamos a hacer nos da una cierta masa, y esta masa nos permitir√° restaurar la <b>base</b> ubicada aqu√≠.  Imagine que nuestro tama√±o es 16, en binario es 16 = ... 0010000.  La elipsis significa que todav√≠a hay muchos ceros, pero estamos interesados ‚Äã‚Äãen esta unidad y los ceros detr√°s de ella.  Si consideramos (16-1), entonces se ve as√≠: (16-1) = ... 0001111.  En c√≥digo binario, el inverso de esto se ver√° as√≠: ~ (16-1) ... 1110000. <br><br><img src="https://habrastorage.org/webt/8q/yj/xz/8qyjxz4dqge5f0oygbg1bhszkks.jpeg"><br><br><img src="https://habrastorage.org/webt/ue/2h/hb/ue2hhb2uzpelqgvzpmzi75c6-mo.jpeg"><br><br>  Por lo tanto, esto nos permite borrar b√°sicamente el bit, que se representar√° esencialmente desde el puntero actual y nos dar√° su <b>base</b> .  Gracias a esto, ser√° muy simple para nosotros verificar si este puntero est√° dentro de los l√≠mites.  Entonces podemos simplemente verificar que <b>(p ')&gt; = base</b> y si el valor ( <b>p'</b> - base) es m√°s peque√±o que el tama√±o seleccionado. <br><br><img src="https://habrastorage.org/webt/x6/w8/il/x6w8ilmsiya6i3irbyat6nd51cy.jpeg"><br><br>  Es bastante sencillo averiguar si el puntero est√° dentro de los l√≠mites de la memoria.  No voy a entrar en detalles; basta con decir que toda la aritm√©tica binaria se resuelve de la misma manera.  Dichos trucos le permiten evitar c√°lculos m√°s complejos. <br><br>  Hay una quinta propiedad m√°s de la <b>comprobaci√≥n de rebote</b> de <b>Buggy</b> : utiliza un sistema de memoria virtual para evitar ir m√°s all√° de los l√≠mites establecidos para el puntero.  La idea principal es que si tenemos dicha aritm√©tica para el puntero con el que determinamos la salida, entonces podemos establecer un bit de alto orden para el puntero. <br><br><img src="https://habrastorage.org/webt/ns/56/tz/ns56tz8drovqvtuwnrsc6qanksc.jpeg"><br><br>  Al hacerlo, garantizamos que desreferenciar el puntero no causar√° problemas de hardware.  Establecer el <b>bit de alto orden</b> por s√≠ solo no causa problemas; la desreferenciaci√≥n del puntero puede causar un problema. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  La versi√≥n completa del curso est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Gracias por quedarte con nosotros.  ¬øTe gustan nuestros art√≠culos?  ¬øQuieres ver m√°s materiales interesantes?  <b>Ap√≥yenos</b> haciendo un pedido o recomend√°ndolo a sus amigos, un <b>descuento del 30% para los usuarios de Habr en un an√°logo √∫nico de servidores de nivel de entrada que inventamos para usted:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">toda la verdad sobre VPS (KVM) E5-2650 v4 (6 n√∫cleos) 10GB DDR4 240GB SSD 1Gbps de $ 20 o c√≥mo dividir el servidor?</a>  (las opciones est√°n disponibles con RAID1 y RAID10, hasta 24 n√∫cleos y hasta 40GB DDR4). <br><br>  <b>Dell R730xd 2 veces m√°s barato?</b>  ¬°Solo tenemos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV desde $ 249</a> en los Pa√≠ses Bajos y los Estados Unidos!</b>  Lea sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo construir un edificio de infraestructura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase utilizando servidores Dell R730xd E5-2650 v4 que cuestan 9,000 euros por un centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416727/">https://habr.com/ru/post/es416727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416713/index.html">Informe del Club de Roma 2018, Cap√≠tulo 3.14: "Ni un solo PIB ..."</a></li>
<li><a href="../es416719/index.html">Extensi√≥n PHP y Kotlin Native. Segunda parte, consciente</a></li>
<li><a href="../es416721/index.html">Casa de bricolaje: casas de mu√±ecas para adultos</a></li>
<li><a href="../es416723/index.html">Accesibilidad API: interfaces de lenguaje natural</a></li>
<li><a href="../es416725/index.html">Kotlin DSL: teor√≠a y pr√°ctica</a></li>
<li><a href="../es416729/index.html">El programa PYCON RUSSIA est√° listo: 25 informes y 3 talleres de oradores de Google, Red Hat, Yelp, Yandex</a></li>
<li><a href="../es416731/index.html">Frost on glass: c√≥mo hacer pl√°stico de vidrio resistente</a></li>
<li><a href="../es416737/index.html">A * Algoritmo de b√∫squeda de ruta en un juego Voxel 3d Unity</a></li>
<li><a href="../es416739/index.html">Nuevo ASUS en Computex 2018</a></li>
<li><a href="../es416741/index.html">Los atacantes usaron certificados D-Link robados en su software de robo de contrase√±as</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>