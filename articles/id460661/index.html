<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😢 🐬 🛄 Semua yang perlu Anda ketahui tentang Node.js 🧒🏼 ⚗️ 🐑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya sajikan kepada Anda terjemahan artikel "Semua yang perlu Anda ketahui tentang Node.js" oleh Jorge Ramón. 





 Saat ini, platform No...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Semua yang perlu Anda ketahui tentang Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460661/"><p>  Halo, Habr!  Saya sajikan kepada Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Semua yang perlu Anda ketahui tentang Node.js"</a> oleh Jorge Ramón. </p><br><p><img src="https://habrastorage.org/webt/ua/qz/gr/uaqzgrarpig3cxhjdiuiutbxbms.jpeg"></p><br><p>  Saat ini, platform Node.js adalah salah satu platform paling populer untuk membangun REST API yang efisien dan skalabel.  Ini juga cocok untuk membangun aplikasi mobile hybrid, program desktop, dan bahkan untuk IoT. </p><br><p>  Saya telah bekerja dengan platform Node.js selama lebih dari 6 tahun dan saya benar-benar menyukainya.  Posting ini terutama mencoba untuk menjadi panduan tentang bagaimana sebenarnya Node.js bekerja. </p><a name="habracut"></a><br><p>  Ayo mulai !! </p><br><p>  <strong>Apa yang akan dibahas:</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dunia sebelum Node.js</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah C10K</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Node.js dan loop acara</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah tugas intensif CPU</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja dan arus mereka</a> </li></ul><br><a name="p1"></a><br><h3 id="mir-do-nodejs">  Dunia sebelum Node.js </h3><br><p>  <strong>Server multithreaded</strong> </p><br><p>  Aplikasi web yang ditulis mengikuti arsitektur klien / server berfungsi sebagai berikut - klien meminta sumber daya yang diperlukan dari server dan server mengirimkan sumber daya sebagai tanggapan.  Dalam skema ini, server merespons permintaan dan memutuskan koneksi. </p><br><p>  Model ini efektif karena setiap permintaan ke server menghabiskan sumber daya (memori, waktu prosesor, dll.).  Untuk memproses setiap permintaan berikutnya dari klien, server harus menyelesaikan pemrosesan permintaan sebelumnya. </p><br><p>  Apakah ini berarti bahwa server hanya dapat memproses satu permintaan pada satu waktu?  Tidak juga!  Ketika server menerima permintaan baru, itu membuat <strong>utas</strong> terpisah untuk memprosesnya. </p><br><p>  <em>Alurnya</em> , dengan kata sederhana, adalah waktu dan sumber daya yang dialokasikan CPU untuk mengeksekusi blok kecil instruksi.  Dengan demikian, server dapat memproses beberapa permintaan sekaligus, tetapi hanya satu per utas.  Model seperti ini juga disebut model <strong>utas per permintaan</strong> . </p><br><p><img src="https://habrastorage.org/webt/mm/ns/gn/mmnsgnzvz7aptv62xrbo6zxju-w.jpeg"></p><br><p>  Untuk memproses permintaan N, server membutuhkan N utas.  Jika server menerima permintaan N + 1, maka server harus menunggu hingga salah satu utas tersedia. </p><br><p>  Pada gambar di atas, server dapat memproses hingga 4 permintaan (utas) sekaligus dan ketika menerima 3 permintaan berikutnya, permintaan ini harus menunggu hingga 4 utas ini tersedia. </p><br><p>  Salah satu cara untuk menghilangkan pembatasan adalah menambahkan lebih banyak sumber daya (memori, inti prosesor, dll.) Ke server, tetapi ini bukan solusi terbaik .... </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/qz/zl/ybqzzljzkgej-kirqwza-43amcw.gif"></div><br><p>  Dan, tentu saja, jangan lupakan keterbatasan teknologi. </p><br><p>  <strong>Memblokir input / output</strong> </p><br><p>  Terbatasnya jumlah utas di server bukan satu-satunya masalah.  Mungkin Anda bertanya-tanya mengapa satu utas tidak dapat memproses beberapa permintaan sekaligus?  semua karena <strong>memblokir operasi I / O.</strong> </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/ao/02/eiao02s-dtpki8au6sybf8-dmbu.gif"></div><br><p>  Misalkan Anda sedang mengembangkan toko online dan Anda memerlukan halaman di mana pengguna dapat melihat daftar semua produk. </p><br><p>  Pengguna mengetuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://yourstore.com/products</a> dan server membuat file HTML dengan semua produk dari database sebagai tanggapan.  Sama sekali tidak rumit, bukan? </p><br><p>  Tapi apa yang terjadi di balik layar? </p><br><ul><li> Ketika seorang pengguna mengetuk <code>/products</code> metode atau fungsi tertentu harus dijalankan untuk memproses permintaan.  Sepotong kecil kode (milik Anda atau kerangka kerja Anda) mem-parsing URL permintaan dan mencari metode atau fungsi yang sesuai.  <strong>Streaming sedang berjalan</strong> . <img width="20" src="https://habrastorage.org/webt/o1/sw/x5/o1swx5v-gnn2ptqjjzonhq3oew0.png"></li><li>  Sekarang metode atau fungsi yang diinginkan dijalankan, seperti pada paragraf pertama, <strong>utas berfungsi.</strong> <img width="20" src="https://habrastorage.org/webt/o1/sw/x5/o1swx5v-gnn2ptqjjzonhq3oew0.png"></li><li>  Karena Anda adalah pengembang yang baik, Anda menyimpan semua log sistem ke file, dan tentu saja, untuk memastikan bahwa router melakukan metode / fungsi yang diinginkan - Anda juga mencatat baris "Metode X mengeksekusi !!". Tetapi semua ini memblokir operasi input / output <strong>stream sedang menunggu</strong> . <img width="20" src="https://habrastorage.org/webt/bq/lm/cq/bqlmcq7ntk4kpr2gncodmxpqqee.png"></li><li>  Semua log disimpan dan garis fungsi berikut dijalankan.  <strong>Utas berfungsi lagi</strong> . <img width="20" src="https://habrastorage.org/webt/o1/sw/x5/o1swx5v-gnn2ptqjjzonhq3oew0.png"></li><li>  Saatnya mengakses database dan mendapatkan semua produk - kueri sederhana seperti <code>SELECT * FROM products</code> melakukan tugasnya, tapi coba tebak?  Ya, ini adalah operasi I / O pemblokiran.  <strong>Arus sedang menunggu</strong> . <img width="20" src="https://habrastorage.org/webt/bq/lm/cq/bqlmcq7ntk4kpr2gncodmxpqqee.png"></li><li>  Anda telah menerima larik atau daftar semua produk, tetapi pastikan Anda telah menjaminkan semua ini.  <strong>Arus sedang menunggu</strong> . <img width="20" src="https://habrastorage.org/webt/bq/lm/cq/bqlmcq7ntk4kpr2gncodmxpqqee.png"></li><li>  Sekarang Anda memiliki semua produk dan inilah saatnya untuk merender template untuk halaman selanjutnya, tetapi sebelum itu Anda harus membacanya.  <strong>Arus sedang menunggu</strong> . <img width="20" src="https://habrastorage.org/webt/bq/lm/cq/bqlmcq7ntk4kpr2gncodmxpqqee.png"></li><li>  Mesin rendering melakukan tugasnya dan mengirimkan respons ke klien.  <strong>Utas berfungsi lagi</strong> . <img width="20" src="https://habrastorage.org/webt/o1/sw/x5/o1swx5v-gnn2ptqjjzonhq3oew0.png"></li><li>  Alurnya gratis, seperti burung di langit. <img width="20" src="https://habrastorage.org/webt/wr/vg/0_/wrvg0_hul5qltn9qpyg9fv6beua.png"></li></ul><br><p>  Seberapa lambat operasi I / O?  Yah itu tergantung spesifik.  Mari kita lihat tabelnya: </p><br><div class="scrollable-table"><table><tbody><tr><th>  <b>Operasi</b> </th><th>  <b>Siklus CPU</b> </th></tr><tr><td>  Register CPU </td><td>  3 ukuran </td></tr><tr><td>  L1 cache </td><td>  8 langkah </td></tr><tr><td>  L2 cache </td><td>  12 langkah </td></tr><tr><td>  RAM </td><td>  150 langkah </td></tr><tr><td>  Disk </td><td>  30.000.000 tindakan </td></tr><tr><td>  Jaringan </td><td>  250.000.000 tindakan </td></tr></tbody></table></div><br><p>  Operasi membaca jaringan dan disk terlalu lambat.  Bayangkan berapa banyak permintaan atau panggilan ke API eksternal yang dapat ditangani sistem Anda selama waktu ini. </p><br><p>  Untuk meringkas: operasi I / O membuat thread menunggu dan menyia-nyiakan sumber daya. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bg/qm/k1/bgqmk13cgzyfg7vmynzpkxdxbdc.gif"></div><br><a name="p2"></a><br><h3 id="problema-c10k">  Masalah C10K </h3><br><p>  <strong>Masalah</strong> </p><br><p>  <b>C10k</b> (ind. <i>C10k; 10k koneksi</i> - 10 ribu masalah koneksi) </p><br><p>  Pada awal 2000-an, server dan mesin klien lambat.  Masalah muncul ketika memproses 10.000 koneksi klien ke mesin yang sama secara paralel. </p><br><p>  Tetapi mengapa model tradisional per permintaan tidak dapat (utas berdasarkan permintaan) menyelesaikan masalah ini?  Baiklah, mari kita gunakan sedikit matematika. </p><br><p>  Implementasi asli dari thread mengalokasikan lebih dari 1 MB memori per stream, meninggalkan ini - untuk 10 ribu thread, diperlukan 10 GB RAM dan ini hanya untuk stream stack.  Ya, dan jangan lupa, kita berada di awal tahun 2000-an !! </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/af/99/xc/af99xcxnykot0wq-zv20o-6cvps.jpeg"></div><br><p>  Saat ini, komputer server dan klien bekerja lebih cepat dan lebih efisien dan hampir semua bahasa pemrograman atau kerangka kerja dapat mengatasi masalah ini.  Namun faktanya, masalahnya tidak diselesaikan.  Untuk 10 juta koneksi klien ke satu mesin, masalahnya kembali lagi (tetapi sekarang adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah C10M</a> ). </p><br><p>  <strong>Penyelamatan JavaScript?</strong> </p><br><p>  Peringatan Spoiler <img width="70" src="https://habrastorage.org/webt/vl/iw/8n/vliw8nxrmg8paobiiyvuozjxpdc.png">  !!! <br>  Node.js sebenarnya memecahkan masalah C10K ... tapi bagaimana?! </p><br><p>  JavaScript sisi server bukanlah sesuatu yang baru dan tidak biasa pada awal 2000-an, pada waktu itu sudah ada implementasi di atas JVM (mesin virtual java) - RingoJS dan AppEngineJS, yang bekerja pada model thread-per-request. </p><br><p>  Tetapi jika mereka tidak bisa menyelesaikan masalah, lalu bagaimana mungkin Node.js ?!  Semua karena JavaScript adalah <strong>utas tunggal</strong> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lp/nx/vh/lpnxvhxjbmqmkzmblpqqmfcxq0s.gif"></div><br><a name="p3"></a><br><h3 id="nodejs-i-cikl-sobytiy">  Node.js dan loop acara </h3><br><p>  <strong>Node.js</strong> </p><br><p>  Node.js adalah platform server yang berjalan di mesin Google Chrome - V8, yang dapat mengkompilasi kode JavaScript ke dalam kode mesin. </p><br><p>  Node.js menggunakan model <strong>event-driven</strong> dan arsitektur <strong>I / O non-blocking</strong> , yang membuatnya ringan dan efisien.  Ini bukan kerangka kerja, atau perpustakaan, ini adalah runtime JavaScript. </p><br><p>  Mari kita tulis contoh kecil: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Importing native http module const http = require('http'); // Creating a server instance where every call // the message 'Hello World' is responded to the client const server = http.createServer(function(request, response) { response.write('Hello World'); response.end(); }); // Listening port 8080 server.listen(8080);</span></span></code> </pre> <br><p>  <strong>Non-blocking i / o</strong> </p><br><p>  Node.js menggunakan operasi input / output yang tidak menghalangi, apa artinya ini: </p><br><ul><li>  Utas utama tidak akan diblokir oleh operasi I / O. </li><li>  Server akan terus melayani permintaan. </li><li>  Kami harus bekerja dengan <strong>kode asinkron</strong> . </li></ul><br><p>  Mari kita menulis contoh di mana server mengirim halaman HTML sebagai tanggapan atas permintaan ke <code>/home</code> , dan untuk semua permintaan lainnya - 'Hello World'.  Untuk mengirim halaman HTML, Anda harus terlebih dahulu membacanya dari file. </p><br><p> <code>home.html</code> </p> <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>This is home page<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> <code>index.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.url === <span class="hljs-string"><span class="hljs-string">'/home'</span></span>) { fs.readFile(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ __dirname }</span></span></span><span class="hljs-string">/home.html`</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, content</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!err) { response.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'text/html'</span></span>); response.write(content); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response.statusCode = <span class="hljs-number"><span class="hljs-number">500</span></span>; response.write(<span class="hljs-string"><span class="hljs-string">'An error has ocurred'</span></span>); } response.end(); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response.write(<span class="hljs-string"><span class="hljs-string">'Hello World'</span></span>); response.end(); } }); server.listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>);</code> </pre> <br><p>  Jika url yang diminta adalah <code>/home</code> , maka modul asli <code>fs</code> digunakan untuk membaca file <code>home.html</code> . </p><br><p>  Fungsi yang termasuk dalam <code>http.createServer</code> dan <code>fs.readFile</code> sebagai argumen adalah <strong>panggilan balik</strong> .  Fungsi-fungsi ini akan dilakukan di beberapa titik di masa depan (yang pertama, segera setelah server menerima permintaan, dan yang kedua, ketika file dibaca dari disk dan ditempatkan di buffer). </p><br><p>  Saat file sedang dibaca dari disk, Node.js dapat memproses permintaan lain dan bahkan membaca file lagi dan semua ini dalam satu aliran ... tapi bagaimana caranya ?! </p><br><p>  <strong>Perulangan acara</strong> </p><br><p>  <strong>Perulangan acara</strong> adalah keajaiban yang terjadi di dalam Node.js.  Ini secara harfiah adalah loop tanpa akhir dan sebenarnya satu utas. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f_/sc/go/f_scgo68j5gpf0xsnzklzdr9cjc.jpeg"></div><br><p>  <strong>Libuv</strong> adalah pustaka C yang mengimplementasikan pola ini dan merupakan bagian dari kernel Node.js.  Anda dapat mempelajari lebih lanjut tentang libuv di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Sebuah siklus peristiwa memiliki 6 fase, setiap eksekusi semua 6 fase disebut <strong>tanda centang</strong> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2k/xy/eq/2kxyeqk7srzdocs9egzl5zlpwhm.png"></div><br><ul><li>  <strong>timer</strong> : dalam fase ini, panggilan balik yang dijadwalkan oleh metode <code>setTimeout()</code> dan <code>setInterval()</code> dijalankan; </li><li>  <strong>panggilan balik yang tertunda</strong> : hampir semua <strong>panggilan balik</strong> dijalankan, kecuali untuk aktivitas <code>close</code> , penghitung waktu, dan <code>setImmediate()</code> ; </li><li>  <strong>menganggur, siapkan</strong> : digunakan hanya untuk keperluan internal; </li><li>  <strong>polling</strong> : bertanggung jawab untuk menerima acara I / O baru.  Node.js dapat memblokir pada saat ini; </li><li>  <strong>check</strong> : callback yang disebabkan oleh metode <code>setImmediate()</code> dijalankan pada tahap ini; </li><li>  <strong>tutup panggilan balik</strong> : misalnya <code>socket.on('close', ...)</code> ; </li></ul><br><p>  Nah, hanya ada satu utas, dan utas ini adalah perulangan acara, tetapi lalu siapa yang melakukan semua I / O? </p><br><p>  Perhatikan <img width="60" src="https://habrastorage.org/webt/92/8i/lj/928iljyzpqhkbczypvvqgkx0zc0.png">  !!! <br>  Ketika sebuah loop peristiwa perlu melakukan operasi I / O, ia menggunakan utas OS dari kumpulan utas, dan ketika tugas selesai, panggilan balik akan diantrekan selama fase <em>panggilan balik yang tertunda</em> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/z7/uw/lzz7uwcdvm1xd1yr6utj7cae36g.png"></div><br><p>  Bukankah itu keren? </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/it/yo/bh/ityobhc10qgnkk5m9yk5xp94ble.gif"></div><br><a name="p4"></a><br><h3 id="problema-cpu-yomkih-zadach">  Masalah tugas intensif CPU </h3><br><p>  Node.js tampaknya sempurna!  Anda dapat membuat apa pun yang Anda inginkan. </p><br><p>  Mari kita menulis API untuk menghitung bilangan prima. </p><br><p>  Bilangan prima adalah bilangan bulat (alami) yang lebih besar dari satu dan hanya dapat dibagi dengan 1 dan dengan sendirinya. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nl/kn/7f/nlkn7fwr_kxhtktm-_gt0ci7ask.jpeg"></div><br><p>  Dengan diberi nomor N, API harus menghitung dan mengembalikan N primes pertama dalam daftar (atau larik). </p><br><p> <code>primes.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>, s = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(n); i &lt;= s; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n % i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nthPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = n; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterator = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(counter &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--; iterator++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { isPrime, nthPrime };</code> </pre> <br><p> <code>index.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> primes = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./primes'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { pathname, query } = url.parse(request.url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathname === <span class="hljs-string"><span class="hljs-string">'/primes'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = primes.nthPrime(query.n || <span class="hljs-number"><span class="hljs-number">0</span></span>); response.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>); response.write(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(result)); response.end(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response.statusCode = <span class="hljs-number"><span class="hljs-number">404</span></span>; response.write(<span class="hljs-string"><span class="hljs-string">'Not Found'</span></span>); response.end(); } }); server.listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>);</code> </pre> <br><p>  <code>prime.js</code> adalah implementasi perhitungan yang diperlukan: fungsi <code>isPrime</code> memeriksa apakah nomornya prima, dan nthPrime mengembalikan N angka-angka tersebut. </p><br><p>  File <code>index.js</code> bertanggung jawab untuk membuat server dan menggunakan modul <code>prime.js</code> untuk memproses setiap permintaan untuk <code>/primes</code> .  Angka N dilemparkan melalui string kueri di URL. </p><br><p>  Untuk mendapatkan 20 primes pertama kita perlu membuat permintaan ke <code>http://localhost:8080/primes?n=20</code> . </p><br><p>  Misalkan kita memiliki 3 klien yang mengetuk kita dan mencoba mengakses API I / O yang tidak menghalangi kita: </p><br><ul><li>  Pertanyaan pertama 5 bilangan prima setiap detik. </li><li>  Yang kedua meminta 1000 bilangan prima setiap detik </li><li>  Yang ketiga meminta 10.000.000.000 bilangan prima, tetapi ... </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pz/rx/bl/pzrxblziplf06w7-kzbyojhafhg.gif"></div><br><p>  Ketika klien ketiga mengirim permintaan, utas utama diblokir dan ini adalah gejala utama masalah <strong>tugas-tugas yang intensif CPU</strong> .  Ketika utas utama sibuk melakukan tugas "berat", itu menjadi tidak dapat diakses untuk tugas-tugas lain. </p><br><p>  Tapi bagaimana dengan libuv?  Jika Anda ingat, pustaka ini membantu Node.js melakukan operasi input / output menggunakan utas OS menghindari pemblokiran utas utama dan Anda memang benar, ini adalah solusi untuk masalah kami, tetapi untuk memungkinkan, modul kami harus ditulis dalam bahasa C ++ jadi libuv dapat bekerja dengannya. </p><br><p>  Untungnya, dimulai dengan v10.5, modul <strong>Worker Threads</strong> asli telah ditambahkan ke Node.js. </p><br><a name="p5"></a><br><h3 id="vorkery-i-ih-potoki">  Pekerja dan arus mereka </h3><br><p>  Seperti yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan</a> dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> : </p><br><blockquote>  Pekerja bermanfaat untuk melakukan operasi JavaScript intensif CPU;  jangan menggunakannya untuk operasi input / output, mekanisme yang sudah dibangun ke dalam Node.js lebih efisien mengatasi tugas-tugas seperti itu daripada utas Pekerja. </blockquote><p>  <strong>Memperbaiki kode</strong> </p><br><p>  Saatnya untuk menulis ulang kode kita: </p><br><p> <code>primes-workerthreads.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>, s = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(n); i &lt;= s; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n % i === <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nthPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = n; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterator = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(counter &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--; iterator++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } parentPort.postMessage(nthPrime(workerData.n));</code> </pre> <br><p> <code>index-workerthreads.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Worker } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { pathname, query } = url.parse(request.url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathname === <span class="hljs-string"><span class="hljs-string">'/primes'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker(<span class="hljs-string"><span class="hljs-string">'./primes-workerthreads.js'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">workerData</span></span>: { <span class="hljs-attr"><span class="hljs-attr">n</span></span>: query.n || <span class="hljs-number"><span class="hljs-number">0</span></span> } }); worker.on(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ response.statusCode = <span class="hljs-number"><span class="hljs-number">500</span></span>; response.write(<span class="hljs-string"><span class="hljs-string">'Oops there was an error...'</span></span>); response.end(); }); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; worker.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ result = message; }); worker.on(<span class="hljs-string"><span class="hljs-string">'exit'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ response.setHeader(<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>, <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>); response.write(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(result)); response.end(); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { response.statusCode = <span class="hljs-number"><span class="hljs-number">404</span></span>; response.write(<span class="hljs-string"><span class="hljs-string">'Not Found'</span></span>); response.end(); } }); server.listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>);</code> </pre> <br><p>  Dalam file <code>index-workerthreads.js</code> , setiap permintaan ke <code>/primes</code> membuat instance dari kelas <code>Worker</code> (dari modul native <code>worker_threads</code> ) untuk mengunggah dan mengeksekusi file <code>primes-workerthreads.js</code> ke thread pekerja.  Ketika daftar bilangan prima dihitung dan siap, peristiwa <code>message</code> dipicu - hasilnya jatuh ke aliran utama karena pekerja tidak memiliki pekerjaan yang tersisa, ia juga memicu acara <code>exit</code> , yang memungkinkan aliran utama untuk mengirim data ke klien. </p><br><p>  <code>primes-workerthreads.js</code> berubah sedikit.  Ini mengimpor data <code>workerData</code> (ini adalah salinan dari parameter yang diteruskan dari utas utama) dan <code>parentPort</code> mana hasil pekerjaan pekerja dilewatkan kembali ke utas utama. </p><br><p>  Sekarang mari kita coba contoh kita lagi dan lihat apa yang terjadi: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zu/vk/gh/zuvkghy8dnhjryfdf5b62ped8dw.gif"></div><br><p>  Utas utama tidak lagi diblokir <img width="115" src="https://habrastorage.org/webt/nn/hs/r3/nnhsr3jiw_4aed53jye8gokutpy.png">  !!!!! </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tt/ij/el/ttijelgt36k_vbengx3qjaaajlc.gif"></div><br><p>  Sekarang semuanya berjalan sebagaimana mestinya, tetapi menghasilkan pekerja tanpa alasan masih bukan praktik yang baik, membuat benang bukanlah kesenangan yang murah.  Pastikan untuk membuat kumpulan utas sebelum ini. </p><br><h4 id="zaklyuchenie">  Kesimpulan </h4><br><p>  Node.js adalah teknologi canggih yang harus dieksplorasi jika memungkinkan. <br>  Rekomendasi pribadi saya - selalu ingin tahu!  Jika Anda tahu cara kerja sesuatu dari dalam, Anda bisa bekerja dengan lebih efisien. </p><br><p>  Itu saja untuk hari ini kawan.  Saya harap posting ini bermanfaat bagi Anda dan Anda mempelajari sesuatu yang baru tentang Node.js. </p><br><p>  Terima kasih telah membaca dan melihat Anda di posting selanjutnya. <img width="20" src="https://habrastorage.org/webt/bd/lk/kd/bdlkkdf7adtljydvhxyw22y3cfi.png">  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460661/">https://habr.com/ru/post/id460661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460645/index.html">Berbuat baik berbuat jahat: menulis kode jahat dengan Go, Bagian 1</a></li>
<li><a href="../id460647/index.html">Memecahkan pekerjaan dengan pwnable.kr 05 - passcode. Tabel tautan prosedur penulisan ulang melalui kerentanan format string</a></li>
<li><a href="../id460651/index.html">Pertemuan Society of Anonymous Testers: TMS, pemantauan pemantauan, penilaian kualitas pencarian dan tes iOS asli</a></li>
<li><a href="../id460655/index.html">Bagaimana saya mematahkan Telegram</a></li>
<li><a href="../id460659/index.html">Menggunakan Pipa untuk Pivoting</a></li>
<li><a href="../id460665/index.html">Draft FAQ: Mengapa standar C ++ keluar setiap tiga tahun?</a></li>
<li><a href="../id460667/index.html">Otomatisasi pengujian layanan berbayar di iOS</a></li>
<li><a href="../id460669/index.html">Bagaimana memastikan keamanan pengembangan, menghemat waktu dan saraf</a></li>
<li><a href="../id460671/index.html">Kepemilikan dan pinjaman dalam D</a></li>
<li><a href="../id460673/index.html">Paparkan keajaiban DiffUtil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>