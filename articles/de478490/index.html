<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔒 👦🏼 🧓🏽 Levenshtein Abstand und Suche nach Controllern 🦎 ✡️ 🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wahrscheinlich gibt es in jeder Stadt in Weißrussland, in der es Oberleitungsbusse gibt, VK-Gruppen oder Chats auf Telegram, in denen Personen den Sta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Levenshtein Abstand und Suche nach Controllern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478490/">  Wahrscheinlich gibt es in jeder Stadt in Weißrussland, in der es Oberleitungsbusse gibt, VK-Gruppen oder Chats auf Telegram, in denen Personen den Standort der Controller verfolgen.  Dies geschieht hauptsächlich, um nicht für Reisen und Reisen kostenlos zu bezahlen, obwohl die Beschreibung der Gruppen fast immer das Nachskript „Für Reisen bezahlen“ enthält. <br><a name="habracut"></a><br>  In VC sieht es normalerweise so aus: <br><br><img src="https://habrastorage.org/webt/ti/eh/cd/tiehcdyeskmccfofp3adt2ko_qe.png" alt="Bild"><br><br>  Ein typischer Kommentar sieht so aus: <br><br><img src="https://habrastorage.org/webt/ki/kp/s0/kikps0wwqqptfwyro8hrf81rtzg.png" alt="Bild"><br><br>  Der Aufbau ist denkbar einfach.  Im Kommentar stehen die Namen der Haltestellen, an denen die Controller gerade bemerkt wurden, sowie die Richtung, in der sie stehen: <br><br><img src="https://habrastorage.org/webt/no/gy/2l/nogy2l1lrraa8gte90lcyuwsume.png" alt="Bild"><br><br>  Der Kommentar ist daher ein Objekt mit einem Stopp, einer Uhrzeit und einem Datum sowie einer eindeutigen ID, anhand derer wir ihn identifizieren können.  Auf diese Weise können Sie die wahrscheinlichste Position berechnen, an der sich die Steuerungen jetzt befinden. <br><br><h4>  Vorbereitung </h4><br>  Zuerst müssen Sie die Zielgruppe bestimmen, aus der die Daten analysiert werden.  Die Gruppe sollte ziemlich viel Aktivität in den Kommentaren haben, sonst riskieren wir, zu wenig Daten zu bekommen <br><br>  In meinem Fall ist dies die Gruppe „Control Gomel“. <br><br>  Wir analysieren Kommentare mit der offiziellen VKontakte-API für Python <br><br>  Wir authentifizieren uns mit dem Zugriffsschlüssel des Benutzers, da einige Gruppen möglicherweise geschlossen sind und der Zugriff auf ihre Kommentare nur möglich ist, wenn Sie in die Gruppe aufgenommen wurden. <br>  Danach können Sie Kommentare extrahieren: <br><br><h4>  Kommentare erhalten </h4><br>  Zunächst erhalten wir den letzten verfügbaren Beitrag in der Gruppe, um Kommentare über vk.wall.getComments abzurufen und den DataFrame zu initialisieren, in dem die Daten gespeichert werden. <br><br>  Jeder Kommentarbeitrag trägt die Aufschrift „Ich wünsche Ihnen einen schönen Tag, bezahle den Fahrpreis und gerate nicht unter Kontrolle“. Laden Sie daher die Kommentare herunter, überprüfen Sie den Inhalt des Beitrags und erhalten Sie eine Reihe von Kommentaren, aus denen Sie Daten abrufen können. <br><br>  Ich habe Kommentare von Posts in den letzten 3 Monaten gelesen, da täglich 1 Post veröffentlicht wird (jetzt, Ende November, beginnt das Schuljahr im September, und die Betreuer berücksichtigen dies höchstwahrscheinlich und wechseln ihre gewöhnlichen Plätze).  Grundsätzlich können auch andere Vorzeichen berücksichtigt werden, wie zum Beispiel die Jahreszeit. <br><br>  Einige der Kommentare sind mit Nachrichten wie "Gibt es jemanden auf Barykin?"  Wenn Sie sich solche (unnötigen) Kommentare ansehen, können Sie einige Anzeichen hervorheben: <br><br><ul><li>  Der Text enthält die Wörter "sauber", "links", "niemand" und dergleichen </li><li>  Die Worte "sag mir", "wer", "was", "wie" </li><li>  Symbole wie zum Beispiel Emoticons </li></ul><br>  Danach gehen wir eine Reihe von Kommentaren durch und ziehen eine eindeutige ID, einen eindeutigen Text, eine eindeutige Uhrzeit, ein eindeutiges Datum und einen eindeutigen Wochentag heraus, die wir in den bereits erstellten DataFrame einfügen. <br><br><div class="spoiler">  <b class="spoiler_title">Kommentare erhalten</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> vk_api <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> check_correctness <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> vk_session = vk_api.VkApi(lp.login, lp.password) vk_session.auth() vk = vk_session.get_api() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vk <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataFromComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vk, groupID)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     posts = vk.wall.get(owner_id=groupID, offset=1, count=90) print("\n") data = pd.DataFrame(columns=['text', 'post_id', "date", "day_in_week", "hour","minute", "day_in_month"]) for post in posts.get("items"): # id     postID = post.get("id") if "  ,       " not in post.get("text"): continue #  commentary       comments = vk.wall.getComments(owner_id=groupID, post_id=postID, count=200) #           dataframe for comment in comments.get("items"): text = comment.get("text") text = re.sub(r"A-Za-z--0123456789 ", "", str(text)) commentaryIsNice = check_correctness.detection(text) if commentaryIsNice: print(text) date = comment.get("date") time_struct = time.gmtime(date) post_id = comment.get("post_id") data = data.append({"text": text, "post_id" : post_id, "date": date,"day_in_week" : time_struct.tm_wday, "hour": (time_struct.tm_hour+3), "minute": time_struct.tm_min, "day_in_month": time_struct.tm_mday}, ignore_index=True) # print(data[:10]) # print(data.info()) print("dataset is ready") return data</span></span></code> </pre> <br></div></div><br>  So erhielten wir einen DataFrame mit dem Kommentartext, der ID, dem Wochentag, der Stunde und der Minute, in der der Kommentar geschrieben wurde.  Wir brauchen nur den Wochentag, die Schreibstunde und den Text.  Es sieht ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/cd/hs/cy/cdhscyg3rx4f5kejgvjdguuscui.png" alt="Bild"><br><br><h4>  Datenbereinigung </h4><br>  Jetzt müssen wir die Daten löschen.  Es ist notwendig, die Richtung aus dem Kommentar zu entfernen, um weniger Fehler bei der Suche nach der Levenshtein-Entfernung zu machen.  Wir finden die Ausdrücke "zur Seite", "gehen", "wie", "in der Nähe", da ihnen normalerweise der Name der zweiten Haltestelle folgt, und wir löschen sie zusammen mit dem, was danach kommt, sowie ersetzen einige umgangssprachliche Namen der Haltestellen durch die üblichen . <br><br><div class="spoiler">  <b class="spoiler_title">Daten löschen</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fuzzywuzzy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> process <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear_commentary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    -     """</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span> splitted = text.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(splitted): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(splitted) == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.NaN <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ( <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ( <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s)) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>): index = i <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> index &lt; len(splitted) - <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>): splitted.remove(splitted[index]) string = <span class="hljs-string"><span class="hljs-string">" "</span></span>.join(splitted) text = (string.lower()) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: splitted = splitted[:index] string = <span class="hljs-string"><span class="hljs-string">" "</span></span>.join(splitted) text = string.lower() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: text = <span class="hljs-string"><span class="hljs-string">" "</span></span>.join(splitted).lower() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clean_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> data.dropna(inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) data[<span class="hljs-string"><span class="hljs-string">"text"</span></span>] = data[<span class="hljs-string"><span class="hljs-string">"text"</span></span>].map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> s: clear_commentary(s)) data.dropna(inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) print(<span class="hljs-string"><span class="hljs-string">"cleaned"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br></div></div><br><h4>  Konvertieren mit Levenshtein Abstand </h4><br>  Wir fahren direkt zur Levenshane-Strecke.  Eine kleine Hilfe: Levenshtein distance - die minimale Anzahl von Operationen, um ein Zeichen einzufügen, ein Zeichen zu löschen und ein Zeichen durch ein anderes zu ersetzen, die erforderlich sind, um eine Zeile in eine andere zu verwandeln. <br><br>  Wir werden es mit der <a href="https://github.com/seatgeek/fuzzywuzzy">Fuzzywuzzy-</a> Bibliothek finden.  Sie können damit schnell und einfach die Levenshtein-Entfernung berechnen.  Um die Arbeit zu beschleunigen, empfehlen die Autoren der Bibliothek auch die Installation der Python-Levenshtein-Bibliothek. <br><br>  Um Stopps von Kommentaren zu erhalten, benötigen wir eine Liste von Stopps.  Es wurde mir freundlicherweise vom Entwickler der GoTrans-Anwendung, Alexander Kozlov, zur Verfügung gestellt. <br><br>  Die Liste musste erweitert werden, um dort einige Haltestellen hinzuzufügen, die nicht vorhanden waren, und um einen Teil der Namen zu ändern, damit sie besser zu finden waren. <br><br><div class="spoiler">  <b class="spoiler_title">Stoppt</b> <div class="spoiler_text">  Haltestellen = ['Supermarkt', 'Wiese', 'Remybtekhnika', 'Leningrad', 'Jaroslawl', 'Polesskaja', <br>  "Jaroslawl", "Timofeenko", "8. März", <br>  "Rechitsky Handelshaus", "Rechitsky Avenue", "Zirkus", "Kaufhaus", "Chongarskaya", <br>  "Chongarka", "Ggu", "Skorina", "Universität", "Gerät", "1000 kleine Dinge", "Maya", "Station", <br>  "Absolventenpark", "Handel und Wirtschaft", "Jubiläum", "Mikrobezirk 18", "Flughafen", "Gegenverkehr", <br>  'gomelgeodezcentr', 'crystal', 'lake lyubenskoye', 'davydovsky market', 'davydovka', <br>  "Fluss sozh", "gomeldrev", <br>  "Sevruki", "GMU Nr. 1", "etc. Rechitsky", "Kostüm", "Krankenhaus für Infektionskrankheiten", "Möwenlager", <br>  Volotova, Koralle, Gomeltorgmash, Gomelproekt, Vneshgomelstroy, Zeitung, <br>  "Kalenikova", "Eremino", "Brennerei", "spezielle industrielle Automatisierung", "2. Schule", "Barykina", <br>  "Maschineneinheiten", "Jugend", "Casting-Körper", "Chemiker", "Golovatsky", "budenny", <br>  "Spu67", "35th", "Gagarin", "50 Jahre bis zum Werk Gomselmash", "Hügel", "Radiofabrik", <br>  "Großmutter", "Glashütte", "Kastanie", "Anlassen von Motoren", "Astronauten", <br>  "rtsrm initial", "bykhovskaya", "Institut des Ministeriums für Notsituationen", "dk gomselmash", "store", "rechitsky", <br>  "Sevruks", "Osovtsy", "Tourist", "Fleischfabrik", "Holy Trinity", "Medical Town", "Oktober", <br>  "Öldepot", "Gomelloblavtotrans", "Milkavita", "Bakunin", "Zip", "Oma", "Harz", <br>  "Baumarkt Ksk", "Straßenbauer", "Feld", "Kamenetskaya", "Bolschewik", "Jakubovka", <br>  "Borodina", "Hippo-Hypermarkt", "Untergrundhelden", "9. Mai", "Kastanie", "Prothetiker", <br>  "iput station", "communist international", "musikpädagogische Hochschule", "landwirtschaftliche Firma", "Umgehungsstraße", "Sieg", <br>  "westlichen", "Perle", "Vladimir", "trocken", "Apotheke", "Ivanova", <br>  "Maschinenbau", "Birken", "60 Jahre", "Power Engineer", "Centrolite", <br>  "Onkologische Klinik", "Schießstand", "Golovintsy", "Koralle", "Süd", "Frühling", <br>  Efremova, Grenze, Belgut, Gomelstroy, Borisenko, Leichtathletikpalast, <br>  "Mitschurinski", "Solar", "Gastello", "Militär", "Autozentrum", "Sanitär", "Uza", <br>  "Medical College", "Kindergarten 11", "Bolschewiki", "Welpen", "Davydovsky", "Ozean", "Fortschritt", <br>  "Dobrushskaya", "weiß", "GSK", "davydovka", "elektrische Ausrüstung", "Freundschaft", <br>  '70 Jahre ',' Autoreparatur ',' Schwedischer Hügel ',' Rennstrecke ',' Wasserkanal ',' Maschinengomel ', <br>  Volotova, Pionier, RCM, Khimtorg, 2. Wiesenstraße, Bochkina, Bäder, <br>  "Onkologische Klinik", "Square", "Lenin", "1st School", "South Store", <br>  'gomelagrotrans', 'millers', 'lyubensky', 'military enlistment office', 'hospital', 'uza', 'rtsrm', <br>  "lysyukovy", "shop iput", "raton", "tankstelle", "randovskoe", "bauernhaus", "kastanie", "ropovsky", <br>  "Romanovichi", "Iljitsch", "Rudern", "Bauunternehmen", "ansteckend", <br>  "Fettfabrik", "Autoservice", "Agroservice", "klebrig", "Nikolskaya", <br>  "Selbstfahrende Erntemaschinen", "Maurer", "Baustoffe", "Reparaturmaschinen", "Verwaltung", <br>  "Oktober", "Waldmärchen", "Tatiana", "Boris Tsarikov", "Zharkovsky", "Zaitseva", <br>  "Umzug", "Karpovich", "Hausbau", "Stadt Elektromobilität", "Zlin", <br>  "stadium gomselmash", "ap 6", "hydraulischer antrieb", "lokomotivendepot", "automarkt osovtsy", <br>  "Neues Leben", "Schukowa", "Militäreinheit", "Dritte Schule", "Wald", "Roter Leuchtturm", <br>  "Regional", "Davydovskaya", "Karbysheva", "Satellit der Welt", "Jugend", "Stadion Lokomotive", <br>  "Solar", "Ladaservice", "μR 21", "Aresa", "Internationalisten", "Kosareva", <br>  "Bogdanova", "Gomel Eisenbeton", "μr 20a", "μr Rechitsky", "medizinische Ausrüstung", "Juraeva", <br>  "College of Art Crafts", "Ice", "DK Festival", "Einkaufszentrum", <br>  "Kuibyshevsky", "Festival", "Garage Koop 27", "Seismik", "Milcha", "Tube Hospital", <br>  "ptu179", "chemische Produkte", "Feuerwehr", "Krankenhaus", "Busdepot", <br>  "Zeitungskomplex", "Sieg", "Klenkowski", "Diamant", "Motorreparatur", "mkr 19"] <br></div></div><br>  Mit .map und fuzzywuzzy.process.extractOne finden wir die Haltestelle mit dem minimalen Levenshtein-Abstand in der Liste. Danach ersetzen wir den Kommentartext durch den Namen der Haltestelle, wodurch wir einen Datensatz mit den Namen der Haltestellen erhalten. <br><br>  Der resultierende Datensatz sieht ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/gd/pd/c8/gdpdc8lwdppzpastghnasxbqsbi.png"><br><br><div class="spoiler">  <b class="spoiler_title">Kommentare werden zu Stopps</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_category_from_comment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""              """</span></span> dict = process.extractOne(text.lower(), stops) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dict[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">75</span></span>: text = dict[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: text = np.nan print(<span class="hljs-string"><span class="hljs-string">"wait"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_category_dataset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""      """</span></span> print(<span class="hljs-string"><span class="hljs-string">"remap started. wait"</span></span>) data.text = data.text.map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> comment: get_category_from_comment(str(comment))) print(<span class="hljs-string"><span class="hljs-string">"remap ends"</span></span>) data.dropna(inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) data[<span class="hljs-string"><span class="hljs-string">"text"</span></span>] = data.text.map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> s: <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s==<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> s) data[<span class="hljs-string"><span class="hljs-string">"text"</span></span>] = data.text.map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> s: <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s==<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> s) data[<span class="hljs-string"><span class="hljs-string">"text"</span></span>] = data.text.map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> s: <span class="hljs-string"><span class="hljs-string">" "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s==<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> s) data[<span class="hljs-string"><span class="hljs-string">"text"</span></span>] = data.text.map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> s: <span class="hljs-string"><span class="hljs-string">" "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s==<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> s) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br></div></div><br><h4>  Datenausgabe </h4><br>  Jetzt können wir davon ausgehen, wo sich die Controller höchstwahrscheinlich zur gegebenen Stunde befinden werden. <br><br>  Wir suchen in den resultierenden Datensätzen nach einer bestimmten Stunde und einem bestimmten Wochentag.  Zum Beispiel am Dienstag, 9 Uhr: <br><br><pre> <code class="python hljs">&lt;code&gt;data[(data[<span class="hljs-string"><span class="hljs-string">"day_in_week"</span></span>] == day) &amp; (data[<span class="hljs-string"><span class="hljs-string">"hour"</span></span>] == hour)]&lt;/code&gt;</code> </pre> <br><img src="https://habrastorage.org/webt/t4/gg/dg/t4ggdgmwezje8lgllisorbqrqwa.png"><br>  <i>(das sind nicht alle Daten)</i> <br><br>  Danach finden wir die Anzahl der eindeutigen Haltestellen und zeigen nur die Haltestellen und ihre Anzahl an: <br><br><pre> <code class="python hljs">df[(df[<span class="hljs-string"><span class="hljs-string">"day_in_week"</span></span>] == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; (df[<span class="hljs-string"><span class="hljs-string">"hour"</span></span>] == <span class="hljs-number"><span class="hljs-number">9</span></span>)][<span class="hljs-string"><span class="hljs-string">"text"</span></span>].value_counts()</code> </pre> <br><img src="https://habrastorage.org/webt/yq/az/if/yqazifl3gkclyqw4ifykvemsrky.png"><br><br>  Jetzt können wir sagen, dass die Controller am Dienstag um 9 Uhr morgens höchstwahrscheinlich an den Haltestellen Myasokombinat, Ul.  Lugovaya, BelGUT, TD "Oma". <br><br>  Der Hauptfehler bei dieser Methode ist der Mangel an Daten.  Nicht für alle Tage und Stunden gibt es Einträge in den Kommentaren, die während der Hauptverkehrszeit gegeben werden, wenn die Leute mehr öffentliche Verkehrsmittel benutzen als die Daten in weniger populären Stunden, wenn Sie jedoch Daten hinzufügen, beispielsweise nicht nur aus den Kommentaren einer Gruppe, sondern auch von alternativen Gruppen oder Telegramm-Chats mit der Anzahl der Einträge wird alles einfacher. <br><br><h4>  Bot mit VK LongPoll API </h4><br>  Um die Möglichkeit zu geben, zeitabhängig und ohne Bindung an einen Computer Daten über den Standort der Steuerungen zu empfangen, habe ich einen Bot für eine Gruppe in VKontakte erstellt, der auf jede Nachricht mit der Anzahl der Stopps in den Aufzeichnungen unter Berücksichtigung der aktuellen Stunde und des aktuellen Wochentags reagiert. <br><br><div class="spoiler">  <b class="spoiler_title">Bot-Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> randint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> vk_api <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> get_stops_from_data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> get_stops_by_time <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_bot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, token)</span></span></span><span class="hljs-function">:</span></span> vk_session = vk_api.VkApi(token=token) vk = vk_session.get_api() print(<span class="hljs-string"><span class="hljs-string">"bot started"</span></span>) longPoll = vk.groups.getLongPollServer(group_id=<span class="hljs-number"><span class="hljs-number">183524419</span></span>) server, key, ts = longPoll[<span class="hljs-string"><span class="hljs-string">'server'</span></span>], longPoll[<span class="hljs-string"><span class="hljs-string">'key'</span></span>], longPoll[<span class="hljs-string"><span class="hljs-string">'ts'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#  :   ts longPoll = post('%s' % server, data={'act': 'a_check', 'key': key, 'ts': ts, 'wait': 25}).json() if longPoll['updates'] and len(longPoll['updates']) != 0: for update in longPoll['updates']: if update['type'] == 'message_new': #        vk.messages.markAsRead(peer_id=update['object']['user_id']) user = update['object']["user_id"] text = get_stops_by_time(data) if text is None or text == {}: message = "íåò çàïèñåé" vk.messages.send(user_id=user, random_id=randint(-2147483648, 2147483647), message=message) print(message) ts = longPoll['ts'] continue message = "   -     \n" \ "\n \n" for i in text.items(): message += i[0] + " " message += str(i[1]) message += "\n" #    vk.messages.send(user_id=user, random_id=randint(-2147483648, 2147483647), message=message) ts = longPoll['ts']</span></span></code> </pre> <br></div></div><br><h4>  Fazit </h4><br>  Die Qualität solcher Hypothesen wurde von mir mehr als einmal in der Praxis getestet, und alles funktioniert einwandfrei.  Es stellte sich heraus, dass die Controller im Grunde genommen an den gleichen Haltestellen sind, obwohl absolut korrekte Vorhersagen nicht gegeben werden können und die Erfolgswahrscheinlichkeit nicht 100% beträgt.  Die Entfernung von Levenshtein hat Dutzende verschiedener Anwendungen, angefangen von der Korrektur von Fehlern in einem Wort bis hin zum Vergleich von Genen, Chromosomen und Proteinen, aber auch Potenzial bei solchen angewandten Problemen. <br><br>  Ich wünsche Ihnen einen schönen Tag und bezahle den Fahrpreis. <br><br>  Alle Botcode- und Datenmanipulationen werden <a href="https://github.com/dingdongyouarewrong/vk_controllers_bot">hier veröffentlicht</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478490/">https://habr.com/ru/post/de478490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478474/index.html">Bruder Pablo Escobar hat auch ein flexibles Smartphone herausgebracht</a></li>
<li><a href="../de478480/index.html">Künstliche Intelligenz, ITSM und allgemein, woher kommt LEAN?</a></li>
<li><a href="../de478482/index.html">Der Entwickler öffnete eine Bar für Entwickler und veranstaltete dort Meetings zu den Themen Angular, Layout und PHP</a></li>
<li><a href="../de478484/index.html">SCADA über Himbeere: Mythos oder Realität?</a></li>
<li><a href="../de478486/index.html">Die Ära der 10-nm-Chips - wer entwickelt solche Prozessoren und was erwartet die Industrie in Zukunft?</a></li>
<li><a href="../de478492/index.html">Escherichia coli auf CO2-Diät: Ein neues Instrument im Kampf gegen die globale Erwärmung?</a></li>
<li><a href="../de478494/index.html">Winnum TRP-Wärmebehandlungslösung: Einrichtung und Verwendung</a></li>
<li><a href="../de478496/index.html">Vor 50 Jahren wurde in Raumnummer 3420 das Internet geboren</a></li>
<li><a href="../de478498/index.html">1. Fortinet Erste Schritte v 6.0. Einleitung</a></li>
<li><a href="../de478500/index.html">Warum gibt es im Sommer so wenige Konferenzen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>