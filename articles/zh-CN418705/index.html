<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏻 🎇 🎡 Futex基础 🍣 ⭐️ 🕡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Futex （ futex- “快速用户空间互斥量”的缩写）是Linux开发人员从IBM在2002年提出的一种机制，并于2003年底进入内核。 主要思想是提供一种更有效的方法，以最少的OS内核调用次数来同步用户线程。 

 在本文中，我们将回顾这些功能模块，尝试了解它们的工作原理，还将它们用作构建更...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Futex基础</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/418705/">  <b>Futex</b> （ <b>futex-</b> “快速用户空间互斥量”的缩写）是Linux开发人员从IBM在2002年提出的一种机制，并于2003年底进入内核。 主要思想是提供一种更有效的方法，以最少的OS内核调用次数来同步用户线程。 <br><br> 在本文中，我们将回顾这些功能模块，尝试了解它们的工作原理，还将它们用作构建更高级别（我们熟悉的）同步对象的基础。 <br><br> 重要一点：futexes是一个相当低级的工具；仅在开发基本库（例如标准C / C ++库）时才值得直接使用它。 您不太可能需要在常规应用程序中使用futex。 <br><a name="habracut"></a><br><h3> 动机 </h3><br> 在futex出现之前，有必要每次都进行系统调用（例如使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">semop</a> ）来控制对多个线程的共享资源的访问，这是资源密集型的，因为每个调用都需要将上下文从用户模式切换到内核模式。 随着现代处理器中内核数量的增加以及应用软件中线程数量的增加，这已经成为一个重要的问题。 鉴于所有这些调用均未携带任何应用功能，未实现任何业务逻辑，而仅保证其余代码的正确操作，因此这甚至更具“冒犯性”。 <br><br> 提议向OS添加新概念“ futex”是基于一个简单的观察结果：在大多数情况下，捕获同步对象的尝试首次成功。 程序员以这样一种方式来编写软件：从锁定锁到解锁，所需的时间尽可能短，这意味着捕获另一个线程的尝试不会遇到障碍的可能性很高。 当流到达这样的“自由”同步对象时，我们可以捕获它而无需使用相对便宜的原子操作进行系统调用。 原子操作成功进行的可能性很大。 <br><br> 在那种罕见的情况下，当我们仍然尝试访问被另一个线程阻塞的资源时，原子操作将返回错误。 在这种情况下，我们有两个选择。 我们可以旋转用户模式的自旋锁，等待资源的释放（这将消耗CPU资源），或者让内核进入睡眠模式，等待资源的释放。 这是futex进入场景的地方。 <br><br><h3> 简单使用futexes-期望和唤醒 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">futex系统调用</a>结合了多种功能。 我们在这里不考虑复杂的选项（其中一些选项太复杂，甚至在官方文档中也没有描述），而是集中在FUTEX_WAIT和FUTEX_WAKE操作上。 官方文档中的描述将为您提供良好的基础： <br><blockquote>  futex（）系统调用为程序提供了一种等待特定条件变为真的方法。 通常，此系统调用在共享内存同步的上下文中使用阻塞构造。 使用futex时，主要同步操作在用户空间中执行。 用户空间程序仅在程序需要长时间进入待机模式直到条件变为真时才执行futex（）系统调用。 另外，futex（）可用于唤醒需要特定条件的进程或线程。 </blockquote> 简而言之，futex是一种内核构造，可在发生某些情况时帮助用户代码同步线程。 一些进程（或线程）可以等待FUTEX_WAIT调用中的事件，而其他进程（或线程）可以使用FUTEX_WAKE调用这些事件。 等待有效地进行-等待线程被内核挂起，并且不使用处理器资源，直到发生预期事件时将它们唤醒。 <br><br> 花时间阅读整个文档。 好吧，或者至少阅读有关FUTEX_WAIT和FUTEX_WAKE的部分。 <br><br> 让我们看一个<a href="">简单的示例</a> ，该<a href="">示例</a>演示了使用futex来协调两个流程的工作的基本用法。 <br><br> 子进程： <br><br><ol><li> 在通用内存插槽中等待0xA </li><li> 将值0xB写入此插槽 </li></ol><br> 父进程此时： <br><br><ol><li> 将0xA值写入共享内存插槽 </li><li> 等待0xB出现在其中 </li></ol><br> 两个过程之间的这种“握手”。 这是代码： <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shm_id = shmget(IPC_PRIVATE, <span class="hljs-number"><span class="hljs-number">4096</span></span>, IPC_CREAT | <span class="hljs-number"><span class="hljs-number">0666</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shm_id &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"shmget"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* shared_data = shmat(shm_id, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); *shared_data = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> forkstatus = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   printf("child waiting for A\n"); wait_on_futex_value(shared_data, 0xA); printf("child writing B\n"); //  0xB         *shared_data = 0xB; wake_futex_blocking(shared_data); } else { //   printf("parent writing A\n"); //  0xA         *shared_data = 0xA; wake_futex_blocking(shared_data); printf("parent waiting for B\n"); wait_on_futex_value(shared_data, 0xB); // Wait for the child to terminate. wait(NULL); shmdt(shared_data); } return 0; }</span></span></code> </pre> <br> 注意POSIX调用以在进程之间分配共享内存。 我们在这里不能使用通常的内存分配，因为即使不同进程中的指针的相同地址实际上也会指向不同的内存块（每个进程唯一）。 <br><br> 应当注意的是，该示例与规范有所不同，因为futex最初是为了等待特定含义的更改而创建的，即“从某物变为某物”，而不是“从某物变为某物”。 为了说明这种可能性，我给出了这个示例，下面我们将考虑基本版本（在该版本上我们实现互斥体）。 <br><br> 这是wait_on_futex_value函数代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_on_futex_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAIT, val, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno != EAGAIN) { perror(<span class="hljs-string"><span class="hljs-string">"futex"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*futex_addr == val) { <span class="hljs-comment"><span class="hljs-comment">//    return; } } else { abort(); } } }</span></span></code> </pre> <br> 该函数的主要任务（实际上是futex系统调用之外）是一个循环，当我们唤醒false（对我们不感兴趣）时，我们将在该循环中运行。 如果在共享内存插槽中安装了新值，但我们没有期望，则会发生这种情况。 好吧，或者在另一个进程比我们的进程更早唤醒的情况下（这在我们的特定情况下不会发生，但是以更一般的方式是可能的）。 <br><br>  Futex语义非常棘手！ 如果futex地址处的值不等于传递的参数val，则FUTEX_WAIT调用将立即返回。 在我们的情况下，如果子进程去等待，而父进程在插槽中写入值0xA，则可能会发生这种情况。 在这种情况下，futex返回值EAGAIN。 <br><br> 这是wake_futex_blocking函数代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake_futex_blocking</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAKE, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"futex wake"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }</code> </pre> <br> 这是FUTEX_WAKE的阻塞包装器，无论有多少侦听器期望它，它都将快速计算并返回一个值。 在我们的示例中，这被用作“握手”的一部分，但其他用途也是可能的。 <br><br><h3>  Futex是自定义代码的内核队列。 </h3><br> 简而言之，futex是内核驱动的队列，用于解决自定义代码任务。 它允许用户代码请求内核挂起其线程的执行直到事件发生，并同时通知另一个线程该事件并唤醒所有等待该事件的线程。 前面我们提到了在用户模式下组织自旋锁的功能，可以等待某些条件得到满足。 但是，内核中的队列是更好的选择，因为它使我们免于在等待循环中执行的数十亿浪费的处理器指令。 <br><br> 这是有关LWN的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ A Futex概述和更新”中</a>的图表： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/476/433/d4e/476433d4e5a9ba7dcd840a7fe5eb3d87.png" alt="图片"><br><br> 在Linux内核代码中，futex是在kernel / futex.c文件中实现的。 内核存储一个哈希表，其中的键是地址，以便快速找到所需的队列并将调用过程添加到其中。 当然，一切都不是那么简单-毕竟，内核本身需要同步对内部数据的访问，并支持futeksov的各种其他选项。 <br><br><h3> 限时等待FUTEX_WAIT </h3><br>  futex系统调用具有超时参数，该参数允许用户指定准备等待多长时间。 这是一个实现的完整<a href="">示例</a> ，但这是关键部分： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child waiting for A\n"</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class"> = {</span></span>.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>, .tv_nsec = <span class="hljs-number"><span class="hljs-number">500000000</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> t1 = time_ns(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(shared_data, FUTEX_WAIT, <span class="hljs-number"><span class="hljs-number">0xA</span></span>, &amp;timeout, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child woken up rc=%d errno=%s, elapsed=%llu\n"</span></span>, futex_rc, futex_rc ? strerror(errno) : <span class="hljs-string"><span class="hljs-string">""</span></span>, time_ns() - t1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; *shared_data == <span class="hljs-number"><span class="hljs-number">0xA</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br> 如果等待被延迟了500毫秒，那么futex函数将结束，在循环的下一个迭代中，我们可以对此做出反应（在屏幕上显示某些内容，写入日志，继续等待或停止）。 <br><br><h3> 使用futex实现互斥 </h3><br> 我们从以下事实开始本文：futex在实现更高级别的同步对象中具有实际用途。 让我们尝试使用它们（以及原子）来实现经典的互斥体。 下面的实现基于Ulrich Drepper撰写的文章“ Futexes are Tricky”中的代码。 <br><br> 对于此示例，我使用C ++，主要是为了使用C ++ 11标准中的原子。 您可以在<a href="">此处</a>找到完整的代码，但最重要的部分是： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() : atom_(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = cmpxchg(&amp;atom_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If the lock was previously unlocked, there's nothing else for us to do. // Otherwise, we'll probably have to wait. if (c != 0) { do { // If the mutex is locked, we signal that we're waiting by setting the // atom to 2. A shortcut checks is it's 2 already and avoids the atomic // operation in this case. if (c == 2 || cmpxchg(&amp;atom_, 1, 2) != 0) { // Here we have to actually sleep, because the mutex is actually // locked. Note that it's not necessary to loop around this syscall; // a spurious wakeup will do no harm since we only exit the do...while // loop when atom_ is indeed 0. syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAIT, 2, 0, 0, 0); } // We're here when either: // (a) the mutex was in fact unlocked (by an intervening thread). // (b) we slept waiting for the atom and were awoken. // // So we try to lock the atom again. We set teh state to 2 because we // can't be certain there's no other thread at this exact point. So we // prefer to err on the safe side. } while ((c = cmpxchg(&amp;atom_, 0, 2)) != 0); } } void unlock() { if (atom_.fetch_sub(1) != 1) { atom_.store(0); syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAKE, 1, 0, 0, 0); } } private: // 0 means unlocked // 1 means locked, no waiters // 2 means locked, there are waiters in lock() std::atomic&lt;int&gt; atom_; };</span></span></code> </pre><br> 在此代码中，cmpxhg函数是一个简单的包装器，可更方便地使用原子： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An atomic_compare_exchange wrapper with semantics expected by the paper's // mutex - return the old value stored in the atom. int cmpxchg(std::atomic&lt;int&gt;* atom, int expected, int desired) { int* ep = &amp;expected; std::atomic_compare_exchange_strong(atom, ep, desired); return *ep; }</span></span></code> </pre> <br> 此代码示例包含许多解释其操作逻辑的注释。 这不会造成伤害，因为存在很大的风险，您可能会想要编写一个稍微简单但完全不正确的版本。 至于此代码-并不是所有代码都完美。 例如，他尝试对std :: atomic类型的内部设备进行假设，将其内容转换为int *，以传递给futex调用。 通常情况并非如此。 该代码可以在Linux x64上编译并运行，但是我们不能保证与其他平台的兼容性。 为了获得它，我们需要为原子添加一个平台依赖层。 由于这不是本文的主题（并且因为您不太可能在同一个C ++模块中混合使用futex），因此我们将省略此实现。 这只是一个示范！ <br><br><h3>  Glibc互斥锁和低级锁 </h3><br> 因此，我们到了glibc实现POSIX线程的地步，其中一部分是pthread_mutex_t类型。 正如我在本文开头所说的那样，futex并不是普通开发人员所需要的。 它们由运行时库或非常专门用于实现更高级别的同步原语的东西使用。 在这种情况下，查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NPTL</a>互斥锁的实现很有趣。 在glibc代码中，这是nptl / pthread_mutex_lock.c文件。 <br><br> 由于需要支持各种类型的互斥锁，因此代码非常复杂，但是如果需要，我们可以找到非常熟悉的块。 您还可以查看sysdeps / unix / sysv / linux / x86_64 / lowlevellock.h和nptl / lowlevellock.c文件。 该代码有些混乱，但是比较交换和futex调用的组合仍然很容易。 <br><br> 您应该已经很好地理解了systeds /nptl/lowlevellock.h文件的初始注释： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Low-level locks use a combination of atomic operations (to acquire and release lock ownership) and futex operations (to block until the state of a lock changes). A lock can be in one of three states: 0: not acquired, 1: acquired with no waiters; no other threads are blocked or about to block for changes to the lock state, &gt;1: acquired, possibly with waiters; there may be other threads blocked or about to block for changes to the lock state. We expect that the common case is an uncontended lock, so we just need to transition the lock between states 0 and 1; releasing the lock does not need to wake any other blocked threads. If the lock is contended and a thread decides to block using a futex operation, then this thread needs to first change the state to &gt;1; if this state is observed during lock release, the releasing thread will wake one of the potentially blocked threads. .. */</span></span></code> </pre> <br><h3> 去运行时futexes </h3><br>  Rantime Go不使用libc（在大多数情况下）。 因此，它不能依赖POSIX线程的实现。 而是直接调用较低级别的系统调用。 这使其成为使用futex的一个很好的例子。 由于无法调用pthread_mutex_t，因此必须编写自己的替代文件。 让我们看看如何做到这一点，让我们从对用户可见的sync.Mutex类型开始（在src / sync / mutex.go中）。 <br><br> 这种类型的Lock方法尝试使用原子交换操作来快速捕获锁。 如果事实证明您需要等待，它将调用runtime_SemacquireMutex，后者将调用runtime.lock。 该函数在src / runtime / lock_futex.go中定义，它声明了您可能熟悉的几个常量： <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( mutex_unlocked = <span class="hljs-number"><span class="hljs-number">0</span></span> mutex_locked = <span class="hljs-number"><span class="hljs-number">1</span></span> mutex_sleeping = <span class="hljs-number"><span class="hljs-number">2</span></span> ... ) <span class="hljs-comment"><span class="hljs-comment">// Possible lock states are mutex_unlocked, mutex_locked and mutex_sleeping. // mutex_sleeping means that there is presumably at least one sleeping thread.</span></span></code> </pre><br>  runtime.lock还试图使用原子函数来捕获锁。 这是有道理的，因为在Go运行时的许多地方都调用了runtime.lock，但是在我看来，通过从Mutex.lock调用runtime.lock时删除原子函数的两个连续调用，可以通过某种方式优化代码。 <br><br> 如果事实证明您需要等待，则会调用与平台相关的函数futexsleep，该函数在src / runtime / os_linux.go文件中为Linux定义。 该函数使用代码FUTEX_WAIT_PRIVATE进行futex系统调用（在这种情况下，这是合适的，因为Go运行时位于一个进程中）。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418705/">https://habr.com/ru/post/zh-CN418705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418691/index.html">牧场主：5分钟内使用裸机进行Kubernetes</a></li>
<li><a href="../zh-CN418693/index.html">为什么幸福很难在大脑中发现</a></li>
<li><a href="../zh-CN418695/index.html">反盗版战争-帝国反击</a></li>
<li><a href="../zh-CN418699/index.html">创建一个模拟器街机。 第三部分</a></li>
<li><a href="../zh-CN418701/index.html">我们研究俄语的语法分析器</a></li>
<li><a href="../zh-CN418707/index.html">KDispatcher-轻巧方便的日常事件总线</a></li>
<li><a href="../zh-CN418709/index.html">需要强迫自己：驱动程序和界面障碍</a></li>
<li><a href="../zh-CN418711/index.html">令牌管理寄存器1.0</a></li>
<li><a href="../zh-CN418713/index.html">改善维基百科质量的游戏</a></li>
<li><a href="../zh-CN418715/index.html">procfs虚拟文件系统的效率如何，并且有可能对其进行优化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>