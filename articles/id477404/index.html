<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêñ ü§òüèª üôèüèø Masalah sering membuat dan menghapus objek di C ++ üôç üßìüèº üõ§Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perusahaan tempat saya bekerja menulis sistem penyaringan lalu lintasnya sendiri dan melindungi bisnis dari serangan DDoS, bot, parser, dan banyak lag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Masalah sering membuat dan menghapus objek di C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477404/"><img src="https://habrastorage.org/webt/fb/bt/53/fbbt53apqltc7isyigy39vkizmk.jpeg" alt="gambar"><br><br>  Perusahaan tempat saya bekerja menulis sistem penyaringan lalu lintasnya sendiri dan melindungi bisnis dari serangan DDoS, bot, parser, dan banyak lagi.  Produk ini didasarkan pada proses seperti <a href="https://en.wikipedia.org/wiki/Reverse_proxy" rel="nofollow">reverse proxying</a> , dengan bantuan yang kami menganalisis volume besar lalu lintas secara real time dan, pada akhirnya, hanya memungkinkan permintaan pengguna yang sah, menyaring semua yang berbahaya. <br><br>  Fitur utama adalah bahwa layanan kami bekerja dengan lalu lintas masuk yang tidak terbatas, sehingga sangat penting untuk menggunakan semua sumber daya workstation seefisien mungkin.  Banyak pengalaman pengembangan dalam C ++ modern membantu kami dalam hal ini, termasuk standar terbaru dan seperangkat perpustakaan yang disebut Boost. <br><a name="habracut"></a><br><h3>  Membalikkan proxy </h3><br>  Mari kita kembali ke membalikkan proxy dan lihat bagaimana Anda dapat mengimplementasikannya di C ++ dan boost.asio.  Pertama-tama, kita membutuhkan dua objek yang disebut sesi server dan klien.  Sesi server membangun dan memelihara koneksi dengan browser, sesi klien membangun dan memelihara koneksi dengan layanan.  Anda juga akan memerlukan buffer aliran yang merangkum pekerjaan dengan memori di dalamnya, di mana sesi server membaca dari soket dan dari mana sesi klien menulis ke soket.  Contoh sesi server dan klien dapat ditemukan dalam dokumentasi untuk boost.asio.  Cara bekerja dengan stream buffer dapat ditemukan di sana. <br><br>  Setelah kami mengumpulkan prototipe proxy terbalik dari contoh, akan menjadi jelas bahwa aplikasi seperti itu mungkin tidak akan melayani lalu lintas masuk tanpa batas.  Kemudian kita akan mulai menambah kompleksitas kode.  Mari kita pikirkan tentang multithreading, wokers dan pool untuk konteks io, dan banyak lagi.  Secara khusus, tentang optimasi prematur terkait dengan menyalin memori antara sesi server dan klien. <br><br>  Jenis penyalinan seperti apa itu?  Faktanya adalah bahwa saat pemfilteran, lalu lintas tidak selalu dikirimkan tidak berubah.  Lihat contoh di bawah ini: di dalamnya kita menghapus satu tajuk dan menambahkan dua tajuk.  Jumlah kueri pengguna di mana tindakan serupa dilakukan meningkat dengan kompleksitas logika di dalam layanan.  Dalam kasus apa pun Anda dapat dengan sembarangan menyalin data dalam kasus seperti itu!  Jika hanya 1% dari total permintaan yang berubah, dan 99% tetap tidak berubah, maka Anda harus mengalokasikan memori baru hanya untuk 1% ini.  Ini akan membantu Anda dengan peningkatan ini :: asio :: const_buffer dan boost :: asio :: mutable_buffer, dengan bantuan yang Anda dapat mewakili beberapa blok memori terus menerus dengan satu entitas. <br><br>  Permintaan pengguna: <br><br><pre><code class="plaintext hljs">Browser -&gt; Proxy: &gt; POST / HTTP/1.1 &gt; User-Agent: curl/7.29.0 &gt; Host: 127.0.0.1:50080 &gt; Accept: */* &gt; Content-Length: 5888903 &gt; Content-Type: application/x-www-form-urlencoded &gt; ... Proxy -&gt; Service: &gt; POST / HTTP/1.1 &gt; User-Agent: curl/7.29.0 &gt; Host: 127.0.0.1:50080 &gt; Accept: */* &gt; Transfer-Encoding: chunked &gt; Content-Type: application/x-www-form-urlencoded &gt; Expect: 100-continue &gt; ... Service -&gt; Proxy: &lt; HTTP/1.1 200 OK Proxy -&gt; Browser &lt; HTTP/1.1 200 OK</code> </pre> <br><h3>  Masalah </h3><br>  Sebagai hasilnya, kami mendapat aplikasi siap pakai yang dapat mengukur dengan baik dan diberkahi dengan segala macam optimasi.  Dengan meluncurkannya dalam produksi, kami cukup senang untuk berapa lama itu bekerja dengan baik dan stabil. <br><br>  Seiring waktu, kami mulai memiliki lebih banyak pelanggan, dengan munculnya lalu lintas yang juga tumbuh.  Di beberapa titik, kami dihadapkan dengan masalah kurangnya kinerja saat memukul mundur serangan besar.  Setelah menganalisis layanan menggunakan utilitas <a href="https://perf.wiki.kernel.org/index.php/Tutorial" rel="nofollow">perf</a> , kami perhatikan bahwa semua operasi dengan heap under load ada di atas.  Kemudian kami menciptakan kembali situasi yang serupa di sirkuit uji menggunakan <a href="https://github.com/yandex/yandex-tank" rel="nofollow">yandex-tank</a> dan kartrid yang dihasilkan berdasarkan lalu lintas nyata.  Mengaitkan layanan melalui <a href="https://software.intel.com/en-us/vtune" rel="nofollow">amplifier,</a> kami melihat gambar berikut ... <br><br>  Cuplikan layar penguat (woslab): <br><br><img src="https://habrastorage.org/webt/tz/ks/d9/tzksd9oddf-rhcfphtkxkun-pdg.png"><br><br>  Dalam tangkapan layar, operator baru bekerja 67 detik, dan operator menghapus lebih banyak lagi - 97 detik. <br><br>  Situasi ini membuat kami sedih.  Bagaimana cara mengurangi waktu tinggal aplikasi di operator baru dan operator hapus?  Adalah logis bahwa ini dapat dilakukan dengan meninggalkan alokasi konstan dari objek yang sering dibuat dan dihapus di heap.  Kami menetapkan tiga pendekatan.  Dua di antaranya adalah standar: <a href="https://en.wikipedia.org/wiki/Object_pool_pattern" rel="nofollow">kumpulan objek</a> dan <a href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation" rel="nofollow">alokasi tumpukan</a> .  Sesi klien yang diatur dalam kumpulan pada tahap permulaan aplikasi ditempatkan dengan baik pada pendekatan pertama.  Pendekatan kedua digunakan di mana-mana di mana permintaan pengguna diproses dari awal hingga berakhir di tumpukan yang sama, dengan kata lain, dalam penangan konteks io yang sama.  Kami tidak akan membahas hal ini secara lebih rinci.  Sebaiknya kita bicara tentang pendekatan ketiga, sebagai pendekatan yang paling kompleks dan menarik.  Ini disebut <a href="https://en.wikipedia.org/wiki/Slab_allocation" rel="nofollow">alokasi</a> slab atau distribusi slab. <br><br>  Gagasan distribusi slab bukanlah hal baru.  Itu diciptakan dan diimplementasikan di Solaris, kemudian dimigrasi ke kernel Linux, dan terdiri dari fakta bahwa objek yang sering digunakan dari jenis yang sama lebih mudah untuk disimpan di kolam.  Kami hanya mengambil objek dari kolam ketika kami membutuhkannya, dan setelah menyelesaikan pekerjaan kami mengembalikannya.  Tidak ada panggilan ke operator baru dan operator hapus!  Apalagi minimal inisialisasi.  Dalam inti slab, distribusi digunakan untuk semaphores, deskriptor file, proses, dan utas.  Dalam kasus kami, ini jatuh dengan sempurna di sesi server dan klien, serta semua yang ada di dalamnya. <br><br>  Bagan (distribusi slab): <br><br><img src="https://habrastorage.org/webt/zb/k2/u8/zbk2u8m0jexhso3nmkttzxkvrw0.png"><br><br>  Selain fakta bahwa pengalokasi slab ada di kernel, implementasinya juga ada di ruang pengguna.  Ada beberapa dari mereka, dan mereka yang aktif berkembang umumnya sedikit.  Kami menetap di perpustakaan bernama <a href="https://github.com/tarantool/small" rel="nofollow">libsmall</a> , yang merupakan bagian dari <a href="https://github.com/tarantool/tarantool" rel="nofollow">tarantool</a> .  Ia memiliki semua yang Anda butuhkan. <br><br><ul><li>  kecil :: pengalokasi </li><li>  small :: slab_cache (utas lokal) </li><li>  small :: slab </li><li>  small :: arena </li><li>  kecil :: kuota </li></ul><br>  Struktur slab :: kecil adalah kumpulan dengan tipe objek tertentu.  Struktur small :: slab_cache adalah cache yang berisi berbagai daftar kumpulan dengan tipe objek tertentu.  Struktur small :: dialokasikan adalah kode yang memilih cache yang diperlukan, mencari kumpulan yang sesuai di dalamnya, di mana objek yang diminta didistribusikan.  Apa yang kecil :: arena dan objek kecil :: kuota lakukan akan menjadi jelas dari contoh di bawah ini. <br><br><h3>  Bungkus </h3><br>  Pustaka libsmall ditulis dalam C, bukan C ++, jadi kami harus mengembangkan beberapa pembungkus untuk integrasi transparan ke pustaka C ++ standar. <br><br><ul><li>  variti :: slab_allocator </li><li>  variti :: slab </li><li>  variti :: thread_local_slab </li><li>  variti :: slab_allocate_share </li></ul><br>  Kelas variti :: slab_allocator mengimplementasikan persyaratan minimum yang ditetapkan oleh standar saat menulis pengalokasi sendiri.  Di dalam kelas-kelas slar variti ::, semua pekerjaan dengan libsmall library dienkapsulasi.  Mengapa variti :: thread_local_slab diperlukan?  Faktanya adalah bahwa cache slab distribusi adalah objek lokal thread.  Ini berarti bahwa setiap utas memiliki set cache yang berbeda.  Ini dilakukan untuk mengurangi hingga nol jumlah operasi yang diblokir saat mendistribusikan objek baru.  Oleh karena itu, dalam memori setiap utas, kami menempatkan instance kami dari kelas variti :: slab, dan aksesnya diatur menggunakan pembungkus variti :: thread_local_slab.  Saya akan memberi tahu Anda tentang fungsi template variti :: slab_allocate_share nanti. <br><br>  Di dalam kelas variti :: slab_allocator, semuanya cukup sederhana.  Dia memiliki kemampuan untuk mengubah dari satu tipe ke tipe lainnya, misalnya, dari void ke char.  Menariknya, Anda dapat memperhatikan prevalensi nullptr dengan pengecualian std :: bad_alloc dalam kasus ketika memori habis dari slab distribusi.  Sisanya meneruskan panggilan di dalam pembungkus variti :: thread_local_slab. <br><br>  Cuplikan (slab_allocator.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab_allocator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = T; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pointer = value_type*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_pointer = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_type*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> reference = value_type&amp;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_reference = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value_type&amp;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebind</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> other = slab_allocator&lt;U&gt;; }; slab_allocator() {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; slab_allocator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> slab_allocator&lt;U&gt;&amp; other) {} <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(thread_local_slab::allocate(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) * n)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p &amp;&amp; n) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ thread_local_slab::deallocate(p, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) * n); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab_allocator</span></span></span><span class="hljs-class">&lt;void&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pointer = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_pointer = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebind</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> slab_allocator&lt;U&gt; other; }; };</code> </pre> <br>  Mari kita lihat bagaimana konstruktor dan destruktor variti :: slab diimplementasikan.  Dalam konstruktor, kami mengalokasikan total memori tidak lebih dari 1 GiB untuk semua objek.  Ukuran setiap kolam dalam wadah kami tidak melebihi 1 MiB.  Objek minimum yang dapat kita distribusikan adalah ukuran 2 byte (pada kenyataannya, libsmall akan meningkatkannya ke minimum yang diperlukan - 8 byte).  Objek yang tersisa yang tersedia melalui distribusi slab kami adalah kelipatan dari dua (ditetapkan oleh konstanta 2.f).  Total, Anda dapat mendistribusikan objek dengan ukuran 8, 16, 32, dll.  Jika objek yang diminta berukuran 24 byte, maka overhead akan muncul dari memori.  Distribusi akan mengembalikan objek ini kepada Anda, tetapi akan ditempatkan di kumpulan yang sesuai dengan objek berukuran 32 byte.  8 byte yang tersisa akan menganggur. <br><br>  Cuplikan (slab.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_to_virt_p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(p) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_to_virt_n</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virt_to_phys_p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(p) - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virt_to_phys_n</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::<span class="hljs-function"><span class="hljs-function">id&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_thread_id</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id*&gt;(p); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slab</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: slab() { small::quota_init(&amp; quota_, <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); small::slab_arena_create(&amp;arena_, &amp; quota_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>, MAP_PRIVATE); small::slab_cache_create(&amp;cache_, &amp;arena_); small::allocator_create(&amp;allocator_, &amp;cache_, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); } ~slab() { small::allocator_destroy(&amp;allocator_); small::slab_cache_destroy(&amp;cache_); small::slab_arena_destroy(&amp;arena_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_n = virt_to_phys_n(n); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_p = small::<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(&amp;allocator_, phys_n); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!phys_p) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; phys_thread_id(phys_p) = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> phys_to_virt_p(phys_p); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_p = virt_to_phys_p(<span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(p)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> phys_n = virt_to_phys_n(n); assert(phys_thread_id(phys_p) == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::get_id()); small::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(&amp;allocator_, phys_p, phys_n); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: small::quota quota_; small::slab_arena arena_; small::slab_cache cache_; small::allocator allocator_; };</code> </pre> <br>  Semua pembatasan ini berlaku untuk turunan khusus dari kelas variti :: slab.  Karena setiap utas memiliki sendiri (pikirkan utas lokal), batas total pada proses tidak akan menjadi 1 GiB, tetapi akan berbanding lurus dengan jumlah utas yang menggunakan distribusi pelat. <br><br>  Bagan (std :: utas :: id): <br><br><img src="https://habrastorage.org/webt/_8/65/jy/_865jyoyp0qqoz7-tgsgmjsc9b0.png"><br><br>  Di satu sisi, menggunakan thread lokal memungkinkan Anda untuk mempercepat pekerjaan distribusi slab dalam aplikasi multi-threaded, di sisi lain, itu memberlakukan batasan serius pada arsitektur aplikasi asinkron.  Anda harus meminta dan mengembalikan objek dalam aliran yang sama.  Melakukan ini sebagai bagian dari boost.asio terkadang sangat bermasalah.  Untuk melacak situasi yang keliru jelas, pada awal setiap objek kita menempatkan pengidentifikasi aliran di mana metode alokasi dipanggil.  Identifier ini kemudian diverifikasi dalam metode deallocate.  Helpers Phys_to_virt_p dan virt_to_phys_p membantu dalam hal ini. <br><br>  Cuplikan (thread_local_slab.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_local_slab</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; };</code> </pre> <br>  Cuplikan (thread_local_slab.cpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">thread_local</span></span> slab* slab_; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::initialize() { slab_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> slab(slab_cfg_); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::finalize() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> slab_; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* thread_local_slab::<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> slab_-&gt;<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(n); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> thread_local_slab::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { slab_-&gt;<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(p, n); }</code> </pre> <br>  Ketika kontrol atas aliran hilang (saat mentransfer objek antara konteks io yang berbeda), penunjuk pintar memungkinkan pelepasan objek yang benar.  Semua yang dia lakukan adalah mendistribusikan objek, mengingat konteks io-nya, dan kemudian membungkusnya di std :: shared_ptr dengan pembagi kustom, yang tidak segera mengembalikan objek ke distribusi, tetapi apakah itu dalam konteks io yang disimpan sebelumnya.  Ini bekerja dengan baik ketika setiap konteks io berjalan pada satu utas.  Kalau tidak, sayangnya, pendekatan ini tidak berlaku. <br><br>  Cuplikan (slab_helper.hpp): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Allocator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; slab_allocate_shared(Allocator allocator, Args... args) { T* p = allocator.allocate(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)p) T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; ptr(p, [allocator](T* p) { p-&gt;~T(); allocator.deallocate(p); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Allocator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; slab_allocate_shared(Allocator allocator, boost::asio::io_service* io, Args... args) { T* p = allocator.allocate(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)p) T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; ptr(p, [allocator, io](T* p) { io-&gt;post([allocator, p]() { p-&gt;~T(); allocator.deallocate(p); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; };</code> </pre> <br><h3>  Solusi </h3><br>  Setelah pekerjaan pembungkusan libsmall selesai, pertama-tama kami memindahkan pengalokasi chun di dalam buffer aliran ke slab.  Ini cukup mudah dilakukan.  Setelah menerima hasil positif, kami melanjutkan dan menerapkan pengalokasi slab terlebih dahulu ke buffer aliran itu sendiri, dan kemudian ke semua objek di dalam sesi server dan klien. <br><br><ul><li>  variti :: chunk </li><li>  variti :: streambuf </li><li>  variti :: server_session </li><li>  variti :: client_session </li></ul><br>  Pada saat yang sama, perlu untuk memecahkan masalah tambahan, yaitu: mentransfer objek sederhana, objek komposit, dan koleksi ke pengalokasi slab.  Dan jika tidak ada kesulitan serius dengan dua kelas objek pertama (objek komposit direduksi menjadi yang sederhana), maka ketika menerjemahkan koleksi kami mengalami kesulitan serius. <br><br><ul><li>  std :: daftar </li><li>  std :: deque </li><li>  std :: vektor </li><li>  std :: string </li><li>  std :: map </li><li>  std :: unordered_map </li></ul><br>  Salah satu batasan utama ketika bekerja dengan distribusi slab adalah bahwa jumlah objek dari tipe yang berbeda tidak boleh terlalu besar (semakin kecil, semakin baik).  Dalam konteks ini, beberapa koleksi mungkin jatuh pada konsep pengalokasi slab, sementara beberapa mungkin tidak. <br><br>  Untuk std :: list slab, pengalokasi berfungsi dengan baik.  Koleksi ini diimplementasikan secara internal menggunakan daftar tertaut, yang masing-masing elemen memiliki ukuran tetap.  Jadi, dengan penambahan data baru ke daftar std :: dalam distribusi slab, jenis objek baru tidak muncul.  Kondisi yang ditunjukkan di atas puas!  Std :: map diatur dengan cara yang sama.  Satu-satunya perbedaan adalah bahwa di dalamnya bukan daftar yang ditautkan, tetapi sebuah pohon. <br><br>  Dalam kasus std :: deque, banyak hal lebih rumit.  Koleksi ini diimplementasikan melalui blok memori yang berdekatan yang berisi pointer ke chunks.  Sementara potongan cukup akurat, std :: deque berperilaku sama dengan daftar std ::, tetapi ketika mereka berakhir, blok memori yang sama ini didistribusikan kembali.  Dari sudut pandang pengalokasi slab, setiap redistribusi memori adalah objek dengan tipe baru.  Jumlah objek yang ditambahkan ke koleksi secara langsung tergantung pada pengguna dan dapat tumbuh tanpa terkendali.  Situasi ini tidak dapat diterima, jadi kami sebelumnya membatasi ukuran std :: deque di mana dimungkinkan, atau std :: list yang disukai. <br><br>  Jika kita mengambil std :: vector dan std :: string, maka mereka masih lebih rumit.  Implementasi koleksi ini agak mirip dengan std :: deque, kecuali bahwa blok memori kontinyu tumbuh secara signifikan lebih cepat.  Kami mengganti std :: vector dan std :: string dengan std :: deque, dan dalam kasus terburuk dengan std :: list.  Ya, kami kehilangan fungsionalitas dan bahkan di suatu tempat dalam kinerja, tetapi ini memengaruhi gambaran akhir jauh lebih sedikit daripada optimisasi untuk segala sesuatu yang dikandung. <br><br>  Kami melakukan hal yang persis sama dengan std :: unordered_map, meninggalkannya demi variti yang ditulis sendiri :: flat_map diimplementasikan melalui std :: deque.  Pada saat yang sama, kami cukup meng-cache kunci yang sering digunakan dalam variabel yang terpisah, misalnya, seperti yang dilakukan dengan header permintaan http di nginx. <br><br><h3>  Kesimpulan </h3><br>  Setelah menyelesaikan transfer penuh dari server dan sesi klien ke pengalokasi slab, kami mengurangi waktu yang dihabiskan untuk bekerja dengan sekelompok lebih dari satu setengah kali. <br><br>  Cuplikan layar penguat (coldslab): <br><br><img src="https://habrastorage.org/webt/ls/yx/l_/lsyxl_b6xngl5xap-t5erwn4now.png"><br><br>  Dalam tangkapan layar, operator baru bekerja 32 detik, dan operator menghapus - 24 detik.  Pada saat ini, fungsi-fungsi lain untuk bekerja dengan heap ditambahkan: smalloc - 21 detik, mslab_alloc - 37 detik, smfree - 8 detik, mslab_free - 21 detik.  Total, 143 detik versus 161 detik. <br><br>  Tetapi pengukuran ini dilakukan segera setelah memulai layanan tanpa menginisialisasi cache dalam distribusi slab.  Setelah penembakan berulang dari tank-yandex, gambar keseluruhan membaik. <br><br>  Cuplikan layar penguat (hotslab): <br><br><img src="https://habrastorage.org/webt/gc/zj/kt/gczjkt5r8yedhniu5afswdjqk2y.png"><br><br>  Dalam tangkapan layar, operator baru bekerja 20 detik, smalloc - 16 detik, mslab_alloc - 27 detik, operator hapus - 16 detik, smfree - 7 detik, mslab_free - 17 detik.  Total 103 detik melawan 161 detik. <br><br>  Meja pengukuran: <br><br><pre> <code class="plaintext hljs"> woslab coldslab hotslab operator new 67s 32s 20s smalloc - 21s 16s mslab_alloc - 37s 27s operator delete 94s 24s 16s smfree - 8s 7s mslab_free - 21s 17s summary 161s 143s 103s</code> </pre><br>  Dalam kehidupan nyata, hasilnya harus lebih baik, karena pengalokasi slab tidak hanya memecahkan masalah alokasi memori yang lama dan membebaskan, tetapi juga mengurangi fragmentasi.  Tanpa slab, seiring waktu, pengoperasian operator baru dan operator hapus hanya akan melambat.  Dengan slab - itu akan selalu tetap pada level yang sama. <br><br>  Seperti yang dapat kita lihat, pengalokasi slab berhasil memecahkan masalah alokasi memori objek yang sering digunakan.  Perhatikan mereka jika masalah seringnya membuat dan memindahkan objek relevan untuk Anda.  Tetapi jangan lupa tentang batasan yang mereka berikan pada arsitektur aplikasi Anda!  Tidak semua objek kompleks dapat dengan mudah ditempatkan dalam distribusi slab.  Terkadang Anda harus menyerah banyak!  Nah, semakin kompleks arsitektur aplikasi Anda, semakin sering Anda harus berhati-hati mengembalikan objek ke cache yang benar dalam hal multithreading.  Ini bisa sederhana ketika Anda segera mengerjakan arsitektur aplikasi, dengan mempertimbangkan penggunaan pengalokasi slab, tetapi pasti akan menyebabkan kesulitan ketika Anda memutuskan untuk mengintegrasikannya pada tahap akhir. <br><br><h3>  Aplikasi </h3><br>  Lihat kode sumber di <a href="https://github.com/sonntex/slab-allocator" rel="nofollow">sini</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477404/">https://habr.com/ru/post/id477404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477390/index.html">Debugging keterlambatan jaringan di Kubernetes</a></li>
<li><a href="../id477392/index.html">Buka mikrofon: backend. Kami mengundang pembicara</a></li>
<li><a href="../id477396/index.html">Cara mendaftar dalam suatu kursus dan ... lanjutkan ke bagian akhir</a></li>
<li><a href="../id477400/index.html">Tentang profesi manajer produk: bagaimana mencapai yang ideal?</a></li>
<li><a href="../id477402/index.html">Menyebarkan Model Keras Deep Learning sebagai Aplikasi Web Python</a></li>
<li><a href="../id477406/index.html">Dukungan dan dukungan teknis. Riset hebat di pasar kerja dan gaji. Apa yang berubah dalam 2 tahun?</a></li>
<li><a href="../id477408/index.html">Tutorial JavaFX: Tata Letak Lanjutan</a></li>
<li><a href="../id477414/index.html">Insinyur Data - Profesi Terseksi Abad ke-21</a></li>
<li><a href="../id477416/index.html">Kapan itu berbahaya untuk hash</a></li>
<li><a href="../id477418/index.html">Pembiasan tiga sisi dalam tiga langkah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>