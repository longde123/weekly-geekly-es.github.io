<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåû üÖ±Ô∏è üêû Mengurai UICollectionViewCell üòå #‚É£ üèµÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah menonton Keynote WWDC 2019 dan mengenal SwiftUI , yang dirancang untuk mendeskripsikan secara deskriptif UI dalam kode, saya ingin berspekulas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengurai UICollectionViewCell</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455421/"><p>  Setelah menonton Keynote WWDC 2019 dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengenal SwiftUI</a> , yang dirancang untuk mendeskripsikan secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskriptif</a> UI dalam kode, saya ingin berspekulasi tentang cara mengisi piring dan koleksi secara deklaratif.  Misalnya, seperti ini: </p><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Builder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widgets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objects: Objects)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Widget</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> header = [ <span class="hljs-type"><span class="hljs-type">Spacing</span></span>(height: <span class="hljs-number"><span class="hljs-number">25</span></span>).widget, <span class="hljs-type"><span class="hljs-type">Header</span></span>(string: <span class="hljs-string"><span class="hljs-string">" "</span></span>).widget, <span class="hljs-type"><span class="hljs-type">Spacing</span></span>(height: <span class="hljs-number"><span class="hljs-number">10</span></span>, separator: .bottom).widget ] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> body = objects .flatMap({ (object: <span class="hljs-type"><span class="hljs-type">Object</span></span>) -&gt; [<span class="hljs-type"><span class="hljs-type">Widgets</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-type"><span class="hljs-type">Title</span></span>(object: object).widget, <span class="hljs-type"><span class="hljs-type">Spacing</span></span>(height: <span class="hljs-number"><span class="hljs-number">1</span></span>, separator: .bottom).widget ] }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> header + body } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> objects: [<span class="hljs-type"><span class="hljs-type">Object</span></span>] = ... <span class="hljs-type"><span class="hljs-type">Builder</span></span> .widgets(objects: objects) .bind(to: collectionView)</code> </pre> <br><p>  Dalam koleksi, ini diterjemahkan sebagai berikut: <a name="habracut"></a></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/el/r0/bp/elr0bpuqgbgcm5unfprets9_woc.png" alt="gambar"></div><p></p><br><h1 id="vvedenie">  Pendahuluan </h1><br><p>  Seperti yang Anda ketahui dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber resmi</a> : sebagian besar waktu mereka, pengembang iOS biasa menghabiskan waktu bekerja dengan tablet.  Jika kami menganggap bahwa pengembang pada proyek ini sangat kurang dan tablet tidak sederhana, maka sama sekali tidak ada waktu tersisa untuk sisa aplikasi.  Dan sesuatu perlu dilakukan dengan ini ... Solusi yang mungkin adalah dekomposisi sel. </p><br><p>  Dekomposisi sel berarti mengganti satu sel dengan beberapa sel yang lebih kecil.  Dengan penggantian ini, secara visual tidak ada yang berubah.  Sebagai contoh, pertimbangkan posting dari umpan berita VK untuk iOS.  Satu pos dapat disajikan baik sebagai sel tunggal, atau sebagai kelompok sel - <strong>primitif</strong> . </p><br><p>  Penguraian sel tidak akan selalu berhasil.  Akan sulit untuk memecah sel menjadi primitif yang memiliki bayangan atau pembulatan di semua sisi.  Dalam hal ini, sel asli akan menjadi primitif. </p><br><h1 id="plyusy-i-minusy">  Pro dan kontra </h1><br><p>  Menggunakan dekomposisi sel, tabel / koleksi mulai terdiri dari primitif yang akan sering digunakan kembali: primitif dengan teks, primitif dengan gambar, primitif dengan latar belakang, dll.  Perhitungan ketinggian primitif tunggal jauh lebih sederhana dan lebih efektif daripada sel kompleks dengan sejumlah besar negara.  Jika diinginkan, ketinggian dinamis primitif dapat dihitung atau bahkan digambar di latar belakang (misalnya, teks melalui <code>CTFramesetter</code> ). </p><br><p>  Di sisi lain, bekerja dengan data menjadi lebih rumit.  Data akan diperlukan untuk setiap primitif, dan menurut <code>IndexPath</code> primitif akan sulit untuk menentukan sel mana yang asli.  Kami harus memperkenalkan lapisan abstraksi baru atau menyelesaikan masalah ini. </p><br><p>  Anda dapat berbicara lama tentang kemungkinan pro dan kontra dari usaha ini, tetapi lebih baik untuk mencoba menggambarkan pendekatan dekomposisi sel. </p><br><h1 id="vybiraem-instrumenty">  Memilih Alat </h1><br><p>  Karena kemampuan <code>UITableView</code> terbatas, dan, seperti yang telah disebutkan, kami memiliki pelat yang agak rumit, solusi yang sesuai adalah menggunakan <code>UICollectionView</code> .  Ini tentang <code>UICollectionView</code> yang akan dibahas dalam publikasi ini. </p><br><p>  Menggunakan <code>UICollectionView</code> dihadapkan dengan situasi di mana basis <code>UICollectionViewFlowLayout</code> tidak dapat membentuk pengaturan yang diinginkan dari elemen koleksi (kami tidak memperhitungkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>UICollectionViewCompositionalLayout</code></a> baru).  Pada saat-saat seperti itu, keputusan biasanya dibuat untuk menemukan beberapa sumber terbuka <code>UICollectionViewLayout</code> .  Tetapi bahkan di antara solusi yang sudah jadi, mungkin tidak ada yang cocok, seperti, misalnya, dalam kasus halaman utama dinamis dari toko online besar atau jejaring sosial.  Kami berasumsi yang terburuk, jadi kami akan membuat <code>UICollectionViewLayout</code> universal kami sendiri. </p><br><p>  Selain kesulitan dalam memilih tata letak, Anda perlu memutuskan bagaimana koleksi akan menerima data.  Selain pendekatan yang biasa, di mana objek (paling sering <code>UIViewController</code> ) mematuhi protokol <code>UICollectionViewDataSource</code> dan menyediakan data untuk koleksi, penggunaan kerangka kerja yang didorong data semakin populer.  Perwakilan cerah dari pendekatan ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CollectionKit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IGListKit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxDataSources,</a> dan lainnya.  Penggunaan kerangka kerja semacam itu menyederhanakan pekerjaan dengan koleksi dan menyediakan kemampuan untuk menganimasikan perubahan data, karena  Algoritma difing sudah ada dalam kerangka kerja.  Untuk tujuan publikasi, kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxDataSources</a> akan dipilih. </p><br><h1 id="vidzhet-i-ego-svoystva">  Widget dan propertinya </h1><br><p>  Kami memperkenalkan struktur data perantara dan menyebutnya <strong>widget</strong> .  Kami menjelaskan properti utama yang harus dimiliki widget: </p><br><ol><li>  Widget harus mematuhi protokol yang diperlukan untuk menggunakan kerangka kerja berbasis data.  Protokol semacam itu biasanya berisi nilai yang terkait (mis. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>IdentifiableType</code></a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxDataSources</a> ) </li><li>  Seharusnya dimungkinkan untuk merakit widget untuk primitif berbeda menjadi sebuah array.  Untuk mencapai ini, widget tidak boleh memiliki nilai terkait.  Untuk tujuan ini, Anda dapat menggunakan mekanisme tipe erasure atau sesuatu seperti itu. </li><li>  Widget harus dapat menghitung ukuran primitif.  Kemudian, ketika membentuk <code>UICollectionViewLayout</code> , tetap hanya untuk memposisikan primitif dengan benar sesuai aturan yang telah ditentukan. </li><li>  Widget harus menjadi pabrik untuk <code>UICollectionViewCell</code> .  Oleh karena itu, dari implementasi <code>UICollectionViewDataSource</code> semua logika untuk membuat sel akan dihapus dan yang tersisa adalah: <br><pre> <code class="plaintext hljs">let cell = widget.widgetCell(collectionView: collectionView, indexPath: indexPath) return cell</code> </pre> </li></ol><br><h1 id="realizaciya-vidzheta">  Implementasi widget </h1><br><p>  Agar dapat menggunakan widget dengan kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxDataSources</a> , widget <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">harus mematuhi protokol</a> <code>Equatable</code> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>IdentifiableType</code></a> .  Karena widget mewakili primitif, itu akan cukup untuk keperluan penerbitan jika widget mengidentifikasi dirinya untuk mematuhi protokol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>IdentifiableType</code></a> .  Dalam praktiknya, ini akan memengaruhi fakta bahwa ketika widget berubah, primitif tidak akan dimuat ulang, tetapi dihapus dan dimasukkan.  Untuk melakukan ini, perkenalkan protokol <code>WidgetIdentifiable</code> baru: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WidgetIdentifiable</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IdentifiableType</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WidgetIdentifiable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> identity: <span class="hljs-type"><span class="hljs-type">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> } }</code> </pre> <br><p>  Untuk menyesuaikan dengan <code>WidgetIdentifiable</code> , widget harus sesuai dengan protokol <code>Hashable</code> .  Widget <code>Hashable</code> akan mengambil data untuk kepatuhan dengan protokol dari objek yang akan menggambarkan primitif tertentu.  Anda dapat menggunakan <code>AnyHashable</code> untuk "menghapus" widget jenis objek. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WidgetIdentifiable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> underlying: <span class="hljs-type"><span class="hljs-type">AnyHashable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span> underlying: <span class="hljs-type"><span class="hljs-type">AnyHashable</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.underlying = underlying } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(into hasher: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Hasher)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.underlying.hash(into: &amp;hasher) } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> ==</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: Widget, rhs: Widget)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.underlying == rhs.underlying } }</code> </pre> <br><p>  Pada tahap ini, dua properti pertama widget dijalankan.  Ini tidak sulit untuk diperiksa dengan mengumpulkan beberapa widget dengan berbagai jenis objek dalam sebuah array. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> widgets = [<span class="hljs-type"><span class="hljs-type">Widget</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello world"</span></span>), <span class="hljs-type"><span class="hljs-type">Widget</span></span>(<span class="hljs-number"><span class="hljs-number">100500</span></span>)]</code> </pre> <br><p>  Untuk mengimplementasikan properti yang tersisa, kami memperkenalkan protokol baru <code>WidgetPresentable</code> </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WidgetPresentable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widgetCell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(collectionView: UICollectionView, indexPath: IndexPath)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UICollectionViewCell</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widgetSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(containerWidth: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGSize</span></span> }</code> </pre> <br><p>  Fungsi <code>widgetSize(containerWidth:)</code> akan digunakan dalam <code>UICollectionViewLayout</code> saat membuat atribut sel, dan <code>widgetCell(collectionView:indexPath:)</code> - untuk mendapatkan sel. </p><br><p>  Jika widget <code>WidgetPresentable</code> protokol <code>WidgetPresentable</code> , widget akan memenuhi semua properti yang ditunjukkan pada awal publikasi.  Namun, objek yang terdapat dalam widget AnyHashable harus diganti dengan komposisi <code>WidgetPresentable</code> dan <code>WidgetHashable</code> , di mana <code>WidgetHashable</code> tidak akan memiliki nilai terkait (seperti dalam kasus <code>Hashable</code> ) dan jenis objek di dalam widget akan tetap "dihapus": </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WidgetHashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widgetEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> any: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widgetHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(into hasher: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Hasher)</span></span></span></span> }</code> </pre> <br><p>  Di versi final, widget akan terlihat seperti ini: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WidgetIdentifiable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> underlying: <span class="hljs-type"><span class="hljs-type">WidgetHashable</span></span> &amp; <span class="hljs-type"><span class="hljs-type">WidgetPresentable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span> underlying: <span class="hljs-type"><span class="hljs-type">WidgetHashable</span></span> &amp; <span class="hljs-type"><span class="hljs-type">WidgetPresentable</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.underlying = underlying } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(into hasher: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Hasher)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.underlying.widgetHash(into: &amp;hasher) } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> ==</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lhs: Widget, rhs: Widget)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.underlying.widgetEqual(rhs.underlying) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WidgetPresentable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widgetCell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(collectionView: UICollectionView, indexPath: IndexPath)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UICollectionViewCell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> underlying.widgetCell(collectionView: collectionView, indexPath: indexPath) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widgetSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(containerWidth: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> underlying.widgetSize(containerWidth: containerWidth) } }</code> </pre> <br><h1 id="obekt-primitiva">  Objek primitif </h1><br><p>  Mari kita coba merakit primitif paling sederhana, yang akan menjadi lekukan dari ketinggian yang diberikan. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Spacing</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> height: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpacingView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> constraint = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.heightAnchor.constraint(equalToConstant: <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: .zero) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.constraint.isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Spacing</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WidgetHashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widgetEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> any: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> spacing = any <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Spacing</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> == spacing } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widgetHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(into hasher: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Hasher)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.hash(into: &amp;hasher) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Spacing</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WidgetPresentable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widgetCell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(collectionView: UICollectionView, indexPath: IndexPath)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UICollectionViewCell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell: <span class="hljs-type"><span class="hljs-type">WidgetCell</span></span>&lt;<span class="hljs-type"><span class="hljs-type">SpacingView</span></span>&gt; = collectionView.cellDequeueSafely(indexPath: indexPath) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cell.view == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { cell.view = <span class="hljs-type"><span class="hljs-type">SpacingView</span></span>() } cell.view?.constraint.constant = height <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widgetSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(containerWidth: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGSize</span></span>(width: containerWidth, height: height) } }</code> </pre> <br><p>  <code>WidgetCell&lt;T&gt;</code> hanyalah subkelas dari <code>UICollectionViewCell</code> yang menerima <code>UIView</code> dan menambahkannya sebagai subview.  <code>cellDequeueSafely(indexPath:)</code> adalah fungsi yang mendaftarkan sel dalam koleksi sebelum digunakan kembali jika sel dalam koleksi sebelumnya belum terdaftar.  <code>Spacing</code> akan digunakan seperti yang dijelaskan di awal publikasi. </p><br><p>  Setelah menerima array widget, tetap hanya untuk mengikat <code>observerWidgets</code> : </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">DataSource</span></span> = <span class="hljs-type"><span class="hljs-type">RxCollectionViewSectionedAnimatedDataSource</span></span>&lt;<span class="hljs-type"><span class="hljs-type">WidgetSection</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataSource: <span class="hljs-type"><span class="hljs-type">DataSource</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.makeDataSource() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observerWidgets: (<span class="hljs-type"><span class="hljs-type">Observable</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Widgets</span></span>&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Disposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collectionView.rx.items(dataSource: dataSource) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeDataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DataSource</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">DataSource</span></span>(configureCell: { (<span class="hljs-number"><span class="hljs-number">_</span></span>, collectionView: <span class="hljs-type"><span class="hljs-type">UICollectionView</span></span>, indexPath: <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>, widget: <span class="hljs-type"><span class="hljs-type">Widget</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = widget.widgetCell(collectionView: collectionView, indexPath: indexPath) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell }) } }</code> </pre> <br><h1 id="rezultaty">  Hasil </h1><br><p>  Sebagai kesimpulan, saya ingin menunjukkan karya nyata dari koleksi, yang dibangun sepenuhnya di atas widget. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_t/od/tz/_todtzto-dqfqf1nwto9pik694c.gif" alt="gambar"></div><br><p>  Seperti yang Anda lihat, dekomposisi <code>UICollectionViewCell</code> layak dan dalam situasi yang sesuai dapat menyederhanakan kehidupan pengembang. </p><br><h1 id="zamechaniya">  Komentar </h1><br><p>  Kode yang diberikan dalam publikasi sangat disederhanakan dan tidak boleh dikompilasi.  Tujuannya adalah untuk menggambarkan pendekatan, bukan untuk menyediakan solusi turnkey. </p><br><p>  Protokol <code>WidgetPresentable</code> dapat diperluas dengan fungsi lain yang mengoptimalkan tata letak, misalnya, <code>widgetSizeEstimated(containerWidth:)</code> atau <code>widgetSizePredefined(containerWidth:)</code> , yang masing-masing mengembalikan estimasi dan ukuran tetap.  Perlu dicatat bahwa fungsi <code>widgetSize(containerWidth:)</code> harus mengembalikan ukuran primitif bahkan untuk perhitungan yang menuntut, misalnya, untuk <code>systemLayoutSizeFitting(_:)</code> .  Perhitungan seperti itu dapat di-cache melalui <code>Dictionary</code> , <code>NSCache</code> , dll. </p><br><p>  Seperti yang Anda ketahui, semua jenis sel yang digunakan oleh <code>UICollectionView</code> harus didaftarkan sebelumnya dalam koleksi.  Namun, untuk menggunakan kembali widget di antara berbagai layar / koleksi dan tidak mendaftarkan semua pengenal / jenis sel terlebih dahulu, Anda perlu memperoleh mekanisme yang akan mendaftarkan sel segera sebelum digunakan pertama kali dalam setiap koleksi.  Dalam publikasi, fungsi <code>cellDequeueSafely(indexPath:)</code> digunakan untuk ini. </p><br><p>  Tidak ada header atau footer dalam koleksi.  Di tempat mereka akan menjadi primitif.  Kehadiran pelengkap dalam koleksi tidak akan memberikan bonus khusus dalam pendekatan saat ini.  Biasanya mereka digunakan ketika array data secara ketat sesuai dengan jumlah sel dan diperlukan untuk menampilkan tampilan tambahan sebelum, setelah atau di antara sel.  Dalam kasus kami, data untuk tampilan tambahan juga dapat ditambahkan ke larik widget dan digambarkan sebagai primitif. </p><br><p>  Dalam koleksi yang sama, widget dengan objek yang sama dapat ditemukan.  Misalnya, <code>Spacing</code> sama di awal dan di akhir koleksi.  Kehadiran objek non-unik tersebut akan mengarah pada kenyataan bahwa animasi dalam koleksi menghilang.  Untuk membuat objek tersebut unik, Anda dapat menggunakan tag <code>AnyHashable</code> khusus, <code>#file</code> dan <code>#file</code> tempat objek itu dibuat, dll. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455421/">https://habr.com/ru/post/id455421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455407/index.html">Mobil listrik dan puncak penjualan mobil bahan bakar</a></li>
<li><a href="../id455409/index.html">Kompatibilitas mundur</a></li>
<li><a href="../id455411/index.html">Megaphone melakukan pembaruan teknis ... nama jaringan</a></li>
<li><a href="../id455413/index.html">Ubah Pocket menjadi Umpan Berita</a></li>
<li><a href="../id455419/index.html">Apple Beta Alive: Trivia Tidak Terungkap Saat Presentasi</a></li>
<li><a href="../id455425/index.html">Membuat terowongan IPSec GRE antara Mikrotik hEX S dan Juniper SRX melalui USB Modem</a></li>
<li><a href="../id455427/index.html">Bagaimana kami belajar memprediksi permintaan pengguna dan mempercepat pemuatan hasil pencarian</a></li>
<li><a href="../id455429/index.html">Bagaimana Doom masuk Super Nintendo</a></li>
<li><a href="../id455439/index.html">Algoritma baru yang dibuat oleh para ilmuwan memungkinkan Anda untuk membuat "kepala bicara" yang hampir sempurna dengan orang-orang nyata</a></li>
<li><a href="../id455441/index.html">21 Juni, Moskow, Deworkacy - Menganalisis Pertemuan # 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>