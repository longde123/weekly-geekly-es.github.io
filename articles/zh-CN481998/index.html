<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏻 🤦🏿 🌌 图灵机，作为自动机程序的模型 🐱 🧑🏻‍🤝‍🧑🏻 💋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="图灵机，作为自动机程序的模型 
 1.简介 
 编程需要新的通用算法模型，并且硬件不仅以不同的形式实现算法，而且还基于另一种算法模型-自动实现算法。 从硬件开发领域采用技术是自动化编程的关键思想。 但是，数字设备的合成与编程不同。 但是，一方面借用一个模型，不建议对其进行实质性的更改，但是另一方面，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>图灵机，作为自动机程序的模型</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481998/"><h2> 图灵机，作为自动机程序的模型 </h2><br><h3>  1.简介 </h3><br> 编程需要新的通用算法模型，并且硬件不仅以不同的形式实现算法，而且还基于另一种算法模型-自动实现算法。 从硬件开发领域采用技术是自动化编程的关键思想。 但是，数字设备的合成与编程不同。 但是，一方面借用一个模型，不建议对其进行实质性的更改，但是另一方面，不能忽视现有的编程理论和实践。 <br><br> 接下来，我们将考虑用于设计自动化程序的SWITCH技术，您将在其中始终遇到这样的过程。 一方面，它极大地改变了状态机模型，从而使它实际上超出了自动机理论的范围。 另一方面，它引入了编程人员难以理解的编程概念，并且有时只是多余的，因为 在程序理论和编程实践中有更多熟悉的对应对象。 <br><br> 作为讨论自动编程问题的基础，我们采用了A. Shalyto最近的演讲  [1]及其关于“自动编程”范式定义的“编程”文章[2，3]。 <br><a name="habracut"></a><br>  <b>1.自动化的对象，程序方案</b> <br><br> 在讲座中，自动编程的成就是借鉴了自动控制理论（TAU），引入了自动控制对象的概念。 但是，回想一下，在TAU中，它们考虑的对象不是太多，而是系统，其中包括以下几个方面[4]： <br><br><img src="https://habrastorage.org/webt/zx/3w/k7/zx3wk7apg6vumkx6wkrhhorjrpg.jpeg" alt="图片"><br><br> 基于此，谈论自动控制系统（ACS）会更正确。 现在让我们看一下图2所示的自行火炮的典型功能图。  1.如果将图灵机的磁带视为控制对象，则执行设备（IS）将成为实现磁带内容变化并移动磁头的MT元素，而测量设备（IS）将成为从磁带中读取信息的元素。 <br><br><img src="https://habrastorage.org/webt/mt/ns/y5/mtnsy5l-h2msdra8jmld6l_mn5i.jpeg" alt="图片"><br>  <i>图1。</i>  <i>自行火炮功能图</i> <br><br> 但是，如果有一种更接近计算机系统设计编程的实践，那么为什么要转向TAU，在这种实践中，当然包括MT的操作设备（OS）被视为操作（OA）和控制（UA）机器的组合。 而且，这更接近我们最终要努力实现的目标-证明自动编程的力量。 在图。 图2示出了Mayorov S.A.，Novikov G.I.的专着的文本屏幕。 电子计算机的结构[5]，其中详细讨论了运算放大器的设计问题。 <br><br><img src="https://habrastorage.org/webt/fv/14/en/fv14ens27xhjytujiwia279csxq.jpeg" alt="图片"><br>  <i>图2。</i>  <i>管理器和操作机的概念</i> <br><br> 但是，如果我们将计算机设计理论与程序理论进行比较，则可以在它们之间找到明显的结构类比。 在编程理论中，任何程序在结构级别上的模型都可以表示为程序方案S =（M，A，C），其中M是存储元素集，A是运算符集，C是控件[10]。 按照这种方法，任何图灵机程序也可以定义为一种程序方案，其中M组由带单元表示，操作员组由与1）单元分析，2）改变带单元中的字符和3）移动磁头相关的MT动作表示。 <br><br> 因此，程序方案的概念与所考虑的操作和控制自动机的概念完全相似，其中UA的模型是下面考虑的结构有限状态机（SKA）的模型，而OA“是对信息执行操作的结构”。 在这种情况下，OA包括数据存储元素（在内存之上）和用于处理信息的块，这些信息实现逻辑条件的计算和某些动作的实现（在许多运算符之上）。 <br><br> 从前述内容可以理解，磁带只能在条件上被认为是MT的控制对象。 仅由于图灵机的控制设备无法直接访问它，因为 所有与单元的操作都通过OA块间接实现。 另外，似乎不太熟悉，或者，如果不说，将其表示为程序（管理）的目标，作为控制系统，将代表存储器（磁带）的对象视为奇怪的事情。 <br> 因此，对于图灵机的正式定义，以及在它的上下文中有限状态机模型的地位，程序论的概念就足够了。 现在，与SWITCH技术框架中对自动机程序非常模糊的定义相反，我们可以说自动机程序是一种具有有限状态机模型形式的控制的程序。 <br><br> 程序本身是什么-具有简单或复杂的行为，具有逻辑控制，“具有显式状态分配”的“多样性”是什么，等等。 等 并不绝对重要。 最主要的是管理类型。 程序的其余元素可以在很宽的范围内确定-从最简单的图灵机到最复杂的任何形式的编程语言的运算符，函数和数据结构-汇编程序，高级语言等。 <br><br> 您还可以记得，图灵机长期以来一直被视为自动垫[6]，或者在极端情况下被认为是其简单的扩展[7]。 但是您需要了解它是什么类型的自动机，它是什么样的扩展以及它们是否等效于经典有限状态机的模型。 让我们尝试澄清一下。 <br><br>  <b>2.在自动编程环境中进行图灵编程</b> <br><br> 在图。 图3显示了专着[8]中MT增量函数的自动机。 从形式上讲，这显然不是MT程序，但已经不是经典的有限状态机。 在图。 图4显示了经典结构有限状态机（SKA）及其在VKPa环境（在Qt库和Qt Creator环境中使用C ++的可视组件自动编程环境）中的实现的图，该结构实现了相同的MT控制单元算法。 <br><br><img src="https://habrastorage.org/webt/6n/xv/rn/6nxvrne_9pugaykk9zhfxekzvju.jpeg" alt="图片"><br>  <i>图3。</i>  <i>使用图灵机增加单位数量</i> <br><br><img src="https://habrastorage.org/webt/iq/fx/d2/iqfxd2lsiammfthsrdqcl3bkneo.jpeg" alt="图片"><br>  <i>图4 SKA形式的MT增量程序模型</i> <br><br> 您会看到结构机器具有四个输入通道和五个输出通道。 这些通道中的每一个都与一个具有相同名称的程序功能相关联-谓词或动作。 在这里，谓词是没有参数的函数，这些函数根据正在查看的磁带单元的值返回布尔值，而动作是没有参数的函数，它们执行一个或另一个操作来更改磁带单元并移动图灵机的头部。 <br><br> 此SKA具有与图3中的自动机相同的状态集。 此外，除了SKA提供的自动机映射本身之外，它还实现了另外两个映射：将谓词集（x1，...，xM）映射到同一台机器的输入通道集，并将机器的输出通道集映射到许多相似的动作-y1，...，yN。 例如，如果当前单元格中存在1，则谓词x3将返回true（相同名称的输入信号的值为1），并且当机器的相同输出信号取值为1时触发的动作y4对应于将磁头向左移动（L），并且等 等 <br><br> 请注意，SKA并不直接控制磁带，而是执行[附加]映射，将自动机的信号与确定Turing机器许多操作的功能联系起来。 这再次使我们确信，在“老式”但数学上严格的映射概念已足够的情况下，无需引入自动控制对象的概念。 <br><br> 比较图中的自动机。  3和图。 如图4所示，可以看出SKA没有使用“ *”命令（见图1）。 在这种情况下，他不发出与该命令相关的信号就足够了。 另外，在相同转换处的两个或多个信号（输入和输出）是并行的。 因此，当访问共享对象有冲突时（例如，您需要更改单元格并移动磁头），将使用一种协议：对一个过渡的操作按其编号顺序依次执行。 在编号较小的动作之后执行编号较大的动作。 该协议不适用于谓词，因为 他们不更换磁带。 因此，我们使机器更紧凑，更直观（无需引入中间状态）。 <br><br> 在测试增量程序的过程中，确定了MT操作期间可能出现问题的情况。 首先，真正的磁带不是无限的，超出范围可能导致程序崩溃。 其次，有必要指出头部的初始位置。 如果没有此功能，例如，如果数字位于磁带的任意位置，并且磁头的初始状态位于数字的左侧且与空间相对，则磁头将立即开始向左移动。 然后它可能会超出磁带的边界，导致程序“崩溃”，或者向左移动了一步，它将写入单元格1，并挂起，将完成“成功”操作。 或者，如果该数字在所有位中都包含1，并且是从磁带的开头写入的，则将数字1转移到高位数字的最终尝试将导致相同的“崩溃”。 <br><br>  <b>2.1。</b>  <b>C ++中MT的对象实现</b> <br><br> 考虑在VKPa环境中使用C ++的图灵机的目标软件实现，该图实现了MT的任何程序，包括增量计算程序。 <br><br> 为此，创建了一个代表任何Turing机器的基类，该基类由实现一个或另一个MT程序的软件对象继承。 清单1中显示了这一基本步骤，清单2中显示了实现增量任务的程序。 <br><br> 清单1. MT基类的软件实现 <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lfsaappl.h"</span></span></span><span class="hljs-meta"> class FTuringMashine : public LFsaAppl { public: FTuringMashine(string strNam, CVarFsaLibrary *pCVFL, LArc* pTBL); protected: int x15(); int x16(); void y14(); void y15(); void y16(); void y17(); QString strSrc; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    QString strTape; //  QString strHead; //  int nIndexHead{0}; //   bool bRestart{false}; //   int nHeadPosition{0}; //    }; #include "stdafx.h" #include "FTuringMashine.h" FTuringMashine::FTuringMashine(string strNam, CVarFsaLibrary *pCVFL, LArc* pTBL): LFsaAppl(pTBL, strNam, nullptr, pCVFL) { nHeadPosition = 0; strHead = "________________________________________"; nIndexHead = nHeadPosition; } //============================================================== //  //  ? int FTuringMashine::x15() { return strTape[nIndexHead] == '#'; } // ? int FTuringMashine::x16() { return bRestart; } //============================================================== //  //      void FTuringMashine::y14() { strTape[nIndexHead] = '#'; } //    ( ) void FTuringMashine::y15() { nIndexHead++; } //    ( ) void FTuringMashine::y16() { nIndexHead--; } //     void FTuringMashine::y17() { strTape = strSrc; nIndexHead = 0; bRestart = false; nIndexHead = nHeadPosition; }</span></span></span></span></code> </pre> <br> 清单2.图灵机的增量程序 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTuringMashine.h"</span></span></span><span class="hljs-meta"> class FTIncrement : public FTuringMashine { public: LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTIncrement(nameFsa, pCVarFsaLibrary); } FTIncrement(string strNam, CVarFsaLibrary *pCVFL); protected: int x1(); int x2(); int x3(); void y1(); void y2(); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTIncrement.h"</span></span></span><span class="hljs-meta"> static LArc TBL_TIncrement[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// . . , .   , 2- , 2011 ., // .17-18 //=====    (. ..   , - .: , 2003. - 208 .) ============== // f(,^` `) = (,`*`,R) // f(,` `) = (,` `,L) // f(,`1`) = (,`0`,L) // f(,` `) = (,`1`,R) // f(,`0`) = (,`1`,R) //========================================= LArc(" ", " ", "^x1", "y15"), LArc(" ", " ", "x1", "y16"), LArc(" ", " ", "x2", "y2y16"), LArc(" ", "", "x1", "y1"), LArc(" ", "", "x3", "y1"), LArc("", " ", "x16", "y17"), LArc() }; FTIncrement::FTIncrement(string strNam, CVarFsaLibrary *pCVFL): FTuringMashine(strNam, pCVFL, TBL_TIncrement) { strSrc = "11011110011111 "; strTape = strSrc; } //  int FTIncrement::x1() { return strTape[nIndexHead] == ' '; } int FTIncrement::x2() { return strTape[nIndexHead] == '1'; } int FTIncrement::x3() { return strTape[nIndexHead] == '0'; } //  void FTIncrement::y1() { strTape[nIndexHead] = '1'; } void FTIncrement::y2() { strTape[nIndexHead] = '0'; }</span></span></span></span></code> </pre><br>  <b>2.2。</b>  <b>使用C ++实现MT的程序示例</b> <br><br> 考虑一个MT程序的示例，该程序“充当语言的接受者，即 它可以从[9]中识别语言。 其过渡函数如图2所示。 图5中的SKA形式的等效自动机。  6。 <br><br><pre> <code class="plaintext hljs">δ(1, a) = (2, x, R) δ(1, y) = (4, y, R) δ(2, a) = (2, a, R) δ(2, y) = (2, y, R) δ(2, b) = (3, y, L) δ(3, y) = (3, y, L) δ(3, a) = (3, a, R) δ(3, x) = (1, x, R) δ(4, y) = (4, a, R) δ(4, #) = (F, #, L)</code> </pre> <br>  <i>图</i>  <i>5.图灵机的转换功能，可以识别语言{anbn：n≥1}</i> <br><br><img src="https://habrastorage.org/webt/z9/ab/hl/z9abhlvacupxhkbuzbfbupsmikq.jpeg" alt="图片"><br>  <i>图</i>  <i>6.识别语言{anbn：n≥1}的图灵机的SKA图</i> <br><br>  SKA形式的MT控制单元具有6个输入通道和7个输出通道。 接受程序还包括相应数量的谓词和动作，这些谓词和动作在自动机图右侧的图中显示。 清单3显示了VKPA环境中C ++程序的实现。 <br><br> 清单3.识别语言的图灵机程序{anbn：n≥1} <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTuringMashine.h"</span></span></span><span class="hljs-meta"> extern LArc TBL_TAcceptor[]; class FTAcceptor : public FTuringMashine { public: LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTAcceptor(nameFsa, pCVarFsaLibrary); } FTAcceptor(string strNam, CVarFsaLibrary *pCVFL, LArc* pTB = TBL_TAcceptor); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y2(); void y3(); void y18(); int nState{1}; friend class CDlgTAcceptor; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTAcceptor.h"</span></span></span><span class="hljs-meta"> LArc TBL_TAcceptor[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// . .Ma  .   . 2013 ., //     , .304 //=====    ============== // f(1,a) = (2,x,R) f(1,y) = (4,y,R) // f(2,a) = (2,x,R) f(2,y) = (2,y,R) // f(2,b) = (2,x,R) f(3,y) = (3,y,L) // f(3,a) = (3,a,R) f(3,x) = (1,x,R) // f(4,y) = (4,a,R) f(4,#) = (F,#,L) //========================================= LArc("1", "2","x1", "y1y15"), // 1,a,2,x,R LArc("1", "4","x3", "y15"), // 1,y,4,R LArc("2", "2","x1", "y15"), // 2,a,2,R LArc("2", "3","x2", "y2y16"), // 2,b,3,y,L LArc("2", "2","x3", "y15"), // 2,y,2,R LArc("3", "3","x1", "y16"), // 3,a,3,L LArc("3", "3","x3", "y16"), // 3,y,3,L LArc("3", "1","x4", "y15"), // 3,x,1,R LArc("4", "4","x3", "y2y15"), // 4,y,4,a,R LArc("4", "F","x15", "-"), // 4,#,F,-,- LArc("F", "1","x16", "y17"), // LArc("1", "1","x16", "y17"), // LArc("2", "1","x16", "y17"), // LArc("3", "1","x16", "y17"), // LArc("4", "1","x16", "y17"), // // LArc("1", "1","--", "y18"), // LArc() }; FTAcceptor::FTAcceptor(string strNam, CVarFsaLibrary *pCVFL, LArc* pTB): FTuringMashine(strNam, pCVFL, pTB) { strSrc = "aaaaaaaaaabbbbbbbbbb#"; strTape = strSrc; } int FTAcceptor::x1() { return strTape[nIndexHead] == 'a'; } int FTAcceptor::x2() { return strTape[nIndexHead] == 'b'; } int FTAcceptor::x3() { return strTape[nIndexHead] == 'y'; } int FTAcceptor::x4() { return strTape[nIndexHead] == 'x'; } void FTAcceptor::y1() { strTape[nIndexHead] = 'x'; } void FTAcceptor::y2() { strTape[nIndexHead] = 'y'; } void FTAcceptor::y3() { strTape[nIndexHead] = 'a'; } void FTAcceptor::y18() { switch(nState) { case 1: if (x1()) { nState = 2; y1(); y5(); break; } if (x3()) { nState = 4; y5(); break; } break; case 2: if (x1()) { nState = 2; y5(); break; } if (x2()) { nState = 3; y2();y6(); break; } if (x3()) { nState = 2; y5(); break; } break; case 3: if (x1()) { nState = 3; y6(); break; } if (x3()) { nState = 3; y6(); break; } if (x4()) { nState = 1; y5(); break; } break; case 4: if (x3()) { nState = 4; y2(); y5(); break; } if (x5()) { nState = 5; break; } break; case 5: if (x6()) { y7(); nState = 1; break; } break; } }</span></span></span></span></code> </pre><br> 在清单3中，动作y18表示根据SWITCH技术方法的MT程序的变体。 在这种情况下，作为VKPA环境自动编程实现的一部分，代替了图1中的自动机。 在图6中，有必要实现具有一种状态的自动机，其在循环中发出信号y18。 它对应于清单3中转换表的注释掉的行。为了使自动机充当SWICH，您需要从该行中删除注释并注释掉其余行。 <br><br> 考虑来自[7]的图灵机程序的另一个示例，其中MT被定义为“有限状态机模型的非常简单的扩展”。 在这种情况下，用于图灵机的程序是过渡的部分定义函数的五分之一的有限列表，并输出δ：S×X→S×X×G。 <br><br>  MT程序找到两个数的最大公约数（GCD），如图2所示。 图7给出了与其等效的SKA图。  8.请注意，此处也未使用重写命令。 清单4显示了C ++实现。 <br><br><img src="https://habrastorage.org/webt/ce/zf/s_/cezfs_layjwqcyzmvo0vhqupkwk.jpeg" alt="图片"><br>  <i>图</i>  <i>7.图灵机的过渡图，该图计算两个数字的GCD，以及在处理一对数字&lt;4，6&gt;时的几种配置</i> <i><br></i> <br><img src="https://habrastorage.org/webt/_p/ai/vl/_paivlzhwtehlewnthhkcrpndba.jpeg" alt="图片"><br>  <i>图</i>  <i>8. SKA图，等效于图7中的图。</i>  <i>7</i> <br><br> 清单4.图灵机的程序，用于查找两个数字的GCD <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTuringMashine.h"</span></span></span><span class="hljs-meta"> class FTGrCmDiv: public FTuringMashine { public: LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTGrCmDiv(nameFsa, pCVarFsaLibrary); } FTGrCmDiv(string strNam, CVarFsaLibrary *pCVFL); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y2(); void y3(); void y17(); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTGrCmDiv.h"</span></span></span><span class="hljs-meta"> static LArc TBL_TGrCmDiv[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//=====     (Greatest Common Divider) ============== // . ..   , - .: , 2003. - 208 . // .194 // .  ..    . .:  , 1974, - 200. // .76, 84-87 LArc("s","s","x1", "y16"), // LArc("s","s","x2", "y16"), // LArc("s","p","x3", "y1"), // LArc("s","r","x15", "y15"), // LArc("p","p","x1", "y15"), // LArc("p","p","x2", "y15"), // LArc("p","s","x3", "y2"), // LArc("p","q","x15", "y16"), // LArc("q","q","x1", "y3y16"), // LArc("q","q","x2", "y14y16"), // LArc("q","s","x3", "y15"), // LArc("q","s","x15", "y15"), // LArc("r","r","x1", "y14y15"), // LArc("r","r","x2", "y3y15"), // LArc("r","s","x3", "y16"), // LArc("r","!","x15", "--"), // LArc("!","s","x16", "y17"), // LArc() }; FTGrCmDiv::FTGrCmDiv(string strNam, CVarFsaLibrary *pCVFL): FTuringMashine(strNam, pCVFL, TBL_TGrCmDiv) { nHeadPosition = 4; strSrc = "#1111111111## "; strTape = strSrc; nIndexHead = nHeadPosition; } int FTGrCmDiv::x1() { return strTape[nIndexHead] == 'a'; } int FTGrCmDiv::x2() { return strTape[nIndexHead] == 'b'; } int FTGrCmDiv::x3() { return strTape[nIndexHead] == '1'; } int FTGrCmDiv::x4() { return strTape[nIndexHead] == '#'; } void FTGrCmDiv::y1() { strTape[nIndexHead] = 'a'; } void FTGrCmDiv::y2() { strTape[nIndexHead] = 'b'; } void FTGrCmDiv::y3() { strTape[nIndexHead] = '1'; } void FTGrCmDiv::y17() { strTape = strSrc; nIndexHead = 4; bRestart = false; nIndexHead = nHeadPosition; }</span></span></span></span></code> </pre><br> 总之，文章[11]中考虑了SWITH技术开发商的另一个MT程序，该程序提出了识别两个版本中括号的任务。 一种是麦莉机器的形式，另一种是混合机器的形式（分别在图9和图11中）。 对应于它们的结构自动机如图2所示。  10和图。  12.清单5显示了C ++程序的实现。 <br><br><img src="https://habrastorage.org/webt/z4/uk/_t/z4uk_t3un74er2osfmikfgmrhni.jpeg" alt="图片"><br>  <i>图</i>  <i>9.识别任意深度的括号。</i>  <i>英里换算图</i> <br><br><img src="https://habrastorage.org/webt/is/s6/mg/iss6mgjxclciek9s1az1t70oomg.jpeg" alt="图片"><br>  <i>图</i>  <i>10.识别任意深度的括号。</i>  <i>伯爵SKA Miles</i> <br><br><img src="https://habrastorage.org/webt/dp/xy/_k/dpxy_kpzxw59qwy2tu0_c_fhpz8.jpeg" alt="图片"><br>  <i>图</i>  <i>11.识别任意深度的括号。</i>  <i>混合自动机的过渡图</i> <br><br><img src="https://habrastorage.org/webt/un/ju/2h/unju2hogmmbwqr1zs4rnaxolbj4.jpeg" alt="图片"><br>  <i>图</i>  <i>12.识别任意深度的括号。</i>  <i>混合自动机过渡的SCA图</i> <br><br> 清单5.用于识别括号的图灵机程序 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../FTuringMashine.h"</span></span></span><span class="hljs-meta"> class FTListing2 : public FTuringMashine { public: void MooreAction(); LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTListing2(nameFsa, pCVarFsaLibrary); } FTListing2(string strNam, CVarFsaLibrary *pCVFL); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y2(); void y3(); void y4(); void y5(); int i{0}; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTListing2.h"</span></span></span><span class="hljs-meta"> static LArc TBL_TListing2[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// .  ..,  ..     , , №2, .144-149 //=====    (. ..   , - .: , 2003. - 208 .) ============== // f(,^` `) = (,`*`,R) // f(,` `) = (,` `,L) // f(,`1`) = (,`0`,L) // f(,` `) = (,`1`,R) // f(,`0`) = (,`1`,R) //========================================= /* //  LArc("0", "1", "x2", "y2"), // '(';  LArc("0", "3", "x3", "--"), // '('; LArc("1", "1", "x2", "y2"), // '(';  LArc("1", "1", "x3", "y3"), // ')';  LArc("1", "3", "^x1x4", "--"), // i!=0;' ';  LArc("1", "3", "x1x3", "--"), // i==0;')';  LArc("1", "2", "x1x4", "--"), // i==0;' ';  LArc("2", "0", "x16", "y17"), // bRestart;  LArc("3", "0", "x16", "y17"), // bRestart;  */ //* //   - LArc("0", "1", "x2", "y2"), // '(' LArc("0", "3", "x3", "--"), // ')' LArc("1", "1", "x2", "y2"), //'(';  LArc("1", "1", "x3", "y3"), // ')';  LArc("1", "2", "x1x4", "--"), // i==0;' '; LArc("1", "3", "^x1x4", "--"), // i!=0;' '; LArc("1", "3", "x1x3", "--"), // i==0;')'; LArc("2", "0", "x16", "y17"), // bRestart;  LArc("3", "0", "x16", "y17"), // bRestart;  //*/ LArc() }; FTListing2::FTListing2(string strNam, CVarFsaLibrary *pCVFL): FTuringMashine(strNam, pCVFL, TBL_TListing2) { strSrc = "(()()) "; strTape = strSrc; } //  int FTListing2::x1() { return i == 0; } int FTListing2::x2() { return strTape[nIndexHead] == '('; } // int FTListing2::x3() { return strTape[nIndexHead] == ')'; } // int FTListing2::x4() { return strTape[nIndexHead] == ' '; } // //  void FTListing2::y1() { i = 0; } // z1_0 void FTListing2::y2() { i++; } // z1_1 void FTListing2::y3() { i--; } // z1_2 void FTListing2::y4() { strTape = ""; } // z2_0 void FTListing2::y5() { strTape = ""; } // z2_1 void FTListing2::MooreAction() { string strState = FGetState(); if (strState=="0") { y1(); } //   else if (strState=="1") { y15(); } //    else if (strState=="2") { y4(); } //  else if (strState=="3") { y5(); } //  }</span></span></span></span></code> </pre><br> 由于图中的自动机  12拒绝工作，决定去图中的机器。 图9显示了与之等效的SKA形式的自动机。  10.是的，从形式上来说，这也是一个混合自动机，从第一个实现中就留下了状态为“ 0”的信号和状态为“ 1”的信号y15（图12）。 在初始安装期间，第一个是必需的，并且y15信号实现了向右的头移，以读取下一个磁带字符。  SKA的其余部分对应于图1中的Miles机器。  9。 <br><br> 在图的自动机之后。 成功测试了10个，返回到图9中的机器。  11.显然，状态为“ 1”的信号z1_1是多余的（对于图12中的自动机，它是信号y2）。 问题在于，当他找到“左括号”时，他会将计数器增加两个单位，而当他找到“左括号”时，他根本不会改变它。 因此，当检测到“左括号”时，它将被调用两次-一次在标记为x2 / y2的循环中，第二次进入该状态。 并且当检测到“右括号”时，计数器首先在循环上减少，然后在进入状态时增加。 <br><br>  MT控件进行此工作的原因是作者对摩尔型自动机功能的错误解释。 显然，他们相信只有在进入摩尔状态自动机时才执行该信号（请参见从状态“ 0”到“ 1”的转换），但实际上，每次您进入该状态时都会发出该信号。 包括经过循环时。 因此，我们不是在处理错误（谁没有记错？），而是在处理更严重的问题-在摩尔型自动机功能的SWITH技术框架内的错误解释。 测试等效模型表明了这一点。 <br><br>  <b>3.结论</b> <br><br> 总而言之，我们可以说图灵和自动编程之间没有形式上的差异，因为 图灵机是自动机程序的抽象模型。 仅在后一种情况下，将使用更多的运算符和数据结构（内存）。 现在，我们可以放心地回答邮政机器作为普通程序模型与自动程序模型图灵机有何不同的问题。 管理模式，只有它，因为 其余的-内存和运算符可以相同。 <br> 因此，普通编程与自动编程的不同之处仅在于控制模型。 因此，尽管为了实现自动机而使用开关类型的普通控制操作员而不能使用类似的操作员，但严格来说，这种编程被认为是自动的。 这可能是自动机的模仿，但失去了其特定的特性，仅此而已。 <br><br> 因此，给出自动机程序和自动机程序设计的概念的定义，我们不必讨论“自动控制对象”，而只需要讨论具有经典有限状态机形式的控制的程序和程序。 <br> 我想提请注意的另一个有趣的事实。 在2000年代初，作者表达了他们对自动编程的理解，为广大读者所接受。 他们关于抽象机的文章发表在PC World杂志2002年第2期中[11，12，13]。 可以说，岁月并没有影响双方的信念。 虽然，也许这仅反映了他们对所选决策的信心程度。 <br><br> 例如，在“关于自动编程的新讲座”中，A。Shalyto 与之前的“带幻灯片的讲座”（十年前）相比，仅添加了基于“最新程序包” Stateflow的示例视频。 看来这证实了A. Shalyto观点的正确性，因为  Stateflow的开发者在UniMod中无法实现的功能（该项目似乎被“冻结”了）。 而且，可能是谁做的不是那么重要... <br><br> 但是，在发布上述文章时，SWITCH技术的作者已经知道对此有所批评。 这不是秘密，因为 它可以在SoftCraft网站上找到[14]。 它还创建了专门针对自动编程的部分，特别是SWITH技术，尤其是KA技术。 在网站的论坛上讨论了作者的立场（当时该论坛是开放的）。 但是，所有人仍然不服气。 <br><br> 目前的结果如下。 曾经对SWITH技术表达的批评是相关和最新的。 它也适用于Stateflow程序包。 在SWITH技术中，没有自动编程，也没有明确的定义，自动机的实现方法没有改变，模型本身不是经典的，没有并行计算模型，等等。 等 在不消除这些问题的情况下，这种自动编程充其量只能发挥有限的作用。 <br><br> 上面提到的问题的原因很明显：尽管对自动机本身及其奇妙的特性说了许多好的和正确的话，但程序理论却被忽略了，自动机理论也被遗忘了。 但是实际上这些是其他机器。 作者深信创建原始模型的构思不当的可疑性。 它涉及同步，无功和其他模型。 当解决一小类问题时，它们很方便，仅此而已。 但是更严重的是，他们没有自己的理论就脱离了自动机理论。 但是理论之外的模型是无助的，因此实际上是毫无意义的。 <br><br><div class="spoiler">  <b class="spoiler_title">参考文献</b> <div class="spoiler_text">  1. Shalyto A. A.关于自动编程的新讲座。  2019年，[电子资源]，访问模式： <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">www.youtube.com/watch?v=PPWTxceMutk&amp;feature=youtu.be</a> ，免费。 亚兹 俄文  （治疗日期2019年12月5日）。 <br>  2. Shalyto A.A. 自动编程的范式。 圣彼得堡国立信息技术，机械和光学大学的科学技术通报。 卷  53.自动编程。  2008年，第  3-23。 <br>  3. Shalyto A.A. 自动编程的范式。 第十一届全俄科学和高等教育会议论文集“技术大学的基础研究与创新”。  SPbSPU。  2007，p。  202–205。，[电子资源]，访问模式： <a href="http://is.ifmo.ru/works/_2007_09_27_shalyto.pdf" rel="nofollow">is.ifmo.ru/works/_2007_09_27_shalyto.pdf</a> ，免费。 亚兹 俄文  （治疗日期2019年12月5日）。 <br>  4. Miroshnik I.V. 自动控制理论。 线性系统。  -圣彼得堡：彼得（Peter），2005年-336羽。 <br>  5. Mayorov S.A.，Novikov G.I. 电子计算机的结构。  -L .：《工程学》，1979年。-384页。 <br>  6. Minsky M.计算和自动机。  M .:米尔（Mir），1971年-364羽。 <br>  7. Karpov Yu.G. 自动机理论。  -圣彼得堡：彼得，2003年。-208页。 <br>  8. Polikarpova N.，A。Shalyto A.自动机编程。 圣彼得堡第二版。：彼得，2011年-176页 <br>  9. J. MacConell算法分析。 主动学习方法。 第三版。  -M。：技术圈，2013。-415羽 <br>  10.多处理器计算系统的算法，软件和体系结构。  M.：Nauka，1982，- 336s。 <br>  11. Shalyto A.A.，Tukkel N.I. 从图灵编程到自动// MirPK。  2号  <a href="http://is.ifmo.ru/%3Fi0%3Dworks%26i1%3Dturing" rel="nofollow">is.ifmo.ru/?i0=works&amp;i1=turing</a> <br>  12.柳比琴科诉 在抽象机器上进行实验。  “ PC World”，第2/3/02期。  <a href="https://www.osp.ru/pcworld/2002/03/163137/" rel="nofollow">www.osp.ru/pcworld/2002/02/162923，www.osp.ru/pcworld/2002/03/163137</a> <br>  13.柳布琴科诉 从图灵机到麦莉汽车。  “ PC World”，第8/02号。  <a href="http://www.osp.ru/pcworld/2002/08/163856/" rel="nofollow">www.osp.ru/pcworld/2002/08/163856</a> <br>  14. SoftCraft网站。 在编程中使用自动机理论。  [电子资源]，访问方式： <a href="http://www.softcraft.ru/auto/" rel="nofollow">www.softcraft.ru/auto</a> ，免费。 亚兹 俄文  （治疗日期2019年12月5日）。 <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481998/">https://habr.com/ru/post/zh-CN481998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481980/index.html">我们如何在Unity中优化脚本</a></li>
<li><a href="../zh-CN481988/index.html">为什么Koji是新手KaiOS应用创建者的理想资源</a></li>
<li><a href="../zh-CN481990/index.html">恶意软件十年：2010年最大的僵尸网络</a></li>
<li><a href="../zh-CN481992/index.html">Tekton管道-Kubernetes原生管道</a></li>
<li><a href="../zh-CN481996/index.html">周末哈布拉侦探2。新水平</a></li>
<li><a href="../zh-CN482000/index.html">你喜欢你的生意吗？</a></li>
<li><a href="../zh-CN482002/index.html">编写微服务博客-第3部分“用户”</a></li>
<li><a href="../zh-CN482004/index.html">我们在VPS服务器上测试1C</a></li>
<li><a href="../zh-CN482008/index.html">乐高积木和绝对零</a></li>
<li><a href="../zh-CN482010/index.html">“新史诗”。 对于开发人员，操作人员和好奇的人</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>