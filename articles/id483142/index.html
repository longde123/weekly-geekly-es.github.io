<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤œ ğŸ§¡ ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿ Porting Quake 3 ke Rust ğŸ» ğŸ˜¢ ğŸ¤ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tim kami Immunant menyukai Rust dan secara aktif bekerja pada C2Rust, sebuah kerangka kerja migrasi yang menangani seluruh rutinitas migrasi ke Rust. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Porting Quake 3 ke Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483142/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2c/61d/a4f/d2c61da4f8dfcdfb39d9fbd7787070a4.png"></div><br>  Tim kami Immunant menyukai Rust dan secara aktif bekerja pada C2Rust, sebuah kerangka kerja migrasi yang menangani seluruh rutinitas migrasi ke Rust.  Kami berusaha untuk secara otomatis memperkenalkan peningkatan keamanan dalam kode Rust yang dikonversi dan membantu programmer melakukannya sendiri ketika framework gagal.  Namun, pertama-tama, kita perlu membuat penerjemah yang andal yang memungkinkan pengguna untuk memulai dengan Rust.  Pengujian pada program CLI kecil perlahan-lahan menjadi usang, jadi kami memutuskan untuk mentransfer Quake 3 ke Rust. Setelah beberapa hari, kami kemungkinan besar adalah orang pertama yang memainkan Quake3 on Rust! <br><br><h2>  Persiapan: Gempa 3 sumber </h2><br>  Setelah mempelajari kode sumber dari Quake 3 asli dan berbagai fork, kami memutuskan <a href="https://ioquake3.org/">ioquake3</a> .  Ini adalah garpu Quake 3 yang dibuat komunitas, yang masih didukung dan dibangun di atas platform modern. <br><a name="habracut"></a><br>  Sebagai titik awal, kami memutuskan untuk memastikan bahwa kami dapat mengumpulkan proyek dalam bentuk aslinya: <br><br><pre><code class="bash hljs">$ make release</code> </pre> <br>  Saat membuat ioquake3, beberapa perpustakaan dan file yang dapat dieksekusi dibuat: <br><br><pre> <code class="bash hljs">$ tree --prune -I missionpack -P <span class="hljs-string"><span class="hljs-string">"*.so|*x86_64"</span></span> . â””â”€â”€ build â””â”€â”€ debug-linux-x86_64 â”œâ”€â”€ baseq3 â”‚ â”œâ”€â”€ cgamex86_64.so <span class="hljs-comment"><span class="hljs-comment"># client â”‚ â”œâ”€â”€ qagamex86_64.so # game server â”‚ â””â”€â”€ uix86_64.so # ui â”œâ”€â”€ ioq3ded.x86_64 # dedicated server binary â”œâ”€â”€ ioquake3.x86_64 # main binary â”œâ”€â”€ renderer_opengl1_x86_64.so # opengl1 renderer â””â”€â”€ renderer_opengl2_x86_64.so # opengl2 renderer</span></span></code> </pre> <br>  Di antara pustaka ini, pustaka UI, klien, dan server dapat dikompilasi baik sebagai rakitan <a href="https://fabiensanglard.net/quake3/qvm.php">VM Quake</a> , atau sebagai pustaka bersama X86 asli.  Dalam proyek kami, kami memutuskan untuk menggunakan versi asli.  Menerjemahkan VM ke Rust dan menggunakan versi QVM akan jauh lebih mudah, tetapi kami ingin menguji C2Rust secara menyeluruh. <br><br>  Dalam proyek transfer kami, kami fokus pada UI, game, klien, renderer OpenGL1, dan executable utama.  Kami juga dapat menerjemahkan renderer OpenGL2, tetapi kami memutuskan untuk melewati ini karena menggunakan sejumlah besar <code>.glsl</code> shader, yang <code>.glsl</code> sistem pembangunan sebagai string literal dalam kode sumber C. Setelah kompilasi, kami akan menambahkan dukungan untuk skrip build untuk embedding Kode GLSL menjadi string Rust, tetapi masih belum ada cara otomatis yang baik untuk memindahkan file sementara yang dihasilkan secara otomatis ini.  Jadi sebagai gantinya, kami hanya menerjemahkan perpustakaan renderer OpenGL1 dan memaksa game untuk menggunakannya sebagai ganti renderer default.  Selain itu, kami memutuskan untuk melewati server khusus dan file misi yang dikemas, karena mereka tidak akan sulit untuk ditransfer dan tidak diperlukan untuk demonstrasi kami. <br><br><h2>  Geser Transpos 3 </h2><br>  Untuk melestarikan struktur direktori yang digunakan dalam Quake 3 dan tidak mengubah kode sumber, kami perlu mendapatkan file biner yang persis sama seperti dalam perakitan asli, yaitu empat pustaka bersama dan satu dieksekusi. <br><br>  Karena C2Rust membuat file rakitan Cargo, masing-masing biner membutuhkan <code>Cargo.toml</code> file <code>Cargo.toml</code> sesuai. <br><br>  Agar C2Rust membuat satu peti untuk setiap keluaran biner, ia juga akan memerlukan daftar file biner dengan objek atau file sumber yang sesuai, serta panggilan tautan yang digunakan untuk membuat setiap file biner (digunakan untuk menentukan detail lain, misalnya, dependensi perpustakaan). <br><br>  Namun, kami dengan cepat menemukan satu batasan yang disebabkan oleh cara C2Rust mencegat proses build asli: C2Rust menerima file <a href="https://sarcasm.github.io/notes/dev/compilation-database.html">database kompilasi</a> pada input yang berisi daftar perintah kompilasi yang dijalankan selama build.  Namun, database ini <strong>hanya</strong> berisi perintah kompilasi tanpa panggilan tautan.  Sebagian besar alat yang membuat database ini memiliki batasan yang disengaja ini, misalnya <code>cmake</code> dengan <code>CMAKE_EXPORT_COMPILE_COMMANDS</code> , <code>bear</code> and <code>compiledb</code> .  Dalam pengalaman kami, satu-satunya alat yang mencakup perintah <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> adalah <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> dibuat oleh <code>CodeChecker</code> , yang tidak kami gunakan karena kami mempelajarinya hanya setelah menulis pembungkus kami sendiri (mereka dijelaskan di bawah).  Ini berarti bahwa untuk mengkompilasi program C dengan beberapa file biner, kami tidak dapat menggunakan file <code>compile_commands.json</code> dibuat oleh salah satu alat umum. <br><br>  Oleh karena itu, kami menulis skrip pembungkus <a href="https://github.com/immunant/c2rust/blob/master/scripts/cc-wrappers/cc">kompilator</a> dan <a href="https://github.com/immunant/c2rust/blob/master/scripts/cc-wrappers/ld">penghubung</a> kami sendiri yang membuang semua panggilan ke kompiler dan penghubung ke basis data, dan kemudian mengonversinya ke <code>compile_commands.json</code> diperluas.  Alih-alih perakitan biasa menggunakan perintah seperti: <br><br><pre> <code class="bash hljs">$ make release</code> </pre> <br>  kami menambahkan pembungkus untuk mencegat perakitan dengan: <br><br><pre> <code class="bash hljs">$ make release CC=/path/to/C2Rust/scripts/cc-wrappers/cc</code> </pre> <br>  Wrappers membuat direktori beberapa file JSON, satu per panggilan.  <a href="https://github.com/immunant/c2rust/blob/master/scripts/convert_build_commands.py">Skrip</a> kedua mengumpulkan semuanya menjadi satu file <code>compile_commands.json</code> baru, yang berisi perintah kompilasi dan kompilasi.  Kemudian kami memperluas C2Rust sehingga membaca perintah build dari database dan membuat kotak terpisah untuk setiap biner yang ditautkan.  Selain itu, C2Rust sekarang juga membaca dependensi pustaka untuk setiap file biner dan secara otomatis menambahkannya ke file <code>build.rs</code> dari peti yang sesuai. <br><br>  Untuk meningkatkan kenyamanan, semua binari dapat dikumpulkan sekaligus dengan menempatkannya di dalam <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">ruang kerja</a> .  C2Rust menciptakan file <code>Cargo.toml</code> ruang kerja tingkat <code>Cargo.toml</code> , sehingga kita dapat membangun proyek dengan satu-satunya <code>cargo build</code> di direktori <code>quake3-rs</code> : <br><br><pre> <code class="bash hljs">$ tree -L 1 . â”œâ”€â”€ Cargo.lock â”œâ”€â”€ Cargo.toml â”œâ”€â”€ cgamex86_64 â”œâ”€â”€ ioquake3 â”œâ”€â”€ qagamex86_64 â”œâ”€â”€ renderer_opengl1_x86_64 â”œâ”€â”€ rust-toolchain â””â”€â”€ uix86_64 $ cargo build --release</code> </pre> <br><h2>  Hilangkan kekasaran </h2><br>  Ketika kami pertama kali mencoba untuk mengkompilasi kode yang diterjemahkan, kami mengalami beberapa masalah dengan sumber-sumber Quake 3: ada kasus batas yang tidak bisa ditangani oleh C2Rust (baik dengan benar, maupun tidak sama sekali). <br><br><h3>  Array pointer </h3><br>  Beberapa tempat dalam kode sumber asli berisi ekspresi yang mengarah ke elemen berikutnya setelah elemen array terakhir.  Berikut adalah contoh kode C yang disederhanakan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p; <span class="hljs-comment"><span class="hljs-comment">// ... if (p &gt;= &amp;array[1024]) { // error... }</span></span></code> </pre> <br>  Standar C (lihat, misalnya, <a href="http://www.iso-9899.info/n1570.html">C11, Bagian 6.5.6</a> ) memungkinkan pointer ke elemen melampaui akhir array.  Namun, Rust melarang ini, bahkan jika kita hanya mengambil alamat elemen.  Kami menemukan contoh pola seperti itu di fungsi <a href=""><code>AAS_TraceClientBBox</code></a> . <br><br>  Compiler Rust juga memberi tanda yang mirip, tetapi contohnya sebenarnya <a href=""><code>G_TryPushingEntity</code></a> di <a href=""><code>G_TryPushingEntity</code></a> , di mana instruksi kondisional adalah dalam bentuk <code>&gt;</code> , bukan <code>&gt;=</code> .  Pointer yang keluar dari batas kemudian direferensikan setelah membangun kondisional, yang merupakan bug keamanan memori. <br><br>  Untuk menghindari masalah ini di masa mendatang, kami memperbaiki transpiler C2Rust sehingga menggunakan aritmatika pointer untuk menghitung alamat elemen array, daripada menggunakan operasi pengindeksan array.  Berkat perbaikan ini, kode yang menggunakan pola serupa "elemen alamat di akhir array" sekarang diterjemahkan dengan benar dan dieksekusi tanpa modifikasi. <br><br><h3>  Elemen Array Panjang Variabel </h3><br>  Kami meluncurkan game untuk menguji segalanya, dan segera panik dari Rust: <br><br><pre> <code class="cpp hljs">thread <span class="hljs-string"><span class="hljs-string">'main'</span></span> panicked at <span class="hljs-string"><span class="hljs-string">'index out of bounds: the len is 4 but the index is 4'</span></span>, quake3-client/src/cm_polylib.rs:<span class="hljs-number"><span class="hljs-number">973</span></span>:<span class="hljs-number"><span class="hljs-number">17</span></span></code> </pre> <br>  Melihat <code>cm_polylib.c</code> , kami perhatikan bahwa ia meringkas bidang <code>p</code> dalam struktur berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numpoints; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> p[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// variable sized } winding_t;</span></span></code> </pre> <br>  Bidang <code>p</code> dalam struktur adalah versi anggota array fleksibel yang tidak didukung oleh standar C99, tetapi masih diterima oleh <code>gcc</code> .  C2Rust mengenali elemen array panjang variabel dengan sintaks C99 ( <code>vec3_t p[]</code> ) dan mengimplementasikan <a href="">heuristik</a> sederhana untuk juga mengidentifikasi versi dari pola ini sebelum C99 (array ukuran 0 dan 1 pada akhir struktur; kami juga menemukan beberapa contoh dalam kode sumber ioquake3). <br><br>  <a href="https://github.com/immunant/ioq3/commit/ace1fae43e736613544c8d33cc69dee794f5124a">Mengubah</a> struktur di atas ke sintaksis C99 menghilangkan panik: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numpoints; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> p[]; <span class="hljs-comment"><span class="hljs-comment">// variable sized } winding_t;</span></span></code> </pre> <br>  Upaya untuk memperbaiki pola ini secara otomatis dalam kasus umum (dengan ukuran array berbeda dari 0 dan 1) akan sangat sulit, karena kita harus membedakan antara array biasa dan elemen array panjang variabel ukuran arbitrer.  Karenanya, sebagai gantinya, kami menyarankan Anda memperbaiki kode C asli secara manual, seperti yang kami lakukan dengan ioquake3. <br><br><h3>  Operan Terikat dalam kode assembler inline </h3><br>  Sumber crash lainnya adalah kode assembler C-assembler ini dari header sistem <code>/usr/include/bits/select.h</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __FD_ZERO(fdsp) \ do { \ int __d0, __d1; \ __asm__ __volatile__ (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cld; rep; "</span></span></span><span class="hljs-meta"> __FD_ZERO_STOS \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=c"</span></span></span><span class="hljs-meta"> (__d0), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=D"</span></span></span><span class="hljs-meta"> (__d1) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta"> (0), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"0"</span></span></span><span class="hljs-meta"> (sizeof (fd_set) \ / sizeof (__fd_mask)), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1"</span></span></span><span class="hljs-meta"> (&amp;__FDS_BITS (fdsp)[0]) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"memory"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  mendefinisikan versi internal makro <code>__FD_ZERO</code> .  Definisi ini memunculkan kasus batas langka <code>gcc</code> : <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">operand I / O terikat</a> dengan ukuran berbeda.  Operator output <code>"=D" (__d1)</code> mengikat register <code>edi</code> ke variabel <code>__d1</code> sebagai nilai 32-bit, dan <code>"1" (&amp;__FDS_BITS (fdsp)[0])</code> mengikat register yang sama ke alamat <code>fdsp-&gt;fds_bits</code> sebagai pointer 64-bit.  <code>gcc</code> dan <code>clang</code> menyelesaikan ketidakcocokan ini.  menggunakan register <code>__d1</code> 64-bit dan memotong nilainya sebelum menetapkan nilai <code>__d1</code> , dan Rust menggunakan semantik LLVM secara default, di mana kasus seperti itu tetap tidak ditentukan.  Di build debug (bukan di rilis, yang berperilaku baik), kami melihat bahwa kedua operan dapat ditugaskan ke register <code>edi</code> , karena pointer dipotong ke 32 bit sebelum kode assembler built-in, yang menyebabkan kegagalan. <br><br>  Karena <code>rustc</code> meneruskan kode assembler Rust bawaan ke LLVM dengan sedikit perubahan, kami memutuskan untuk memperbaiki kasus khusus ini di C2Rust.  Kami telah mengimplementasikan <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> peti baru yang <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> masalah ini berkat sistem tipe Rust yang menggunakan fungsi <a href="">trait</a> dan helper yang secara otomatis memperluas dan memotong operand yang diikat ke ukuran internal yang cukup besar untuk menampung kedua operan.  Kode di atas diterjemahkan dengan benar sebagai berikut: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> __d0: c_int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> __d1: c_int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Reference to the output value of the first operand let fresh5 = &amp;mut __d0; // The internal storage for the first tied operand let fresh6; // Reference to the output value of the second operand let fresh7 = &amp;mut __d1; // The internal storage for the second tied operand let fresh8; // Input value of the first operand let fresh9 = (::std::mem::size_of::&lt;fd_set&gt;() as c_ulong).wrapping_div(::std::mem::size_of::&lt;__fd_mask&gt;() as c_ulong); // Input value of the second operand let fresh10 = &amp;mut *fdset.__fds_bits.as_mut_ptr().offset(0) as *mut __fd_mask; asm!("cld; rep; stosq" : "={cx}" (fresh6), "={di}" (fresh8) : "{ax}" (0), // Cast the input operands into the internal storage type // with optional zero- or sign-extension "0" (AsmCast::cast_in(fresh5, fresh9)), "1" (AsmCast::cast_in(fresh7, fresh10)) : "memory" : "volatile"); // Cast the operands out (types are inferred) with truncation AsmCast::cast_out(fresh5, fresh9, fresh6); AsmCast::cast_out(fresh7, fresh10, fresh8);</span></span></code> </pre> <br>  Perlu dicatat bahwa kode ini tidak memerlukan tipe apa pun untuk nilai input dan output dalam perakitan kode assembler; ketika menyelesaikan konflik tipe, sebaliknya mengandalkan mereka untuk output tipe Rust (terutama tipe <code>fresh6</code> dan <code>fresh8</code> ). <br><br><h3>  Variabel Global yang Diselaraskan </h3><br>  Sumber kegagalan yang terakhir adalah variabel global berikut yang menyimpan konstanta SSE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ssemask[<span class="hljs-number"><span class="hljs-number">16</span></span>] __attribute__((aligned(<span class="hljs-number"><span class="hljs-number">16</span></span>))) = { <span class="hljs-string"><span class="hljs-string">"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x00\x00\x00\x00"</span></span> };</code> </pre> <br>  Karat saat ini mendukung atribut pelurusan untuk tipe struktural, tetapi tidak untuk variabel global, mis.  elemen <code>static</code> .  Kami mempertimbangkan cara untuk memecahkan masalah ini dalam kasus umum, baik di Rust atau di C2Rust, tetapi untuk sekarang di ioquake3 kami memutuskan untuk memperbaikinya secara manual dengan file <a href="https://github.com/immunant/ioq3/blob/master/asm-snapvector.patch">tambalan</a> pendek.  File tambalan ini menggantikan yang setara <code>ssemask</code> Rust <code>ssemask</code> berikut ini: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C, align(16))]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SseMask</span></span></span></span>([<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">16</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ssemask: SseMask = SseMask([ <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ]);</code> </pre> <br><h2>  Menjalankan quake3-rs </h2><br>  Ketika <code>cargo build --release</code> , binari dibuat, tetapi mereka dibuat di bawah <code>target/release</code> dengan struktur direktori yang biner <code>ioquake3</code> tidak dikenali.  Kami menulis <a href="">skrip</a> yang membuat tautan simbolis di direktori saat ini untuk membuat ulang struktur direktori yang benar (termasuk tautan ke file <code>.pk3</code> berisi sumber daya game): <br><br><pre> <code class="bash hljs">$ /path/to/make_quake3_rs_links.sh /path/to/quake3-rs/target/release /path/to/paks</code> </pre> <br>  Path <code>/path/to/paks</code> harus menunjuk ke direktori yang berisi file <code>.pk3</code> . <br><br>  Sekarang mari kita jalankan gamenya!  Kita perlu melewatkan <code>+set vm_game 0</code> , dll, jadi kita memuat modul-modul ini sebagai pustaka bersama Rust, dan bukan sebagai rakitan QVM, serta <code>cl_renderer</code> untuk menggunakan renderer OpenGL1. <br><br><pre> <code class="bash hljs">$ ./ioquake3 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> sv_pure 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_game 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_cgame 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_ui 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> cl_renderer <span class="hljs-string"><span class="hljs-string">"opengl1"</span></span></code> </pre> <br>  Dan ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18e/fb3/94c/18efb394c9f33f6a1cbe78503a25bb4c.png"></div><br>  Kami meluncurkan Quake3 di Rust! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2c/61d/a4f/d2c61da4f8dfcdfb39d9fbd7787070a4.png"></div><br>  Berikut ini adalah video tentang bagaimana kami mentransposisikan Quake 3, mengunduh game dan memainkannya: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lQjvSJLDXW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Anda dapat mempelajari <a href="https://github.com/immunant/ioq3/tree/transpiled/quake3-rs">sumber-sumber</a> yang <code>transpiled</code> cabang yang <code>transpiled</code> dari repositori kami.  Juga ada cabang <code>refactored</code> berisi <a href="https://github.com/immunant/ioq3/tree/refactored/quake3-rs">sumber yang</a> sama dengan beberapa <a href="https://github.com/immunant/ioq3/blob/transpiled/refactor_commands.txt">perintah refactoring yang sudah</a> diterapkan sebelumnya. <br><br><h2>  Bagaimana cara mengubah posisi </h2><br>  Jika Anda ingin mencoba mengubah posisi Quake 3 dan menjalankannya sendiri, maka perlu diingat bahwa Anda akan membutuhkan sumber daya permainan Quake 3 Anda sendiri atau sumber daya demo dari Internet.  Anda juga perlu menginstal C2Rust (pada saat penulisan, versi nightly yang diperlukan adalah <code>nightly-2019-12-05</code> , tetapi kami menyarankan Anda melihat ke <a href="https://github.com/immunant/c2rust">dalam repositori</a> C2Rust atau di <a href="https://crates.io/crates/c2rust">crates.io</a> untuk menemukan versi terbaru): <br><br><pre> <code class="bash hljs">$ cargo +nightly-2019-12-05 install c2rust</code> </pre> <br>  dan salinan repositori C2Rust dan ioquake3 kami: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> &lt;a href=<span class="hljs-string"><span class="hljs-string">"/cdn-cgi/l/email-protection"</span></span> class=<span class="hljs-string"><span class="hljs-string">"__cf_email__"</span></span> data-cfemail=<span class="hljs-string"><span class="hljs-string">"dcbbb5a89cbbb5a8b4a9bef2bfb3b1"</span></span>&gt;[email protected]&lt;/a&gt;:immunant/c2rust.git $ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> &lt;a href=<span class="hljs-string"><span class="hljs-string">"/cdn-cgi/l/email-protection"</span></span> class=<span class="hljs-string"><span class="hljs-string">"__cf_email__"</span></span> data-cfemail=<span class="hljs-string"><span class="hljs-string">"dcbbb5a89cbbb5a8b4a9bef2bfb3b1"</span></span>&gt;[email protected]&lt;/a&gt;:immunant/ioq3.git</code> </pre> <br>  Sebagai alternatif untuk menginstal <code>c2rust</code> menggunakan perintah di atas, Anda dapat membangun C2Rust secara manual menggunakan <code>cargo build --release</code> .  Bagaimanapun, repositori C2Rust akan tetap diperlukan, karena berisi skrip wrapper kompiler yang diperlukan untuk mengubah ioquake3. <br><br>  Kami telah memposting <a href="">skrip</a> yang secara otomatis mengangkut kode C dan menerapkan tambalan <code>ssemask</code> .  Untuk menggunakannya, jalankan perintah berikut dari tingkat atas repositori <code>ioq3</code> : <br><br><pre> <code class="bash hljs">$ ./transpile.sh &lt;/path/to/C2Rust repository&gt; &lt;/path/to/c2rust binary&gt;</code> </pre> <br>  Perintah ini harus membuat subdirektori <code>quake3-rs</code> berisi kode Rust, yang <code>cargo build --release</code> Anda dapat menjalankan <code>cargo build --release</code> dan langkah-langkah lainnya yang dijelaskan di atas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483142/">https://habr.com/ru/post/id483142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483130/index.html">Apa yang harus dilakukan jika kode untuk mengunci koper dilupakan?</a></li>
<li><a href="../id483132/index.html">Desain dan pembuatan teleskop</a></li>
<li><a href="../id483134/index.html">Pengujian otentikasi dua faktor dan kemungkinan penyelesaiannya</a></li>
<li><a href="../id483136/index.html">Memeriksa MacBook bekas sebelum membeli - daftar periksa</a></li>
<li><a href="../id483140/index.html">Poligon Dunia Lain: Amiga 500</a></li>
<li><a href="../id483144/index.html">Ilmuwan He Jiankui adalah pahlawan, bukan penjahat</a></li>
<li><a href="../id483146/index.html">Konferensi DEFCON 27. Alat Peretasan WiFi Nirkabel Kraken</a></li>
<li><a href="../id483148/index.html">Kami membahas kembar digital dan simulasi dengan pendiri perusahaan konsultan</a></li>
<li><a href="../id483154/index.html">Saya menghabiskan $ 40 ribu dan merusak ide bagus untuk startup</a></li>
<li><a href="../id483156/index.html">Letakkan kucing di atas kakinya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>