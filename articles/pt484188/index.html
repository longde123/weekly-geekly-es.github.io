<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚫️ 🤱🏼 📤 Padrões de Design de Banco de Dados 🕺🏾 🚶🏿 🤛🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Indo de um projeto para outro, infelizmente, somos confrontados com a falta de padrões uniformes para o design de banco de dados, apesar do SQL existi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Padrões de Design de Banco de Dados</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/484188/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pa/zj/ej/pazjejv8zvpor7tzaggxr54csd4.jpeg"></div><br>  Indo de um projeto para outro, infelizmente, somos confrontados com a falta de padrões uniformes para o design de banco de dados, apesar do SQL existir há várias décadas.  Suspeito que o motivo seja em parte porque a maioria dos desenvolvedores não entende a arquitetura do banco de dados.  Ao longo dos anos de meu trabalho na contratação de desenvolvedores, só conheci várias vezes aqueles que podiam normalizar corretamente o banco de dados.  Honestamente, isso pode ser uma tarefa difícil, mas muitos dos desenvolvedores que entrevistei, mesmo fluentes em SQL, não tinham habilidades de design de banco de dados. <br><br>  Este artigo não é sobre normalização de banco de dados.  Se você quiser aprender isso, <a href="https://youtu.be/y1tcbhWLiUM">aqui</a> eu contei brevemente o básico. <br><br>  Se você possui um banco de dados em funcionamento, precisa responder à pergunta: “quais padrões podem ser aplicados para facilitar o <i>uso</i> desse banco <i>de</i> dados?”.  Se esses padrões forem amplamente utilizados, será fácil usar o banco de dados, porque você não precisará estudar e lembrar de novos conjuntos de padrões sempre que começar a trabalhar com um novo banco de dados. <br><a name="habracut"></a><br><h1>  Nomeação ou sublinhado do CamelCase? </h1><br>  Eu sempre encontro bancos de dados nos quais as tabelas são nomeadas no estilo <code>CustomerOrders</code> ou <code>customer_orders</code> .  Qual é o melhor para usar?  Talvez você queira aplicar um padrão já estabelecido, mas se estiver criando um novo banco de dados, recomendo usar sublinhados para aumentar a acessibilidade.  A frase "abaixo do valor" tem um significado diferente em comparação com "subestimar", mas com um sublinhado, o primeiro sempre será <code>under_value</code> e o segundo será <code>undervalue</code> .  E ao usar o CamelCase, obtemos <code>Undervalue</code> e <code>UnderValue</code> , que são idênticos em termos de SQL que não <code>UnderValue</code> maiúsculas de minúsculas.  Além disso, se você tiver problemas de visão e estiver constantemente experimentando fones de ouvido e pinos para enfatizar as palavras, é <i>muito</i> mais fácil ler o sublinhado. <br><br>  Finalmente, é difícil ler o CamelCase para aqueles para quem o inglês não é nativo. <br>  Para resumir, esta não é uma recomendação estrita, mas uma preferência pessoal. <br><br><h1>  Plural ou singular em nomes de tabelas? </h1><br>  Os especialistas em teoria de banco de dados vêm discutindo há muito tempo se as tabelas devem ser singulares (cliente) ou plurais (clientes).  Deixe-me cortar esse nó górdio sem aprofundar a teoria, simplesmente com a ajuda do pragmatismo: nomes de tabelas plurais têm menos probabilidade de entrar em conflito com palavras-chave reservadas. <br><br>  Você tem usuários - <code>users</code> ?  SQL tem a palavra-chave do <code>user</code> .  Você precisa de uma tabela de restrições?  <code>constraint</code> é uma palavra reservada.  A palavra <code>audit</code> <br>  reservado, mas você precisa de uma tabela de <code>audit</code> ?  Basta usar a forma <i>plural</i> de substantivos e, em seguida, a maioria das palavras reservadas não o incomodará no SQL.  Até o PostgreSQL, que possui um excelente analisador de SQL, tropeçou na tabela de <code>user</code> . <br><br>  Basta usar o plural, e a probabilidade de conflito será muito menor. <br><br><h1>  Não nomeie a coluna com o ID como "id" </h1><br>  Eu mesmo pequei ao longo dos anos.  Certa vez, trabalhei com um cliente em Paris e o DBA reclamou de mim quando dei à coluna <code>id</code> o nome <code>id</code> .  Eu pensei que ele era apenas um pedante.  De fato, o nome da coluna <code>customers.id</code> é único e <code>customers.customer_id</code> é uma repetição de informações. <br><br>  E depois tive que depurar isso: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thread.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> email <span class="hljs-keyword"><span class="hljs-keyword">thread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> email selected <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> selected.id = thread.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> recipient <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> recipient.id = thread.recipient_id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> station_area sa <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> sa.id = recipient.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> station st <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> st.id = sa.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> star origin <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> origin.id = thread.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> star destination <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> destination.id = st.id <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ( route.from_id = origin.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> route.to_id = destination.id ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> selected.id = ? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( thread.sender_id = ? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ( thread.recipient_id = ? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( origin.id = destination.id <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ( route.distance <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() &gt;= thread.datesent + ( route.distance * <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-string"><span class="hljs-string">'30 seconds'</span></span> ) )))) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> datesent <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, thread.parent_id <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span></code> </pre> <br>  Percebeu o problema?  Se o SQL usasse nomes de IDs completos, como <code>email_id</code> , <code>star_id</code> ou <code>station_id</code> , os erros surgiriam imediatamente <i>quando eu escrevesse esse código</i> , e não mais tarde, quando tentasse entender o que havia feito de errado. <br><br>  Faça um favor a si mesmo e use os nomes completos para o ID.  Mais tarde obrigado. <br><br><h1>  Nomes de colunas </h1><br>  Dê às colunas os nomes descritivos possíveis.  Digamos que a coluna de <code>temperature</code> não tenha nada a ver com isso: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-string"><span class="hljs-string">'too cold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> areas <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> temperature &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br>  Eu moro na França, e para nós uma temperatura de 32 graus será "muito fria".  Portanto, é melhor nomear a coluna <code>fahrenheit</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-string"><span class="hljs-string">'too cold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> areas <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fahrenheit &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br>  Agora tudo está completamente claro. <br><br>  Se você tiver restrições de chave estrangeira, atribua o mesmo nome às colunas nos dois lados da restrição sempre que possível.  Aqui está um SQL razoável e perfeitamente pensado: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> some_table s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> some_other_table o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.owner = s.person_id;</code> </pre> <br>  Este código está realmente certo.  Mas quando você olha para a definição da tabela, verá que <code>some_other_table.owner</code> possui uma restrição de chave estrangeira com <code>companies.company_id</code> .  Então, basicamente, esse SQL está errado.  Era necessário usar nomes idênticos: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> some_table s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> some_other_table o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.company_id = s.person_id;</code> </pre> <br>  Agora, fica claro imediatamente que temos um erro, basta verificar uma linha de código e não consultar a definição da tabela. <br><br>  No entanto, quero observar que isso nem sempre pode ser feito.  Se você tiver uma tabela com um armazém de origem e um destino, poderá comparar o <code>source_id</code> com o <code>destination_id</code> com o <code>warehouse_id</code> .  Nesse caso, é melhor fornecer os nomes <code>source_warehouse_id</code> e <code>destination_warehouse_id</code> . <br><br>  Observe também que no exemplo acima, o <code>owner</code> descreverá a finalidade melhor que <code>company_id</code> .  Se isso lhe parecer confuso, você poderá nomear a coluna <code>owning_company_id</code> .  Em seguida, o nome informará o objetivo da coluna. <br><br><h1>  Evitar valores nulos </h1><br>  Esse conselho é conhecido por muitos desenvolvedores de banco de dados experientes, mas, infelizmente, eles não falam sobre isso com frequência: por uma boa razão, não permita valores NULL no banco de dados. <br>  Este é um tópico importante, mas bastante complicado.  Primeiro, discutimos a teoria, depois seu efeito na arquitetura do banco de dados e, em conclusão, analisaremos um exemplo prático de problemas graves causados ​​pela presença de valores NULL. <br><br><h2>  Tipos de bancos de dados </h2><br>  O banco de dados pode conter dados de diferentes <i>tipos</i> : INTEGER, JSON, DATETIME, etc. O tipo está associado à coluna e qualquer valor adicionado a ela deve corresponder a esse tipo. <br><br>  Mas o que é um tipo?  Este é um nome, um conjunto de valores válidos e um conjunto de operações válidas.  Eles nos ajudam a evitar comportamentos indesejados.  Por exemplo, o que acontece em Java se você tentar comparar uma sequência e um número? <br><br><pre> <code class="sql hljs">CustomerAccount.java:5: error: bad operand types for binary operator '&gt;' if ( current &gt; threshold ) { ^ first type: String second type: int</code> </pre> <br>  Mesmo se você não perceber que <code>current &gt; threshold</code> compara tipos incomparáveis, o compilador capturará isso para você. <br><br>  Ironicamente, os bancos de dados que armazenam seus dados - e são sua última linha de defesa contra a corrupção de dados - funcionam muito bem com tipos!  Apenas nojento.  Por exemplo, se sua tabela de <code>customers</code> tiver uma chave substituta, você poderá fazer o seguinte: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, birthdate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> customers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> customer_id &gt; weight;</code> </pre> <br>  Obviamente, isso não faz sentido e, na realidade, você receberá um erro de compilação.  Muitas linguagens de programação facilitam a captura de erros desse tipo, mas com bancos de dados, o oposto é verdadeiro. <br><br>  Essa é uma situação normal no mundo dos bancos de dados, provavelmente porque o <a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">primeiro padrão SQL foi lançado em 1992</a> .  Os computadores estavam lentos naqueles anos e tudo o que complicou a implementação sem dúvida diminuiu a velocidade dos bancos de dados. <br><br>  E então valores NULL aparecem em cena.  O padrão SQL os implementou corretamente em apenas um local, nos <code>IS NOT NULL</code> <code>IS NULL</code> e <code>IS NOT NULL</code> .  Como o valor NULL é desconhecido por definição, você não pode ter operadores projetados para ele.  E então existem <code>IS NULL</code> e <code>IS NOT NULL</code> vez de <code>= NULL</code> e <code>!= NULL</code> .  E qualquer comparação de valores NULL leva ao aparecimento de um novo valor NULL. <br><br>  Se isso lhe parecer estranho, será muito mais fácil se você escrever "desconhecido" em vez de NULL: <br><br><blockquote>  Comparar valores desconhecidos <s>NULL</s> resulta em valores desconhecidos <s>NULL</s> . </blockquote><br>  Sim, agora eu vejo! <br><br><h2>  O que significa um valor nulo? </h2><br>  Armado com as migalhas da teoria, consideramos suas conseqüências práticas. <br><br>  Você precisa pagar um bônus de US $ 500 a todos os funcionários cujo salário no ano for superior a US $ 50 mil. Você escreve este código: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> employee_number, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> salary &gt; <span class="hljs-number"><span class="hljs-number">50000</span></span>;</code> </pre> <br>  E você acabou de ser demitido, porque seu chefe ganhou mais de US $ 50 mil, mas o salário dele não está no banco de dados (na coluna Salário dos <code>employees.salary</code> é NULL) e o operador de comparação não pode comparar NULL com 50.000. <br><br>  Por que existe NULL nesta coluna?  Talvez o salário seja confidencial.  Talvez a informação ainda não tenha chegado.  Talvez este seja um consultor e não seja pago.  Talvez ele tenha um salário por hora, não um salário.  Há <i>muitas</i> razões pelas quais os dados podem estar ausentes. <br><br>  A presença ou ausência de informações na coluna sugere que depende de <i>outra</i> coisa, e não da desnormalização da chave primária e do banco de dados.  Portanto, colunas nas quais pode haver valores NULL são boas candidatas para a criação de novas tabelas.  Nesse caso, você pode ter tabelas <code></code> , <code></code> <code>_</code> , <code>__</code> , etc. Você ainda é demitido por combinar salários cegamente e seu chefe não ter um.  Mas então sua base começa a fornecer informações suficientes para sugerir que o problema é mais do que uma questão salarial. <br><br>  E sim, foi um exemplo estúpido, mas foi a gota d'água. <br><br><h2>  Valores NULL levam a situações logicamente impossíveis </h2><br>  Pode parecer que sou pedante em relação a valores NULL.  No entanto, vejamos outro exemplo que está muito mais próximo da realidade. <br><br>  Alguns anos atrás, trabalhei em Londres para um registrador de domínio e tentei entender por que uma consulta SQL de 80 linhas retorna dados incorretos.  Nessa situação, as informações definitivamente deveriam ter sido retornadas, mas isso não aconteceu.  Tenho vergonha de admitir, mas levei um dia para entender que o motivo era uma combinação de condições: <br><br><ul><li>  Eu usei OUTER JOIN. <br></li><li>  Eles poderiam facilmente gerar valores NULL. <br></li><li>  Valores NULL podem fazer com que o SQL dê uma resposta incorreta. <br></li></ul><br>  Muitos desenvolvedores não conhecem o último aspecto, então vamos ver um exemplo do livro <a href="https://www.amazon.com/Database-Depth-Relational-Theory-Practitioners/dp/0596100124/">Database In Depth</a> .  Um diagrama simples de duas tabelas: <br><br> <code>suppliers</code> <br> <div class="scrollable-table"><table><tbody><tr><td>  supplier_id <br></td><td>  cidade <br></td></tr><tr><td>  s1 <br></td><td>  Londres <br></td></tr></tbody></table></div><br> <code>parts</code> <br> <br><div class="scrollable-table"><table><tbody><tr><td>  part_id <br></td><td>  cidade <br></td></tr><tr><td>  p1 <br></td><td>  Nulo <br></td></tr></tbody></table></div><br>  É difícil encontrar um exemplo mais simples. <br><br>  Este código retorna <code>p1</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> parts;</code> </pre> <br>  O que esse código fará? <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> parts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> city = city;</code> </pre> <br>  Ele não retornará nada, porque você não pode comparar um valor NULL, mesmo com outro NULL ou o mesmo NULL.  Parece estranho porque a cidade em cada linha deve ser a mesma, mesmo que não a conheçamos, certo?  Então, o que retornará o seguinte código?  Tente entender isso antes de ler mais. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s.supplier_id, p.part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> suppliers s, parts p <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> p.city &lt;&gt; s.city <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> p.city &lt;&gt; <span class="hljs-string"><span class="hljs-string">'Paris'</span></span>;</code> </pre> <br>  Não recebemos uma string em resposta, porque não podemos comparar a cidade <code>NULL</code> ( <code>p.city</code> ) e, portanto, nenhuma das ramificações da <code>WHERE</code> levará a <code>true</code> . <br><br>  No entanto, sabemos que a cidade desconhecida é Paris ou não Paris.  Se for Paris, a primeira condição será verdadeira ( <code>&lt;&gt; 'London'</code> ).  Se não for Paris, a segunda condição será verdadeira ( <code>&lt;&gt; 'Paris'</code> ).  Portanto, a <code>WHERE</code> deve ser <code>true</code> , mas não é e, como resultado, o SQL gera um resultado logicamente impossível. <br><br>  Foi um bug que encontrei em Londres.  Toda vez que você escreve SQL que pode gerar ou conter valores NULL, corre o risco de obter um resultado falso.  Isso acontece com pouca frequência, mas é muito difícil de identificar. <br><br><h1>  Sumário </h1><br><ul><li>  Use <code>__</code> vez de <code>CamelCase</code> . <br></li><li>  Os nomes das tabelas devem estar no plural. <br></li><li>  Dê nomes estendidos para campos com identificadores ( <code>item_id</code> vez de <code>id</code> ). <br></li><li>  Evite nomes de coluna ambíguos. <br></li><li>  Se possível, nomeie as colunas com chaves estrangeiras da mesma maneira que as colunas às quais elas se referem. <br></li><li>  Sempre que possível, adicione NOT NULL a todas as definições de coluna. <br></li><li>  Sempre que possível, evite escrever SQL que possa gerar valores NULL. <br></li></ul><br>  Embora não seja perfeito, este guia de design de banco de dados facilitará sua vida. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484188/">https://habr.com/ru/post/pt484188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484176/index.html">Implementando o modelo de status no Unity</a></li>
<li><a href="../pt484178/index.html">Switch Ethernet inteligente para o planeta Terra</a></li>
<li><a href="../pt484180/index.html">PBX virtual Rostelecom: o que e como pode ser feito através da API</a></li>
<li><a href="../pt484182/index.html">Xenobots: nanorobôs vivos de células de sapo</a></li>
<li><a href="../pt484186/index.html">LDAP - "autenticação" é um antipadrão</a></li>
<li><a href="../pt484192/index.html">Fácil e fácil de implantar aplicativos no cartucho Tarantool (parte 2)</a></li>
<li><a href="../pt484194/index.html">Kubernetes traduzido em crianças</a></li>
<li><a href="../pt484196/index.html">Gravando som JS de um microfone ou comentários de voz</a></li>
<li><a href="../pt484198/index.html">Verso da moeda: quem ganhou e perdeu com o crescimento das ações da Tesla</a></li>
<li><a href="../pt484200/index.html">Como definir metas para alcançá-las</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>