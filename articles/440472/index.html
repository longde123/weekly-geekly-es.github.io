<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐼 🧛 ✌🏾 Implementación de modelos seq2seq en Tensorflow 🔈 👨🏽‍🚀 👈🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La generación de datos utilizando una red neuronal recurrente se está convirtiendo en un método cada vez más popular y se está utilizando en muchas ár...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementación de modelos seq2seq en Tensorflow</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440472/"><p>  La generación de datos utilizando una red neuronal recurrente se está convirtiendo en un método cada vez más popular y se está utilizando en muchas áreas de la informática.  Desde el comienzo del nacimiento del concepto seq2seq en 2014, solo han pasado cinco años, pero el mundo ha visto muchas aplicaciones, comenzando con los modelos clásicos de traducción y reconocimiento de voz, y terminando con la generación de descripciones de objetos en fotografías. </p><br><p> Por otro lado, con el tiempo, la biblioteca Tensorflow, lanzada por Google específicamente para el desarrollo de redes neuronales, ganó popularidad.  Naturalmente, los desarrolladores de Google no podían ignorar un paradigma tan popular como seq2seq, por lo que la biblioteca Tensorflow proporciona clases para el desarrollo dentro de este paradigma.  Este artículo describe este sistema de clases. </p><a name="habracut"></a><br><h2 id="rekurentnye-seti">  Redes recurrentes </h2><br><p>  En la actualidad, las redes recurrentes son uno de los formalismos más conocidos y prácticos para construir redes neuronales profundas.  Las redes recursivas están diseñadas para procesar datos en serie, por lo tanto, a diferencia de una célula normal (neurona), que recibe datos como entrada y genera el resultado de los cálculos, una célula recursiva contiene dos entradas y dos salidas. </p><br><p>  Una de las entradas representa los datos del elemento actual de la secuencia, y la segunda entrada se llama <i>estado</i> y se transmite como resultado de los cálculos de celda en el elemento anterior de la secuencia. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/684/601/aa6/684601aa63886d86a1b4dafcf8ab079c.png" width="100" alt="imagen"><br><p>  La figura muestra la celda A, para la cual se ingresan los datos de un elemento de secuencia <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>t</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.156ex" height="1.817ex" viewBox="0 -520.7 928.1 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhjsnyGEFnuPcW0guhHALA30eA4JuQ#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhjsnyGEFnuPcW0guhHALA30eA4JuQ#MJMATHI-74" x="809" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>t</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-1"> x_t </script>  así como la condición no indicada aquí <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>&amp;#x2212;</mo><mn>1</mn></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.017ex" height="1.937ex" viewBox="0 -520.7 1729.5 834" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhjsnyGEFnuPcW0guhHALA30eA4JuQ#MJMATHI-73" x="0" y="0"></use><g transform="translate(469,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhjsnyGEFnuPcW0guhHALA30eA4JuQ#MJMATHI-74" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhjsnyGEFnuPcW0guhHALA30eA4JuQ#MJMAIN-2212" x="361" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhjsnyGEFnuPcW0guhHALA30eA4JuQ#MJMAIN-31" x="1140" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>s</mi><mrow class="MJX-TeXAtom-ORD"><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-2"> s_ {t-1} </script>  .  En la salida, la celda A da el estado <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>t</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.916ex" height="1.817ex" viewBox="0 -520.7 825.1 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhjsnyGEFnuPcW0guhHALA30eA4JuQ#MJMATHI-73" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhjsnyGEFnuPcW0guhHALA30eA4JuQ#MJMATHI-74" x="663" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>s</mi><mi>t</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-3"> s_t </script>  y el resultado del cálculo <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>h</mi><mi>t</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.165ex" height="2.419ex" viewBox="0 -780.1 932.1 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhjsnyGEFnuPcW0guhHALA30eA4JuQ#MJMATHI-68" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhjsnyGEFnuPcW0guhHALA30eA4JuQ#MJMATHI-74" x="815" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>h</mi><mi>t</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-4"> h_t </script>  . </p><br><p>  En la práctica, la secuencia de datos generalmente se divide en subsecuencias de cierta longitud fija y se pasa al cálculo por subconjuntos completos (lotes).  En otras palabras, las subsecuencias son ejemplos de aprendizaje.  Las entradas, salidas y estados de celda de una red recursiva son secuencias de números reales.  Para el cálculo de entrada <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.384ex" height="1.696ex" viewBox="0 -520.7 1026.4 730.2" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhjsnyGEFnuPcW0guhHALA30eA4JuQ#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/440472/&amp;usg=ALkJrhjsnyGEFnuPcW0guhHALA30eA4JuQ#MJMAIN-31" x="809" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-5"> x_1 </script>  es necesario usar un estado que no fue el resultado de un cálculo en una secuencia de datos dada.  Tales estados se llaman estados iniciales.  Si la secuencia es lo suficientemente larga, entonces tiene sentido mantener el contexto de los cálculos en cada subsecuencia.  En este caso, es posible transmitir el último estado calculado en la secuencia anterior como el estado inicial.  Si la secuencia no es tan larga o la subsecuencia es el primer segmento, puede inicializar el estado inicial con ceros. </p><br><p>  Por el momento, para entrenar redes neuronales en casi todas partes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se utiliza</a> el algoritmo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propagación hacia atrás de errores</a> .  El resultado del cálculo en el conjunto de ejemplos transmitidos (en nuestro caso, el conjunto de subsecuencias) se compara con el resultado esperado (datos marcados).  La diferencia entre los valores reales y esperados se denomina error y este error se propaga a los pesos de la red en la dirección opuesta.  Por lo tanto, la red se adapta a los datos etiquetados y, como regla, el resultado de esta adaptación funciona bien para los datos que la red no reunió en los ejemplos de entrenamiento inicial (hipótesis de generalización). </p><br><p>  En el caso de una red recursiva, tenemos varias opciones sobre qué salidas considerar el error.  Aquí describiremos dos principales: </p><br><ol><li>  Puede considerar el error comparando la salida de la última celda de la subsecuencia con la salida esperada.  Esto funciona bien para la tarea de clasificación.  Por ejemplo, necesitamos determinar el color emocional de un tweet.  Para hacer esto, seleccionamos tweets y los marcamos en tres categorías: negativo, positivo y neutral.  La salida de la celda será de tres números: pesos de categoría.  El tweet también se marcará con tres números: las probabilidades de que el tweet pertenezca a la categoría correspondiente.  Después de calcular el error en un subconjunto de datos, puede propagarlo a través de la salida o el estado que desee. </li><li>  Puede leer el error inmediatamente en las salidas del cálculo de celda para cada elemento de la subsecuencia.  Esto es muy adecuado para la tarea de predecir el siguiente elemento de una secuencia de los anteriores.  Este enfoque se puede utilizar, por ejemplo, en el problema de determinar anomalías en series temporales de datos o en la tarea de predecir el siguiente carácter en el texto, para luego generarlo.  La propagación de errores también es posible a través de estados o salidas. </li></ol><br><p>  A diferencia de una red neuronal normal totalmente conectada, una red recursiva es profunda en el sentido de que el error se propaga no solo desde las salidas de la red a sus pesos, sino también hacia la izquierda, a través de las conexiones entre estados.  La profundidad de la red está así determinada por la longitud de la subsecuencia.  Para propagar el error a través del estado de la red recursiva, hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algoritmo</a> especial.  Su característica es que los gradientes de los pesos se multiplican entre sí, cuando el error se propaga de derecha a izquierda.  Si el error inicial es mayor que la unidad, como resultado, el error puede llegar a ser muy grande.  Por el contrario, si el error inicial es menor que la unidad, entonces, en algún lugar al comienzo de la secuencia, el error puede desvanecerse.  Esta situación en la teoría de las redes neuronales se llama el carrusel del error estándar.  Para evitar tales situaciones durante el entrenamiento, se inventaron células especiales que no tienen tales inconvenientes.  La primera de estas células fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LSTM</a> , ahora hay una amplia gama de alternativas, de las cuales la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GRU</a> más popular. </p><br><p>  Una buena introducción a las redes de recurrencia se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en este artículo</a> .  Otra fuente conocida es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un artículo</a> del blog de Andrey Karpaty. </p><br><p>  La biblioteca Tensorflow tiene muchas clases y funciones para implementar redes recursivas.  Aquí hay un ejemplo de cómo crear una red recursiva dinámica basada en una celda del tipo GRU: </p><br><pre><code class="python hljs">cell = tf.contrib.rnn.GRUCell(dimension) outputs, state = tf.nn.dynamic_rnn(cell, input, sequence_length=input_length, dtype=tf.float32)</code> </pre> <br><p>  En este ejemplo, se crea una celda GRU, que luego se usa para crear una red recursiva dinámica.  El tensor de datos de entrada y las longitudes reales de las subsecuencias se transmiten a la red.  Los datos de entrada siempre se especifican mediante un vector de números reales.  Para un solo valor, por ejemplo, un código de símbolo o una palabra, el llamado  incrustación: asigna este código a alguna secuencia de números.  La función de crear una red recursiva dinámica devuelve un par de valores: una lista de salidas de red para todos los valores de la secuencia y el último estado calculado.  Como entrada, la función toma una celda, datos de entrada y un tensor de longitud de subsecuencia. </p><br><p>  Una red recursiva dinámica difiere de una estática en que no crea una red de celdas de red para la subsecuencia por adelantado (en la etapa de determinación del gráfico de cálculo), sino que lanza las celdas en las entradas dinámicamente durante el cálculo del gráfico en los datos de entrada.  Por lo tanto, esta función necesita conocer las longitudes de subsecuencias de los datos de entrada para detenerse en el momento adecuado. </p><br><h2 id="porozhdayuschie-modeli-na-osnove-rekurentnyh-setey">  Generando modelos basados ​​en redes de recurrencia </h2><br><h3 id="porozhdayuschie-rekurentnye-seti">  Generando redes de recurrencia </h3><br><p>  Anteriormente, consideramos dos métodos para calcular los errores de las redes recursivas: en la última salida o en todas las salidas para una secuencia dada.  Aquí consideramos el problema de generar secuencias.  La capacitación de la red de generadores se basa en el segundo método de lo anterior. </p><br><p>  Con más detalle, estamos tratando de entrenar una red recursiva para predecir el siguiente elemento de una secuencia.  Como se mencionó anteriormente, la salida de una celda en una red recursiva es simplemente una secuencia de números.  Este vector no es muy conveniente para el aprendizaje, por lo tanto, introducen otro nivel, que recibe este vector en la entrada, y en la salida da el peso de las predicciones.  Este nivel se llama <em>nivel de proyección</em> y le permite comparar la salida de la celda en un elemento dado de la secuencia con la salida esperada en los datos etiquetados. </p><br><p>  Para ilustrar, considere la tarea de generar texto que se representa como una secuencia de caracteres.  La longitud del vector de salida del nivel de proyección es igual al tamaño del alfabeto del texto fuente.  El tamaño del alfabeto generalmente no supera los 150 caracteres, si cuenta los caracteres de los idiomas ruso e inglés, así como los signos de puntuación.  La salida del nivel de proyección es un vector con la longitud del alfabeto, donde cada símbolo corresponde a una determinada posición en este vector: el índice de este símbolo.  Los datos etiquetados también son un vector que consiste en ceros, donde uno se encuentra en la posición del personaje que sigue la secuencia. </p><br><p>  Para el entrenamiento, utilizamos dos secuencias de datos: </p><br><ol><li>  Una secuencia de caracteres en el texto fuente, al principio de la cual se agrega un carácter especial que no forma parte del texto fuente.  Por lo general, se conoce como <em>ir</em> . </li><li>  La secuencia de caracteres del texto fuente tal cual, sin adiciones. </li></ol><br><p>  Ejemplo para el texto "mamá lavó el marco": </p><br><pre> <code class="python hljs">[<span class="hljs-string"><span class="hljs-string">'&lt;go&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">'] ['</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]</code> </pre> <br><p>  Para el entrenamiento, generalmente se forman minibatches, que consisten en un pequeño número de ejemplos.  En nuestro caso, se trata de cadenas que pueden tener diferentes longitudes.  El código descrito a continuación utiliza el siguiente método para resolver el problema de diferentes longitudes.  De las muchas líneas en este minipaquete, se calcula la longitud máxima.  Todas las demás líneas se rellenan con un carácter especial (relleno) para que todos los ejemplos en el minipacket tengan la misma longitud.  En el ejemplo de código a continuación, la cadena del <em>pad</em> se usa como dicho carácter.  Además, para una mejor generación, al final del ejemplo, agregue el símbolo para el final de la oración - <em>eos</em> .  Por lo tanto, en realidad, los datos del ejemplo se verán un poco diferentes: </p><br><pre> <code class="python hljs">[<span class="hljs-string"><span class="hljs-string">'&lt;go&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span>&lt;eos&gt;<span class="hljs-string"><span class="hljs-string">', '</span></span>&lt;pad&gt;<span class="hljs-string"><span class="hljs-string">', '</span></span>&lt;pad&gt;<span class="hljs-string"><span class="hljs-string">', '</span></span>&lt;pad&gt;<span class="hljs-string"><span class="hljs-string">'] ['</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-string"><span class="hljs-string">', '</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;eos&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;pad&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;pad&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;pad&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;pad&gt;'</span></span>]</code> </pre> <br><p>  La primera secuencia se alimenta a la entrada de la red, y la segunda secuencia se usa como datos etiquetados.  El entrenamiento de predicción se basa en desplazar la secuencia original un personaje a la izquierda. </p><br><h3 id="obuchenie-i-porozhdenie">  Entrenamiento y desove </h3><br><h4 id="obuchenie">  Entrenamiento </h4><br><p>  El algoritmo de aprendizaje es bastante simple.  Para cada elemento de la secuencia de entrada, calculamos el vector de salida de su nivel de proyección y lo comparamos con el marcado.  La única pregunta es cómo calcular el error.  Puede usar el error cuadrático medio, pero para calcular el error en esta situación, es mejor usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">entropía cruzada</a> .  La biblioteca Tensorflow proporciona varias funciones para su cálculo, aunque no hay nada que detenga la implementación de la fórmula de cálculo directamente en el código. </p><br><p>  Para mayor claridad, presentamos alguna notación.  Por symbol_id indicaremos el identificador del símbolo (su número de serie en el alfabeto).  El término símbolo aquí es bastante arbitrario y simplemente significa un elemento del alfabeto.  El alfabeto puede no contener símbolos, sino palabras o incluso algunos conjuntos de atributos más complejos.  El término symbol_embedding se usará para denotar el vector de números que corresponde a un elemento dado del alfabeto.  Por lo general, estos conjuntos de números se almacenan en una tabla de tamaños que coincide con el tamaño del alfabeto. </p><br><p>  Tensorflow proporciona una función que le permite acceder a la tabla de incrustación y reemplazar los índices de caracteres con sus vectores de incrustación.  Primero, definimos una variable para almacenar la tabla: </p><br><pre> <code class="python hljs">embedding_table = tf.Variable(tf.random_uniform([alphabet_size, embedding_size]))</code> </pre> <br><p>  Después de eso, puede convertir los tensores de entrada en tensores de inserción: </p><br><pre> <code class="python hljs">input_embeddings = tf.nn.embedding_lookup(embedding_table, input_ids)</code> </pre> <br><p>  El resultado de la llamada a la función es un tensor de la misma dimensión que se transfirió a la entrada, pero como resultado, todos los índices de caracteres se reemplazan con las secuencias de incrustación correspondientes. </p><br><h4 id="porozhdenie">  Engendrar </h4><br><p>  Para calcular, una celda de una red recursiva necesita un estado y el carácter actual.  El resultado del cálculo es una salida y un nuevo estado.  Si aplicamos el nivel de proyección a la salida, podemos obtener un vector de pesos donde el peso en la posición correspondiente puede considerarse (muy condicionalmente) como la probabilidad de que este símbolo aparezca en la siguiente posición de la secuencia. </p><br><p>  Se pueden usar varias estrategias para seleccionar el siguiente símbolo en función del vector de peso generado por el nivel de proyección: </p><br><ul><li>  Estrategia de búsqueda codiciosa.  Cada vez que seleccionamos el símbolo con el mayor peso, es decir  muy probablemente en esta situación, pero no necesariamente la más apropiada en el contexto de toda la secuencia. </li><li>  Estrategia para elegir la mejor secuencia (búsqueda de haz).  No seleccionamos un símbolo a la vez, pero recordamos varias variantes de los símbolos más probables.  Después de calcular todas estas opciones para todos los elementos de la secuencia generada, seleccionamos la secuencia de caracteres más probable, teniendo en cuenta el contexto de toda la secuencia.  Por lo general, esto se implementa por medio de una matriz cuyo ancho es igual a la longitud de la secuencia y la altura al número de anchos de generación de haz.  Una vez completada la generación de las variantes de secuencia, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utiliza</a> una de las variantes del algoritmo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Viterbi</a> para seleccionar la secuencia más probable. </li></ul><br><h2 id="sistema-tipov-seq2seq-v-biblioteke-tensorflow">  Sistema de tipo seq2seq de la biblioteca Tensorflow </h2><br><p>  Dado lo anterior, está claro que la implementación de modelos generativos basados ​​en redes de recurrencia es una tarea bastante difícil de codificar.  Por lo tanto, naturalmente, se propusieron sistemas de clase para facilitar la solución de este problema.  Uno de estos sistemas se llama seq2seq, luego describimos la funcionalidad de sus tipos principales. </p><br><p>  Pero, antes que nada, algunas palabras sobre el nombre de la biblioteca.  El nombre seq2seq es la abreviatura de secuencia a secuencia (de secuencia a secuencia).  Se propuso la idea original de generar una secuencia para implementar un sistema de traducción.  La secuencia de entrada de palabras se alimentó a la entrada de una red recursiva, llamada codificador en este sistema.  El resultado de esta red recursiva fue el estado del cálculo de la celda en el último carácter de la secuencia.  Este estado se presentó como el estado inicial de la segunda red recursiva, el decodificador, que fue entrenado para generar la siguiente palabra.  Las palabras fueron utilizadas como símbolos en ambas redes.  Los errores en el decorador se propagaron al codificador a través del estado transmitido.  El vector de estado mismo en esta terminología se llamaba vector de pensamiento.  La presentación intermedia se utilizó en los modelos de traducción tradicionales y, como regla, era un gráfico que representaba la estructura del texto de entrada para la traducción.  El sistema de traducción generó texto de salida basado en esta estructura intermedia. </p><br><p>  En realidad, la implementación de seq2seq en Tensorflow pertenece a la parte del decodificador, sin afectar el codificador.  Por lo tanto, sería correcto llamar a la biblioteca 2seq, pero la fuerza de la tradición y la inercia de pensar aquí obviamente prevalecieron sobre el sentido común. </p><br><p>  Los dos metatipos principales en la biblioteca seq2seq son: </p><br><ol><li>  Clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">auxiliar</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Decodificador de</a> clase. </li></ol><br><p>  Los desarrolladores de la biblioteca identificaron estos tipos basándose en las siguientes consideraciones.  Consideremos el proceso de aprendizaje y el proceso de generación, que describimos anteriormente, desde un ángulo ligeramente diferente. </p><br><p>  Para el entrenamiento necesitas: </p><br><ol><li>  Para cada carácter, pase el cálculo del estado actual y la incrustación del carácter actual. </li><li>  Recuerde el estado de salida y la proyección calculada para la salida. </li><li>  Obtenga el siguiente personaje en la secuencia y vaya al paso 1. </li></ol><br><p>  Después de eso, puede comenzar a contar los errores comparando los resultados de los cálculos con los siguientes caracteres de la secuencia. </p><br><p>  Para generarlo es necesario: </p><br><ol><li>  Para cada carácter, pase el cálculo del estado actual y la incrustación del carácter actual. </li><li>  Recuerde el estado de salida y la proyección calculada para la salida. </li><li>  Calcule el siguiente carácter como el máximo de los índices de nivel de proyección y vaya al paso 1. </li></ol><br><p>  Como se puede ver en la descripción, los algoritmos son muy similares.  Por lo tanto, los desarrolladores de la biblioteca decidieron encapsular el procedimiento para obtener el siguiente carácter en la clase Helper.  Para el entrenamiento, esto es solo leer el siguiente personaje de la secuencia, y para generarlo, seleccionar el personaje con el peso máximo (por supuesto, para la búsqueda codiciosa). </p><br><p>  En consecuencia, la clase base Helper implementa el método next_inputs para obtener el siguiente carácter del estado y actual, así como el método de muestra para obtener índices de caracteres del nivel de proyección.  La clase TrainingHelper se proporciona para la capacitación, y la clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GreedyEmbeddingHelper</a> está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">disponible</a> para la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generación</a> codiciosa.  Desafortunadamente, el modelo de búsqueda de haz no encaja en este tipo de sistema, por lo tanto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> implementa una clase especial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BeamSearchDecoder</a> en la biblioteca para esto.  sin usar Helper. </p><br><p>  La clase Decoder proporciona una interfaz para implementar un decodificador.  De hecho, la clase proporciona dos métodos: </p><br><ol><li>  inicializar para inicializar al comienzo del trabajo. </li><li>  paso para implementar un paso o generación de aprendizaje.  El contenido de este paso está determinado por el Ayudante correspondiente. </li></ol><br><p>  La biblioteca implementa la clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BasicDecoder</a> , que se puede usar tanto para entrenar como para reproducirse con los asistentes TrainingHelper y GreedyEmbeddingHelper.  Estas tres clases suelen ser suficientes para implementar modelos de generación basados ​​en redes de recurrencia. </p><br><p>  Finalmente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las</a> funciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dynamic_decode</a> se usan para organizar el paso a través de una entrada o secuencia generada. </p><br><p>  A continuación, consideraremos un ejemplo ilustrativo, que muestra métodos para construir modelos de generación para varios tipos de biblioteca seq2seq. </p><br><h2 id="illyustrativnyy-primer">  Ejemplo ilustrativo </h2><br><p>  En primer lugar, debe decirse que todos los ejemplos se implementan en Python 2.7.  Se puede encontrar una lista de bibliotecas adicionales en el archivo require.txt. </p><br><p>  Como ejemplo ilustrativo, considere parte de los datos para el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desafío de normalización de texto:</a> concurso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">idioma ruso</a> realizado por Kaggle por Google en 2017.  El propósito de esta competencia fue convertir el texto ruso en una forma adecuada para leer.  El texto del concurso se desglosó en expresiones mecanografiadas.  Los datos de entrenamiento se especificaron en un archivo CSV de la siguiente forma: </p><br><pre> <code class="plaintext hljs">"sentence_id","token_id","class","before","after" 0,0,"PLAIN","","" 0,1,"PLAIN","","" 0,2,"PLAIN","","" 0,3,"DATE","1862 ","    " 0,4,"PUNCT",".","." 1,0,"PLAIN","","" 1,1,"PLAIN","","" 1,2,"PLAIN","","" 1,3,"PLAIN","","" 1,4,"PLAIN","","" 1,5,"PLAIN","","" 1,6,"PLAIN","","" 1,7,"PLAIN","","" 1,8,"PLAIN","","" 1,9,"PUNCT",".","." ...</code> </pre> <br><p>  En el ejemplo anterior, una expresión de tipo DATE es interesante, en ella, "1862" se traduce en "mil ochocientos sesenta y dos años".  Para ilustrar, consideramos los datos de tipo DATE solo como pares de la forma (expresión antes, expresión después).  Inicio del archivo de datos: </p><br><pre> <code class="plaintext hljs">before,after 1862 ,     1811 ,    12  2013,      15  2013,      1905 ,    17  2014,      7  2010 ,      1 ,  1843 ,     30  2007 ,      1846 ,     1996 ,     9 ,  ...</code> </pre> <br><p>  Construiremos el modelo generador utilizando la biblioteca seq2seq, en la que el codificador se implementará a nivel de símbolo (es decir, los elementos del alfabeto son símbolos), y el decodificador usará las palabras como alfabeto.  El código de muestra, como los datos, está disponible en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio en Github</a> . </p><br><p>  Los datos de entrenamiento se dividen en tres subconjuntos: train.csv, test.csv y dev.csv, para entrenamiento, prueba y verificación de reentrenamiento, respectivamente.  Los datos están en el directorio de datos.  Se implementan tres modelos en el repositorio: seq2seq_greedy.py, seq2seq_attention.py y seq2seq_beamsearch.py.  Aquí miramos el código para el modelo de búsqueda codicioso básico. </p><br><p>  Todos los modelos usan la clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estimator</a> para implementar.  El uso de esta clase le permite simplificar la codificación sin distraerse con partes que no sean modelos.  Por ejemplo, no es necesario implementar un ciclo de transferencia de datos para el entrenamiento, crear sesiones para trabajar con Tensorflow, pensar en transferir datos a Tensorboard, etc.  Estimator requiere solo dos funciones para su implementación: para la transferencia de datos y para construir un modelo.  Los ejemplos también usan la clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dataset</a> para pasar datos para su procesamiento.  Esta implementación moderna es mucho más rápida que los diccionarios tradicionales para transferir datos del formulario feed_dict. </p><br><h3 id="formirovanie-dannyh">  Generacion de datos </h3><br><p>  Considere un código de generación de datos para capacitación y generación. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_fn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(line_before, line_after)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Encode in Bytes for TF source = [c.encode('utf8') for c in line_before.decode('utf8').rstrip('\n')] t = [w.encode('utf8') for w in nltk.word_tokenize(line_after.decode('utf8').strip())] learn_target = t + ['&lt;eos&gt;'] + ['&lt;pad&gt;'] target = ['&lt;go&gt;'] + t + ['&lt;eos&gt;'] return (source, len(source)), (target, learn_target, len(target)) def generator_fn(data_file): with open(data_file, 'rb') as f: reader = csv.DictReader(f, delimiter=',', quotechar='"') for row in reader: yield parse_fn(row['before'], row['after']) def input_fn(data_file, params=None): params = params if params is not None else {} shapes = (([None], ()), ([None], [None], ())) types = ((tf.string, tf.int32), (tf.string, tf.string, tf.int32)) defaults = (('&lt;pad&gt;', 0), ('&lt;pad&gt;', '&lt;pad&gt;', 0)) dataset = tf.data.Dataset.from_generator(functools.partial(generator_fn, data_file), output_shapes=shapes, output_types=types) dataset = dataset.repeat(params['epochs']) return (dataset.padded_batch(params.get('batch_size', 50), shapes, defaults).prefetch(1))</span></span></code> </pre> <br><p>  La función input_fn se usa para crear una colección de datos que el Estimador luego pasa al entrenamiento y la generación.  El tipo de datos se establece primero.  Este es un par de la forma ((secuencia del codificador, longitud), (secuencia del decodificador, secuencia del decodificador con un prefijo, longitud)).  La cadena "" se usa como prefijos, cada secuencia de codificador termina con una palabra especial "".  Además, debido al hecho de que las secuencias (tanto de entrada como de salida) tienen una longitud desigual, se utiliza el símbolo de relleno con el valor "". <br></p><p>  El código de preparación de datos lee el archivo de datos, divide la cadena del codificador en caracteres y la cadena del decodificador en palabras, utilizando la biblioteca nltk para esto.  Una fila procesada de esta manera es un ejemplo de datos de entrenamiento.  La colección generada se divide en mini paquetes y la cantidad de datos se clona de acuerdo con el número de eras de entrenamiento (cada época es un pase de datos). </p><br><h3 id="rabota-so-slovaryami">  Trabajar con diccionarios </h3><br><p>  Los diccionarios se almacenan como una lista en archivos, una línea para una palabra o carácter.  Para construir diccionarios, use el script build_vocabs.py.  Los diccionarios generados se encuentran en el directorio de datos como archivos de la forma vocab. *. Txt. </p><br><p>  Código para leer diccionarios: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Read vocabs and inputs dropout = params['dropout'] source, source_length = features training = (mode == tf.estimator.ModeKeys.TRAIN) vocab_source = tf.contrib.lookup.index_table_from_file(vocabulary_file=params['source_vocab_file'], num_oov_buckets=params['num_oov_buckets']) with open(params['source_vocab_file']) as f: num_sources = sum(1 for _ in f) + params['num_oov_buckets'] vocab_target = tf.contrib.lookup.index_table_from_file(vocabulary_file=params['target_vocab_file'], num_oov_buckets=params['num_oov_buckets']) with open(params['target_vocab_file']) as f: num_targets = sum(1 for _ in f) + params['num_oov_buckets']</span></span></code> </pre> <br><p>  Aquí, probablemente, la función index_table_from_file, que lee las entradas del diccionario de un archivo, es interesante, y su parámetro num_oov_buckets es el número de canastas de vocabulario.  Por defecto, este número es igual a uno, es decir  todas las palabras que no están en el diccionario tienen el mismo índice igual al tamaño del diccionario + 1. Tenemos tres palabras desconocidas: "", "" y "", para las cuales queremos tener índices diferentes.  Por lo tanto, establezca este parámetro en el número tres.  Desafortunadamente, debe volver a leer el archivo de entrada para obtener el número de palabras en el diccionario como una constante de tiempo para configurar el gráfico del modelo. <br></p><p>  Todavía necesitamos crear una tabla para implementar la incrustación - _source_embedding, así como para traducir cadenas de palabras a cadenas de identificación: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># source embeddings matrix _source_embedding = tf.Variable(tf.random_uniform([num_sources, params['embedding_size']])) source_ids = vocab_source.lookup(source) source_embedding = tf.nn.embedding_lookup(_source_embedding, source_ids)</span></span></code> </pre> <br><h3 id="realizaciya-kodirovschika">  Implementación del codificador </h3><br><p>  Para el codificador, utilizaremos una red recursiva bidireccional con varios niveles.     ,     ,      . </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># add multilayer bidirectional RNN cell_fw = tf.contrib.rnn.MultiRNNCell([tf.contrib.rnn.GRUCell(params['dim']) for _ in range(params['layers'])]) cell_bw = tf.contrib.rnn.MultiRNNCell([tf.contrib.rnn.GRUCell(params['dim']) for _ in range(params['layers'])]) outputs, states = tf.nn.bidirectional_dynamic_rnn(cell_fw, cell_bw, source_embedding, sequence_length=source_length, dtype=tf.float32) # prepare output output = tf.concat(outputs, axis=-1) encoder_output = tf.layers.dense(output, params['dim']) # prepare state state_fw, state_bw = states cells = [] for fw, bw in zip(state_fw, state_bw): state = tf.concat([fw, bw], axis=-1) cells += [tf.layers.dense(state, params['dim'])] encoder_state = tuple(cells)</span></span></code> </pre> <br><p>       GRU,    MultiRNNCell,   ,   rnn.Cell.    , <br> sequence_length —     ,     ,    . </p><br><p> ,       ,       ,           .      ,      128,        256.     ,        ,      128.        . </p><br><p>     .  Porque    , ,    bidirectional_dynamic_rnn,   ,     .           ,      .     , ..       . , ,  .            ,   ,       . </p><br><h3 id="realizaciya-dekodirovschika">   </h3><br><p>     ,    .           . </p><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># decoder RNN cell decoder_cell = tf.contrib.rnn.MultiRNNCell([tf.contrib.rnn.GRUCell(params['dim']) for _ in range(params['layers'])]) decoder_initial_state = encoder_state # projection layer projection_layer = tf.layers.Dense(num_targets, use_bias=False) # embedding table for targets target_embedding = tf.Variable(tf.random_uniform([num_targets, params['embedding_size']]))</span></span></code> </pre> <br><h4 id="obuchenie-1">  </h4><br><p>    TrainingHelper + BasicDecoder. </p><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># target embeddings matrix target, learn_target, target_length = labels target_ids = vocab_target.lookup(target) target_learn_ids = vocab_target.lookup(learn_target) # train encoder _target_embedding = tf.nn.embedding_lookup(target_embedding, target_ids) train_helper = tf.contrib.seq2seq.TrainingHelper(_target_embedding, target_length) train_decoder = tf.contrib.seq2seq.BasicDecoder(decoder_cell, train_helper, decoder_initial_state, output_layer=projection_layer) train_outputs, _, _ = tf.contrib.seq2seq.dynamic_decode(train_decoder) train_output = train_outputs.rnn_output train_sample_id = train_outputs.sample_id</span></span></code> </pre> <br><h4 id="porozhdenie-1">  </h4><br><p>        . </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># prediction decoder prediction_helper = tf.contrib.seq2seq.GreedyEmbeddingHelper( embedding=target_embedding, start_tokens=tf.fill([batch_size], tf.to_int32(vocab_target.lookup(tf.fill([], '&lt;go&gt;')))), end_token=tf.to_int32(vocab_target.lookup(tf.fill([], '&lt;eos&gt;')))) prediction_decoder = tf.contrib.seq2seq.BasicDecoder(decoder_cell, prediction_helper, decoder_initial_state, output_layer=projection_layer) prediction_output, _, _ = tf.contrib.seq2seq.dynamic_decode(prediction_decoder, maximum_iterations=params['max_iters']) # prepare prediction reverse_vocab_target = tf.contrib.lookup.index_to_string_table_from_file(params['target_vocab_file']) pred_strings = reverse_vocab_target.lookup(tf.to_int64(prediction_output.sample_id)) predictions = { 'ids': prediction_output.sample_id, 'text': pred_strings }</span></span></code> </pre> <br><p>     GreedyEmbeddingHelper       "",     "".        . , ,    dynamic_decode      .    ,    ,   . ,     ,        . <br><br></p><h4 id="funkciya-poter-i-optimizaciya">     </h4><br><p>     ,        seq2seq. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># loss masks = tf.sequence_mask(lengths=target_length, dtype=tf.float32) loss = tf.contrib.seq2seq.sequence_loss(logits=train_output, targets=target_learn_ids, weights=masks)</span></span></code> </pre> <br><p>    ,     ,      sequence_mask. </p><br><p>     Adam   ,   . </p><br><pre> <code class="python hljs">optimizer = tf.train.AdamOptimizer(learning_rate=params.get(<span class="hljs-string"><span class="hljs-string">'lr'</span></span>, <span class="hljs-number"><span class="hljs-number">.001</span></span>)) grads, vs = zip(*optimizer.compute_gradients(loss)) grads, gnorm = tf.clip_by_global_norm(grads, params.get(<span class="hljs-string"><span class="hljs-string">'clip'</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>)) train_op = optimizer.apply_gradients(zip(grads, vs), global_step=tf.train.get_or_create_global_step())</code> </pre> <br><h4 id="rezultaty-obucheniya">   </h4><br><p>         .     0.9   . , ,     ,    .   ,    . </p><br><pre> <code class="plaintext hljs">24  1944                 1  2003              1992 .           11  1927               1969            1  2016             1047          1863            17      22  2014              </code> </pre> <br><p>        .   —   ,   —  ,   —  . </p><br><p>  ,    —   .             .    ,    ( ),       .       .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>        ,     . </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>            seq2seq.      ,          ,     .    ,  . </p><br><p>           .  Tensorflow   ,   ,     .   ,         ,   .        ,        . ,      ,   padding  ,   embedding     ?       , ,       .         —     . ,    ,    . ,    ,    ,    . ,       . ,          , , ,        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440472/">https://habr.com/ru/post/440472/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440462/index.html">Las 7 mejores estrategias de marketing de contenidos que no debe perderse en 2019</a></li>
<li><a href="../440464/index.html">Trabaje con el servicio de bases de datos administradas de Digital Ocean en .NET Core</a></li>
<li><a href="../440466/index.html">Control remoto web UART</a></li>
<li><a href="../440468/index.html">2 veces más, 10 veces más rápido, durante todo el día, todo por el bien de las personas</a></li>
<li><a href="../440470/index.html">Incruste un intérprete de Python en una aplicación Java utilizando el proyecto Panamá</a></li>
<li><a href="../440474/index.html">Efectos de filtrado SVG. Parte 4. Imágenes a dos colores con feComponentTransfer</a></li>
<li><a href="../440476/index.html">"Comienza con mitaps" o ¿Necesitas cursos de programación?</a></li>
<li><a href="../440478/index.html">3CX v16 Beta 1 con soporte para Raspberry Pi lanzado</a></li>
<li><a href="../440486/index.html">Precio de calidad: 7 principios para optimizar los costos de prueba</a></li>
<li><a href="../440488/index.html">Mapas de sombras reflectantes: parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>