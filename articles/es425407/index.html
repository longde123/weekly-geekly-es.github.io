<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèª üëç ü§úüèæ Firecore: un juego divertido en AVR üíø üëª üòè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quiero compartir otra noche de construcci√≥n a largo plazo, lo que demuestra que puedes hacer juegos incluso en hardware d√©bil. 

 Sobre lo que ten√≠a q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Firecore: un juego divertido en AVR</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425407/"><img src="https://habrastorage.org/webt/dv/yz/hr/dvyzhr-e4xxmj6jbln7ngiti5d0.png"><br><br>  Quiero compartir otra noche de construcci√≥n a largo plazo, lo que demuestra que puedes hacer juegos incluso en hardware d√©bil. <br><br>  Sobre lo que ten√≠a que hacer, c√≥mo se decidi√≥ y c√≥mo hacer algo m√°s que otro clon de Pong: bienvenido a Cat. <br><br>  Precauci√≥n: ¬°excelente art√≠culo, tr√°fico y m√∫ltiples inserciones de c√≥digo! <br><a name="habracut"></a><br><h3>  Brevemente sobre el juego </h3><hr>  ¬°Disp√°rales!  - Ahora en AVR. <br><br>  De hecho, este es otro shmap, por lo que una vez m√°s, el personaje principal <s>Shepard</s> debe salvar a la galaxia de un ataque repentino de personas desconocidas, abri√©ndose paso a trav√©s del espacio a trav√©s de las estrellas y los campos de asteroides que limpian simult√°neamente cada sistema estelar. <br>  Todo el juego est√° escrito en C y C ++ sin usar la biblioteca Wire de Arduino. <br><br>  El juego tiene 4 barcos para elegir (este √∫ltimo est√° disponible despu√©s de pasar), cada uno con sus propias caracter√≠sticas: <br><ul><li>  maniobrabilidad; </li><li>  durabilidad </li><li>  arma de fuego. </li></ul><br>  Tambi√©n implementado: <br><ul><li>  Gr√°ficos en color 2D; </li><li>  encendido para armas; </li><li>  jefes al final de los niveles; </li><li>  niveles con asteroides (y su animaci√≥n de rotaci√≥n); </li><li>  cambio de color de fondo en los niveles (y no solo en el espacio negro); </li><li>  el movimiento de estrellas en el fondo a diferentes velocidades (por efecto de profundidad); </li><li>  puntuaci√≥n y ahorro en EEPROM; </li><li>  los mismos sonidos (disparos, explosiones, etc.); </li><li>  Un mar de oponentes id√©nticos. </li></ul><br><h3>  Plataforma </h3><hr>  El regreso del fantasma. <br><br><blockquote>  Aclarar√© de antemano que esta plataforma debe ser percibida como la vieja consola de juegos de la <s>primera</s> tercera generaci√≥n (80, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">shiru8bit</a> ). <br></blockquote><br>  Adem√°s, las modificaciones de hardware sobre el hardware original est√°n prohibidas, lo que garantiza el lanzamiento en cualquier otra placa id√©ntica desde el primer momento. <br>  Este juego fue escrito para el tablero Arduino Esplora, pero creo que transferirlo a GBA o cualquier otra plataforma no ser√° dif√≠cil. <br>  Sin embargo, incluso en este recurso, esta placa se cubri√≥ solo un par de veces, y no val√≠a la pena mencionar otras tablas, a pesar de la comunidad bastante grande de cada una: <br><ul><li>  GameBuino META: </li><li>  Pokitto; </li><li>  makerBuino; </li><li>  Arduboy </li><li>  UzeBox / FuzeBox; </li><li>  y muchos otros </li></ul><br>  Para empezar, lo que no est√° en Esplora: <br><ul><li>  mucha memoria (ROM 28kb, RAM 2.5kb); </li><li>  potencia (CPU de 8 bits a 16 MHz); </li><li>  DMA </li><li>  generador de personajes; </li><li>  √°reas de memoria asignadas o registros especiales.  destino (paleta, azulejos, fondo, etc.); </li><li>  controla el brillo de la pantalla (oh, tantos efectos en la basura); </li><li>  extensores de espacio de direcciones (mapeadores); </li><li>  depurador (¬° <s>pero qui√©n lo necesita cuando hay una pantalla completa!</s> ). </li></ul><br>  Continuar√© con el hecho de que hay: <br><ul><li>  SPI de hardware (puede ejecutarse a velocidad F_CPU / 2); </li><li>  pantalla basada en ST7735 160x128 1.44 "; </li><li>  una pizca de temporizadores (solo 4 piezas); </li><li>  una pizca de GPIO; </li><li>  un pu√±ado de botones (5 piezas + joystick de dos ejes); </li><li>  pocos sensores (iluminaci√≥n, aceler√≥metro, term√≥metro); </li><li>  emisor de <s>irritaci√≥n</s> piezo zumbador. </li></ul><br>  Aparentemente no hay casi nada all√≠.  ¬°No es sorprendente que nadie quisiera hacer nada con ella excepto el clon de Pong y un par de tres juegos durante todo este tiempo! <br>  Quiz√°s el hecho es que escribir bajo el controlador ATmega32u4 (y similares) es similar a la programaci√≥n para Intel 8051 (que tiene casi 40 a√±os en el momento de la publicaci√≥n), donde debe observar una gran cantidad de condiciones y recurrir a varios trucos y trucos. <br><br><h3>  Procesamiento perif√©rico </h3><hr>  ¬°Uno para todo! <br><br>  Despu√©s de mirar el circuito, era claramente visible que todos los perif√©ricos est√°n conectados a trav√©s del expansor GPIO (multiplexor 74HC4067D m√°s MUX) y se conmutan usando GPIO PF4, PF5, PF6, PF7 o el mordisco PORTF senior, y la salida MUX se lee en GPIO - PF1. <br>  Es muy conveniente cambiar la entrada simplemente asignando valores al puerto PORTF por m√°scara y sin olvidar el mordisco menor: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> getAnalogMux(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> chMux) { MUX_PORTX = ((MUX_PORTX &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) | ((chMux&lt;&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0xF0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readADC(); }</code> </pre> <br>  Encuesta de clic de bot√≥n: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_MIN_LVL 800 bool readSwitchButton(uint8_t btn) { bool state = true; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(getAnalogMux(btn) &gt; SW_BTN_MIN_LVL) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// low state == pressed state = false; } return state; }</span></span></span></span></code> </pre><br>  Los siguientes son los valores para el puerto F: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_1_MUX 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_2_MUX 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_3_MUX 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_BTN_4_MUX 12</span></span></code> </pre><br>  Al agregar un poco m√°s: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_A SW_BTN_4_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_B SW_BTN_1_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_X SW_BTN_2_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUTTON_Y SW_BTN_3_MUX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> buttonIsPressed(a) readSwitchButton(a)</span></span></code> </pre><br>  Puede entrevistar con seguridad la cruz correcta: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateBtnStates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_A)) btnStates.aBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_B)) btnStates.bBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_X)) btnStates.xBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buttonIsPressed(BUTTON_Y)) btnStates.yBtn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Tenga en cuenta que el estado anterior no se restablece, de lo contrario, puede perderse el hecho de presionar la tecla (tambi√©n funciona como una protecci√≥n adicional contra el parloteo). <br><br><h3>  Sfx </h3><hr>  Un zumbido. <br><br>  ¬øQu√© pasa si no hay DAC, no hay chip de Yamaha, y solo hay un rect√°ngulo PWM de 1 bit para el sonido? <br>  Al principio, no parece tanto, pero, a pesar de esto, el astuto PWM se usa aqu√≠ para recrear la t√©cnica de "audio PDM" y con su ayuda puede hacerlo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">.</a> <br><br>  La biblioteca de Gamebuino proporciona algo similar y todo lo que se necesita es transferir el generador emergente a otro GPIO y el temporizador a Esplora (salida timer4 y OCR4D).  Para un funcionamiento correcto, el temporizador 1 tambi√©n se utiliza para generar interrupciones y volver a cargar el registro OCR4D con nuevos datos. <br><br>  El motor de Gamebuino usa patrones de sonido (como en la m√∫sica del rastreador), lo que ahorra mucho espacio, pero debe hacer todas las muestras usted mismo, no hay bibliotecas con las listas para usar. <br>  Vale la pena mencionar que este motor est√° vinculado a un per√≠odo de actualizaci√≥n de aproximadamente 1/50 segundos o 20 cuadros / segundo. <br><br>  Para leer patrones de sonido, despu√©s de leer el Wiki en formato de audio, dibuj√© una GUI simple en Qt.  No emite sonido de la misma manera, pero ofrece un concepto aproximado de c√≥mo sonar√° el patr√≥n y le permite cargarlo, guardarlo y editarlo. <br><br><h3>  Gr√°ficos </h3><hr>  Pixelart inmortal. <br><br>  La pantalla codifica los colores en dos bytes (RGB565), pero dado que las im√°genes en este formato ocupar√°n mucho, la paleta index√≥ todas ellas para ahorrar espacio, que ya he descrito m√°s de una vez en mis art√≠culos anteriores. <br>  A diferencia de Famicom / NES, no hay l√≠mites de color para la imagen y hay m√°s colores disponibles en la paleta. <br><br>  Cada imagen en el juego es una matriz de bytes en la que se almacenan los siguientes datos: <br><ul><li>  ancho, alto; </li><li>  iniciar marcador de datos; </li><li>  diccionario (si lo hay, pero m√°s sobre eso m√°s adelante); </li><li>  carga √∫til </li><li>  Fin del marcador de datos. </li></ul><br>  Por ejemplo, tal imagen (ampliada 10 veces): <br><img src="https://habrastorage.org/webt/zk/rr/es/zkrresh27swmtvck9fagoemando.png"><br><br>  en el c√≥digo se ver√° as√≠: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pic_t</span></span> weaponLaserPic1[] PROGMEM = { <span class="hljs-number"><span class="hljs-number">0x0f</span></span>,<span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x32</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0xad</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0x41</span></span>,<span class="hljs-number"><span class="hljs-number">0x22</span></span>,<span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x06</span></span>,<span class="hljs-number"><span class="hljs-number">0xa2</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-number"><span class="hljs-number">0x8f</span></span>,<span class="hljs-number"><span class="hljs-number">0x23</span></span>,<span class="hljs-number"><span class="hljs-number">0xff</span></span>, };</code> </pre><br>  ¬øD√≥nde sin un barco en este g√©nero?  Despu√©s de cientos de bocetos de prueba con una diferencia de p√≠xeles, solo quedaron estos barcos para el jugador: <br><img src="https://habrastorage.org/webt/ao/4y/jm/ao4yjmxt3bl3ydqrjajnmgy4ms8.png"><br>  Es de destacar que los barcos no tienen una llama en las baldosas (aqu√≠ est√° para mayor claridad), se aplica por separado para crear una animaci√≥n del escape del motor. <br><br>  No te olvides de los pilotos de cada barco: <br><img src="https://habrastorage.org/webt/fk/fj/xf/fkfjxfoscgeu69pabaolb4zt6mo.png"><br><br>  La variaci√≥n de las naves enemigas no es demasiado grande, pero d√©jame recordarte que no hay demasiado espacio, as√≠ que aqu√≠ hay tres naves: <br><img src="https://habrastorage.org/webt/w2/-v/o3/w2-vo3itdzkpoptpywwgjn5ytc8.png"><br><br>  Sin bonos can√≥nicos en la forma de mejorar las armas y restaurar la salud, el jugador no durar√° mucho: <br><img src="https://habrastorage.org/webt/kw/gw/7d/kwgw7duf5hnztuobgg_pwclk8nm.png"><br><br>  Por supuesto, con el aumento en el poder de las armas, el tipo de proyectiles emitidos cambia: <br><img src="https://habrastorage.org/webt/yq/dn/67/yqdn67u3cvbmzbn0j46v9iiievy.png"><br><br>  Como se escribi√≥ al principio, el juego tiene un nivel de asteroides, viene despu√©s de cada segundo jefe.  Es interesante porque hay muchos objetos m√≥viles y giratorios de diferentes tama√±os.  Adem√°s, cuando un jugador los golpea, colapsan parcialmente, volvi√©ndose m√°s peque√±os en tama√±o. <br><blockquote>  Sugerencia: los asteroides grandes ganan m√°s puntos. <br></blockquote><br><img src="https://habrastorage.org/webt/d6/hg/9a/d6hg9atxd8gzj9m9njyhac4i7bq.gif"><br><img src="https://habrastorage.org/webt/ow/pv/yf/owpvyfbgmn45yueagrafne4w2ng.gif"><br><img src="https://habrastorage.org/webt/jc/eh/r_/jcehr_zvccitvi24lcdmxiiewik.gif"><br>  Para crear esta animaci√≥n simple, 12 im√°genes peque√±as son suficientes: <br><img src="https://habrastorage.org/webt/yr/uz/g3/yruzg3mwjlg3bv_z2pljhzyql68.png"><br>  Se dividen en tres para cada tama√±o (grande, mediano y peque√±o) y para cada √°ngulo de rotaci√≥n necesita 4 m√°s rotados 0, 90, 180 y 270 grados.  En el juego, es suficiente reemplazar el puntero a la matriz con la imagen en un intervalo igual, creando as√≠ la ilusi√≥n de rotaci√≥n. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotateAsteroid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">asteroid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;asteroid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { asteroid.sprite.pPic = getAsteroidPic(asteroid); ++asteroid.angle; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveAsteroids</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;asteroid : asteroids) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(asteroid.onUse) { updateSprite(&amp;asteroid.sprite); rotateAsteroid(asteroid); ...</code> </pre><br>  Esto se hace solo debido a la falta de capacidades de hardware, y una implementaci√≥n de software como la transformaci√≥n Affine tomar√° m√°s que las im√°genes en s√≠ y ser√° muy lenta. <br><br><div class="spoiler">  <b class="spoiler_title">Un pedazo de sat√©n para los interesados.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/el/uf/0l/eluf0lkcjsygvumvmosh_yzreig.png"><br>  Puedes notar parte de los prototipos y lo que aparece solo en los cr√©ditos despu√©s de pasar el juego. <br></div></div><br>  Adem√°s de los gr√°ficos simples, para ahorrar espacio y agregar un efecto retro, los glifos en min√∫sculas y todos los glifos que ten√≠an hasta 30 y despu√©s de 127 bytes de ASCII fueron eliminados de la fuente. <br><blockquote>  Importante! <br>  No olvide que const y constexpr en AVR no significa en absoluto que los datos estar√°n en la memoria del programa, aqu√≠ para esto necesita usar PROGMEM adicionalmente. <br>  Esto se debe al hecho de que el n√∫cleo AVR se basa en la arquitectura de Harvard, por lo que se necesitan c√≥digos de acceso especiales para la CPU para acceder a los datos. <br></blockquote><br><h3>  Exprimiendo la galaxia </h3><hr>  La forma m√°s f√°cil de empacar es RLE. <br><br>  Despu√©s de estudiar los datos empaquetados, puede observar que no se utiliza el bit m√°s significativo en el byte de carga √∫til en el rango de 0x00 a 0x50.  Esto le permite agregar los datos y el marcador de inicio para el inicio de la repetici√≥n (0x80), y el siguiente byte para indicar el n√∫mero de repeticiones, lo que le permite empaquetar una serie de 257 (+2 por el hecho de que RLE de dos bytes es est√∫pido) de bytes id√©nticos en solo dos. <br>  Implementaci√≥n y visualizaci√≥n del desempacador: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_RLE_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpInd, repeatTimes; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); ++pPic; <span class="hljs-comment"><span class="hljs-comment">// make offset to picture data while((tmpInd = getPicByte(++pPic)) != PIC_DATA_END) { // get color index or repeat times if(tmpInd &amp; RLE_MARK) { // is it color index? tmpInd &amp;= DATA_MARK; // get color index to repeat repeatTimes = getPicByte(++pPic)+1; // zero RLE does not exist! } ++repeatTimes; // get color from colorTable by color index repeatColor = palette_RAM[(tmpInd == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpInd]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br>  Lo principal es no mostrar la imagen fuera de la pantalla, de lo contrario ser√° basura, ya que no hay verificaci√≥n de bordes aqu√≠. <br>  La imagen de prueba se descomprime en ~ 39 ms.  al mismo tiempo, ocupa 3040 bytes, mientras que sin compresi√≥n tomar√≠a 11,200 bytes o 22,400 bytes sin indexar. <br><br>  Imagen de prueba (ampliada 2 veces): <br><img src="https://habrastorage.org/webt/ao/nl/6n/aonl6nxjmfjhbsmp0uc4n6h7w0e.png"><br>  En la imagen de arriba puede ver el entrelazado, pero en la pantalla se suaviza por hardware, creando un efecto similar al CRT y al mismo tiempo aumentando significativamente la relaci√≥n de compresi√≥n. <br><br><h3>  RLE no es una panacea </h3><hr>  Somos tratados por deja vu. <br><br>  Como sabes, RLE va bien con los empacadores tipo LZ.  WiKi acudi√≥ al rescate con una lista de m√©todos de compresi√≥n.  El √≠mpetu fue el video de "GameHut" sobre el an√°lisis de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">introducci√≥n</a> imposible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Sonic 3D Blast.</a> <br>  Habiendo estudiado muchos empacadores (LZ77, LZW, LZSS, LZO, RNC, etc.), llegu√© a la conclusi√≥n de que sus desempacadores: <br><ul><li>  requieren mucha RAM para datos desempaquetados (al menos 64kb. y m√°s); </li><li>  voluminoso y lento (algunos necesitan construir √°rboles Huffman para cada subunidad); </li><li>  tener una baja relaci√≥n de compresi√≥n con una peque√±a ventana (requisitos de RAM muy estrictos); </li><li>  tener ambig√ºedades con las licencias. </li></ul><br>  Despu√©s de meses de adaptaciones in√∫tiles, se decidi√≥ modificar el empaquetador existente. <br>  Por analog√≠a con los empaquetadores tipo LZ, para lograr la m√°xima compresi√≥n, se utiliz√≥ el acceso al diccionario, pero a nivel de bytes: los pares de bytes repetidos con mayor frecuencia se reemplazan con un puntero de bytes en el diccionario. <br>  Pero hay una trampa: ¬øc√≥mo distinguir un byte de "cu√°ntas repeticiones" de un "marcador de diccionario"? <br>  Despu√©s de una larga sesi√≥n con un trozo de papel y un juego m√°gico con murci√©lagos, esto apareci√≥: <br><blockquote><ul><li>  El "marcador de diccionario" es un marcador RLE (0x80) + byte de datos (0x50) + n√∫mero de posici√≥n en el diccionario; </li><li>  limite el byte "cu√°ntas repeticiones" al tama√±o del marcador de diccionario - 1 (0xCF); </li><li>  el diccionario no puede usar el valor 0xff (es para el marcador del final de la imagen). </li></ul><br></blockquote><br>  Aplicando todo esto, obtenemos un tama√±o de diccionario fijo: no m√°s de 46 pares de bytes y reducci√≥n de RLE a 209 bytes.  Obviamente, no todas las im√°genes se pueden empaquetar as√≠, pero ya no se convertir√°n. <br>  En ambos algoritmos, la estructura de la imagen empaquetada ser√° la siguiente: <br><ul><li>  1 byte por ancho y alto; </li><li>  1 byte para el tama√±o del diccionario, es un puntero marcador al comienzo de los datos empaquetados; </li><li>  de 0 a 92 bytes del diccionario; </li><li>  1 a N bytes de datos empaquetados. </li></ul><br>  La utilidad de empaquetador resultante en D (pickoPacker) es suficiente para colocar en una carpeta con archivos indexados * .png y ejecutar desde la terminal (o cmd).  Si necesita ayuda, ejecute con la opci√≥n "-h" o "--help". <br>  Despu√©s de que se ejecuta la utilidad, obtenemos archivos * .h, cuyo contenido es conveniente para transferir al lugar correcto en el proyecto (por lo tanto, no hay protecci√≥n). <br><br>  Antes de desempacar, se preparan la pantalla, el diccionario y los datos iniciales: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawPico_DIC_P</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pPic)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpData = getPicSize(pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); tftSetAddrWindow(x, y, x+tmpData.u8Data1, y+tmpData.u8Data2); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tmpByte, unfoldPos, dictMarker; alphaReplaceColorId = getAlphaReplaceColorId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pDict = &amp;pPic[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// save dictionary pointer pPic += getPicByte(&amp;pPic[2]); // make offset to picture data do { unfoldPos = dictMarker = 0; do { if((tmpByte = getPicByte(++pPic)) != PIC_DATA_END) { if(tmpByte &lt; DICT_MARK) { buf_packed[unfoldPos] = tmpByte; } else { dictMarker = 1; setPicWData(&amp;buf_packed[unfoldPos]) = getPicWData(pDict, tmpByte); ++unfoldPos; } ++unfoldPos; } else { break; } } while((unfoldPos &lt; MAX_UNFOLD_SIZE) //&amp;&amp; (unfoldPos) &amp;&amp; ((tmpByte &gt; DATA_MARK) || (tmpByte &gt; MAX_DATA_LENGTH))); if(unfoldPos) { buf_packed[unfoldPos] = PIC_DATA_END; // mark end of chunk printBuf_RLE( dictMarker ? unpackBuf_DIC(pDict) : &amp;buf_packed[0] ); // V2V3 decoder } } while(unfoldPos); }</span></span></code> </pre><br>  Una pieza de datos le√≠da se puede empaquetar en un diccionario, por lo que lo revisamos y desempaquetamos: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPackedMark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptr &gt;= DICT_MARK) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*(++ptr) != PIC_DATA_END); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint8_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackBuf_DIC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pDict)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> swap = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dictMarker = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> getBufferPtr = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a[], <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b[]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> swap ? &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>] : &amp;b[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrP = getBufferPtr(buf_unpacked, buf_packed); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptrU = getBufferPtr(buf_packed, buf_unpacked); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(dictMarker) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP &gt;= DICT_MARK) { setPicWData(ptrU) = getPicWData(pDict, *ptrP); ++ptrU; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *ptrU = *ptrP; } ++ptrU; ++ptrP; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*ptrP == PIC_DATA_END) { *ptrU = *ptrP; <span class="hljs-comment"><span class="hljs-comment">// mark end of chunk swap = !swap; ptrP = getBufferPtr(buf_unpacked, buf_packed); ptrU = getBufferPtr(buf_packed, buf_unpacked); dictMarker = findPackedMark(ptrP); } } return getBufferPtr(buf_unpacked, buf_packed); }</span></span></code> </pre><br>  Ahora, desde el b√∫fer recibido, desempaquetamos RLE de una manera familiar y lo mostramos en la pantalla: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printBuf_RLE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> repeatColor; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> repeatTimes, tmpByte; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tmpByte = *pData) != PIC_DATA_END) { <span class="hljs-comment"><span class="hljs-comment">// get color index or repeat times if(tmpByte &amp; RLE_MARK) { // is it RLE byte? tmpByte &amp;= DATA_MARK; // get color index to repeat repeatTimes = *(++pData)+1; // zero RLE does not exist! } ++repeatTimes; ++pData; // get color from colorTable by color index repeatColor = palette_RAM[(tmpByte == ALPHA_COLOR_ID) ? alphaReplaceColorId : tmpByte]; do { pushColorFast(repeatColor); } while(--repeatTimes); } }</span></span></code> </pre><br>  Sorprendentemente, la sustituci√≥n del algoritmo no afect√≥ significativamente el tiempo de desempaquetado y es de ~ 47 ms.  Esto es casi 8 ms.  m√°s tiempo, ¬°pero la imagen de prueba solo toma 1650 bytes! <br><br><h3>  Hasta la ultima medida </h3><hr>  ¬°Casi todo se puede hacer m√°s r√°pido! <br><br>  A pesar de la presencia de SPI de hardware, el n√∫cleo AVR produce mucho dolor de cabeza cuando se usa. <br>  Desde hace tiempo se sabe que SPI en AVR, adem√°s de ejecutarse a velocidad F_CPU / 2, tambi√©n tiene un registro de datos de solo 1 byte (no es posible cargar 2 bytes a la vez). <br>  Adem√°s, casi todo el c√≥digo SPI en AVR que conoc√≠ funciona de acuerdo con este esquema: <br><ul><li>  Descargar datos SPDR </li><li>  interrogar el bit SPIF en el SPSR en un bucle. </li></ul><br>  Como puede ver, el suministro continuo de datos, como se hace en el STM32, no huele aqu√≠.  ¬°Pero, incluso aqu√≠, puede acelerar la salida de ambos desempacadores en ~ 3 ms! <br><br>  Al abrir la hoja de datos y mirar la secci√≥n "Relojes del conjunto de instrucciones", puede calcular los costos de CPU al transmitir un byte a trav√©s de SPI: <br><ul><li>  1 ciclo para cargar registros con nuevos datos; </li><li>  2 latidos por bit (o 16 latidos por byte); </li><li>  1 barra por l√≠nea de reloj m√°gica (un poco m√°s tarde sobre "NOP"); </li><li>  1 reloj para verificar el bit de estado en SPSR (o 2 relojes en la rama); </li></ul><br>  En total, para transmitir un p√≠xel (dos bytes), se deben gastar 38 ciclos de reloj o ~ 425600 ciclos de reloj para la imagen de prueba (11,200 bytes). <br>  Sabiendo que F_CPU == 16 MHz obtenemos <s>0.0000000625</s> 62.5 nanosegundos por ciclo de reloj ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Proceso0169</a> ), multiplicando los valores, obtenemos ~ 26 milisegundos.  Surge la pregunta: ‚Äú¬øDesde d√≥nde escrib√≠ antes que el tiempo de desempaque es de 39 ms?  y 47 ms.  Todo es simple: l√≥gica de desempaquetado + manejo de interrupciones. <br><br>  Aqu√≠ hay un ejemplo de salida de interrupci√≥n: <br><img src="https://habrastorage.org/webt/du/ks/p1/duksp1nkfluio5sgfwyimgo9aik.png"><br>  y sin interrupci√≥n: <br><img src="https://habrastorage.org/webt/v7/hp/xq/v7hpxqzhvsazrct5sbq7dkywq1w.png"><br>  Los gr√°ficos muestran que el tiempo entre la configuraci√≥n de la ventana de direcci√≥n en la pantalla VRAM y el comienzo de la transferencia de datos en la versi√≥n sin interrupciones es menor y casi no hay espacios entre bytes durante la transmisi√≥n (el gr√°fico es uniforme). <br>  Desafortunadamente, no puedes desactivar las interrupciones para cada salida de imagen, de lo contrario el sonido y el n√∫cleo de todo el juego se romper√°n (m√°s sobre eso m√°s adelante). <br><br>  Fue escrito anteriormente sobre un cierto "NOP m√°gico" para una l√≠nea de reloj.  El hecho es que para estabilizar el CLK y establecer el indicador SPIF, se necesita exactamente 1 ciclo de reloj y para cuando se lee este indicador, ya est√° configurado, lo que evita la ramificaci√≥n en 2 barras en la instrucci√≥n BREQ. <br>  Aqu√≠ hay un ejemplo sin un NOP: <br><img src="https://habrastorage.org/webt/vp/ia/w5/vpiaw5asga4dqawu3byh03k9gii.png"><br>  y con el <br><img src="https://habrastorage.org/webt/jg/-q/4b/jg-q4b4ot1sy445kc5rvoyq-ixe.png"><br><br>  La diferencia parece insignificante, solo unos pocos microsegundos, pero si toma una escala diferente: <br>  NOP grande: <br><img src="https://habrastorage.org/webt/nf/ds/gi/nfdsgii8xkar_f6jo5fihrpx8ei.png"><br>  y con ella demasiado grande: <br><img src="https://habrastorage.org/webt/8z/d9/e9/8zd9e9l79lnhj9qshrykzxxptmw.png"><br>  entonces la diferencia se hace mucho m√°s notable, llegando a ~ 4.3ms. <br><br>  Ahora hagamos el siguiente truco sucio: <br><blockquote>  Cambiamos el orden de carga y lectura de los registros y no puede esperar cada segundo byte del indicador SPIF, pero verif√≠quelo solo antes de cargar el primer byte del siguiente p√≠xel. <br></blockquote><br>  Aplicamos conocimiento e implementamos la funci√≥n "pushColorFast (repeatColor);": <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPDR_TX_WAIT(a) asm volatile(a); while((SPSR &amp; (1&lt;&lt;SPIF)) == 0); typedef union { uint16_t val; struct { uint8_t lsb; uint8_t msb; }; } SPDR_t; ... do { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_t in = {.val = repeatColor}; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); SPDR = in.msb; SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"nop"</span></span></span><span class="hljs-meta">); SPDR = in.lsb; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pushColorFast(repeatColor); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } while(--repeatTimes); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> ESPLORA_OPTIMIZE SPDR_TX_WAIT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// dummy wait to stable SPI #endif }</span></span></span></span></code> </pre><br>  A pesar de la interrupci√≥n del temporizador, el uso del truco anterior proporciona una ganancia de casi 6 ms. <br><img src="https://habrastorage.org/webt/ba/ah/hm/baahhmqnnvjznm1ssuihfi-ryhu.png"><br><br>  As√≠ es como el simple conocimiento del hierro le permite exprimir un poco m√°s y generar algo similar: <br><img src="https://habrastorage.org/webt/xo/fj/wv/xofjwvtbu_w_4leeunorug-axri.gif"><br><br><h3>  Colisiones del Coliseo </h3><hr>  La batalla de las cajas. <br><br>  Para empezar, todo el conjunto de objetos (barcos, proyectiles, asteroides, bonos) son estructuras (sprites) con los siguientes par√°metros: <br><ul><li>  coordenadas actuales X, Y; </li><li>  nuevas coordenadas X, Y; </li><li>  puntero a la imagen. </li></ul><br>  Como la imagen almacena el ancho y la altura, no es necesario duplicar estos par√°metros, adem√°s, dicha organizaci√≥n simplifica la l√≥gica en muchos aspectos. <br><br>  El c√°lculo en s√≠ mismo se simplifica al banal, basado en la intersecci√≥n de los rect√°ngulos.  Aunque no es lo suficientemente preciso y no calcula conflictos futuros, esto es m√°s que suficiente. <br>  La verificaci√≥n se realiza alternativamente en los ejes X e Y. Debido a esto, la ausencia de intersecci√≥n en el eje X reduce el c√°lculo de la colisi√≥n. <br><blockquote>  Primero, el lado derecho del primer rect√°ngulo con el lado izquierdo del segundo rect√°ngulo se verifica para la parte com√∫n del eje X. Si tiene √©xito, se realiza una verificaci√≥n similar para el lado izquierdo del primer y el lado derecho del segundo rect√°ngulo. <br>  Despu√©s de detectar con √©xito las intersecciones a lo largo del eje X, se realiza una verificaci√≥n de la misma manera para los lados superior e inferior de los rect√°ngulos a lo largo del eje Y. <br></blockquote><br>  Lo anterior parece mucho m√°s f√°cil de lo que parece: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSpriteCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprOne, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sprite_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pSprTwo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataOne = getPicSize(pSprOne-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tmpDataTwo = getPicSize(pSprTwo-&gt;pPic, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ----------- Check X position ----------- */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objOnePosEndX = (pSprOne-&gt;pos.Old.x + tmpDataOne.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(objOnePosEndX &gt;= pSprTwo-&gt;pos.Old.x) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> objTwoPosEndX = (pSprTwo-&gt;pos.Old.x + tmpDataTwo.u8Data1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pSprOne-&gt;pos.Old.x &gt;= objTwoPosEndX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// nope, different X positions } // ok, objects on same X lines; Go next... } else { return false; // nope, absolutelly different X positions } /* ---------------------------------------- */ /* ----------- Check Y position ----------- */ uint8_t objOnePosEndY = (pSprOne-&gt;pos.Old.y + tmpDataOne.u8Data2); if(objOnePosEndY &gt;= pSprTwo-&gt;pos.Old.y) { uint8_t objTwoPosEndY = (pSprTwo-&gt;pos.Old.y + tmpDataTwo.u8Data2); if(pSprOne-&gt;pos.Old.y &lt;= objTwoPosEndY) { // ok, objects on same Y lines; Go next... // yep, if we are here // then, part of one object collide wthith another object return true; } else { return false; // nope, different Y positions } } else { return false; // nope, absolutelly different Y positions } }</span></span></code> </pre><br>  Queda por agregar esto al juego: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkInVadersCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(aliens[<span class="hljs-number"><span class="hljs-number">0</span></span>].weapon.ray) gopher; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(alien.alive) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checkSpriteCollision(&amp;ship.sprite, &amp;alien.sprite)) { gopher.sprite.pos.Old = alien.sprite.pos.Old; rocketEpxlosion(&amp;gopher); <span class="hljs-comment"><span class="hljs-comment">// now make gopher to explode \(^_^)/ removeSprite(&amp;alien.sprite); alien.alive = false; score -= SCORE_PENALTY; if(score &lt; 0) score = 0; } } } }</span></span></code> </pre><br><br><h3>  Curva de Bezier </h3><hr>  Rieles espaciales. <br><br>  Como en cualquier otro juego con este g√©nero, las naves enemigas deben moverse a lo largo de las curvas. <br>  Se decidi√≥ implementar curvas cuadr√°ticas como las m√°s simples para el controlador y esta tarea.  Tres puntos son suficientes para ellos: el inicial (P0), el final (P2) y el imaginario (P1).  Los dos primeros especifican el principio y el final de la l√≠nea, el √∫ltimo punto describe el tipo de curvatura. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gran art√≠culo sobre curvas.</a> <br>  Como se trata de una curva param√©trica de Bezier, tambi√©n necesita un par√°metro m√°s: el n√∫mero de puntos intermedios entre los puntos inicial y final. <br><br>  Total obtenemos aqu√≠ tal estructura: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// 7 bytes position_t P0; position_t P1; position_t P2; uint8_t totalSteps; } bezier_t;</span></span></code> </pre>  En √©l, position_t es una estructura de dos bytes de coordenadas X e Y. <br>  Encontrar un punto para cada coordenada se calcula utilizando esta f√≥rmula (thx Wiki): <br>  B = ((1.0 - t) ^ 2) P0 + 2t (1.0 - t) P1 + (t ^ 2) P2, <br>  t [&gt; = 0 &amp;&amp; &lt;= 1] <br><br>  Durante mucho tiempo, su implementaci√≥n se resolvi√≥ de frente sin una matem√°tica de punto fijo: <br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pItemLine-&gt;step)/((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)pLine-&gt;totalSteps); pPos-&gt;x = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.x + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.x + t*t*pLine-&gt;P2.x; pPos-&gt;y = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P0.y + <span class="hljs-number"><span class="hljs-number">2</span></span>*t*(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - t)*pLine-&gt;P1.y + t*t*pLine-&gt;P2.y; ...</code> </pre><br>  Por supuesto, esto no se puede dejar.  Despu√©s de todo, deshacerse del flotador no solo podr√≠a mejorar la velocidad, sino tambi√©n liberar la ROM, por lo que se encontraron las siguientes implementaciones: <br><ul><li>  avrfix; </li><li>  stdfix; </li><li>  libfixmath; </li><li>  fixedptc. </li></ul><br>  El primero sigue siendo un caballo oscuro, ya que es una biblioteca compilada y no quer√≠a meterse con el desensamblador. <br><br>  El segundo candidato del paquete GCC tampoco funcion√≥, ya que el avr-gcc utilizado no fue parcheado y el tipo "short _Accum" no estuvo disponible. <br><br>  La tercera opci√≥n, a pesar de que tiene una gran cantidad de tapete.  funciones, tiene operaciones de bits codificadas en bits espec√≠ficos bajo el formato Q16.16, lo que hace que sea imposible controlar los valores de Q e I. <br><br>  Esta √∫ltima puede considerarse una versi√≥n simplificada de "matem√°ticas fijas", pero la principal ventaja es la capacidad de controlar no solo el tama√±o de la variable, que por defecto es de 32 bits con el formato Q24.8, sino tambi√©n los valores de Q e I. <br><br>  Resultados de la prueba en diferentes configuraciones: <br><table><tbody><tr><th>  Tipo </th><th>  IQ </th><th>  Banderas adicionales </th><th>  Byte ROM </th><th>  Tms. * </th></tr><tr><td>  flotar </td><td>  - </td><td>  - </td><td>  4236 </td><td>  35 </td></tr><tr><td>  matem√°tica fija </td><td>  16,16 </td><td>  - </td><td>  4796 </td><td>  119 </td></tr><tr><td>  matem√°tica fija </td><td>  16,16 </td><td>  FIXMATH_NO_OVERFLOW </td><td>  4664 </td><td>  89 </td></tr><tr><td>  matem√°tica fija </td><td>  16,16 </td><td>  FIXMATH_OPTIMIZE_8BIT </td><td>  5036 </td><td>  92 </td></tr><tr><td>  matem√°tica fija </td><td>  16,16 </td><td>  _NO_OVERFLOW + _8BIT </td><td>  4916 </td><td>  89 </td></tr><tr><td>  fixedptc </td><td>  24,8 </td><td>  FIXEDPT_BITS 32 </td><td>  4420 </td><td>  64 </td></tr><tr><td>  fixedptc </td><td>  9,7 </td><td>  FIXEDPT_BITS 16 </td><td>  3490 </td><td>  31 </td></tr></tbody></table>  * La verificaci√≥n se realiz√≥ en el patr√≥n: "195,175,145,110,170,70,170" y la tecla "-Os". <br><br>  Se puede ver en la tabla que ambas bibliotecas tomaron m√°s ROM y se mostraron peor que el c√≥digo compilado de GCC cuando se usaba flotante. <br>  Tambi√©n se ve que una peque√±a revisi√≥n para el formato Q9.7 y una disminuci√≥n de la variable a 16 bits dio una aceleraci√≥n de 4 ms.  y liberando ROM a ~ 50 bytes. <br><br>  El efecto esperado fue una disminuci√≥n en la precisi√≥n y un aumento en el n√∫mero de errores: <br><img src="https://habrastorage.org/webt/sz/v0/yt/szv0ytpsb0ogl5hkp39blbggvzw.png"><br>  que en este caso no es cr√≠tico. <br><br><h3>  Asignaci√≥n de recursos </h3><hr>  Los martes y jueves trabajan solo una hora. <br><br>  En la mayor√≠a de los casos, todos los c√°lculos se realizan en cada fotograma, lo que no siempre est√° justificado, ya que puede que no haya suficiente tiempo en el fotograma para acortar algo y tendr√° que enga√±ar alternando, contando fotogramas u omiti√©ndolos.  As√≠ que fui m√°s all√°: abandon√© por completo la dotaci√≥n de personal. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habiendo dividido todo en peque√±as tareas, ya sea: calcular colisiones, procesar sonido, botones y mostrar gr√°ficos, es suficiente realizarlas en un cierto intervalo, y la inercia del ojo y la capacidad de actualizar solo una parte de la pantalla har√°n el truco. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestionamos todo esto no una vez con el sistema operativo, sino con la m√°quina de estado que cre√© hace un par de a√±os o, m√°s simplemente, no con el gestor de tareas tinySM desplazado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repetir√© las razones para usarlo en lugar de cualquiera de los RTOS:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requisitos de ROM m√°s bajos (~ 250 bytes de n√∫cleo); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requisitos de RAM m√°s bajos (~ 9 bytes por tarea); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> principio de trabajo simple y comprensible; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> determinismo de comportamiento; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se pierde menos tiempo de CPU; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deja acceso al hierro; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plataforma independiente; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escrito en C y f√°cil de envolver en C ++; </font></font></li><li> <s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitaba mi propia bicicleta.</font></font></s> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como describ√≠ una vez, las tareas se organizan en una matriz de punteros a estructuras, donde se almacena un puntero a una funci√≥n y su intervalo de llamada. </font><font style="vertical-align: inherit;">Esta agrupaci√≥n simplifica la descripci√≥n del juego en etapas separadas, lo que tambi√©n le permite reducir el n√∫mero de ramas y cambiar din√°micamente el conjunto de tareas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, durante la pantalla de inicio, se realizan 7 tareas, y durante el juego ya hay 20 tareas (todas las tareas se describen en el archivo gameTasks.c). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero debe definir algunas macros para su conveniencia:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> T(a) a##Task #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_N(a) const taskParams_t T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK(a,b) TASK_N(a) PROGMEM = {.pFunc=a, .timeOut=b} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_P(a) (taskParams_t*)&amp;T(a) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR_N(a) const tasksArr_t a##TasksArr[] #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_ARR(a) TASK_ARR_N(a) PROGMEM #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TASK_END NULL</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La declaraci√≥n de tarea en realidad est√° creando una estructura, inicializando sus campos y coloc√°ndola en la ROM: </font></font><br><pre> <code class="cpp hljs">TASK(updateBtnStates, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada una de estas estructuras ocupa 4 bytes de ROM (dos por puntero y dos por intervalo). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una buena ventaja de las macros es que no funciona para crear m√°s de una estructura √∫nica para cada funci√≥n. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habiendo declarado las tareas necesarias, las agregamos a la matriz y tambi√©n las colocamos en la ROM:</font></font><br><pre> <code class="cpp hljs">TASK_ARR( game ) = { TASK_P(updateBtnStates), TASK_P(playMusic), TASK_P(drawStars), TASK_P(moveShip), TASK_P(drawShip), TASK_P(checkFireButton), TASK_P(pauseMenu), TASK_P(drawPlayerWeapon), TASK_P(checkShipHealth), TASK_P(drawSomeGUI), TASK_P(checkInVaders), TASK_P(drawInVaders), TASK_P(moveInVaders), TASK_P(checkInVadersRespawn), TASK_P(checkInVadersRay), TASK_P(checkInVadersCollision), TASK_P(dropWeaponGift), TASK_END };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al establecer el indicador USE_DYNAMIC_MEM en 0 para la memoria est√°tica, lo principal a recordar es inicializar los punteros al almac√©n de tareas en la RAM y establecer el n√∫mero m√°ximo de ellos que se ejecutar√°n: </font></font><br><pre> <code class="cpp hljs">... tasksContainer_t tasksContainer; taskFunc_t tasksArr[MAX_GAME_TASKS]; ... initTasksArr(&amp;tasksContainer, &amp;tasksArr[<span class="hljs-number"><span class="hljs-number">0</span></span>], MAX_GAME_TASKS); ‚Ä¶</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Establecer tareas para la ejecuci√≥n: </font></font><br><pre> <code class="cpp hljs">... addTasksArray_P(gameTasksArr); ‚Ä¶</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La protecci√≥n contra el desbordamiento se controla mediante el indicador USE_MEM_PANIC; si est√° seguro del n√∫mero de tareas, puede deshabilitarla para guardar la ROM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo queda ejecutar el controlador:</font></font><br><pre> <code class="cpp hljs">... runTasks(); ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dentro hay un bucle infinito que contiene la l√≥gica b√°sica. </font><font style="vertical-align: inherit;">Una vez dentro, la pila tambi√©n se restaura gracias a "__attribute__ ((noreturn))". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el bucle, los elementos de la matriz se analizan alternativamente en busca de la necesidad de llamar a la tarea despu√©s de que haya pasado el intervalo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cuenta regresiva de los intervalos se realiz√≥ sobre la base del temporizador 0 como un sistema con una cantidad de 1 ms ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesar de la distribuci√≥n exitosa de las tareas en el tiempo, a veces se superpon√≠an (jitter), lo que causaba un desvanecimiento a corto plazo de todo y todo en el juego. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definitivamente ten√≠a que decidirse, pero ¬øc√≥mo? </font><font style="vertical-align: inherit;">Acerca de c√≥mo se perfil√≥ todo la pr√≥xima vez, pero por ahora intente encontrar el huevo de Pascua en la fuente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El final </font></font></h3><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, usando muchos trucos (y muchos m√°s de los cuales no he descrito), todo result√≥ en una ROM de 24kb y 1500 bytes de RAM. </font><font style="vertical-align: inherit;">Si tiene alguna pregunta, me complacer√° responderla.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para aquellos que no encontraron o no buscaron un huevo de Pascua:</font></font></b> <div class="spoiler_text">   : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invadersMagicRespawn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br>   , ? <br><div class="spoiler"> <b class="spoiler_title">  invadersMagicRespawn:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ tftSetTextSize(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { tftSetCP437(RN &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>); tftSetTextColorBG((((RN % <span class="hljs-number"><span class="hljs-number">192</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFC</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>), COLOR_BLACK); tftDrawCharInt(((RN % <span class="hljs-number"><span class="hljs-number">26</span></span>) * <span class="hljs-number"><span class="hljs-number">6</span></span>), ((RN &amp; <span class="hljs-number"><span class="hljs-number">15</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>), (RN % <span class="hljs-number"><span class="hljs-number">255</span></span>)); tftPrintAt_P(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">58</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)creditP0); } } a(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;alien : aliens) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!alien.alive) { alien.respawnTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br>   ¬´(void)¬ª    ,  ¬´action()¬ª          10 ,    ¬´disablePause();¬ª.               ¬´Matrix Falling code¬ª    .       130  ROM. <br></div></div><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para compilar y ejecutar es suficiente poner la carpeta (o enlace) "esploraAPI" en "/ arduino / bibliotecas /". </font></font><br><br>  Referencias <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un juego</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esploraAPI;</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empacador de pickoPacker;</font></font></a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PD: Puedes ver y escuchar c√≥mo se ve todo un poco m√°s tarde cuando hago un video aceptable. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425407/">https://habr.com/ru/post/es425407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425395/index.html">10 datos f√≠sicos que deber√≠as haber sabido en la escuela pero que quiz√°s no sab√≠as</a></li>
<li><a href="../es425397/index.html">10 bibliotecas que todo desarrollador de Android deber√≠a conocer</a></li>
<li><a href="../es425401/index.html">Informe del Club de Roma 2018, Cap√≠tulo 1.11: Tecnolog√≠a disruptiva y la revoluci√≥n digital</a></li>
<li><a href="../es425403/index.html">Finanzas de creadores de Craigslist: sitio contra noticias falsas, discriminaci√≥n y excesos de gigantes de Internet</a></li>
<li><a href="../es425405/index.html">Novedades de gran poder</a></li>
<li><a href="../es425409/index.html">DevBoy: haciendo un generador de se√±al</a></li>
<li><a href="../es425411/index.html">Scrum est√° muerto</a></li>
<li><a href="../es425413/index.html">¬øSon tan buenos los joons?</a></li>
<li><a href="../es425415/index.html">Perl 5: como las macros ocultaron los errores</a></li>
<li><a href="../es425417/index.html">Flash para todos. Todos los arreglos flash de QSAN</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>