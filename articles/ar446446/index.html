<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📐 🥠 👌🏿 أساسيات محرك JavaScript: النماذج العامة والتخزين المؤقت المضمّن. الجزء 1 🏠 ✔️ ☁️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا اصدقاء في نهاية شهر أبريل ، أطلقنا دورة جديدة بعنوان "أمن نظم المعلومات" . والآن نريد أن نطلعكم على ترجمة المقال ، والتي ستكون بالتأكيد مفيدة لل...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>أساسيات محرك JavaScript: النماذج العامة والتخزين المؤقت المضمّن. الجزء 1</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/446446/" style=";text-align:right;direction:rtl">  مرحبا اصدقاء  في نهاية شهر أبريل ، أطلقنا دورة جديدة بعنوان <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"أمن نظم المعلومات"</a> .  والآن نريد أن نطلعكم على ترجمة المقال ، والتي ستكون بالتأكيد مفيدة للغاية للدورة.  يمكن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الاطلاع على</a> المقال الأصلي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> . <br><br>  توضح المقالة الأسس الرئيسية ، فهي مشتركة بين جميع محركات جافا سكريبت ، وليس فقط على الإصدار <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الثامن</a> ، الذي يعمل عليه مؤلفو المحرك ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بنديكت</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وماتياس</a> ).  كمطور جافا سكريبت ، أستطيع أن أقول إن الفهم العميق لكيفية عمل محرك جافا سكريبت سوف يساعدك على معرفة كيفية كتابة التعليمات البرمجية الفعالة. <br><br><img src="https://habrastorage.org/webt/14/ef/xe/14efxewawb3ttgslcsxyzicgjy0.png"><br><a name="habracut"></a><br><blockquote style=";text-align:right;direction:rtl">  <b>ملاحظة</b> : إذا كنت تفضل مشاهدة العروض التقديمية من قراءة المقالات ، فقم بمشاهدة هذا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الفيديو</a> .  إذا لم يكن كذلك ، ثم تخطي ذلك وقراءة. </blockquote>  <b>خط أنابيب (خط أنابيب) محرك جافا سكريبت</b> <br><br>  كل شيء يبدأ بحقيقة أن تكتب كود JavaScript.  بعد ذلك ، يقوم مشغل JavaScript بمعالجة الكود المصدري ويعرضه كشجرة بناء جملة مجردة (AST).  بناءً على AST المشيد ، يمكن للمترجم أخيرًا بدء العمل والبدء في إنشاء رمز ثانوي.  ! ممتاز  هذه هي اللحظة التي ينفذ فيها المحرك شفرة JavaScript. <br><br><img src="https://habrastorage.org/webt/i6/8r/f2/i68rf23urqlxa20gzhubwz2-snq.jpeg"><br><br>  لجعله يعمل بشكل أسرع ، يمكنك إرسال رمز الكود الثاني إلى برنامج التحويل البرمجي الأمثل مع بيانات ملفات التعريف.  يقوم المحول البرمجي المُحسّن بعمل افتراضات معينة استنادًا إلى بيانات ملفات التعريف ، ثم يُنشئ رمزًا محسنًا للغاية للماكينة. <br><br>  إذا كانت الافتراضات غير صحيحة في مرحلة ما ، فسيقوم برنامج التحويل البرمجي الأمثل بإلغاء تحسين الكود والعودة إلى مرحلة المترجم. <br><br>  <b>خطوط أنابيب مترجم / مترجم في محركات جافا سكريبت</b> <br><br>  الآن ، دعونا نلقي نظرة فاحصة على أجزاء خط الأنابيب التي تنفذ شفرة JavaScript ، أي حيث يتم تفسير الشفرة وتحسينها ، وكذلك إلقاء نظرة على بعض الاختلافات بين محركات JavaScript الرئيسية. <br><br>  في قلب كل شيء ، يوجد خط أنابيب يحتوي على مترجم ومترجم مثالي.  ينشئ المترجم الشفهي بسرعة رمزًا ثانويًا غير محسّن ، والمترجم المحسن ، بدوره ، يعمل لفترة أطول ، لكن الإخراج يحتوي على كود آلة محسن للغاية. <br><br><img src="https://habrastorage.org/webt/gh/ap/o6/ghapo68sxzyqniyjqw0v0xewpry.jpeg"><br><br>  التالي هو خط أنابيب يوضح كيفية عمل V8 ، محرك JavaScript المستخدم من قبل Chrome و Node.js. <br><br><img src="https://habrastorage.org/webt/8i/nu/0w/8inu0wkuzc8_enexkp8o7pn7jgi.jpeg"><br><br>  يُطلق على المترجم في V8 اسم Ignition ، وهو المسؤول عن إنشاء وتنفيذ الرمز الفرعي.  إنه يجمع بيانات ملفات التعريف التي يمكن استخدامها لتسريع التنفيذ في الخطوة التالية أثناء معالجة الرمز الثانوي.  عندما تصبح الوظيفة <i>ساخنة</i> ، على سبيل المثال ، في حالة بدء تشغيلها بشكل متكرر ، يتم نقل الرمز الثنائي الذي تم إنشاؤه وبيانات ملفات التعريف إلى TurboFan ، أي إلى برنامج التحويل البرمجي الأمثل لإنشاء رمز آلة محسّن للغاية استنادًا إلى بيانات ملفات التعريف. <br><br><img src="https://habrastorage.org/webt/ww/n5/zi/wwn5zi7l8vzzcfaik86qwhdtprc.jpeg"><br><br>  على سبيل المثال ، يعمل محرك SpiderMonkey JavaScript الخاص بـ Mozilla ، والذي يستخدم في Firefox و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">SpiderNode</a> ، بشكل مختلف قليلاً.  انها ليست واحدة ، ولكن اثنين من المجمعين الأمثل.  تم تحسين المترجم الشفوي إلى مترجم أساسي (مترجم Baseline) ، والذي ينتج عنه بعض التعليمات البرمجية المحسنة.  جنبا إلى جنب مع البيانات الشخصية التي تم جمعها أثناء تنفيذ التعليمات البرمجية ، يمكن لبرنامج التحويل البرمجي IonMonkey إنشاء رمز مُحسّن بشكل كبير.  إذا فشل تحسين المضاربة ، يعود IonMonkey إلى رمز Baseline. <br><br><img src="https://habrastorage.org/webt/gu/ek/ps/guekpsu0p1nqwv-pynj7ts8skdo.jpeg"><br><br>  Chakra - يحتوي محرك جافا سكريبت من Microsoft ، والمستخدم في Edge و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Node-ChakraCore</a> ، على بنية متشابهة للغاية ويستخدم اثنين <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">من المترجمين المحسنين</a> .  تم تحسين المترجم الفوري في SimpleJIT (حيث يرمز JIT إلى "مترجم Just-In-Time" ، والذي ينتج رمزًا محسّنًا إلى حد ما. بالإضافة إلى بيانات ملفات التعريف ، يمكن لـ FullJIT إنشاء كود محسّن بدرجة أكبر. <br><br><img src="https://habrastorage.org/webt/z-/bl/0v/z-bl0va0qlsrvgandnxrb08q52g.jpeg"><br><br>  يحتوي JavaScriptCore (يُشار إليه اختصارًا باسم JSC) ، وهو محرك جافا سكريبت من Apple يستخدمه Safari و React Native ، بشكل عام على ثلاثة برامج تجميع مختلفة مختلفة.  LLInt هو مترجم منخفض المستوى تم تحسينه إلى برنامج التحويل البرمجي الأساسي ، والذي بدوره تم تحسينه إلى برنامج التحويل البرمجي DFG (تدفق البيانات) ، وتم تحسينه بالفعل إلى برنامج التحويل البرمجي FTL (Faster Than Light). <br><br>  لماذا بعض المحركات لديها أكثر المجمعين الأمثل من غيرها؟  الأمر كله يتعلق بالتسويات.  يمكن للمترجم معالجة الرمز السري بسرعة ، لكن البايت كود وحده ليس فعالًا بشكل خاص.  المحول البرمجي الأمثل ، من ناحية أخرى ، يعمل لفترة أطول قليلاً ، لكنه ينتج رمز أكثر كفاءة للماكينة.  هذا حل وسط بين الحصول على الكود (المترجم الفوري) بسرعة أو بعض الانتظار وتشغيل الكود مع أقصى أداء (المحول البرمجي الأمثل).  تختار بعض المحركات إضافة العديد من برامج التحويل البرمجي المحسّنة ذات الخصائص المختلفة للوقت والكفاءة ، مما يتيح لك توفير أفضل تحكم في هذا الحل الوسط وفهم تكلفة المضاعفات الإضافية للجهاز الداخلي.  المفاضلة الأخرى هي استخدام الذاكرة ؛ تحقق من هذه <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المقالة</a> للحصول على فهم أفضل. <br><br>  لقد درسنا للتو الاختلافات الرئيسية بين خطوط أنابيب المترجم المحسن والمترجم لمحركات جافا سكريبت المختلفة.  على الرغم من هذه الاختلافات عالية المستوى ، فإن جميع محركات جافا سكريبت لديها نفس البنية: لديهم جميعها محللًا ونوعًا من خطوط أنابيب مترجم / مترجم. <br><br>  <b>نموذج كائن JavaScript</b> <br><br>  دعونا نرى ما هو مشترك بين محركات جافا سكريبت وما هي الحيل التي يستخدمونها لتسريع الوصول إلى خصائص كائنات جافا سكريبت؟  اتضح أن جميع المحركات الرئيسية تفعل ذلك بطريقة مماثلة. <br><br>  تعرّف مواصفات ECMAScript جميع الكائنات على أنها قواميس بمفاتيح سلسلة مطابقة لخصائص <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الخاصية</a> . <br><br><img src="https://habrastorage.org/webt/7s/vv/qq/7svvqqqqfcqi2y-v88nlstidtik.jpeg"><br><br>  بالإضافة إلى <code>[[Value]]</code> ، تحدد المواصفات الخصائص التالية: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <code>[[Writable]]</code> يحدد ما إذا كان يمكن إعادة تخصيص خاصية ؛ </li><li style=";text-align:right;direction:rtl">  <code>[[Enumerable]]</code> ما إذا كان يتم عرض الخاصية في حلقات for-in ؛ </li><li style=";text-align:right;direction:rtl">  <code>[[Configurable]]</code> يحدد ما إذا كان يمكن حذف خاصية. </li></ul><br>  يبدو الترقيم <code>[[  ]]</code> غريبًا ، لكن هكذا تصف المواصفات الخصائص في JavaScript.  لا يزال بإمكانك الحصول على سمات الخصائص هذه لأي كائن وخاصية محددة في JavaScript باستخدام واجهة برمجة تطبيقات <code>Object.getOwnPropertyDescriptor</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(object, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// → { value: 42, writable: true, enumerable: true, configurable: true }</span></span></code> </pre> <br>  حسنًا ، لذلك يقوم JavaScript بتعريف الكائنات.  ماذا عن المصفوفات؟ <br><br>  يمكنك أن تتخيل المصفوفات ككائنات خاصة.  الفرق الوحيد هو أن المصفوفات لديها معالجة فهرس خاص.  هنا ، يعد فهرس الصفيف مصطلحًا خاصًا في مواصفات ECMAScript.  يحتوي JavaScript على عدد العناصر في صفيف - ما يصل إلى 2³² - 1.  فهرس الصفيف هو أي فهرس متاح من هذا النطاق ، أي قيمة عددية صحيحة من 0 إلى 2³² - 2. <br><br>  الفرق الآخر هو أن المصفوفات لها خاصية <code>length</code> السحر. <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; array.length; <span class="hljs-comment"><span class="hljs-comment">// → 2 array[2] = 'c'; array.length; // → 3</span></span></code> </pre> <br>  في هذا المثال ، يبلغ طول الصفيف 2 في وقت الإنشاء.  ثم نخصص عنصرًا آخر للفهرس 2 ويزداد الطول تلقائيًا. <br><br>  يعرّف JavaScript الصفائف وكذلك الكائنات.  على سبيل المثال ، يتم تمثيل جميع المفاتيح ، بما في ذلك مؤشرات الصفيف ، صراحة كسلسلة.  يتم تخزين العنصر الأول للصفيف تحت المفتاح "0". <br><br><img src="https://habrastorage.org/webt/a0/nr/18/a0nr18etozy9wzmzzsd9zbykxt0.jpeg"><br><br>  خاصية <code>length</code> هي مجرد خاصية أخرى تبين أنها غير قابلة للتعداد وغير قابلة للتكوين. <br><br>  بمجرد إضافة عنصر إلى الصفيف ، يقوم JavaScript تلقائيًا بتحديث سمة الخاصية <code>[[Value]]</code> لخاصية <code>length</code> . <br><br><img src="https://habrastorage.org/webt/ws/hs/89/wshs896vflemplsrai-wqu5brkw.jpeg"><br><br>  بشكل عام ، يمكننا القول أن المصفوفات تتصرف بشكل مشابه للأشياء. <br><br>  <b>تعظيم الاستفادة من الوصول إلى الممتلكات</b> <br><br>  الآن بعد أن عرفنا كيف يتم تعريف الكائنات في JavaScript ، دعونا نلقي نظرة على كيفية السماح لمحركات JavaScript بالعمل مع الكائنات بكفاءة. <br><br>  في الحياة اليومية ، يعد الوصول إلى العقارات هو العملية الأكثر شيوعًا.  من المهم للغاية للمحرك القيام بذلك بسرعة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-string"><span class="hljs-string">'qux'</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">// Here, we're accessing the property `foo` on `object`: doSomething(object.foo); // ^^^^^^^^^^</span></span></code> </pre> <br>  <b>شكل</b> <br><br>  في برامج JavaScript ، من الممارسات الشائعة تعيين مفاتيح الخصائص نفسها للعديد من الكائنات.  يقولون أن مثل هذه الأشياء لها نفس <i>الشكل</i> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// `object1` and `object2` have the same shape.</span></span></code> </pre> <br>  أيضًا الميكانيكا الشائعة هي الوصول إلى خاصية الكائنات من نفس الشكل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object.x); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^ } const object1 = { x: 1, y: 2 }; const object2 = { x: 3, y: 4 }; logX(object1); logX(object2);</span></span></code> </pre> <br>  مع العلم بذلك ، يمكن لمحركات JavaScript تحسين الوصول إلى خاصية كائن بناءً على شكله.  انظر كيف يعمل <br><br>  لنفترض أن لدينا كائنًا بخصائص x و y ، يستخدم بنية بيانات القاموس ، التي تحدثنا عنها سابقًا ؛  أنه يحتوي على سلاسل المفاتيح التي تشير إلى سمات كل منها. <br><br><img src="https://habrastorage.org/webt/ss/ne/v9/ssnev9md3jko58annrfjraz35ay.jpeg"><br><br>  إذا قمت بالوصول إلى خاصية ، مثل <code>object.y,</code> يبحث محرك JavaScript عن JSObject باستخدام المفتاح <code>'y'</code> ، ثم يقوم بتحميل خصائص الخاصية التي تطابق هذا الاستعلام وتُرجع أخيرًا <code>[[Value]]</code> . <br><br>  ولكن أين يتم تخزين هذه الخصائص الملكية في الذاكرة؟  يجب علينا تخزينها كجزء من JSObject؟  إذا قمنا بذلك ، فسوف نرى المزيد من الكائنات من هذا النموذج لاحقًا ، وفي هذه الحالة ، يعد هدرًا للمساحة تخزين قاموس كامل يحتوي على أسماء الخصائص والسمات في JSObject نفسها ، نظرًا لتكرار أسماء الممتلكات لجميع الكائنات من نفس النموذج.  هذا يسبب الكثير من الازدواجية ويؤدي إلى سوء تخصيص الذاكرة.  للتحسين ، تخزن المحركات شكل الكائن بشكل منفصل. <br><br><img src="https://habrastorage.org/webt/mc/yr/mt/mcyrmt9jarqodgtvnwoxzatiwyy.jpeg"><br><br>  يحتوي هذا <code>Shape</code> على جميع أسماء الخصائص والسمات باستثناء <code>[[Value]]</code> .  بدلاً من ذلك ، يحتوي النموذج على قيم الإزاحة داخل JSObject ، بحيث يعرف مشغل JavaScript مكان البحث عن القيم.  يشير كل ملف JSObject بنموذج شائع إلى نسخة محددة من النموذج.  الآن يجب على كل JSObject تخزين القيم الفريدة للكائن فقط. <br><br><img src="https://habrastorage.org/webt/-0/-q/t5/-0-qt5an58iyuoeskzaibbtgcno.jpeg"><br><br>  ميزة تصبح واضحة بمجرد أن لدينا الكثير من الأشياء.  لا يهم عددهم ، لأنه إذا كان لديهم نموذج واحد ، فإننا نحفظ المعلومات حول النموذج والملكية مرة واحدة فقط. <br><br>  تستخدم جميع محركات JavaScript النماذج كوسيلة للتحسين ، لكنها لا تسميها مباشرة <code>shapes</code> : <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  الوثائق الأكاديمية تدعوهم "الفئات المخفية" (مماثلة لفئات جافا سكريبت) ؛ </li><li style=";text-align:right;direction:rtl">  V8 يدعوهم الخرائط. </li><li style=";text-align:right;direction:rtl">  شقرا يدعو لهم أنواع. </li><li style=";text-align:right;direction:rtl">  JavaScriptCore يدعو لهم الهياكل. </li><li style=";text-align:right;direction:rtl">  SpiderMonkey يطلق عليهم الأشكال. </li></ol><br>  في هذه المقالة ، ما زلنا نسميها <code>shapes</code> . <br><br>  <b>سلاسل الانتقال والأشجار</b> <br><br>  ماذا يحدث إذا كان لديك كائن ذو شكل معين ، لكنك أضفت خاصية جديدة إليه؟  كيف يحدد محرك JavaScript نموذجًا جديدًا؟ <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = {}; object.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; object.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  تخلق النماذج ما يسمى سلاسل الانتقال في مشغل JavaScript.  هنا مثال: <br><br><img src="https://habrastorage.org/webt/tm/tz/np/tmtznpiuyzkz9vpxqe6byhw2x-k.jpeg"><br><br>  الكائن في البداية ليس له خصائص ، فهو يتوافق مع نموذج فارغ.  يضيف التعبير التالي الخاصية <code>'x'</code> بالقيمة 5 إلى هذا الكائن ، ثم ينتقل المحرك إلى النموذج الذي يحتوي على الخاصية <code>'x'</code> وتضاف القيمة 5 إلى JSObject عند الإزاحة الأولى 0. يضيف السطر التالي الخاصية <code>'y'</code> ، ثم ينتقل المحرك إلى التالي نموذج يحتوي بالفعل على <code>'x'</code> و <code>'y'</code> ، ويضيف أيضًا القيمة 6 إلى JSObject عند الإزاحة 1. <br><blockquote style=";text-align:right;direction:rtl">  <b>ملاحظة</b> : التسلسل الذي تضاف به الخصائص يؤثر على النموذج.  على سبيل المثال ، سينتج {x: 4، y: 5} شكل مختلف عن {y: 5، x: 4}. <br></blockquote>  نحن لسنا بحاجة حتى لتخزين جدول الخصائص بأكمله لكل نموذج.  بدلاً من ذلك ، يحتاج كل نموذج إلى معرفة خاصية جديدة فقط يحاولون تضمينها فيها.  على سبيل المثال ، في هذه الحالة ، لا نحتاج إلى تخزين معلومات حول "x" في النموذج الأخير ، حيث يمكن العثور عليها مسبقًا في السلسلة.  لكي ينجح هذا ، يتم دمج النموذج مع النموذج السابق. <br><br><img src="https://habrastorage.org/webt/ks/ou/pv/ksoupve8bep3jsp0v7u2ahyv9jg.jpeg"><br><br>  إذا قمت بكتابة <code>ox</code> في شفرة JavaScript الخاصة بك ، فسوف يبحث JavaScript عن الخاصية <code>'x'</code> على طول سلسلة النقل حتى يكتشف نموذجًا يحتوي بالفعل على الخاصية <code>'x'</code> . <br><br>  ولكن ماذا يحدث إذا كان من المستحيل إنشاء سلسلة انتقالية؟  على سبيل المثال ، ماذا يحدث إذا كان لديك كائنين فارغين وقمت بإضافة خصائص مختلفة إليهما؟ <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; object2.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  في هذه الحالة ، يظهر فرع ، وبدلاً من سلسلة النقل ، نحصل على شجرة انتقال: <br><br><img src="https://habrastorage.org/webt/bc/ga/ax/bcgaaxeskfqwqt8geu_pxmqwdou.jpeg"><br><br>  ننشئ كائنًا فارغًا ونضيف الخاصية <code>'x'</code> .  نتيجة لذلك ، لدينا ملف <code>JSObject</code> يحتوي على قيمة واحدة <code>JSObject</code> : فارغ <code>JSObject</code> له خاصية <code>'x'</code> واحدة. <br><br>  المثال الثاني يبدأ بحقيقة أن لدينا كائنًا فارغًا <code>b</code> ، ولكن بعد ذلك نضيف خاصية أخرى <code>'y'</code> .  نتيجة لذلك ، هنا نحصل على سلسلتين من الأشكال ، لكن في النهاية نحصل على ثلاث سلاسل. <br><br>  هل هذا يعني أننا نبدأ دائمًا بنموذج فارغ؟  ليس بالضرورة.  تستخدم المحركات بعض التحسينات الحرفية للأشياء ، والتي تحتوي بالفعل على خصائص.  لنفترض أننا قمنا بإضافة x ، بدءًا من كائن فارغ حرفي ، أو لدينا كائن حرفي يحتوي بالفعل على <code>x</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> };</code> </pre> <br>  في المثال الأول ، نبدأ بنموذج فارغ وننتقل إلى سلسلة تحتوي أيضًا على <code>x</code> ، تمامًا كما رأينا سابقًا. <br><br>  في حالة <code>object2</code> من المنطقي إنشاء كائنات لها بالفعل x من البداية ، بدلاً من البدء بكائن فارغ وانتقال. <br><br><img src="https://habrastorage.org/webt/qv/_0/l-/qv_0l-f5eekqflfmto7lfd-awwq.jpeg"><br><br>  الحرفي للكائن الذي يحتوي على الخاصية <code>'x'</code> يبدأ بنموذج يحتوي على <code>'x'</code> من البداية ، ويتم تخطي النموذج الفارغ بشكل فعال.  هذا هو (على الأقل) ما يفعله V8 و SpiderMonkey.  يعمل التحسين على تقصير سلسلة النقل ويجعلها أكثر ملاءمة لتجميع الكائنات من القيم الحرفية. <br><br>  يتحدث <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">منشور</a> مدونة Benedict حول تعدد الأشكال المدهش للتطبيقات على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">React</a> حول كيفية تأثير هذه التفاصيل الدقيقة على الأداء. <br><br>  علاوة على ذلك ، سترى مثالًا لنقاط كائن ثلاثي الأبعاد مع الخصائص <code>'x'</code> و <code>'y'</code> و <code>'z'</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = {}; point.x = <span class="hljs-number"><span class="hljs-number">4</span></span>; point.y = <span class="hljs-number"><span class="hljs-number">5</span></span>; point.z = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  كما فهمت سابقًا ، فإننا ننشئ كائنًا به ثلاثة أشكال في الذاكرة (بدون حساب النموذج الفارغ).  للوصول إلى خاصية <code>'x'</code> لهذا الكائن ، على سبيل المثال ، إذا قمت بكتابة <code>point.x</code> في البرنامج ، فيجب أن يتبع محرك JavaScript قائمة مرتبطة: بدءًا من النموذج في أسفل الصفحة ، ثم الانتقال تدريجياً إلى النموذج الذي يحتوي على <code>'x'</code> في القمة. <br><br><img src="https://habrastorage.org/webt/tv/rn/mp/tvrnmp1s5p25dseplockgifr6x0.jpeg"><br><br>  اتضح ببطء شديد ، لا سيما إذا كنت تفعل ذلك في كثير من الأحيان مع وجود الكثير من خصائص الكائن.  وقت إقامة العقار هو <code>O(n)</code> ، أي أنها وظيفة خطية ترتبط بعدد خصائص الكائن.  لتسريع عمليات البحث عن العقارات ، تضيف محركات JavaScript بنية بيانات ShapeTable.  ShapeTable هو قاموس حيث يتم تعيين المفاتيح بطريقة معينة مع النماذج وإنتاج الخاصية المطلوبة. <br><br><img src="https://habrastorage.org/webt/y8/vh/40/y8vh40rwdlx99jdv-rpumbe1u3u.jpeg"><br><br>  انتظر ثانية ، الآن نعود إلى بحث القاموس ... هذا هو بالضبط ما بدأناه عندما نضع النماذج في المقام الأول!  إذن لماذا نهتم بالأشكال؟ <br>  والحقيقة هي أن النماذج تساهم في تحسين آخر يسمى " <i>ذاكرة التخزين المؤقت المضمنة".</i> <br><br>  سنتحدث عن مفهوم ذاكرة التخزين المؤقت المضمنة أو المرحلية في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الجزء الثاني من</a> المقالة ، والآن نريد دعوتك إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ندوة عبر الإنترنت مفتوحة مجانًا</a> ، والتي سيعقدها المحلل الفيروسي الشهير والمعلم غير المتفرغ ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ألكسندر كولسنيكوف</a> ، في 9 أبريل. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar446446/">https://habr.com/ru/post/ar446446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar446434/index.html">زيمبرا التعاون جناح التحجيم</a></li>
<li><a href="../ar446436/index.html">كيفية توليد فرضيات حول احتياجات المستهلكين المحتملين لمنتجك المستقبلي</a></li>
<li><a href="../ar446438/index.html">تجربة إنشاء بوابة API الخاصة بنا</a></li>
<li><a href="../ar446440/index.html">كتاب الرد السريع. تطبيقات الويب في React و JSX و Redux و GraphQL »</a></li>
<li><a href="../ar446444/index.html">من Skype إلى WebRTC: كيف نظمنا اتصالات فيديو الويب</a></li>
<li><a href="../ar446448/index.html">5 قواعد أساسية لإجراء مقابلات مع مشكلة لتحديد احتياجات المستهلك</a></li>
<li><a href="../ar446452/index.html">مهمة "Bereshit" على سطح القمر - في 4 أبريل 2019 ، تم الانتهاء من الانتقال إلى المدار القمري ، و 7 أيام من الرحلة ، و 6 مناورات ، وهبوط واحد</a></li>
<li><a href="../ar446454/index.html">Golang تطوير خادم الويب - من السهل إلى المجمع</a></li>
<li><a href="../ar446456/index.html">استبدال الواردات في الممارسة العملية. الجزء 1. الخيارات</a></li>
<li><a href="../ar446458/index.html">العالمي DRO على أساس اردوينو نانو - shDRO. الجزء 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>