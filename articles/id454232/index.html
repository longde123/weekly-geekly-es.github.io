<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍈 🌤️ 👨🏾‍🎓 OOP dalam bahasa pemrograman grafis. Bagian 2 MOS dan OOP 🖐🏽 ➡️ 🐙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian pertama, saya mencoba untuk menunjukkan bahwa kucing OOP hitam di ruang gelap bahasa grafis ada, bahkan jika itu bukan kucing, tetapi kuci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OOP dalam bahasa pemrograman grafis. Bagian 2 MOS dan OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454232/"><p>  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama,</a> saya mencoba untuk menunjukkan bahwa kucing OOP hitam di ruang gelap bahasa grafis ada, bahkan jika itu bukan kucing, tetapi kucing setengah mati dari flayer Schroedinger, yang artinya tidak.  Contoh implementasi metodologi pemrograman berorientasi objek ditunjukkan, ketika sebuah program bukan C ++ atau kode Java, tetapi diagram Simulink, SimInTech, SimulationX atau SCADE Esterel - setiap notasi grafis dari deskripsi algoritma. </p><br><p> Dalam materi iklan, Matlab Simulink sering menggunakan istilah MOS - desain berbasis model.  Dalam banyak teks, mereka menekankan bahwa diagram grafis dari algoritma adalah model, yang tentu saja benar.  Namun, dalam definisi awal MOS, model ini terutama merupakan model objek yang dikembangkan sistem kontrol, termasuk perangkat lunak kontrol.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lebih banyak metodologi MOS dijelaskan di sini.</a>  Jadi, ketika mengembangkan sistem kontrol sesuai dengan metodologi MOS, adalah mungkin dan perlu untuk menggunakan metodologi OOP untuk pengembangan perangkat lunak manajemen.  Dan untuk benar-benar menutup masalah dengan model, inilah gambar dengan perbedaan satu dari yang lain.  Jika semuanya jelas, maka Anda tidak bisa lagi membaca. </p><br><p><img width="700" src="https://habrastorage.org/webt/6q/lp/ti/6qlptikqb67uqw2kui8ejgydl7s.png"></p><br><a name="habracut"></a><br><p>  Mari kita kembali ke bahasa grafis dan OOP sebagaimana diterapkan untuk mengontrol program untuk industri.  Bahasa pemrograman grafis menyediakan catatan program dalam bentuk diagram dari serangkaian blok yang dihubungkan oleh jalur komunikasi.  Sebagai aturan, dalam pemrograman industri, kode untuk kompiler dan pemuatan berikutnya ke peralatan target dibuat dari sirkuit grafis oleh generator kode otomatis. </p><br><p>  Sebagai bagian dari spesialisasi saya, saya harus bekerja dengan mengelola perangkat lunak untuk pembangkit listrik tenaga nuklir di mana dilarang untuk menggunakan C ++ dengan standar keamanan, hanya C murni, dan dalam beberapa kasus bahkan tidak C, tetapi logika "besi", di mana algoritma diimplementasikan sebagai sirkuit elektronik pada transistor dan menyampaikan  Dan kepatuhan terhadap standar dipantau oleh para pengawas yang keras. </p><br><p><img width="700" src="https://habrastorage.org/webt/kt/cu/i1/ktcui1vz0x-4bn3uce7zntd40i0.jpeg"></p><br><p>  Tapi di sini, betapapun mengejutkannya kedengarannya, pengembangannya masih menggunakan metodologi OOP.  Karena ketika Anda tidak dapat menggunakan OOP, tetapi Anda benar-benar ingin, Anda bisa.  Benar, maka semuanya harus dikembalikan kembali, dan itu tidak akan menjadi C ++ dan kode akhir, untuk keamanan dan standar standar semua.  Seperti yang mereka katakan, makan ikan, dan tidak duduk untuk pelanggaran. </p><br><p>  Untuk membuat objek nyata dengan definisi OOP, kami mengikat struktur data dan skema pemrosesan menjadi satu objek, ini disebut enkapsulasi.  Dan karena kita tidak dapat menggunakan C ++ untuk sistem NPP yang andal, kita harus menguraikan semua ini saat membuat kode.  Seperti yang dijelaskan dalam komentar di artikel sebelumnya, kompiler C ++ Front pertama bekerja dengan cara yang sama, ia menerjemahkan kode OOP C ++ menjadi murni C. </p><br><p>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi pertama implementasi OOP</a> dalam bahasa grafis, kami membuat blok khusus yang berisi skema perhitungan grafis.  Selama inisialisasi, blok ini mengikat skema kelas (metode) ke "instance kelas" tertentu - satu set variabel yang dinamai dengan cara khusus. </p><br><p>  Pertimbangkan perwujudan kedua dari metodologi OOP dalam bahasa pemrograman grafis.  Gambar 1 menunjukkan operasi algoritma pemrosesan sensor. </p><br><p><img width="700" src="https://habrastorage.org/webt/zi/ci/3_/zici3_ssrtr7--y2enbtoa6flts.png"><br>  <i><font color="#999999">Gambar 1. Program pemrosesan sensor.</font></i> </p><br><p>  Ini adalah metode kelas.  Ini sesuai dengan kategori sendiri <b>"Sensor"</b> dalam database - kelas abstrak dengan seperangkat bidang yang diberikan dan instance dari sensor spesifik kelas <b>KBA31CFO1</b> .  Untuk sensor ini, bidang memiliki nilai tertentu, beberapa bidang ditetapkan oleh pengguna, beberapa bidang dihitung selama pelaksanaan program.  lihat gambar  2 </p><br><p><img width="700" src="https://habrastorage.org/webt/ht/ei/ct/hteict0a86fegqyvxgqhcllfebc.png"><br>  <i><font color="#999999">Gambar 2. Database sinyal dengan kategori terbuka "Sensor".</font></i> </p><br><p>  Sejauh ini, semuanya seperti pada perwujudan pertama, di mana kami membentuk pengikatan skema desain ke sensor tertentu saat memasang unit pada sirkuit.  "Di mana bedanya?"  - kamu bertanya.  Dan perbedaannya ada di dalam blok.  Jika dalam versi pertama ada diagram desain di dalamnya, yang disalin dengan setiap instalasi blok, maka dalam versi ini bagian dalamnya terlihat seperti ini: </p><br><p><img width="700" src="https://habrastorage.org/webt/7x/nx/hu/7xnxhufgyyih-wha7hqii0szr7o.png"><br>  <i><font color="#999999">Gambar 3. Interior dari instance blok dari instance kelas.</font></i> </p><br><p>  Alih-alih skema desain, hanya pengiriman dan penerimaan data yang "ditunjukkan" di dalam blok. <br>  Dan perhitungan itu sendiri terjadi di tempat lain, dalam diagram dari Gambar 1. Dalam beberapa kasus, dimungkinkan untuk tidak menggunakan blok sama sekali dalam diagram perhitungan, cukup untuk memiliki contoh kelas sensor dalam database tunggal.  Ini adalah cara kedua untuk mengimplementasikan enkapsulasi dalam bahasa grafis.  Kuncinya adalah bahwa semua blok dalam diagram pada Gambar 1 adalah vektorial, dan mereka memproses bukan satu sinyal, tetapi vektor sinyal dari semua sensor jenis ini dalam skema perhitungan.  Jika Anda mengaktifkan mode menampilkan hasil pada jalur komunikasi, maka kita akan melihat bahwa setiap jalur komunikasi tidak mengandung satu digit, tetapi vektor 4 angka (sesuai dengan jumlah sensor dalam database). </p><br><p><img width="700" src="https://habrastorage.org/webt/rt/2k/ml/rt2kmlwmldjmc8n4aqsorxtxqyc.png"><br>  <i><font color="#999999">Gambar 4. Diagram pemrosesan sinyal sensor dalam mode nilai tampilan.</font></i> </p><br><p>  Dengan demikian, satu skema pemrosesan mengimplementasikan pemrosesan semua sensor dalam proyek, dengan masing-masing sensor diproses dengan parameternya sendiri yang ditentukan dalam database sebagai karakteristik instance kelas tertentu.  Sebagai contoh, limiter mengambil nilai maksimum dari database, yang ditetapkan sama untuk tiga sensor pertama dan berbeda untuk yang keempat.  (lihat gambar 5) </p><br><p><img width="450" src="https://habrastorage.org/webt/zf/fk/q_/zffkq_axhvogvctwlxrqfsat2cg.png"><br>  <i><font color="#999999">Gambar 5. Parameter blok limiter dalam skema perhitungan.</font></i> </p><br><p>  Dan bagaimana dengan kode yang dihasilkan, yang secara otomatis dihasilkan sesuai dengan skema luar biasa ini, bagaimana Anda mengatur untuk menghindari artefak OOP?  Ini sederhana: tidak ada kecurangan dan tidak ada OOP, C murni dalam kode.  Untuk setiap blok skema pemrosesan vektor, siklus akan dibentuk yang menyediakan banyak perhitungan karena ada instance kelas dalam proyek.  Dalam kasus kami, ada 4 sensor, jadi pertama-tama kami membentuk array dimensi "4" dengan membaca sinyal dari sensor: </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Index=104 UID=104 GeneratorClassName=TSignalReader Name=buz1.sensor.Macro6.Macro3.Macro157.SignalReader3 Type=    */</span></span> }; state_vars-&gt;kbastdv104_out_0_[<span class="hljs-number"><span class="hljs-number">0</span></span>] = kba31cf001_mf_type; state_vars-&gt;kbastdv104_out_0_[<span class="hljs-number"><span class="hljs-number">1</span></span>] = kba32cf001_mf_type; state_vars-&gt;kbastdv104_out_0_[<span class="hljs-number"><span class="hljs-number">2</span></span>] = kba33cf001_mf_type; state_vars-&gt;kbastdv104_out_0_[<span class="hljs-number"><span class="hljs-number">3</span></span>] = uf40y329084320_mf_type</code> </pre> <br><p>  Lalu kami mengurutkan semua blok secara berurutan dan menjalankannya dalam satu lingkaran.  Untuk setiap elemen array tipe, setiap blok perhitungan akan dilakukan untuk semua sensor. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Index=211 UID=211 GeneratorClassName=TAndSrc Name=buz1.sensor.Macro6.And61 Type=  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>;i++){ locals-&gt;v211_out_0_[i] = state_vars-&gt;kbastdv125_out_0_[i] &amp;&amp; (!(locals-&gt;v191_out_7_[i] &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/* Index=212 UID=212 GeneratorClassName=TMulDbl Name=buz1.sensor.Macro6.Mul_oper1 Type= */</span></span> locals-&gt;v209_out_2_[i] = consts-&gt;kbastdv121_a_[i]*state_vars-&gt;kbastdv127_out_0_[i]; <span class="hljs-comment"><span class="hljs-comment">/* Index=213 UID=213 GeneratorClassName=TSumSrc Name=buz1.sensor.Macro6.Add_oper1 Type= */</span></span> locals-&gt;v209_out_3_[i] = (<span class="hljs-number"><span class="hljs-number">1</span></span>)*consts-&gt;kbastdv122_a_[i]+(<span class="hljs-number"><span class="hljs-number">1</span></span>)*locals-&gt;v209_out_2_[i]; … }</code> </pre><br>  Setelah perhitungan, kami merekam sinyal untuk setiap instance kelas: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Index=776 UID=776 GeneratorClassName=TSignalWriter Name=buz1.sensor.Macro6.Macro3.SignalWriter4 Type=    */</span></span> kba31cf001_mf_xb01 = state_vars-&gt;kbastdv207_out_0_[<span class="hljs-number"><span class="hljs-number">0</span></span>]; kba32cf001_mf_xb01 = state_vars-&gt;kbastdv207_out_0_[<span class="hljs-number"><span class="hljs-number">1</span></span>]; kba33cf001_mf_xb01 = state_vars-&gt;kbastdv207_out_0_[<span class="hljs-number"><span class="hljs-number">2</span></span>]; uf40y329084320_mf_xb01 = state_vars-&gt;kbastdv207_out_0_[<span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre><br><p>  Seperti yang Anda lihat, tidak ada objek dalam kode akhir.  SI bersih, polos dan aman.  Dalam contoh di atas, implementasi OOP dalam bahasa grafis, rangkaian vektor menghitung semua sensor dari jenis yang sama.  Teknik ini memungkinkan Anda mengubah satu skema untuk mengubah pemrosesan semua sensor. </p><br><p>  Manfaat tambahan lain dari pendekatan ini adalah asuransi kesalahan.  Bayangkan: Anda secara manual menambahkan sensor dan di satu tempat Anda lupa menambah jumlah pengulangan selama pemrosesan dalam satu siklus.  Tidak ada penganalisa kode statis yang dapat mendeteksi kesalahan ini, kodenya benar.  Dan bahkan di tempat kerja ini mungkin tidak mempengaruhi dengan segera dan dengan cara yang jelas. </p><br><p>  Pada akhirnya, polimorfisme dan warisan yang dijanjikan.  Dalam metode pertama, pengguna menerima banyak skema identik, yang dapat diedit setelah menginstal blok submodel dan, dengan demikian, melakukan polimorfisme, mengubah perilaku instance kelas tertentu.  Saya pikir semua orang menduga bahwa mungkin untuk mengubah skema pemrosesan untuk sensor tertentu, dan kami akan mendapatkan kelas baru yang memiliki bidang yang sama, tetapi metodenya berbeda.  Anda juga bisa menambahkan bidang baru dan mendapatkan kelas baru dengan bidang berbeda yang berisi semua bidang induk dan metode induk. </p><br><p>  Gambar 6 menunjukkan contoh dua blok kelas "induk" dan "pewaris".  Di dalam blok, skema perhitungan kelas induk disimpan.  Semua data pergi ke blok vektor umum, mirip dengan blok pada Gambar.  4. Metode kelas induk diulangi sepenuhnya.  Dan kemudian kelas penerus memiliki <b>Yatm</b> bidang tambahan dan perhitungan kembali nilai tambahan menggunakan blok interpolasi linier. </p><br><p>  Dengan demikian, tetap dimungkinkan untuk mengubah metode pemrosesan induk, yang akan berubah di semua kelas-ahli waris, serta secara individual menyesuaikan perilaku ahli waris. </p><br><p><img width="700" src="https://habrastorage.org/webt/cj/uf/fl/cjufflnh6w6vxom0ihlevs34vf0.png"><br>  <i><font color="#999999">Gambar 6. Polimorfisme pada ahli waris kelas.</font></i> </p><br><p>  Untuk meringkas, kami dapat berpendapat bahwa metodologi OOP dapat digunakan untuk membuat perangkat lunak dalam bahasa pemrograman grafis.  Abstraksi, enkapsulasi, pewarisan, polimorfisme - semua prinsip ini mudah dan alami diimplementasikan oleh alat pengembangan yang tepat.  Penting untuk dicatat bahwa kode akhir, setelah pembuatan otomatis dari bahasa grafis, tetap murni aman C tanpa OOP </p><br><p>  Dalam beberapa kasus, hasil pengembangan perangkat lunak kontrol dalam bentuk grafis bukan kode C untuk memuat ke controller, tetapi diagram sirkuit "logika besi", tetapi teknik yang dijelaskan di atas OOP juga berfungsi dengan baik. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454232/">https://habr.com/ru/post/id454232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454216/index.html">Bukti yang ditemukan bahwa semua perubahan adalah campuran urutan dan peluang</a></li>
<li><a href="../id454220/index.html">Termometer dua digit</a></li>
<li><a href="../id454222/index.html">Mutakhirkan subsistem disk server lama dengan bus PCIe 1.0 - 2.0</a></li>
<li><a href="../id454224/index.html">Rekomendasi di Okko: cara mendapatkan ratusan juta dengan mengalikan beberapa matriks</a></li>
<li><a href="../id454226/index.html">Memori pada domain magnetik silindris. Bagian 1. Prinsip kerja</a></li>
<li><a href="../id454240/index.html">Analisis wavelet. Bagian 3</a></li>
<li><a href="../id454242/index.html">"Lihat, apa jetpack yang kumiliki!" "Ha, lihat roket yang kumiliki!" (catatan dari kejuaraan roket)</a></li>
<li><a href="../id454246/index.html">Varietas koordinat yang digunakan dalam GUI Unity3d</a></li>
<li><a href="../id454248/index.html">Budak di era kecerdasan buatan</a></li>
<li><a href="../id454252/index.html">Bahkan sumber daya web dari organisasi terkenal tidak dilindungi dari kesalahan anak-anak.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>