<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ³ ğŸ–•ğŸ¿ â¤µï¸ Jaringan di Android menggunakan Corutin dan Retrofit ğŸ“ ğŸ¤›ğŸ» â™’ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semakin saya membaca dan menonton laporan coroutine di Kotlin, semakin saya mengagumi alat bahasa ini. Rilis stabil mereka baru-baru ini dirilis di Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jaringan di Android menggunakan Corutin dan Retrofit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428994/"><p>  Semakin saya membaca dan menonton laporan coroutine di Kotlin, semakin saya mengagumi alat bahasa ini.  Rilis stabil mereka baru-baru ini dirilis di Kotlin 1.3, yang berarti sudah saatnya untuk memulai penyelaman dan mencoba coroutine dalam aksi menggunakan kode RxJava saya yang ada sebagai contoh.  Dalam posting ini, kita akan fokus pada bagaimana mengambil permintaan jaringan yang ada dan mengonversinya dengan mengganti RxJava dengan coroutine. </p><br><p><img src="https://habrastorage.org/webt/h-/7v/mt/h-7vmtalbemnlfsu3g8hto3x2la.png"></p><a name="habracut"></a><br><p>  Terus terang, sebelum saya mencoba coroutine, saya pikir mereka sangat berbeda dari sebelumnya.  Namun, prinsip dasar corutin mencakup konsep yang sama yang kita gunakan dalam aliran reaktif RxJava.  Sebagai contoh, mari kita ambil konfigurasi RxJava sederhana untuk membuat permintaan jaringan dari salah satu aplikasi saya: </p><br><ul><li>  Kami mendefinisikan antarmuka jaringan untuk Retrofit menggunakan adaptor Rx ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">retrofit2: adaptor-rxjava2</a> ).  Fungsi akan mengembalikan objek dari framework Rx, seperti <strong>Single</strong> atau <strong>Observable</strong> .  (Fungsi digunakan di sini dan bukan metode, karena diasumsikan bahwa kode lama juga ditulis di Kotlin. Nah, atau dikonversi dari Jawa melalui Android Studio). </li><li>  Kami memanggil fungsi tertentu dari kelas lain (misalnya, repositori, atau aktivitas). </li><li>  Kami menentukan utas untuk Penjadwal mana mereka akan dieksekusi dan mengembalikan hasilnya (metode <strong>.subscribeOn ()</strong> dan <strong>.observeOn ()</strong> ). </li><li>  Kami menyimpan tautan ke objek untuk berhenti berlangganan (misalnya, di CompositeObservable). </li><li>  Berlangganan aliran acara. </li><li>  Berhenti berlangganan dari aliran tergantung pada peristiwa dari siklus hidup Aktivitas. </li></ul><br><p>  Ini adalah algoritma dasar untuk bekerja dengan Rx (tidak memperhitungkan fungsi pemetaan dan rincian manipulasi data lainnya).  Sedangkan untuk corutin, prinsipnya tidak banyak berubah.  Konsep yang sama, hanya terminologi yang berubah. </p><br><ul><li>  Kami mendefinisikan antarmuka jaringan untuk Retrofit menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adaptor untuk coroutine</a> .  Fungsi akan mengembalikan objek yang <strong>Ditangguhkan</strong> dari API Corutin. </li><li>  Kami memanggil fungsi-fungsi ini dari kelas lain (misalnya, repositori, atau aktivitas).  Satu-satunya perbedaan: setiap fungsi harus ditandai sebagai <strong>ditangguhkan</strong> . </li><li>  Tentukan dispatcher yang akan digunakan untuk coroutine. </li><li>  Kami menyimpan tautan ke objek <strong>Pekerjaan</strong> untuk berhenti berlangganan. </li><li>  Jalankan coroutine dengan cara apa pun yang memungkinkan. </li><li>  Kami membatalkan coroutine tergantung pada peristiwa dari siklus hidup Kegiatan. </li></ul><br><p>  Seperti yang Anda lihat dari urutan di atas, proses eksekusi Rx dan Corutin sangat mirip.  Jika kami tidak memperhitungkan detail implementasi, ini berarti kami dapat mempertahankan pendekatan yang kami miliki - kami hanya mengganti beberapa hal untuk menjadikan implementasi kami ramah-coroutine. </p><br><p><img src="https://habrastorage.org/webt/rx/wm/xt/rxwmxtqqqcz0_wsvmjl8tjmel7m.png"></p><br><p>  Langkah pertama yang harus kita ambil adalah mengizinkan Retrofit mengembalikan objek yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditangguhkan</a> .  Objek yang ditangguhkan adalah berjangka non-pemblokiran yang dapat dibatalkan jika perlu.  Objek-objek ini pada dasarnya adalah Pekerjaan coroutine, yang berisi nilai untuk pekerjaan yang sesuai.  Menggunakan tipe Deferred memungkinkan kita untuk mencampurkan ide yang sama dengan Job, dengan tambahan kemampuan untuk mendapatkan status tambahan, seperti keberhasilan atau kegagalan - yang membuatnya ideal untuk permintaan jaringan. </p><br><p>  Jika Anda menggunakan Retrofit dengan RxJava, Anda mungkin menggunakan Pabrik Adaptor Panggilan RxJava.  Untungnya, Jake Worton menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">padanannya untuk coroutine</a> . </p><br><p>  Kita dapat menggunakan adaptor panggilan ini di pembuat Retrofit, dan kemudian mengimplementasikan antarmuka Retrofit kami dengan cara yang sama seperti dengan RxJava: </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(okHttpClient: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">OkHttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: MyService { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> retrofit = Retrofit.Builder() .baseUrl(<span class="hljs-string"><span class="hljs-string">"some_api"</span></span>) .client(okHttpClient) .addCallAdapterFactory(CoroutineCallAdapterFactory()) .build() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrofit.create(MyService::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p>  Sekarang mari kita lihat antarmuka MyService, yang digunakan di atas.  Kita harus mengganti tipe yang dapat diobservasi yang dikembalikan dengan Ditangguhkan di antarmuka Retrofit.  Jika dulu seperti ini: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"some_endpoint"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;List&lt;MyData&gt;&gt;</code> </pre> <br><p>  Sekarang kita ganti dengan: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"some_endpoint"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Deferred&lt;List&lt;MyData&gt;&gt;</code> </pre> <br><p>  Setiap kali kita memanggil getData (), objek Ditangguhkan akan kembali kepada kita - analog dari permintaan Ayub untuk jaringan.  Sebelumnya, kami entah bagaimana menyebut fungsi ini dengan RxJava: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;List&lt;MyData&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> myService.getData() .map { result -&gt; result.map { myDataMapper.mapFromRemote(it) } } }</code> </pre> <br><p>  Dalam aliran RxJava ini, kami memanggil fungsi utilitas kami, kemudian menerapkan operasi peta dari API RxJava dengan pemetaan data yang dikembalikan dari permintaan ke sesuatu yang digunakan di lapisan UI.  Ini akan sedikit berubah ketika kita menggunakan implementasi dengan coroutine.  Sebagai permulaan, fungsi kita harus <strong>ditunda</strong> (ditangguhkan), untuk melakukan operasi yang malas di dalam tubuh fungsi.  Dan untuk ini, fungsi panggilan juga harus ditangguhkan.  Fungsi yang ditangguhkan adalah non-blocking, dan dapat dikontrol setelah awalnya disebut.  Anda dapat memulainya, menjeda, melanjutkan atau membatalkannya. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { ... }</code> </pre> <br><p>  Sekarang kita harus memanggil fungsi utilitas kita.  Pada pandangan pertama, kita melakukan hal yang sama, tetapi kita harus ingat bahwa sekarang kita <strong>ditangguhkan</strong> alih-alih <strong>diamati</strong> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData() ... }</code> </pre> <br><p>  Karena perubahan ini, kami tidak dapat lagi menggunakan rantai operasi peta dari RxJava API.  Dan bahkan pada titik ini, data tidak tersedia bagi kami - kami hanya memiliki instance Deferred.  Sekarang kita harus menggunakan fungsi <strong>await ()</strong> untuk menunggu hasil dari query dan kemudian melanjutkan untuk mengeksekusi kode di dalam fungsi: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData().await() ... }</code> </pre> <br><p>  Pada titik ini, kami mendapatkan permintaan yang lengkap dan data darinya tersedia untuk digunakan.  Karena itu, kami sekarang dapat melakukan operasi pemetaan: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;MyData&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = myService.getData().await() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.map { myDataMapper.mapFromRemote(it) } }</code> </pre> <br><p>  Kami mengambil antarmuka Retrofit kami bersama dengan kelas panggilan dan menggunakan coroutine.  Sekarang kami ingin memanggil kode ini dari Aktivitas atau fragmen kami dan menggunakan data yang kami dapatkan dari jaringan. </p><br><p>  Dalam Aktivitas kami, kami akan mulai dengan membuat tautan ke Ayub, di mana kami dapat menetapkan operasi coroutine kami dan kemudian menggunakannya untuk mengontrol, misalnya, membatalkan permintaan, selama panggilan <strong>onDestroy ()</strong> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myJob: Job? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { myJob?.cancel() <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() }</code> </pre> <br><p>  Sekarang kita dapat menetapkan sesuatu ke variabel myJob.  Mari kita lihat permintaan kami dengan coroutine: </p><br><pre> <code class="hljs pgsql">myJob = CoroutineScope(Dispatchers.IO).launch { val result = repo.getLeagues() withContext(Dispatchers.Main) { //<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> result } }</code> </pre> <br><p>  Dalam posting ini, saya tidak ingin menyelidiki Dispatcher atau melakukan operasi dalam coroutine, karena ini adalah topik untuk posting lain.  Singkatnya, apa yang terjadi di sini: </p><br><ul><li>  Buat instance CoroutineScope menggunakan IO Dispatcher sebagai parameter.  Dispatcher ini digunakan untuk melakukan pemblokiran operasi I / O, seperti permintaan jaringan. </li><li>  Kami meluncurkan coroutine kami dengan fungsi <strong>peluncuran</strong> - fungsi ini meluncurkan coroutine baru dan mengembalikan tautan ke variabel tipe Job. </li><li>  Kemudian kami menggunakan tautan ke repositori kami untuk menerima data dengan melakukan permintaan jaringan. </li><li>  Pada akhirnya, kami menggunakan operator utama untuk melakukan pekerjaan pada utas UI.  Di sini kita dapat menampilkan data yang diterima kepada pengguna. </li></ul><br><p>  Dalam posting berikutnya, penulis berjanji untuk menggali sedikit lebih dalam ke detail, tetapi bahan saat ini harus cukup untuk mulai mempelajari coroutine. </p><br><p>  Dalam posting ini, kami mengganti implementasi RxJava dari respons Retrofit dengan objek <strong>Ditangguhkan</strong> dari API Corutin.  Kami memanggil fungsi-fungsi ini untuk menerima data dari jaringan, dan kemudian menampilkannya dalam aktivitas kami.  Saya harap Anda melihat betapa sedikit perubahan yang perlu Anda lakukan untuk memulai dengan coroutine, dan menghargai kesederhanaan API, terutama ketika membaca dan menulis kode. </p><br><p>  Dalam komentar di posting asli, saya menemukan permintaan tradisional: tampilkan seluruh kode.  Oleh karena itu, saya membuat aplikasi sederhana yang, pada saat startup, mendapatkan jadwal kereta api dengan Yandex. Schedule API dan menampilkannya di RecyclerView.  Tautan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/AndreySBer/RetrofitCoroutinesExample</a> </p><br><p>  Saya juga ingin menambahkan bahwa coroutine tampaknya menjadi pengganti yang lebih rendah untuk RxJava, karena mereka tidak menawarkan serangkaian operasi yang setara untuk menyinkronkan utas.  Dalam hal ini, perlu melihat implementasi ReactiveX untuk Kotlin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxKotlin</a> . </p><br><p>  Jika Anda menggunakan Android Jetpack, saya juga menemukan contoh dengan Retrofit, coroutine, LiveData, dan MVVM: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://codinginfinite.com/kotlin-coroutine-call-adapter-retrofit/</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428994/">https://habr.com/ru/post/id428994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428984/index.html">Julia dan potret fase sistem dinamis</a></li>
<li><a href="../id428986/index.html">ThinkJava Conference # 8 di Kharkov</a></li>
<li><a href="../id428988/index.html">Tips Alam - Cloudy Night Light</a></li>
<li><a href="../id428990/index.html">Contoh Konfigurasi UIViewControllers Menggunakan RouteComposer</a></li>
<li><a href="../id428992/index.html">Bypass kunci secara selektif pada router dengan firmware Padavan dan Keenetic OS</a></li>
<li><a href="../id428996/index.html">Klub Santa Claus anonim 2018-2019 di Habrahabr</a></li>
<li><a href="../id428998/index.html">Cara menggunakan fitur Profiler eksperimental baru di Bereaksi</a></li>
<li><a href="../id429000/index.html">Mengapa Bill Gates menciptakan toilet sebesar $ 233 miliar</a></li>
<li><a href="../id429006/index.html">Cina: â€œtoko perakitan duniaâ€ tidak sesederhana kelihatannya</a></li>
<li><a href="../id429008/index.html">Alpha Zero, Catur dan Belajar Bahasa Inggris: Masa Kini dan Masa Depan Kecerdasan Buatan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>