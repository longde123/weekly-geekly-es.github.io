<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😮 🏭 🌡️ Menggunakan SQL in Rails 👸 👇🏾 🤷🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pertama, artikel ini bukan tentang bagaimana saya suka kereta api, dan kedua, artikel ini bukan tentang bagaimana saya membenci mereka. Mereka dapat d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan SQL in Rails</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421939/"><p>  Pertama, artikel ini bukan tentang bagaimana saya suka kereta api, dan kedua, artikel ini bukan tentang bagaimana saya membenci mereka.  Mereka dapat diperlakukan dengan cara yang sangat berbeda dan mereka akan menjadi lebih baik hanya jika Anda mengubahnya.  Dan mereka bisa menjadi lebih buruk hanya jika mereka mulai berubah.  Secara umum, saya memperingatkan Anda, tetapi Anda mengerti saya. </p><br><p> Salah satu konsep utama ActiveRecord adalah bahwa databasenya cukup utilitarian dan dapat diubah.  Nah, Anda duduk di sana, menulis model Anda menggunakan MySQL, dan tiba-tiba Anda membaca di suatu tempat bahwa Anda dapat mengambil MySQL dan menggantinya dengan MongoDB.  Yah, tidak terlalu radikal, tetapi, katakanlah, di PostgreSQL, Anda mungkin punya alasan untuk mengganti MySQL.  Atau sebaliknya, saya tidak menentang MySQL.  Di sini ActiveRecord mengklaim untuk memudahkan Anda, yang seharusnya mencakup, sebelum / sesudah filter dan asosiasi cukup abstrak untuk tidak perlu khawatir tentang menghasilkan kueri basis data dan mengurus logika aplikasi.  Bahwa alih-alih <code>WHERE is_archived = TRUE</code> Anda senang menulis di <code>where(is_archived: true)</code> dan ActiveRecord akan melakukan segalanya untuk Anda.  Semua contoh akan diterjemahkan untuk PostgreSQL, bukan untuk MySQL, sehingga pengguna MySQL harus menciptakan sepeda mereka sendiri. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/ff1/cfc/e53ff1cfc747b1a79b89c8139cd1d196.gif"></p><br><p>  Tapi bagaimanapun caranya!  Dalam praktiknya, ternyata lapisan abstraksi ini benar-benar penuh lubang, seperti palung dari kisah Ikan Emas.  Dan banyak fitur dasar tidak dapat digunakan, seperti membandingkan tanggal atau bekerja dengan array.  Dan Anda mendapatkan cakupan dengan paksa di <code>where("#{quoted_table_name}.finished_at &gt;= ?", Date.current)</code> atau di <code>where("#{quoted_table_name}.other_ids &lt;@ ARRAY[?]", ids)</code> .  Ke mana ActiveRecord memberikan jawaban yang sepenuhnya sadar dan logis: jangan gunakan itu.  Alih-alih array, gunakan koneksi habtm, dan jika Anda perlu membandingkan tanggal, hiduplah dengan itu.  Ya, dan Tuhan melarang Anda untuk melewatkan <code>quoted_table_name</code> dalam cakupan seperti itu - <code>includes</code> atau <code>joins</code> meletakkan semuanya di tempatnya.  Lebih mudah di mana-mana dan selalu menulis, agar tidak menjatuhkan tangan Anda. </p><a name="habracut"></a><br><p>  Yah, tentu saja, begitu Anda memutuskan untuk mengganggu ActiveRecord di sini, tidak akan ada jalan untuk kembali.  Bukan berarti tidak akan ada kesempatan, bahkan harapan hantu untuk transisi tanpa rasa sakit ke database lain.  Akan lebih mudah untuk mencetak dan membakar kode sumber ini.  Dan tentu saja, tidak ada alasan lain untuk tidak menggunakan fitur basis data tambahan dalam aplikasi Anda.  Gunakan untuk kesehatan dan paksa orang lain! </p><br><p>  Dan ketika ternyata lingkup Anda dalam folder model terdiri dari lebih dari setengah fitur tambahan ini, cukup jelas bahwa ActiveRecord hanyalah sebuah shell yang nyaman untuk mengintegrasikan satu bagian kode dengan label dengan potongan kode lainnya.  Dan cakupan, seperti di <code>where(is_archived: true).joins(:sprint).merge(Sprint.archived)</code> , akan bekerja dengan baik dan menggabungkannya tidak akan lebih sulit daripada membuat telur orak, kan? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/618/8a9/0b1/6188a90b173dcc6238fa5fa649ee3227.gif"></p><br><p>  Tahap selanjutnya adalah denormalisasi.  Tidak, denasionalisasi, seolah-olah, selalu tidak lenyap, tetapi perawatannya berada di pundak Rails dan ActiveRecord yang kuat, dan Anda tahu bahwa kedua orang ini tidak berbeda dalam kecepatan dan asketisme dalam persyaratan sumber daya.  Katakanlah <code>counter_cache: true</code> adalah langkah pertama menuju denormalisasi, karena <code>COUNT(*) AS sprints_count</code> tidak akan memungkinkan Anda membuat ActiveRecord (Anda tidak ingin mengubah <code>select()</code> , kan?).  Dan <code>counter_cache</code> tidak jauh dari sempurna, dan dalam beberapa kasus mungkin ada sinkronisasi dari jumlah riil dari yang di-cache.  Tentu saja tidak kritis, tetapi tidak menyenangkan.  Dan ini hanya kandidat pertama yang menetap di database dan tidak memuat kepala mesin ruby ​​yang sudah dimuat.  Hanya beberapa pemicu dan Anda selesai!  Pertama, ketika menghapus dan menambahkan catatan baru ke piring A, Anda perlu menghitung jumlah catatan di pelat B dan hanya itu, kan?  Nah, saat mengedit, tentu saja, jika <code>foreign_key</code> berubah, karena <code>UPDATE B SET a_id = $1 WHERE id = $2</code> akan memecah counter_cache untuk A lama dan baru. </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> update_#{parent_table}_#{child_table}_counter_on_insert() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">UPDATE</span></span></span><span class="pgsql"> #{parent_table} </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SET</span></span></span><span class="pgsql"> #{counter_column} = COALESCE((</span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> COUNT(id) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> #{child_table} </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">GROUP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> #{foreign_column} </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">HAVING</span></span></span><span class="pgsql"> #{foreign_column} = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.#{foreign_column}), </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql">) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> (#{parent_table}.id = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.#{foreign_column}); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">NULL</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre><br><p>  Jalur basis data berikutnya akan terkait dengan tanggal-waktu.  Dan sebagai permulaan, mari kita melayani bidang <code>created_at</code> dan <code>updated_at</code> dalam database, untungnya, ini jauh lebih sederhana.  Pengaturan default pertama: </p><br><pre> <code class="hljs ruby"> change_column_default <span class="hljs-symbol"><span class="hljs-symbol">:table_name</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:created_at</span></span>, -&gt; { <span class="hljs-string"><span class="hljs-string">'CURRENT_TIMESTAMP'</span></span> } change_column_default <span class="hljs-symbol"><span class="hljs-symbol">:table_name</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:updated_at</span></span>, -&gt; { <span class="hljs-string"><span class="hljs-string">'CURRENT_TIMESTAMP'</span></span> }</code> </pre> <br><p>  Dan untuk segera melakukannya di mana saja, Anda dapat mengatur siklus untuk semua pelat tempat bidang ini berada.  Selain <code>ar_internal_metadata</code> dan <code>ar_internal_metadata</code> , tentu saja: </p><br><pre> <code class="hljs matlab"> (tables - <span class="hljs-comment"><span class="hljs-comment">%w(schema_migrations ar_internal_metadata)).each { ... }</span></span></code> </pre> <br><p>  Itu saja, sekarang nilai default untuk tabel ini akan persis seperti yang kita butuhkan.  Dan sekarang adalah waktu untuk memastikan bahwa pagar tidak menyentuh bidang ini.  Ini dilakukan dengan dua baut di tempat yang tepat.  Dan ya, ada opsi dalam menyiapkan kerangka kerja yang bertanggung jawab untuk ini: </p><br><pre> <code class="hljs lua">Rails.application.<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.active_record.record_timestamps = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><p>  Jadi, langkah selanjutnya adalah memperbarui bidang <code>updated_at</code> pada saat catatan diperbarui.  Sederhana: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> touch_for_#{<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span>}_on_update() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">CURRENT_TIMESTAMP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.updated_at; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre> <br><p>  Sekarang Anda harus benar-benar menghilangkan <code>touch: true</code> dalam model.  Hal ini sangat mirip dengan target di dasbor - juga sepenuhnya berlubang.  Dan saya bahkan tidak akan menjelaskan mengapa, karena Anda sudah tahu semua kasus ini.  Ini tidak jauh lebih rumit, yang Anda butuhkan adalah memperbarui updated_at tidak hanya untuk diri Anda sendiri: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> touch_for_#{<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span>}_on_update() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">UPDATE</span></span></span><span class="pgsql"> foreign_table_name </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SET</span></span></span><span class="pgsql"> updated_at = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">CURRENT_TIMESTAMP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> id = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.foreign_column_name; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">CURRENT_TIMESTAMP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.updated_at; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre> <br><p>  Tentu saja, rantai panggilan pemicu tersebut akan melakukan tindakan yang tidak perlu, tetapi dalam postgres mekanisme waras, pemicu dipanggil tanpa mengubah catatan itu sendiri.  Anda dapat mencoba melakukan <code>SET title = title</code> , tetapi hasilnya tidak lebih baik daripada <code>SET updated_at = CURRENT_TIMESTAMP</code> . </p><br><p>  Pemicu yang sama persis akan ada di sisipan, hanya memperbarui <code>updated_at</code> tidak perlu: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> touch_for_#{<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span>}_on_insert() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">UPDATE</span></span></span><span class="pgsql"> foreign_table_name </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SET</span></span></span><span class="pgsql"> updated_at = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">CURRENT_TIMESTAMP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> id = </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">.foreign_column_name; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN</span></span></span><span class="pgsql"> </span><span class="hljs-built_in"><span class="pgsql"><span class="hljs-built_in">NEW</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre> <br><p>  Tentu saja, Anda dapat mencoba menulis ini dengan satu fungsi, menambahkan tanda centang untuk kejadian saat ini tepat di dalam pelatuk, mirip dengan <code>IF TG_OP = 'UPDATE' THEN</code> , tetapi lebih baik untuk membuat semua pemicu sesederhana mungkin untuk mengurangi kemungkinan kesalahan. </p><br><p>  Anda mungkin ingin mengotomatisasi pembuatan pemicu semacam itu, dan kemudian Anda mungkin perlu menemukan semua hubungan asing antara tabel saat ini dan yang lainnya.  Anda dapat dengan mudah melakukan ini dengan permintaan ini: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ccu.<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> foreign_table_name, kcu.<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> information_schema.table_constraints <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tc <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> information_schema.key_column_usage <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> kcu <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tc.<span class="hljs-built_in"><span class="hljs-built_in">constraint_name</span></span> = kcu.<span class="hljs-built_in"><span class="hljs-built_in">constraint_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> information_schema.constraint_column_usage <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ccu <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ccu.<span class="hljs-built_in"><span class="hljs-built_in">constraint_name</span></span> = tc.<span class="hljs-built_in"><span class="hljs-built_in">constraint_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> constraint_type = <span class="hljs-string"><span class="hljs-string">'FOREIGN KEY'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tc.<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span> = <span class="hljs-string"><span class="hljs-string">'#{table_name}'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ccu.<span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span>;</code> </pre><br><p>  Tip lain yang sangat membantu.  Pemicu panggilan dengan cara yang sama untuk dapat memverifikasi ada atau tidaknya apa yang dibutuhkan oleh satu permintaan, misalnya, permintaan ini akan menemukan semua pemicu sisipan sentuh: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> routine_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> information_schema.<span class="hljs-keyword"><span class="hljs-keyword">routines</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> routine_name <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'touch_for_%_on_insert'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> routine_type =<span class="hljs-string"><span class="hljs-string">'FUNCTION'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> specific_schema=<span class="hljs-string"><span class="hljs-string">'public'</span></span>;</code> </pre> <br><p>  Dan terakhir, yang terburuk adalah yang tersisa.  Faktanya adalah bahwa rel tidak dirancang untuk setidaknya beberapa jenis database pintar, dan mereka benar-benar tidak peduli dengan fakta bahwa setidaknya sesuatu selain bidang <code>id</code> dapat berubah dalam database, dan itu hanya ketika dimasukkan.  Oleh karena itu, tidak ada mekanisme waras untuk menambahkan <code>RETURNING updated_at</code> untuk memperbarui permintaan, tidak ada, Anda harus menyelami bagian dalam Rails ke telinga. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5e2/741/5b9/5e27415b90ea63490670e7d4e2e4e758.jpg"></p><br><p>  Mankipatch ternyata tidak terlalu rapi, tetapi pertama-tama tujuannya adalah untuk merusak pekerjaan kerangka saat ini sesedikit mungkin. </p><br><div class="spoiler">  <b class="spoiler_title">Saya akan membawanya sepenuhnya</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">module ActiveRecord module Persistence # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/persistence.rb#L729-L741 def _create_record(attribute_names = self.attribute_names) attribute_names &amp;= self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.column_names attributes_values = attributes_with_values_for_create(attribute_names) an_id, *affected_rows = self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>._insert_record(attributes_values).dup self.id ||= an_id <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.primary_key Hash[ApplicationRecord.custom_returning_columns(self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.quoted_table_name, :<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>).take(affected_rows.size).zip(affected_rows)].<span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>| public_send("#{column_name}=", self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.attribute_types[<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span>.to_s].deserialize(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> @new_record = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> yield(self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> block_given? id <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> private :_create_record # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/persistence.rb#L710-L725 def _update_record(attribute_names = self.attribute_names) attribute_names &amp;= self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.column_names attribute_names = attributes_for_update(attribute_names) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> attribute_names.empty? affected_rows = [] @_trigger_update_callback = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> affected_rows = _update_row(attribute_names) @_trigger_update_callback = affected_rows.<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Hash[ApplicationRecord.custom_returning_columns(self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.quoted_table_name, :<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>).take(affected_rows.size).zip(affected_rows)].<span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>| public_send("#{column_name}=", self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.attribute_types[<span class="hljs-built_in"><span class="hljs-built_in">column_name</span></span>.to_s].deserialize(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> yield(self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> block_given? affected_rows.<span class="hljs-keyword"><span class="hljs-keyword">none</span></span>? ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> private :_update_record <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> module ConnectionAdapters module PostgreSQL module DatabaseStatements # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb#L93-L96 def exec_update(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> = nil, binds = []) execute_and_clear(sql_with_returning(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>), <span class="hljs-type"><span class="hljs-type">name</span></span>, binds) { |result| <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.wrap(result.<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>.first) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/connection_adapters/abstract/database_statements.rb#L147-L152 def <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(arel, <span class="hljs-type"><span class="hljs-type">name</span></span> = nil, pk = nil, _id_value = nil, sequence_name = nil, binds = []) <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>, binds = to_sql_and_binds(arel, binds) exec_insert(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>, binds, pk, sequence_name).<span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>.first <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> # https://github.com/rails/rails/blob/v5<span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/activerecord/lib/active_record/connection_adapters/postgresql/database_statements.rb#L98-L111 def sql_for_insert(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>, pk, id_value, sequence_name, binds) # :nodoc: table_ref = extract_table_ref_from_insert_sql(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pk.nil? # Extract the <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>. Yuck. pk = primary_key(table_ref) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> table_ref <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> returning_columns = quote_returning_column_names(table_ref, pk, :<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> returning_columns.<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> = "#{sql} RETURNING #{returning_columns.join(', ')}" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> super <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> original repo def quote_returning_column_names(table_ref, pk, action) returning_columns = [] returning_columns &lt;&lt; pk <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> suppress_composite_primary_key(pk) returning_columns += ApplicationRecord.custom_returning_columns(table_ref, action) returning_columns.map { |<span class="hljs-keyword"><span class="hljs-keyword">column</span></span>| quote_column_name(<span class="hljs-keyword"><span class="hljs-keyword">column</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> original repo def sql_with_returning(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) table_ref = extract_table_ref_from_update_sql(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) returning_columns = quote_returning_column_names(table_ref, nil, :<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> returning_columns.blank? "#{sql} RETURNING #{returning_columns.join(', ')}" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> original repo def extract_table_ref_from_update_sql(<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>[/<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>\s("[A-Za-z0-9_."\[\]\s]+"|[A-Za-z0-9_."\[\]]+)\s*<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>/im] Regexp.last_match(<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;.strip <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  Yang paling penting adalah di sini kita beralih ke <code>ApplicationRecord.custom_returning_columns</code> untuk mencari tahu kolom mana selain id yang menarik bagi kita.  Dan metode ini terlihat seperti ini: </p><br><pre> <code class="hljs vhdl"> class &lt;&lt; self def custom_returning_columns(table_ref, action) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ['<span class="hljs-string"><span class="hljs-string">"schema_migrations"</span></span>', '<span class="hljs-string"><span class="hljs-string">"ar_internal_metadata"</span></span>'].include?(table_ref) res = [] res &lt;&lt; :created_at <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> action == :create res &lt;&lt; :updated_at res += <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> table_ref <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> '<span class="hljs-string"><span class="hljs-string">"user_applications"</span></span>' [:api_token] <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> '<span class="hljs-string"><span class="hljs-string">"users"</span></span>' [:session_salt, :password_changed_at] # ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><hr><br><p>  Alih-alih kesimpulan, kita dapat mengatakan bahwa, sakit kepala Rails menjadi sedikit kurang sakit.  Proses <code>counter_cache</code> seperti <code>counter_cache</code> dan <code>touch</code> akan terlupakan, dan di artikel berikutnya kita dapat memikirkan sesuatu yang lebih global, seperti menghapus ruang gantung, validasi data, penghapusan data cascading, atau penghapusan paranoid.  Jika Anda menyukai artikel ini, tentu saja. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421939/">https://habr.com/ru/post/id421939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421929/index.html">Setahun sebelum Brexit: Inggris menyelesaikan masalah kekurangan tenaga kerja melalui robot</a></li>
<li><a href="../id421931/index.html">Dampak Spectre, Meltdown, dan perlindungan Foreshadow pada kinerja Linux 4.19</a></li>
<li><a href="../id421933/index.html">Studi tentang HDD sistem file model DVR QCM-08DL</a></li>
<li><a href="../id421935/index.html">Kesan pertama transisi dari Ubuntu 16.04 LTS ke Ubuntu 18.04 LTS</a></li>
<li><a href="../id421937/index.html">Kota pintar di dalam - sekilas Huawei</a></li>
<li><a href="../id421945/index.html">Google dan Mastercard membuat kesepakatan rahasia untuk melacak pembelian di toko</a></li>
<li><a href="../id421947/index.html">Selamat datang di Android Devs Meetup 8 September</a></li>
<li><a href="../id421949/index.html">Pasukan Bunuh Diri Bagaimana kami merekrut pengembang junior yang paling galak</a></li>
<li><a href="../id421953/index.html">Summ3r 0f h4ck: magang musim panas di Digital Security</a></li>
<li><a href="../id421955/index.html">Senat tidak ingin robot terganggu oleh bir. Dan apa lagi yang harus ditulis pada hari Jumat?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>