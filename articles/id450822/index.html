<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏿 🧙🏼 🌭 Kerangka kerja yang hilang 🍻 🕢 🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa kita menggunakan kerangka kerja? Angular, React, dan Vue membantu kami membangun aplikasi web yang kompleks: kode struktur, mengelola keadaan,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kerangka kerja yang hilang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/450822/">  Mengapa kita menggunakan kerangka kerja?  Angular, React, dan Vue membantu kami membangun aplikasi web yang kompleks: kode struktur, mengelola keadaan, dan mengembangkan antarmuka yang kompleks.  Selama dekade terakhir, kerangka kerja telah menjadi standar.  Standar yang mahal.  Karena kerangka kerja mulai digunakan, JS telah sangat membengkak.  Ada lebih banyak halaman dengan berat beberapa megabyte, dan bagian penting dari buku ini adalah kerangka itu sendiri.  Tampaknya sedikit, tetapi bagi pengguna itu sangat penting - di telepon atau di Internet yang lemah, halaman mungkin tidak dimuat.  Ini masalah. <br><br><img src="https://habrastorage.org/webt/l4/wd/k7/l4wdk7s_mctdg-p6ctwusbwiq7m.png"><br><br>  Selain kelebihan berat badan, kerangka kerja klasik memiliki banyak kelemahan lain dan mereka tidak cocok untuk semua proyek.  Masalah-masalah ini diselesaikan dalam "kerangka kerja yang terancam punah."  Apa tren baru ini, mengapa ini bukan "kerangka kerja JS lain", tetapi sebuah ide bagus dan bagaimana kerangka kerja misterius dapat meningkatkan aplikasi kita, Pavel Malyshev akan memberi tahu. <br><a name="habracut"></a><br>  <b>Tentang pembicara: Pavel Malyshev</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">PaulMaly</a> ) - fullstack dengan pengalaman lebih dari 10 tahun.  Dia bekerja di Mustlab, yang memasang iklan di web, Smart TV dan perangkat seluler, serta IoT.  Seorang penginjil kerangka JS Svelte di Rusia, memimpin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelompok Telegram</a> tentang topik ini. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/NvNe4nKmZT0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Apa yang seharusnya tidak ada dalam laporan </h2><br>  Ketika saya mempertimbangkan cerita ini, saya memutuskan bahwa itu seharusnya tidak standar.  Karena itu, saya menulis apa yang seharusnya tidak ada di sini.  Tidak akan ada penekanan pada kerangka kerja tertentu, perbandingan dengan kerangka kerja lain - mereka bosan dengan semua orang, dan, tentu saja, saya tidak ingin menjadi Kapten Obvious.  Semua ini seharusnya tidak ada dalam cerita saya, tetapi, sayangnya, itu akan ... <br><br>  Ketika Anda membaca namanya, Anda mungkin berpikir bahwa ada kerangka kerja lain, dan sudah ada kebun binatang keseluruhan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9e/324/d9c/b9e324d9cd7205923e0805c009b820e5.png"><br><br>  Tampak bagi saya bahwa jika suatu kerangka kerja baru muncul, maka kerangka kerja lama tidak memenuhi sebagian dari kebutuhan kita.  Mungkin kebutuhan itu sendiri berubah seiring waktu, dan itulah sebabnya kita membutuhkan solusi baru - lebih efektif dan menarik.  Oleh karena itu, saya meminta Anda untuk mendekati hal tersebut dari sudut pandang ini dengan pikiran terbuka dan melihat kerangka kerja yang menghilang sebagai alat baru yang dapat membantu dalam pekerjaan Anda. <br><br>  Untuk memulainya, mari kita cari tahu siapa itu siapa. <br><br><h2>  Siapa itu siapa? </h2><br>  Saya mengambil tiga besar dan Svelte.  Sangat menarik bahwa setiap alat mencirikan dirinya sendiri secara berbeda.  Posisi <b>sudut</b> itu sendiri sebagai kerangka kerja untuk semua kesempatan, "semua dalam satu kotak".  <b>Bereaksi</b> meniru perpustakaan: "Saya sekecil perpustakaan", tetapi bersama dengan seluruh infrastruktur itu juga merupakan kerangka kerja yang lengkap.  <b>Vue</b> seharusnya merupakan kerangka kerja progresif.  Anda dapat beralih ke sana dengan jQuery secara berurutan mentransfer kode, dimulai hampir dengan tag <code>script</code> biasa tanpa kolektor.  <b>Langsing</b> adalah kerangka menghilang secara ajaib.  Wat? <br><br>  Mari kita cari tahu apa yang saya bicarakan. <br><br><h2>  Mengapa kerangka kerja itu mulai menghilang? </h2><br><blockquote>  Kami mengirim terlalu banyak kode kepada pengguna kami. </blockquote><br>  Pelanggan kami menjadi lebih mobile, tetapi teknologi internet tidak bagus di mana-mana - bahkan 3G tidak ada di mana-mana, belum lagi LTE.  Kita perlu mengurangi ukuran kode. <br><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">studi yang menarik</a> dari 2017 tentang topik ini, yang menunjukkan bahwa jika aplikasi Anda memiliki banyak JS, maka Anda hanya bisa memasukkan <b>130 Kb untuk membuat pengguna senang</b> .  Jika JS kecil, maka hingga 170Kb.  Perbedaan ini disebabkan oleh fakta bahwa penelitian memperhitungkan bahwa JS berbeda dari jenis sumber daya lainnya, perlu diurai, ditafsirkan, dan sebagainya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b5/032/ec3/8b5032ec37fd48a2f95998759f41c5f9.png"><br><br>  Dalam penelitian tersebut, 130 Kb tidak hanya JS, tetapi secara umum semuanya, termasuk CSS, HTML, tentu saja, tanpa gambar.  Pada saat yang sama, satu Angular memiliki berat 143 Kb, dan kami bahkan belum menulis satu baris kode pun.  Mari kita lihat apa yang ditawarkan solusi saat ini kepada kami. <br><br><h3>  Performa </h3><br>  Pada prinsipnya, setiap kerangka kerja klasik adalah abstraksi atas platform yang memungkinkan kita untuk menulis pada tingkat yang lebih nyaman.  Ini buruk karena abstraksi apa pun memiliki beberapa biaya, termasuk kinerja. <br><br><blockquote>  Kami mengeluarkan biaya tambahan karena abstraksi yang tidak perlu antara kode kami dan browser. </blockquote><br>  Fitur kerangka kerja yang hilang adalah mereka <b>menghapus abstraksi dan perhitungan yang tidak perlu dari runtime browser</b> , melakukan analisis dan perhitungan pada saat kompilasi.  Itu sebabnya mereka menghilang.  Kami akan membicarakan ini secara lebih rinci di bawah ini. <br><br><h3>  Kompatibilitas </h3><br><blockquote>  Solusi yang ditulis untuk kerangka klasik tidak dapat diterapkan di mana pun. </blockquote><br>  Mereka hanya bekerja dalam kerangka kerja kerangka ini.  Misalnya, Anda melakukan 2-3 proyek pada React favorit Anda, menulis banyak solusi keren untuknya, dan kemudian memutuskan untuk pindah ke Angular.  Anda tidak lagi membutuhkan solusi ini, Anda dapat membuangnya.  Meskipun ide intinya adalah pencocokan komponen, kerangka kerja klasik membuat kita tidak mungkin menggunakan kembali kode. <br><br>  Hal tentang menghilangnya kerangka kerja adalah bahwa mereka <b>tidak memiliki abstraksi</b> , dan dalam hal ini tidak ada kerangka kerja dalam runtime.  Kode Anda benar-benar vanilla JS, yang dapat dibawa kemana saja - ke proyek apa pun, bahkan pada kerangka kerja yang berbeda.  Misalnya, Anda dapat mengambil kode pada kerangka yang hilang dan mentransfernya ke Bereaksi. <br><br><h3>  Pemecahan kode &amp; guncangan pohon </h3><br><blockquote>  Teknologi lama menyulitkan untuk menerapkan teknologi baru. </blockquote><br>  Sebagian besar kerangka kerja dibuat ketika teknologi ini tidak begitu dikembangkan.  Kami memiliki kernel yang cukup monolitik, dan komponen apa pun, bahkan bagian terkecil dari kode Anda, terikat pada keseluruhan kerangka kerja.  Dengan demikian, tidak mungkin untuk melakukan pemecahan kode secara efektif dan bahkan pengocokan pohon. <br><br>  Sekarang semua kerangka kerja berkembang menuju modularitas yang lebih besar untuk "mengguncang" lebih baik.  Dalam kerangka yang hilang, ini diselesaikan di luar kotak, karena mereka dibuat sedemikian rupa sehingga <b>hanya kode yang Anda butuhkan pada awalnya ditambahkan ke bundel</b> , dan itu menyelesaikan tugas Anda secara eksklusif.  Ini adalah kasus yang sangat spesifik - seolah-olah Anda menulis kode dengan tangan Anda persis untuk tugas Anda dan memasukkannya ke dalam bundel, hanya kerangka yang melakukan ini untuk Anda. <br><br><h3>  Biaya fitur </h3><br><blockquote>  Kerangka kerja apa pun memiliki harga untuk fitur baru. </blockquote><br>  Komunitas memerlukan fitur baru yang berbeda dan masing-masing anggota membutuhkan sesuatu sendiri, dan setiap fitur memiliki harga.  Dalam kerangka kerja yang hilang, masalah ini diselesaikan pada tingkat konsep, karena fitur apa pun yang tidak Anda gunakan tidak akan pernah masuk ke bundel Anda. <br>  Jadi, pertanyaan utama: dapatkah kerangka kerja yang hilang, dan khususnya Svelte, menyelesaikan semua masalah ini?  Mari kita perbaiki. <br><br><h2>  Bez dengan runtime </h2><br>  Rantime adalah topik yang agak fana.  Tidak jelas apa itu, dan orang yang berbeda memahaminya secara berbeda.  Dalam konteks ini, saya akan berbicara tentang runtime dari sudut pandang dua aspek: <b>lingkungan di mana kode dieksekusi</b> dan <b>kode itu sendiri</b> . <br><br><h3>  Runtime sebagai lingkungan </h3><br>  Mari kita lihat sebuah contoh.  Jika kode ditulis dalam Vanilla, maka satu-satunya runtime yang diperlukan adalah DOM.  Jika kode ditulis dalam React, maka Anda memerlukan runtime yang berbeda: DOM, React, dan React DOM. <br><br><blockquote>  Apa pun, komponen terkecil dari kode Anda di Bereaksi akan bergantung pada lingkungan apa kerangka kerja Anda, yaitu, pada saat runtime. </blockquote><br><br><h3>  Runtime sebagai eksekusi kode </h3><br>  Poin kedua adalah runtime dalam hal eksekusi kode pada saat runtime.  Mari kita lihat kasus runtime dasar hari ini untuk frontend - DOM virtual - sebagian besar runtime, misalnya, dalam Bereaksi aplikasi - menggunakan contoh sederhana: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {world}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Ada variabel dinamis dalam bagian HTML ini.  Dari sudut pandang DOM virtual, kodenya bekerja seperti ini. <br><br><ul><li>  Variabel ini sedang dimodifikasi. <br></li><li>  Pohon DOM virtual dalam memori sedang dibangun. <br></li><li>  Dibandingkan dengan versi sebelumnya. <br></li><li>  Manipulasi DOM dilakukan secara langsung, yang pada akhirnya cukup efektif, karena kami mendapat beberapa perbedaan dan kami tahu persis apa yang harus diubah di DOM yang sebenarnya. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/12e/082/a7e/12e082a7e3f5e596d6251c22b4016046.png"><br><br><blockquote>  DOM virtual adalah overhead mutlak, karena akan selalu lebih cepat seperti ini: begitu perubahan terjadi, mereka segera melakukan perubahan pada DOM. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/5f8/18a/d83/5f818ad83b71a697f3af30a4b747bdaf.png"><br><br>  Pertanyaan: bagaimana memahami apa yang telah berubah dan apa yang perlu diubah?  DOM virtual memecahkan masalah apa yang telah berubah, bukan kecepatan perubahan ini.  Kecepatan dicapai karena fakta bahwa kita tahu sebanyak mungkin apa yang telah berubah, dan dapat secara efektif memanipulasi DOM. <br><br><h2>  Kompilasi </h2><br>  Untuk mengatasi masalah ini, menghilang kerangka hanya menentukan perubahan pada tahap kompilasi: Anda menulis kode, saat kompilasi, kerangka menghilang membangun semua dependensi, menghitung manipulasi mana dalam DOM yang diperlukan.  Faktanya, segala sesuatu yang DOM virtual lakukan dalam runtime, kerangka kerja menghilang tidak dalam membangun waktu: itu menghasilkan manipulasi langsung dengan DOM, yang hanya disebut selama runtime.  Hasilnya adalah diagram: ketika kita membuat perubahan, manipulasi dalam DOM berjalan segera. <br><br><blockquote>  Anda tidak dapat menulis aplikasi serius dalam JavaScript vanilla tanpa mengenai dinding yang rumit.  Tetapi seorang kompiler dapat melakukannya untuk Anda. <br>  <b>Rich Harris, pencipta Svelte</b> </blockquote><br>  Saya akan memberi tahu Anda bagaimana saya bertemu Svelte.  Kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek yang menarik</a> - widget yang akan dimasukkan pada situs yang jumlahnya tidak terbatas, sementara kami tidak tahu situs apa ini, di perangkat mana pengguna akan membukanya.  Widget harus berukuran sangat kecil dan sangat cepat.  Tentu saja, ketika kami mengambil tugas ini, kami segera mengerti apa yang harus dilakukan pada Bereaksi atau bahkan pada Vue bukanlah suatu pilihan, karena ternyata banyak overhead tambahan. <br><br>  Kami hampir cenderung menulis di Vanilla, tetapi sulit dan tidak selalu nyaman untuk dipertahankan.  Tapi kami beruntung - kami menemukan Svelte.  Gagasan utama kerangka ini diberikan dalam kutipan: Anda tidak dapat menulis aplikasi serius pada Vanilla, karena Anda akan dengan cepat berlari ke tembok kompleksitas - akan sulit bagi tim untuk bekerja, tidak ada pendekatan umum, dan kompiler dapat melakukannya untuk Anda. <br><br><h3>  Bagaimana cara kerjanya </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/822/0c9/463/8220c9463072b5a7aedd40185dfa8a70.png"><br><br>  <b>Kode sumber adalah kode berbasis kerangka kerja</b> - kode yang tergantung pada kerangka kerja.  Semuanya seperti biasa: ada beberapa dokumentasi, Anda menulis kode seolah-olah Anda menggunakan kerangka kerja lain yang memiliki semacam API, prinsip dan pendekatan.  Semuanya seperti biasa. <br><br>  Pada waktu build, kode ini dikompilasi.  Akibatnya, vanilla JS terletak di bundel, dan, seperti yang saya katakan, persis kode yang diperlukan untuk menjalankan aplikasi Anda secara khusus sampai di sana.  Jika dalam dua menit Anda menambahkan fungsi baru di sana atau menggunakan fitur baru dari framework, Svelte akan menambahkannya di sana, dan itu juga akan masuk ke dalam bundel.  Kalau tidak, ini tidak akan terjadi. <br><br>  Mari kita perhatikan langkah-langkahnya secara lebih rinci.  Langkah pertama adalah <b>komponen</b> .  Pertimbangkan komponen yang sama. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {world}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Pada langkah kedua - <b>AST</b> - kode ini diproduksi di pohon sintaksis abstrak. <br><br><pre> <code class="xml hljs">{"type": "Element", "name": "h1", "children": [{ "type": "Text", "data": "Hello",....}]}</code> </pre><br>  Langkah ketiga adalah <b>DOM API</b> .  Atas dasar pohon, kode dihasilkan secara langsung, yang diperlukan untuk pengoperasian komponen ini.  Kode ini sangat sederhana, pada prinsipnya tidak ada runtimes dan abstraksi yang rumit. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">changed, ctx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (changed.name) { text_1.data = ctx.name; } }</code> </pre><br>  Di akhir artikel, tunjukkan dalam survei apakah Anda menyukai gagasan kompilasi AOT dari kerangka Svelte?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terakhir kali,</a> mayoritas berbicara positif. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5aa/be9/d8e/5aabe9d8e0bd77fef1a1ed0e1844ac91.png"><br><br>  Sekarang mari kita lihat apa Svelte itu. <br><br><h2>  Langsing </h2><br>  Kata bahasa Inggris langsing atau langsing berarti "langsing, fleksibel."  Svelte JS adalah! <br><br>  Saya mengklaim bahwa ini bukan "kerangka JS yang lain" karena ini adalah <b>kerangka kerja UI waktu</b> .  Kerangka kerja reguler bekerja di runtime, dan Svelte hanya ada sebelum kita mengompilasinya. <br><br>  Ini adalah <b>penganalisa statis kompilasi-waktu</b> , atau penganalisa kode statis yang melewati kode selama kompilasi, menganalisis secara statis dan, berdasarkan ini, menghasilkan bundel akhir yang sesuai. <br><br>  Ini adalah <b>kompiler di masa depan</b> - kompiler AOT yang melakukan semuanya. <br><br>  Pencipta kerangka Rich Harris, yang bisa Anda ketahui dari alat-alat seperti Rollup, Ractive, Buble - analog dari Babel - adalah cowok keren.  Menurut pendapat saya, Rollup yang sama masih merupakan implementasi pengocok pohon terbaik.  Itu muncul di dalamnya jauh lebih awal daripada di Webpack, dan masih berfungsi lebih baik.  Harris awalnya membangun kerangka Svelte dengan pohon-gemetar, pemecahan kode, dan pendekatan modern lainnya. <br><br><blockquote>  Svelte adalah alat untuk menulis vanilla JS tanpa harus menulis vanilla JS. </blockquote><br>  Mari kita lihat kerangka ini dari dalam. <br><br><h3>  Komponen File Tunggal </h3><br>  <b>Svelte adalah komponen file tunggal</b> .  Jika Anda bekerja dengan Vue, itu akan mengingatkan Anda pada kerangka ini, tetapi ini bukan kebetulan.  Sintaks yang digunakan Vue terutama berasal dari kerangka kerja Ractive, yang juga dibuat oleh Harris pada tahun 2012.  Kerangka ini, sayangnya, tidak menjadi populer, menurut saya, karena dirilis pada 1.0 terlambat.  Mereka sangat kacau dengan versi yang Ractive dalam versi kecil selama 6 tahun. <br><br>  Vue meminjam banyak antarmuka dari sana, dan Svelte adalah penerus Ractive.  Oleh karena itu, akan terlihat bagi Anda bahwa semuanya serupa, tetapi komponen file tunggal muncul di Ractive pada 2013.  Mereka terlihat sedikit berbeda, tetapi secara keseluruhan - terlihat.  Komponen apa pun yang Anda tulis di Svelte akan terlihat seperti ini. <br><br><pre> <code class="plaintext hljs">&lt;h1 &gt;Hello {world}!&lt;/h1 &gt; &lt;script&gt; export default { /* component behaviour */ }; &lt;/script&gt; &lt;style&gt;    /* scoped styles */ &lt;/style&gt;</code> </pre> <br>  Di atas adalah templat HTML tertentu - HTML biasa tanpa pengecualian.  Satu-satunya hal di atasnya adalah bahasa template tertentu yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HTMLx</a> .  Saya akan bercerita lebih banyak tentang dia nanti. <br><br>  Selanjutnya adalah skrip di mana kita menulis perilaku komponen kita.  Cara menulisnya dijelaskan dalam panduan ini.  Di sana Anda dapat mengimpor, membuat berbagai fungsi dan metode - semua seperti di Vue. <br><br>  Anda bisa menggunakan gaya lingkup untuk mendapatkan gaya komponen terisolasi dari kotak.  Ia bekerja seperti ini: dalam kompilasi utama, hash dihasilkan, sebagai hasilnya, itu seperti meniru Shadow DOM. <br><br>  Tidak ada bagian yang diperlukan, sehingga komponen hanya dapat terdiri dari satu HTML. <br><br><h3>  Sintaks HTMLx </h3><br>  Seperti halnya HTML, data ditulis dalam tanda kurung. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Ini adalah bagaimana pernyataan bersyarat ditulis. <br><br><pre> <code class="xml hljs">{#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if}</code> </pre> <br>  Enumerasi dan loop: <br><pre> <code class="xml hljs">{#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each}</code> </pre> <br>  Anda dapat menggunakan arahan untuk menangkap acara, untuk pengikatan data ganda. <br><br><pre> <code class="xml hljs">{#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"say(name)"</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each}</code> </pre> <br>  Ada sangat sedikit arahan dalam HTMLx - hanya 4-5 jenis, dan tidak ada arahan khusus, seperti di Angular. <br><br>  Anda dapat memasukkan data dinamis apa pun ke dalam atribut apa pun, tidak ada masalah dengan ini. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{dynamic}"</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"used"</span></span></span><span class="hljs-tag">&gt;</span></span> {#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"say(name) "</span></span></span><span class="hljs-tag"> &gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  Gaya terisolasi dan penghapusan yang tidak terpakai </h3><br>  Jika Anda menggunakan gaya terisolasi, selain terisolasi, gaya yang tidak digunakan juga dipotong secara otomatis. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{dynamic}"</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"used"</span></span></span><span class="hljs-tag">&gt;</span></span> {#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"say(name) "</span></span></span><span class="hljs-tag"> &gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> .used {...} .unused {...} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Jika style <code>used</code> , maka itu digunakan, dan jika style <code>unused</code> , itu tidak akan ada dalam bundel.  Kerangka kerja akan memotong segalanya, tetapi rapi.  Karena itu, fitur ini dapat dengan mudah dipatahkan jika Anda menggunakan banyak dinamika.  Svelte akan berpikir: "Aku lebih baik tidak menyentuh" ​​- dan pergi.  Seseorang harus berhati-hati, tetapi itu sangat nyaman.  Karena Svelte memiliki penganalisa statis, itu menunjukkan di konsol saat startup yang gaya tidak digunakan.  Jika Anda benar-benar tidak membutuhkannya, Anda dapat segera menghapusnya. <br><br><h3>  Komposisi Komponen </h3><br>  Semuanya seperti biasa di sini: kami mengimpor file, mendaftarkannya di komponen, menggunakannya sebagai tag. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Nested</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">foo</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"static"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{dynamic}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bind:baz</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">baz</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> Nested </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'Nested.html'</span></span></span><span class="javascript">;</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">' export default {   components: {Nested} }; </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Anda dapat mentransfer data apa pun melalui atribut, menggunakan ikatan ganda.  Atau tidak menggunakan - penjilidan ganda adalah opsional, bahkan dapat dinonaktifkan pada tingkat kompiler, dan tidak akan berada di tempat lain.  Ini untuk mereka yang tidak suka binding.  Binding diperoleh menggunakan <code>bind:</code> directive. <br><br><h3>  Fitur tambahan dari Svelte </h3><br>  Dua kemungkinan pertama adalah: <b>SSR &amp; Hidrasi</b> - render dan hidrasi server, dan <b>manajemen negara bawaan</b> - manajemen negara global bawaan berdasarkan solusi kami sendiri, yang disebut toko. <br><br>  Pada prinsipnya, Anda dapat menggunakan Redux, yang banyak dilakukan: mereka yang terbiasa Redux menggunakannya dengan Svelte.  Tetapi ada solusi internal yang lebih sederhana yang sangat terintegrasi sehingga jika Anda mendaftarkannya di toko, maka itu segera tersedia di semua hierarki komponen - tidak ada manipulasi sama sekali.  Satu-satunya hal untuk menggunakannya adalah menggunakan awalan <code>$</code> , yaitu, semua metode atau menyimpan data ditulis dengan awalan ini.  <code>$</code> dapat digunakan di semua templat. <br><br>  Toko memiliki fitur menarik yang belum saya lihat di tempat lain - meluas secara global ke satu hierarki komponen.  Jika Anda, misalnya, memiliki komponen Root, ini digunakan di seluruh hierarki ini.  Jika Anda memiliki toko lain di suatu tempat di dalam hierarki ini, maka toko ini meluas ke seluruh hierarki yang lebih rendah. <br><br>  Ini nyaman ketika Anda ingin membuat komponen kompleks besar dengan banyak subkomponen, dan kemudian menggunakannya dalam proyek yang berbeda, di beberapa di antaranya ada Redux, dan yang lain tidak.  Jika Anda menggunakan toko reguler dengan Redux, maka Anda perlu memastikan bahwa proyek tempat Anda menambahkannya memiliki Redux.  Ini tidak perlu dilakukan di sini - Svelte mengimplementasikan toko sendiri untuk hierarki ini.  Dapat dengan mudah ditransfer bahkan ke proyek-proyek di mana tidak ada toko global sama sekali.  Anda membawanya, dan Svelte sudah melakukan segalanya di dalam. <br><br>  <b>Elemen khusus didukung di luar kotak</b> .  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs khusus</a> di mana dukungan diuji oleh kerangka kerja standar Komponen Web.  Menurut tes, Svelte memiliki dukungan 100% untuk elemen khusus.  Ia bekerja seperti ini: nama tag ditentukan, bendera "customElement: true" diatur dalam kompiler, dan elemen kustom yang siap digunakan dihasilkan yang mendukung semua fitur Svelte yang ada. <br><br>  <b>Sapper - Pembuat aplikasi Svelte</b> .  Ini adalah analog dari Next.js dan Nuxt.js untuk Vue.  Pada prinsipnya, semuanya sama: isomorfisme, dukungan untuk pemisahan kode, pengambilan awal dan offline di luar kotak dan fitur lainnya.  Menurut pendapat saya, baru-baru ini bahkan beberapa ide routing datang dari Sapper ke Next.js. <br><br>  Tetapi tidak satu pun Svelte yang melakukan ini.  Kami untuk kompetisi yang adil! <br><br><h2>  Siapa lagi </h2><br>  <b>Stensil</b> adalah kerangka kerja dari pengembang ionik.  Mereka juga bekerja pada kerangka yang dikompilasi, tetapi dengan fokus besar pada komponen web dan elemen kustom.  Svelte berbeda dari itu dalam komponennya yang biasanya dikompilasi ke dalam kelas JS reguler dan tidak ada bias dalam komponen web. <br><br>  <b>Glimmer</b> - Saya pikir semua orang tahu proyek ini.  Ini disajikan di sini hanya karena ia mengkompilasi: ia memiliki bytecode sendiri, mesin virtual sendiri, yang jelas memberikan optimasi tambahan untuk kode akhir. <br><br>  <b>Marko dari eBay</b> .  Saya belum mempelajarinya secara rinci, tetapi mereka juga mengkompilasi, tidak yakin apa yang sedalam Svelte.  Benar, saya tidak mengerti secara detail dan bisa salah. <br><br>  <b>Sudut</b>  Ada kompiler AOT di sini, dan itu akan dipromosikan dengan baik, tetapi itu hanyalah kompilasi ulang template string dalam bentuk yang sudah jadi sebelumnya.  Sejauh yang saya mengerti, belum ada kompilasi AoT lengkap di sana. <br><br><h2>  Halo film </h2><br>  Saya menulis aplikasi kecil - daftar film dengan filter berdasarkan pada TMDb API.  Ini memiliki kategori: populer, peringkat teratas, mendatang.  Anda dapat berkeliling halaman, memilih negara, menerapkan filter untuk itu, mengubah bahasa.  Aplikasi primitif ini hanya membutuhkan 6,4 Kb. <br><br>  Secara total, HELLO MOVIES adalah total 172 baris kode bersama dengan HTML, termasuk 36 baris kode JS bersama dengan segala macam kutipan.  Ini semua kode yang saya pribadi tulis.  Secara alami, semua ini dikompilasi ke volume yang jauh lebih besar, tetapi bagi saya, sebagai pengembang, itu tidak masalah. <br><br>  Beberapa indikator lagi.  "TodoList MVC" di Svelte membutuhkan 3,6 Kb - tergantung pada siapa yang mengatakannya, tetapi bahkan pada Vanilla dibutuhkan 11 Kb, dan pada Vue dan Bereaksi lebih banyak lagi - masing-masing 80 dan 300 Kb.  Proyek "RealWorld", tiruan dari Medium, dengan pendaftaran, akun, suka, bagikan, teman - 40 Kb, di React and Angular - 211 dan 575 Kb.  Klon "HackerNews" di Svelte adalah 30 Kb, pada React dan Vue - beberapa kali lebih banyak. <br><br><h2>  Tingkatan yang dicapai </h2><br>  Kita semua suka hollichivat pada topik tolok ukur.  Saya menggunakan tolok ukur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Krausest yang</a> terkenal.  Anda mungkin berpikir bahwa saya sekarang akan menunjukkan hasil di mana Svelte hanya membuat semua orang berkeping-keping, dan Inferno hanya menangis.  Tetapi ini tidak akan terjadi. <br><br><img src="https://habrastorage.org/webt/3r/xz/4_/3rxz4_c2qbhoczgeo8yzr_kbg8s.jpeg"><br><br>  Saya mengambil perbandingan Svelte dengan Tiga Besar - Angular, React dan Vue dalam versi terbaru.  Akibatnya, ia mengidentifikasi dua posisi pertama mengenai Vanilla.  Dan di sini angkanya tidak sepenting ide utama, yaitu bahwa <b>Svelte sangat seimbang</b> . <br><br>  Svelte berusaha untuk seimbang - <b>itu baik dalam segala hal dalam tolok ukur apa pun</b> .  Dengan beberapa parameter, Svelte bahkan menyalip Vanilla, oleh beberapa dibutuhkan yang pertama, dan di suatu tempat di depan Vue dan Angular.  Namun, dalam semua tes, Angular dan Vue mengkonsumsi banyak memori, tetapi Svelte tidak.        ,    ,       .   — . <br><br>  Svelte     —    .  ,    . <br><br><h2> - —   ! </h2><br>  Svelte   New York Times.    . ,      Svelte, ,   legacy-  CMS,       .     ,     ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/080/9a3/6c8/0809a36c8b7f7d9d4eb9e18fe3d3bfa2.png"><br><br> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> -</a>   « » —  ,  Drag&amp;Drop.       Svelte,    . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Soft-Gear</a>    ,     ,  Svelte.   ,         -     . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">airca.st</a>    Svelte.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dabble</a>   Svelte.    -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">i-want-to-ride-an-electric-citi</a>        Svelte. <br><br>      . ,   RuTube.       Smart TV   Tizen,    Samsung.     Tizen  Smart TV     Svelte.      ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46c/154/f5d/46c154f5d392f46698fb5a03e4234adc.png"><br><br><h2>   </h2><br><br> <b>  standalone vanilla JavaScript  </b> .     ,      ,  overhead . <br><br> <b>    </b> .  Svelte       DOM.    . <br><br> <b>  </b> .  ,     Vue,   Svelte  .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">REPL</a> ,         ,     . <br><br> <b>      </b> .   ,      —    ,         .       ,   . <br><br> <b>Code-splitting &amp; tree-shaking</b> .         code-splitting  tree-shaking.         .     ,          . <br><br> <b>Micro-frontends ready</b> .     -.      ,    ,        PHP,    Svelte-. ,      .      ,          .        code-splitting  tree-shaking. <br><br><h2>   </h2><br><br> <b>Svelte  ,   </b> .      2016 .          . <br><br> <b> </b> .  ,              .         . ,  ,   ,    ,     ,     Vue. <br><br> <b>  </b> .  React  Facebook, Angular — Google, Vue    ,      Rich Harris   ,            . <br><br><blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf</a>   ++      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,  ,    .   33       .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>              ++ 27  28 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450822/">https://habr.com/ru/post/id450822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450812/index.html">PSR-14 - acara utama dalam PHP</a></li>
<li><a href="../id450814/index.html">Bagaimana BGP Bekerja</a></li>
<li><a href="../id450816/index.html">Tajuk HTTP untuk pengembang yang bertanggung jawab</a></li>
<li><a href="../id450818/index.html">Dari Latensi Ceph Tinggi ke Patch Kernel dengan eBPF / BCC</a></li>
<li><a href="../id450820/index.html">Komite program FrontendConf: kerangka kerja, cakrawala, pengalaman dunia dan misi konferensi</a></li>
<li><a href="../id450824/index.html">Keadaan css</a></li>
<li><a href="../id450826/index.html">Cara berbicara dengan mikrokontroler dari JS</a></li>
<li><a href="../id450828/index.html">Ketika kota tertidur ...</a></li>
<li><a href="../id450830/index.html">Nikita Dubko pada konferensi, sindrom penipu dan pelaporan</a></li>
<li><a href="../id450832/index.html">Kisah satu animasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>