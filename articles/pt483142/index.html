<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèΩ ü§¥üèΩ üõê Portando o Quake 3 para a Ferrugem üéØ üïî üëàüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nossa equipe Immunant ama Rust e est√° trabalhando ativamente no C2Rust, uma estrutura de migra√ß√£o que cuida de toda a rotina de migra√ß√£o para o Rust. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Portando o Quake 3 para a Ferrugem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483142/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2c/61d/a4f/d2c61da4f8dfcdfb39d9fbd7787070a4.png"></div><br>  Nossa equipe Immunant ama Rust e est√° trabalhando ativamente no C2Rust, uma estrutura de migra√ß√£o que cuida de toda a rotina de migra√ß√£o para o Rust.  N√≥s nos esfor√ßamos para introduzir automaticamente melhorias de seguran√ßa no c√≥digo Rust convertido e ajudar o programador a faz√™-lo quando a estrutura falhar.  No entanto, antes de tudo, precisamos criar um tradutor confi√°vel que permita que os usu√°rios iniciem o Rust.  Os testes em pequenos programas CLI est√£o lentamente se tornando obsoletos, por isso decidimos transferir o Quake 3. para o Rust. Depois de alguns dias, provavelmente fomos os primeiros a jogar o Quake3 no Rust! <br><br><h2>  Prepara√ß√£o: Terremoto 3 fontes </h2><br>  Tendo estudado o c√≥digo fonte do Quake 3 original e v√°rios garfos, decidimos pelo <a href="https://ioquake3.org/">ioquake3</a> .  Este √© um fork do Quake 3 criado pela comunidade, que ainda √© suportado e constru√≠do em plataformas modernas. <br><a name="habracut"></a><br>  Como ponto de partida, decidimos garantir a montagem do projeto em sua forma original: <br><br><pre><code class="bash hljs">$ make release</code> </pre> <br>  Ao criar o ioquake3, v√°rias bibliotecas e arquivos execut√°veis ‚Äã‚Äãs√£o criados: <br><br><pre> <code class="bash hljs">$ tree --prune -I missionpack -P <span class="hljs-string"><span class="hljs-string">"*.so|*x86_64"</span></span> . ‚îî‚îÄ‚îÄ build ‚îî‚îÄ‚îÄ debug-linux-x86_64 ‚îú‚îÄ‚îÄ baseq3 ‚îÇ ‚îú‚îÄ‚îÄ cgamex86_64.so <span class="hljs-comment"><span class="hljs-comment"># client ‚îÇ ‚îú‚îÄ‚îÄ qagamex86_64.so # game server ‚îÇ ‚îî‚îÄ‚îÄ uix86_64.so # ui ‚îú‚îÄ‚îÄ ioq3ded.x86_64 # dedicated server binary ‚îú‚îÄ‚îÄ ioquake3.x86_64 # main binary ‚îú‚îÄ‚îÄ renderer_opengl1_x86_64.so # opengl1 renderer ‚îî‚îÄ‚îÄ renderer_opengl2_x86_64.so # opengl2 renderer</span></span></code> </pre> <br>  Entre essas bibliotecas, as bibliotecas de interface do usu√°rio, cliente e servidor podem ser compiladas como um assembly <a href="https://fabiensanglard.net/quake3/qvm.php">Quake VM</a> ou como bibliotecas compartilhadas X86 nativas.  Em nosso projeto, decidimos usar vers√µes nativas.  Traduzir VMs para Rust e usar vers√µes QVM seria muito mais simples, mas quer√≠amos testar completamente o C2Rust. <br><br>  Em nosso projeto de transfer√™ncia, focamos na interface do usu√°rio, jogo, cliente, renderizador OpenGL1 e no execut√°vel principal.  Tamb√©m podemos traduzir o renderizador OpenGL2, mas decidimos pular isso porque ele usa uma quantidade significativa de <code>.glsl</code> , que o sistema de compila√ß√£o incorpora como literais de string no c√≥digo-fonte C. Ap√≥s a compila√ß√£o, adicionaremos suporte para scripts de compila√ß√£o para incorpora√ß√£o C√≥digo GLSL em seq√º√™ncias de caracteres Rust, mas ainda n√£o existe uma boa maneira automatizada de transpor esses arquivos tempor√°rios gerados automaticamente.  Em vez disso, acabamos de traduzir a biblioteca do renderizador OpenGL1 e for√ßamos o jogo a us√°-lo em vez do renderizador padr√£o.  Al√©m disso, decidimos pular o servidor dedicado e os arquivos de miss√£o empacotados, porque eles n√£o ser√£o dif√≠ceis de transferir e n√£o s√£o necess√°rios para a nossa demonstra√ß√£o. <br><br><h2>  Transpose Quake 3 </h2><br>  Para preservar a estrutura de diret√≥rios usada no Quake 3 e n√£o alterar o c√≥digo-fonte, precisamos obter exatamente os mesmos arquivos bin√°rios que no assembly nativo, ou seja, quatro bibliotecas compartilhadas e um arquivo execut√°vel. <br><br>  Como o C2Rust cria os arquivos de montagem do Cargo, cada bin√°rio requer seu pr√≥prio caixote Rust com o arquivo <code>Cargo.toml</code> correspondente. <br><br>  Para que o C2Rust crie uma caixa por arquivo bin√°rio de sa√≠da, ele tamb√©m precisar√° de uma lista de arquivos bin√°rios com o objeto ou os arquivos de origem correspondentes, bem como uma chamada de vinculador usada para criar cada arquivo bin√°rio (usado para determinar outros detalhes, por exemplo, depend√™ncias da biblioteca). <br><br>  No entanto, descobrimos rapidamente uma limita√ß√£o causada pela maneira como o C2Rust intercepta o processo de compila√ß√£o nativo: o C2Rust recebe um arquivo de <a href="https://sarcasm.github.io/notes/dev/compilation-database.html">banco de dados de compila√ß√£o</a> na entrada que cont√©m uma lista de comandos de compila√ß√£o que s√£o executados durante a compila√ß√£o.  No entanto, esse banco de dados cont√©m <strong>apenas</strong> comandos de compila√ß√£o sem chamadas do vinculador.  A maioria das ferramentas que criam esse banco de dados tem essa limita√ß√£o intencional, por exemplo, <code>cmake</code> com <code>CMAKE_EXPORT_COMPILE_COMMANDS</code> , <code>bear</code> e <code>compiledb</code> .  Em nossa experi√™ncia, a √∫nica ferramenta que inclui comandos de <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> √© o criador de <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> criado pelo <code>CodeChecker</code> , que n√£o usamos porque aprendemos sobre isso somente depois de escrever nossos pr√≥prios wrappers (eles s√£o descritos abaixo).  Isso significava que, para compilar um programa C com v√°rios arquivos bin√°rios, n√£o foi poss√≠vel usar o arquivo <code>compile_commands.json</code> criado por qualquer uma das ferramentas comuns. <br><br>  Portanto, escrevemos nossos pr√≥prios scripts de <a href="https://github.com/immunant/c2rust/blob/master/scripts/cc-wrappers/cc">compilador</a> e wrapper <a href="https://github.com/immunant/c2rust/blob/master/scripts/cc-wrappers/ld">vinculador</a> que despejam todas as chamadas para o compilador e vinculador ao banco de dados e, em seguida, o convertem no <code>compile_commands.json</code> estendido.  Em vez da montagem usual, use um comando como: <br><br><pre> <code class="bash hljs">$ make release</code> </pre> <br>  adicionamos wrappers para interceptar o assembly com: <br><br><pre> <code class="bash hljs">$ make release CC=/path/to/C2Rust/scripts/cc-wrappers/cc</code> </pre> <br>  Os wrappers criam um diret√≥rio de v√°rios arquivos JSON, um por chamada.  O segundo <a href="https://github.com/immunant/c2rust/blob/master/scripts/convert_build_commands.py">script</a> coleta todos eles em um novo arquivo <code>compile_commands.json</code> , que cont√©m os comandos de compila√ß√£o e compila√ß√£o.  Em seguida, estendemos o C2Rust para que ele leia os comandos de constru√ß√£o do banco de dados e crie uma caixa separada para cada bin√°rio vinculado.  Al√©m disso, o C2Rust agora tamb√©m l√™ depend√™ncias da biblioteca para cada arquivo bin√°rio e as adiciona automaticamente ao arquivo <code>build.rs</code> da caixa correspondente. <br><br>  Para melhorar a conveni√™ncia, todos os bin√°rios podem ser coletados por vez, colocando-os dentro da √°rea de <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">trabalho</a> .  O C2Rust cria o arquivo <code>Cargo.toml</code> trabalho de n√≠vel <code>Cargo.toml</code> , para que possamos construir o projeto com o √∫nico <code>cargo build</code> no diret√≥rio <code>quake3-rs</code> : <br><br><pre> <code class="bash hljs">$ tree -L 1 . ‚îú‚îÄ‚îÄ Cargo.lock ‚îú‚îÄ‚îÄ Cargo.toml ‚îú‚îÄ‚îÄ cgamex86_64 ‚îú‚îÄ‚îÄ ioquake3 ‚îú‚îÄ‚îÄ qagamex86_64 ‚îú‚îÄ‚îÄ renderer_opengl1_x86_64 ‚îú‚îÄ‚îÄ rust-toolchain ‚îî‚îÄ‚îÄ uix86_64 $ cargo build --release</code> </pre> <br><h2>  Eliminar rugosidade </h2><br>  Quando tentamos compilar o c√≥digo traduzido pela primeira vez, encontramos alguns problemas com as fontes do Quake 3: havia casos de fronteira com os quais o C2Rust n√£o conseguia lidar (nem corretamente nem de alguma forma). <br><br><h3>  Ponteiros de matriz </h3><br>  V√°rios locais no c√≥digo-fonte original cont√™m express√µes que apontam para o pr√≥ximo elemento ap√≥s o √∫ltimo elemento da matriz.  Aqui est√° um exemplo de c√≥digo C simplificado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p; <span class="hljs-comment"><span class="hljs-comment">// ... if (p &gt;= &amp;array[1024]) { // error... }</span></span></code> </pre> <br>  O padr√£o C (veja, por exemplo, <a href="http://www.iso-9899.info/n1570.html">C11, Se√ß√£o 6.5.6</a> ) permite que ponteiros para um elemento ultrapassem o final de uma matriz.  No entanto, Rust pro√≠be isso, mesmo que apenas tomemos o endere√ßo do elemento.  Encontramos exemplos desse padr√£o na fun√ß√£o <a href=""><code>AAS_TraceClientBBox</code></a> . <br><br>  O compilador Rust tamb√©m sinalizou um exemplo semelhante, mas realmente <a href=""><code>G_TryPushingEntity</code></a> , em <a href=""><code>G_TryPushingEntity</code></a> , onde a instru√ß√£o condicional √© da forma <code>&gt;</code> , n√£o <code>&gt;=</code> .  Um ponteiro que sai dos limites √© desreferenciado ap√≥s a constru√ß√£o condicional, que √© um erro de seguran√ßa da mem√≥ria. <br><br>  Para evitar esse problema no futuro, corrigimos o transpiler C2Rust para que ele use a aritm√©tica do ponteiro para calcular o endere√ßo de um elemento da matriz, em vez de usar a opera√ß√£o de indexa√ß√£o da matriz.  Gra√ßas a essa corre√ß√£o, o c√≥digo que usa o padr√£o semelhante ‚Äúendere√ßo do elemento no final da matriz‚Äù agora est√° corretamente traduzido e executado sem modifica√ß√µes. <br><br><h3>  Elementos de matriz de comprimento vari√°vel </h3><br>  Lan√ßamos o jogo para testar tudo e imediatamente entramos em p√¢nico com Rust: <br><br><pre> <code class="cpp hljs">thread <span class="hljs-string"><span class="hljs-string">'main'</span></span> panicked at <span class="hljs-string"><span class="hljs-string">'index out of bounds: the len is 4 but the index is 4'</span></span>, quake3-client/src/cm_polylib.rs:<span class="hljs-number"><span class="hljs-number">973</span></span>:<span class="hljs-number"><span class="hljs-number">17</span></span></code> </pre> <br>  <code>cm_polylib.c</code> , notamos que ele desreferencia o campo <code>p</code> na seguinte estrutura: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numpoints; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> p[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// variable sized } winding_t;</span></span></code> </pre> <br>  O campo <code>p</code> na estrutura √© uma vers√£o do membro da matriz flex√≠vel que n√£o √© suportada pelo padr√£o C99, mas ainda √© aceito pelo <code>gcc</code> .  C2Rust reconhece elementos de matrizes de comprimento vari√°vel com a sintaxe C99 ( <code>vec3_t p[]</code> ) e implementa uma <a href="">heur√≠stica</a> simples para tamb√©m identificar vers√µes desse padr√£o at√© C99 (matrizes de tamanhos 0 e 1 no final das estruturas; tamb√©m encontramos v√°rios exemplos no c√≥digo-fonte ioquake3). <br><br>  <a href="https://github.com/immunant/ioq3/commit/ace1fae43e736613544c8d33cc69dee794f5124a">Alterar</a> a estrutura acima para a sintaxe C99 eliminou o p√¢nico: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numpoints; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> p[]; <span class="hljs-comment"><span class="hljs-comment">// variable sized } winding_t;</span></span></code> </pre> <br>  Uma tentativa de corrigir automaticamente esse padr√£o no caso geral (com tamanhos de matriz diferentes de 0 e 1) ser√° extremamente dif√≠cil, porque teremos que distinguir entre matrizes comuns e elementos de matrizes de tamanho vari√°vel de tamanhos arbitr√°rios.  Portanto, em vez disso, recomendamos que voc√™ corrija o c√≥digo C original manualmente, como fizemos com ioquake3. <br><br><h3>  Operandos vinculados no c√≥digo assembler embutido </h3><br>  Outra fonte de falha foi esse c√≥digo do assembler C-assembler no cabe√ßalho do sistema <code>/usr/include/bits/select.h</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __FD_ZERO(fdsp) \ do { \ int __d0, __d1; \ __asm__ __volatile__ (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cld; rep; "</span></span></span><span class="hljs-meta"> __FD_ZERO_STOS \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=c"</span></span></span><span class="hljs-meta"> (__d0), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=D"</span></span></span><span class="hljs-meta"> (__d1) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta"> (0), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"0"</span></span></span><span class="hljs-meta"> (sizeof (fd_set) \ / sizeof (__fd_mask)), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1"</span></span></span><span class="hljs-meta"> (&amp;__FDS_BITS (fdsp)[0]) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"memory"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  definindo a vers√£o interna da macro <code>__FD_ZERO</code> .  Essa defini√ß√£o levanta um caso raro de fronteira de <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">E / S de operandos vinculados</a> <code>gcc</code> : com tamanhos diferentes.  O operador de sa√≠da <code>"=D" (__d1)</code> vincula o registro <code>edi</code> √† vari√°vel <code>__d1</code> como um valor de 32 bits e <code>"1" (&amp;__FDS_BITS (fdsp)[0])</code> vincula o mesmo registro ao endere√ßo <code>fdsp-&gt;fds_bits</code> como um ponteiro de 64 bits.  <code>gcc</code> e <code>clang</code> resolvem essa incompatibilidade.  usando o registro de 64 bits <code>rdi</code> e truncando seu valor antes de atribuir o valor <code>__d1</code> , e Rust usa a sem√¢ntica do LLVM por padr√£o, no qual esse caso permanece indefinido.  Nas compila√ß√µes de depura√ß√£o (n√£o nas vers√µes, que se comportaram bem), vimos que os dois operandos podem ser atribu√≠dos ao registrador <code>edi</code> , pelo qual o ponteiro √© truncado para 32 bits antes do c√≥digo do assembler interno, o que causa falhas. <br><br>  Como <code>rustc</code> passa o c√≥digo do assembler Rust embutido para o LLVM com muito poucas altera√ß√µes, decidimos corrigir esse caso espec√≠fico no C2Rust.  Implementamos um novo engradado <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> que <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> esse problema gra√ßas ao sistema do tipo Rust, usando fun√ß√µes de <a href="">caracter√≠stica</a> e auxiliar que expandem e truncam automaticamente operandos vinculados a um tamanho interno grande o suficiente para acomodar os dois operandos.  O c√≥digo acima traduz corretamente para o seguinte: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> __d0: c_int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> __d1: c_int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Reference to the output value of the first operand let fresh5 = &amp;mut __d0; // The internal storage for the first tied operand let fresh6; // Reference to the output value of the second operand let fresh7 = &amp;mut __d1; // The internal storage for the second tied operand let fresh8; // Input value of the first operand let fresh9 = (::std::mem::size_of::&lt;fd_set&gt;() as c_ulong).wrapping_div(::std::mem::size_of::&lt;__fd_mask&gt;() as c_ulong); // Input value of the second operand let fresh10 = &amp;mut *fdset.__fds_bits.as_mut_ptr().offset(0) as *mut __fd_mask; asm!("cld; rep; stosq" : "={cx}" (fresh6), "={di}" (fresh8) : "{ax}" (0), // Cast the input operands into the internal storage type // with optional zero- or sign-extension "0" (AsmCast::cast_in(fresh5, fresh9)), "1" (AsmCast::cast_in(fresh7, fresh10)) : "memory" : "volatile"); // Cast the operands out (types are inferred) with truncation AsmCast::cast_out(fresh5, fresh9, fresh6); AsmCast::cast_out(fresh7, fresh10, fresh8);</span></span></code> </pre> <br>  √â importante notar que esse c√≥digo n√£o requer nenhum tipo de valores de entrada e sa√≠da na montagem do c√≥digo do assembler; ao resolver conflitos de tipo, <code>fresh6</code> <code>fresh8</code> Rust (principalmente tipos <code>fresh6</code> e <code>fresh8</code> ). <br><br><h3>  Vari√°veis ‚Äã‚Äãglobais alinhadas </h3><br>  A √∫ltima fonte da falha foi a seguinte vari√°vel global que armazena a constante SSE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ssemask[<span class="hljs-number"><span class="hljs-number">16</span></span>] __attribute__((aligned(<span class="hljs-number"><span class="hljs-number">16</span></span>))) = { <span class="hljs-string"><span class="hljs-string">"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x00\x00\x00\x00"</span></span> };</code> </pre> <br>  Atualmente, o Rust suporta o atributo de alinhamento para tipos estruturais, mas n√£o para vari√°veis ‚Äã‚Äãglobais, ou seja,  elementos <code>static</code> .  N√≥s pensamos em maneiras de resolver esse problema no caso geral, no Rust ou no C2Rust, mas por enquanto no ioquake3 decidimos corrigi-lo manualmente com um pequeno arquivo de <a href="https://github.com/immunant/ioq3/blob/master/asm-snapvector.patch">patch</a> .  Esse arquivo de corre√ß√£o substitui o equivalente ao <code>ssemask</code> do Rust <code>ssemask</code> seguinte: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C, align(16))]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SseMask</span></span></span></span>([<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">16</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ssemask: SseMask = SseMask([ <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ]);</code> </pre> <br><h2>  Executando o quake3-rs </h2><br>  Quando a <code>cargo build --release</code> , os bin√°rios s√£o criados, mas s√£o criados sob <code>target/release</code> com uma estrutura de diret√≥rio que o bin√°rio <code>ioquake3</code> n√£o reconhece.  Escrevemos um <a href="">script</a> que cria links simb√≥licos no diret√≥rio atual para recriar a estrutura de diret√≥rios correta (incluindo links para arquivos <code>.pk3</code> contendo recursos do jogo): <br><br><pre> <code class="bash hljs">$ /path/to/make_quake3_rs_links.sh /path/to/quake3-rs/target/release /path/to/paks</code> </pre> <br>  O caminho <code>/path/to/paks</code> deve apontar para o diret√≥rio que cont√©m os arquivos <code>.pk3</code> . <br><br>  Agora vamos rodar o jogo!  Precisamos passar <code>+set vm_game 0</code> , etc., portanto, carregamos esses m√≥dulos como bibliotecas compartilhadas Rust, e n√£o como um assembly QVM, al√©m de <code>cl_renderer</code> para usar o renderizador OpenGL1. <br><br><pre> <code class="bash hljs">$ ./ioquake3 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> sv_pure 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_game 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_cgame 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_ui 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> cl_renderer <span class="hljs-string"><span class="hljs-string">"opengl1"</span></span></code> </pre> <br>  E ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18e/fb3/94c/18efb394c9f33f6a1cbe78503a25bb4c.png"></div><br>  Lan√ßamos o Quake3 no Rust! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2c/61d/a4f/d2c61da4f8dfcdfb39d9fbd7787070a4.png"></div><br>  Aqui est√° um v√≠deo de como transpomos o Quake 3, baixamos o jogo e jogamos um pouco: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lQjvSJLDXW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Voc√™ pode estudar as <a href="https://github.com/immunant/ioq3/tree/transpiled/quake3-rs">fontes transpiladas</a> no ramo <code>transpiled</code> do nosso reposit√≥rio.  Tamb√©m h√° uma ramifica√ß√£o <code>refactored</code> contendo as mesmas <a href="https://github.com/immunant/ioq3/tree/refactored/quake3-rs">fontes</a> com v√°rios <a href="https://github.com/immunant/ioq3/blob/transpiled/refactor_commands.txt">comandos de refatora√ß√£o</a> pr√©-aplicados. <br><br><h2>  Como transpor </h2><br>  Se voc√™ quiser transpor o Quake 3 e execut√°-lo, lembre-se de que precisar√° de seus pr√≥prios recursos de jogo ou recursos de demonstra√ß√£o do Quake 3 da Internet.  Voc√™ tamb√©m precisar√° instalar o C2Rust (no momento da reda√ß√£o, a vers√£o noturna necess√°ria √© <code>nightly-2019-12-05</code> , mas recomendamos que voc√™ procure no <a href="https://github.com/immunant/c2rust">reposit√≥rio do</a> C2Rust ou em <a href="https://crates.io/crates/c2rust">crates.io</a> para encontrar a vers√£o mais recente): <br><br><pre> <code class="bash hljs">$ cargo +nightly-2019-12-05 install c2rust</code> </pre> <br>  e c√≥pias de nossos reposit√≥rios C2Rust e ioquake3: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> &lt;a href=<span class="hljs-string"><span class="hljs-string">"/cdn-cgi/l/email-protection"</span></span> class=<span class="hljs-string"><span class="hljs-string">"__cf_email__"</span></span> data-cfemail=<span class="hljs-string"><span class="hljs-string">"dcbbb5a89cbbb5a8b4a9bef2bfb3b1"</span></span>&gt;[email protected]&lt;/a&gt;:immunant/c2rust.git $ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> &lt;a href=<span class="hljs-string"><span class="hljs-string">"/cdn-cgi/l/email-protection"</span></span> class=<span class="hljs-string"><span class="hljs-string">"__cf_email__"</span></span> data-cfemail=<span class="hljs-string"><span class="hljs-string">"dcbbb5a89cbbb5a8b4a9bef2bfb3b1"</span></span>&gt;[email protected]&lt;/a&gt;:immunant/ioq3.git</code> </pre> <br>  Como alternativa √† instala√ß√£o do <code>c2rust</code> usando o comando acima, voc√™ pode criar o C2Rust manualmente usando <code>cargo build --release</code> .  De qualquer forma, o reposit√≥rio C2Rust ainda ser√° necess√°rio, pois cont√©m os scripts de wrapper do compilador necess√°rios para transpor o ioquake3. <br><br>  <code>ssemask</code> um <a href="">script</a> que transporta automaticamente o c√≥digo C e aplica o patch <code>ssemask</code> .  Para us√°-lo, execute o seguinte comando no n√≠vel superior do reposit√≥rio <code>ioq3</code> : <br><br><pre> <code class="bash hljs">$ ./transpile.sh &lt;/path/to/C2Rust repository&gt; &lt;/path/to/c2rust binary&gt;</code> </pre> <br>  Este comando deve criar um subdiret√≥rio <code>quake3-rs</code> contendo o c√≥digo Rust, para o qual voc√™ pode executar o <code>cargo build --release</code> e as etapas restantes descritas acima. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt483142/">https://habr.com/ru/post/pt483142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt483130/index.html">O que fazer se o c√≥digo para a fechadura da mala for esquecido?</a></li>
<li><a href="../pt483132/index.html">Projeto e fabrica√ß√£o de um telesc√≥pio</a></li>
<li><a href="../pt483134/index.html">Teste de autentica√ß√£o de dois fatores e poss√≠veis solu√ß√µes alternativas</a></li>
<li><a href="../pt483136/index.html">Verificando o MacBook usado antes da compra - lista de verifica√ß√£o</a></li>
<li><a href="../pt483140/index.html">Pol√≠gonos Outro Mundo: Amiga 500</a></li>
<li><a href="../pt483144/index.html">O cientista He Jiankui √© um her√≥i, n√£o um criminoso</a></li>
<li><a href="../pt483146/index.html">Confer√™ncia DEFCON 27. Kraken Wireless WiFi Hacking Tool</a></li>
<li><a href="../pt483148/index.html">Discutimos g√™meos digitais e simula√ß√£o com o fundador de uma empresa de consultoria</a></li>
<li><a href="../pt483154/index.html">Gastei US $ 40 mil e arruinei uma √≥tima id√©ia para uma startup</a></li>
<li><a href="../pt483156/index.html">Coloque o gato de p√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>