<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏽 🤴🏽 🛐 Portando o Quake 3 para a Ferrugem 🎯 🕔 👈🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nossa equipe Immunant ama Rust e está trabalhando ativamente no C2Rust, uma estrutura de migração que cuida de toda a rotina de migração para o Rust. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Portando o Quake 3 para a Ferrugem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483142/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2c/61d/a4f/d2c61da4f8dfcdfb39d9fbd7787070a4.png"></div><br>  Nossa equipe Immunant ama Rust e está trabalhando ativamente no C2Rust, uma estrutura de migração que cuida de toda a rotina de migração para o Rust.  Nós nos esforçamos para introduzir automaticamente melhorias de segurança no código Rust convertido e ajudar o programador a fazê-lo quando a estrutura falhar.  No entanto, antes de tudo, precisamos criar um tradutor confiável que permita que os usuários iniciem o Rust.  Os testes em pequenos programas CLI estão lentamente se tornando obsoletos, por isso decidimos transferir o Quake 3. para o Rust. Depois de alguns dias, provavelmente fomos os primeiros a jogar o Quake3 no Rust! <br><br><h2>  Preparação: Terremoto 3 fontes </h2><br>  Tendo estudado o código fonte do Quake 3 original e vários garfos, decidimos pelo <a href="https://ioquake3.org/">ioquake3</a> .  Este é um fork do Quake 3 criado pela comunidade, que ainda é suportado e construído em plataformas modernas. <br><a name="habracut"></a><br>  Como ponto de partida, decidimos garantir a montagem do projeto em sua forma original: <br><br><pre><code class="bash hljs">$ make release</code> </pre> <br>  Ao criar o ioquake3, várias bibliotecas e arquivos executáveis ​​são criados: <br><br><pre> <code class="bash hljs">$ tree --prune -I missionpack -P <span class="hljs-string"><span class="hljs-string">"*.so|*x86_64"</span></span> . └── build └── debug-linux-x86_64 ├── baseq3 │ ├── cgamex86_64.so <span class="hljs-comment"><span class="hljs-comment"># client │ ├── qagamex86_64.so # game server │ └── uix86_64.so # ui ├── ioq3ded.x86_64 # dedicated server binary ├── ioquake3.x86_64 # main binary ├── renderer_opengl1_x86_64.so # opengl1 renderer └── renderer_opengl2_x86_64.so # opengl2 renderer</span></span></code> </pre> <br>  Entre essas bibliotecas, as bibliotecas de interface do usuário, cliente e servidor podem ser compiladas como um assembly <a href="https://fabiensanglard.net/quake3/qvm.php">Quake VM</a> ou como bibliotecas compartilhadas X86 nativas.  Em nosso projeto, decidimos usar versões nativas.  Traduzir VMs para Rust e usar versões QVM seria muito mais simples, mas queríamos testar completamente o C2Rust. <br><br>  Em nosso projeto de transferência, focamos na interface do usuário, jogo, cliente, renderizador OpenGL1 e no executável principal.  Também podemos traduzir o renderizador OpenGL2, mas decidimos pular isso porque ele usa uma quantidade significativa de <code>.glsl</code> , que o sistema de compilação incorpora como literais de string no código-fonte C. Após a compilação, adicionaremos suporte para scripts de compilação para incorporação Código GLSL em seqüências de caracteres Rust, mas ainda não existe uma boa maneira automatizada de transpor esses arquivos temporários gerados automaticamente.  Em vez disso, acabamos de traduzir a biblioteca do renderizador OpenGL1 e forçamos o jogo a usá-lo em vez do renderizador padrão.  Além disso, decidimos pular o servidor dedicado e os arquivos de missão empacotados, porque eles não serão difíceis de transferir e não são necessários para a nossa demonstração. <br><br><h2>  Transpose Quake 3 </h2><br>  Para preservar a estrutura de diretórios usada no Quake 3 e não alterar o código-fonte, precisamos obter exatamente os mesmos arquivos binários que no assembly nativo, ou seja, quatro bibliotecas compartilhadas e um arquivo executável. <br><br>  Como o C2Rust cria os arquivos de montagem do Cargo, cada binário requer seu próprio caixote Rust com o arquivo <code>Cargo.toml</code> correspondente. <br><br>  Para que o C2Rust crie uma caixa por arquivo binário de saída, ele também precisará de uma lista de arquivos binários com o objeto ou os arquivos de origem correspondentes, bem como uma chamada de vinculador usada para criar cada arquivo binário (usado para determinar outros detalhes, por exemplo, dependências da biblioteca). <br><br>  No entanto, descobrimos rapidamente uma limitação causada pela maneira como o C2Rust intercepta o processo de compilação nativo: o C2Rust recebe um arquivo de <a href="https://sarcasm.github.io/notes/dev/compilation-database.html">banco de dados de compilação</a> na entrada que contém uma lista de comandos de compilação que são executados durante a compilação.  No entanto, esse banco de dados contém <strong>apenas</strong> comandos de compilação sem chamadas do vinculador.  A maioria das ferramentas que criam esse banco de dados tem essa limitação intencional, por exemplo, <code>cmake</code> com <code>CMAKE_EXPORT_COMPILE_COMMANDS</code> , <code>bear</code> e <code>compiledb</code> .  Em nossa experiência, a única ferramenta que inclui comandos de <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> é o criador de <a href="https://github.com/Ericsson/codechecker/tree/master/analyzer/tools/build-logger"><code>build-logger</code></a> criado pelo <code>CodeChecker</code> , que não usamos porque aprendemos sobre isso somente depois de escrever nossos próprios wrappers (eles são descritos abaixo).  Isso significava que, para compilar um programa C com vários arquivos binários, não foi possível usar o arquivo <code>compile_commands.json</code> criado por qualquer uma das ferramentas comuns. <br><br>  Portanto, escrevemos nossos próprios scripts de <a href="https://github.com/immunant/c2rust/blob/master/scripts/cc-wrappers/cc">compilador</a> e wrapper <a href="https://github.com/immunant/c2rust/blob/master/scripts/cc-wrappers/ld">vinculador</a> que despejam todas as chamadas para o compilador e vinculador ao banco de dados e, em seguida, o convertem no <code>compile_commands.json</code> estendido.  Em vez da montagem usual, use um comando como: <br><br><pre> <code class="bash hljs">$ make release</code> </pre> <br>  adicionamos wrappers para interceptar o assembly com: <br><br><pre> <code class="bash hljs">$ make release CC=/path/to/C2Rust/scripts/cc-wrappers/cc</code> </pre> <br>  Os wrappers criam um diretório de vários arquivos JSON, um por chamada.  O segundo <a href="https://github.com/immunant/c2rust/blob/master/scripts/convert_build_commands.py">script</a> coleta todos eles em um novo arquivo <code>compile_commands.json</code> , que contém os comandos de compilação e compilação.  Em seguida, estendemos o C2Rust para que ele leia os comandos de construção do banco de dados e crie uma caixa separada para cada binário vinculado.  Além disso, o C2Rust agora também lê dependências da biblioteca para cada arquivo binário e as adiciona automaticamente ao arquivo <code>build.rs</code> da caixa correspondente. <br><br>  Para melhorar a conveniência, todos os binários podem ser coletados por vez, colocando-os dentro da área de <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">trabalho</a> .  O C2Rust cria o arquivo <code>Cargo.toml</code> trabalho de nível <code>Cargo.toml</code> , para que possamos construir o projeto com o único <code>cargo build</code> no diretório <code>quake3-rs</code> : <br><br><pre> <code class="bash hljs">$ tree -L 1 . ├── Cargo.lock ├── Cargo.toml ├── cgamex86_64 ├── ioquake3 ├── qagamex86_64 ├── renderer_opengl1_x86_64 ├── rust-toolchain └── uix86_64 $ cargo build --release</code> </pre> <br><h2>  Eliminar rugosidade </h2><br>  Quando tentamos compilar o código traduzido pela primeira vez, encontramos alguns problemas com as fontes do Quake 3: havia casos de fronteira com os quais o C2Rust não conseguia lidar (nem corretamente nem de alguma forma). <br><br><h3>  Ponteiros de matriz </h3><br>  Vários locais no código-fonte original contêm expressões que apontam para o próximo elemento após o último elemento da matriz.  Aqui está um exemplo de código C simplificado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p; <span class="hljs-comment"><span class="hljs-comment">// ... if (p &gt;= &amp;array[1024]) { // error... }</span></span></code> </pre> <br>  O padrão C (veja, por exemplo, <a href="http://www.iso-9899.info/n1570.html">C11, Seção 6.5.6</a> ) permite que ponteiros para um elemento ultrapassem o final de uma matriz.  No entanto, Rust proíbe isso, mesmo que apenas tomemos o endereço do elemento.  Encontramos exemplos desse padrão na função <a href=""><code>AAS_TraceClientBBox</code></a> . <br><br>  O compilador Rust também sinalizou um exemplo semelhante, mas realmente <a href=""><code>G_TryPushingEntity</code></a> , em <a href=""><code>G_TryPushingEntity</code></a> , onde a instrução condicional é da forma <code>&gt;</code> , não <code>&gt;=</code> .  Um ponteiro que sai dos limites é desreferenciado após a construção condicional, que é um erro de segurança da memória. <br><br>  Para evitar esse problema no futuro, corrigimos o transpiler C2Rust para que ele use a aritmética do ponteiro para calcular o endereço de um elemento da matriz, em vez de usar a operação de indexação da matriz.  Graças a essa correção, o código que usa o padrão semelhante “endereço do elemento no final da matriz” agora está corretamente traduzido e executado sem modificações. <br><br><h3>  Elementos de matriz de comprimento variável </h3><br>  Lançamos o jogo para testar tudo e imediatamente entramos em pânico com Rust: <br><br><pre> <code class="cpp hljs">thread <span class="hljs-string"><span class="hljs-string">'main'</span></span> panicked at <span class="hljs-string"><span class="hljs-string">'index out of bounds: the len is 4 but the index is 4'</span></span>, quake3-client/src/cm_polylib.rs:<span class="hljs-number"><span class="hljs-number">973</span></span>:<span class="hljs-number"><span class="hljs-number">17</span></span></code> </pre> <br>  <code>cm_polylib.c</code> , notamos que ele desreferencia o campo <code>p</code> na seguinte estrutura: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numpoints; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> p[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// variable sized } winding_t;</span></span></code> </pre> <br>  O campo <code>p</code> na estrutura é uma versão do membro da matriz flexível que não é suportada pelo padrão C99, mas ainda é aceito pelo <code>gcc</code> .  C2Rust reconhece elementos de matrizes de comprimento variável com a sintaxe C99 ( <code>vec3_t p[]</code> ) e implementa uma <a href="">heurística</a> simples para também identificar versões desse padrão até C99 (matrizes de tamanhos 0 e 1 no final das estruturas; também encontramos vários exemplos no código-fonte ioquake3). <br><br>  <a href="https://github.com/immunant/ioq3/commit/ace1fae43e736613544c8d33cc69dee794f5124a">Alterar</a> a estrutura acima para a sintaxe C99 eliminou o pânico: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numpoints; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> p[]; <span class="hljs-comment"><span class="hljs-comment">// variable sized } winding_t;</span></span></code> </pre> <br>  Uma tentativa de corrigir automaticamente esse padrão no caso geral (com tamanhos de matriz diferentes de 0 e 1) será extremamente difícil, porque teremos que distinguir entre matrizes comuns e elementos de matrizes de tamanho variável de tamanhos arbitrários.  Portanto, em vez disso, recomendamos que você corrija o código C original manualmente, como fizemos com ioquake3. <br><br><h3>  Operandos vinculados no código assembler embutido </h3><br>  Outra fonte de falha foi esse código do assembler C-assembler no cabeçalho do sistema <code>/usr/include/bits/select.h</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __FD_ZERO(fdsp) \ do { \ int __d0, __d1; \ __asm__ __volatile__ (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cld; rep; "</span></span></span><span class="hljs-meta"> __FD_ZERO_STOS \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=c"</span></span></span><span class="hljs-meta"> (__d0), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=D"</span></span></span><span class="hljs-meta"> (__d1) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta"> (0), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"0"</span></span></span><span class="hljs-meta"> (sizeof (fd_set) \ / sizeof (__fd_mask)), \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1"</span></span></span><span class="hljs-meta"> (&amp;__FDS_BITS (fdsp)[0]) \ : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"memory"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  definindo a versão interna da macro <code>__FD_ZERO</code> .  Essa definição levanta um caso raro de fronteira de <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">E / S de operandos vinculados</a> <code>gcc</code> : com tamanhos diferentes.  O operador de saída <code>"=D" (__d1)</code> vincula o registro <code>edi</code> à variável <code>__d1</code> como um valor de 32 bits e <code>"1" (&amp;__FDS_BITS (fdsp)[0])</code> vincula o mesmo registro ao endereço <code>fdsp-&gt;fds_bits</code> como um ponteiro de 64 bits.  <code>gcc</code> e <code>clang</code> resolvem essa incompatibilidade.  usando o registro de 64 bits <code>rdi</code> e truncando seu valor antes de atribuir o valor <code>__d1</code> , e Rust usa a semântica do LLVM por padrão, no qual esse caso permanece indefinido.  Nas compilações de depuração (não nas versões, que se comportaram bem), vimos que os dois operandos podem ser atribuídos ao registrador <code>edi</code> , pelo qual o ponteiro é truncado para 32 bits antes do código do assembler interno, o que causa falhas. <br><br>  Como <code>rustc</code> passa o código do assembler Rust embutido para o LLVM com muito poucas alterações, decidimos corrigir esse caso específico no C2Rust.  Implementamos um novo engradado <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> que <a href="https://github.com/immunant/c2rust/tree/master/c2rust-asm-casts"><code>c2rust-asm-casts</code></a> esse problema graças ao sistema do tipo Rust, usando funções de <a href="">característica</a> e auxiliar que expandem e truncam automaticamente operandos vinculados a um tamanho interno grande o suficiente para acomodar os dois operandos.  O código acima traduz corretamente para o seguinte: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> __d0: c_int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> __d1: c_int = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Reference to the output value of the first operand let fresh5 = &amp;mut __d0; // The internal storage for the first tied operand let fresh6; // Reference to the output value of the second operand let fresh7 = &amp;mut __d1; // The internal storage for the second tied operand let fresh8; // Input value of the first operand let fresh9 = (::std::mem::size_of::&lt;fd_set&gt;() as c_ulong).wrapping_div(::std::mem::size_of::&lt;__fd_mask&gt;() as c_ulong); // Input value of the second operand let fresh10 = &amp;mut *fdset.__fds_bits.as_mut_ptr().offset(0) as *mut __fd_mask; asm!("cld; rep; stosq" : "={cx}" (fresh6), "={di}" (fresh8) : "{ax}" (0), // Cast the input operands into the internal storage type // with optional zero- or sign-extension "0" (AsmCast::cast_in(fresh5, fresh9)), "1" (AsmCast::cast_in(fresh7, fresh10)) : "memory" : "volatile"); // Cast the operands out (types are inferred) with truncation AsmCast::cast_out(fresh5, fresh9, fresh6); AsmCast::cast_out(fresh7, fresh10, fresh8);</span></span></code> </pre> <br>  É importante notar que esse código não requer nenhum tipo de valores de entrada e saída na montagem do código do assembler; ao resolver conflitos de tipo, <code>fresh6</code> <code>fresh8</code> Rust (principalmente tipos <code>fresh6</code> e <code>fresh8</code> ). <br><br><h3>  Variáveis ​​globais alinhadas </h3><br>  A última fonte da falha foi a seguinte variável global que armazena a constante SSE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ssemask[<span class="hljs-number"><span class="hljs-number">16</span></span>] __attribute__((aligned(<span class="hljs-number"><span class="hljs-number">16</span></span>))) = { <span class="hljs-string"><span class="hljs-string">"\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x00\x00\x00\x00"</span></span> };</code> </pre> <br>  Atualmente, o Rust suporta o atributo de alinhamento para tipos estruturais, mas não para variáveis ​​globais, ou seja,  elementos <code>static</code> .  Nós pensamos em maneiras de resolver esse problema no caso geral, no Rust ou no C2Rust, mas por enquanto no ioquake3 decidimos corrigi-lo manualmente com um pequeno arquivo de <a href="https://github.com/immunant/ioq3/blob/master/asm-snapvector.patch">patch</a> .  Esse arquivo de correção substitui o equivalente ao <code>ssemask</code> do Rust <code>ssemask</code> seguinte: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C, align(16))]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SseMask</span></span></span></span>([<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">16</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ssemask: SseMask = SseMask([ <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ]);</code> </pre> <br><h2>  Executando o quake3-rs </h2><br>  Quando a <code>cargo build --release</code> , os binários são criados, mas são criados sob <code>target/release</code> com uma estrutura de diretório que o binário <code>ioquake3</code> não reconhece.  Escrevemos um <a href="">script</a> que cria links simbólicos no diretório atual para recriar a estrutura de diretórios correta (incluindo links para arquivos <code>.pk3</code> contendo recursos do jogo): <br><br><pre> <code class="bash hljs">$ /path/to/make_quake3_rs_links.sh /path/to/quake3-rs/target/release /path/to/paks</code> </pre> <br>  O caminho <code>/path/to/paks</code> deve apontar para o diretório que contém os arquivos <code>.pk3</code> . <br><br>  Agora vamos rodar o jogo!  Precisamos passar <code>+set vm_game 0</code> , etc., portanto, carregamos esses módulos como bibliotecas compartilhadas Rust, e não como um assembly QVM, além de <code>cl_renderer</code> para usar o renderizador OpenGL1. <br><br><pre> <code class="bash hljs">$ ./ioquake3 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> sv_pure 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_game 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_cgame 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> vm_ui 0 +<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> cl_renderer <span class="hljs-string"><span class="hljs-string">"opengl1"</span></span></code> </pre> <br>  E ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18e/fb3/94c/18efb394c9f33f6a1cbe78503a25bb4c.png"></div><br>  Lançamos o Quake3 no Rust! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2c/61d/a4f/d2c61da4f8dfcdfb39d9fbd7787070a4.png"></div><br>  Aqui está um vídeo de como transpomos o Quake 3, baixamos o jogo e jogamos um pouco: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lQjvSJLDXW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Você pode estudar as <a href="https://github.com/immunant/ioq3/tree/transpiled/quake3-rs">fontes transpiladas</a> no ramo <code>transpiled</code> do nosso repositório.  Também há uma ramificação <code>refactored</code> contendo as mesmas <a href="https://github.com/immunant/ioq3/tree/refactored/quake3-rs">fontes</a> com vários <a href="https://github.com/immunant/ioq3/blob/transpiled/refactor_commands.txt">comandos de refatoração</a> pré-aplicados. <br><br><h2>  Como transpor </h2><br>  Se você quiser transpor o Quake 3 e executá-lo, lembre-se de que precisará de seus próprios recursos de jogo ou recursos de demonstração do Quake 3 da Internet.  Você também precisará instalar o C2Rust (no momento da redação, a versão noturna necessária é <code>nightly-2019-12-05</code> , mas recomendamos que você procure no <a href="https://github.com/immunant/c2rust">repositório do</a> C2Rust ou em <a href="https://crates.io/crates/c2rust">crates.io</a> para encontrar a versão mais recente): <br><br><pre> <code class="bash hljs">$ cargo +nightly-2019-12-05 install c2rust</code> </pre> <br>  e cópias de nossos repositórios C2Rust e ioquake3: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> &lt;a href=<span class="hljs-string"><span class="hljs-string">"/cdn-cgi/l/email-protection"</span></span> class=<span class="hljs-string"><span class="hljs-string">"__cf_email__"</span></span> data-cfemail=<span class="hljs-string"><span class="hljs-string">"dcbbb5a89cbbb5a8b4a9bef2bfb3b1"</span></span>&gt;[email protected]&lt;/a&gt;:immunant/c2rust.git $ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> &lt;a href=<span class="hljs-string"><span class="hljs-string">"/cdn-cgi/l/email-protection"</span></span> class=<span class="hljs-string"><span class="hljs-string">"__cf_email__"</span></span> data-cfemail=<span class="hljs-string"><span class="hljs-string">"dcbbb5a89cbbb5a8b4a9bef2bfb3b1"</span></span>&gt;[email protected]&lt;/a&gt;:immunant/ioq3.git</code> </pre> <br>  Como alternativa à instalação do <code>c2rust</code> usando o comando acima, você pode criar o C2Rust manualmente usando <code>cargo build --release</code> .  De qualquer forma, o repositório C2Rust ainda será necessário, pois contém os scripts de wrapper do compilador necessários para transpor o ioquake3. <br><br>  <code>ssemask</code> um <a href="">script</a> que transporta automaticamente o código C e aplica o patch <code>ssemask</code> .  Para usá-lo, execute o seguinte comando no nível superior do repositório <code>ioq3</code> : <br><br><pre> <code class="bash hljs">$ ./transpile.sh &lt;/path/to/C2Rust repository&gt; &lt;/path/to/c2rust binary&gt;</code> </pre> <br>  Este comando deve criar um subdiretório <code>quake3-rs</code> contendo o código Rust, para o qual você pode executar o <code>cargo build --release</code> e as etapas restantes descritas acima. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt483142/">https://habr.com/ru/post/pt483142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt483130/index.html">O que fazer se o código para a fechadura da mala for esquecido?</a></li>
<li><a href="../pt483132/index.html">Projeto e fabricação de um telescópio</a></li>
<li><a href="../pt483134/index.html">Teste de autenticação de dois fatores e possíveis soluções alternativas</a></li>
<li><a href="../pt483136/index.html">Verificando o MacBook usado antes da compra - lista de verificação</a></li>
<li><a href="../pt483140/index.html">Polígonos Outro Mundo: Amiga 500</a></li>
<li><a href="../pt483144/index.html">O cientista He Jiankui é um herói, não um criminoso</a></li>
<li><a href="../pt483146/index.html">Conferência DEFCON 27. Kraken Wireless WiFi Hacking Tool</a></li>
<li><a href="../pt483148/index.html">Discutimos gêmeos digitais e simulação com o fundador de uma empresa de consultoria</a></li>
<li><a href="../pt483154/index.html">Gastei US $ 40 mil e arruinei uma ótima idéia para uma startup</a></li>
<li><a href="../pt483156/index.html">Coloque o gato de pé</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>