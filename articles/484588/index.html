<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîå üßò üò∑ Modelo automatizado de gesti√≥n de programas üë®üèª‚Äçüé® ü•¢ üñäÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introducci√≥n 
 En [1], se respondi√≥ a la pregunta de lo que se considera programaci√≥n autom√°tica (AP), pero el modelo de una m√°quina de estados fin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modelo automatizado de gesti√≥n de programas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484588/"><h3>  1. Introducci√≥n </h3><br>  En [1], se respondi√≥ a la pregunta de lo que se considera programaci√≥n autom√°tica (AP), pero el modelo de una m√°quina de estados finitos (SC) no se describi√≥ en detalle como un modelo de control de programas autom√°ticos.  Est√° claro que un aut√≥mata abstracto puro no es adecuado para este papel, porque  limitado por el n√∫mero de canales.  Pero el modelo estructural del aut√≥mata, as√≠ como la teor√≠a de los aut√≥matas estructurales que le corresponden, todav√≠a no permiten dar una respuesta sobre la elecci√≥n del modelo de aut√≥mata. <br><br>  El problema comienza con el hecho de que entre los muchos trabajos sobre la teor√≠a de aut√≥matas finitos (TCA) hay pocos que den una definici√≥n del modelo de un aut√≥mata estructural finito (SCA).  Es cierto que uno puede entender que un aut√≥mata estructural es un diagrama [estructural] de aut√≥matas elementales (elementos funcionales) que implementa un modelo de aut√≥mata abstracto [2].  Recuerde que, de acuerdo con la teor√≠a, todo comienza con la creaci√≥n de un modelo de dispositivo en forma de aut√≥mata abstracto, y luego la tarea es sintetizar un circuito digital que lo implemente [3]. <br><br>  La programaci√≥n a primera vista se parece un poco a una s√≠ntesis de circuitos digitales.  Pero solo al principio.  En primer lugar, todo comienza con un algoritmo.  En segundo lugar, los problemas estructurales de organizar e implementar circuitos digitales y programaci√≥n tienen mucho en com√∫n, especialmente en el contexto de la programaci√≥n paralela.  Pero discutiremos el tema del paralelismo por separado.  Mientras tanto, nuestra tarea es elegir y / o modificar el modelo de una m√°quina de estados finitos, lo que ser√≠a comprensible, conveniente y agradable para los programadores mimados por diversas herramientas de software. <br><br>  Es cierto que la pregunta es inmediatamente l√≥gica: ¬øpor qu√© un "kit de herramientas autom√°tico" m√°s y bastante inusual?  Intentaremos responder a esta pregunta definiendo un modelo de control autom√°tico [anidado], considerando tambi√©n sus ventajas en comparaci√≥n con el modelo de programaci√≥n habitual. <br><a name="habracut"></a><br><h3>  2. Definici√≥n del modelo de control de programas autom√°ticos. </h3><br>  En el proceso de evoluci√≥n, la pr√°ctica de la programaci√≥n ha formado ciertos requisitos para el modelo de gesti√≥n del programa.  Debe reconocerse que el modelo de una m√°quina cl√°sica de estados finitos les corresponde bastante poco.  Y si la tarea es utilizar aut√≥matas en la programaci√≥n, entonces debe adaptarse.  Esto es deseable hacerlo en el marco de la teor√≠a de los aut√≥matas.  Las principales reclamaciones al AP existente se reducen al hecho de que esta condici√≥n se viola. <br><br>  <i>Definici√≥n 1.</i> Llamamos a la <i>forma normal disyuntiva de aut√≥matas finitos (DNFA)</i> aut√≥matas finitos completamente definidos cuyas transiciones est√°n etiquetadas por conjunciones elementales de variables l√≥gicas. <br><br>  El modelo de ADN se basa en modelos formales de <i>aut√≥matas</i> totalmente (totalmente) definidos <i>con un estado abstracto</i> [4] y <i>aut√≥matas l√≥gicos</i> [5]. <br><br>  <i>Definici√≥n 2.</i> Llamamos a la <i>forma disyuntiva de un aut√≥mata finito (DFA) un</i> aut√≥mata en forma de un DFA que contiene solo <i>las transiciones resultantes</i> . <br><br>  Las transiciones marcadas con se√±ales de salida y las transiciones con un gui√≥n en lugar de las se√±ales de salida que cambian el estado actual del aut√≥mata se clasifican como transiciones efectivas.  Las transiciones que no est√°n incluidas en la descripci√≥n del aut√≥mata disyuntivo constituyen una <i>adici√≥n del DKA (DDA)</i> al aut√≥mata DFA completamente definido.  Tal adici√≥n es un aut√≥mata que consiste en estados aislados con transiciones en forma de bucles y con guiones en lugar de las se√±ales de salida. <br><br><h3>  3. El modelo de memoria para el modelo de c√°lculo AP </h3><br>  La presencia de muchas entradas y salidas del DFA establece el paralelismo de los operadores / funciones de software asociados con √©l.  Para su correcta implementaci√≥n, se requiere un modelo de memoria del tipo CREW (lectura simult√°nea exclusiva - escritura) [6].  Dentro de su marco, la lectura de valores de datos actuales est√° permitida por parte del conjunto de todas las funciones (predicados y acciones), y solo una de ellas puede cambiar <i>datos generales</i> para acciones ejecutables paralelas. <br><br>  El modelo de control autom√°tico, en contraste con el modelo inform√°tico de subprocesos m√∫ltiples, limita claramente la ejecuci√≥n de los operadores / funciones del programa autom√°tico a los l√≠mites de un ciclo de tiempo discreto.  En tal situaci√≥n, cualquier cambio en la memoria por acciones realizadas en el ciclo de reloj actual puede escribirse en la <i>"memoria oculta"</i> , de modo que despu√©s de que se completen y antes del inicio del siguiente ciclo de reloj discreto, se conviertan en sus nuevos valores. <br><br>  La interacci√≥n de los operadores de programas de aut√≥matas con la memoria se denominar√° <i>modelo de memoria oculta</i> .  Este modelo es una parte esencial del modelo general de programaci√≥n autom√°tica.  Asegura la correcci√≥n del funcionamiento paralelo de los operadores AP y simplifica la programaci√≥n de procesos paralelos. <br><br>  Dentro del marco del modelo de memoria, en realidad no se necesitan mecanismos complejos y poco confiables para la sincronizaci√≥n multiproceso de los procesos (para m√°s detalles ver [7]).  Pero si es necesario, debido a la equivalencia de aut√≥matas y <i>esquemas gr√°ficos de algoritmos (GAW)</i> [8], el modelo de programaci√≥n autom√°tica no limita su aplicaci√≥n. <br><br><h3>  4. Modelos anidados e inerciales de aut√≥matas </h3><br>  La tarea de crear un modelo del elemento l√≥gico del retraso, elegido adem√°s como ejemplo, por un lado, demuestra los problemas del modelo cl√°sico del aut√≥mata y, por otro lado, refleja las cualidades del modelo DKA que resuelve problemas algor√≠tmicos con medios m√°s visuales y convenientes.  El modelo introducido de aut√≥matas anidados genera una subclase de modelos de aut√≥matas, en lo sucesivo denominados <i>aut√≥matas inerciales</i> , y una subclase correspondiente de <i>algoritmos inerciales</i> . <br><br>  Entonces, que sea la tarea de crear un modelo discreto de un elemento l√≥gico de retardo que implemente la transmisi√≥n de una se√±al de entrada binaria.  Adem√°s, los tiempos de sus retrasos t01 y t10, respectivamente, a los estados unitarios y cero en el caso general no coinciden. <br><br>  El modelo m√°s simple de un <i>solo retraso</i> en forma de aut√≥mata Mealy se muestra en la Fig.  1 (ver, para comparaci√≥n, el modelo de retraso en [2]).  Sus retrasos est√°n determinados por un √∫nico ciclo de reloj discreto.  Se presentan modelos m√°s complejos de retrasos en el <i>transporte</i> (para m√°s detalles sobre los tipos de retrasos, v√©ase [9]) en forma de un aut√≥mata Miley y un modelo combinado de Miley-Moore, respectivamente, en la Fig.  2a y la fig.  2b. <br><br><img src="https://habrastorage.org/webt/1v/1j/pw/1v1jpwicourr8xbg6yf2egq5nxk.jpeg" alt="imagen"><br>  Fig.  1. Modelo de unidad de retraso en forma de aut√≥mata Miles <br><br><img src="https://habrastorage.org/webt/di/bf/-d/dibf-daun_zrsuqr6hohywv2le0.jpeg" alt="imagen"><br>  Fig.  2. El modelo de retraso de transporte de Miles (a) y Miles-Moore (b) <br><br>  La se√±al de entrada x3 (recordamos que en el programa autom√°tico corresponde al predicado [1]) toma un valor verdadero si el valor del contador de reloj es igual al valor de la variable t igual al retraso t01 o t10.  El valor de la variable t se asigna a las se√±ales y3 e y4 (en el programa, las funciones de acci√≥n del mismo nombre que las se√±ales de salida).  Las se√±ales y1, y2 establecen el valor de la variable que representa la salida del modelo.  La se√±al y5 incrementa el contador del reloj, que se restablece mediante la se√±al y6. <br><br>  <i>Observaci√≥n 2. Los estados internos del modelo en la Fig.</i>  <i>1, es conveniente asociarlo con un estado de salida de un elemento.</i>  <i>Esto nos permite excluir no solo los operadores y1 e y2, sino tambi√©n la propia variable de salida.</i> <i><br></i> <br>  La implementaci√≥n de la incorporaci√≥n de aut√≥matas similar a las subrutinas de llamadas forma la tecnolog√≠a de la programaci√≥n de aut√≥matas modulares.  Al mismo tiempo, a nivel de software, en contraste con intentos similares a nivel de hardware (ver [10] para comparaci√≥n), esto es mucho m√°s simple.  Para hacer esto, debe insertar la llamada al programa del aut√≥mata anidado, y luego el n√∫cleo de la implementaci√≥n de aut√≥matas, como un procesador normal, organiza el retorno del control al nivel actual de anidamiento. <br><br>  <i>Definici√≥n 3. Los aut√≥matas anidados</i> se denominar√°n aut√≥matas con un estado final, cuya transici√≥n inicia el procedimiento de volver al nivel (rango) anterior de anidamiento. <br><br>  La implementaci√≥n correcta de la anidaci√≥n de aut√≥matas impone restricciones en el procedimiento para su creaci√≥n.  En primer lugar, un aut√≥mata anidado solo puede estar subordinado.  Adem√°s, un aut√≥mata de nivel superior, excluido el rango cero, tambi√©n puede ser un aut√≥mata anidado.  En segundo lugar, en cualquier transici√≥n <b>solo</b> se puede crear <b>un</b> aut√≥mata anidado.  El mecanismo de los aut√≥matas anidados tambi√©n crea la base para la implementaci√≥n de algoritmos recursivos basados ‚Äã‚Äãen el control autom√°tico. <br><br><img src="https://habrastorage.org/webt/8c/4u/e5/8c4ue5ufusdgforqughwh5aw83w.jpeg" alt="imagen"><br>  Fig.  3. Modelo de retraso en forma de aut√≥matas anidados <br><br>  La Fig. 3 muestra el modelo de retraso, donde la Fig. 3a representa el modelo de nivel superior, y las Fig. 3b y Fig.  3c: variantes de aut√≥matas anidados para el transporte y <i>los</i> retrasos de <i>inercia</i> (para m√°s detalles sobre los tipos de retrasos, consulte [8]).  Al mismo tiempo, estos son ejemplos de dos tipos de aut√≥matas anidados: <i>ordinarios</i> e <i>inerciales</i> .  El tipo de un aut√≥mata anidado se define por el nombre de sus estados finales: un estado con el nombre "00" determina la salida habitual del aut√≥mata anidado, y un estado con el nombre "XX" no cambia el estado actual del aut√≥mata de nivel superior. <br><br>  Una explicaci√≥n importante para comprender el algoritmo de retraso de inercia.  Para ello (ver Fig. 3c), el valor del predicado x1 depende de la transici√≥n en la que se crea el aut√≥mata incorporado.  En otras palabras, el predicado en el estado "0" controla la preservaci√≥n de "cero" en la entrada, y en el estado "1", por el contrario, "unidades".  Si el valor en la entrada es cero en el valor cero de la salida, entonces necesita devolver el valor verdadero.  Adem√°s, si se viola la estabilidad de la entrada (el valor x1 es falso) y el tiempo de retraso no ha expirado (el valor x3 es falso), la salida de la m√°quina integrada se realiza a trav√©s del estado de inercia (ver Fig. 3c). <br><br>  <i>Definici√≥n 4. Los</i> aut√≥matas, incluida la llamada de aut√≥matas anidados que tienen un estado de inercia final, se denominar√°n <i>aut√≥matas inerciales</i> . <br><br>  En el modelo de la Fig. 3a, la acci√≥n z1 (el s√≠mbolo z se selecciona para los nombres de acciones que incluyen una llamada a un aut√≥mata anidado) crea un aut√≥mata anidado si se define un valor de retraso.  Como parte de esta acci√≥n, se determina el tipo de retraso especificado, de acuerdo con el cual se crea uno de los aut√≥matas anidados, que se muestra en la Fig. 3b o la Fig.  3c. <br><br>  En el nivel superior de la jerarqu√≠a, la vista del aut√≥mata en la Fig. 3a coincide completamente en estructura con el modelo en la Fig. 1, y solo difiere en presencia de acciones en las transiciones.  Los retrasos con aut√≥matas anidados tienen una forma m√°s simple en comparaci√≥n con el modelo de un solo nivel en la figura 2.  Un aut√≥mata anidado tambi√©n puede considerarse como una especie de "aut√≥mata de biblioteca" al que se puede llamar desde cualquier otro aut√≥mata. <br><br><h3>  3. Programaci√≥n de aut√≥matas de objetos. </h3><br>  El modelo de control autom√°tico, adem√°s de la forma gr√°fica, tambi√©n tiene una forma tabular simple: una tabla de transici√≥n (TP), que se puede interpretar eficazmente en C ++.  Dentro de su marco, un programa de aut√≥mata separado (o una parte de √©l) y, en consecuencia, su definici√≥n en forma de un circuito de programa S puede ser representado por una clase.  En este caso, los modelos de memoria corresponder√°n a las propiedades de la clase, el conjunto de operaciones corresponder√° a los m√©todos de la clase y el control autom√°tico en forma de TP describir√° el comportamiento de la clase.  La introducci√≥n del control en la clase nos permite hablar sobre objetos activos, tambi√©n llamados a menudo agentes, etc. <br><br>  Muchos objetos con comportamiento en forma de control de aut√≥matas formalizan el concepto de un <i>programa paralelo de aut√≥matas de objetos</i> .  En este caso, el modelo de cualquier programa paralelo puede representarse mediante un diagrama de programa en el que el control C se presentar√° en forma de una red de aut√≥matas, donde los aut√≥matas componentes describen el comportamiento de los objetos activos, la memoria M est√° representada por una combinaci√≥n de propiedades de objetos, y muchos operadores A est√°n representados por una combinaci√≥n de m√©todos de objetos de programa. <br><br>  En el entorno VKPA, la funci√≥n del lenguaje de programaci√≥n automatizado se asigna al lenguaje C ++.  En ‚ÄúC ++ autom√°tico‚Äù, los objetos est√°n dotados de actividad / comportamiento y tienen los medios para describir e implementar paralelismo, tanto a nivel de m√©todos de objetos individuales como a nivel de describir la operaci√≥n paralela de muchos objetos. <br><br>  Las implementaciones de objetos existentes de AP son bastante complicadas.  En VKPa, su implementaci√≥n de objetos se basa en la interpretaci√≥n de aut√≥matas y el control dedicado del programa.  A diferencia de la implementaci√≥n directa de aut√≥matas, utilizada, por ejemplo, en la tecnolog√≠a SWITH, esto elimina el procedimiento para convertir un modelo de aut√≥mata en un modelo de diagrama de flujo.  El algoritmo de interpretaci√≥n utilizado en VKPa es similar al m√©todo de interpretaci√≥n de tablas de decisi√≥n de E. Hamby [12]. <br><br>  A menos que se especifique lo contrario, asociaremos a√∫n m√°s el concepto de un programa de aut√≥matas con el concepto de un <i>objeto de aut√≥matas (AO)</i> en el sentido de OOP, pero teniendo en cuenta el concepto de un programa paralelo de aut√≥matas de objetos presentado anteriormente.  Debido a esto, los operadores y la memoria del AP se determinar√°n a trav√©s de los m√©todos y propiedades de los objetos activos.  Los objetos de aut√≥matas se distinguen de los objetos ordinarios por la presencia de comportamiento determinado por el modelo de m√°quina de estados. <br><br><h3>  4. Conclusiones </h3><br>  Crear un modelo de aut√≥matas anidados es un paso hacia un cambio cualitativo en la tecnolog√≠a de programaci√≥n.  El modelo de inercia descrito del aut√≥mata es similar al concepto de estados hist√≥ricos en UML.  La incrustaci√≥n habitual de aut√≥matas tiene una programaci√≥n anal√≥gica, la "incrustaci√≥n inercial" no la tiene, porque  En un programa, no puede volver a un comando que precede a una llamada de subrutina.  Y estos son elementos de una diferencia cualitativa entre la programaci√≥n autom√°tica y la programaci√≥n ordinaria. <br><br>  Por supuesto, puede introducir la memoria en la sombra en la programaci√≥n ordinaria y denotar el paralelismo de las funciones.  Pero en el marco del modelo de aut√≥mata, todo esto tiene una forma org√°nica, tanto en t√©rminos de descripci√≥n como en t√©rminos de rendimiento.  Todo est√° determinado por el paralelismo natural del modelo.  El modelo de diagrama de bloques no tiene tales capacidades. <br><br>  Los objetos activos tambi√©n ampl√≠an las capacidades de programaci√≥n.  Pero el "contenedor de objetos", por su parte, afecta cualitativamente la programaci√≥n autom√°tica, simplificando los procedimientos para invocar e implementar aut√≥matas anidados.  Por lo tanto, el uso de las propiedades de clase [local] le permite implementar no solo la incrustaci√≥n, sino tambi√©n cualquier algoritmo recursivo. <br><br><div class="spoiler">  <b class="spoiler_title">Referencias</b> <div class="spoiler_text">  1. M√°quina de Turing, como modelo de programas autom√°ticos.  [Recurso electr√≥nico], Modo de acceso: <a href="https://habr.com/ru/post/481998/">habr.com/en/post/481998</a> , gratis.  Yaz  Ruso  (fecha de tratamiento 07.01.2020). <br>  2. KUDRYAVTSEV VB, Aleshin S.V., PODKOLZIN A.S.  Introducci√≥n a la teor√≠a de aut√≥matas - M.: Ciencia.  Ch.  ed.  Phys.-Math.  lit., 1985 .-- 320 p. <br>  3. GLUSHKOV V.M.  S√≠ntesis de m√°quinas digitales.  M .: Fizmatgiz, 1962. <br>  4. ZAKREVSKY A.D.  S√≠ntesis l√≥gica de esquemas en cascada.  - M .: Ciencia.  Ch.  ed.  Phys.-mat.  lit., 1981. - 416 p. <br>  5. KUZNETSOV O.P.  Gr√°ficos de aut√≥matas l√≥gicos y sus transformaciones // Automatizaci√≥n y telemec√°nica.  - 1975. - No. 9.‚Äì S. 149-158. <br>  6. Kormen T., Leiserson Ch., Rivest R. Algoritmos: construcci√≥n y an√°lisis - M .: MCCMO, 2001. - 960 p. <br>  7. BUCH G., RAMBO J., JACOBSON I. UML.  Manual de usuario.  Segunda edicion.  Academia IT: Mosc√∫, 2007 .-- 493 p. <br>  8. BARANOV S.I.  S√≠ntesis de firmware  - L .: Energ√≠a, 1979.- 232s. <br>  9. ARMSTRONG J.R.  Modelado de sistemas digitales en el lenguaje VHDL: Traducci√≥n del ingl√©s / M .: Mir, 1992. - 175 p. <br>  10. HAMBARTSUMYAN A.A., ZAPOLSKYH E.N.  Acerca de un enfoque para la descomposici√≥n temporal de aut√≥matas.  Yo, Avtomat.  y Telemech., 1981, n√∫mero 2, 135-144 <br>  11. SHALYTO A. A. El paradigma de la programaci√≥n autom√°tica.  Bolet√≠n cient√≠fico y t√©cnico de la Universidad Estatal de San Petersburgo de Tecnolog√≠as de la Informaci√≥n, Mec√°nica y √ìptica.  Vol.  53. Programaci√≥n automatizada.  2008, p.  3-23. <br>  12. HAMBI E. Tablas de decisiones de programaci√≥n.  M .: Mir, 1976 .-- 86 p. <br></div></div></div></div><p>Source: <a href="https://habr.com/ru/post/484588/">https://habr.com/ru/post/484588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484578/index.html">Objetivos del nivel de servicio: experiencia de Google (traducci√≥n del cap√≠tulo del libro de Google SRE)</a></li>
<li><a href="../484580/index.html">Lo que necesita saber sobre simuladores para memoria</a></li>
<li><a href="../484582/index.html">ASP.NET MVC: Entity Framework, MySQL y el uso de Dependency Resolver para seleccionar un repositorio</a></li>
<li><a href="../484584/index.html">¬øPor qu√© necesitamos un gerente en un proyecto de TI y qu√© suceder√° cuando no lo sea?</a></li>
<li><a href="../484586/index.html">Trabaja con IPv6 en PHP</a></li>
<li><a href="../484590/index.html">Para que los chicos no se avergonzaran de mostrar</a></li>
<li><a href="../484592/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 398 (13-19 de enero de 2020)</a></li>
<li><a href="../484596/index.html">Blazor Client Side Online Store: Parte 1 - Autorizaci√≥n oidc (oauth2) + Identity Server4</a></li>
<li><a href="../484600/index.html">Microsoft Ignite The Tour Praga Conferencia t√©cnica</a></li>
<li><a href="../484602/index.html">Libro "Desarrollo de aplicaciones m√≥viles en C # para iOS y Android"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>