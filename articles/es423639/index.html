<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèø ü§æ ü§πüèæ Escritura m√°s eficiente de matrices en memoria persistente de contrato inteligente en Solidity üë©üèæ‚Äçü§ù‚Äçüë®üèø ü§òüèæ üéÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, tuve que trabajar un poco con la cadena de bloques Ethereum . La idea en la que estaba trabajando requer√≠a almacenar un n√∫mero bastante...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escritura m√°s eficiente de matrices en memoria persistente de contrato inteligente en Solidity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423639/"> Recientemente, tuve que trabajar un poco con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cadena de bloques Ethereum</a> .  La idea en la que estaba trabajando requer√≠a almacenar un n√∫mero bastante grande de enteros directamente en la cadena de bloques para que el contrato inteligente tuviera un acceso conveniente a ellos.  La mayor√≠a de las lecciones sobre el desarrollo de contratos inteligentes nos dicen: "no almacenen muchos datos en la cadena de bloques, ¬°es costoso!"  Pero, ¬øcu√°nto es "mucho" y cu√°nto sube demasiado el precio para un uso pr√°ctico?  Ten√≠a que averiguarlo, porque no pod√≠amos hacer que nuestros datos se desconectaran, toda la idea se derrumb√≥. <br><br>  Estoy empezando a trabajar con Solidity y EVM, por lo que este art√≠culo no pretende ser la verdad definitiva, pero no pude encontrar otros materiales sobre este tema ni en ruso ni en ingl√©s (aunque es muy malo que no lo haya encontrado antes) ), as√≠ que espero que pueda ser √∫til para alguien.  Bueno, o como √∫ltimo recurso, puede ser √∫til para m√≠ si camaradas experimentados me dicen c√≥mo y d√≥nde me equivoco exactamente. <br><br>  Para empezar, decid√≠ averiguar r√°pidamente si podemos hacerlo.  Tomemos el tipo de contrato est√°ndar y generalizado: el token <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ERC20</a> .  Al menos, dicho contrato almacena en la cadena de bloques la correspondencia de las direcciones de las personas que compraron tokens a sus saldos.  En realidad, solo se almacenan los saldos, cada uno de los cuales ocupa 32 bytes (de hecho, no tiene sentido guardarlo aqu√≠ debido a las caracter√≠sticas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solidity</a> y EVM).  Un token m√°s o menos exitoso puede tener f√°cilmente decenas de miles de propietarios, y as√≠ obtenemos que almacenar aproximadamente 320,000 bytes en la cadena de bloques es perfectamente aceptable.  ¬°Y no necesitamos m√°s! <br><br><h2>  Enfoque ingenuo </h2><br>  Bueno, tratemos de guardar nuestros datos.  Una parte importante de ellos son enteros sin signo de 8 bits, por lo que transferiremos su matriz al contrato e intentaremos escribirlos en la memoria de solo lectura: <br><a name="habracut"></a><br><pre><code class="javascript hljs">uint8[] m_test; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint8[] data</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ m_test = data; }</code> </pre> <br>  Goofy!  Esta funci√≥n come gas, como si no fuera en s√≠ misma.  ¬°Un intento de ahorrar 100 valores nos cost√≥ 814033 gas, 8100 gas por byte! <br><br>  Exhala y da un paso atr√°s hacia la teor√≠a.  ¬øCu√°l es el costo m√≠nimo (en gas) de almacenar datos en la cadena de bloques Ethereum?  Debe recordarse que los datos se almacenan en bloques de 32 bytes.  EVM puede leer o escribir solo un bloque completo a la vez, por lo que idealmente, los datos a escribir deben empaquetarse de la manera m√°s eficiente posible para que un solo comando de escritura se guarde m√°s inmediatamente.  Porque este mismo comando de grabaci√≥n, SSTORE, solo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuesta 20,000 gases</a> (si escribimos en una celda de memoria en la que no hemos escrito antes).  Entonces, nuestro m√≠nimo te√≥rico, ignorando todos los dem√°s gastos, es de aproximadamente 625 gases por byte.  ¬°Lejos del 8100 que obtuvimos en el ejemplo anterior!  Ahora es el momento de profundizar y descubrir qui√©n est√° comiendo nuestro gas y c√≥mo detenerlo. <br><br>  Nuestro primer impulso deber√≠a ser mirar el c√≥digo generado por el compilador Solidity de nuestra l√≠nea solitaria (m_test = data), porque no hay nada m√°s que ver.  Este es un impulso bueno y correcto que nos familiarizar√° con un hecho aterrador: ¬°el compilador en este lugar gener√≥ algunos horrores antiguos que no entender√°s a primera vista!  Echando un vistazo r√°pido a la lista, vemos no solo SSTORE (que se espera), sino tambi√©n SLOAD (carga desde la memoria de solo lectura) e incluso EXP (exponenciaci√≥n).  En general, parece una forma muy costosa de registrar datos.  Y lo peor de todo, resulta bastante obvio que SSTORE tambi√©n se llama, con demasiada frecuencia.  ¬øQu√© est√° pasando aqu√≠? <br><br>  Algunas cosas  Resulta que almacenar enteros de 8 bits es casi lo peor que puede hacer con EVM / Solidity (el art√≠culo, un enlace al que cit√© al principio, habla sobre esto).  Perdemos productividad (lo que significa que pagamos m√°s gasolina) a cada paso.  En primer lugar, cuando pasamos una matriz de valores de 8 bits a la entrada de nuestra funci√≥n, cada uno de ellos se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">expande</a> a 256 bits.  Es decir, ¬°solo por el tama√±o de los datos de la transacci√≥n ya perdemos 32 veces!  Agradable  Sin embargo, un lector atento notar√° que el costo del byte almacenado es, sin embargo, solo 13 veces mayor que el m√≠nimo te√≥rico, y no 32, lo que significa que si bien se guarda el contrato en la memoria permanente, no todo es tan malo.  Aqu√≠ est√° la cosa: al guardar, todav√≠a empaqueta los datos, y en la memoria permanente del contrato nuestros n√∫meros de 8 bits se almacenar√°n de la manera m√°s eficiente, 32 piezas en cada bloque de memoria.  Esto plantea la pregunta, pero ¬øc√≥mo es la conversi√≥n de los n√∫meros desempaquetados de "256 bits" que nos llegaron en la entrada de la funci√≥n en un formato empaquetado?  La respuesta es "la forma m√°s est√∫pida que puedo imaginar". <br><br>  Si escribimos todo lo que sucede de forma simplificada, nuestra l√≠nea de c√≥digo solitaria se convierte en un ciclo misterioso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; data.length; ++i) { <span class="hljs-comment"><span class="hljs-comment">//      ,    256-bit  8-bit uint8 from_value = uint8(data[i]); //  32-     -        ,     uint256 to_value = get_storage_data_at_offset(m_test, i); //        (    2  ) add_byte_to_value(to_value, i % 32, from_value); //  32-      set_storage_data_at_offset(m_test, i, to_value); }</span></span></code> </pre><br>  La apariencia de este c√≥digo casi no se ve afectada al activar o desactivar la optimizaci√≥n (al menos en el compilador Solidity versi√≥n 0.4.24), y como puede ver, llama a SSTORE (como parte de set_storage_data_at_offset) 32 veces m√°s de lo necesario (una vez para cada n√∫mero de 8 bits, y no una vez para 32 de esos n√∫meros).  Lo que nos salva del fiasco completo es que volver a grabar en la misma celda no cuesta 20,000, sino 5,000 gas.  Entonces, cada 32 bytes nos cuesta 20,000 + 5,000 * 31 = 125,000 gas, o aproximadamente 4,000 gas por byte.  El resto del valor que vimos anteriormente proviene de la lectura de la memoria (tambi√©n no es una operaci√≥n barata) y otros c√°lculos ocultos en el c√≥digo anterior en las funciones (y hay muchos de ellos). <br><br>  Bueno, no podemos hacer nada con el compilador, <s>por lo que buscaremos un bot√≥n</s> .  Solo queda concluir que no es necesario transferir y almacenar en los arreglos contractuales de n√∫meros de 8 bits de esta manera. <br><br><h2>  Soluci√≥n simple para n√∫meros de 8 bits. </h2><br>  ¬øY que es necesario?  Y entonces: <br><br><pre> <code class="javascript hljs">bytes m_test; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes data</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ m_test = data; }</code> </pre><br>  Operamos en todos los campos de tipo bytes.  Con este enfoque, guardar 100 valores costar√° 129914 de gas, ¬°solo 1300 de gas por byte, 6 veces mejor que usar uint8 []!  El costo de esto ser√° un inconveniente: los elementos de una matriz de bytes de tipo son de tipo bytes1, que no se convierte autom√°ticamente a ninguno de los tipos enteros habituales, por lo que deber√° colocar la conversi√≥n de tipo expl√≠cita en los lugares correctos.  No es muy agradable, pero la ganancia es 6 veces el costo de grabaci√≥n, ¬°creo que vale la pena!  Y s√≠, perderemos un poco cuando trabajemos con estos datos, al leer, en comparaci√≥n con el almacenamiento de cada n√∫mero como 256 bits, pero aqu√≠ la escala comienza a importar: la ganancia de guardar mil o dos n√∫meros de 8 bits en forma empaquetada puede , dependiendo de la tarea, superan las p√©rdidas al leerlas m√°s tarde. <br><br>  Antes de llegar a este enfoque, primero intent√© escribir una funci√≥n m√°s eficiente para guardar datos en el macro ensamblador local <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JULIA</a> , pero encontr√© algunos problemas que hicieron que mi soluci√≥n fuera un poco menos eficiente, y di un consumo de aproximadamente 1530 gases. por byte  Sin embargo, todav√≠a es √∫til para nosotros en este art√≠culo, por lo que el trabajo no se hizo en vano. <br><br>  Adem√°s, noto que cuantos m√°s datos guarde a la vez, menor ser√° el costo por byte, lo que sugiere que parte del costo es fijo.  Por ejemplo, si guarda 3000 valores, cuando nos acercamos a los bytes obtenemos 900 de gas por byte. <br><br><h2>  Soluci√≥n m√°s general </h2><br>  Bueno, eso, todo est√° bien, eso termina bien, ¬øverdad?  Pero nuestros problemas no terminaron aqu√≠, porque a veces queremos escribir no solo n√∫meros de 8 bits en la memoria del contrato, sino tambi√©n otros tipos de datos que no coinciden directamente con el tipo de bytes.  Es decir, est√° claro que cualquier cosa puede codificarse en el b√∫fer de bytes, pero obtenerlo desde all√≠ m√°s adelante puede que ya no sea conveniente e incluso costoso debido a gestos innecesarios para convertir la memoria en bruto al tipo deseado.  Entonces, la funci√≥n que guarda la matriz de bytes transmitidos en una matriz del tipo deseado sigue siendo √∫til para nosotros.  Es bastante simple, pero me llev√≥ mucho tiempo encontrar toda la informaci√≥n necesaria y comprender EVM y JULIA para escribirla, y todo esto no se recopil√≥ en un solo lugar.  Por lo tanto, creo que ser√° √∫til si traigo aqu√≠ lo que desenterr√©. <br><br>  Para comenzar, hablemos sobre c√≥mo Solidity almacena una matriz en la memoria.  Las matrices son un concepto que existe solo en el marco de Solidity, EVM no sabe nada sobre ellas, sino que simplemente almacena una matriz virtual de 2 ^ 256 bloques de 32 bytes.  Est√° claro que los bloques vac√≠os no se almacenan, pero de hecho, tenemos una tabla de bloques no vac√≠os, cuya clave es un n√∫mero de 256 bits.  Y es precisamente este n√∫mero el que aceptan los comandos EVM SSTORE y SLOAD como entrada (esto no es del todo obvio en la documentaci√≥n). <br><br>  Para almacenar matrices, Solidity hace una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cosa</a> tan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dif√≠cil</a> : en primer lugar, la matriz de bloques "principal" est√° asignada en alg√∫n lugar de la memoria constante, en el orden habitual de colocaci√≥n de los miembros del contrato (o estructuras, pero esta es una canci√≥n separada), como si fuera N√∫mero normal de 256 bits.  Esto asegura que la matriz reciba un bloque completo, independientemente de otras variables almacenadas.  Este bloque almacena la longitud de la matriz.  Pero dado que no se conoce de antemano y puede cambiar (estamos hablando de matrices din√°micas aqu√≠), los autores de Solidity necesitaban averiguar d√≥nde colocar los datos de la matriz para que no se crucen accidentalmente con los datos de otra matriz.  Estrictamente hablando, esta es una tarea insoluble: si crea dos matrices de m√°s de 2 ^ 128 de longitud, entonces se garantiza que se intersecar√°n donde no las coloque, pero en la pr√°ctica nadie deber√≠a hacer esto, por lo que se usa este simple truco: tome el hash SHA3 del n√∫mero del bloque principal de la matriz , y el n√∫mero resultante se usa como una clave en la tabla de bloques (que, recuerdo, 2 ^ 256).  Con esta tecla, se coloca el primer bloque de datos de la matriz y el resto, secuencialmente, si es necesario.  La probabilidad de colisi√≥n de matrices no gigantes es extremadamente peque√±a. <br><br>  Por lo tanto, en teor√≠a, todo lo que tenemos que hacer es encontrar d√≥nde est√°n los datos de la matriz y copiar el b√∫fer de bytes que nos pasa bloque por bloque.  Mientras trabajamos con tipos m√°s peque√±os que la mitad del tama√±o del bloque, al menos ganaremos ligeramente la soluci√≥n "ingenua" generada por el compilador. <br><br>  Solo queda un problema: si todo se hace as√≠, los bytes de nuestra matriz resultar√°n al rev√©s.  Porque EVM es big-endian.  La forma m√°s f√°cil y efectiva, por supuesto, es implementar bytes al enviar, pero por la simplicidad de la API, decid√≠ hacer esto en el c√≥digo del contrato.  Si desea guardar algo m√°s, no dude en descartar esta parte de la funci√≥n y hacer todo al momento del env√≠o. <br><br>  Aqu√≠ est√° la funci√≥n que tengo para convertir una matriz de bytes en una matriz de enteros con signo de 64 bits (sin embargo, se puede adaptar f√°cilmente a otros tipos): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign_int64_storage_from_bytes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">int64[] storage to, bytes memory from</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internal</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    .      int64,     8    (sizeof  Solidity  :( ) to.length = from.length / 8; //     ,  SHA3      uint256 addr; bytes32 base; assembly{ // keccak256   ,    ,          mstore(addr, to_slot) base := keccak256(addr, 32) } uint i = 0; for(uint offset = 0; offset &lt; from.length; offset += 32) { //  32-     //     32  -  ,   ,     uint256 tmp; assembly{ tmp := mload(add(from, add(offset,32))) } //   .  ,     ,       . for(uint b = 0; b &lt; 16; ++b) { uint shift = b*8; uint shift2 = (256 - (b+1)*8); uint low = (tmp &amp; (0xFF &lt;&lt; shift)) &gt;&gt; shift; uint high = (tmp &amp; (0xFF &lt;&lt; shift2)) &gt;&gt; shift2; tmp = tmp &amp; ~( (0xFF &lt;&lt; shift) | (0xFF &lt;&lt; shift2)); tmp = tmp | (low &lt;&lt; shift2) | (high &lt;&lt; shift); } //      assembly{ sstore(add(base, i), tmp) } i += 1; } }</span></span></code> </pre><br>  Con los n√∫meros de 64 bits, ganamos no tanto como con los de 8 bits, en comparaci√≥n con el c√≥digo que genera el compilador, pero esta funci√≥n consume 718466 de gas (7184 de gas por n√∫mero, 898 de gas por byte) frente a 1003225 para los ingenuos. soluciones (1003 gas por n√∫mero, 1254 por byte), lo que hace que su uso sea bastante significativo.  Y como se mencion√≥ anteriormente, puede ahorrar m√°s eliminando la direcci√≥n de byte a la persona que llama. <br><br>  Vale la pena se√±alar que el l√≠mite de gas por unidad en Ethereum establece un l√≠mite para la cantidad de datos que podemos registrar en una transacci√≥n.  Para empeorar las cosas, agregar datos a una matriz ya llena es una tarea mucho m√°s complicada, excepto cuando el √∫ltimo bloque usado de la matriz se llen√≥ hasta el l√≠mite (en cuyo caso puede usar la misma funci√≥n, pero con una sangr√≠a diferente).  En este momento, el l√≠mite de gas por bloque es de aproximadamente 6 millones, lo que significa que podemos ahorrar m√°s o menos 6Kb de datos a la vez, pero en realidad a√∫n menos, debido a otros gastos. <br><br><h2>  Pr√≥ximos cambios </h2><br>  Los pr√≥ximos cambios en la red Ethereum en octubre, que ocurrir√°n con la activaci√≥n de los EIP que pertenecen a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Constantinopla</a> , deber√≠an facilitar y abaratar el almacenamiento de datos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EIP 1087</a> sugiere que la tarifa de almacenamiento de datos no se cobrar√° por cada comando SSTORE, sino por la cantidad de bloques modificados, lo que har√° que el enfoque ingenuo utilizado por el compilador sea casi tan rentable como el c√≥digo escrito manualmente en JULIA (pero no del todo, habr√° muchos movimientos corporales adicionales all√≠, especialmente para valores de 8 bits).  La transici√≥n planificada a WebAssembly como el lenguaje base de EVM cambiar√° la imagen a√∫n m√°s, pero esto a√∫n es una perspectiva muy lejana, y tenemos que resolver los problemas ahora. <br><br>  Esta publicaci√≥n no pretende ser la mejor soluci√≥n para el problema, y ‚Äã‚Äãme alegrar√° si alguien ofrece una m√°s efectiva: reci√©n comenc√© a comenzar con Ethereum y podr√≠a perder de vista algunas caracter√≠sticas de EVM que podr√≠an ayudarme.  Pero en mis b√∫squedas en la red, no vi nada sobre este tema, y ‚Äã‚Äãtal vez los pensamientos y el c√≥digo anteriores ser√°n √∫tiles para alguien como punto de partida para la optimizaci√≥n. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423639/">https://habr.com/ru/post/es423639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423629/index.html">Gesti√≥n de cambios en la infraestructura de TI de Mars</a></li>
<li><a href="../es423631/index.html">Dos habilidades que te ayudar√°n a convertirte en un gran desarrollador</a></li>
<li><a href="../es423633/index.html">Utilizamos 54 leyes federales para el beneficio de la contabilidad del hogar</a></li>
<li><a href="../es423635/index.html">Reproductor de audiolibros de estilo retro</a></li>
<li><a href="../es423637/index.html">7 lecciones pr√°cticas sobre UX</a></li>
<li><a href="../es423641/index.html">Deep Learning y OpenVINO Toolkit. Respuestas de expertos de Intel</a></li>
<li><a href="../es423643/index.html">Los bancos controlan cada vez m√°s la reputaci√≥n de los clientes: investigaci√≥n de Business Insider</a></li>
<li><a href="../es423645/index.html">C√≥mo servimos a la infraestructura de TI de Luzhniki durante la Copa del Mundo</a></li>
<li><a href="../es423647/index.html">Crea una red neuronal simple</a></li>
<li><a href="../es423649/index.html">"Kubernetes a todos los campos!" - Entrevista con el comit√© del programa de la conferencia DevOops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>