<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💯 👩🏼‍⚖️ 😃 Exploration du shader de sable du jeu Journey 😯 👏🏿 👩🏻‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parmi les nombreux jeux indépendants sortis au cours des 10 dernières années, l'un de mes favoris est définitivement Journey . Grâce à son esthétique ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exploration du shader de sable du jeu Journey</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476448/">  Parmi les nombreux jeux indépendants sortis au cours des 10 dernières années, l'un de mes favoris est définitivement <em>Journey</em> .  Grâce à son esthétique époustouflante et sa belle bande sonore, <em>Journey</em> est devenu un exemple d'excellence dans presque tous les aspects du développement. <br><br>  Je suis développeur de jeux et artiste technique, j'ai donc été le plus intrigué par la façon dont le sable a été rendu.  Ce n'est pas seulement beau, mais aussi directement lié au gameplay de base et au gameplay dans son ensemble.  <em>Journey</em> est littéralement construit de sable, et sans un tel effet étonnant, le jeu lui-même ne pourrait tout simplement pas exister. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/be0/2a8/63fbe02a87ccac8101001a43d953776f.jpg"></div><br>  Dans cet article en deux articles, je rendrai hommage à l'héritage de <em>Journey</em> en vous apprenant à recréer exactement le même rendu de sable à l'aide de shaders.  Que les dunes de sable soient nécessaires dans votre jeu, cette série de didacticiels vous permettra d'apprendre à recréer une esthétique spécifique dans votre propre jeu.  Si vous souhaitez recréer le magnifique shader de sable utilisé dans <em>Journey</em> , vous devez d'abord comprendre comment il a été construit.  Et bien qu'il semble extrêmement complexe, il se compose en fait de plusieurs effets relativement simples.  Cette approche de l'écriture de shaders est nécessaire pour devenir un artiste technique à succès.  Par conséquent, j'espère que vous ferez ce <em>voyage</em> avec moi, dans lequel nous explorerons non seulement la création de shaders, mais aussi apprendre à combiner l'esthétique et le gameplay. <br><a name="habracut"></a><br><h1>  Analyse de sable dans Journey </h1><br>  Cet article, comme de nombreuses autres tentatives pour recréer le rendu de sable <em>Journey</em> , est basé sur un rapport de GDC que l'ingénieur principal de la société John Edwards, intitulé " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">Sand Rendering in Journey</a> ".  Dans cet exposé, John Edwards parle de toutes les couches d'effets ajoutées aux dunes de sable de <em>Journey</em> pour obtenir le bon look. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wt2yYnBRD3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Le rapport est très utile, mais dans le contexte de ce didacticiel, de nombreuses limitations et décisions prises par John Edwards ne sont pas importantes.  Nous allons essayer de recréer les shaders de sable, qui rappellent le shader <em>Journey</em> , principalement par des références visuelles. <br><br>  Commençons par un simple maillage 3D d'une dune parfaitement lisse.  La crédibilité du rendu du sable dépend de deux aspects: l'éclairage et le grain.  Un moyen intéressant de réfléchir la lumière du sable est fourni par un <strong>modèle d'éclairage</strong> modifié.  Dans le contexte du codage des shaders, le modèle d'éclairage détermine les ombres et les reflets en fonction des propriétés du modèle et des conditions d'éclairage de la scène. <br><br>  Cependant, tout cela ne suffit pas pour créer l'illusion du réalisme.  Le problème est que le sable ne peut tout simplement pas être modélisé avec des surfaces planes.  Le grain de sable doit être pris en considération.  C'est pourquoi il existe deux effets distincts qui fonctionnent directement avec la <strong>normale à la surface</strong> , qui peuvent être utilisés pour simuler de petites particules de sable à la surface de la dune. <br><br>  Le diagramme ci-dessous montre tous les effets que nous allons apprendre dans ce tutoriel.  D'un point de vue technique, des calculs normaux sont effectués avant le traitement de l'éclairage.  Pour faciliter l'étude, les effets seront décrits dans un ordre différent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/0b9/8a1/3730b98a1670ef00cf68efb0af0cc08b.png"></div><br><h6>  Couleur diffuse </h6><br>  L'effet de shader de sable le plus simple est sa <strong>couleur diffuse</strong> , qui décrit grossièrement la composante <em>terne</em> de l'apparence générale.  La couleur diffuse est calculée en fonction de la couleur <em>réelle</em> de l'objet et des conditions d'éclairage.  Une sphère peinte en blanc ne sera pas parfaitement blanche partout, car la couleur diffuse dépend de la lumière incidente sur elle.  Les couleurs diffuses sont calculées à l'aide d'un modèle mathématique qui se rapproche de la réflexion de la lumière d'une surface.  Grâce à un rapport de John Edwards avec le GDC, nous connaissons exactement l'équation utilisée, qu'il appelle la <strong>réflectance à contraste diffus</strong> ;  il est basé sur le modèle bien connu de <strong>réflexions Lambert</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/509/4c1/65b/5094c165b5f2e1ba10696fec1641482c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br>  <i>Avant et après l'application de l'équation</i> <br><br><h6>  Sable normal </h6><br>  La géométrie d'origine est complètement lisse.  Pour compenser cela, la <strong>normale de surface du</strong> modèle est modifiée à l'aide d'une technique appelée <strong>bump mapping</strong> .  Il vous permet d'utiliser une texture pour simuler une géométrie plus complexe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><h6>  Éclairage de bord </h6><br>  Chaque niveau <em>Journey</em> utilise une palette de couleurs limitée.  Pour cette raison, il est assez difficile de comprendre où se termine une dune et où commence une autre.  Pour augmenter la lisibilité, la technique de petite mise en évidence de ce qui n'est visible que le long du bord de la dune est utilisée.  Il s'agit de l' <strong>éclairage de jante</strong> , et il existe de nombreuses façons de le mettre en œuvre.  Pour ce tutoriel, j'ai choisi une méthode basée <strong>sur les</strong> réflexions de <strong>Fresnel</strong> qui modélise les réflexions sur les surfaces polies à des <em>angles</em> dits d' <em>incidence</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><h6>  Miroir reflet de l'océan </h6><br>  L'un des aspects les plus agréables <em>du</em> gameplay de <em>Journey</em> est la possibilité de «surfer» sur les dunes de sable.  C'est probablement pourquoi cette entreprise de jeux vidéo voulait que le sable ressemble plus à un liquide qu'à un solide.  Pour cela, une forte réflexion a été utilisée, que l'on retrouve souvent dans les shaders à eau.  John Edwards appelle cet effet l' <strong>océan spéculaire</strong> , et dans le tutoriel, nous l'implémentons en utilisant la <strong>réflexion de Blinn-Fong</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><h6>  Reflet éblouissant </h6><br>  L'ajout d'un composant spéculaire océanique au shader de sable lui donne un aspect plus fluide.  Cependant, il ne permet toujours pas de transmettre l'un des aspects visuels les plus importants du sable: les réflexions aléatoires.  Dans les vraies dunes, cet effet se produit car chaque grain de sable réfléchit la lumière dans sa direction et très souvent l'un de ces rayons réfléchis pénètre dans notre œil.  Une telle <strong>réflexion scintillante</strong> (réflexion des réflexions) se produit même dans des endroits où la lumière directe du soleil ne tombe pas;  il complète l'océan spéculaire et renforce le sentiment de crédibilité. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><h6>  Vagues de sable </h6><br>  Changer les normales nous a permis de simuler l'effet de petits grains de sable recouvrant la surface de la dune.  Sur les dunes du monde réel, des vagues provoquées par le vent apparaissent souvent.  Leur forme varie en fonction de la pente et de la position de chaque dune par rapport à la direction du vent.  Potentiellement, de tels motifs peuvent être créés grâce à une texture de relief, mais dans ce cas, il sera impossible de changer la forme des dunes en temps réel.  La solution proposée par John Edwards est similaire à une technique appelée <strong>ombrage triplanaire</strong> : elle utilise quatre textures différentes, mélangées selon la position et la pente de chaque dune. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/828/9b4/997/8289b49971bbe0046845f71284790124.png"></div><br><h1>  Journey Sand Shader Anatomy </h1><br>  Unity propose de nombreux modèles de shaders pour vous aider à démarrer.  Puisque nous sommes intéressés par les matériaux pouvant recevoir de l'éclairage et des ombres projetées, nous devons commencer par le <strong>shader de</strong> surface (shader de surface). <br><br>  Tous <strong>les shaders de surface</strong> sont réalisés en deux étapes.  Tout d'abord, <strong>une fonction de surface</strong> est appelée qui recueille les propriétés de la surface à rendre, par exemple son <em>albédo</em> , sa <em>rugosité</em> , ses <em>propriétés métalliques</em> , sa <em>transparence</em> et sa <em>direction normale</em> .  Ensuite, toutes ces propriétés sont transférées à <strong>la fonction d'éclairage</strong> , qui prend en compte l'influence des sources de lumière externes et calcule l'ombrage et l'éclairage. <br><br><h2>  Fonction de surface </h2><br>  Commençons par ce qui devient le cœur de notre fonction de surface, appelé dans le code <code>surf</code> ci-dessous.  Les seules propriétés que nous devons définir sont la <em>couleur du sable</em> et la <strong>normale à la surface</strong> .  La normale d'un modèle 3D est un vecteur indiquant la position de la surface.  Les vecteurs normaux sont utilisés par la fonction d'éclairage pour calculer la manière dont la lumière sera réfléchie.  Ils sont généralement calculés lors de l'importation du maillage.  Cependant, ils peuvent être modifiés pour simuler une géométrie plus complexe.  C'est ici que les effets <strong>sable normal</strong> et <strong>vagues de</strong> <strong>sable</strong> déforment la norme sable pour simuler sa rugosité. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); N = SandNormal (N); o.Normal = N; }</code> </pre> <br>  Lorsque vous écrivez des normales à <code>o.Normal</code> elles doivent être exprimées dans un <strong>espace tangent</strong> .  Cela signifie que le vecteur est sélectionné par rapport à la surface du modèle 3D.  Autrement dit, <code>float3(0, 0, 1)</code> signifie en fait qu'aucune modification n'est réellement apportée au modèle 3D normal. <br><br>  Les deux fonctions, <code>RipplesNormal</code> et <code>SandNormal</code> reçoivent <code>SandNormal</code> le vecteur normal et le modifient.  Plus tard, nous verrons comment cela peut être fait. <br><br><h2>  Fonction d'éclairage </h2><br>  C'est dans la fonction d'éclairage que tous les autres effets sont implémentés.  Le code ci-dessous montre comment chaque composant individuel est calculé dans des fonctions distinctes (couleur diffuse, éclairage du bord, réflexion spéculaire de l'océan et paillettes).  Ensuite, ils sont tous combinés. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Journey fullforwardshadows float4 LightingJourney (SurfaceOutput s, fixed3 viewDir, UnityGI gi) { float3 diffuseColor = DiffuseColor (); float3 rimColor = RimLighting (); float3 oceanColor = OceanSpecular (); float3 glitterColor = GlitterSpecular (); float3 specularColor = saturate(max(rimColor, oceanColor)); float3 color = diffuseColor + specularColor + glitterColor; return float4(color * s.Albedo, 1); }</span></span></code> </pre> <br>  La méthode de combinaison des composants est assez arbitraire et nous permet de la changer pour étudier les possibilités artistiques. <br><br>  En règle générale, les réflexions spéculaires s’empilent sur les couleurs diffuses.  Puisqu'il n'y a pas ici une, mais trois réflexions spéculaires ( <em>lumière du bord</em> , <em>spéculaire océanique</em> et <em>spéculaire scintillant</em> ), nous devons être plus prudents afin de ne pas faire scintiller le sable <em>trop</em> .  Puisque la lumière de la jante et l'océan spéculaire font partie du même effet, nous ne pouvons en choisir que la valeur maximale.  Le spéculaire scintillant est ajouté séparément car ce composant crée du sable vacillant. <br><br><h2>  Partie 2. Couleur diffuse </h2><br>  Dans la deuxième partie de l'article, nous nous concentrerons sur le modèle d'éclairage utilisé dans le jeu et sur cela.  comment le recréer dans Unity. <br><br>  Dans la partie précédente, nous avons jeté les bases de ce qui deviendra progressivement notre version du shader de sable Journey.  Comme mentionné précédemment, <strong>la fonction d'éclairage est</strong> utilisée dans <strong>les shaders de surface</strong> pour calculer l'effet de l'éclairage, de sorte que les ombres et les reflets apparaissent sur la surface.  Nous avons découvert que Journey a plusieurs effets qui entrent dans cette catégorie.  Nous commencerons par l'effet le plus basique (et le plus simple) que l'on retrouve au coeur de ce shader: son <strong>éclairage</strong> diffus ( <strong>éclairage</strong> diffus / diffus). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78f/166/71c/78f16671c754f05e619ce034fad81926.png"></div><br>  Pour l'instant, nous omettons tous les autres effets et composants, en nous concentrant sur l' <strong>éclairage du sable</strong> . <br><br>  La fonction d'éclairage que nous avons <code>DiffuseColor</code> dans la partie précédente de l'article intitulée <code>LightingJourney</code> délègue simplement le calcul de la couleur diffuse du sable à une fonction appelée <code>DiffuseColor</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightingJourney</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SurfaceOutput s, fixed3 viewDir, UnityGI gi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Lighting properties float3 L = gi.light.dir; float3 N = s.Normal; // Lighting calculation float3 diffuseColor = DiffuseColor(N, L); // Final color return float4(diffuseColor, 1); }</span></span></code> </pre> <br>  Du fait que chaque effet est autonome et stocké dans sa propre fonction, notre code sera plus modulaire et plus propre. <br><br><h2>  Réflexion Lambert </h2><br>  Avant de créer un éclairage diffus "comme dans Journey", il est agréable de voir à quoi ressemble la fonction d'éclairage diffus "basique".  La technique d'ombrage la plus simple pour les matériaux mats est appelée <strong>réflectance lambertienne</strong> .  Ce modèle se rapproche de l'apparence de la plupart des surfaces non brillantes et non métalliques.  Il doit son nom au scientifique encyclopédique suisse <strong>Johann Heinrich Lambert</strong> , qui a proposé son concept en 1760. <br><br>  Le concept de réflexion de Lambert est basé sur une idée simple: la <em>luminosité d'une surface dépend de la quantité de lumière qui y est incidente</em> .  Géométriquement, cela peut être illustré dans le diagramme ci-dessous, où la sphère est éclairée par une source de lumière à distance.  Bien que les zones rouges et vertes de la sphère reçoivent la même quantité d'éclairage, leurs surfaces sont sensiblement différentes.  Si la lumière dans la zone rouge est distribuée sur une plus grande zone, cela signifie que chaque unité du carré rouge reçoit moins de lumière que le vert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/d48/495/2cfd484953877a47fe5ba564b399ea35.png"></div><br>  Théoriquement, la réflexion de Lambert dépend de l'angle relatif entre la <em>surface</em> et la <em>lumière incidente</em> .  D'un point de vue mathématique, nous disons qu'il s'agit d'une fonction de la <strong>normale à la surface</strong> et à la <strong>direction de l'illumination</strong> .  Ces quantités sont exprimées à l'aide de deux vecteurs de longueur unitaire (appelés <strong>vecteurs unitaires</strong> ) <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> N </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> L </script>  .  Les vecteurs simples sont un moyen standard de spécifier des <em>directions</em> dans le contexte du codage des shaders. <br><br><div class="spoiler">  <b class="spoiler_title">La valeur de N et L</b> <div class="spoiler_text">  <strong>Normal</strong> à la surface <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.074ex" viewBox="0 -772.3 888.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> N </script>  Est un vecteur unitaire dirigé <em>loin de</em> la surface elle-même. <br><br>  Par analogie, nous pouvons supposer que la <strong>direction de l'éclairage</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.074ex" viewBox="0 -772.3 681.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> L </script>  pointe <em>de la</em> source de lumière et suit la direction dans laquelle la lumière se déplace.  Mais ce n'est pas le cas: la direction de l'illumination est un vecteur unique pointant <em>dans la direction de la</em> direction d'où provient la lumière. <br><br>  Cela peut être déroutant, surtout si vous êtes nouveau dans la création de shaders.  Cependant, grâce à une telle notation, les équations deviennent plus faciles. </div></div><br><div class="spoiler">  <b class="spoiler_title">Réflexion de Lambert dans l'unité</b> <div class="spoiler_text">  Avant Unity 5 <strong>Standard Shader</strong> , la réflexion Lambert était le modèle standard pour ombrer les surfaces éclairées. <br><br>  Vous pouvez toujours y accéder dans l'inspecteur des matériaux: dans le <em>shader Legacy,</em> il est appelé <em>Diffus</em> . <br><br>  Si vous écrivez votre propre shader de surface, la réflexion Lambert est disponible en tant que fonction d'éclairage appelée <code>Lambert</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Lambert fullforwardshadows</span></span></code> </pre> <br>  Son implémentation se trouve dans la fonction <code>LightingLambert</code> définie dans le fichier <code>CGIncludes\Lighting.cginc</code> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Réflexion de Lambert et climat</b> <div class="spoiler_text">  La réflexion de Lambert est un modèle assez ancien, mais elle permet de comprendre des concepts complexes tels que l'ombrage de surface.  Il peut également être utilisé pour expliquer de nombreux autres phénomènes.  Par exemple, le même diagramme explique pourquoi il fait plus froid aux pôles de la planète qu'à l'équateur. </div></div><br>  Après avoir regardé de plus près, nous pouvons voir que la surface reçoit le maximum d'éclairement lorsque sa normale est parallèle à la direction de l'éclairage.  Et vice versa: il n'y a pas de lumière si deux vecteurs unitaires sont perpendiculaires l'un à l'autre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e1/d06/6c6/0e1d066c6ff998abda8ca5c7607e4c4e.png"></div><br>  De toute évidence, l'angle entre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> N </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> L </script>  critique pour la réflexion selon Lambert.  De plus, la luminosité est maximale et égale à <math></math><img src="https://habrastorage.org/getpro/habr/formulas/35b/e60/e68/35be60e68c535df673e0aef590e20870.svg" alt="100 $ \% $" data-tex="inline">  quand l'angle est <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMAIN-30" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> 0 </script>  et minimal ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-15"><span class="MJXp-mn" id="MJXp-Span-16">0</span><span class="MJXp-mi" id="MJXp-Span-17">%</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.098ex" height="2.298ex" viewBox="0 -832 1334 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMAIN-30" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMAIN-25" x="500" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> 0 \% </script>  ) lorsque l'angle tend à <math></math><img src="https://habrastorage.org/getpro/habr/formulas/1f7/311/bbe/1f7311bbeecd1aa665d6babf72501a8c.svg" alt="90 $ ^ {\ circ} $" data-tex="inline">  .  Si vous connaissez l' <em>algèbre vectorielle</em> , vous pourriez comprendre qu'une quantité représentant la réflexion de Lambert <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-18"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">I</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.172ex" height="2.057ex" viewBox="0 -780.1 504.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-49" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9"> I </script>  est égal à <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-20"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">N</span><span class="MJXp-mtext" id="MJXp-Span-22">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.417ex" height="2.057ex" viewBox="0 -780.1 3624 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-63" x="1138" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-64" x="1572" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-6F" x="2095" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-74" x="2581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4C" x="2942" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-10"> N \ cdot L </script>  où est l'opérateur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-28"><span class="MJXp-mtext" id="MJXp-Span-29">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.771ex" height="2.057ex" viewBox="0 -780.1 2054 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-63" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-64" x="683" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-6F" x="1207" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-74" x="1692" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-11"> \ cdot </script>  appelé <strong>produit scalaire</strong> . <br><br>  (1) <p><math> </math> $$ afficher $$ \ commencer {équation *} I = N \ cdot L \ terminer {équation *} $$ afficher $$ </p><br>  Le produit scalaire est une mesure de la «coïncidence» de deux vecteurs l'un par rapport à l'autre et varie dans l'intervalle de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="MJXp-mo" id="MJXp-Span-41" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-42">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> + 1 </script>  (pour deux vecteurs identiques) à <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-43"><span class="MJXp-mo" id="MJXp-Span-44" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mn" id="MJXp-Span-45">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> -1 </script>  (pour deux vecteurs opposés).  Un produit scalaire est le fondement de l'ombrage, que j'ai examiné en détail dans le didacticiel sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modèles de rendu et d'éclairage physiquement basés</a> . <br><br><h3>  Implémentation </h3><br>  Et pour <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-46"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> N </script>  et à <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> L </script>  Vous pouvez facilement accéder aux fonctions d'éclairage du shader de surface via <code>s.Normal</code> et <code>gi.light.dirin</code> .  Pour simplifier, nous les renommerons dans le code du shader en <code>N</code> et <code>L</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate( dot(N, L) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  <code>saturate</code> fonction <code>saturate</code> limite la valeur de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-50"><span class="MJXp-mn" id="MJXp-Span-51">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> 0 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-52"><span class="MJXp-mn" id="MJXp-Span-53">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> 1 </script>  .  Cependant, comme le produit scalaire se situe dans la plage de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-54"><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mn" id="MJXp-Span-56">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> -1 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-57"><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-59">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> + 1 </script>  , nous devrons travailler uniquement avec ses valeurs négatives.  C'est pourquoi la réflexion Lambert est souvent mise en œuvre comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, L) );</code> </pre> <br><h2>  Réflexion de contraste de la lumière ambiante </h2><br>  Bien que la réflexion de Lambert nuise bien à la plupart des matériaux, elle n'est ni physiquement précise ni photoréaliste.  Dans les jeux plus anciens, les shaders Lambert étaient largement utilisés.  Les jeux qui utilisent cette technique <em>semblent</em> souvent vieux car ils peuvent reproduire par inadvertance l'esthétique des vieux jeux.  Si vous ne vous efforcez pas pour cela, alors la réflexion Lambert devrait être évitée et utiliser une technologie plus moderne. <br><br>  Un tel modèle est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">le modèle de réflexion Oren-Nayyar</a> , qui a été initialement décrit dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">Généralisation du</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">modèle de réflexion</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">de Lambert</a> , publié en 1994 par Michael Oren et Sri C. Nayyar.  Le modèle Oren-Nayyar est une généralisation de la réflexion Lambert et est spécialement conçu pour les surfaces rugueuses.  Initialement, les développeurs de Journey voulaient utiliser la réflexion Oren-Nayyar comme base pour leur shader de sable.  Cependant, cette idée a été abandonnée en raison des coûts de calcul élevés. <br><br>  Dans son rapport de 2013, l'artiste technique John Edwards explique que le modèle de réflexion créé pour le sable Journey était basé sur une série d'essais et d'erreurs.Les développeurs n'avaient pas l'intention de recréer le rendu photoréaliste du désert, mais de donner vie à une esthétique concrète immédiatement reconnaissable. <br><br>  Selon lui, le modèle d'ombrage résultant correspond à cette équation: <br><br>  (2) <p><math> </math> $$ afficher $$ \ commencer {équation *} I = 4 * \ gauche (\ gauche (N \ odot \ gauche [1, 0,3, 1 \ droite] \ droite) \ cdot L \ droite) \ end {équation *} $$ afficher $$ </p><br>  où <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mtext" id="MJXp-Span-84">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> \ odot </script>  - produit <strong>élément par élément de</strong> deux vecteurs. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  Modèle de réflexion (2) John Edwards appelle le <strong>contraste diffus</strong> , nous allons donc utiliser ce nom tout au long du didacticiel. <br><br>  L'animation ci-dessous montre la différence d'ombrage Lambert (à gauche) et le contraste diffus de Journey (à droite). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q-hQiDA71Yg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">Quelle est la signification de 4 et 0,3?</b> <div class="spoiler_text">  Bien que le contraste diffus n'ait pas été conçu pour être physiquement précis, nous pouvons toujours essayer de comprendre ce qu'il fait. <br><br>  À la base, il utilise toujours la réflexion Lambert.  La première différence évidente est que le résultat global est multiplié par <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-89"><span class="MJXp-mn" id="MJXp-Span-90"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><script type="math/tex" id="MathJax-Element-23"> 4 </script>  .  Cela signifie que tous les pixels normalement reçus <math></math><img src="https://habrastorage.org/getpro/habr/formulas/5fc/5d7/0b6/5fc5d70b6ec460d4ee10de0435b3ed01.svg" alt="25 $ \% $" data-tex="inline">  l'éclairage brillera maintenant comme s'il recevait <math></math><img src="https://habrastorage.org/getpro/habr/formulas/35b/e60/e68/35be60e68c535df673e0aef590e20870.svg" alt="100 $ \% $" data-tex="inline">  l'éclairage.  En multipliant tout par <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-91"><span class="MJXp-mn" id="MJXp-Span-92"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><script type="math/tex" id="MathJax-Element-24"> 4 </script>  l'ombrage faible selon Lambert devient beaucoup plus fort, et la région de transition entre l'obscurité et la lumière est plus petite.  Dans ce cas, l'ombre devient plus nette. <br><br>  Effet de la multiplication de la composante <code>y</code> sur la direction normale <math></math><img src="https://habrastorage.org/getpro/habr/formulas/34c/99c/5d3/34c99c5d3317cdd989bf0d0d03e51b22.svg" alt="0,3 $" data-tex="inline">  expliquer est beaucoup plus difficile.  À mesure que les composants du vecteur changent, la direction générale dans laquelle il pointe change.  Réduire la valeur de la composante <code>y</code> à tout <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="MJXp-mn" id="MJXp-Span-94"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30 </font></font></span><span class="MJXp-mi" id="MJXp-Span-95"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></span></span></span><script type="math/tex" id="MathJax-Element-25"> 30 \% </script>  à partir de sa valeur d'origine, la réflexion du contraste diffus fait que les ombres deviennent plus verticales. <br><br>  Remarque: un produit scalaire mesure directement l'angle entre deux vecteurs uniquement s'ils ont tous deux une longueur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mn" id="MJXp-Span-97"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-26"> 1 </script>  .  Le changement effectué réduit la longueur normale <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-98"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><script type="math/tex" id="MathJax-Element-27"> N </script>  qui n'est plus un vecteur unitaire. </div></div><br><h2>  Des nuances de gris à la couleur </h2><br>  Toutes les animations présentées ci-dessus ont des nuances de gris, car elles montrent les valeurs de leur modèle de réflexion, variant dans l'intervalle de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-100"><span class="MJXp-mn" id="MJXp-Span-101">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> 0 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-102"><span class="MJXp-mn" id="MJXp-Span-103">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> 1 </script>  ". Nous pouvons facilement ajouter des couleurs en utilisant <code>NdotL</code> comme coefficient d'interpolation entre deux couleurs: une pour le sable entièrement ombragé et l'autre pour le sable entièrement éclairé. <br><br><pre> <code class="cpp hljs">float3 _TerrainColor; float3 _ShadowColor; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); float3 color = lerp(_ShadowColor, _TerrainColor, NdotL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; }</code> </pre> <br><h2>  Partie 3. Sable normal </h2><br>  Dans la troisième partie, nous nous concentrerons sur la création de cartes normales qui transforment des modèles 3D lisses en dunes de sable. <br><br>  Dans la partie précédente du tutoriel, nous avons implémenté l'éclairage diffus du sable Journey.  En utilisant uniquement cet effet, les dunes du désert sembleront plutôt plates et ennuyeuses. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cb/dd6/9a8/8cbdd69a8a92614469132400c0979c79.png"></div><br>  L'un des effets les plus intrigants de Journey est la granularité du sable.  En regardant n'importe quelle capture d'écran, il nous semble que les dunes ne sont pas lisses et homogènes, mais créées à partir de millions de grains de sable microscopiques. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e93/307/efc/e93307efce359d4830f5894dde30c9e6.jpg"></div><br>  Cet effet peut être obtenu en utilisant une technique appelée <strong>bump mapping</strong> , qui permet à la lumière de rebondir sur une surface plane comme si elle était plus complexe.  Voyez comment cet effet change l'apparence du rendu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br>  De petites différences peuvent être observées avec l'augmentation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3d5/b3f/ea73d5b3fb56c941c9b61f022dcb8699.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f8/efa/5c4/2f8efa5c4926a0de947b8ff91e114498.png"></div><br><h2>  Nous traitons des cartes normales </h2><br>  Le sable se compose d'innombrables grains de sable, chacun ayant sa propre forme et composition (voir ci-dessous).  Chaque particule individuelle réfléchit l'éclairage dans une direction potentiellement aléatoire.  Une façon de réaliser cet effet est de créer un modèle 3D contenant tous ces grains de sable microscopiques.  Mais en raison du nombre incroyable de polygones requis, cette approche n'est pas réalisable. <br><br>  Mais il existe une autre solution souvent utilisée pour simuler une géométrie plus complexe par rapport à un vrai modèle 3D.  Chaque sommet ou face du modèle 3D est associé à un paramètre appelé sa <strong>direction normale</strong> .  Il s'agit d'un vecteur de longueur unitaire utilisé pour calculer la réflexion de la lumière sur la surface d'un modèle 3D.  Autrement dit, pour simuler du sable, vous devez simuler cette distribution apparemment aléatoire de grains de sable, et donc comment ils affectent les normales de surface. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/bc4/cc3/413bc4cc3466b827a1a1d86559d54054.jpg"></div><br>  Cela peut se faire de nombreuses façons.  Le plus simple est de créer une texture qui change la direction des normales d'origine du modèle de dune. <br><br>  <strong>Normal à la surface</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-104"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-30"> N </script>  dans le cas général, il est calculé par la géométrie du modèle 3D.  Cependant, vous pouvez le modifier en utilisant la <strong>carte normale</strong> .  Les cartes normales sont des textures qui vous permettent de simuler une géométrie plus complexe en modifiant l'orientation locale des normales à la surface.  Cette technique est souvent appelée <strong>bump mapping</strong> . <br><br>  Changer les normales est une tâche assez simple qui peut être effectuée dans la fonction <code>surf</code> du <strong>shader de surface</strong> .  Cette fonction prend deux paramètres, dont l'un est une <code>struct</code> appelée <code>SurfaceOutput</code> .  Il contient toutes les propriétés nécessaires au rendu d'une partie d'un modèle 3D, de sa couleur ( <code>o.Albedo</code> ) à sa transparence ( <code>o.Alpha</code> ).  Un autre paramètre qu'il contient est la direction normale ( <code>o.Normal</code> ), qui peut être réécrite pour changer la façon dont la lumière est réfléchie sur le modèle. <br><br>  Selon la documentation Unity sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">Shaders de surface</a> , toutes les normales écrites dans la structure <code>o.Normal</code> doivent être exprimées dans l' <strong>espace tangent</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SurfaceOutput</span></span></span><span class="hljs-class"> {</span></span> fixed3 Albedo; <span class="hljs-comment"><span class="hljs-comment">// diffuse color fixed3 Normal; // tangent space normal, if written fixed3 Emission; half Specular; // specular power in 0..1 range fixed Gloss; // specular intensity fixed Alpha; // alpha for transparencies };</span></span></code> </pre> <br>  Ainsi, nous pouvons signaler que les vecteurs unitaires doivent être exprimés dans le système de coordonnées par rapport à la normale du maillage.  Par exemple, lors de l'écriture dans <code>o.Normal</code> valeurs de <code>float3(0, 0, 1)</code> normal resteront inchangées. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  En effet, le vecteur <code>float3(0, 0, 1)</code> est en fait un vecteur normal exprimé par rapport à la géométrie du modèle 3D. <br><br>  Donc, pour changer la normale à la surface dans le <strong>shader de surface</strong> , il suffit d'écrire un nouveau vecteur dans <strong>la fonction de surface</strong> en <code>o.Normal</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = ... <span class="hljs-comment"><span class="hljs-comment">// change the normal here }</span></span></code> </pre> <br>  Dans le reste de l'article, nous allons créer l'approximation initiale, que nous compliquerons dans la sixième partie du tutoriel. <br><br><h2>  Sable normal </h2><br>  La partie la plus problématique consiste à comprendre <em>comment les</em> grains de sable changent normalement à la surface.  Bien qu'individuellement chaque grain de sable puisse diffuser la lumière dans n'importe quelle direction, dans l'ensemble, quelque chose d'autre se produit.  Toute approche physiquement précise doit étudier la distribution des vecteurs normaux sur la surface du sable et la modéliser mathématiquement.  De tels modèles existent vraiment, mais la solution présentée dans notre tutoriel est beaucoup plus simple, et en même temps très efficace. <br><br>  À chaque point du modèle, un <strong>vecteur unitaire aléatoire est</strong> échantillonné à partir de la texture.  Ensuite, la normale à la surface s'incline d'une certaine quantité vers ce vecteur.  Avec la création correcte d'une texture aléatoire et la sélection d'une quantité appropriée de mélange, nous pouvons déplacer la normale à la surface de manière à créer un sentiment de granulation, sans perdre la courbure globale des dunes. <br><br>  Les valeurs aléatoires peuvent être échantillonnées en utilisant une texture remplie de couleurs aléatoires.  Les composantes R, G et B de chaque pixel sont utilisées comme composantes X, Y et Z du vecteur normal.  Les composants de couleur sont dans la gamme <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-106"><span class="MJXp-mtext" id="MJXp-Span-107">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-111">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-112">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-113">e</span><span class="MJXp-mo" id="MJXp-Span-114" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mn" id="MJXp-Span-115">0</span><span class="MJXp-mo" id="MJXp-Span-116" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-117">1</span><span class="MJXp-mtext" id="MJXp-Span-118">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-120">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124">e</span><span class="MJXp-mo" id="MJXp-Span-125" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-31"> \ gauche [0, 1 \ droite] </script>  , ils doivent donc être convertis en un intervalle <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-126"><span class="MJXp-mtext" id="MJXp-Span-127">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-133">e</span><span class="MJXp-mo" id="MJXp-Span-134" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mo" id="MJXp-Span-135" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-136">1</span><span class="MJXp-mo" id="MJXp-Span-137" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-138" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-139">1</span><span class="MJXp-mtext" id="MJXp-Span-140">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-141">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-143">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-144">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146">e</span><span class="MJXp-mo" id="MJXp-Span-147" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-32"> \ gauche [-1, + 1 \ droite] </script>  .  Ensuite, le vecteur résultant est normalisé de sorte que sa longueur soit égale à <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-148"><span class="MJXp-mn" id="MJXp-Span-149">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> 1 </script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d2/c95/03d/0d2c9503d98fd2463e7e3682743736bd.png"></div><br><div class="spoiler">  <b class="spoiler_title">Créez des textures aléatoires</b> <div class="spoiler_text">  Il existe de nombreuses façons de générer des textures aléatoires.  Pour obtenir l'effet souhaité, le plus important est la distribution générale des vecteurs aléatoires qui peuvent être échantillonnés à partir de la texture. <br><br>  Dans l'image ci-dessus, chaque pixel est complètement aléatoire.  Il n'y a pas de direction générale (couleur) qui prévaut dans la texture, car chaque valeur a la même probabilité que toutes les autres.  Cette texture nous donne un type de sable qui disperse la lumière dans toutes les directions. <br><br>  Lors d'une conférence GDC, John Edwards a clairement indiqué que la texture aléatoire utilisée pour le sable dans Journey était générée à partir d'une distribution gaussienne.  Cela garantit que la direction dominante coïncide avec la normale à la surface. </div></div><br><div class="spoiler">  <b class="spoiler_title">Les vecteurs aléatoires doivent-ils être normalisés?</b> <div class="spoiler_text">  L'image que j'ai utilisée pour échantillonner des vecteurs aléatoires a été générée à l'aide d'un processus complètement aléatoire.  Non seulement chaque pixel est généré individuellement: les composants R, G et B d'un pixel sont également indépendants les uns des autres.  Autrement dit, dans le cas général, les vecteurs échantillonnés à partir de cette texture ne seront pas garantis d'avoir une longueur égale à <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-150"><span class="MJXp-mn" id="MJXp-Span-151"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-34"> 1 </script>  . <br><br>  Bien sûr, vous pouvez générer une texture dans laquelle chaque pixel lors de la conversion de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-152"><span class="MJXp-mtext" id="MJXp-Span-153">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-154"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-155"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-156"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-157"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-158"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-159"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mo" id="MJXp-Span-160" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mn" id="MJXp-Span-161"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-162" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-163"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-165"><font style="vertical-align: inherit;">d </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-166"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-167"><font style="vertical-align: inherit;">o </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-169"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170"><font style="vertical-align: inherit;">e </font></span><span class="MJXp-mo" id="MJXp-Span-171" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;">]</font></span></font><span class="MJXp-mtext" id="MJXp-Span-164">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-165"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-166"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-167"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-169"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-171" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"></font></span></span></span><script type="math/tex" id="MathJax-Element-35"> \ gauche [0, 1 \ droite] </script>  dans <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-172"><span class="MJXp-mtext" id="MJXp-Span-173">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-174"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-175"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-176"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-178"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mo" id="MJXp-Span-180" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mo" id="MJXp-Span-181" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-182"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-183" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mo" id="MJXp-Span-184" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-185"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187"><font style="vertical-align: inherit;">d </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-188"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189"><font style="vertical-align: inherit;">o </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-190"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-192"><font style="vertical-align: inherit;">e </font></span><span class="MJXp-mo" id="MJXp-Span-193" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;">]</font></span></font><span class="MJXp-mtext" id="MJXp-Span-186">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-188"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-190"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-192"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-193" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"></font></span></span></span><script type="math/tex" id="MathJax-Element-36"> \ gauche [-1, + 1 \ droite] </script>  et devra en fait avoir une longueur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-194"><span class="MJXp-mn" id="MJXp-Span-195"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-37"> 1 </script>  .  Cependant, deux problèmes se posent ici. <br><br> ,             . -,    <em> </em>   mip-,             . <br><br>   ,    . </div></div><br><h2>  Implémentation </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la partie précédente du didacticiel, nous nous sommes familiarisés avec le concept de «cartes normales» lorsqu'il est apparu dans le tout premier contour de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la fonction de surface</font></font></strong> <code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En rappelant le diagramme présenté au début de l'article, vous pouvez voir que deux effets sont nécessaires pour recréer le rendu du sable Journey. La première ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normales de sable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) que nous considérons dans cette partie de l'article, et la seconde ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vagues de sable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) que nous étudierons dans la sixième partie.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); <span class="hljs-comment"><span class="hljs-comment">// Covered in Journey Sand Shader #6 N = SandNormal (N); // Covered in this article o.Normal = N; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la section précédente, nous avons introduit le concept de bump mapping, qui nous a montré qu'une partie de l'effet nécessiterait un échantillonnage de la texture (c'est ce qu'on appelle dans le code </font></font><code>uv_SandTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le problème avec le code ci-dessus est que pour les calculs, vous devez connaître la position réelle du point que nous dessinons. En fait, vous avez besoin d'une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coordonnée UV</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour échantillonner la texture </font><font style="vertical-align: inherit;">, qui détermine à partir de quel pixel lire. Si le modèle 3D que nous utilisons est relativement plat et a une conversion UV, alors nous pouvons utiliser son UV pour échantillonner une texture aléatoire.</font></font><br><br><pre> <code class="cpp hljs">N = WavesNormal(IN.uv_SandTex.xy, N); N = SandNormal (IN.uv_SandTex.xy, N);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou vous pouvez également utiliser la position dans le monde ( </font></font><code>IN.worldPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) du point rendu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons enfin nous concentrer sur </font></font><code>SandNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sa mise en œuvre. </font><font style="vertical-align: inherit;">Comme indiqué précédemment dans cette partie, l'idée est d'échantillonner un pixel à partir d'une texture aléatoire et de l'utiliser (après la conversion en un vecteur unitaire) comme nouvelle normale.</font></font><br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment zoomer une texture aléatoire?</font></font></b> <div class="spoiler_text">    UV- 3D-      ,   .      ,       . <br><br>   ,  Unity   .   ,        <code>_SandText_ST</code> . Unity       (  ) <code>_SandTex</code> . <br><br>  <code>_SandText_ST</code>    :     .        ,          <em>Tiling</em>  <em>Offset</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/a84/059/f29a84059ab970f412217f09c87fcf6f.png"></div><br>       ,     <code>TRANSFORM_TEX</code> : <br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; float4 _SandTex_ST; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, TRANSFORM_TEX(uv, _SandTex)).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inclinez les normales </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'extrait de code illustré ci-dessus fonctionne, mais ne produit pas de très bons résultats. La raison en est simple: si nous retournons simplement une normale complètement aléatoire, mais perdons essentiellement la sensation de courbure. En fait, la direction de la normale est utilisée pour calculer comment la lumière doit être réfléchie par la surface, et son objectif principal est d'ombrer le modèle en fonction de sa courbure. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La différence peut être vue dans les images ci-dessous. Ci-dessus, les normales des dunes sont complètement aléatoires, et il est impossible de comprendre où l'une finit et où commence une autre. En dessous, seule la normale du modèle est utilisée, ce qui nous donne une surface trop lisse.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/9cb/acb/6209cbacb616db15bee5f95e314779c8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/476/f0a/f25/476f0af2535dc2d552ce4b01a1d7751a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les deux solutions ne nous conviennent pas. </font><font style="vertical-align: inherit;">Nous avons besoin de quelque chose entre les deux. </font><font style="vertical-align: inherit;">Une direction aléatoire échantillonnée à partir d'une texture doit être utilisée pour </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incliner la</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> normale d'une certaine quantité, comme indiqué ci-dessous:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/929/dfb/7e6/929dfb7e6d4712b7c69a403d0733c25b.png" width="239" height="240"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'opération décrite dans le diagramme est appelée </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slerp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui signifie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpolation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linéaire sphérique (interpolation linéaire sphérique). </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slerp</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonctionne exactement comme lerp, à une exception près - il peut être utilisé pour interpoler en toute sécurité entre des vecteurs unitaires, et le résultat de l'opération sera d'autres vecteurs unitaires. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, l'implémentation correcte de slerp est assez chère. </font><font style="vertical-align: inherit;">Et pour un effet, du moins basé sur le hasard, il est illogique de l'utiliser.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montrez-moi l'équation slerp</font></font></b> <div class="spoiler_text">    , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-196"><span class="MJXp-msubsup" id="MJXp-Span-197"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-199" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-38">p_0</script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-200"><span class="MJXp-msubsup" id="MJXp-Span-201"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-202" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-203" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-39">p_1</script>   ,       .  Alors <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-204"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-205">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-206">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-207">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-208">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-209">p</span></span></span><script type="math/tex" id="MathJax-Element-40">slerp</script>    : <br><br>  (1) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-210"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-211">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-212">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-213">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-214">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-215">p</span><span class="MJXp-mrow" id="MJXp-Span-216"><span class="MJXp-mo" id="MJXp-Span-217" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-218"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-219" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-220" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-221" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-222"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-223" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-224" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-225" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-226">t</span><span class="MJXp-mo" id="MJXp-Span-227" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span><span class="MJXp-mo" id="MJXp-Span-228" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mfrac" id="MJXp-Span-229" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-230">sin</span><span class="MJXp-mo" id="MJXp-Span-231" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-232"><span class="MJXp-mo" id="MJXp-Span-233" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-234"><span class="MJXp-mo" id="MJXp-Span-235" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-236">1</span><span class="MJXp-mo" id="MJXp-Span-237" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-238">t</span><span class="MJXp-mo" id="MJXp-Span-239" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mi" id="MJXp-Span-240">Ω</span><span class="MJXp-mo" id="MJXp-Span-241" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-242">sin</span><span class="MJXp-mo" id="MJXp-Span-243" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-244"><span class="MJXp-mo" id="MJXp-Span-245" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-246">Ω</span><span class="MJXp-mo" id="MJXp-Span-247" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-248"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-249" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-250" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-251" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mfrac" id="MJXp-Span-252" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-253">sin</span><span class="MJXp-mo" id="MJXp-Span-254" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-255"><span class="MJXp-mo" id="MJXp-Span-256" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-257">t</span><span class="MJXp-mi" id="MJXp-Span-258">Ω</span><span class="MJXp-mo" id="MJXp-Span-259" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-260">sin</span><span class="MJXp-mo" id="MJXp-Span-261" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-262"><span class="MJXp-mo" id="MJXp-Span-263" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-264">Ω</span><span class="MJXp-mo" id="MJXp-Span-265" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-266"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-267" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-268" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-41">\begin{equation*} slerp\left(p_0, p_1, t\right) = \frac{\sin\left[\left(1-t\right)\Omega\right]}{\sin\left(\Omega\right)}p_0 + \frac{\sin\left(t\Omega\right)}{\sin\left(\Omega\right)} p_1 \end{equation*}</script> </math></p><br>  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-269"><span class="MJXp-mi" id="MJXp-Span-270">Ω</span></span></span><script type="math/tex" id="MathJax-Element-42">\Omega</script> —     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-271"><span class="MJXp-msubsup" id="MJXp-Span-272"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-273" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-274" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-43">p_0</script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-275"><span class="MJXp-msubsup" id="MJXp-Span-276"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-277" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-278" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-44">p_1</script> ,       : <br><br> (2) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-279"><span class="MJXp-mi" id="MJXp-Span-280">Ω</span><span class="MJXp-mo" id="MJXp-Span-281" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-282">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-283">o</span><span class="MJXp-msubsup" id="MJXp-Span-284"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-285" style="margin-right: 0.05em;">s</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-286" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-287">−</span><span class="MJXp-mn" id="MJXp-Span-288">1</span></span></span><span class="MJXp-mrow" id="MJXp-Span-289"><span class="MJXp-mo" id="MJXp-Span-290" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-291"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-292" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-293" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-294" style="margin-left: 0.267em; margin-right: 0.267em;">⋅</span><span class="MJXp-msubsup" id="MJXp-Span-295"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-296" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-297" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-298" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-45">\begin{equation*} \Omega=cos^{-1} \left(p_0 \cdot p_1 \right) \end{equation*}</script> </math></p><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est important de noter que si nous utilisons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'interpolation linéaire</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> traditionnelle </font><font style="vertical-align: inherit;">, le vecteur résultant sera très différent:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/5e1/42f/eef5e142f1c8c05cac9b3d4f18d8e097.png" width="239" height="240"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'opération Lerp entre deux vecteurs unitaires séparés ne crée pas toujours d'autres vecteurs unitaires. </font><font style="vertical-align: inherit;">En fait, cela ne se produit jamais, sauf si le coefficient est</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-299"><span class="MJXp-mn" id="MJXp-Span-300"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-46-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-46">1</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-301"><span class="MJXp-mn" id="MJXp-Span-302"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-47-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-47">0</script>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Malgré cela, la normalisation du résultat lerp aboutit en fait à un vecteur unité qui est étonnamment proche du résultat généré par slerp: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nlerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 n1, float3 n2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> normalize(lerp(n1, n2, t)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette technique, appelée </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nlerp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , fournit une approximation étroite de slerp. </font><font style="vertical-align: inherit;">Son utilisation a été popularisée par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casey Muratori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , l'un des développeurs de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Witness</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si vous souhaitez en savoir plus sur ce sujet, je vous recommande de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comprendre les articles Slerp. </font><font style="vertical-align: inherit;">Then Not Use It de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonathan Blow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Math Magician - Lerp, Slerp et Nlerp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grâce à nlerp, nous pouvons désormais incliner efficacement les vecteurs normaux d'un côté aléatoire, échantillonnés à partir de </font></font><code>_SandTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _SandStrength; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); // Rotates N towards Ns based on _SandStrength float3 Ns = nlerp(N, S, _SandStrength); return Ns; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le résultat est présenté ci-dessous: </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rddUAStRjZ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Et ensuite </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans la prochaine partie, nous considérerons les reflets vacillants, grâce auxquels les dunes ressembleront à l'océan. </font></font><br><br><h3>  Remerciements </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le jeu vidéo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Journey a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> été </font><font style="vertical-align: inherit;">développé par </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thatgamecompany</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et publié par </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sony Computer Entertainment</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il est disponible pour PC ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Epic Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et PS4 ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des modèles 3D d'arrière-plans de dunes et d'options d'éclairage sont créés par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jiadi Deng</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un modèle 3D du personnage de Journey a été trouvé sur le forum FacePunch (maintenant fermé).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Forfait Unity </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous souhaitez recréer cet effet, le package Unity complet peut être téléchargé depuis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il comprend tout ce dont vous avez besoin, des shaders aux modèles 3D.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476448/">https://habr.com/ru/post/fr476448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476434/index.html">Nous écrivons des pilotes USB pour les appareils abandonnés</a></li>
<li><a href="../fr476436/index.html">Rapports de la première réunion en Russie des développeurs de robots sur Robot Operating System</a></li>
<li><a href="../fr476442/index.html">Donnez de l'espace ou un microcontrôleur comme un fréquencemètre</a></li>
<li><a href="../fr476444/index.html">Démystification des principes de l'informatique quantique</a></li>
<li><a href="../fr476446/index.html">Plugins Jira: quelques exemples de l'invention réussie du vélo</a></li>
<li><a href="../fr476450/index.html">Présentation de cPanel - une console Web pour la gestion des sites et l'hébergement</a></li>
<li><a href="../fr476452/index.html">Stockage de valeur-clé ou comment nos applications sont devenues plus pratiques</a></li>
<li><a href="../fr476454/index.html">La 5G arrive: quelles entreprises assureront l'introduction de nouvelles technologies en 2020</a></li>
<li><a href="../fr476456/index.html">Le système chinois de crédit social n'est tout d'abord pas un système d'évaluation des citoyens, mais une API massive</a></li>
<li><a href="../fr476460/index.html">Le premier format de fichier à succès sur Internet n'était pas MP3, mais MIDI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>