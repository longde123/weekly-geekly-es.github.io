<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíØ üë©üèº‚Äç‚öñÔ∏è üòÉ Exploration du shader de sable du jeu Journey üòØ üëèüèø üë©üèª‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parmi les nombreux jeux ind√©pendants sortis au cours des 10 derni√®res ann√©es, l'un de mes favoris est d√©finitivement Journey . Gr√¢ce √† son esth√©tique ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exploration du shader de sable du jeu Journey</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476448/">  Parmi les nombreux jeux ind√©pendants sortis au cours des 10 derni√®res ann√©es, l'un de mes favoris est d√©finitivement <em>Journey</em> .  Gr√¢ce √† son esth√©tique √©poustouflante et sa belle bande sonore, <em>Journey</em> est devenu un exemple d'excellence dans presque tous les aspects du d√©veloppement. <br><br>  Je suis d√©veloppeur de jeux et artiste technique, j'ai donc √©t√© le plus intrigu√© par la fa√ßon dont le sable a √©t√© rendu.  Ce n'est pas seulement beau, mais aussi directement li√© au gameplay de base et au gameplay dans son ensemble.  <em>Journey</em> est litt√©ralement construit de sable, et sans un tel effet √©tonnant, le jeu lui-m√™me ne pourrait tout simplement pas exister. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/be0/2a8/63fbe02a87ccac8101001a43d953776f.jpg"></div><br>  Dans cet article en deux articles, je rendrai hommage √† l'h√©ritage de <em>Journey</em> en vous apprenant √† recr√©er exactement le m√™me rendu de sable √† l'aide de shaders.  Que les dunes de sable soient n√©cessaires dans votre jeu, cette s√©rie de didacticiels vous permettra d'apprendre √† recr√©er une esth√©tique sp√©cifique dans votre propre jeu.  Si vous souhaitez recr√©er le magnifique shader de sable utilis√© dans <em>Journey</em> , vous devez d'abord comprendre comment il a √©t√© construit.  Et bien qu'il semble extr√™mement complexe, il se compose en fait de plusieurs effets relativement simples.  Cette approche de l'√©criture de shaders est n√©cessaire pour devenir un artiste technique √† succ√®s.  Par cons√©quent, j'esp√®re que vous ferez ce <em>voyage</em> avec moi, dans lequel nous explorerons non seulement la cr√©ation de shaders, mais aussi apprendre √† combiner l'esth√©tique et le gameplay. <br><a name="habracut"></a><br><h1>  Analyse de sable dans Journey </h1><br>  Cet article, comme de nombreuses autres tentatives pour recr√©er le rendu de sable <em>Journey</em> , est bas√© sur un rapport de GDC que l'ing√©nieur principal de la soci√©t√© John Edwards, intitul√© " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">Sand Rendering in Journey</a> ".  Dans cet expos√©, John Edwards parle de toutes les couches d'effets ajout√©es aux dunes de sable de <em>Journey</em> pour obtenir le bon look. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wt2yYnBRD3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Le rapport est tr√®s utile, mais dans le contexte de ce didacticiel, de nombreuses limitations et d√©cisions prises par John Edwards ne sont pas importantes.  Nous allons essayer de recr√©er les shaders de sable, qui rappellent le shader <em>Journey</em> , principalement par des r√©f√©rences visuelles. <br><br>  Commen√ßons par un simple maillage 3D d'une dune parfaitement lisse.  La cr√©dibilit√© du rendu du sable d√©pend de deux aspects: l'√©clairage et le grain.  Un moyen int√©ressant de r√©fl√©chir la lumi√®re du sable est fourni par un <strong>mod√®le d'√©clairage</strong> modifi√©.  Dans le contexte du codage des shaders, le mod√®le d'√©clairage d√©termine les ombres et les reflets en fonction des propri√©t√©s du mod√®le et des conditions d'√©clairage de la sc√®ne. <br><br>  Cependant, tout cela ne suffit pas pour cr√©er l'illusion du r√©alisme.  Le probl√®me est que le sable ne peut tout simplement pas √™tre mod√©lis√© avec des surfaces planes.  Le grain de sable doit √™tre pris en consid√©ration.  C'est pourquoi il existe deux effets distincts qui fonctionnent directement avec la <strong>normale √† la surface</strong> , qui peuvent √™tre utilis√©s pour simuler de petites particules de sable √† la surface de la dune. <br><br>  Le diagramme ci-dessous montre tous les effets que nous allons apprendre dans ce tutoriel.  D'un point de vue technique, des calculs normaux sont effectu√©s avant le traitement de l'√©clairage.  Pour faciliter l'√©tude, les effets seront d√©crits dans un ordre diff√©rent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/0b9/8a1/3730b98a1670ef00cf68efb0af0cc08b.png"></div><br><h6>  Couleur diffuse </h6><br>  L'effet de shader de sable le plus simple est sa <strong>couleur diffuse</strong> , qui d√©crit grossi√®rement la composante <em>terne</em> de l'apparence g√©n√©rale.  La couleur diffuse est calcul√©e en fonction de la couleur <em>r√©elle</em> de l'objet et des conditions d'√©clairage.  Une sph√®re peinte en blanc ne sera pas parfaitement blanche partout, car la couleur diffuse d√©pend de la lumi√®re incidente sur elle.  Les couleurs diffuses sont calcul√©es √† l'aide d'un mod√®le math√©matique qui se rapproche de la r√©flexion de la lumi√®re d'une surface.  Gr√¢ce √† un rapport de John Edwards avec le GDC, nous connaissons exactement l'√©quation utilis√©e, qu'il appelle la <strong>r√©flectance √† contraste diffus</strong> ;  il est bas√© sur le mod√®le bien connu de <strong>r√©flexions Lambert</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/509/4c1/65b/5094c165b5f2e1ba10696fec1641482c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br>  <i>Avant et apr√®s l'application de l'√©quation</i> <br><br><h6>  Sable normal </h6><br>  La g√©om√©trie d'origine est compl√®tement lisse.  Pour compenser cela, la <strong>normale de surface du</strong> mod√®le est modifi√©e √† l'aide d'une technique appel√©e <strong>bump mapping</strong> .  Il vous permet d'utiliser une texture pour simuler une g√©om√©trie plus complexe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><h6>  √âclairage de bord </h6><br>  Chaque niveau <em>Journey</em> utilise une palette de couleurs limit√©e.  Pour cette raison, il est assez difficile de comprendre o√π se termine une dune et o√π commence une autre.  Pour augmenter la lisibilit√©, la technique de petite mise en √©vidence de ce qui n'est visible que le long du bord de la dune est utilis√©e.  Il s'agit de l' <strong>√©clairage de jante</strong> , et il existe de nombreuses fa√ßons de le mettre en ≈ìuvre.  Pour ce tutoriel, j'ai choisi une m√©thode bas√©e <strong>sur les</strong> r√©flexions de <strong>Fresnel</strong> qui mod√©lise les r√©flexions sur les surfaces polies √† des <em>angles</em> dits d' <em>incidence</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><h6>  Miroir reflet de l'oc√©an </h6><br>  L'un des aspects les plus agr√©ables <em>du</em> gameplay de <em>Journey</em> est la possibilit√© de ¬´surfer¬ª sur les dunes de sable.  C'est probablement pourquoi cette entreprise de jeux vid√©o voulait que le sable ressemble plus √† un liquide qu'√† un solide.  Pour cela, une forte r√©flexion a √©t√© utilis√©e, que l'on retrouve souvent dans les shaders √† eau.  John Edwards appelle cet effet l' <strong>oc√©an sp√©culaire</strong> , et dans le tutoriel, nous l'impl√©mentons en utilisant la <strong>r√©flexion de Blinn-Fong</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><h6>  Reflet √©blouissant </h6><br>  L'ajout d'un composant sp√©culaire oc√©anique au shader de sable lui donne un aspect plus fluide.  Cependant, il ne permet toujours pas de transmettre l'un des aspects visuels les plus importants du sable: les r√©flexions al√©atoires.  Dans les vraies dunes, cet effet se produit car chaque grain de sable r√©fl√©chit la lumi√®re dans sa direction et tr√®s souvent l'un de ces rayons r√©fl√©chis p√©n√®tre dans notre ≈ìil.  Une telle <strong>r√©flexion scintillante</strong> (r√©flexion des r√©flexions) se produit m√™me dans des endroits o√π la lumi√®re directe du soleil ne tombe pas;  il compl√®te l'oc√©an sp√©culaire et renforce le sentiment de cr√©dibilit√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><h6>  Vagues de sable </h6><br>  Changer les normales nous a permis de simuler l'effet de petits grains de sable recouvrant la surface de la dune.  Sur les dunes du monde r√©el, des vagues provoqu√©es par le vent apparaissent souvent.  Leur forme varie en fonction de la pente et de la position de chaque dune par rapport √† la direction du vent.  Potentiellement, de tels motifs peuvent √™tre cr√©√©s gr√¢ce √† une texture de relief, mais dans ce cas, il sera impossible de changer la forme des dunes en temps r√©el.  La solution propos√©e par John Edwards est similaire √† une technique appel√©e <strong>ombrage triplanaire</strong> : elle utilise quatre textures diff√©rentes, m√©lang√©es selon la position et la pente de chaque dune. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/828/9b4/997/8289b49971bbe0046845f71284790124.png"></div><br><h1>  Journey Sand Shader Anatomy </h1><br>  Unity propose de nombreux mod√®les de shaders pour vous aider √† d√©marrer.  Puisque nous sommes int√©ress√©s par les mat√©riaux pouvant recevoir de l'√©clairage et des ombres projet√©es, nous devons commencer par le <strong>shader de</strong> surface (shader de surface). <br><br>  Tous <strong>les shaders de surface</strong> sont r√©alis√©s en deux √©tapes.  Tout d'abord, <strong>une fonction de surface</strong> est appel√©e qui recueille les propri√©t√©s de la surface √† rendre, par exemple son <em>alb√©do</em> , sa <em>rugosit√©</em> , ses <em>propri√©t√©s m√©talliques</em> , sa <em>transparence</em> et sa <em>direction normale</em> .  Ensuite, toutes ces propri√©t√©s sont transf√©r√©es √† <strong>la fonction d'√©clairage</strong> , qui prend en compte l'influence des sources de lumi√®re externes et calcule l'ombrage et l'√©clairage. <br><br><h2>  Fonction de surface </h2><br>  Commen√ßons par ce qui devient le c≈ìur de notre fonction de surface, appel√© dans le code <code>surf</code> ci-dessous.  Les seules propri√©t√©s que nous devons d√©finir sont la <em>couleur du sable</em> et la <strong>normale √† la surface</strong> .  La normale d'un mod√®le 3D est un vecteur indiquant la position de la surface.  Les vecteurs normaux sont utilis√©s par la fonction d'√©clairage pour calculer la mani√®re dont la lumi√®re sera r√©fl√©chie.  Ils sont g√©n√©ralement calcul√©s lors de l'importation du maillage.  Cependant, ils peuvent √™tre modifi√©s pour simuler une g√©om√©trie plus complexe.  C'est ici que les effets <strong>sable normal</strong> et <strong>vagues de</strong> <strong>sable</strong> d√©forment la norme sable pour simuler sa rugosit√©. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); N = SandNormal (N); o.Normal = N; }</code> </pre> <br>  Lorsque vous √©crivez des normales √† <code>o.Normal</code> elles doivent √™tre exprim√©es dans un <strong>espace tangent</strong> .  Cela signifie que le vecteur est s√©lectionn√© par rapport √† la surface du mod√®le 3D.  Autrement dit, <code>float3(0, 0, 1)</code> signifie en fait qu'aucune modification n'est r√©ellement apport√©e au mod√®le 3D normal. <br><br>  Les deux fonctions, <code>RipplesNormal</code> et <code>SandNormal</code> re√ßoivent <code>SandNormal</code> le vecteur normal et le modifient.  Plus tard, nous verrons comment cela peut √™tre fait. <br><br><h2>  Fonction d'√©clairage </h2><br>  C'est dans la fonction d'√©clairage que tous les autres effets sont impl√©ment√©s.  Le code ci-dessous montre comment chaque composant individuel est calcul√© dans des fonctions distinctes (couleur diffuse, √©clairage du bord, r√©flexion sp√©culaire de l'oc√©an et paillettes).  Ensuite, ils sont tous combin√©s. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Journey fullforwardshadows float4 LightingJourney (SurfaceOutput s, fixed3 viewDir, UnityGI gi) { float3 diffuseColor = DiffuseColor (); float3 rimColor = RimLighting (); float3 oceanColor = OceanSpecular (); float3 glitterColor = GlitterSpecular (); float3 specularColor = saturate(max(rimColor, oceanColor)); float3 color = diffuseColor + specularColor + glitterColor; return float4(color * s.Albedo, 1); }</span></span></code> </pre> <br>  La m√©thode de combinaison des composants est assez arbitraire et nous permet de la changer pour √©tudier les possibilit√©s artistiques. <br><br>  En r√®gle g√©n√©rale, les r√©flexions sp√©culaires s‚Äôempilent sur les couleurs diffuses.  Puisqu'il n'y a pas ici une, mais trois r√©flexions sp√©culaires ( <em>lumi√®re du bord</em> , <em>sp√©culaire oc√©anique</em> et <em>sp√©culaire scintillant</em> ), nous devons √™tre plus prudents afin de ne pas faire scintiller le sable <em>trop</em> .  Puisque la lumi√®re de la jante et l'oc√©an sp√©culaire font partie du m√™me effet, nous ne pouvons en choisir que la valeur maximale.  Le sp√©culaire scintillant est ajout√© s√©par√©ment car ce composant cr√©e du sable vacillant. <br><br><h2>  Partie 2. Couleur diffuse </h2><br>  Dans la deuxi√®me partie de l'article, nous nous concentrerons sur le mod√®le d'√©clairage utilis√© dans le jeu et sur cela.  comment le recr√©er dans Unity. <br><br>  Dans la partie pr√©c√©dente, nous avons jet√© les bases de ce qui deviendra progressivement notre version du shader de sable Journey.  Comme mentionn√© pr√©c√©demment, <strong>la fonction d'√©clairage est</strong> utilis√©e dans <strong>les shaders de surface</strong> pour calculer l'effet de l'√©clairage, de sorte que les ombres et les reflets apparaissent sur la surface.  Nous avons d√©couvert que Journey a plusieurs effets qui entrent dans cette cat√©gorie.  Nous commencerons par l'effet le plus basique (et le plus simple) que l'on retrouve au coeur de ce shader: son <strong>√©clairage</strong> diffus ( <strong>√©clairage</strong> diffus / diffus). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78f/166/71c/78f16671c754f05e619ce034fad81926.png"></div><br>  Pour l'instant, nous omettons tous les autres effets et composants, en nous concentrant sur l' <strong>√©clairage du sable</strong> . <br><br>  La fonction d'√©clairage que nous avons <code>DiffuseColor</code> dans la partie pr√©c√©dente de l'article intitul√©e <code>LightingJourney</code> d√©l√®gue simplement le calcul de la couleur diffuse du sable √† une fonction appel√©e <code>DiffuseColor</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightingJourney</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SurfaceOutput s, fixed3 viewDir, UnityGI gi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Lighting properties float3 L = gi.light.dir; float3 N = s.Normal; // Lighting calculation float3 diffuseColor = DiffuseColor(N, L); // Final color return float4(diffuseColor, 1); }</span></span></code> </pre> <br>  Du fait que chaque effet est autonome et stock√© dans sa propre fonction, notre code sera plus modulaire et plus propre. <br><br><h2>  R√©flexion Lambert </h2><br>  Avant de cr√©er un √©clairage diffus "comme dans Journey", il est agr√©able de voir √† quoi ressemble la fonction d'√©clairage diffus "basique".  La technique d'ombrage la plus simple pour les mat√©riaux mats est appel√©e <strong>r√©flectance lambertienne</strong> .  Ce mod√®le se rapproche de l'apparence de la plupart des surfaces non brillantes et non m√©talliques.  Il doit son nom au scientifique encyclop√©dique suisse <strong>Johann Heinrich Lambert</strong> , qui a propos√© son concept en 1760. <br><br>  Le concept de r√©flexion de Lambert est bas√© sur une id√©e simple: la <em>luminosit√© d'une surface d√©pend de la quantit√© de lumi√®re qui y est incidente</em> .  G√©om√©triquement, cela peut √™tre illustr√© dans le diagramme ci-dessous, o√π la sph√®re est √©clair√©e par une source de lumi√®re √† distance.  Bien que les zones rouges et vertes de la sph√®re re√ßoivent la m√™me quantit√© d'√©clairage, leurs surfaces sont sensiblement diff√©rentes.  Si la lumi√®re dans la zone rouge est distribu√©e sur une plus grande zone, cela signifie que chaque unit√© du carr√© rouge re√ßoit moins de lumi√®re que le vert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/d48/495/2cfd484953877a47fe5ba564b399ea35.png"></div><br>  Th√©oriquement, la r√©flexion de Lambert d√©pend de l'angle relatif entre la <em>surface</em> et la <em>lumi√®re incidente</em> .  D'un point de vue math√©matique, nous disons qu'il s'agit d'une fonction de la <strong>normale √† la surface</strong> et √† la <strong>direction de l'illumination</strong> .  Ces quantit√©s sont exprim√©es √† l'aide de deux vecteurs de longueur unitaire (appel√©s <strong>vecteurs unitaires</strong> ) <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> N </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> L </script>  .  Les vecteurs simples sont un moyen standard de sp√©cifier des <em>directions</em> dans le contexte du codage des shaders. <br><br><div class="spoiler">  <b class="spoiler_title">La valeur de N et L</b> <div class="spoiler_text">  <strong>Normal</strong> √† la surface <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.074ex" viewBox="0 -772.3 888.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> N </script>  Est un vecteur unitaire dirig√© <em>loin de</em> la surface elle-m√™me. <br><br>  Par analogie, nous pouvons supposer que la <strong>direction de l'√©clairage</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.074ex" viewBox="0 -772.3 681.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> L </script>  pointe <em>de la</em> source de lumi√®re et suit la direction dans laquelle la lumi√®re se d√©place.  Mais ce n'est pas le cas: la direction de l'illumination est un vecteur unique pointant <em>dans la direction de la</em> direction d'o√π provient la lumi√®re. <br><br>  Cela peut √™tre d√©routant, surtout si vous √™tes nouveau dans la cr√©ation de shaders.  Cependant, gr√¢ce √† une telle notation, les √©quations deviennent plus faciles. </div></div><br><div class="spoiler">  <b class="spoiler_title">R√©flexion de Lambert dans l'unit√©</b> <div class="spoiler_text">  Avant Unity 5 <strong>Standard Shader</strong> , la r√©flexion Lambert √©tait le mod√®le standard pour ombrer les surfaces √©clair√©es. <br><br>  Vous pouvez toujours y acc√©der dans l'inspecteur des mat√©riaux: dans le <em>shader Legacy,</em> il est appel√© <em>Diffus</em> . <br><br>  Si vous √©crivez votre propre shader de surface, la r√©flexion Lambert est disponible en tant que fonction d'√©clairage appel√©e <code>Lambert</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Lambert fullforwardshadows</span></span></code> </pre> <br>  Son impl√©mentation se trouve dans la fonction <code>LightingLambert</code> d√©finie dans le fichier <code>CGIncludes\Lighting.cginc</code> . </div></div><br><div class="spoiler">  <b class="spoiler_title">R√©flexion de Lambert et climat</b> <div class="spoiler_text">  La r√©flexion de Lambert est un mod√®le assez ancien, mais elle permet de comprendre des concepts complexes tels que l'ombrage de surface.  Il peut √©galement √™tre utilis√© pour expliquer de nombreux autres ph√©nom√®nes.  Par exemple, le m√™me diagramme explique pourquoi il fait plus froid aux p√¥les de la plan√®te qu'√† l'√©quateur. </div></div><br>  Apr√®s avoir regard√© de plus pr√®s, nous pouvons voir que la surface re√ßoit le maximum d'√©clairement lorsque sa normale est parall√®le √† la direction de l'√©clairage.  Et vice versa: il n'y a pas de lumi√®re si deux vecteurs unitaires sont perpendiculaires l'un √† l'autre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e1/d06/6c6/0e1d066c6ff998abda8ca5c7607e4c4e.png"></div><br>  De toute √©vidence, l'angle entre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> N </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> L </script>  critique pour la r√©flexion selon Lambert.  De plus, la luminosit√© est maximale et √©gale √† <math></math><img src="https://habrastorage.org/getpro/habr/formulas/35b/e60/e68/35be60e68c535df673e0aef590e20870.svg" alt="100 $ \% $" data-tex="inline">  quand l'angle est <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMAIN-30" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> 0 </script>  et minimal ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-15"><span class="MJXp-mn" id="MJXp-Span-16">0</span><span class="MJXp-mi" id="MJXp-Span-17">%</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.098ex" height="2.298ex" viewBox="0 -832 1334 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMAIN-30" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMAIN-25" x="500" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> 0 \% </script>  ) lorsque l'angle tend √† <math></math><img src="https://habrastorage.org/getpro/habr/formulas/1f7/311/bbe/1f7311bbeecd1aa665d6babf72501a8c.svg" alt="90 $ ^ {\ circ} $" data-tex="inline">  .  Si vous connaissez l' <em>alg√®bre vectorielle</em> , vous pourriez comprendre qu'une quantit√© repr√©sentant la r√©flexion de Lambert <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-18"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">I</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.172ex" height="2.057ex" viewBox="0 -780.1 504.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-49" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9"> I </script>  est √©gal √† <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-20"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">N</span><span class="MJXp-mtext" id="MJXp-Span-22">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.417ex" height="2.057ex" viewBox="0 -780.1 3624 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-63" x="1138" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-64" x="1572" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-6F" x="2095" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-74" x="2581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-4C" x="2942" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-10"> N \ cdot L </script>  o√π est l'op√©rateur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-28"><span class="MJXp-mtext" id="MJXp-Span-29">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.771ex" height="2.057ex" viewBox="0 -780.1 2054 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-63" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-64" x="683" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-6F" x="1207" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjbwhrS4U3Y76OxlLWmFYli2J9NMw#MJMATHI-74" x="1692" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-11"> \ cdot </script>  appel√© <strong>produit scalaire</strong> . <br><br>  (1) <p><math> </math> $$ afficher $$ \ commencer {√©quation *} I = N \ cdot L \ terminer {√©quation *} $$ afficher $$ </p><br>  Le produit scalaire est une mesure de la ¬´co√Øncidence¬ª de deux vecteurs l'un par rapport √† l'autre et varie dans l'intervalle de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="MJXp-mo" id="MJXp-Span-41" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-42">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> + 1 </script>  (pour deux vecteurs identiques) √† <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-43"><span class="MJXp-mo" id="MJXp-Span-44" style="margin-left: 0em; margin-right: 0.111em;">‚àí</span><span class="MJXp-mn" id="MJXp-Span-45">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> -1 </script>  (pour deux vecteurs oppos√©s).  Un produit scalaire est le fondement de l'ombrage, que j'ai examin√© en d√©tail dans le didacticiel sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®les de rendu et d'√©clairage physiquement bas√©s</a> . <br><br><h3>  Impl√©mentation </h3><br>  Et pour <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-46"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> N </script>  et √† <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> L </script>  Vous pouvez facilement acc√©der aux fonctions d'√©clairage du shader de surface via <code>s.Normal</code> et <code>gi.light.dirin</code> .  Pour simplifier, nous les renommerons dans le code du shader en <code>N</code> et <code>L</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate( dot(N, L) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  <code>saturate</code> fonction <code>saturate</code> limite la valeur de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-50"><span class="MJXp-mn" id="MJXp-Span-51">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> 0 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-52"><span class="MJXp-mn" id="MJXp-Span-53">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> 1 </script>  .  Cependant, comme le produit scalaire se situe dans la plage de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-54"><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0em; margin-right: 0.111em;">‚àí</span><span class="MJXp-mn" id="MJXp-Span-56">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> -1 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-57"><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-59">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> + 1 </script>  , nous devrons travailler uniquement avec ses valeurs n√©gatives.  C'est pourquoi la r√©flexion Lambert est souvent mise en ≈ìuvre comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, L) );</code> </pre> <br><h2>  R√©flexion de contraste de la lumi√®re ambiante </h2><br>  Bien que la r√©flexion de Lambert nuise bien √† la plupart des mat√©riaux, elle n'est ni physiquement pr√©cise ni photor√©aliste.  Dans les jeux plus anciens, les shaders Lambert √©taient largement utilis√©s.  Les jeux qui utilisent cette technique <em>semblent</em> souvent vieux car ils peuvent reproduire par inadvertance l'esth√©tique des vieux jeux.  Si vous ne vous efforcez pas pour cela, alors la r√©flexion Lambert devrait √™tre √©vit√©e et utiliser une technologie plus moderne. <br><br>  Un tel mod√®le est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">le mod√®le de r√©flexion Oren-Nayyar</a> , qui a √©t√© initialement d√©crit dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">G√©n√©ralisation du</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">mod√®le de r√©flexion</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">de Lambert</a> , publi√© en 1994 par Michael Oren et Sri C. Nayyar.  Le mod√®le Oren-Nayyar est une g√©n√©ralisation de la r√©flexion Lambert et est sp√©cialement con√ßu pour les surfaces rugueuses.  Initialement, les d√©veloppeurs de Journey voulaient utiliser la r√©flexion Oren-Nayyar comme base pour leur shader de sable.  Cependant, cette id√©e a √©t√© abandonn√©e en raison des co√ªts de calcul √©lev√©s. <br><br>  Dans son rapport de 2013, l'artiste technique John Edwards explique que le mod√®le de r√©flexion cr√©√© pour le sable Journey √©tait bas√© sur une s√©rie d'essais et d'erreurs.Les d√©veloppeurs n'avaient pas l'intention de recr√©er le rendu photor√©aliste du d√©sert, mais de donner vie √† une esth√©tique concr√®te imm√©diatement reconnaissable. <br><br>  Selon lui, le mod√®le d'ombrage r√©sultant correspond √† cette √©quation: <br><br>  (2) <p><math> </math> $$ afficher $$ \ commencer {√©quation *} I = 4 * \ gauche (\ gauche (N \ odot \ gauche [1, 0,3, 1 \ droite] \ droite) \ cdot L \ droite) \ end {√©quation *} $$ afficher $$ </p><br>  o√π <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mtext" id="MJXp-Span-84">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> \ odot </script>  - produit <strong>√©l√©ment par √©l√©ment de</strong> deux vecteurs. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  Mod√®le de r√©flexion (2) John Edwards appelle le <strong>contraste diffus</strong> , nous allons donc utiliser ce nom tout au long du didacticiel. <br><br>  L'animation ci-dessous montre la diff√©rence d'ombrage Lambert (√† gauche) et le contraste diffus de Journey (√† droite). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q-hQiDA71Yg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">Quelle est la signification de 4 et 0,3?</b> <div class="spoiler_text">  Bien que le contraste diffus n'ait pas √©t√© con√ßu pour √™tre physiquement pr√©cis, nous pouvons toujours essayer de comprendre ce qu'il fait. <br><br>  √Ä la base, il utilise toujours la r√©flexion Lambert.  La premi√®re diff√©rence √©vidente est que le r√©sultat global est multipli√© par <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-89"><span class="MJXp-mn" id="MJXp-Span-90"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><script type="math/tex" id="MathJax-Element-23"> 4 </script>  .  Cela signifie que tous les pixels normalement re√ßus <math></math><img src="https://habrastorage.org/getpro/habr/formulas/5fc/5d7/0b6/5fc5d70b6ec460d4ee10de0435b3ed01.svg" alt="25 $ \% $" data-tex="inline">  l'√©clairage brillera maintenant comme s'il recevait <math></math><img src="https://habrastorage.org/getpro/habr/formulas/35b/e60/e68/35be60e68c535df673e0aef590e20870.svg" alt="100 $ \% $" data-tex="inline">  l'√©clairage.  En multipliant tout par <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-91"><span class="MJXp-mn" id="MJXp-Span-92"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><script type="math/tex" id="MathJax-Element-24"> 4 </script>  l'ombrage faible selon Lambert devient beaucoup plus fort, et la r√©gion de transition entre l'obscurit√© et la lumi√®re est plus petite.  Dans ce cas, l'ombre devient plus nette. <br><br>  Effet de la multiplication de la composante <code>y</code> sur la direction normale <math></math><img src="https://habrastorage.org/getpro/habr/formulas/34c/99c/5d3/34c99c5d3317cdd989bf0d0d03e51b22.svg" alt="0,3 $" data-tex="inline">  expliquer est beaucoup plus difficile.  √Ä mesure que les composants du vecteur changent, la direction g√©n√©rale dans laquelle il pointe change.  R√©duire la valeur de la composante <code>y</code> √† tout <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="MJXp-mn" id="MJXp-Span-94"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30 </font></font></span><span class="MJXp-mi" id="MJXp-Span-95"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></span></span></span><script type="math/tex" id="MathJax-Element-25"> 30 \% </script>  √† partir de sa valeur d'origine, la r√©flexion du contraste diffus fait que les ombres deviennent plus verticales. <br><br>  Remarque: un produit scalaire mesure directement l'angle entre deux vecteurs uniquement s'ils ont tous deux une longueur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mn" id="MJXp-Span-97"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-26"> 1 </script>  .  Le changement effectu√© r√©duit la longueur normale <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-98"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><script type="math/tex" id="MathJax-Element-27"> N </script>  qui n'est plus un vecteur unitaire. </div></div><br><h2>  Des nuances de gris √† la couleur </h2><br>  Toutes les animations pr√©sent√©es ci-dessus ont des nuances de gris, car elles montrent les valeurs de leur mod√®le de r√©flexion, variant dans l'intervalle de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-100"><span class="MJXp-mn" id="MJXp-Span-101">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> 0 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-102"><span class="MJXp-mn" id="MJXp-Span-103">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> 1 </script>  ". Nous pouvons facilement ajouter des couleurs en utilisant <code>NdotL</code> comme coefficient d'interpolation entre deux couleurs: une pour le sable enti√®rement ombrag√© et l'autre pour le sable enti√®rement √©clair√©. <br><br><pre> <code class="cpp hljs">float3 _TerrainColor; float3 _ShadowColor; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); float3 color = lerp(_ShadowColor, _TerrainColor, NdotL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; }</code> </pre> <br><h2>  Partie 3. Sable normal </h2><br>  Dans la troisi√®me partie, nous nous concentrerons sur la cr√©ation de cartes normales qui transforment des mod√®les 3D lisses en dunes de sable. <br><br>  Dans la partie pr√©c√©dente du tutoriel, nous avons impl√©ment√© l'√©clairage diffus du sable Journey.  En utilisant uniquement cet effet, les dunes du d√©sert sembleront plut√¥t plates et ennuyeuses. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cb/dd6/9a8/8cbdd69a8a92614469132400c0979c79.png"></div><br>  L'un des effets les plus intrigants de Journey est la granularit√© du sable.  En regardant n'importe quelle capture d'√©cran, il nous semble que les dunes ne sont pas lisses et homog√®nes, mais cr√©√©es √† partir de millions de grains de sable microscopiques. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e93/307/efc/e93307efce359d4830f5894dde30c9e6.jpg"></div><br>  Cet effet peut √™tre obtenu en utilisant une technique appel√©e <strong>bump mapping</strong> , qui permet √† la lumi√®re de rebondir sur une surface plane comme si elle √©tait plus complexe.  Voyez comment cet effet change l'apparence du rendu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br>  De petites diff√©rences peuvent √™tre observ√©es avec l'augmentation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3d5/b3f/ea73d5b3fb56c941c9b61f022dcb8699.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f8/efa/5c4/2f8efa5c4926a0de947b8ff91e114498.png"></div><br><h2>  Nous traitons des cartes normales </h2><br>  Le sable se compose d'innombrables grains de sable, chacun ayant sa propre forme et composition (voir ci-dessous).  Chaque particule individuelle r√©fl√©chit l'√©clairage dans une direction potentiellement al√©atoire.  Une fa√ßon de r√©aliser cet effet est de cr√©er un mod√®le 3D contenant tous ces grains de sable microscopiques.  Mais en raison du nombre incroyable de polygones requis, cette approche n'est pas r√©alisable. <br><br>  Mais il existe une autre solution souvent utilis√©e pour simuler une g√©om√©trie plus complexe par rapport √† un vrai mod√®le 3D.  Chaque sommet ou face du mod√®le 3D est associ√© √† un param√®tre appel√© sa <strong>direction normale</strong> .  Il s'agit d'un vecteur de longueur unitaire utilis√© pour calculer la r√©flexion de la lumi√®re sur la surface d'un mod√®le 3D.  Autrement dit, pour simuler du sable, vous devez simuler cette distribution apparemment al√©atoire de grains de sable, et donc comment ils affectent les normales de surface. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/bc4/cc3/413bc4cc3466b827a1a1d86559d54054.jpg"></div><br>  Cela peut se faire de nombreuses fa√ßons.  Le plus simple est de cr√©er une texture qui change la direction des normales d'origine du mod√®le de dune. <br><br>  <strong>Normal √† la surface</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-104"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-30"> N </script>  dans le cas g√©n√©ral, il est calcul√© par la g√©om√©trie du mod√®le 3D.  Cependant, vous pouvez le modifier en utilisant la <strong>carte normale</strong> .  Les cartes normales sont des textures qui vous permettent de simuler une g√©om√©trie plus complexe en modifiant l'orientation locale des normales √† la surface.  Cette technique est souvent appel√©e <strong>bump mapping</strong> . <br><br>  Changer les normales est une t√¢che assez simple qui peut √™tre effectu√©e dans la fonction <code>surf</code> du <strong>shader de surface</strong> .  Cette fonction prend deux param√®tres, dont l'un est une <code>struct</code> appel√©e <code>SurfaceOutput</code> .  Il contient toutes les propri√©t√©s n√©cessaires au rendu d'une partie d'un mod√®le 3D, de sa couleur ( <code>o.Albedo</code> ) √† sa transparence ( <code>o.Alpha</code> ).  Un autre param√®tre qu'il contient est la direction normale ( <code>o.Normal</code> ), qui peut √™tre r√©√©crite pour changer la fa√ßon dont la lumi√®re est r√©fl√©chie sur le mod√®le. <br><br>  Selon la documentation Unity sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer">Shaders de surface</a> , toutes les normales √©crites dans la structure <code>o.Normal</code> doivent √™tre exprim√©es dans l' <strong>espace tangent</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SurfaceOutput</span></span></span><span class="hljs-class"> {</span></span> fixed3 Albedo; <span class="hljs-comment"><span class="hljs-comment">// diffuse color fixed3 Normal; // tangent space normal, if written fixed3 Emission; half Specular; // specular power in 0..1 range fixed Gloss; // specular intensity fixed Alpha; // alpha for transparencies };</span></span></code> </pre> <br>  Ainsi, nous pouvons signaler que les vecteurs unitaires doivent √™tre exprim√©s dans le syst√®me de coordonn√©es par rapport √† la normale du maillage.  Par exemple, lors de l'√©criture dans <code>o.Normal</code> valeurs de <code>float3(0, 0, 1)</code> normal resteront inchang√©es. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  En effet, le vecteur <code>float3(0, 0, 1)</code> est en fait un vecteur normal exprim√© par rapport √† la g√©om√©trie du mod√®le 3D. <br><br>  Donc, pour changer la normale √† la surface dans le <strong>shader de surface</strong> , il suffit d'√©crire un nouveau vecteur dans <strong>la fonction de surface</strong> en <code>o.Normal</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = ... <span class="hljs-comment"><span class="hljs-comment">// change the normal here }</span></span></code> </pre> <br>  Dans le reste de l'article, nous allons cr√©er l'approximation initiale, que nous compliquerons dans la sixi√®me partie du tutoriel. <br><br><h2>  Sable normal </h2><br>  La partie la plus probl√©matique consiste √† comprendre <em>comment les</em> grains de sable changent normalement √† la surface.  Bien qu'individuellement chaque grain de sable puisse diffuser la lumi√®re dans n'importe quelle direction, dans l'ensemble, quelque chose d'autre se produit.  Toute approche physiquement pr√©cise doit √©tudier la distribution des vecteurs normaux sur la surface du sable et la mod√©liser math√©matiquement.  De tels mod√®les existent vraiment, mais la solution pr√©sent√©e dans notre tutoriel est beaucoup plus simple, et en m√™me temps tr√®s efficace. <br><br>  √Ä chaque point du mod√®le, un <strong>vecteur unitaire al√©atoire est</strong> √©chantillonn√© √† partir de la texture.  Ensuite, la normale √† la surface s'incline d'une certaine quantit√© vers ce vecteur.  Avec la cr√©ation correcte d'une texture al√©atoire et la s√©lection d'une quantit√© appropri√©e de m√©lange, nous pouvons d√©placer la normale √† la surface de mani√®re √† cr√©er un sentiment de granulation, sans perdre la courbure globale des dunes. <br><br>  Les valeurs al√©atoires peuvent √™tre √©chantillonn√©es en utilisant une texture remplie de couleurs al√©atoires.  Les composantes R, G et B de chaque pixel sont utilis√©es comme composantes X, Y et Z du vecteur normal.  Les composants de couleur sont dans la gamme <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-106"><span class="MJXp-mtext" id="MJXp-Span-107">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-111">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-112">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-113">e</span><span class="MJXp-mo" id="MJXp-Span-114" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mn" id="MJXp-Span-115">0</span><span class="MJXp-mo" id="MJXp-Span-116" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-117">1</span><span class="MJXp-mtext" id="MJXp-Span-118">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-120">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124">e</span><span class="MJXp-mo" id="MJXp-Span-125" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-31"> \ gauche [0, 1 \ droite] </script>  , ils doivent donc √™tre convertis en un intervalle <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-126"><span class="MJXp-mtext" id="MJXp-Span-127">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-133">e</span><span class="MJXp-mo" id="MJXp-Span-134" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mo" id="MJXp-Span-135" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mn" id="MJXp-Span-136">1</span><span class="MJXp-mo" id="MJXp-Span-137" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-138" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-139">1</span><span class="MJXp-mtext" id="MJXp-Span-140">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-141">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-143">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-144">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146">e</span><span class="MJXp-mo" id="MJXp-Span-147" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-32"> \ gauche [-1, + 1 \ droite] </script>  .  Ensuite, le vecteur r√©sultant est normalis√© de sorte que sa longueur soit √©gale √† <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-148"><span class="MJXp-mn" id="MJXp-Span-149">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> 1 </script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d2/c95/03d/0d2c9503d98fd2463e7e3682743736bd.png"></div><br><div class="spoiler">  <b class="spoiler_title">Cr√©ez des textures al√©atoires</b> <div class="spoiler_text">  Il existe de nombreuses fa√ßons de g√©n√©rer des textures al√©atoires.  Pour obtenir l'effet souhait√©, le plus important est la distribution g√©n√©rale des vecteurs al√©atoires qui peuvent √™tre √©chantillonn√©s √† partir de la texture. <br><br>  Dans l'image ci-dessus, chaque pixel est compl√®tement al√©atoire.  Il n'y a pas de direction g√©n√©rale (couleur) qui pr√©vaut dans la texture, car chaque valeur a la m√™me probabilit√© que toutes les autres.  Cette texture nous donne un type de sable qui disperse la lumi√®re dans toutes les directions. <br><br>  Lors d'une conf√©rence GDC, John Edwards a clairement indiqu√© que la texture al√©atoire utilis√©e pour le sable dans Journey √©tait g√©n√©r√©e √† partir d'une distribution gaussienne.  Cela garantit que la direction dominante co√Øncide avec la normale √† la surface. </div></div><br><div class="spoiler">  <b class="spoiler_title">Les vecteurs al√©atoires doivent-ils √™tre normalis√©s?</b> <div class="spoiler_text">  L'image que j'ai utilis√©e pour √©chantillonner des vecteurs al√©atoires a √©t√© g√©n√©r√©e √† l'aide d'un processus compl√®tement al√©atoire.  Non seulement chaque pixel est g√©n√©r√© individuellement: les composants R, G et B d'un pixel sont √©galement ind√©pendants les uns des autres.  Autrement dit, dans le cas g√©n√©ral, les vecteurs √©chantillonn√©s √† partir de cette texture ne seront pas garantis d'avoir une longueur √©gale √† <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-150"><span class="MJXp-mn" id="MJXp-Span-151"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-34"> 1 </script>  . <br><br>  Bien s√ªr, vous pouvez g√©n√©rer une texture dans laquelle chaque pixel lors de la conversion de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-152"><span class="MJXp-mtext" id="MJXp-Span-153">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-154"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-155"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-156"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-157"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-158"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-159"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mo" id="MJXp-Span-160" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mn" id="MJXp-Span-161"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-162" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-163"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-165"><font style="vertical-align: inherit;">d </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-166"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-167"><font style="vertical-align: inherit;">o </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-169"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170"><font style="vertical-align: inherit;">e </font></span><span class="MJXp-mo" id="MJXp-Span-171" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;">]</font></span></font><span class="MJXp-mtext" id="MJXp-Span-164">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-165"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-166"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-167"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-169"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-171" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"></font></span></span></span><script type="math/tex" id="MathJax-Element-35"> \ gauche [0, 1 \ droite] </script>  dans <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-172"><span class="MJXp-mtext" id="MJXp-Span-173">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-174"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-175"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-176"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-178"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mo" id="MJXp-Span-180" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mo" id="MJXp-Span-181" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-182"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-183" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mo" id="MJXp-Span-184" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-185"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187"><font style="vertical-align: inherit;">d </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-188"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189"><font style="vertical-align: inherit;">o </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-190"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-192"><font style="vertical-align: inherit;">e </font></span><span class="MJXp-mo" id="MJXp-Span-193" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;">]</font></span></font><span class="MJXp-mtext" id="MJXp-Span-186">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-188"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-190"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-192"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-193" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"></font></span></span></span><script type="math/tex" id="MathJax-Element-36"> \ gauche [-1, + 1 \ droite] </script>  et devra en fait avoir une longueur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-194"><span class="MJXp-mn" id="MJXp-Span-195"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-37"> 1 </script>  .  Cependant, deux probl√®mes se posent ici. <br><br> ,             . -,    <em> </em>   mip-,             . <br><br>   ,    . </div></div><br><h2>  Impl√©mentation </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la partie pr√©c√©dente du didacticiel, nous nous sommes familiaris√©s avec le concept de ¬´cartes normales¬ª lorsqu'il est apparu dans le tout premier contour de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la fonction de surface</font></font></strong> <code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En rappelant le diagramme pr√©sent√© au d√©but de l'article, vous pouvez voir que deux effets sont n√©cessaires pour recr√©er le rendu du sable Journey. La premi√®re ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normales de sable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) que nous consid√©rons dans cette partie de l'article, et la seconde ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vagues de sable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) que nous √©tudierons dans la sixi√®me partie.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); <span class="hljs-comment"><span class="hljs-comment">// Covered in Journey Sand Shader #6 N = SandNormal (N); // Covered in this article o.Normal = N; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la section pr√©c√©dente, nous avons introduit le concept de bump mapping, qui nous a montr√© qu'une partie de l'effet n√©cessiterait un √©chantillonnage de la texture (c'est ce qu'on appelle dans le code </font></font><code>uv_SandTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le probl√®me avec le code ci-dessus est que pour les calculs, vous devez conna√Ætre la position r√©elle du point que nous dessinons. En fait, vous avez besoin d'une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coordonn√©e UV</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour √©chantillonner la texture </font><font style="vertical-align: inherit;">, qui d√©termine √† partir de quel pixel lire. Si le mod√®le 3D que nous utilisons est relativement plat et a une conversion UV, alors nous pouvons utiliser son UV pour √©chantillonner une texture al√©atoire.</font></font><br><br><pre> <code class="cpp hljs">N = WavesNormal(IN.uv_SandTex.xy, N); N = SandNormal (IN.uv_SandTex.xy, N);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou vous pouvez √©galement utiliser la position dans le monde ( </font></font><code>IN.worldPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) du point rendu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons enfin nous concentrer sur </font></font><code>SandNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sa mise en ≈ìuvre. </font><font style="vertical-align: inherit;">Comme indiqu√© pr√©c√©demment dans cette partie, l'id√©e est d'√©chantillonner un pixel √† partir d'une texture al√©atoire et de l'utiliser (apr√®s la conversion en un vecteur unitaire) comme nouvelle normale.</font></font><br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment zoomer une texture al√©atoire?</font></font></b> <div class="spoiler_text">    UV- 3D-      ,   .      ,       . <br><br>   ,  Unity   .   ,        <code>_SandText_ST</code> . Unity       (  ) <code>_SandTex</code> . <br><br>  <code>_SandText_ST</code>    :     .        ,          <em>Tiling</em>  <em>Offset</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/a84/059/f29a84059ab970f412217f09c87fcf6f.png"></div><br>       ,     <code>TRANSFORM_TEX</code> : <br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; float4 _SandTex_ST; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, TRANSFORM_TEX(uv, _SandTex)).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inclinez les normales </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'extrait de code illustr√© ci-dessus fonctionne, mais ne produit pas de tr√®s bons r√©sultats. La raison en est simple: si nous retournons simplement une normale compl√®tement al√©atoire, mais perdons essentiellement la sensation de courbure. En fait, la direction de la normale est utilis√©e pour calculer comment la lumi√®re doit √™tre r√©fl√©chie par la surface, et son objectif principal est d'ombrer le mod√®le en fonction de sa courbure. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La diff√©rence peut √™tre vue dans les images ci-dessous. Ci-dessus, les normales des dunes sont compl√®tement al√©atoires, et il est impossible de comprendre o√π l'une finit et o√π commence une autre. En dessous, seule la normale du mod√®le est utilis√©e, ce qui nous donne une surface trop lisse.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/9cb/acb/6209cbacb616db15bee5f95e314779c8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/476/f0a/f25/476f0af2535dc2d552ce4b01a1d7751a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les deux solutions ne nous conviennent pas. </font><font style="vertical-align: inherit;">Nous avons besoin de quelque chose entre les deux. </font><font style="vertical-align: inherit;">Une direction al√©atoire √©chantillonn√©e √† partir d'une texture doit √™tre utilis√©e pour </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incliner la</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> normale d'une certaine quantit√©, comme indiqu√© ci-dessous:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/929/dfb/7e6/929dfb7e6d4712b7c69a403d0733c25b.png" width="239" height="240"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'op√©ration d√©crite dans le diagramme est appel√©e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slerp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui signifie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpolation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lin√©aire sph√©rique (interpolation lin√©aire sph√©rique). </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slerp</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonctionne exactement comme lerp, √† une exception pr√®s - il peut √™tre utilis√© pour interpoler en toute s√©curit√© entre des vecteurs unitaires, et le r√©sultat de l'op√©ration sera d'autres vecteurs unitaires. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, l'impl√©mentation correcte de slerp est assez ch√®re. </font><font style="vertical-align: inherit;">Et pour un effet, du moins bas√© sur le hasard, il est illogique de l'utiliser.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montrez-moi l'√©quation slerp</font></font></b> <div class="spoiler_text">    , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-196"><span class="MJXp-msubsup" id="MJXp-Span-197"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-199" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-38">p_0</script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-200"><span class="MJXp-msubsup" id="MJXp-Span-201"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-202" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-203" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-39">p_1</script>   ,       .  Alors <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-204"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-205">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-206">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-207">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-208">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-209">p</span></span></span><script type="math/tex" id="MathJax-Element-40">slerp</script>    : <br><br>  (1) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-210"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-211">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-212">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-213">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-214">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-215">p</span><span class="MJXp-mrow" id="MJXp-Span-216"><span class="MJXp-mo" id="MJXp-Span-217" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-218"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-219" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-220" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-221" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-222"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-223" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-224" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-225" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-226">t</span><span class="MJXp-mo" id="MJXp-Span-227" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span><span class="MJXp-mo" id="MJXp-Span-228" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mfrac" id="MJXp-Span-229" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-230">sin</span><span class="MJXp-mo" id="MJXp-Span-231" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-232"><span class="MJXp-mo" id="MJXp-Span-233" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-234"><span class="MJXp-mo" id="MJXp-Span-235" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-236">1</span><span class="MJXp-mo" id="MJXp-Span-237" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-238">t</span><span class="MJXp-mo" id="MJXp-Span-239" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mi" id="MJXp-Span-240">Œ©</span><span class="MJXp-mo" id="MJXp-Span-241" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-242">sin</span><span class="MJXp-mo" id="MJXp-Span-243" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-244"><span class="MJXp-mo" id="MJXp-Span-245" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-246">Œ©</span><span class="MJXp-mo" id="MJXp-Span-247" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-248"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-249" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-250" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-251" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mfrac" id="MJXp-Span-252" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-253">sin</span><span class="MJXp-mo" id="MJXp-Span-254" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-255"><span class="MJXp-mo" id="MJXp-Span-256" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-257">t</span><span class="MJXp-mi" id="MJXp-Span-258">Œ©</span><span class="MJXp-mo" id="MJXp-Span-259" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-260">sin</span><span class="MJXp-mo" id="MJXp-Span-261" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-262"><span class="MJXp-mo" id="MJXp-Span-263" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-264">Œ©</span><span class="MJXp-mo" id="MJXp-Span-265" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-266"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-267" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-268" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-41">\begin{equation*} slerp\left(p_0, p_1, t\right) = \frac{\sin\left[\left(1-t\right)\Omega\right]}{\sin\left(\Omega\right)}p_0 + \frac{\sin\left(t\Omega\right)}{\sin\left(\Omega\right)} p_1 \end{equation*}</script> </math></p><br>  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-269"><span class="MJXp-mi" id="MJXp-Span-270">Œ©</span></span></span><script type="math/tex" id="MathJax-Element-42">\Omega</script> ‚Äî     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-271"><span class="MJXp-msubsup" id="MJXp-Span-272"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-273" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-274" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-43">p_0</script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-275"><span class="MJXp-msubsup" id="MJXp-Span-276"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-277" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-278" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-44">p_1</script> ,       : <br><br> (2) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-279"><span class="MJXp-mi" id="MJXp-Span-280">Œ©</span><span class="MJXp-mo" id="MJXp-Span-281" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-282">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-283">o</span><span class="MJXp-msubsup" id="MJXp-Span-284"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-285" style="margin-right: 0.05em;">s</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-286" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-287">‚àí</span><span class="MJXp-mn" id="MJXp-Span-288">1</span></span></span><span class="MJXp-mrow" id="MJXp-Span-289"><span class="MJXp-mo" id="MJXp-Span-290" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-291"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-292" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-293" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-294" style="margin-left: 0.267em; margin-right: 0.267em;">‚ãÖ</span><span class="MJXp-msubsup" id="MJXp-Span-295"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-296" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-297" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-298" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-45">\begin{equation*} \Omega=cos^{-1} \left(p_0 \cdot p_1 \right) \end{equation*}</script> </math></p><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est important de noter que si nous utilisons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'interpolation lin√©aire</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> traditionnelle </font><font style="vertical-align: inherit;">, le vecteur r√©sultant sera tr√®s diff√©rent:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/5e1/42f/eef5e142f1c8c05cac9b3d4f18d8e097.png" width="239" height="240"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'op√©ration Lerp entre deux vecteurs unitaires s√©par√©s ne cr√©e pas toujours d'autres vecteurs unitaires. </font><font style="vertical-align: inherit;">En fait, cela ne se produit jamais, sauf si le coefficient est</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-299"><span class="MJXp-mn" id="MJXp-Span-300"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-46-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-46">1</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-301"><span class="MJXp-mn" id="MJXp-Span-302"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-47-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-47">0</script>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Malgr√© cela, la normalisation du r√©sultat lerp aboutit en fait √† un vecteur unit√© qui est √©tonnamment proche du r√©sultat g√©n√©r√© par slerp: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nlerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 n1, float3 n2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> normalize(lerp(n1, n2, t)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette technique, appel√©e </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nlerp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , fournit une approximation √©troite de slerp. </font><font style="vertical-align: inherit;">Son utilisation a √©t√© popularis√©e par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casey Muratori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , l'un des d√©veloppeurs de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Witness</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si vous souhaitez en savoir plus sur ce sujet, je vous recommande de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comprendre les articles Slerp. </font><font style="vertical-align: inherit;">Then Not Use It de </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonathan Blow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Math Magician - Lerp, Slerp et Nlerp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√¢ce √† nlerp, nous pouvons d√©sormais incliner efficacement les vecteurs normaux d'un c√¥t√© al√©atoire, √©chantillonn√©s √† partir de </font></font><code>_SandTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _SandStrength; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); // Rotates N towards Ns based on _SandStrength float3 Ns = nlerp(N, S, _SandStrength); return Ns; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le r√©sultat est pr√©sent√© ci-dessous: </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rddUAStRjZ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Et ensuite </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans la prochaine partie, nous consid√©rerons les reflets vacillants, gr√¢ce auxquels les dunes ressembleront √† l'oc√©an. </font></font><br><br><h3>  Remerciements </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le jeu vid√©o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Journey a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©t√© </font><font style="vertical-align: inherit;">d√©velopp√© par </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thatgamecompany</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et publi√© par </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sony Computer Entertainment</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il est disponible pour PC ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Epic Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et PS4 ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des mod√®les 3D d'arri√®re-plans de dunes et d'options d'√©clairage sont cr√©√©s par </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jiadi Deng</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un mod√®le 3D du personnage de Journey a √©t√© trouv√© sur le forum FacePunch (maintenant ferm√©).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Forfait Unity </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous souhaitez recr√©er cet effet, le package Unity complet peut √™tre t√©l√©charg√© depuis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il comprend tout ce dont vous avez besoin, des shaders aux mod√®les 3D.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476448/">https://habr.com/ru/post/fr476448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476434/index.html">Nous √©crivons des pilotes USB pour les appareils abandonn√©s</a></li>
<li><a href="../fr476436/index.html">Rapports de la premi√®re r√©union en Russie des d√©veloppeurs de robots sur Robot Operating System</a></li>
<li><a href="../fr476442/index.html">Donnez de l'espace ou un microcontr√¥leur comme un fr√©quencem√®tre</a></li>
<li><a href="../fr476444/index.html">D√©mystification des principes de l'informatique quantique</a></li>
<li><a href="../fr476446/index.html">Plugins Jira: quelques exemples de l'invention r√©ussie du v√©lo</a></li>
<li><a href="../fr476450/index.html">Pr√©sentation de cPanel - une console Web pour la gestion des sites et l'h√©bergement</a></li>
<li><a href="../fr476452/index.html">Stockage de valeur-cl√© ou comment nos applications sont devenues plus pratiques</a></li>
<li><a href="../fr476454/index.html">La 5G arrive: quelles entreprises assureront l'introduction de nouvelles technologies en 2020</a></li>
<li><a href="../fr476456/index.html">Le syst√®me chinois de cr√©dit social n'est tout d'abord pas un syst√®me d'√©valuation des citoyens, mais une API massive</a></li>
<li><a href="../fr476460/index.html">Le premier format de fichier √† succ√®s sur Internet n'√©tait pas MP3, mais MIDI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>