<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚ÄçüöÄ üïµÔ∏è üï∫üèΩ Bases du moteur JavaScript: formulaires g√©n√©raux et mise en cache en ligne. Partie 1 üë©üèΩ‚Äç‚úàÔ∏è üë®üèΩ‚Äçüé® üßúüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour mes amis. Fin avril, nous lan√ßons un nouveau cours ¬´S√©curit√© des Syst√®mes d'Information¬ª . Et maintenant, nous voulons partager avec vous une ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bases du moteur JavaScript: formulaires g√©n√©raux et mise en cache en ligne. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/446446/">  Bonjour mes amis.  Fin avril, nous lan√ßons un nouveau cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´S√©curit√© des Syst√®mes d'Information¬ª</a> .  Et maintenant, nous voulons partager avec vous une traduction de l'article, qui sera certainement tr√®s utile pour le cours.  L'article original se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trouve ici</a> . <br><br>  L'article d√©crit les fondements cl√©s, ils sont communs √† tous les moteurs JavaScript, et pas seulement √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V8</a> , sur laquelle les auteurs du moteur ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Benedict</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Matias</a> ) travaillent.  En tant que d√©veloppeur JavaScript, je peux dire qu'une compr√©hension plus approfondie du fonctionnement du moteur JavaScript vous aidera √† comprendre comment √©crire du code efficace. <br><br><img src="https://habrastorage.org/webt/14/ef/xe/14efxewawb3ttgslcsxyzicgjy0.png"><br><a name="habracut"></a><br><blockquote>  <b>Remarque</b> : si vous pr√©f√©rez regarder des pr√©sentations que lire des articles, regardez cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vid√©o</a> .  Sinon, sautez-le et lisez la suite. </blockquote>  <b>Moteur JavaScript de pipeline (pipeline)</b> <br><br>  Tout commence par le fait que vous √©crivez du code JavaScript.  Apr√®s cela, le moteur JavaScript traite le code source et le pr√©sente comme un arbre de syntaxe abstraite (AST).  Sur la base de l'AST construit, l'interpr√©teur peut enfin se mettre au travail et commencer √† g√©n√©rer du bytecode.  Super!  C'est le moment o√π le moteur ex√©cute le code JavaScript. <br><br><img src="https://habrastorage.org/webt/i6/8r/f2/i68rf23urqlxa20gzhubwz2-snq.jpeg"><br><br>  Pour le faire fonctionner plus rapidement, vous pouvez envoyer du bytecode au compilateur d'optimisation avec les donn√©es de profilage.  Le compilateur d'optimisation √©met certaines hypoth√®ses sur la base des donn√©es de profilage, puis g√©n√®re un code machine hautement optimis√©. <br><br>  Si √† un moment donn√© les hypoth√®ses s'av√®rent incorrectes, le compilateur d'optimisation d√©soptimisera le code et retournera √† l'√©tape de l'interpr√©teur. <br><br>  <b>Pipelines d'interpr√©tation / compilateur dans les moteurs JavaScript</b> <br><br>  Examinons maintenant de plus pr√®s les parties du pipeline qui ex√©cutent votre code JavaScript, √† savoir o√π le code est interpr√©t√© et optimis√©, et examinons √©galement quelques diff√©rences entre les principaux moteurs JavaScript. <br><br>  Au c≈ìur de tout se trouve un pipeline qui contient un interpr√©teur et un compilateur d'optimisation.  L'interpr√©teur g√©n√®re rapidement un bytecode non optimis√©, le compilateur d'optimisation, √† son tour, fonctionne plus longtemps, mais la sortie a un code machine hautement optimis√©. <br><br><img src="https://habrastorage.org/webt/gh/ap/o6/ghapo68sxzyqniyjqw0v0xewpry.jpeg"><br><br>  Ensuite, un pipeline qui montre comment fonctionne la V8, le moteur JavaScript utilis√© par Chrome et Node.js. <br><br><img src="https://habrastorage.org/webt/8i/nu/0w/8inu0wkuzc8_enexkp8o7pn7jgi.jpeg"><br><br>  L'interpr√©teur dans V8 est appel√© Ignition, qui est responsable de la g√©n√©ration et de l'ex√©cution du bytecode.  Il collecte des donn√©es de profilage qui peuvent √™tre utilis√©es pour acc√©l√©rer l'ex√©cution √† l'√©tape suivante pendant le traitement du bytecode.  Lorsqu'une fonction devient <i>chaude</i> , par exemple, si elle d√©marre fr√©quemment, le bytecode g√©n√©r√© et les donn√©es de profilage sont transf√©r√©s vers le TurboFan, c'est-√†-dire vers le compilateur d'optimisation pour g√©n√©rer un code machine hautement optimis√© bas√© sur les donn√©es de profilage. <br><br><img src="https://habrastorage.org/webt/ww/n5/zi/wwn5zi7l8vzzcfaik86qwhdtprc.jpeg"><br><br>  Par exemple, le moteur JavaScript SpiderMonkey de Mozilla, qui est utilis√© dans Firefox et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SpiderNode</a> , fonctionne un peu diff√©remment.  Il n'a pas un, mais deux compilateurs d'optimisation.  L'interpr√©teur est optimis√© en un compilateur de base (compilateur Baseline), qui produit du code optimis√©.  Avec les donn√©es de profilage collect√©es lors de l'ex√©cution du code, le compilateur IonMonkey peut g√©n√©rer du code fortement optimis√©.  Si l'optimisation sp√©culative √©choue, IonMonkey retourne au code de base. <br><br><img src="https://habrastorage.org/webt/gu/ek/ps/guekpsu0p1nqwv-pynj7ts8skdo.jpeg"><br><br>  Chakra - Le moteur JavaScript de Microsoft, utilis√© dans Edge et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Node-ChakraCore</a> , a une structure tr√®s similaire et utilise deux compilateurs d'optimisation.  L'interpr√©teur est optimis√© dans SimpleJIT (o√π JIT signifie ¬´Just-In-Time compiler¬ª, qui produit un code quelque peu optimis√©. Avec les donn√©es de profilage, FullJIT peut cr√©er un code encore plus optimis√©. <br><br><img src="https://habrastorage.org/webt/z-/bl/0v/z-bl0va0qlsrvgandnxrb08q52g.jpeg"><br><br>  JavaScriptCore (en abr√©g√© JSC), le moteur JavaScript d'Apple utilis√© par Safari et React Native, a g√©n√©ralement trois compilateurs d'optimisation diff√©rents.  LLInt est un interpr√©teur de bas niveau optimis√© pour le compilateur de base, qui √† son tour est optimis√© pour le compilateur DFG (Data Flow Graph), et il est d√©j√† optimis√© pour le compilateur FTL (Faster Than Light). <br><br>  Pourquoi certains moteurs ont-ils des compilateurs plus optimisants que d'autres?  Il s'agit de compromis.  L'interpr√©teur peut traiter rapidement le bytecode, mais le bytecode seul n'est pas particuli√®rement efficace.  Le compilateur d'optimisation, en revanche, fonctionne un peu plus longtemps, mais produit un code machine plus efficace.  C'est un compromis entre obtenir rapidement le code (interpr√®te) ou attendre et ex√©cuter le code avec des performances maximales (optimisation du compilateur).  Certains moteurs choisissent d'ajouter plusieurs compilateurs d'optimisation avec diff√©rentes caract√©ristiques de temps et d'efficacit√©, ce qui vous permet de fournir le meilleur contr√¥le sur cette solution de compromis et de comprendre le co√ªt des complications suppl√©mentaires du p√©riph√©rique interne.  Un autre compromis est l'utilisation de la m√©moire; consultez cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> pour une meilleure compr√©hension. <br><br>  Nous venons d'examiner les principales diff√©rences entre les pipelines de compilateur d'interpr√©teur et d'optimiseur pour divers moteurs JavaScript.  Malgr√© ces diff√©rences de haut niveau, tous les moteurs JavaScript ont la m√™me architecture: ils ont tous un analyseur et une sorte de pipeline interpr√®te / compilateur. <br><br>  <b>Mod√®le d'objet JavaScript</b> <br><br>  Voyons ce que les autres moteurs JavaScript ont en commun et quelles astuces ils utilisent pour acc√©l√©rer l'acc√®s aux propri√©t√©s des objets JavaScript?  Il s'av√®re que tous les moteurs principaux le font de mani√®re similaire. <br><br>  La sp√©cification ECMAScript d√©finit tous les objets comme des dictionnaires avec des cl√©s de cha√Æne correspondant aux attributs de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">propri√©t√©</a> . <br><br><img src="https://habrastorage.org/webt/7s/vv/qq/7svvqqqqfcqi2y-v88nlstidtik.jpeg"><br><br>  En plus de <code>[[Value]]</code> - <code>[[Value]]</code> , la sp√©cification d√©finit les propri√©t√©s suivantes: <br><br><ul><li>  <code>[[Writable]]</code> d√©termine si une propri√©t√© peut √™tre r√©affect√©e; </li><li>  <code>[[Enumerable]]</code> d√©termine si la propri√©t√© est affich√©e dans les boucles for-in; </li><li>  <code>[[Configurable]]</code> d√©termine si une propri√©t√© peut √™tre supprim√©e. </li></ul><br>  La notation <code>[[  ]]</code> semble √©trange, mais c'est ainsi que la sp√©cification d√©crit les propri√©t√©s en JavaScript.  Vous pouvez toujours obtenir ces attributs de propri√©t√© pour tout objet et propri√©t√© donn√©s en JavaScript √† l'aide de l'API <code>Object.getOwnPropertyDescriptor</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(object, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí { value: 42, writable: true, enumerable: true, configurable: true }</span></span></code> </pre> <br>  Ok, donc JavaScript d√©finit les objets.  Et les tableaux? <br><br>  Vous pouvez imaginer les tableaux comme des objets sp√©ciaux.  La seule diff√©rence est que les tableaux ont un traitement d'index sp√©cial.  Ici, un index de tableau est un terme sp√©cial dans la sp√©cification ECMAScript.  JavaScript a des limites sur le nombre d'√©l√©ments dans un tableau - jusqu'√† 2¬≥¬≤ - 1.  Un index de tableau est tout index disponible de cette plage, c'est-√†-dire toute valeur enti√®re de 0 √† 2¬≥¬≤ - 2. <br><br>  Une autre diff√©rence est que les tableaux ont la propri√©t√© magique de la <code>length</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; array.length; <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 2 array[2] = 'c'; array.length; // ‚Üí 3</span></span></code> </pre> <br>  Dans cet exemple, le tableau a une longueur de 2 au moment de la cr√©ation.  Ensuite, nous attribuons un autre √©l√©ment √† l'index 2 et la longueur augmente automatiquement. <br><br>  JavaScript d√©finit les tableaux ainsi que les objets.  Par exemple, toutes les cl√©s, y compris les indices de tableau, sont repr√©sent√©es explicitement sous forme de cha√Ænes.  Le premier √©l√©ment du tableau est stock√© sous la cl√© ¬´0¬ª. <br><br><img src="https://habrastorage.org/webt/a0/nr/18/a0nr18etozy9wzmzzsd9zbykxt0.jpeg"><br><br>  La propri√©t√© <code>length</code> n'est qu'une autre propri√©t√© qui s'av√®re non √©num√©rable et non configurable. <br><br>  D√®s qu'un √©l√©ment est ajout√© au tableau, JavaScript met automatiquement √† jour l'attribut de la propri√©t√© <code>[[Value]]</code> de la propri√©t√© <code>length</code> . <br><br><img src="https://habrastorage.org/webt/ws/hs/89/wshs896vflemplsrai-wqu5brkw.jpeg"><br><br>  En g√©n√©ral, nous pouvons dire que les tableaux se comportent de mani√®re similaire aux objets. <br><br>  <b>Optimisation de l'acc√®s aux propri√©t√©s</b> <br><br>  Maintenant que nous savons comment les objets sont d√©finis en JavaScript, voyons comment les moteurs JavaScript vous permettent de travailler efficacement avec des objets. <br><br>  Dans la vie de tous les jours, l'acc√®s aux propri√©t√©s est l'op√©ration la plus courante.  Il est extr√™mement important que le moteur le fasse rapidement. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-string"><span class="hljs-string">'qux'</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">// Here, we're accessing the property `foo` on `object`: doSomething(object.foo); // ^^^^^^^^^^</span></span></code> </pre> <br>  <b>Formulaires</b> <br><br>  Dans les programmes JavaScript, il est assez courant d'affecter les m√™mes cl√©s de propri√©t√© √† de nombreux objets.  Ils disent que ces objets ont la m√™me <i>forme</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// `object1` and `object2` have the same shape.</span></span></code> </pre> <br>  La m√©canique commune est √©galement l'acc√®s √† la propri√©t√© d'objets de la m√™me forme: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object.x); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^ } const object1 = { x: 1, y: 2 }; const object2 = { x: 3, y: 4 }; logX(object1); logX(object2);</span></span></code> </pre> <br>  Sachant cela, les moteurs JavaScript peuvent optimiser l'acc√®s √† la propri√©t√© d'un objet en fonction de sa forme.  Voyez comment cela fonctionne. <br><br>  Supposons que nous ayons un objet avec les propri√©t√©s x et y, il utilise la structure de donn√©es du dictionnaire, dont nous avons parl√© plus t√¥t;  il contient des cha√Ænes de cl√©s qui pointent vers leurs attributs respectifs. <br><br><img src="https://habrastorage.org/webt/ss/ne/v9/ssnev9md3jko58annrfjraz35ay.jpeg"><br><br>  Si vous acc√©dez √† une propri√©t√©, telle que <code>object.y,</code> le moteur JavaScript recherche un JSObject avec la cl√© <code>'y'</code> , puis charge les attributs de propri√©t√© qui correspondent √† cette requ√™te et retourne finalement <code>[[Value]]</code> . <br><br>  Mais o√π ces attributs de propri√©t√© sont-ils stock√©s en m√©moire?  Faut-il les stocker dans le cadre d'un JSObject?  Si nous le faisons, nous verrons plus d'objets de cette forme plus tard, auquel cas, c'est un gaspillage d'espace pour stocker un dictionnaire complet contenant les noms des propri√©t√©s et des attributs dans JSObject lui-m√™me, car les noms de propri√©t√© sont r√©p√©t√©s pour tous les objets de la m√™me forme.  Cela provoque beaucoup de duplication et conduit √† une mauvaise allocation de la m√©moire.  Pour l'optimisation, les moteurs stockent la forme de l'objet s√©par√©ment. <br><br><img src="https://habrastorage.org/webt/mc/yr/mt/mcyrmt9jarqodgtvnwoxzatiwyy.jpeg"><br><br>  Cette <code>Shape</code> contient tous les noms et attributs de propri√©t√© sauf <code>[[Value]]</code> .  Au lieu de cela, le formulaire contient les valeurs de d√©calage √† l'int√©rieur du JSObject, de sorte que le moteur JavaScript sait o√π chercher les valeurs.  Chaque JSObject avec un formulaire commun indique une instance sp√©cifique du formulaire.  D√©sormais, chaque JSObject ne doit stocker que des valeurs uniques √† l'objet. <br><br><img src="https://habrastorage.org/webt/-0/-q/t5/-0-qt5an58iyuoeskzaibbtgcno.jpeg"><br><br>  L'avantage devient √©vident d√®s que nous avons beaucoup d'objets.  Leur nombre n'a pas d'importance, car s'ils ont un seul formulaire, nous n'enregistrons les informations sur le formulaire et la propri√©t√© qu'une seule fois. <br><br>  Tous les moteurs JavaScript utilisent des formulaires comme moyen d'optimisation, mais ils ne les nomment pas directement en tant que <code>shapes</code> : <br><br><ol><li>  La documentation acad√©mique les appelle classes cach√©es (similaires aux classes JavaScript); </li><li>  V8 les appelle Maps; </li><li>  Chakra les appelle des types; </li><li>  JavaScriptCore les appelle Structures; </li><li>  SpiderMonkey les appelle des formes. </li></ol><br>  Dans cet article, nous continuons √† les appeler des <code>shapes</code> . <br><br>  <b>Cha√Ænes de transition et arbres</b> <br><br>  Que se passe-t-il si vous avez un objet d'une certaine forme, mais que vous lui ajoutez une nouvelle propri√©t√©?  Comment le moteur JavaScript d√©finit-il un nouveau formulaire? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = {}; object.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; object.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Les formulaires cr√©ent ce qu'on appelle des cha√Ænes de transition dans le moteur JavaScript.  Voici un exemple: <br><br><img src="https://habrastorage.org/webt/tm/tz/np/tmtznpiuyzkz9vpxqe6byhw2x-k.jpeg"><br><br>  Un objet n'a initialement aucune propri√©t√©, il correspond √† un formulaire vide.  L'expression suivante ajoute la propri√©t√© <code>'x'</code> avec une valeur de 5 √† cet objet, puis le moteur passe au formulaire qui contient la propri√©t√© <code>'x'</code> et la valeur 5 est ajout√©e √† JSObject au premier d√©calage 0. La ligne suivante ajoute la propri√©t√© <code>'y'</code> , puis le moteur passe au suivant un formulaire qui contient d√©j√† √† la fois <code>'x'</code> et <code>'y'</code> , et ajoute √©galement la valeur 6 √† JSObject au d√©calage 1. <br><blockquote>  <b>Remarque</b> : La s√©quence dans laquelle les propri√©t√©s sont ajout√©es affecte le formulaire.  Par exemple, {x: 4, y: 5} donnera une forme diff√©rente de {y: 5, x: 4}. <br></blockquote>  Nous n'avons m√™me pas besoin de stocker la table de propri√©t√©s enti√®re pour chaque formulaire.  Au lieu de cela, chaque formulaire a besoin de conna√Ætre uniquement une nouvelle propri√©t√© qu'ils essaient d'y inclure.  Par exemple, dans ce cas, nous n'avons pas besoin de stocker des informations sur ¬´x¬ª sous cette derni√®re forme, car elles peuvent √™tre trouv√©es plus t√¥t dans la cha√Æne.  Pour que cela fonctionne, le formulaire fusionne avec son formulaire pr√©c√©dent. <br><br><img src="https://habrastorage.org/webt/ks/ou/pv/ksoupve8bep3jsp0v7u2ahyv9jg.jpeg"><br><br>  Si vous √©crivez <code>ox</code> dans votre code JavaScript, JavaScript recherchera la propri√©t√© <code>'x'</code> long de la cha√Æne de transition jusqu'√† ce qu'il d√©tecte un formulaire qui contient d√©j√† la propri√©t√© <code>'x'</code> . <br><br>  Mais que se passe-t-il s'il est impossible de cr√©er une cha√Æne de transition?  Par exemple, que se passe-t-il si vous avez deux objets vides et que vous leur ajoutez des propri√©t√©s diff√©rentes? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; object2.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Dans ce cas, une branche appara√Æt, et au lieu de la cha√Æne de transition, nous obtenons un arbre de transition: <br><br><img src="https://habrastorage.org/webt/bc/ga/ax/bcgaaxeskfqwqt8geu_pxmqwdou.jpeg"><br><br>  Nous cr√©ons un objet vide <code>a</code> et y ajoutons la propri√©t√© <code>'x'</code> .  En cons√©quence, nous avons un <code>JSObject</code> contenant une seule valeur et deux formulaires: vide et un formulaire avec une seule propri√©t√© <code>'x'</code> . <br><br>  Le deuxi√®me exemple commence par le fait que nous avons un objet vide <code>b</code> , mais ensuite nous ajoutons une autre propri√©t√© <code>'y'</code> .  En cons√©quence, nous obtenons ici deux cha√Ænes de formes, mais √† la fin, nous obtenons trois cha√Ænes. <br><br>  Est-ce √† dire que nous commen√ßons toujours par un formulaire vide?  Pas forc√©ment.  Les moteurs utilisent une certaine optimisation des litt√©raux d'objet, qui contiennent d√©j√† des propri√©t√©s.  Disons que nous ajoutons x, en commen√ßant par un litt√©ral d'objet vide, ou que nous avons un litt√©ral d'objet qui contient d√©j√† <code>x</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> };</code> </pre> <br>  Dans le premier exemple, nous commen√ßons avec un formulaire vide et passons √† une cha√Æne qui contient √©galement <code>x</code> , comme nous l'avons vu pr√©c√©demment. <br><br>  Dans le cas de <code>object2</code> il est logique de cr√©er directement des objets qui ont d√©j√† x d√®s le d√©but, plut√¥t que de commencer avec un objet vide et une transition. <br><br><img src="https://habrastorage.org/webt/qv/_0/l-/qv_0l-f5eekqflfmto7lfd-awwq.jpeg"><br><br>  Le litt√©ral d'un objet qui contient la propri√©t√© <code>'x'</code> commence par un formulaire contenant <code>'x'</code> d√®s le d√©but, et le formulaire vide est effectivement ignor√©.  C'est (au moins) ce que font V8 et SpiderMonkey.  L'optimisation raccourcit la cha√Æne de transition et facilite l'assemblage d'objets √† partir de litt√©raux. <br><br>  Le billet de blog de Benedict sur l'incroyable polymorphisme des applications sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">React</a> explique comment de telles subtilit√©s peuvent affecter les performances. <br><br>  De plus, vous verrez un exemple de points d'un objet tridimensionnel avec les propri√©t√©s <code>'x'</code> , <code>'y'</code> , <code>'z'</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = {}; point.x = <span class="hljs-number"><span class="hljs-number">4</span></span>; point.y = <span class="hljs-number"><span class="hljs-number">5</span></span>; point.z = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Comme vous l'avez compris pr√©c√©demment, nous cr√©ons un objet avec trois formulaires en m√©moire (sans compter le formulaire vide).  Pour acc√©der √† la propri√©t√© <code>'x'</code> de cet objet, par exemple, si vous √©crivez <code>point.x</code> dans votre programme, le moteur JavaScript doit suivre une liste li√©e: en commen√ßant par le formulaire tout en bas, puis en remontant progressivement vers le formulaire qui a <code>'x'</code> tout en haut. <br><br><img src="https://habrastorage.org/webt/tv/rn/mp/tvrnmp1s5p25dseplockgifr6x0.jpeg"><br><br>  Cela se r√©v√®le tr√®s lentement, surtout si vous le faites souvent et avec beaucoup de propri√©t√©s de l'objet.  Le temps de s√©jour d'une propri√©t√© est <code>O(n)</code> , c'est-√†-dire qu'il s'agit d'une fonction lin√©aire qui est en corr√©lation avec le nombre de propri√©t√©s de l'objet.  Pour acc√©l√©rer les recherches de propri√©t√©s, les moteurs JavaScript ajoutent une structure de donn√©es ShapeTable.  ShapeTable est un dictionnaire o√π les cl√©s sont mapp√©es d'une certaine mani√®re avec les formulaires et produisent la propri√©t√© souhait√©e. <br><br><img src="https://habrastorage.org/webt/y8/vh/40/y8vh40rwdlx99jdv-rpumbe1u3u.jpeg"><br><br>  Attendez une seconde, maintenant nous retournons √† la recherche de dictionnaire ... C'est exactement ce avec quoi nous avons commenc√© lorsque nous avons mis les formulaires en premier lieu!  Alors, pourquoi nous soucions-nous m√™me des formulaires? <br>  Le fait est que les formulaires contribuent √† une autre optimisation appel√©e <i>caches en ligne.</i> <br><br>  Nous parlerons du concept de caches en ligne ou de circuits int√©gr√©s dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxi√®me partie de l'</a> article, et nous voulons maintenant vous inviter √† un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">webinaire ouvert gratuit</a> , qui sera organis√© par le c√©l√®bre analyste de virus et professeur √† temps partiel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alexander Kolesnikov</a> , le 9 avril. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446446/">https://habr.com/ru/post/fr446446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446434/index.html">Mise √† l'√©chelle de Zimbra Collaboration Suite</a></li>
<li><a href="../fr446436/index.html">Comment g√©n√©rer des hypoth√®ses sur les besoins des consommateurs potentiels de votre futur produit</a></li>
<li><a href="../fr446438/index.html">Notre exp√©rience de cr√©ation d'API de passerelle</a></li>
<li><a href="../fr446440/index.html">Le livre React Fast. Applications Web dans React, JSX, Redux et GraphQL ¬ª</a></li>
<li><a href="../fr446444/index.html">De Skype √† WebRTC: comment nous avons organis√© la communication vid√©o sur le Web</a></li>
<li><a href="../fr446448/index.html">5 r√®gles de base pour mener des entretiens de probl√®mes pour identifier les besoins des consommateurs</a></li>
<li><a href="../fr446452/index.html">Mission lunaire "Bereshit" - le 4 avril 2019, la transition vers l'orbite lunaire a √©t√© achev√©e, 7 jours de vol √† venir, 6 man≈ìuvres et 1 atterrissage</a></li>
<li><a href="../fr446454/index.html">D√©veloppement de serveur Web Golang - De facile √† complexe</a></li>
<li><a href="../fr446456/index.html">La substitution des importations dans la pratique. Partie 1. Options</a></li>
<li><a href="../fr446458/index.html">DRO universel bas√© sur Arduino Nano - shDRO. 2e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>