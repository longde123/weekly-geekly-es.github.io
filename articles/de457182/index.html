<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📼 ⌚️ 🛕 REXX Language, 40. Jahrestag 👩🏼‍🎓 🎭 👨🏻‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="REXX ist für seine Zeit eine ziemlich alte, fortgeschrittene Sprache. Er erschien laut Wikipedia 1979, das heißt, er wurde kürzlich 40 Jahre alt. Natü...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>REXX Language, 40. Jahrestag</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457182/"> REXX ist für seine Zeit eine ziemlich alte, fortgeschrittene Sprache.  Er erschien laut Wikipedia 1979, das heißt, er wurde kürzlich 40 Jahre alt.  Natürlich nicht die altmodischste Sprache, aber ein anständiges Alter. <br><br>  Rexx ist eine Abkürzung, es bedeutet Restructured Extended Executor, was uns wahrscheinlich auf seine Vorfahren EXEC / EXEC2 verweist.  Ich traf ihn im VM / SP 3-Betriebssystem, wo er genau diese Skriptsprachen ersetzte.  Dann war es in OS / 2 beliebt, wurde in vielen anderen Betriebssystemen verwendet, und viele Implementierungen und abgeleitete Dialekte wurden erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e3/3-/xm/e33-xmyp9y5febqdrmh7hulewou.png" alt="Bild"></div><br>  Er hat Habré nicht allzu viel Aufmerksamkeit geschenkt, ich werde versuchen, die Lücken in diesem Artikel zu schließen. <br><a name="habracut"></a><br><h2>  Vorfahren, Ursprünge, Autoren </h2><br>  Die Implementierung in der Originalsprache hatte einen Autor, einen Mitarbeiter von IBM Mike Cowlishaw.  Diese Implementierung wurde in S / 360 Assembler geschrieben. <br><br>  Wikipedia glaubt, dass REXX von PL / 1, EXEC und EXEC2 sowie Algol beeinflusst wurde.  Im Großen und Ganzen ja, diese Sprache ist zweifellos in ihrer Syntax - der Erbe von Algol (oder Pascal, wenn Sie so wollen).  Das heißt, Schleifen, Blöcke usw.  Konstruktionen sind nicht von geschweiften Klammern umgeben, sondern von Schlüsselwörtern, z. B. do / end.  Für EXEC und EXEC2 wurde REXX als Ersatz für sie erstellt, und vielleicht hat es nichts mehr mit ihnen zu tun.  Aber im Vergleich zu PL / 1 ist REXX viel einfacher und der Zweck der Sprache ist völlig anders. <br><br>  Wie der REXX-Code aussieht: <br><br><pre><code class="delphi hljs">/*    <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">10</span></span> */ sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> say count sum = sum + count <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> say "    " sum"."</code> </pre> <br><h2>  Eigenschaften </h2><br>  Was war meiner Meinung nach das interessanteste oder ungewöhnlichste in dieser Sprache? <br><br>  1. Die Syntax der Sprache ist ziemlich frei, es ist natürlich nicht Fortran.  Algol und Pascal sehen am meisten aus.  Grundsätzlich auch im Grunde. <br><br>  Es gibt Operatoren, die für die strukturelle Programmierung typisch sind. <br><br>  Es gibt Funktionen und Verfahren.  Hier ist es etwas ungewöhnlich, dass die Prozedur standardmäßig alle Variablen vor dem aufrufenden Code verbirgt. Einige davon können jedoch mithilfe des Schlüsselkonstrukts expose &lt;Variablenliste&gt; verfügbar gemacht werden. <br><br>  Das Tippen ist dynamisch.  Eine Variable kann zu verschiedenen Zeitpunkten der Ausführung als Zeichenfolge oder als Zahl interpretiert und auch nicht definiert werden (dies kann überprüft werden, obwohl es schief ist).  Tatsächlich hat die Sprache einen primitiven Datentyp - Zeichenfolgen, über die arithmetische Operationen ausgeführt werden können, wenn die Zeichenfolge eine korrekte Zahl ist. <br><br>  Hier ist ein kleines Wikipedia-Beispiel: <br><br><pre> <code class="delphi hljs">say hello /* =&gt; HELLO */ hello = <span class="hljs-number"><span class="hljs-number">25</span></span> say hello /* =&gt; <span class="hljs-number"><span class="hljs-number">25</span></span> */ hello = "say <span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>" say hello /* =&gt; say <span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> */ interpret hello /* =&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> */ drop hello say hello /* =&gt; HELLO */</code> </pre><br>  Dies zeigt, dass die undefinierte Variable in der ersten (und letzten) Zeile in ihrem Namen in Großbuchstaben berechnet wird.  Auf diese Weise können Sie auf Unsicherheit prüfen. <br><br>  Die Interpretationsaussage ist ein Analogon zu dem, was heute gewöhnlich als eval bezeichnet wird. <br><br>  Die Fehlerbehandlung ist Basic vielleicht am ähnlichsten: <br><br><pre> <code class="delphi hljs">signal <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> halt <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> forever ... /*   */ <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> halt: /* .    halt,    */ <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span></code> </pre><br>  Dies ist die Programmabschlussverarbeitung (per Taste vom Terminal).  Neben dem Anhalten gibt es noch andere „Signale“, darunter beispielsweise die Syntax (Syntaxfehler im interpretierten Code).  Ich erinnere mich nicht, dass ich es praktisch angewendet habe, aber es ist ziemlich logisch, die syntaktische Korrektheit zu überprüfen, zum Beispiel, was der Interpretationseingabe zugeführt wird. <br><br>  2. Es gab keine regulären Ausdrücke, wie wir in Perl sagen (es blieben jedoch fast 10 Jahre vor Perl).  Das Konzept der regulären Ausdrücke tauchte früher auf, und es handelte sich sicherlich bereits um das Grep-Dienstprogramm.  Stattdessen gab es den Analyseoperator, ein vereinfachtes Analogon von Stammgästen, mit der Substitution von Gruppen in Variablen. <br><br><pre> <code class="delphi hljs">parse [origin] [template]</code> </pre><br>  Das heißt,  Wir analysieren den Inhalt der Quelle (der ein Argument für eine Funktion, eine Variable, einen Ausdruck usw. sein kann) auf Übereinstimmung mit der Vorlage.  Die Vorlage kann Literale enthalten, die die Werte und Variablen, die den Wert von der Quelle erhalten haben, zwischen diesen Trennzeichen trennen.  In gewisser Weise sieht es aus wie Gruppen in regulären Ausdrücken. <br><br><pre> <code class="delphi hljs">fio = <span class="hljs-string"><span class="hljs-string">', '</span></span> parse <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fio firstName <span class="hljs-string"><span class="hljs-string">','</span></span> LastName say firstName say LastName</code> </pre><br>  Dies ist natürlich viel einfacher als reguläre Ausdrücke, schon allein deshalb, weil es keine Metazeichen wie \ d, keine Wiederholung in Form von * oder +, keine Alternativen, nichts dergleichen gab. <br><br>  3. Rexx verfügte über eine API, mit der es nicht nur für das Betriebssystem (CMS), sondern auch für jedes andere Programm, das diese API unterstützte, als Skriptsprache verwendet werden konnte.  Das heißt,  Tatsächlich war es eine DSL-Schriftsprache.  Wahrscheinlich einer der ersten.  Gleichzeitig könnte die Laufzeit den Interpreter implementieren und ihm zusätzliche Funktionen oder Befehle zur Verfügung stellen, die als Ergebnis des Programms verfügbar sind. <br><br>  Es sah ungefähr so ​​aus: Als er den XEDIT-Texteditor startete, suchte er irgendwo auf zugänglichen Datenträgern nach einer Datei namens PROFILE XEDIT, die ein REXX-Skript enthielt.  Dieses Skript kann Funktionstasten zuweisen und zusätzliche Befehle definieren, die von XEDIT verfügbar sind.  In Bezug auf die Bedeutung ist es heute zum Beispiel .bashrc am nächsten.  Oder sein Analogon für vim. <br><br>  Dementsprechend könnten die in PROFILE XEDIT definierten REXX-Prozeduren und -Funktionen Editorbefehle ausführen und auf Informationen über geöffnete Dateien zugreifen, einschließlich des Inhalts der Datei selbst. <br><br>  4. Für die Übertragung von Befehlen an die Host-Umgebung (z. B. das Betriebssystem oder beispielsweise einen Texteditor) war keine spezielle Syntax erforderlich.  Stattdessen wurden alle Ausdrücke, die Rexx nicht erkannte, an die Ausführung übergeben.  Um den Betriebssystembefehl in das Skript zu schreiben, war es ausreichend, ihn in Anführungszeichen zu setzen, zum Beispiel: <br><br><pre> <code class="delphi hljs"><span class="hljs-string"><span class="hljs-string">'list * * * (stack'</span></span></code> </pre><br>  Ein Befehl kann durch Verketten von Zeichenfolgenkonstanten und -variablen erstellt werden.  Das Symbol der Verkettungsoperation war einfach ein Leerzeichen. <br><br>  Um den Befehl an eine andere Anwendung zu übertragen, gab es eine Adressanweisung.  Wenn Sie beispielsweise den XEDIT-Texteditor in der Umgebung verwenden, müssen Sie Folgendes tun, um nicht den XEDIT-Befehl, sondern das Betriebssystem (CMS) auszuführen: <br><br><pre> <code class="delphi hljs">address cms <span class="hljs-string"><span class="hljs-string">'list * * * (stack'</span></span></code> </pre><br>  5. Das CMS implementierte eine API für den Zugriff auf den OS-Befehlsstapel, mit der Rexx auch Daten austauschte.  Der obige Befehl gab die resultierende Liste der Dateien an den Stapel zurück, von wo aus das Skript sie abrufen und eine Zeile als Standardeingabe lesen konnte.  In mancher Hinsicht ähnelt dies Unix-Pipes, unterscheidet sich jedoch etwas von diesen.  Eine Pipe ist immer noch ein Bytestrom, und ein Stapel in CMS ist eine Sammlung von Zeichenfolgen.  Im Allgemeinen ist dies ein typischer Unterschied zwischen der Ideologie von Unix und dem Betriebssystem von IBM, bei dem die Dateien weitgehend auf feste oder variable (aber gleichzeitig bekannte) Längen ausgerichtet waren. <br><br>  6. Als Teil der API können Anwendungen auf Rexx-Skriptvariablen zugreifen und diese lesen und ändern.  Dies war eine weitere Möglichkeit, Daten auszutauschen. <br><br>  7. Eine ziemlich effektive Arithmetik beliebiger Genauigkeit wurde implementiert.  Beliebig - das bedeutet zum Beispiel 100 Zeichen oder mehr - wie viel Speicher ausreicht. <br><br>  8. Speicherverwaltung - automatisch.  Es gab zwar zum Beispiel einen Drop-Operator, um den Wert einer Variablen (eines assoziativen Arrays oder seiner Elemente) zu löschen, aber auf jeden Fall hatten Sie nichts mit Zeigern und Blockgrößen zu tun. <br><br>  9. Als einzige, aber gleichzeitig sehr universelle Datenstruktur gab es assoziative Arrays, die beispielsweise Javascript sehr ähnlich waren.  Das heißt, wenn Sie a.1 schreiben, ist dies ein Element des Arrays a mit Schlüssel 1. Wenn Sie ab schreiben, ist dies ein Element mit Schlüssel b. <br><br>  Angenommen, Sie fügen dem Wörterbuch ein Wort hinzu: <br><br><pre> <code class="delphi hljs">add_word: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expose</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dictionary</span></span></span><span class="hljs-function">. </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arg</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">n</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dictionary</span></span></span><span class="hljs-function">.0 + 1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dictionary</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">n</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dictionary</span></span></span><span class="hljs-function">.0 = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">n</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span></span></code> </pre><br>  Die Wörterbuchvariable in diesem Fragment ist unser assoziatives Array.  Die Prozedur gibt dieses Array nicht zurück, macht es jedoch von außen zugänglich (mithilfe von exponieren).  dictionary.0 speichert die Anzahl der Elemente im Wörterbuch (dies ist nur eine Konvention, und wie Sie sehen können, führen wir sie selbst aus), dictionary.n ist das n-te Wort des Wörterbuchs. <br><br>  10. Die Sprache hatte keinen einfachen Zugriff auf den Speicher oder die OC-API, obwohl es im Prinzip durchaus möglich war, etwas Ähnliches dafür zu schreiben.  Ich kann einige Beispiele für Spracherweiterungen nennen, eines wurde für die Arbeit mit einer SQL / DS-Datenbank (DB2) entwickelt und das zweite für den Austausch von Nachrichten zwischen virtuellen Maschinen in VM / SP.  Das heißt, alles, was Sie als DSL arrangieren können, kann im Prinzip implementiert werden. <br><br><h2>  REXX-Unterstützung in Anwendungen </h2><br>  Zusätzlich zum CMS selbst unterstützte REXX sofort den Haupt-XEDIT-Texteditor.  Sie konnten damit Makros auf REXX schreiben, die an Funktionstasten aufgehängt werden konnten, oder Befehle entweder über die Befehlszeile oder als sogenannte aufrufen.  "Präfix" -Befehle, die neben den Zeilen des Textes eingegeben wurden und deren Bearbeitung ermöglichten.  Mit dem Befehl d konnten Sie beispielsweise die Zeile löschen, neben der Sie eingegeben haben, es gab Befehle zum Kopieren oder Verschieben und andere.  Ein Makro unter REXX kann beispielsweise eine Zeichenfolge in Groß- oder Kleinbuchstaben konvertieren. <br><br>  Die zweite Anwendung, die die Sprache in meinem Speicher unterstützte, hieß DMS (Display Management System für CMS (DMS / CMS)) und war ein Tool zur Entwicklung interaktiver Programme, die aus Panels bestanden.  In REXX war es möglich, eines der vorgezeichneten Formulare auszuwählen, seine Felder mit Werten zu füllen und auf dem Bildschirm anzuzeigen.  Nachdem der Benutzer eine Funktionstaste gedrückt hatte, erhielt das Programm die Steuerung zurück und die REXX-Variablen enthielten die Werte der geänderten Felder.  Das nächste funktionale Analogon von DMS würde ich HTML und seine Formen nennen.  Und in Bezug auf die Komplexität (Einfachheit) der Entwicklung war dies vielleicht sogar ein wenig einfacher, obwohl HTML sicherlich in Bezug auf Ausdrucksmöglichkeiten gewinnt (zum Beispiel gab es in DMS überhaupt keine Bilder, was für Textterminals verständlich ist). <br><br>  Eine weitere erwähnenswerte Anwendung hieß ISPF.  Aber es war bereits viel breiter als DMS, und es ähnelte eher der integrierten Entwicklungsumgebung, wie sie jetzt aussieht, angepasst an Textterminals.  Und ja, der Texteditor wurde auch in REXX programmiert. <br><br>  Beginnend mit VM / SP 6 führte CMS Tools ein, mit denen virtuelle Fenster variabler Größe auf dem Terminalbildschirm erstellt und Text darin angezeigt werden können.  Die entsprechende API erschien für REXX (genauer gesagt, es war hauptsächlich eine Erweiterung von REXX). <br><br>  Eine weitere sehr interessante Anwendung von REXX war der sogenannte Auto-Operator.  Dies war eine Anwendung, die in der virtuellen Maschine des Betriebssystembetreibers ausgeführt wurde und alle Nachrichten empfing, die normalerweise an das Terminal des Bedieners kamen, und deren programmgesteuerte Verarbeitung ermöglichte.  Befehlshandler - REXX-Skript.  So war es beispielsweise möglich, vielen Personen einige Bedienerfunktionen zu geben, für die diese Personen einfach Nachrichten an die virtuelle Maschine des Bedieners sendeten, und der Handler (im Namen des privilegierten Benutzers, des Bedieners) einige Befehle für sie ausführte.  Nun, ich habe zum Beispiel Festplatten- oder Banddatenträger in das System eingebunden. <br><br>  Die Möglichkeiten waren jedoch nicht auf so einfache Dinge beschränkt.  Beispielsweise können Sie keine Nachricht an den Benutzer senden, wenn diese nicht im System vorhanden ist.  Senden Sie es an den automatischen Operator, es speichert es in der Warteschlange und sendet es dann (nachdem Sie eine Nachricht erhalten haben, dass der Benutzer angemeldet ist) an wen es benötigt wird.  Tatsächlich ist dies eine einfache E-Mail-Implementierung mit einem kleinen REXX-Skript. <br><br><h2>  Auswirkungen auf die Entwicklung </h2><br>  Ich würde sagen, dass wir mit dem Aufkommen von REXX in VM / SP 3 begonnen haben, einen wesentlichen Teil dessen zu schreiben, was zuvor beispielsweise auf PL / 1 geschrieben wurde.  Dies ist eine ziemlich leistungsfähige und gleichzeitig immer noch einfache Sprache, mit der Sie relativ große Anwendungen richtig strukturieren können.  Zunächst wahrscheinlich aufgrund seiner Integrationsmöglichkeiten, als es als DSL verwendet wurde. <br><br>  Die Fähigkeit, Datenbankabfragen (SQL / DS) zu erfüllen, Bildschirmformulare anzuzeigen, Dateien zu lesen und zu schreiben, deckt einen wesentlichen Teil der Anforderungen an die Entwicklung von Geschäftsanwendungen ab. <br><br>  Offensichtlich mochten viele Leute die Sprache.  Er war in OS / 2, war auf Amigami, unter Windows und vielen anderen wo.  Später gab es Object REXX mit Objekterweiterungen und NetREXX für JVM.  Die Hauptsache ist, dass diese Sprache noch lebt.  Und im Allgemeinen würde ich, wenn ich heute entscheiden müsste, worüber ich Skripte schreiben möchte, zum Beispiel Rexx, bash, die vollständig vogelsprachliche cmd.exe - definitiv die erste wählen würde.  Aber im Vergleich zu bereits neueren Sprachen wie Perl, Python und vielen, vielen anderen ist nicht alles so offensichtlich.  Angenommen, die Idee von Rexx, Befehle und Variablen zur Laufzeit zu übertragen, war gut - aber die Idee, beispielsweise COM, mit seiner Objektorientierung, ist noch funktionaler. <br><br>  Trotz der letzten 40 Jahre wird es immer noch in IBM z OS verwendet, und laut Wikipedia wurde vor kurzem um 2012 ein Sprachbuch veröffentlicht. Für verschiedene Betriebssysteme ist es durchaus möglich, Live-Implementierungen herunterzuladen und selbst auszuprobieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457182/">https://habr.com/ru/post/de457182/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457164/index.html">Navigation in einer plattformübergreifenden .NET Core-Anwendung mit Speicherstatus auf der Festplatte am Beispiel von ReactiveUI und Avalonia</a></li>
<li><a href="../de457168/index.html">Prototyp-Stimmungsanalyse mit Python und TextBlob</a></li>
<li><a href="../de457172/index.html">ScreenLogger - Lächeln, Sie werden von einer versteckten Kamera gefilmt</a></li>
<li><a href="../de457178/index.html">Wie Prozessoren entworfen und hergestellt werden: CPU-Design</a></li>
<li><a href="../de457180/index.html">Die offizielle Seite Node.js ist jetzt in russischer Sprache</a></li>
<li><a href="../de457184/index.html">Erstellen Sie dynamisch robots.txt für ASP.NET Core-Sites</a></li>
<li><a href="../de457186/index.html">Python in Visual Studio Code - Veröffentlichung im Juni</a></li>
<li><a href="../de457188/index.html">Ruhiger, ruhiger Streit</a></li>
<li><a href="../de457190/index.html">Wir behandeln das Geschäft durch die Implementierung von CRM-Systemen</a></li>
<li><a href="../de457192/index.html">Airbus erreicht mit der gemischten Realität von Microsoft neue Höhen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>