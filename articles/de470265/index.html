<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôåüèø üë©‚Äçüë©‚Äçüëß‚Äçüëß ü§æüèæ C ++ Abk√ºrzung Spickzettel und mehr. Teil 1: C ++ ü¶Ñ üßíüèø üì´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einmal wurde ich f√ºr die Position eines C ++ - Entwicklers in einem anst√§ndigen und sogar bekannten B√ºro interviewt. Ich hatte damals schon einige Erf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ Abk√ºrzung Spickzettel und mehr. Teil 1: C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470265/">  Einmal wurde ich f√ºr die Position eines C ++ - Entwicklers in einem anst√§ndigen und sogar bekannten B√ºro interviewt.  Ich hatte damals schon einige Erfahrungen, damals wurde ich sogar als f√ºhrender Entwickler bei meinem Arbeitgeber bezeichnet.  Aber als ich gefragt wurde, ob ich solche Dinge wie DRY, KISS, YAGNI, NIH w√ºsste, musste ich immer wieder mit ‚ÄûNein‚Äú antworten. <br><br>  Ich habe nat√ºrlich kl√§glich versagt.  Aber dann wurden die obigen Abk√ºrzungen gegoogelt und erinnert.  W√§hrend ich thematische Artikel und B√ºcher las, mich auf Interviews vorbereitete und nur mit Kollegen sprach, lernte ich mehr Neues, verga√ü sie, googelte erneut und verstand.  Vor ein paar Monaten erw√§hnte einer meiner Kollegen beil√§ufig im IIFE-Arbeitschat im Kontext von C ++.  Wie dieser Gro√üvater in einem Witz fiel ich fast vom Herd und stieg wieder in Google ein. <br><br><img src="https://habrastorage.org/webt/i7/7u/fc/i77ufc8-ui3-rtrvpu-421lmpfq.png"><br><a name="habracut"></a><br>  Zu diesem Zeitpunkt habe ich beschlossen, (haupts√§chlich f√ºr mich selbst) einen Spickzettel f√ºr Abk√ºrzungen zu erstellen, die f√ºr einen C ++ - Entwickler n√ºtzlich sind.  Dies bedeutet nicht, dass sie nur f√ºr C ++ gelten oder dass es sich um All-All-All-Konzepte aus C ++ handelt (Sie k√∂nnen B√§nde √ºber Sprachsprachen schreiben).  Nein, dies sind nur Konzepte, denen ich tats√§chlich in Arbeiten und Interviews begegnet bin, normalerweise ausgedr√ºckt in Form von Abk√ºrzungen.  Nun, ich habe absolut triviale Dinge wie LIFO, FIFO, CRUD, OOP, GCC und MSVC verpasst. <br><br>  Trotzdem kamen die Abk√ºrzungen anst√§ndig vor, so dass ich den Spickzettel in zwei Teile teilte: stark charakteristisch f√ºr C ++ und h√§ufiger.  Wenn es angebracht war, habe ich die Konzepte zusammengefasst, ansonsten habe ich sie einfach alphabetisch aufgelistet.  Im Allgemeinen macht ihre Reihenfolge nicht viel Sinn. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegende Dinge:</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ODR</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POD</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POF</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PIMPL</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RAII</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTTI</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STL</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UB</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Feinheiten der Sprache:</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ADL</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRTP</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CTAD</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EBO</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IIFE</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NVI</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RVO und NRVO</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SFINAE</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SBO, SOO, SSO</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>UPDATE:</b></a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lebenslauf</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LTO</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PCH</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PGO</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SEH / VEH</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TMP</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VLA</a> <br><br><h2>  Grundlegende Dinge <a name="Basics"></a></h2><br><h3>  ODR <a name="ODR"></a></h3><br>  <i>Eine Definitionsregel.</i>  <i>Die Regel einer Definition.</i>  Vereinfacht bedeutet Folgendes: <br><br><ul><li>  Innerhalb einer einzelnen √úbersetzungseinheit kann jede Variable, Funktion, Klasse usw. nicht mehr als eine Definition haben.  Es gibt so viele Anzeigen wie m√∂glich (au√üer √úbertragungen ohne einen bestimmten Basistyp, die einfach nicht ohne Definition deklariert werden k√∂nnen), aber nicht mehr als eine Definition.  Weniger m√∂glich, wenn die Entit√§t nicht verwendet wird. </li><li>  W√§hrend des gesamten Programms muss jede verwendete Nicht-Inline-Funktion und Variable genau eine Definition haben.  Jede verwendete Inline-Funktion und Variable muss in jeder √úbersetzungseinheit eine Definition haben. </li><li>  Einige Entit√§ten - beispielsweise Klassen, Inline-Funktionen und eine Variable, Vorlagen, Aufz√§hlungen usw. - k√∂nnen mehrere Definitionen in einem Programm haben (jedoch nicht mehr als eine in einer √úbersetzungseinheit).  Tats√§chlich geschieht dies, wenn derselbe Header, der beispielsweise eine vollst√§ndig implementierte Klasse enth√§lt, mit mehreren CPP-Dateien verbunden ist.  Aber diese Definitionen sollten √ºbereinstimmen (ich vereinfache stark, aber das Wesentliche ist dies).  Sonst wird es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UB sein</a> . </li></ul><br>  Der Compiler erkennt leicht eine <i>ODR-</i> Verletzung innerhalb einer √úbersetzungseinheit.  Er kann jedoch nichts tun, wenn die Regel auf Programmebene verletzt wird - schon allein deshalb, weil der Compiler jeweils eine √úbersetzungseinheit verarbeitet. <br><br>  Der Linker kann viel mehr Verst√∂√üe feststellen, ist aber streng genommen nicht dazu verpflichtet (weil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UB</a> laut Standard hier ist) und kann etwas verpassen.  Dar√ºber hinaus ist die Suche nach <i>ODR-</i> Verst√∂√üen in der Verkn√ºpfungsphase quadratisch komplex, und die Zusammenstellung von C ++ - Code ist nicht so schnell. <br><br>  Infolgedessen liegt die Hauptverantwortung f√ºr die Einhaltung dieser Regel (insbesondere auf Programmebene) beim Entwickler selbst.  Und ja - nur Entit√§ten mit einem externen Link k√∂nnen <i>ODR</i> im Programmma√üstab verletzen.  diejenigen von innen (d. h. in anonymen Namespaces definiert) nehmen an diesem Karneval nicht teil. <br><br>  Lesen Sie mehr: einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Englisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  Pod <a name="POD"></a></h3><br>  <i>Einfache alte Daten.</i>  <i>Einfache Datenstruktur.</i>  Die einfachste Definition: Dies ist eine solche Struktur, die Sie in bin√§rer Form an die C-Bibliothek senden / von dieser empfangen k√∂nnen.  Oder, das ist das gleiche, richtig mit einfachem <code>memcpy</code> kopieren. <br><br>  Von Standard zu Standard hat sich die vollst√§ndige Definition im Detail ge√§ndert.  Der neueste C ++ 17 <i>POD</i> definiert derzeit, wie <br><br><ul><li>  Skalartyp </li><li>  oder eine Klasse / Struktur / Vereinigung, die: <br>  - Es gibt eine triviale Klasse <br>  - Es gibt eine Klasse mit einem Standardger√§t <br>  - enth√§lt keine nicht statischen Nicht- <i>POD</i> -Felder <br></li><li>  oder ein Array dieser Typen </li></ul><br>  Trivialklasse: <br><br><ul><li>  hat mindestens eine nicht gel√∂scht: <br>  - Standardkonstruktor <br>  - Konstruktor kopieren <br>  - beweglicher Konstruktor <br>  - Zuweisungsoperator kopieren <br>  - Zuweisungsoperator verschieben <br></li><li>  Alle Standardkonstruktoren, die Konstruktoren und Zuweisungsoperatoren kopieren und verschieben, sind trivial (vereinfacht - vom Compiler generiert) oder remote </li><li>  hat einen trivialen nicht entfernten Destruktor </li><li>  Alle Basistypen und alle Felder von Klassentypen haben triviale Destruktoren </li><li>  keine virtuellen Methoden (einschlie√ülich Destruktor) </li><li>  Keine virtuellen Basistypen </li></ul><br>  Klasse mit einem Standardger√§t (Standardlayoutklasse): <br><br><ul><li>  keine virtuellen Methoden </li><li>  Keine virtuellen Basistypen </li><li>  Keine nicht statischen Linkfelder </li><li>  Alle nicht statischen Felder haben denselben Zugriffsmodifikator (√∂ffentlich / gesch√ºtzt / privat). </li><li>  Alle nicht statischen Felder und Basisklassen sind ebenfalls Typen mit einem Standardger√§t </li><li>  Alle nicht statischen Felder der Klasse selbst und aller ihrer Vorfahren werden in einer einzigen Klasse deklariert (d. h. in der Klasse selbst oder in einem der Vorfahren). </li><li>  Es erbt nicht zweimal denselben Typ, d. H. Es ist unm√∂glich, dies zu tun: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> :</span></span> A{}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> B, C {};</code> </pre> </li><li>  Der Typ des ersten nicht statischen Felds oder, wenn es sich um ein Array handelt, der Typ seines Elements darf nicht mit einem der Grundtypen √ºbereinstimmen (aufgrund des obligatorischen <i>EBO</i> in diesem Fall). </li></ul><br>  In C ++ 20 gibt es jedoch nicht mehr das Konzept des <i>POD-</i> Typs, sondern nur noch den trivialen Typ und den Typ mit dem Standardger√§t. <br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins (Russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei (Englisch)</a> <br><br><h3>  POF <a name="POF"></a></h3><br>  <i>Einfache alte Funktion.</i>  <i>Eine einfache Funktion</i> im <i>C-Stil, die</i> im Standard vor C ++ 14 einschlie√ülich nur im Zusammenhang mit Signalhandlern erw√§hnt wurde.  Die Voraussetzungen daf√ºr sind: <br><br><ul><li>  verwendet nur Dinge, die C und C ++ gemeinsam haben (d. h. keine Ausnahmen und beispielsweise <code>try-catch</code> ) </li><li>  verursacht keine direkten oder indirekten Nicht- <i>POF-</i> Funktionen, mit Ausnahme von <code>std::atomic_init</code> Operationen ( <code>std::atomic_init</code> , <code>std::atomic_fetch_add</code> usw.) </li></ul><br>  Nur solche Funktionen, die auch eine C-Verbindung ( <code>extern "C"</code> ) haben, d√ºrfen vom Standard als Signalhandler verwendet werden.  Die Unterst√ºtzung anderer Funktionen h√§ngt vom Compiler ab. <br><br>  In C ++ 17 verschwindet das <i>POF-</i> Konzept, anstatt dass es als signal-sichere Auswertung erscheint.  In solchen Berechnungen sind verboten: <br><br><ul><li>  ruft alle Funktionen der Standardbibliothek auf, au√üer atomar, sperrfrei </li><li>  <code>new</code> und <code>delete</code> Anrufe </li><li>  mit <code>dynamic_cast</code> </li><li>  Aufruf der Entit√§t <code>thread_local</code> </li><li>  jede Arbeit mit Ausnahmen </li><li>  Initialisierung einer lokalen statischen Variablen </li><li>  Warten auf den Abschluss der statischen Variableninitialisierung </li></ul><br>  Wenn der Signalhandler einen der oben genannten Schritte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausf√ºhrt,</a> verspricht der Standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UB</a> . <br><br>  Weiterlesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeit (Englisch)</a> <br><br><h3>  PIMPL <a name="PIMPL"></a></h3><br>  <i>Zeiger auf die Implementierung.</i>  <i>Zeiger auf die Umsetzung.</i>  Die klassische Redewendung in C ++, auch bekannt als D-Zeiger, undurchsichtiger Zeiger, Kompilierungsfirewall.  Es besteht in der Tatsache, dass alle privaten Methoden, Felder und anderen Implementierungsdetails einer bestimmten Klasse einer separaten Klasse zugeordnet sind und nur √∂ffentliche Methoden (d. H. Eine Schnittstelle) und ein Zeiger auf eine Instanz dieser neuen separaten Klasse in der urspr√ºnglichen Klasse verbleiben.  Zum Beispiel: <br><br><div class="spoiler">  <b class="spoiler_title">foo.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Foo(); ~Foo(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doThis</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doThat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Impl&gt; pImpl_; };</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">foo.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"foo.hpp"</span></span></span><span class="hljs-meta"> class Foo::Impl { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// implementation }; Foo::Foo() : pImpl_(std::make_unique&lt;Impl&gt;()) {} Foo::~Foo() = default; void Foo::doThis() { pImpl_-&gt;doThis(); } int Foo::doThat() { return pImpl_-&gt;doThat(); }</span></span></span></span></code> </pre> <br></div></div><br>  Warum ist dies notwendig, d. H. Vorteile: <br><br><ul><li>  Kapselung: Benutzer der Klasse erhalten √ºber die Header-Verbindung nur das, was sie ben√∂tigen - eine √∂ffentliche Schnittstelle.  Wenn sich die Implementierungsdetails √§ndern, muss der Clientcode nicht neu kompiliert werden (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ABI</a> ). </li><li>  Kompilierungszeit: Da der √∂ffentliche Header nichts √ºber die Implementierung wei√ü, enth√§lt er nicht die vielen ben√∂tigten Header.  Dementsprechend wird die Anzahl implizit verbundener Header im Clientcode reduziert.  Die Suche nach Namen und die Aufl√∂sung von √úberladungen wird ebenfalls vereinfacht, da die √∂ffentliche √úberschrift keine privaten Mitglieder enth√§lt (obwohl sie privat sind, nehmen sie an diesen Prozessen teil). </li></ul><br>  Preis, d. H. Nachteile: <br><br><ul><li>  Plus mindestens eine Zeiger-Dereferenzierung und plus ein Funktionsaufruf beim Zugriff auf √∂ffentliche Methoden. </li><li>  Die Gr√∂√üe der ben√∂tigten Speicherklasse wird um die Gr√∂√üe des Zeigers erh√∂ht. </li><li>  Ein Teil dieses Speichers (h√∂chstwahrscheinlich gr√∂√üer) wird auf dem Heap zugewiesen, was sich auch negativ auf die Leistung auswirkt. </li><li>  Die logische Konstanz kann leicht verletzt werden.  Ein solcher Code wird beispielsweise kompiliert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Foo::doThis() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { pImpl_-&gt;doThis(); <span class="hljs-comment"><span class="hljs-comment">// cosnt method pImpl_-&gt;doSmthElse(); // non-const method }</span></span></code> </pre> </li></ul><br>  Einige dieser M√§ngel k√∂nnen behoben werden, aber der Preis verkompliziert den Code weiter und f√ºhrt zus√§tzliche Abstraktionsebenen ein (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FTSE</a> ). <br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins (russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei (englisch)</a> <br><br><h3>  RAII <a name="RAII"></a></h3><br>  <i>Ressourcenbeschaffung ist Initialisierung.</i>  <i>Das Erfassen einer Ressource ist die Initialisierung.</i>  Die Bedeutung dieser Redewendung ist, dass die Beibehaltung einer bestimmten Ressource w√§hrend der gesamten Lebensdauer des entsprechenden Objekts anh√§lt.  Die Erfassung der Ressource erfolgt zum Zeitpunkt der Erstellung / Initialisierung des Objekts, der Freigabe - zum Zeitpunkt der Zerst√∂rung / Finalisierung desselben Objekts. <br><br>  Seltsamerweise (haupts√§chlich f√ºr C ++ - Programmierer) wird diese Redewendung auch in anderen Sprachen verwendet, selbst in Sprachen mit einem Garbage Collector.  In Java ist es <code>try--</code> , in Python die <code>with</code> Anweisung, in C # die <code>using</code> Direktive, in Go the <code>defer</code> .  Aber es ist in C ++ mit seiner absolut vorhersehbaren Lebensdauer von Objekten, in die <i>RAII</i> besonders organisch passt. <br><br>  In C ++ wird eine Ressource normalerweise im Konstruktor erfasst und im Destruktor freigegeben.  Beispielsweise steuern intelligente Zeiger den Speicher auf diese Weise, Dateistreams verwalten Dateien und Mutex sperrt Mutexe.  Das Sch√∂ne ist, dass unabh√§ngig davon, wie der Block verlassen wird (G√ºltigkeitsbereich) - ob dies an einem der Austrittspunkte normal ist oder eine Ausnahme ausgel√∂st wurde - das in diesem Block erstellte Ressourcensteuerungsobjekt zerst√∂rt und die Ressource freigegeben wird.  Das hei√üt,  Neben der Kapselung von <i>RAII</i> in C ++ tr√§gt es auch zur Gew√§hrleistung der Sicherheit im Sinne von Ausnahmen bei. <br><br>  Einschr√§nkungen, wo ohne sie.  Destruktoren in C ++ geben keine Werte zur√ºck und sollten kategorisch keine Ausnahmen ausl√∂sen.  Wenn die Freigabe der Ressource von der einen oder anderen begleitet wird, ist es dementsprechend erforderlich, zus√§tzliche Logik im Destruktor des Steuerobjekts zu implementieren. <br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einmal (Russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  RTTI <a name="RTTI"></a></h3><br>  <i>Informationen zum Laufzeit-Typ.</i>  <i>Typidentifikation zur Laufzeit.</i>  Dies ist ein Mechanismus zum Abrufen von Informationen √ºber den Typ eines Objekts oder Ausdrucks zur Laufzeit.  Es existiert in anderen Sprachen, aber in C ++ wird es verwendet f√ºr: <br><br><ul><li> <code>dynamic_cast</code> </li> <li>  <code>typeid</code> und <code>type_info</code> </li><li>  Ausnahme fangen </li></ul><br>  Eine wichtige Einschr√§nkung: <i>RTTI</i> verwendet eine Tabelle mit virtuellen Funktionen und funktioniert daher nur f√ºr polymorphe Typen (ein virtueller Destruktor ist ausreichend).  Eine wichtige Erkl√§rung: <code>dynamic_cast</code> und <code>typeid</code> verwenden nicht immer <i>RTTI</i> und funktionieren daher f√ºr nicht polymorphe Typen.  Um beispielsweise einen Link zu einem Nachkommen dynamisch in einen Link zu einem Vorfahren <i>umzuwandeln</i> , wird <i>RTTI</i> nicht ben√∂tigt, da alle Informationen zur Kompilierungszeit verf√ºgbar sind. <br><br>  <i>RTTI ist</i> nicht kostenlos, wenn auch ein wenig, wirkt sich jedoch negativ auf die Leistung und Gr√∂√üe des verbrauchten Speichers aus (daher der h√§ufige Rat, <code>dynamic_cast</code> wegen seiner Langsamkeit nicht zu verwenden).  Mit Compilern k√∂nnen Sie <i>RTTI</i> daher in der Regel deaktivieren.  GCC und MSVC versprechen, dass dies die Richtigkeit des Abfangens von Ausnahmen nicht beeintr√§chtigt. <br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einmal (Russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  STL <a name="STL"></a></h3><br>  <i>Standardvorlagenbibliothek.</i>  <i>Standardvorlagenbibliothek.</i>  Teil der C ++ - Standardbibliothek, die generische Container, Iteratoren, Algorithmen und Hilfsfunktionen bereitstellt. <br><br>  Trotz seines bekannten Namens wurde <i>STL</i> im Standard noch nie so genannt.  Aus den Abschnitten des Standards kann die <i>STL</i> eindeutig der Container-Bibliothek, der Iterator-Bibliothek, der Algorithmus-Bibliothek und teilweise der allgemeinen Dienstprogrammbibliothek zugeordnet werden. <br><br>  In Stellenbeschreibungen finden Sie h√§ufig zwei separate Anforderungen - Kenntnisse in C ++ und Vertrautheit mit <i>STL</i> .  Ich habe das nie verstanden, weil <i>STL</i> seit dem ersten Standard von 1998 ein wesentlicher Bestandteil der Sprache ist. <br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einmal (Russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  UB <a name="UB"></a></h3><br>  <i>Undefiniertes Verhalten.</i>  <i>Undefiniertes Verhalten.</i>  Dieses Verhalten tritt in den Fehlerf√§llen auf, f√ºr die der Standard keine Anforderungen stellt.  Viele davon sind im Standard explizit aufgef√ºhrt und f√ºhren zu <i>UB</i> .  Dazu geh√∂ren zum Beispiel: <br><br><ul><li>  Verletzung der Grenzen eines Arrays oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STL-</a> Containers </li><li>  Verwendung einer nicht initialisierten Variablen </li><li>  Dereferenzieren eines Nullzeigers </li><li>  Ganzzahl√ºberlauf mit Vorzeichen </li></ul><br>  Das Ergebnis von <i>UB</i> h√§ngt von allem in einer Reihe ab - sowohl von der Compiler-Version als auch vom Wetter auf dem Mars.  Dar√ºber hinaus kann dieses Ergebnis alles sein: ein Kompilierungsfehler und eine korrekte Ausf√ºhrung sowie ein Absturz.  Unbestimmtes Verhalten ist b√∂se, es ist notwendig, es loszuwerden. <br><br>  Undefiniertes Verhalten sollte dagegen nicht mit <i>nicht spezifiziertem Verhalten</i> verwechselt <i>werden</i> .  Nicht angegebenes Verhalten ist das korrekte Verhalten des richtigen Programms, das jedoch mit Genehmigung des Standards vom Compiler abh√§ngt.  Und der Compiler muss es nicht dokumentieren.  Dies ist beispielsweise die Reihenfolge, in der die Argumente einer Funktion ausgewertet werden, oder die Implementierungsdetails von <code>std::map</code> . <br><br>  Nun, hier k√∂nnen Sie sich an das implementierungsdefinierte Verhalten erinnern.  Von nicht spezifizierten unterscheidet sich in der Verf√ºgbarkeit der Dokumentation.  Beispiel: Der Compiler kann den Typ <code>std::size_t</code> beliebig gro√ü machen, muss jedoch angeben, welcher. <br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins (russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei (englisch)</a> <br><br><h2>  Die Feinheiten der Zunge <a name="Cobwebs"></a></h2><br><h3>  ADL <a name="ADL"></a></h3><br>  <i>Argumentabh√§ngige Suche.</i>  <i>Argumentabh√§ngige Suche.</i>  Er ist die Suche nach Koenig - zu Ehren von Andrew Koenig.  Dies ist ein Satz von Regeln zum Aufl√∂sen nicht qualifizierter Funktionsnamen (d. H. Namen ohne den Operator <code>::</code> :) zus√§tzlich zur √ºblichen Namensaufl√∂sung.  Einfach ausgedr√ºckt: Der Name einer Funktion wird in Namespaces nachgeschlagen, die sich auf ihre Argumente beziehen (dies ist der Bereich, der den Typ des Arguments, den Typ selbst, wenn es sich um eine Klasse handelt, alle ihre Vorfahren usw. enth√§lt). <br><br><div class="spoiler">  <b class="spoiler_title">Einfachstes Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; namespace N { struct S {}; void f(S) { std::cout &lt;&lt; "f(S)" &lt;&lt; std::endl; }; } int main() { N::S s; f(s); }</span></span></span></span></code> </pre> <br>  Die Funktion <code>f</code> im Namespace <code>N</code> nur gefunden, weil ihr Argument zu diesem Raum geh√∂rt. <br></div></div><br>  Auch der triviale <code>std::cout &lt;&lt; "Hello World!\n"</code> verwendet <i>ADL</i> , <code>std::basic_stream::operator&lt;&lt;</code> f√ºr <code>const char*</code> nicht √ºberladen ist.  Das erste Argument f√ºr diese Anweisung ist jedoch <code>std::basic_stream</code> , und der Compiler sucht und findet eine geeignete √úberladung im <code>std</code> . <br><br>  Einige Details: <i>ADL ist</i> nicht anwendbar, wenn bei einer regul√§ren Suche eine Deklaration eines Klassenmitglieds oder eine Funktionsdeklaration im aktuellen Block ohne Verwendung <code>using</code> oder eine Deklaration weder einer Funktion noch einer Funktionsvorlage gefunden wurde.  Oder wenn der Funktionsname in Klammern angegeben ist (das obige Beispiel l√§sst sich nicht mit <code>(f)(s)</code> kompilieren; Sie m√ºssen <code>(N::f)(s);</code> schreiben <code>(N::f)(s);</code> ). <br><br>  Manchmal zwingt <i>ADL</i> Sie, vollst√§ndig qualifizierte Funktionsnamen zu verwenden, wenn dies unn√∂tig erscheint. <br><br><div class="spoiler">  <b class="spoiler_title">Beispielsweise wird dieser Code nicht kompiliert</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> N1 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S)</span></span></span><span class="hljs-function"> </span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> N2 { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N1::S)</span></span></span><span class="hljs-function"> </span></span>{}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N1::S s)</span></span></span><span class="hljs-function"> </span></span>{ foo(s); } }</code> </pre> <br></div></div><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins (Englisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei (Englisch)</a> <br><br><h3>  CRTP <a name="CRTP"></a></h3><br>  <i>Seltsamerweise wiederkehrendes Vorlagenmuster.</i>  <i>Seltsames rekursives Muster.</i>  Das Wesentliche der Vorlage ist wie folgt: <br><br><ul><li>  Einige Klassen erben von der Vorlagenklasse </li><li>  Die untergeordnete Klasse wird als Vorlagenparameter ihrer Basisklasse verwendet </li></ul><br>  Es ist einfacher, ein Beispiel zu geben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived&gt; {};</code> </pre> <br>  <i>CRTP</i> ist ein Paradebeispiel f√ºr statischen Polymorphismus.  Die Basisklasse stellt eine Schnittstelle bereit, die abgeleiteten Klassen stellen eine Implementierung bereit.  Im Gegensatz zum normalen Polymorphismus gibt es jedoch keinen Aufwand f√ºr das Erstellen und Verwenden einer Tabelle mit virtuellen Funktionen. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;actionImpl(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">staticPolymorphicHandler</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arg</span></span></span><span class="hljs-class">) {</span></span> arg.action(); }</code> </pre> <br>  Bei korrekter Verwendung ist <code>T</code> immer ein Nachkomme von <code>Base</code> , daher reicht <code>static_cast</code> zum <code>static_cast</code> .  Ja, in diesem Fall kennt die Basisklasse die untergeordnete Schnittstelle. <br></div></div><br>  Ein weiterer h√§ufiger Anwendungsbereich f√ºr <i>CRTP</i> ist die Erweiterung (oder <i>Einschr√§nkung</i> ) der Funktionalit√§t <i>geerbter</i> Klassen (in einigen Sprachen als Mixin bezeichnet).  Vielleicht die bekanntesten Beispiele: <br><br><ul><li> <code>struct Derived : singleton&lt;Derived&gt; { ‚Ä¶ }</code> </li> <li> <code>struct Derived : private boost::noncopyable&lt;Derived&gt; { ‚Ä¶ }</code> </li> <li> <code>struct Derived : std::enable_shared_from_this&lt;Derived&gt; { ‚Ä¶ }</code> </li> <li>  <code>struct Derived : counter&lt;Derived&gt; { ‚Ä¶ }</code> - Z√§hlt die Anzahl der erstellten und / oder vorhandenen Objekte </li></ul><br>  Nachteile bzw. Momente, die Aufmerksamkeit erfordern: <br><br><ul><li>  Es gibt keine gemeinsame Basisklasse. Sie k√∂nnen keine Sammlung verschiedener Nachkommen erstellen und √ºber einen Zeiger auf den Basistyp darauf zugreifen.  Wenn Sie m√∂chten, k√∂nnen Sie Base vom √ºblichen polymorphen Typ erben. </li><li>  Es gibt eine zus√§tzliche M√∂glichkeit, Ihren Fu√ü aus Unachtsamkeit heraus zu schie√üen: <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived1</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived1&gt; {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived2</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived1&gt; {};</code> </pre> <br>  Sie k√∂nnen jedoch zus√§tzlichen Schutz hinzuf√ºgen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Base() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> T;</code> </pre> </div></div></li><li>  Weil  Da alle Methoden nicht virtuell sind, verbergen die Methoden des Nachkommens Methoden der Basisklasse mit denselben Namen.  Daher ist es besser, sie anders zu nennen. </li><li>  Im Allgemeinen verf√ºgen Nachkommen √ºber √∂ffentliche Methoden, die nur in der Basisklasse verwendet werden sollten.  Dies ist nicht gut, wird aber durch eine zus√§tzliche Abstraktionsebene korrigiert (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FTSE</a> ). </li></ul><br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einmal (Russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  CTAD <a name="CTAD"></a></h3><br>  <i>Abzug von Klassenvorlagenargumenten.</i>  <i>Automatisches Ableiten des Typs des Klassenvorlagenparameters.</i>  Dies ist eine neue Funktion aus C ++ 17.  Bisher wurden nur Variablentypen ( <code>auto</code> ) und Funktionsvorlagenparameter automatisch angezeigt, weshalb Hilfsfunktionen wie <code>std::make_pair</code> , <code>std::make_tuple</code> usw. <code>std::make_tuple</code> . Jetzt werden sie zum gr√∂√üten Teil nicht mehr ben√∂tigt, da der Compiler k√∂nnen die Parameter von Klassenvorlagen automatisch anzeigen: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// -&gt; std::pair&lt;int, double&gt; auto lck = std::lock_guard{mtx}; // -&gt; std::lock_guard&lt;std::mutex&gt;</span></span></code> </pre> <br>  <i>CTAD</i> ist eine neue M√∂glichkeit, die noch weiterentwickelt werden muss (C ++ 20 verspricht bereits Verbesserungen).  In der Zwischenzeit gelten folgende Einschr√§nkungen: <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">Eine teilweise Inferenz von Parametertypen wird nicht unterst√ºtzt</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  std::tuple&lt;&gt; t{1, 2, 3}; // </span></span></code> </pre></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Vorlagen-Aliase werden nicht unterst√ºtzt</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPair</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:pair&lt;T, U&gt;; MyPair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Konstruktoren, die nur in Vorlagenspezialisierungen verf√ºgbar sind, werden nicht unterst√ºtzt.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-class">&lt;int&gt; {</span></span> Wrapper(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) {}; }; Wrapper w{<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Verschachtelte Vorlagen werden nicht unterst√ºtzt</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> {</span></span> Bar(T, U) {}; }; }; Foo::Bar x{ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Foo&lt;int&gt;::Bar x{1, 2.0}; // OK</span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Offensichtlich funktioniert CTAD nicht, wenn der Typ des Vorlagenparameters nicht mit den Konstruktorargumenten zusammenh√§ngt.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> Collection(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) {}; }; Collection c{<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li></ul><br>  In einigen F√§llen helfen explizite Inferenzregeln, die im selben Block wie die Klassenvorlage deklariert werden sollen. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class">) {</span></span>}; }; Collection c{v.begin(), v.end()}; <span class="hljs-comment"><span class="hljs-comment">//  template &lt;class It&gt; Collection(It, It)-&gt;Collection&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;; Collection c{v.begin(), v.end()}; //  OK</span></span></code> </pre> </div></div><br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einmal (Russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  EBO <a name="EBO"></a></h3><br>  <i>Leere Basisoptimierung.</i>  <i>Optimierung einer leeren Basisklasse.</i>  Wird auch als EBCO (Empty Base Class Optimization) bezeichnet. <br><br>  Wie Sie wissen, kann in C ++ die Gr√∂√üe eines Objekts einer Klasse nicht Null sein.  Andernfalls wird die gesamte Arithmetik der Zeiger unterbrochen, da an einer Adresse so viele verschiedene Objekte markiert werden k√∂nnen, wie Sie m√∂chten.  Daher haben selbst Objekte leerer Klassen (d. H. Klassen ohne ein einzelnes nicht statisches Feld) eine Gr√∂√üe ungleich Null, die vom Compiler und vom Betriebssystem abh√§ngt und normalerweise gleich 1 ist. <br><br>  Somit wird Speicher f√ºr alle Objekte leerer Klassen vergeblich verschwendet.  Aber nicht die Objekte ihrer Nachkommen, denn in diesem Fall macht der Standard ausdr√ºcklich eine Ausnahme.  Der Compiler darf keinen Speicher f√ºr eine leere Basisklasse reservieren und somit nicht nur 1 Byte der leeren Klasse, sondern alle 4 (je nach Plattform) speichern, da auch eine Ausrichtung vorliegt. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 4 std::cout &lt;&lt; sizeof(int) &lt;&lt; std::endl; // 4</span></span></code> </pre> </div></div><br>  Da <i>jedoch</i> verschiedene Objekte desselben Typs nicht an derselben Adresse platziert werden k√∂nnen, funktioniert das <i>EBO</i> nicht, wenn: <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">Eine leere Klasse wird zweimal unter Vorfahren gefunden</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty2</span></span></span><span class="hljs-class"> :</span></span> Empty {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty, Empty2 { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Empty2) &lt;&lt; std::endl; // 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 8</span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Das erste nicht statische Feld ist ein Objekt derselben leeren Klasse oder ihres Nachkommens</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty { Empty e; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 8</span></span></code> </pre> </div></div></li></ul><br>  In F√§llen, in denen Objekte leerer Klassen nicht statische Felder sind, werden keine Optimierungen bereitgestellt (das Attribut <code>[[no_unique_address]]</code> wird <code>[[no_unique_address]]</code> in C ++ 20 <code>[[no_unique_address]]</code> ).  Es ist jedoch eine Schande, 4 Bytes (oder wie viel der Compiler ben√∂tigt) f√ºr jedes dieser Felder auszugeben, sodass Sie Objekte leerer Klassen mit dem ersten nicht leeren nicht statischen Feld selbst "reduzieren" k√∂nnen. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty1</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty2</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Member</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyOptimization</span></span></span><span class="hljs-class"> :</span></span> Empty ... { Member member; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> EmptyOptimization&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Empty1, Empty2&gt; data; };</code> </pre> <br>  Seltsam, aber in diesem Fall ist die Gr√∂√üe von Foo f√ºr verschiedene Compiler unterschiedlich, f√ºr MSVC 2019 ist es 8, f√ºr GCC 8.3.0 ist es 4. In jedem Fall hat das Erh√∂hen der Anzahl leerer Klassen keinen Einfluss auf die Gr√∂√üe von <code>Foo</code> . </div></div><br>  Lesen Sie mehr: einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Englisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  IIFE <a name="IIFE"></a></h3><br>  <i>Sofort aufgerufener Funktionsausdruck.</i>  <i>Funktionsausdruck sofort aufgerufen.</i>  Im Allgemeinen ist dies eine Redewendung in JavaScript, von der Jason Turner sie zusammen mit dem Namen ausgeliehen hat.  Tats√§chlich wird nur ein Lambda erstellt und sofort aufgerufen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> myVar = [&amp;] { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition1()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> computeSomeComplexStuff(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> condition2() ? computeSonethingElse() : DEFAULT_VALUE; } ();</code> </pre> <br>  Warum ist das notwendig?  Nun, zum Beispiel wie im obigen Code, um eine Konstante durch das Ergebnis einer nichttrivialen Berechnung zu initialisieren und den Bereich nicht mit unn√∂tigen Variablen und Funktionen zu verstopfen. <br><br>  Lesen Sie mehr: einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Englisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  NVI <a name="NVI"></a></h3><br>  <i>Nicht virtuelle Schnittstelle.</i>  <i>Nicht virtuelle Schnittstelle.</i>  Nach dieser Redewendung sollte eine offene Klassenschnittstelle keine virtuellen Funktionen enthalten.  Alle virtuellen Funktionen werden privat gemacht (maximal gesch√ºtzt) und in offenen nicht virtuellen Funktionen aufgerufen. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Base() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// check precondition fooImpl(); // check postconditions } private: virtual void fooImpl() = 0; }; class Derived : public Base { private: void fooImpl() override { } };</span></span></code> </pre> </div></div><br>  Warum ist das notwendig: <br><br><ul><li>  Jede offene virtuelle Funktion f√ºhrt zwei Dinge aus: Sie definiert die √∂ffentliche Schnittstelle der Klasse und beteiligt sich am √ºbergeordneten Verhalten in untergeordneten Klassen.  Die Verwendung von <i>NVI</i> eliminiert solche Funktionen bei doppelter Belastung: Die Schnittstelle wird durch einige Funktionen definiert, Verhaltens√§nderungen durch andere.  Sie k√∂nnen beide unabh√§ngig voneinander √§ndern. </li><li>  Wenn f√ºr alle Optionen zur Implementierung einer virtuellen Funktion (Vor- und Nachpr√ºfungen, Mutex-Erfassung usw.) einige allgemeine Anforderungen gelten, ist es sehr praktisch, diese an einem Ort (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DRY</a> ) - in der Basisklasse - zu sammeln und zu verhindern, dass die Erben √ºberschreiben  .  Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es stellt sich ein Sonderfall der Mustervorlagenmethode heraus. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Geb√ºhr f√ºr die Verwendung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine gewisse Schwellung des Codes, eine m√∂gliche Leistungsminderung (aufgrund eines zus√§tzlichen Methodenaufrufs) und eine erh√∂hte Anf√§lligkeit f√ºr das Problem einer fragilen Basisklasse (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: einmal </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Englisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei (Englisch)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RVO und NRVO </font></font><a name="RVO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Benannt) R√ºckgabewertoptimierung. Optimierung des (benannten) R√ºckgabewerts.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist ein Sonderfall der vom Standard zugelassenen Kopierentfernung. Der Compiler kann unn√∂tige Kopien tempor√§rer Objekte weglassen, selbst wenn ihre Konstruktoren und Destruktoren offensichtliche Nebenwirkungen haben. Eine solche Optimierung ist zul√§ssig, wenn die Funktion ein Objekt nach Wert zur√ºckgibt (die beiden anderen zul√§ssigen F√§lle der Kopierentfernung sind das Ausl√∂sen und Abfangen von Ausnahmen).</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Foo(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = bar(); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> w√ºrde hier ein tempor√§res Objekt </font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Funktion </font><font style="vertical-align: inherit;">erstellt </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dann w√ºrde √ºber den Kopierkonstruktor ein weiteres tempor√§res Objekt in der Funktion daraus erstellt </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(um das Ergebnis zu erhalten </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), und erst dann w√ºrde das Objekt erstellt </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und der Wert des zweiten tempor√§ren Objekts ihm zugewiesen. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beseitigt all diese Kopierungen und Zuweisungen, und die Funktion </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird direkt erstellt </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies geschieht folgenderma√üen: Eine Funktion </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weist einem Objekt in seinem Stapelrahmen einen Platz zu </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Eine Funktion </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(die bereits in ihrem Frame arbeitet) erh√§lt Zugriff auf diesen im vorherigen Frame zugewiesenen Speicher und erstellt dort das gew√ºnschte Objekt. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unterscheidet sich von</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºhrt dieselbe Optimierung durch, jedoch nicht, wenn das Objekt im Ausdruck erstellt wird </font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sondern wenn das zuvor in der Funktion erstellte Objekt zur√ºckgegeben wird.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz des scheinbar kleinen Unterschieds ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> viel schwieriger zu implementieren und funktioniert daher in vielen F√§llen nicht. </font><font style="vertical-align: inherit;">Wenn eine Funktion beispielsweise ein globales Objekt oder eines ihrer Argumente zur√ºckgibt oder wenn eine Funktion mehrere Austrittspunkte hat und unterschiedliche Objekte √ºber diese zur√ºckgegeben werden, wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht </font><i><font style="vertical-align: inherit;">angewendet</font></i><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO funktioniert hier nicht</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> condition)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) { Foo f1; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f1; } Foo f2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f2; }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast alle Compiler unterst√ºtzen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seit langem </font><font style="vertical-align: inherit;">. Der Grad der Unterst√ºtzung f√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann von Compiler zu Compiler und von Version zu Version variieren. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind nur Optimierungen. Und obwohl das Kopieren des Konstruktors und des Zuweisungsoperators nicht aufgerufen wird, sollten sie in der Klasse des Objekts liegen. Die Regeln haben sich in C ++ 17 etwas ge√§ndert: Jetzt wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht als Kopierelision betrachtet, es ist obligatorisch geworden und der entsprechende Konstruktor und Zuweisungsoperator werden nicht ben√∂tigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(N) RVO ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in konstanter Form ein schl√ºpfriges Thema. Bis einschlie√ülich C ++ 14 wurde nichts dar√ºber gesagt, C ++ 17 erfordert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in solchen Ausdr√ºcken, und das kommende C ++ 20 - verbietet.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein paar Worte zum Zusammenhang mit der Semantik der Verschiebung. </font><font style="vertical-align: inherit;">Erstens ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(N) RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> noch effektiver, weil </font><font style="vertical-align: inherit;">Der Verschiebungskonstruktor und der Destruktor m√ºssen nicht aufgerufen werden. </font><font style="vertical-align: inherit;">Zweitens, wenn </font><i><font style="vertical-align: inherit;">NRVO</font></i><font style="vertical-align: inherit;"> nicht </font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von derselben Funktion zur√ºckkehrt </font></font><code>std::move(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert es</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> garantiert nicht. </font><font style="vertical-align: inherit;">Um Standard zu paraphrasieren: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gilt f√ºr prvalue, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO gilt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr lvalue, a </font></font><code>std::move(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist xvalue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eins (Englisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei (Englisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drei (Englisch)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SFINAE </font></font><a name="SFINAE"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Substitutionsfehler ist kein Fehler. </font><font style="vertical-align: inherit;">Fehlgeschlagene Substitution ist kein Fehler. </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Funktion des Instanziierungsprozesses von Vorlagen - Funktionen und Klassen - in C ++. </font><font style="vertical-align: inherit;">Wenn eine bestimmte Vorlage nicht instanziiert werden kann, wird dies unter dem Strich nicht als Fehler angesehen, wenn andere Optionen vorhanden sind. </font><font style="vertical-align: inherit;">Ein vereinfachter Algorithmus zur Auswahl der am besten geeigneten Funktions√ºberladung funktioniert beispielsweise folgenderma√üen:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Name der Funktion wird aufgel√∂st - der Compiler sucht in allen betrachteten Namespaces nach allen Funktionen mit dem angegebenen Namen (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unangemessene Funktionen werden verworfen - nicht die Anzahl der Argumente, es ist keine Konvertierung von Argumenttypen erforderlich, es war nicht m√∂glich, Typen f√ºr die Funktionsvorlage abzuleiten usw. </font></font></li><li>          (viable functions),          .           ‚Äî     . </li></ol><br>   <i>SFINAE</i>    :      ,        ,      ,    (  ).    . <br><br> <i>SFINAE</i>     , ,           .       -  , . . ,        . <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; template &lt;class, class = void&gt; struct HasToString : std::false_type {}; //    ,      //   -    ,  //     ‚Äî  ,    ,   template &lt;class T&gt; struct HasToString&lt;T, std::void_t&lt;decltype(&amp;T::toString)&gt;&gt; : std::is_same&lt;std::string, decltype(std::declval&lt;T&gt;().toString())&gt; {}; struct Foo { std::string toString() { return {}; } }; int main() { std::cout &lt;&lt; HasToString&lt;Foo&gt;::value &lt;&lt; std::endl; // 1 std::cout &lt;&lt; HasToString&lt;int&gt;::value &lt;&lt; std::endl; // 0 }</span></span></span></span></code> </pre> </div></div><br>   C++17 <code>static if</code>      <i>SFINAE</i> ,    C++20        .  Mal sehen. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eins (Russisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei (Englisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drei (Englisch)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SBO, SOO, SSO </font></font><a name="SBO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimierung f√ºr kleine Puffer / Objekte / Zeichenfolgen. Optimierung kleiner Puffer / Objekte / Zeilen.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manchmal wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Sinne der Small Size Optimization verwendet, aber sehr selten. Wir gehen daher davon aus, dass es bei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um Zeichenfolgen geht. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind einfach Synonyme, und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der bekannteste Sonderfall. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Datenstrukturen, die dynamischen Speicher verwenden, nehmen sicherlich auch einen Platz auf dem Stapel ein. Zumindest um einen Zeiger auf einen Haufen zu speichern. Das Wesentliche dieser Optimierungen ist nicht, Speicher vom Heap f√ºr relativ kleine Objekte anzufordern (was relativ teuer ist), sondern sie in den bereits zugewiesenen Stapelspeicherplatz zu legen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel k√∂nnte std :: string folgenderma√üen implementiert werden:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* begin_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> capacity_; };</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Gr√∂√üe dieser Klasse erhalte ich 24 Bytes (abh√§ngig vom Compiler und der Plattform). </font></font> Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichenfolgen, die nicht l√§nger als 24 Zeichen sind, k√∂nnen auf dem Stapel platziert werden. </font><font style="vertical-align: inherit;">Eigentlich nat√ºrlich erst um 24, da man irgendwie zwischen Platzierung auf dem Stapel und auf dem Haufen unterscheiden muss. </font><font style="vertical-align: inherit;">Aber hier ist der einfachste Weg f√ºr kurze Zeilen mit bis zu 8 Zeichen (gleiche Gr√∂√üe - 24 Byte):</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> Buffer { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* begin_; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> local_[<span class="hljs-number"><span class="hljs-number">8</span></span>]; }; Buffer buffer_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _size; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _capacity; };</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neben dem Fehlen von Zuordnungen auf dem Heap gibt es einen weiteren Vorteil - einen hohen Grad an Datenlokalit√§t. </font><font style="vertical-align: inherit;">Ein Array oder Vektor solcher optimierten Objekte belegt tats√§chlich nur einen kontinuierlichen Speicherplatz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast alle Implementierungen </font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwenden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und zumindest einige Implementierungen </font></font><code>std::function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es wird jedoch </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">niemals auf diese Weise optimiert, da der Standard verlangt, dass </font></font><code>std::swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr zwei Vektoren kein Kopieren oder Zuweisen ihrer Elemente verursacht wird und dass alle g√ºltigen Iteratoren g√ºltig bleiben. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird es nicht erlauben, diese Anforderungen zu erf√ºllen (denn </font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie sind es nicht). </font><font style="vertical-align: inherit;">Aber </font></font><code>boost::container::small_vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wie Sie sich vorstellen k√∂nnen, wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit (Englisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UDPATE </font></font><a name="Update"></a></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank an </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyerK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr diese zus√§tzliche Liste von Abk√ºrzungen.</font></font><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lebenslauf </font></font><a name="CV"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualifikanten wie const und volatile. </font></font></i> <code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet, dass das Objekt / die Variable nicht ge√§ndert werden kann. Ein Versuch, dies zu tun, f√ºhrt entweder zu einem Fehler zur Kompilierungszeit oder zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur Laufzeit. </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet, dass sich das Objekt / die Variable unabh√§ngig von den Aktionen des Programms √§ndern kann (z. B. schreiben einige Mikrocontroller-F√ºllungen etwas in den Speicher), und der Compiler sollte den Zugriff darauf nicht optimieren. </font><font style="vertical-align: inherit;">Der Zugriff auf ein </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekt, das nicht √ºber einen </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link oder Zeiger erfolgt, f√ºhrt ebenfalls zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eins (russisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei (englisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drei (russisch)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LTO </font></font><a name="LTO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindungszeitoptimierung. </font><font style="vertical-align: inherit;">Linkoptimierung. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie der Name schon sagt, erfolgt diese Optimierung w√§hrend der Verkn√ºpfung, d. H. Nach der Kompilierung. </font><font style="vertical-align: inherit;">Der Linker kann etwas tun, was der Compiler nicht gewagt hat: einige Funktionen inline zu machen, nicht verwendeten Code und Daten wegzuwerfen. </font><font style="vertical-align: inherit;">Erh√∂ht nat√ºrlich die Verbindungszeit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiterlesen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit (Englisch)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PCH </font></font><a name="PCH"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorkompilierte Header. </font><font style="vertical-align: inherit;">Vorkompilierte Header. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oft verwendete, aber selten ge√§nderte Header-Dateien werden einmal kompiliert und im internen Compiler-Format gespeichert. </font><font style="vertical-align: inherit;">Der Zusammenbau des Projekts dauert daher weniger, manchmal sogar viel weniger. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit (rus.)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pgo </font></font><a name="PGO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profilgesteuerte Optimierung. </font><font style="vertical-align: inherit;">Optimierung basierend auf Profilerstellungsergebnissen. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist eine Programmoptimierungsmethode, jedoch nicht durch statische Code-Analyse, sondern durch Start des Testprogramms und Sammeln realer Statistiken. </font><font style="vertical-align: inherit;">Beispielsweise kann das Verzweigen und Aufrufen virtueller Funktionen auf diese Weise optimiert werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit (rus.)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seh / veh </font></font><a name="SEH"></a></h3><br> <i>Structured/Vectored Exception Handling.</i>   MSVC     .     <code>try-catch</code> <i>SEH</i>     : <code>__try</code> , <code>__except</code> , <code>__finally</code> ,       ,   ,     ,   -  ,      . . <i>VEH</i>     ,      . <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> (.)</a> <br><br><h3> TMP <a name="TMP"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template Meta-Programmierung. </font><font style="vertical-align: inherit;">Vorlagen-Metaprogrammierung. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metaprogrammierung ist, wenn ein Programm aufgrund seiner Arbeit ein anderes erstellt. </font><font style="vertical-align: inherit;">Vorlagen in C ++ implementieren eine solche Metaprogrammierung. </font><font style="vertical-align: inherit;">Der Vorlagen-Compiler generiert die erforderliche Anzahl von Klassen oder Funktionen. </font><font style="vertical-align: inherit;">Es ist bekannt, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in C ++ Turing-vollst√§ndig ist, d. H. Jede Funktion kann darauf implementiert werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit (rus.)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vla </font></font><a name="VLA"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays mit variabler L√§nge. </font><font style="vertical-align: inherit;">Arrays variabler L√§nge.</font></font></i>  Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arrays, deren L√§nge zur Kompilierungszeit unbekannt ist: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[n]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der C ++ - Standard erlaubt dies nicht. </font><font style="vertical-align: inherit;">Was etwas seltsam ist, da sie seit dem C99-Standard in reinem C existieren. </font><font style="vertical-align: inherit;">Und werden von einigen C ++ - Compilern als Erweiterung unterst√ºtzt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit (rus.)</font></font></a> <br><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ich etwas verpasst habe oder mich irgendwo geirrt habe - schreibe in die Kommentare. </font><font style="vertical-align: inherit;">Denken Sie bitte daran, dass hier nur Abk√ºrzungen aufgef√ºhrt sind, die in direktem Zusammenhang mit C ++ stehen. </font><font style="vertical-align: inherit;">F√ºr andere, aber nicht weniger n√ºtzlich, wird es einen separaten Beitrag geben. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweiter Teil</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470265/">https://habr.com/ru/post/de470265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470247/index.html">RESHI.RU - ein Roboter l√∂st und erkl√§rt Schultextprobleme in der Mathematik</a></li>
<li><a href="../de470251/index.html">Wie ich eine Desktop-Anwendung auf Flutter gemacht habe (+ Bonus)</a></li>
<li><a href="../de470255/index.html">Optimierung des Anleihenportfolios mit ALGLIB</a></li>
<li><a href="../de470257/index.html">Umh√ºllen Sie ImmutableList in Java</a></li>
<li><a href="../de470259/index.html">Aimybox bei der Suche: Das Framework zum Erstellen von Sprachassistenten ben√∂tigt einen iOS-Assistenten</a></li>
<li><a href="../de470269/index.html">ReactOS 0.4.12: Âçé‰∏∫ Ôºå ‰Ω† ËÆ§‰∏∫ ËÆ§‰∏∫ ÊÄé‰πà Ê†∑Ôºü</a></li>
<li><a href="../de470271/index.html">F # 6: Tupel</a></li>
<li><a href="../de470273/index.html">F # 7: Aufzeichnungen</a></li>
<li><a href="../de470275/index.html">F # 8: Diskriminierte Gewerkschaften</a></li>
<li><a href="../de470277/index.html">Wie ist das globale Netzwerk in der Russischen F√∂deration organisiert und organisiert?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>