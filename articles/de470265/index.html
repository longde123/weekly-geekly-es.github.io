<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏿 👩‍👩‍👧‍👧 🤾🏾 C ++ Abkürzung Spickzettel und mehr. Teil 1: C ++ 🦄 🧒🏿 📫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einmal wurde ich für die Position eines C ++ - Entwicklers in einem anständigen und sogar bekannten Büro interviewt. Ich hatte damals schon einige Erf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ Abkürzung Spickzettel und mehr. Teil 1: C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470265/">  Einmal wurde ich für die Position eines C ++ - Entwicklers in einem anständigen und sogar bekannten Büro interviewt.  Ich hatte damals schon einige Erfahrungen, damals wurde ich sogar als führender Entwickler bei meinem Arbeitgeber bezeichnet.  Aber als ich gefragt wurde, ob ich solche Dinge wie DRY, KISS, YAGNI, NIH wüsste, musste ich immer wieder mit „Nein“ antworten. <br><br>  Ich habe natürlich kläglich versagt.  Aber dann wurden die obigen Abkürzungen gegoogelt und erinnert.  Während ich thematische Artikel und Bücher las, mich auf Interviews vorbereitete und nur mit Kollegen sprach, lernte ich mehr Neues, vergaß sie, googelte erneut und verstand.  Vor ein paar Monaten erwähnte einer meiner Kollegen beiläufig im IIFE-Arbeitschat im Kontext von C ++.  Wie dieser Großvater in einem Witz fiel ich fast vom Herd und stieg wieder in Google ein. <br><br><img src="https://habrastorage.org/webt/i7/7u/fc/i77ufc8-ui3-rtrvpu-421lmpfq.png"><br><a name="habracut"></a><br>  Zu diesem Zeitpunkt habe ich beschlossen, (hauptsächlich für mich selbst) einen Spickzettel für Abkürzungen zu erstellen, die für einen C ++ - Entwickler nützlich sind.  Dies bedeutet nicht, dass sie nur für C ++ gelten oder dass es sich um All-All-All-Konzepte aus C ++ handelt (Sie können Bände über Sprachsprachen schreiben).  Nein, dies sind nur Konzepte, denen ich tatsächlich in Arbeiten und Interviews begegnet bin, normalerweise ausgedrückt in Form von Abkürzungen.  Nun, ich habe absolut triviale Dinge wie LIFO, FIFO, CRUD, OOP, GCC und MSVC verpasst. <br><br>  Trotzdem kamen die Abkürzungen anständig vor, so dass ich den Spickzettel in zwei Teile teilte: stark charakteristisch für C ++ und häufiger.  Wenn es angebracht war, habe ich die Konzepte zusammengefasst, ansonsten habe ich sie einfach alphabetisch aufgelistet.  Im Allgemeinen macht ihre Reihenfolge nicht viel Sinn. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegende Dinge:</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ODR</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POD</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POF</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PIMPL</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RAII</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTTI</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STL</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UB</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Feinheiten der Sprache:</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ADL</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRTP</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CTAD</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EBO</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IIFE</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NVI</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RVO und NRVO</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SFINAE</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SBO, SOO, SSO</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>UPDATE:</b></a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lebenslauf</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LTO</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PCH</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PGO</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SEH / VEH</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TMP</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VLA</a> <br><br><h2>  Grundlegende Dinge <a name="Basics"></a></h2><br><h3>  ODR <a name="ODR"></a></h3><br>  <i>Eine Definitionsregel.</i>  <i>Die Regel einer Definition.</i>  Vereinfacht bedeutet Folgendes: <br><br><ul><li>  Innerhalb einer einzelnen Übersetzungseinheit kann jede Variable, Funktion, Klasse usw. nicht mehr als eine Definition haben.  Es gibt so viele Anzeigen wie möglich (außer Übertragungen ohne einen bestimmten Basistyp, die einfach nicht ohne Definition deklariert werden können), aber nicht mehr als eine Definition.  Weniger möglich, wenn die Entität nicht verwendet wird. </li><li>  Während des gesamten Programms muss jede verwendete Nicht-Inline-Funktion und Variable genau eine Definition haben.  Jede verwendete Inline-Funktion und Variable muss in jeder Übersetzungseinheit eine Definition haben. </li><li>  Einige Entitäten - beispielsweise Klassen, Inline-Funktionen und eine Variable, Vorlagen, Aufzählungen usw. - können mehrere Definitionen in einem Programm haben (jedoch nicht mehr als eine in einer Übersetzungseinheit).  Tatsächlich geschieht dies, wenn derselbe Header, der beispielsweise eine vollständig implementierte Klasse enthält, mit mehreren CPP-Dateien verbunden ist.  Aber diese Definitionen sollten übereinstimmen (ich vereinfache stark, aber das Wesentliche ist dies).  Sonst wird es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UB sein</a> . </li></ul><br>  Der Compiler erkennt leicht eine <i>ODR-</i> Verletzung innerhalb einer Übersetzungseinheit.  Er kann jedoch nichts tun, wenn die Regel auf Programmebene verletzt wird - schon allein deshalb, weil der Compiler jeweils eine Übersetzungseinheit verarbeitet. <br><br>  Der Linker kann viel mehr Verstöße feststellen, ist aber streng genommen nicht dazu verpflichtet (weil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UB</a> laut Standard hier ist) und kann etwas verpassen.  Darüber hinaus ist die Suche nach <i>ODR-</i> Verstößen in der Verknüpfungsphase quadratisch komplex, und die Zusammenstellung von C ++ - Code ist nicht so schnell. <br><br>  Infolgedessen liegt die Hauptverantwortung für die Einhaltung dieser Regel (insbesondere auf Programmebene) beim Entwickler selbst.  Und ja - nur Entitäten mit einem externen Link können <i>ODR</i> im Programmmaßstab verletzen.  diejenigen von innen (d. h. in anonymen Namespaces definiert) nehmen an diesem Karneval nicht teil. <br><br>  Lesen Sie mehr: einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Englisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  Pod <a name="POD"></a></h3><br>  <i>Einfache alte Daten.</i>  <i>Einfache Datenstruktur.</i>  Die einfachste Definition: Dies ist eine solche Struktur, die Sie in binärer Form an die C-Bibliothek senden / von dieser empfangen können.  Oder, das ist das gleiche, richtig mit einfachem <code>memcpy</code> kopieren. <br><br>  Von Standard zu Standard hat sich die vollständige Definition im Detail geändert.  Der neueste C ++ 17 <i>POD</i> definiert derzeit, wie <br><br><ul><li>  Skalartyp </li><li>  oder eine Klasse / Struktur / Vereinigung, die: <br>  - Es gibt eine triviale Klasse <br>  - Es gibt eine Klasse mit einem Standardgerät <br>  - enthält keine nicht statischen Nicht- <i>POD</i> -Felder <br></li><li>  oder ein Array dieser Typen </li></ul><br>  Trivialklasse: <br><br><ul><li>  hat mindestens eine nicht gelöscht: <br>  - Standardkonstruktor <br>  - Konstruktor kopieren <br>  - beweglicher Konstruktor <br>  - Zuweisungsoperator kopieren <br>  - Zuweisungsoperator verschieben <br></li><li>  Alle Standardkonstruktoren, die Konstruktoren und Zuweisungsoperatoren kopieren und verschieben, sind trivial (vereinfacht - vom Compiler generiert) oder remote </li><li>  hat einen trivialen nicht entfernten Destruktor </li><li>  Alle Basistypen und alle Felder von Klassentypen haben triviale Destruktoren </li><li>  keine virtuellen Methoden (einschließlich Destruktor) </li><li>  Keine virtuellen Basistypen </li></ul><br>  Klasse mit einem Standardgerät (Standardlayoutklasse): <br><br><ul><li>  keine virtuellen Methoden </li><li>  Keine virtuellen Basistypen </li><li>  Keine nicht statischen Linkfelder </li><li>  Alle nicht statischen Felder haben denselben Zugriffsmodifikator (öffentlich / geschützt / privat). </li><li>  Alle nicht statischen Felder und Basisklassen sind ebenfalls Typen mit einem Standardgerät </li><li>  Alle nicht statischen Felder der Klasse selbst und aller ihrer Vorfahren werden in einer einzigen Klasse deklariert (d. h. in der Klasse selbst oder in einem der Vorfahren). </li><li>  Es erbt nicht zweimal denselben Typ, d. H. Es ist unmöglich, dies zu tun: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> :</span></span> A{}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> B, C {};</code> </pre> </li><li>  Der Typ des ersten nicht statischen Felds oder, wenn es sich um ein Array handelt, der Typ seines Elements darf nicht mit einem der Grundtypen übereinstimmen (aufgrund des obligatorischen <i>EBO</i> in diesem Fall). </li></ul><br>  In C ++ 20 gibt es jedoch nicht mehr das Konzept des <i>POD-</i> Typs, sondern nur noch den trivialen Typ und den Typ mit dem Standardgerät. <br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins (Russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei (Englisch)</a> <br><br><h3>  POF <a name="POF"></a></h3><br>  <i>Einfache alte Funktion.</i>  <i>Eine einfache Funktion</i> im <i>C-Stil, die</i> im Standard vor C ++ 14 einschließlich nur im Zusammenhang mit Signalhandlern erwähnt wurde.  Die Voraussetzungen dafür sind: <br><br><ul><li>  verwendet nur Dinge, die C und C ++ gemeinsam haben (d. h. keine Ausnahmen und beispielsweise <code>try-catch</code> ) </li><li>  verursacht keine direkten oder indirekten Nicht- <i>POF-</i> Funktionen, mit Ausnahme von <code>std::atomic_init</code> Operationen ( <code>std::atomic_init</code> , <code>std::atomic_fetch_add</code> usw.) </li></ul><br>  Nur solche Funktionen, die auch eine C-Verbindung ( <code>extern "C"</code> ) haben, dürfen vom Standard als Signalhandler verwendet werden.  Die Unterstützung anderer Funktionen hängt vom Compiler ab. <br><br>  In C ++ 17 verschwindet das <i>POF-</i> Konzept, anstatt dass es als signal-sichere Auswertung erscheint.  In solchen Berechnungen sind verboten: <br><br><ul><li>  ruft alle Funktionen der Standardbibliothek auf, außer atomar, sperrfrei </li><li>  <code>new</code> und <code>delete</code> Anrufe </li><li>  mit <code>dynamic_cast</code> </li><li>  Aufruf der Entität <code>thread_local</code> </li><li>  jede Arbeit mit Ausnahmen </li><li>  Initialisierung einer lokalen statischen Variablen </li><li>  Warten auf den Abschluss der statischen Variableninitialisierung </li></ul><br>  Wenn der Signalhandler einen der oben genannten Schritte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausführt,</a> verspricht der Standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UB</a> . <br><br>  Weiterlesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeit (Englisch)</a> <br><br><h3>  PIMPL <a name="PIMPL"></a></h3><br>  <i>Zeiger auf die Implementierung.</i>  <i>Zeiger auf die Umsetzung.</i>  Die klassische Redewendung in C ++, auch bekannt als D-Zeiger, undurchsichtiger Zeiger, Kompilierungsfirewall.  Es besteht in der Tatsache, dass alle privaten Methoden, Felder und anderen Implementierungsdetails einer bestimmten Klasse einer separaten Klasse zugeordnet sind und nur öffentliche Methoden (d. H. Eine Schnittstelle) und ein Zeiger auf eine Instanz dieser neuen separaten Klasse in der ursprünglichen Klasse verbleiben.  Zum Beispiel: <br><br><div class="spoiler">  <b class="spoiler_title">foo.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Foo(); ~Foo(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doThis</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doThat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Impl&gt; pImpl_; };</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">foo.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"foo.hpp"</span></span></span><span class="hljs-meta"> class Foo::Impl { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// implementation }; Foo::Foo() : pImpl_(std::make_unique&lt;Impl&gt;()) {} Foo::~Foo() = default; void Foo::doThis() { pImpl_-&gt;doThis(); } int Foo::doThat() { return pImpl_-&gt;doThat(); }</span></span></span></span></code> </pre> <br></div></div><br>  Warum ist dies notwendig, d. H. Vorteile: <br><br><ul><li>  Kapselung: Benutzer der Klasse erhalten über die Header-Verbindung nur das, was sie benötigen - eine öffentliche Schnittstelle.  Wenn sich die Implementierungsdetails ändern, muss der Clientcode nicht neu kompiliert werden (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ABI</a> ). </li><li>  Kompilierungszeit: Da der öffentliche Header nichts über die Implementierung weiß, enthält er nicht die vielen benötigten Header.  Dementsprechend wird die Anzahl implizit verbundener Header im Clientcode reduziert.  Die Suche nach Namen und die Auflösung von Überladungen wird ebenfalls vereinfacht, da die öffentliche Überschrift keine privaten Mitglieder enthält (obwohl sie privat sind, nehmen sie an diesen Prozessen teil). </li></ul><br>  Preis, d. H. Nachteile: <br><br><ul><li>  Plus mindestens eine Zeiger-Dereferenzierung und plus ein Funktionsaufruf beim Zugriff auf öffentliche Methoden. </li><li>  Die Größe der benötigten Speicherklasse wird um die Größe des Zeigers erhöht. </li><li>  Ein Teil dieses Speichers (höchstwahrscheinlich größer) wird auf dem Heap zugewiesen, was sich auch negativ auf die Leistung auswirkt. </li><li>  Die logische Konstanz kann leicht verletzt werden.  Ein solcher Code wird beispielsweise kompiliert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Foo::doThis() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { pImpl_-&gt;doThis(); <span class="hljs-comment"><span class="hljs-comment">// cosnt method pImpl_-&gt;doSmthElse(); // non-const method }</span></span></code> </pre> </li></ul><br>  Einige dieser Mängel können behoben werden, aber der Preis verkompliziert den Code weiter und führt zusätzliche Abstraktionsebenen ein (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FTSE</a> ). <br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins (russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei (englisch)</a> <br><br><h3>  RAII <a name="RAII"></a></h3><br>  <i>Ressourcenbeschaffung ist Initialisierung.</i>  <i>Das Erfassen einer Ressource ist die Initialisierung.</i>  Die Bedeutung dieser Redewendung ist, dass die Beibehaltung einer bestimmten Ressource während der gesamten Lebensdauer des entsprechenden Objekts anhält.  Die Erfassung der Ressource erfolgt zum Zeitpunkt der Erstellung / Initialisierung des Objekts, der Freigabe - zum Zeitpunkt der Zerstörung / Finalisierung desselben Objekts. <br><br>  Seltsamerweise (hauptsächlich für C ++ - Programmierer) wird diese Redewendung auch in anderen Sprachen verwendet, selbst in Sprachen mit einem Garbage Collector.  In Java ist es <code>try--</code> , in Python die <code>with</code> Anweisung, in C # die <code>using</code> Direktive, in Go the <code>defer</code> .  Aber es ist in C ++ mit seiner absolut vorhersehbaren Lebensdauer von Objekten, in die <i>RAII</i> besonders organisch passt. <br><br>  In C ++ wird eine Ressource normalerweise im Konstruktor erfasst und im Destruktor freigegeben.  Beispielsweise steuern intelligente Zeiger den Speicher auf diese Weise, Dateistreams verwalten Dateien und Mutex sperrt Mutexe.  Das Schöne ist, dass unabhängig davon, wie der Block verlassen wird (Gültigkeitsbereich) - ob dies an einem der Austrittspunkte normal ist oder eine Ausnahme ausgelöst wurde - das in diesem Block erstellte Ressourcensteuerungsobjekt zerstört und die Ressource freigegeben wird.  Das heißt,  Neben der Kapselung von <i>RAII</i> in C ++ trägt es auch zur Gewährleistung der Sicherheit im Sinne von Ausnahmen bei. <br><br>  Einschränkungen, wo ohne sie.  Destruktoren in C ++ geben keine Werte zurück und sollten kategorisch keine Ausnahmen auslösen.  Wenn die Freigabe der Ressource von der einen oder anderen begleitet wird, ist es dementsprechend erforderlich, zusätzliche Logik im Destruktor des Steuerobjekts zu implementieren. <br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einmal (Russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  RTTI <a name="RTTI"></a></h3><br>  <i>Informationen zum Laufzeit-Typ.</i>  <i>Typidentifikation zur Laufzeit.</i>  Dies ist ein Mechanismus zum Abrufen von Informationen über den Typ eines Objekts oder Ausdrucks zur Laufzeit.  Es existiert in anderen Sprachen, aber in C ++ wird es verwendet für: <br><br><ul><li> <code>dynamic_cast</code> </li> <li>  <code>typeid</code> und <code>type_info</code> </li><li>  Ausnahme fangen </li></ul><br>  Eine wichtige Einschränkung: <i>RTTI</i> verwendet eine Tabelle mit virtuellen Funktionen und funktioniert daher nur für polymorphe Typen (ein virtueller Destruktor ist ausreichend).  Eine wichtige Erklärung: <code>dynamic_cast</code> und <code>typeid</code> verwenden nicht immer <i>RTTI</i> und funktionieren daher für nicht polymorphe Typen.  Um beispielsweise einen Link zu einem Nachkommen dynamisch in einen Link zu einem Vorfahren <i>umzuwandeln</i> , wird <i>RTTI</i> nicht benötigt, da alle Informationen zur Kompilierungszeit verfügbar sind. <br><br>  <i>RTTI ist</i> nicht kostenlos, wenn auch ein wenig, wirkt sich jedoch negativ auf die Leistung und Größe des verbrauchten Speichers aus (daher der häufige Rat, <code>dynamic_cast</code> wegen seiner Langsamkeit nicht zu verwenden).  Mit Compilern können Sie <i>RTTI</i> daher in der Regel deaktivieren.  GCC und MSVC versprechen, dass dies die Richtigkeit des Abfangens von Ausnahmen nicht beeinträchtigt. <br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einmal (Russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  STL <a name="STL"></a></h3><br>  <i>Standardvorlagenbibliothek.</i>  <i>Standardvorlagenbibliothek.</i>  Teil der C ++ - Standardbibliothek, die generische Container, Iteratoren, Algorithmen und Hilfsfunktionen bereitstellt. <br><br>  Trotz seines bekannten Namens wurde <i>STL</i> im Standard noch nie so genannt.  Aus den Abschnitten des Standards kann die <i>STL</i> eindeutig der Container-Bibliothek, der Iterator-Bibliothek, der Algorithmus-Bibliothek und teilweise der allgemeinen Dienstprogrammbibliothek zugeordnet werden. <br><br>  In Stellenbeschreibungen finden Sie häufig zwei separate Anforderungen - Kenntnisse in C ++ und Vertrautheit mit <i>STL</i> .  Ich habe das nie verstanden, weil <i>STL</i> seit dem ersten Standard von 1998 ein wesentlicher Bestandteil der Sprache ist. <br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einmal (Russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  UB <a name="UB"></a></h3><br>  <i>Undefiniertes Verhalten.</i>  <i>Undefiniertes Verhalten.</i>  Dieses Verhalten tritt in den Fehlerfällen auf, für die der Standard keine Anforderungen stellt.  Viele davon sind im Standard explizit aufgeführt und führen zu <i>UB</i> .  Dazu gehören zum Beispiel: <br><br><ul><li>  Verletzung der Grenzen eines Arrays oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STL-</a> Containers </li><li>  Verwendung einer nicht initialisierten Variablen </li><li>  Dereferenzieren eines Nullzeigers </li><li>  Ganzzahlüberlauf mit Vorzeichen </li></ul><br>  Das Ergebnis von <i>UB</i> hängt von allem in einer Reihe ab - sowohl von der Compiler-Version als auch vom Wetter auf dem Mars.  Darüber hinaus kann dieses Ergebnis alles sein: ein Kompilierungsfehler und eine korrekte Ausführung sowie ein Absturz.  Unbestimmtes Verhalten ist böse, es ist notwendig, es loszuwerden. <br><br>  Undefiniertes Verhalten sollte dagegen nicht mit <i>nicht spezifiziertem Verhalten</i> verwechselt <i>werden</i> .  Nicht angegebenes Verhalten ist das korrekte Verhalten des richtigen Programms, das jedoch mit Genehmigung des Standards vom Compiler abhängt.  Und der Compiler muss es nicht dokumentieren.  Dies ist beispielsweise die Reihenfolge, in der die Argumente einer Funktion ausgewertet werden, oder die Implementierungsdetails von <code>std::map</code> . <br><br>  Nun, hier können Sie sich an das implementierungsdefinierte Verhalten erinnern.  Von nicht spezifizierten unterscheidet sich in der Verfügbarkeit der Dokumentation.  Beispiel: Der Compiler kann den Typ <code>std::size_t</code> beliebig groß machen, muss jedoch angeben, welcher. <br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins (russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei (englisch)</a> <br><br><h2>  Die Feinheiten der Zunge <a name="Cobwebs"></a></h2><br><h3>  ADL <a name="ADL"></a></h3><br>  <i>Argumentabhängige Suche.</i>  <i>Argumentabhängige Suche.</i>  Er ist die Suche nach Koenig - zu Ehren von Andrew Koenig.  Dies ist ein Satz von Regeln zum Auflösen nicht qualifizierter Funktionsnamen (d. H. Namen ohne den Operator <code>::</code> :) zusätzlich zur üblichen Namensauflösung.  Einfach ausgedrückt: Der Name einer Funktion wird in Namespaces nachgeschlagen, die sich auf ihre Argumente beziehen (dies ist der Bereich, der den Typ des Arguments, den Typ selbst, wenn es sich um eine Klasse handelt, alle ihre Vorfahren usw. enthält). <br><br><div class="spoiler">  <b class="spoiler_title">Einfachstes Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; namespace N { struct S {}; void f(S) { std::cout &lt;&lt; "f(S)" &lt;&lt; std::endl; }; } int main() { N::S s; f(s); }</span></span></span></span></code> </pre> <br>  Die Funktion <code>f</code> im Namespace <code>N</code> nur gefunden, weil ihr Argument zu diesem Raum gehört. <br></div></div><br>  Auch der triviale <code>std::cout &lt;&lt; "Hello World!\n"</code> verwendet <i>ADL</i> , <code>std::basic_stream::operator&lt;&lt;</code> für <code>const char*</code> nicht überladen ist.  Das erste Argument für diese Anweisung ist jedoch <code>std::basic_stream</code> , und der Compiler sucht und findet eine geeignete Überladung im <code>std</code> . <br><br>  Einige Details: <i>ADL ist</i> nicht anwendbar, wenn bei einer regulären Suche eine Deklaration eines Klassenmitglieds oder eine Funktionsdeklaration im aktuellen Block ohne Verwendung <code>using</code> oder eine Deklaration weder einer Funktion noch einer Funktionsvorlage gefunden wurde.  Oder wenn der Funktionsname in Klammern angegeben ist (das obige Beispiel lässt sich nicht mit <code>(f)(s)</code> kompilieren; Sie müssen <code>(N::f)(s);</code> schreiben <code>(N::f)(s);</code> ). <br><br>  Manchmal zwingt <i>ADL</i> Sie, vollständig qualifizierte Funktionsnamen zu verwenden, wenn dies unnötig erscheint. <br><br><div class="spoiler">  <b class="spoiler_title">Beispielsweise wird dieser Code nicht kompiliert</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> N1 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S)</span></span></span><span class="hljs-function"> </span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> N2 { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N1::S)</span></span></span><span class="hljs-function"> </span></span>{}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N1::S s)</span></span></span><span class="hljs-function"> </span></span>{ foo(s); } }</code> </pre> <br></div></div><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins (Englisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei (Englisch)</a> <br><br><h3>  CRTP <a name="CRTP"></a></h3><br>  <i>Seltsamerweise wiederkehrendes Vorlagenmuster.</i>  <i>Seltsames rekursives Muster.</i>  Das Wesentliche der Vorlage ist wie folgt: <br><br><ul><li>  Einige Klassen erben von der Vorlagenklasse </li><li>  Die untergeordnete Klasse wird als Vorlagenparameter ihrer Basisklasse verwendet </li></ul><br>  Es ist einfacher, ein Beispiel zu geben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived&gt; {};</code> </pre> <br>  <i>CRTP</i> ist ein Paradebeispiel für statischen Polymorphismus.  Die Basisklasse stellt eine Schnittstelle bereit, die abgeleiteten Klassen stellen eine Implementierung bereit.  Im Gegensatz zum normalen Polymorphismus gibt es jedoch keinen Aufwand für das Erstellen und Verwenden einer Tabelle mit virtuellen Funktionen. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;actionImpl(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">staticPolymorphicHandler</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arg</span></span></span><span class="hljs-class">) {</span></span> arg.action(); }</code> </pre> <br>  Bei korrekter Verwendung ist <code>T</code> immer ein Nachkomme von <code>Base</code> , daher reicht <code>static_cast</code> zum <code>static_cast</code> .  Ja, in diesem Fall kennt die Basisklasse die untergeordnete Schnittstelle. <br></div></div><br>  Ein weiterer häufiger Anwendungsbereich für <i>CRTP</i> ist die Erweiterung (oder <i>Einschränkung</i> ) der Funktionalität <i>geerbter</i> Klassen (in einigen Sprachen als Mixin bezeichnet).  Vielleicht die bekanntesten Beispiele: <br><br><ul><li> <code>struct Derived : singleton&lt;Derived&gt; { … }</code> </li> <li> <code>struct Derived : private boost::noncopyable&lt;Derived&gt; { … }</code> </li> <li> <code>struct Derived : std::enable_shared_from_this&lt;Derived&gt; { … }</code> </li> <li>  <code>struct Derived : counter&lt;Derived&gt; { … }</code> - Zählt die Anzahl der erstellten und / oder vorhandenen Objekte </li></ul><br>  Nachteile bzw. Momente, die Aufmerksamkeit erfordern: <br><br><ul><li>  Es gibt keine gemeinsame Basisklasse. Sie können keine Sammlung verschiedener Nachkommen erstellen und über einen Zeiger auf den Basistyp darauf zugreifen.  Wenn Sie möchten, können Sie Base vom üblichen polymorphen Typ erben. </li><li>  Es gibt eine zusätzliche Möglichkeit, Ihren Fuß aus Unachtsamkeit heraus zu schießen: <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived1</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived1&gt; {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived2</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived1&gt; {};</code> </pre> <br>  Sie können jedoch zusätzlichen Schutz hinzufügen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Base() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> T;</code> </pre> </div></div></li><li>  Weil  Da alle Methoden nicht virtuell sind, verbergen die Methoden des Nachkommens Methoden der Basisklasse mit denselben Namen.  Daher ist es besser, sie anders zu nennen. </li><li>  Im Allgemeinen verfügen Nachkommen über öffentliche Methoden, die nur in der Basisklasse verwendet werden sollten.  Dies ist nicht gut, wird aber durch eine zusätzliche Abstraktionsebene korrigiert (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FTSE</a> ). </li></ul><br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einmal (Russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  CTAD <a name="CTAD"></a></h3><br>  <i>Abzug von Klassenvorlagenargumenten.</i>  <i>Automatisches Ableiten des Typs des Klassenvorlagenparameters.</i>  Dies ist eine neue Funktion aus C ++ 17.  Bisher wurden nur Variablentypen ( <code>auto</code> ) und Funktionsvorlagenparameter automatisch angezeigt, weshalb Hilfsfunktionen wie <code>std::make_pair</code> , <code>std::make_tuple</code> usw. <code>std::make_tuple</code> . Jetzt werden sie zum größten Teil nicht mehr benötigt, da der Compiler können die Parameter von Klassenvorlagen automatisch anzeigen: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// -&gt; std::pair&lt;int, double&gt; auto lck = std::lock_guard{mtx}; // -&gt; std::lock_guard&lt;std::mutex&gt;</span></span></code> </pre> <br>  <i>CTAD</i> ist eine neue Möglichkeit, die noch weiterentwickelt werden muss (C ++ 20 verspricht bereits Verbesserungen).  In der Zwischenzeit gelten folgende Einschränkungen: <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">Eine teilweise Inferenz von Parametertypen wird nicht unterstützt</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  std::tuple&lt;&gt; t{1, 2, 3}; // </span></span></code> </pre></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Vorlagen-Aliase werden nicht unterstützt</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPair</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:pair&lt;T, U&gt;; MyPair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Konstruktoren, die nur in Vorlagenspezialisierungen verfügbar sind, werden nicht unterstützt.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-class">&lt;int&gt; {</span></span> Wrapper(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) {}; }; Wrapper w{<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Verschachtelte Vorlagen werden nicht unterstützt</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> {</span></span> Bar(T, U) {}; }; }; Foo::Bar x{ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Foo&lt;int&gt;::Bar x{1, 2.0}; // OK</span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Offensichtlich funktioniert CTAD nicht, wenn der Typ des Vorlagenparameters nicht mit den Konstruktorargumenten zusammenhängt.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> Collection(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) {}; }; Collection c{<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li></ul><br>  In einigen Fällen helfen explizite Inferenzregeln, die im selben Block wie die Klassenvorlage deklariert werden sollen. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class">) {</span></span>}; }; Collection c{v.begin(), v.end()}; <span class="hljs-comment"><span class="hljs-comment">//  template &lt;class It&gt; Collection(It, It)-&gt;Collection&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;; Collection c{v.begin(), v.end()}; //  OK</span></span></code> </pre> </div></div><br><br>  Lesen Sie mehr: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einmal (Russisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  EBO <a name="EBO"></a></h3><br>  <i>Leere Basisoptimierung.</i>  <i>Optimierung einer leeren Basisklasse.</i>  Wird auch als EBCO (Empty Base Class Optimization) bezeichnet. <br><br>  Wie Sie wissen, kann in C ++ die Größe eines Objekts einer Klasse nicht Null sein.  Andernfalls wird die gesamte Arithmetik der Zeiger unterbrochen, da an einer Adresse so viele verschiedene Objekte markiert werden können, wie Sie möchten.  Daher haben selbst Objekte leerer Klassen (d. H. Klassen ohne ein einzelnes nicht statisches Feld) eine Größe ungleich Null, die vom Compiler und vom Betriebssystem abhängt und normalerweise gleich 1 ist. <br><br>  Somit wird Speicher für alle Objekte leerer Klassen vergeblich verschwendet.  Aber nicht die Objekte ihrer Nachkommen, denn in diesem Fall macht der Standard ausdrücklich eine Ausnahme.  Der Compiler darf keinen Speicher für eine leere Basisklasse reservieren und somit nicht nur 1 Byte der leeren Klasse, sondern alle 4 (je nach Plattform) speichern, da auch eine Ausrichtung vorliegt. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 4 std::cout &lt;&lt; sizeof(int) &lt;&lt; std::endl; // 4</span></span></code> </pre> </div></div><br>  Da <i>jedoch</i> verschiedene Objekte desselben Typs nicht an derselben Adresse platziert werden können, funktioniert das <i>EBO</i> nicht, wenn: <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">Eine leere Klasse wird zweimal unter Vorfahren gefunden</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty2</span></span></span><span class="hljs-class"> :</span></span> Empty {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty, Empty2 { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Empty2) &lt;&lt; std::endl; // 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 8</span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Das erste nicht statische Feld ist ein Objekt derselben leeren Klasse oder ihres Nachkommens</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty { Empty e; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 8</span></span></code> </pre> </div></div></li></ul><br>  In Fällen, in denen Objekte leerer Klassen nicht statische Felder sind, werden keine Optimierungen bereitgestellt (das Attribut <code>[[no_unique_address]]</code> wird <code>[[no_unique_address]]</code> in C ++ 20 <code>[[no_unique_address]]</code> ).  Es ist jedoch eine Schande, 4 Bytes (oder wie viel der Compiler benötigt) für jedes dieser Felder auszugeben, sodass Sie Objekte leerer Klassen mit dem ersten nicht leeren nicht statischen Feld selbst "reduzieren" können. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty1</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty2</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Member</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyOptimization</span></span></span><span class="hljs-class"> :</span></span> Empty ... { Member member; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> EmptyOptimization&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Empty1, Empty2&gt; data; };</code> </pre> <br>  Seltsam, aber in diesem Fall ist die Größe von Foo für verschiedene Compiler unterschiedlich, für MSVC 2019 ist es 8, für GCC 8.3.0 ist es 4. In jedem Fall hat das Erhöhen der Anzahl leerer Klassen keinen Einfluss auf die Größe von <code>Foo</code> . </div></div><br>  Lesen Sie mehr: einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Englisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  IIFE <a name="IIFE"></a></h3><br>  <i>Sofort aufgerufener Funktionsausdruck.</i>  <i>Funktionsausdruck sofort aufgerufen.</i>  Im Allgemeinen ist dies eine Redewendung in JavaScript, von der Jason Turner sie zusammen mit dem Namen ausgeliehen hat.  Tatsächlich wird nur ein Lambda erstellt und sofort aufgerufen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> myVar = [&amp;] { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition1()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> computeSomeComplexStuff(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> condition2() ? computeSonethingElse() : DEFAULT_VALUE; } ();</code> </pre> <br>  Warum ist das notwendig?  Nun, zum Beispiel wie im obigen Code, um eine Konstante durch das Ergebnis einer nichttrivialen Berechnung zu initialisieren und den Bereich nicht mit unnötigen Variablen und Funktionen zu verstopfen. <br><br>  Lesen Sie mehr: einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Englisch)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei (Englisch)</a> <br><br><h3>  NVI <a name="NVI"></a></h3><br>  <i>Nicht virtuelle Schnittstelle.</i>  <i>Nicht virtuelle Schnittstelle.</i>  Nach dieser Redewendung sollte eine offene Klassenschnittstelle keine virtuellen Funktionen enthalten.  Alle virtuellen Funktionen werden privat gemacht (maximal geschützt) und in offenen nicht virtuellen Funktionen aufgerufen. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Base() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// check precondition fooImpl(); // check postconditions } private: virtual void fooImpl() = 0; }; class Derived : public Base { private: void fooImpl() override { } };</span></span></code> </pre> </div></div><br>  Warum ist das notwendig: <br><br><ul><li>  Jede offene virtuelle Funktion führt zwei Dinge aus: Sie definiert die öffentliche Schnittstelle der Klasse und beteiligt sich am übergeordneten Verhalten in untergeordneten Klassen.  Die Verwendung von <i>NVI</i> eliminiert solche Funktionen bei doppelter Belastung: Die Schnittstelle wird durch einige Funktionen definiert, Verhaltensänderungen durch andere.  Sie können beide unabhängig voneinander ändern. </li><li>  Wenn für alle Optionen zur Implementierung einer virtuellen Funktion (Vor- und Nachprüfungen, Mutex-Erfassung usw.) einige allgemeine Anforderungen gelten, ist es sehr praktisch, diese an einem Ort (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DRY</a> ) - in der Basisklasse - zu sammeln und zu verhindern, dass die Erben überschreiben  .  Das heißt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es stellt sich ein Sonderfall der Mustervorlagenmethode heraus. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Gebühr für die Verwendung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine gewisse Schwellung des Codes, eine mögliche Leistungsminderung (aufgrund eines zusätzlichen Methodenaufrufs) und eine erhöhte Anfälligkeit für das Problem einer fragilen Basisklasse (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: einmal </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Englisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei (Englisch)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RVO und NRVO </font></font><a name="RVO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Benannt) Rückgabewertoptimierung. Optimierung des (benannten) Rückgabewerts.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist ein Sonderfall der vom Standard zugelassenen Kopierentfernung. Der Compiler kann unnötige Kopien temporärer Objekte weglassen, selbst wenn ihre Konstruktoren und Destruktoren offensichtliche Nebenwirkungen haben. Eine solche Optimierung ist zulässig, wenn die Funktion ein Objekt nach Wert zurückgibt (die beiden anderen zulässigen Fälle der Kopierentfernung sind das Auslösen und Abfangen von Ausnahmen).</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Foo(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = bar(); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> würde hier ein temporäres Objekt </font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Funktion </font><font style="vertical-align: inherit;">erstellt </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dann würde über den Kopierkonstruktor ein weiteres temporäres Objekt in der Funktion daraus erstellt </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(um das Ergebnis zu erhalten </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), und erst dann würde das Objekt erstellt </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und der Wert des zweiten temporären Objekts ihm zugewiesen. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beseitigt all diese Kopierungen und Zuweisungen, und die Funktion </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird direkt erstellt </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies geschieht folgendermaßen: Eine Funktion </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weist einem Objekt in seinem Stapelrahmen einen Platz zu </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Eine Funktion </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(die bereits in ihrem Frame arbeitet) erhält Zugriff auf diesen im vorherigen Frame zugewiesenen Speicher und erstellt dort das gewünschte Objekt. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unterscheidet sich von</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> führt dieselbe Optimierung durch, jedoch nicht, wenn das Objekt im Ausdruck erstellt wird </font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sondern wenn das zuvor in der Funktion erstellte Objekt zurückgegeben wird.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz des scheinbar kleinen Unterschieds ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> viel schwieriger zu implementieren und funktioniert daher in vielen Fällen nicht. </font><font style="vertical-align: inherit;">Wenn eine Funktion beispielsweise ein globales Objekt oder eines ihrer Argumente zurückgibt oder wenn eine Funktion mehrere Austrittspunkte hat und unterschiedliche Objekte über diese zurückgegeben werden, wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht </font><i><font style="vertical-align: inherit;">angewendet</font></i><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO funktioniert hier nicht</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> condition)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) { Foo f1; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f1; } Foo f2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f2; }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast alle Compiler unterstützen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seit langem </font><font style="vertical-align: inherit;">. Der Grad der Unterstützung für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann von Compiler zu Compiler und von Version zu Version variieren. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind nur Optimierungen. Und obwohl das Kopieren des Konstruktors und des Zuweisungsoperators nicht aufgerufen wird, sollten sie in der Klasse des Objekts liegen. Die Regeln haben sich in C ++ 17 etwas geändert: Jetzt wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht als Kopierelision betrachtet, es ist obligatorisch geworden und der entsprechende Konstruktor und Zuweisungsoperator werden nicht benötigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(N) RVO ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in konstanter Form ein schlüpfriges Thema. Bis einschließlich C ++ 14 wurde nichts darüber gesagt, C ++ 17 erfordert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in solchen Ausdrücken, und das kommende C ++ 20 - verbietet.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein paar Worte zum Zusammenhang mit der Semantik der Verschiebung. </font><font style="vertical-align: inherit;">Erstens ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(N) RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> noch effektiver, weil </font><font style="vertical-align: inherit;">Der Verschiebungskonstruktor und der Destruktor müssen nicht aufgerufen werden. </font><font style="vertical-align: inherit;">Zweitens, wenn </font><i><font style="vertical-align: inherit;">NRVO</font></i><font style="vertical-align: inherit;"> nicht </font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von derselben Funktion zurückkehrt </font></font><code>std::move(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert es</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> garantiert nicht. </font><font style="vertical-align: inherit;">Um Standard zu paraphrasieren: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gilt für prvalue, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO gilt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für lvalue, a </font></font><code>std::move(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist xvalue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eins (Englisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei (Englisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drei (Englisch)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SFINAE </font></font><a name="SFINAE"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Substitutionsfehler ist kein Fehler. </font><font style="vertical-align: inherit;">Fehlgeschlagene Substitution ist kein Fehler. </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Funktion des Instanziierungsprozesses von Vorlagen - Funktionen und Klassen - in C ++. </font><font style="vertical-align: inherit;">Wenn eine bestimmte Vorlage nicht instanziiert werden kann, wird dies unter dem Strich nicht als Fehler angesehen, wenn andere Optionen vorhanden sind. </font><font style="vertical-align: inherit;">Ein vereinfachter Algorithmus zur Auswahl der am besten geeigneten Funktionsüberladung funktioniert beispielsweise folgendermaßen:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Name der Funktion wird aufgelöst - der Compiler sucht in allen betrachteten Namespaces nach allen Funktionen mit dem angegebenen Namen (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unangemessene Funktionen werden verworfen - nicht die Anzahl der Argumente, es ist keine Konvertierung von Argumenttypen erforderlich, es war nicht möglich, Typen für die Funktionsvorlage abzuleiten usw. </font></font></li><li>          (viable functions),          .           —     . </li></ol><br>   <i>SFINAE</i>    :      ,        ,      ,    (  ).    . <br><br> <i>SFINAE</i>     , ,           .       -  , . . ,        . <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; template &lt;class, class = void&gt; struct HasToString : std::false_type {}; //    ,      //   -    ,  //     —  ,    ,   template &lt;class T&gt; struct HasToString&lt;T, std::void_t&lt;decltype(&amp;T::toString)&gt;&gt; : std::is_same&lt;std::string, decltype(std::declval&lt;T&gt;().toString())&gt; {}; struct Foo { std::string toString() { return {}; } }; int main() { std::cout &lt;&lt; HasToString&lt;Foo&gt;::value &lt;&lt; std::endl; // 1 std::cout &lt;&lt; HasToString&lt;int&gt;::value &lt;&lt; std::endl; // 0 }</span></span></span></span></code> </pre> </div></div><br>   C++17 <code>static if</code>      <i>SFINAE</i> ,    C++20        .  Mal sehen. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eins (Russisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei (Englisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drei (Englisch)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SBO, SOO, SSO </font></font><a name="SBO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimierung für kleine Puffer / Objekte / Zeichenfolgen. Optimierung kleiner Puffer / Objekte / Zeilen.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manchmal wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Sinne der Small Size Optimization verwendet, aber sehr selten. Wir gehen daher davon aus, dass es bei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um Zeichenfolgen geht. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind einfach Synonyme, und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der bekannteste Sonderfall. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Datenstrukturen, die dynamischen Speicher verwenden, nehmen sicherlich auch einen Platz auf dem Stapel ein. Zumindest um einen Zeiger auf einen Haufen zu speichern. Das Wesentliche dieser Optimierungen ist nicht, Speicher vom Heap für relativ kleine Objekte anzufordern (was relativ teuer ist), sondern sie in den bereits zugewiesenen Stapelspeicherplatz zu legen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel könnte std :: string folgendermaßen implementiert werden:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* begin_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> capacity_; };</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Größe dieser Klasse erhalte ich 24 Bytes (abhängig vom Compiler und der Plattform). </font></font> Das heißt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichenfolgen, die nicht länger als 24 Zeichen sind, können auf dem Stapel platziert werden. </font><font style="vertical-align: inherit;">Eigentlich natürlich erst um 24, da man irgendwie zwischen Platzierung auf dem Stapel und auf dem Haufen unterscheiden muss. </font><font style="vertical-align: inherit;">Aber hier ist der einfachste Weg für kurze Zeilen mit bis zu 8 Zeichen (gleiche Größe - 24 Byte):</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> Buffer { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* begin_; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> local_[<span class="hljs-number"><span class="hljs-number">8</span></span>]; }; Buffer buffer_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _size; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _capacity; };</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neben dem Fehlen von Zuordnungen auf dem Heap gibt es einen weiteren Vorteil - einen hohen Grad an Datenlokalität. </font><font style="vertical-align: inherit;">Ein Array oder Vektor solcher optimierten Objekte belegt tatsächlich nur einen kontinuierlichen Speicherplatz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast alle Implementierungen </font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwenden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und zumindest einige Implementierungen </font></font><code>std::function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es wird jedoch </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">niemals auf diese Weise optimiert, da der Standard verlangt, dass </font></font><code>std::swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für zwei Vektoren kein Kopieren oder Zuweisen ihrer Elemente verursacht wird und dass alle gültigen Iteratoren gültig bleiben. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird es nicht erlauben, diese Anforderungen zu erfüllen (denn </font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie sind es nicht). </font><font style="vertical-align: inherit;">Aber </font></font><code>boost::container::small_vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wie Sie sich vorstellen können, wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit (Englisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UDPATE </font></font><a name="Update"></a></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank an </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyerK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für diese zusätzliche Liste von Abkürzungen.</font></font><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lebenslauf </font></font><a name="CV"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualifikanten wie const und volatile. </font></font></i> <code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet, dass das Objekt / die Variable nicht geändert werden kann. Ein Versuch, dies zu tun, führt entweder zu einem Fehler zur Kompilierungszeit oder zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur Laufzeit. </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet, dass sich das Objekt / die Variable unabhängig von den Aktionen des Programms ändern kann (z. B. schreiben einige Mikrocontroller-Füllungen etwas in den Speicher), und der Compiler sollte den Zugriff darauf nicht optimieren. </font><font style="vertical-align: inherit;">Der Zugriff auf ein </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekt, das nicht über einen </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link oder Zeiger erfolgt, führt ebenfalls zu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eins (russisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei (englisch)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drei (russisch)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LTO </font></font><a name="LTO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindungszeitoptimierung. </font><font style="vertical-align: inherit;">Linkoptimierung. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie der Name schon sagt, erfolgt diese Optimierung während der Verknüpfung, d. H. Nach der Kompilierung. </font><font style="vertical-align: inherit;">Der Linker kann etwas tun, was der Compiler nicht gewagt hat: einige Funktionen inline zu machen, nicht verwendeten Code und Daten wegzuwerfen. </font><font style="vertical-align: inherit;">Erhöht natürlich die Verbindungszeit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiterlesen: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit (Englisch)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PCH </font></font><a name="PCH"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorkompilierte Header. </font><font style="vertical-align: inherit;">Vorkompilierte Header. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oft verwendete, aber selten geänderte Header-Dateien werden einmal kompiliert und im internen Compiler-Format gespeichert. </font><font style="vertical-align: inherit;">Der Zusammenbau des Projekts dauert daher weniger, manchmal sogar viel weniger. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit (rus.)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pgo </font></font><a name="PGO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profilgesteuerte Optimierung. </font><font style="vertical-align: inherit;">Optimierung basierend auf Profilerstellungsergebnissen. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist eine Programmoptimierungsmethode, jedoch nicht durch statische Code-Analyse, sondern durch Start des Testprogramms und Sammeln realer Statistiken. </font><font style="vertical-align: inherit;">Beispielsweise kann das Verzweigen und Aufrufen virtueller Funktionen auf diese Weise optimiert werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit (rus.)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seh / veh </font></font><a name="SEH"></a></h3><br> <i>Structured/Vectored Exception Handling.</i>   MSVC     .     <code>try-catch</code> <i>SEH</i>     : <code>__try</code> , <code>__except</code> , <code>__finally</code> ,       ,   ,     ,   -  ,      . . <i>VEH</i>     ,      . <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> (.)</a> <br><br><h3> TMP <a name="TMP"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template Meta-Programmierung. </font><font style="vertical-align: inherit;">Vorlagen-Metaprogrammierung. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metaprogrammierung ist, wenn ein Programm aufgrund seiner Arbeit ein anderes erstellt. </font><font style="vertical-align: inherit;">Vorlagen in C ++ implementieren eine solche Metaprogrammierung. </font><font style="vertical-align: inherit;">Der Vorlagen-Compiler generiert die erforderliche Anzahl von Klassen oder Funktionen. </font><font style="vertical-align: inherit;">Es ist bekannt, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in C ++ Turing-vollständig ist, d. H. Jede Funktion kann darauf implementiert werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit (rus.)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vla </font></font><a name="VLA"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays mit variabler Länge. </font><font style="vertical-align: inherit;">Arrays variabler Länge.</font></font></i>  Das heißt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arrays, deren Länge zur Kompilierungszeit unbekannt ist: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[n]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der C ++ - Standard erlaubt dies nicht. </font><font style="vertical-align: inherit;">Was etwas seltsam ist, da sie seit dem C99-Standard in reinem C existieren. </font><font style="vertical-align: inherit;">Und werden von einigen C ++ - Compilern als Erweiterung unterstützt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen Sie mehr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeit (rus.)</font></font></a> <br><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ich etwas verpasst habe oder mich irgendwo geirrt habe - schreibe in die Kommentare. </font><font style="vertical-align: inherit;">Denken Sie bitte daran, dass hier nur Abkürzungen aufgeführt sind, die in direktem Zusammenhang mit C ++ stehen. </font><font style="vertical-align: inherit;">Für andere, aber nicht weniger nützlich, wird es einen separaten Beitrag geben. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweiter Teil</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470265/">https://habr.com/ru/post/de470265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470247/index.html">RESHI.RU - ein Roboter löst und erklärt Schultextprobleme in der Mathematik</a></li>
<li><a href="../de470251/index.html">Wie ich eine Desktop-Anwendung auf Flutter gemacht habe (+ Bonus)</a></li>
<li><a href="../de470255/index.html">Optimierung des Anleihenportfolios mit ALGLIB</a></li>
<li><a href="../de470257/index.html">Umhüllen Sie ImmutableList in Java</a></li>
<li><a href="../de470259/index.html">Aimybox bei der Suche: Das Framework zum Erstellen von Sprachassistenten benötigt einen iOS-Assistenten</a></li>
<li><a href="../de470269/index.html">ReactOS 0.4.12: 华为 ， 你 认为 认为 怎么 样？</a></li>
<li><a href="../de470271/index.html">F # 6: Tupel</a></li>
<li><a href="../de470273/index.html">F # 7: Aufzeichnungen</a></li>
<li><a href="../de470275/index.html">F # 8: Diskriminierte Gewerkschaften</a></li>
<li><a href="../de470277/index.html">Wie ist das globale Netzwerk in der Russischen Föderation organisiert und organisiert?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>