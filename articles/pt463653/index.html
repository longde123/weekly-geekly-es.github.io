<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóëÔ∏è üññüèº üíÉüèº Limita√ß√µes dos jogos de 16 bits e sua recrea√ß√£o no Unity ‚öìÔ∏è üê¨ üéõÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em nosso primeiro tutorial de retro-jogo, mostramos como personalizar a ferramenta 2D Pixel Perfect e como os gr√°ficos foram criados na era dos jogos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Limita√ß√µes dos jogos de 16 bits e sua recrea√ß√£o no Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463653/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ff/83e/cc7/7ff83ecc7638cc4231d30cbd03a253f5.png" alt="imagem"></div><br>  Em nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro tutorial de</a> retro-jogo, mostramos como personalizar a ferramenta 2D Pixel Perfect e como os gr√°ficos foram criados na era dos jogos de 8 bits.  Neste post, seremos transportados para a era de 16 bits.  Com o Mega Cat Studios, aprenderemos como criar gr√°ficos aut√™nticos para jogos no estilo de Sega Genesis (Mega Drive) e Super NES usando as op√ß√µes do Unity, estruturas gr√°ficas e paletas de cores. <br><br><h2>  Crie gr√°ficos aut√™nticos no estilo Genesis </h2><br>  Nesta se√ß√£o, consideraremos o fluxo de trabalho da cria√ß√£o de gr√°ficos que simulam a imagem de diferentes consoles.  Haver√° menos restri√ß√µes do que em um projeto de 8 bits e mais liberdade ao trabalhar com cores, mas ainda assim, o Genesis tem limites.  Acreditamos que tamb√©m ser√° √∫til explicar como o hardware do console funcionou para que voc√™ possa aplicar essas restri√ß√µes em seu pr√≥prio projeto retro. <br><br><h2>  Paletas e sub-paletas </h2><br>  A transi√ß√£o dos consoles de 8 para 16 bits, devido √† complexidade do equipamento, proporcionou aos desenvolvedores mais oportunidades.  No entanto, os princ√≠pios para a cria√ß√£o de gr√°ficos NES de alta qualidade ainda s√£o v√°lidos.  Todos os gr√°ficos ainda s√£o armazenados em blocos, por exemplo, 8 √ó 8 e coletados em imagens grandes - sprites e elementos de plano de fundo.  Os artistas ainda est√£o limitados a subpaletas com uma cor transparente comum, mas 16 bits fornecem mais flexibilidade para trabalhar com paletas.  Voc√™ provavelmente ficar√° satisfeito com o fato de os consoles de 16 bits n√£o possu√≠rem uma paleta de cores bem definida, ou seja, o n√∫mero de cores dispon√≠veis aumentou bastante em compara√ß√£o ao NES. <br><a name="habracut"></a><br>  Al√©m disso, o Genesis possui sub-paletas contendo 15 cores mais a cor geral usada para transpar√™ncia de sprites e camadas.  No entanto, uma das desvantagens da cria√ß√£o de gr√°ficos para o Genesis √© trabalhar com sub-paletas.  As sub-paletas podem ser atribu√≠das livremente a sprites ou blocos de plano de fundo, mas o Genesis permite que voc√™ use n√£o mais que quatro sub-paletas por vez.  Portanto, os artistas precisam pensar em quais cores devem ser usadas na sub-paleta, para que seu n√∫mero de sprites e planos de fundo seja m√°ximo.  A sub-paleta Genesis geralmente cont√©m cores usadas para segundo plano e sprites. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b32/307/3a0/b323073a0263df666c196d02752ab3c4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/991/d48/3e7/991d483e76ca6dbca198c5c68c512c2e.png" width="729" height="151"></div><br>  <i>A cena do jogo para Genesis √© mostrada acima e as sub-paletas usadas abaixo.</i> <br><br>  Ao criar gr√°ficos para qualquer plataforma de 16 bits, voc√™ precisa trabalhar com uma paleta indexada.  Para fazer isso, voc√™ pode usar o editor Gimp, uma alternativa gratuita ao Photoshop que permite manipular paletas indexadas. <br><br>  Para criar uma paleta indexada no Gimp, v√° em <b>Image&gt; Mode&gt; Indexed</b> ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12c/4d2/f4f/12c4d2f4fcbe205b41af06268456d728.png"></div><br>  A janela Convers√£o de cores indexadas √© aberta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5eb/47d/78d/5eb47d78d29d7c9d1a8ff0d4b5e4e5a5.png"></div><br>  Para N√∫mero m√°ximo de cores, defina o valor como <b>15</b> .  Voc√™ pode usar padr√µes de pontilhamento autom√°tico, mas eles geralmente ficam melhores se voc√™ os criar manualmente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5a/aae/a7b/d5aaaea7b7295e5cdb8119be1ee4a551.png"></div><br>  As cores da imagem agora est√£o indexadas.  Esta informa√ß√£o √© salva automaticamente com a imagem para que o √≠ndice de cores possa ser usado.  Se voc√™ precisar alterar a ordem das cores no √≠ndice, clique com o bot√£o direito do mouse no mapa de cores e selecione <b>Reorganizar</b> mapa de cores <b>...</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dae/c84/530/daec845306aaf222db7ec36ab3e0043a.png"></div><br>  Uma janela ser√° aberta, permitindo que voc√™ arraste e solte cores, alterando sua ordem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdc/f0e/2c8/cdcf0e2c85543492765713f17934df03.png"></div><br>  Um truque popular para aumentar a profundidade de cores √© controlar a paleta em uma linha de digitaliza√ß√£o espec√≠fica, semelhante √† maneira como a rolagem de paralaxe √© implementada no NES.  O console Genesis pode alterar a escolha da sub-paleta de gr√°ficos na linha de varredura especificada.  Esse truque √© frequentemente usado para criar a ilus√£o de que parte do n√≠vel est√° submersa.  As cores subaqu√°ticas s√£o adicionadas a uma sub-paleta separada e essa sub-paleta √© carregada quando a linha de digitaliza√ß√£o especificada √© renderizada na tela. <br><br><h2>  Armazenamento em blocos e carregamento neste console </h2><br>  Em geral, os consoles de 16 bits carregam blocos gr√°ficos diferentes dos de 8 bits.  Os consoles de 8 bits carregavam sprites e blocos de segundo plano com grandes peda√ßos de dados para economizar energia de processamento, enquanto os recursos dos consoles de 16 bits forneciam maior flexibilidade.  Eles podiam carregar e substituir blocos separados rapidamente, gra√ßas ao qual era poss√≠vel carregar apenas os gr√°ficos necess√°rios.  Portanto, em uma √∫nica tela ou n√≠vel, voc√™ pode usar uma variedade maior de gr√°ficos. <br><br>  Outro aspecto exclusivo do Genesis / Mega Drive √© que os dados gr√°ficos e da paleta n√£o s√£o os √∫nicos dados carregados no console da VRAM durante o jogo.  Isso dificultava a cria√ß√£o de um design gr√°fico para o console, porque o n√∫mero de blocos gr√°ficos que podiam ser carregados na mem√≥ria em um determinado momento dependia do que mais estava acontecendo no jogo.  No caso geral, a maioria dos jogos tinha espa√ßo suficiente para carregar cerca de 1000 blocos e, com elementos din√¢micos, os blocos sempre podiam ser baixados e carregados livremente na mem√≥ria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62b/077/356/62b077356f85edd37119d66b9a0302bd.png" width="1600" height="501"></div><br>  <i>Mosaicos carregados na mem√≥ria na cena mostrada acima.</i>  <i>Um grande espa√ßo vazio no meio e artefatos abaixo √© o espa√ßo alocado na mem√≥ria para inimigos e outros elementos do jogo.</i> <br><br>  Apesar do fato de que no VRAM uma variedade maior de pe√ßas pode ser carregada ao mesmo tempo, na maioria das vezes esse espa√ßo adicional √© reservado para sprites.  Isso forneceu uma anima√ß√£o mais complexa e permitiu exibir mais sprites na tela simultaneamente.  Ou seja, a filosofia fundamental do design com segmentos de blocos repetidos ainda era usada ativamente nos gr√°ficos de 16 bits, devido aos quais o plano de fundo n√£o ocupava muito espa√ßo dispon√≠vel.  As permiss√µes do NES, Genesis e SNES s√£o quase as mesmas, portanto, segmentos 16 √ó 16 geralmente eram o ponto de partida para esses tipos de design. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e7/6e4/ce5/1e76e4ce579739aaa92ba97773b9d9b2.png" width="1600" height="867"></div><br>  <i>Aqui, o artista usou um padr√£o de bloco 32 √ó 32 para criar a parte principal do piso, que √© o plano de fundo.</i> <br><br><h2>  Trabalhar com camadas de fundo </h2><br>  O Genesis / Mega Drive permite exibir simultaneamente na tela duas camadas de fundo.  Isso significa que os elementos de sobreposi√ß√£o s√£o mais convenientes para a cria√ß√£o de planos de fundo de design.  No entanto, existem apenas duas camadas, portanto, para dar maior profundidade √† cena, o artista e o desenvolvedor podem usar truques com linhas de digitaliza√ß√£o.  Felizmente, como tudo isso podia ser transferido para a segunda camada, os designers estavam livres para colocar objetos em primeiro plano na frente do plano de fundo sem destruir as ilus√µes. <br><br>  Al√©m disso, gra√ßas √† presen√ßa da segunda camada, os desenvolvedores n√£o precisavam mais aplicar truques com prioridades de sprite.  Em vez de mudar constantemente as prioridades dos sprites em tempo real, agora era poss√≠vel definir uma segunda camada do plano de fundo exibida na frente do jogador.  No entanto, para uma sobreposi√ß√£o mais complexa, ela ainda pode exigir manipula√ß√£o r√°pida de prioridades de sprites.  A segunda camada de plano de fundo tamb√©m possui uma √°rea que pode ser usada para a interface.  Esta √°rea est√° bloqueada no lugar e nunca ser√° rolada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d1/e8b/1ec/5d1e8b1ecf884a5b7df8825edec191e6.png" width="650" height="240"></div><br>  <i>Devido √† vista de cima para baixo da √°rvore, era necess√°rio criar ladrilhos especiais para manipular a ordem das camadas de sprite.</i> <br><br><h2>  Restri√ß√µes de Sprite </h2><br>  Ao mudar para 16 bits, a liberdade de trabalhar com sprites aumenta bastante.  Genesis / Mega Drive permite exibir simultaneamente na tela at√© 80 sprites e at√© 20 sprites em uma linha horizontal;  todos os sprites subsequentes n√£o s√£o renderizados.  Al√©m disso, os sprites n√£o s√£o mais considerados 8x8 tiles separados.  O Genesis √© capaz de gerar sprites √∫nicos compostos de v√°rias pe√ßas.  Eles podem ser de uma pe√ßa para pe√ßas 4x4.  Imagens maiores ter√£o que ser compostas por v√°rios sprites. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80c/877/672/80c877672f97cbe26df1a7ba887d29c1.png" width="650" height="240"></div><br>  <i>Os gr√°ficos do chefe final usam um grande n√∫mero de elementos de fundo animados, camadas e muitos sprites.</i>  <i>Tudo isso seria imposs√≠vel em uma plataforma de 8 bits.</i> <br><br><h2>  Padr√µes de pontilhado e contraste </h2><br>  Uma das caracter√≠sticas dos gr√°ficos da era de 16 bits √© o uso do pontilhamento.  Naqueles dias, os jogos eram jogados em TVs CRT, onde os pixels da tela geralmente se mesclavam.  Os artistas aproveitaram esse recurso aplicando padr√µes de pontilhado em seus gr√°ficos: quando um pixel se mesclava com outro em um padr√£o repetitivo, isso criava a ilus√£o de mais cores do que o console permitia.  Para transmitir a est√©tica do original, o pontilhamento ainda √© usado ativamente na pixel art, apesar das melhores exibi√ß√µes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afd/2e2/f63/afd2e2f630cf7765c18f40d0c68b4950.png" width="623" height="240"></div><br>  <i>O pontilhamento era frequentemente usado em consoles de 16 bits.</i>  <i>Em uma tela CRT, o padr√£o de pixels foi misturado, criando novas cores ou efeitos de transpar√™ncia, quando isso n√£o foi poss√≠vel.</i> <br><br>  Comparado ao SNES, o Genesis / Mega Drive exibe cores com maior contraste.  Isso tamb√©m precisa ser considerado ao escolher sub-paletas.  Se voc√™ criar um jogo com cores suaves e sem brilho, durante a renderiza√ß√£o no hardware original, as paletas poder√£o ser diferentes.  Em geral, os gr√°ficos devem ser criados em uma paleta de cores de alto contraste para que o resultado final corresponda √† vis√£o original do artista. <br><br><h2>  Crie gr√°ficos aut√™nticos no estilo SNES </h2><br>  Os jogos Super NES ainda funcionavam com grades / blocos de 8 √ó 8 pixels, por isso √© extremamente √∫til usar blocos repetidos.  Em geral, seus tamanhos devem ser m√∫ltiplos de oito. <br><br><h2>  Paleta de cores </h2><br>  A primeira diferen√ßa fundamental entre Genesis / Mega Drive e SNES est√° relacionada √† paleta de cores.  Como o Mega Drive, o console SNES n√£o possui uma paleta de cores costurada em hardware, para que voc√™ possa escolher suas pr√≥prias cores. <br><br>  A complexidade do SNES √© que ele usou cores com profundidade de 5 bits por pixel (bits por pixel, BPP), que raramente s√£o vistas hoje.  Voc√™ pode implement√°-los com o Gimp e simplesmente posterizar a imagem em 32 tons de RGB, o que corresponder√° √†s cores com 5 BPP.  Isso exibir√° com precis√£o as cores da imagem no console. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f68/319/d19/f68319d19b2667682787c08eddb5a158.png"></div><br>  Esta op√ß√£o no Gimp est√° localizada no item de menu <b>Cores&gt; Posterizar ...</b> Aparecer√° uma janela pop-up na qual voc√™ pode definir os n√≠veis de Posteriza√ß√£o para 32 para criar cores compat√≠veis com 5 BPP. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96a/e0d/cc2/96ae0dcc2a2f31a300d9b6f5bac6354b.png"></div><br><h2>  Resolu√ß√£o da tela </h2><br>  Outra grande diferen√ßa entre os dois sistemas est√° relacionada √† resolu√ß√£o da tela.  Como o SNES era descendente do NES, os dois consoles tinham resolu√ß√µes de tela semelhantes.  A resolu√ß√£o interna do SNES √© 256 √ó 224.  Permite renderizar imagens em √°reas seguras da maioria das TVs CRT sem aparar parte da imagem.  Essa resolu√ß√£o nunca muda, portanto, ser√° o tamanho da imagem e o artista deve us√°-la. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66d/e64/cc3/66de64cc31329db4bd07f2953cb7d75f.png" width="256" height="224"></div><br>  <i>Esta imagem ocupa a resolu√ß√£o SNES de tela cheia usada na maioria dos modos de tela.</i> <br><br><h2>  Modos de tela do console </h2><br>  Nesta se√ß√£o, falaremos brevemente sobre os diferentes modos de tela. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/799/f1d/9ca/799f1d9caa299ff12bfe90efa8eca109.png"></div><br>  A maior diferen√ßa entre os consoles √© que o SNES pode renderizar gr√°ficos de fundo em sete modos de tela diferentes.  Em alguns modos de tela, o SNES pode renderizar 256 cores simultaneamente de uma sub-paleta na tela.  Aqui est√£o os modos de tela mais populares: <br><br><ul><li>  <b>Modo 1:</b> um dos modos de tela mais comuns para o SNES.  Este √© o modo mais comum que demonstra os recursos do console.  O modo 1 permite que voc√™ trabalhe com tr√™s camadas de fundo, duas das quais t√™m suas pr√≥prias sub-paletas de 16 cores e a √∫ltima camada possui uma sub-paleta de quatro cores. </li><li>  <b>Modo 3:</b> Esse modo √© comumente usado para imagens est√°ticas grandes, como telas de abertura ou cenas.  Possui duas camadas de fundo.  O primeiro usa uma sub-paleta completa de 256 cores, o segundo usa uma sub-paleta de 16 cores. </li><li>  <b>Modo 7:</b> Este √© um dos principais recursos do SNES.  Este modo foi mostrado na maioria dos materiais de publicidade do console.  Gra√ßas ao Modo 7, os consoles dom√©sticos pela primeira vez foram capazes de realizar transforma√ß√µes de imagem em tempo real: redimensionar, girar, esticar e inclinar no plano de fundo.  Foi usado para criar efeitos pseudo-3D que podem ser vistos em muitos jogos de corrida e simuladores de v√¥o do SNES. </li></ul><br>  Para garantir que essas fun√ß√µes funcionem, o √∫nico plano de fundo no Modo 7 √© processado de maneira muito diferente dos outros modos de tela.  Em primeiro lugar, existe apenas um plano de cores de 256 cores, ou seja, todos os sprites devem ter cores de uma sub-paleta desse plano de fundo.  Em segundo lugar, em vez do tamanho normal da tela SNES, o plano de fundo no Modo 7 era 1024 √ó 1024 pixels.  Ele √© dimensionado e ajustado conforme o designer precisa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fe/e26/51a/3fee2651a4bbb628cbf6c79541e50780.png" width="520" height="224"></div><br>  Este escrit√≥rio usa o Modo 1 com uma sub-paleta (os outros dois s√£o usados ‚Äã‚Äãpara a interface do usu√°rio).  A tela Obrigado por reproduzir usa o Modo 3, que permite ao artista aplicar uma paleta de 256 cores. <br><br><h2>  Tamanhos de Sprite </h2><br>  Comparado √† complexidade dos modos de tela de segundo plano, as regras para trabalhar com sprites s√£o relativamente simples.  O SNES tem v√°rios modos de sprite diferentes, quase como o Mega Drive, mas com uma restri√ß√£o estrita: o console pode usar apenas dois modos de sprite diferentes no jogo <br><br>  Sprites podem ter tamanhos de 8 √ó 8, 16 √ó 16, 32 √ó 32 ou 64 √ó 64.  Mas isso n√£o √© tudo - os designers tiveram que escolher combina√ß√µes em uma lista pronta de tamanhos de sprites.  As seguintes combina√ß√µes podem ser usadas nos jogos SNES: <br><br><ul><li>  8 √ó 8, 16 √ó 16 </li><li>  8 √ó 8, 32 √ó 32 </li><li>  8 √ó 8, 64 √ó 64 </li><li>  16 √ó 16, 32 √ó 32 </li><li>  16 √ó 16, 64 √ó 64 </li><li>  32 √ó 32, 64 √ó 64 </li></ul><br>  Esses tamanhos s√£o escolhidos "de uma vez por todas" e todos os sprites do jogo devem corresponder a eles.  O SNES √© capaz de renderizar 32 sprites em uma linha de varredura horizontal e n√£o mais que 128 sprites na tela por vez.  Todos os outros n√£o ser√£o renderizados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/0f3/ef3/deb0f3ef3b38b654d808bbc41c03081d.png" width="650" height="640"></div><br>  <i>O Crunch-Out do Fork Parker usa uma combina√ß√£o de 32 √ó 32 e 16 √ó 16 para todos os sprites do jogo.</i> <br><br>  Sprites podem trabalhar com oito sub-paletas de 16 cores.  Como em todos os consoles retr√¥, a primeira cor de qualquer sub-paleta √© a cor geral usada para transpar√™ncia.  Um grande n√∫mero de sub-paletas em compara√ß√£o com outros consoles nos d√° mais liberdade na escolha de cores para sprites.  Voc√™ s√≥ precisa se lembrar de que existe um limite estrito de 256 cores. <br><br><h2>  Usando o 2D Pixel Perfect para criar jogos retr√¥ </h2><br>  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tutorial retro anterior,</a> abordamos as op√ß√µes 2D Pixel Perfect e recriamos gr√°ficos no estilo de 8 bits. <br><br>  A partir do Unity 2019.2, o pacote 2D Pixel Perfect faz parte do 2D Renderer, que por sua vez faz parte do pacote Lightweight Render Pipeline (LWRP).  Se voc√™ n√£o usar o LWRP, o 2D Pixel Perfect tamb√©m poder√° ser usado como um pacote separado.  Neste tutorial, mostraremos como configurar um projeto no LWRP. <br><br><h2>  Preparando um novo projeto no Unity 2019.2 e no LWRP </h2><br><ol><li>  Inicie o Unity Hub, clique em Novo, selecione <b>2D</b> e especifique o nome do seu projeto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/375/300/f7b375300754b91d5a8fc5a1d045bb95.png"></div></li><li>  Para importar um pacote 2D Pixel Perfect, clique no menu Janela na barra de ferramentas e selecione <b>Gerenciador de Pacotes</b> .  Na janela exibida, selecione o pacote <b>Lightweight RP</b> e verifique se a vers√£o √© 6.9.0 ou superior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e90/8d6/e82/e908d6e824bfd3510efd8fd98c8f21ef.png"></div></li><li>  Em seguida, voc√™ precisa configurar o Renderizador 2D no Editor e criar um novo ativo de pipeline.  Na janela Projeto, clique com o bot√£o direito do mouse na janela Ativos e selecione <b>Criar&gt; Renderiza√ß√£o&gt; Pipeline de renderiza√ß√£o leve&gt; Ativo de pipeline</b> . </li><li>  Na janela Ativos da janela Projeto, crie um novo Renderizador 2D clicando com o bot√£o direito do mouse e escolhendo <b>Criar&gt; Renderiza√ß√£o&gt; Pipeline de renderiza√ß√£o leve&gt; Renderizador 2D</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/a37/fbb/433a37fbb86e42240f9f90322a84818b.png"></div></li><li>  Selecione o ativo de pipeline criado.  Selecione <b>Geral</b> e mude o Tipo de <b>renderizador de Forward Renderer</b> para <b>Custom</b> . </li><li>  Atribua o renderizador 2D gerado como o valor do campo de dados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1aa/a61/a0a/1aaa61a0af6b9041e9f301d842017c6d.png"></div></li><li>  Nas op√ß√µes de gr√°ficos, altere as configura√ß√µes de pipeline de renderiza√ß√£o grav√°vel para usar o novo ativo de pipeline que voc√™ criou. <br><br>  Isso completa a configura√ß√£o do 2D Renderer, bem como da 2D Pixel Perfect Camera. </li></ol><br>  No Unity 2019.2, sprites bidimensionais podem ter material Sprite-Lit que lhes permite responder √†s condi√ß√µes de ilumina√ß√£o 2D.  Se o seu projeto n√£o tiver ilumina√ß√£o 2D, use material que n√£o exija ilumina√ß√£o 2D para que os sprites fiquem vis√≠veis, ou seja, "Sprites-Default". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67d/5e3/9d8/67d5e39d877a368fcc6ba635a5be7b22.png"></div><br><h2>  Tintura Pixel Perfect para estilos de gr√°ficos de 16 bits </h2><br>  Voc√™ deve adicionar o componente Pixel Perfect Camera √† c√¢mera principal.  Recomendamos que voc√™ marque a caixa de sele√ß√£o Executar no modo de edi√ß√£o. <br><br>  O console <b>Sega Genesis</b> tinha uma resolu√ß√£o de 320 √ó 224 pixels (ou uma grade de 40 √ó 28 blocos de tamanho 8 √ó 8 pixels).  Isso se aplica √† vers√£o NTSC. <br><br>  O console <b>Super NES</b> tamb√©m na vers√£o NTSC tinha uma resolu√ß√£o de 256 √ó 224 (30 √ó 28 blocos com um tamanho de 8 √ó 8 pixels). <br><br>  Para criar os dois estilos gr√°ficos, recomendamos o uso de uma resolu√ß√£o de altura de 224 pixels e 8 PPU. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ff/83e/cc7/7ff83ecc7638cc4231d30cbd03a253f5.png" width="1194" height="950"></div><br>  Usando o sprite de ajuda (acima mostra uma imagem em tela cheia de 320 √ó 224 do Sonic the Hedgehog para Sega Genesis), voc√™ pode entender como um sprite com 8 pixels por unidade (pixels por unidade, PPU) √© colocado na janela Cena com a mesma resolu√ß√£o e PPU. <br><br>  Se voc√™ precisar de um lembrete do que cada uma das op√ß√µes do componente 2D Pixel Perfect Camera faz, leia o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tutorial do jogo retro anterior</a> . <br><br><h2>  Desenvolvimento adicional </h2><br>  Espero que tenham gostado desta s√©rie de posts sobre a cria√ß√£o de jogos retr√¥ de 8 e 16 bits usando o 2D Pixel Perfect na vers√£o mais recente do Unity. <br><br>  N√£o conclu√≠mos o 2D Pixel Perfect, porque este pacote estar√° pronto para produ√ß√£o no Unity 2019.3 e tamb√©m ter√° mais compatibilidade com o Cinemachine 2D. <br><br>  Mantenha-nos atualizados sobre seus projetos com o 2D Pixel Perfect e n√£o se esque√ßa de visitar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener noreferrer">f√≥rum 2D</a> para conversar com usu√°rios do Unity e desenvolvedores de fun√ß√µes 2D. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463653/">https://habr.com/ru/post/pt463653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463637/index.html">Testando sua infraestrutura como c√≥digo com Pulumi. Parte 2</a></li>
<li><a href="../pt463639/index.html">Well Apple BLEee</a></li>
<li><a href="../pt463647/index.html">V√≠deos e relat√≥rios com o SmartMail Meetup: Frontend</a></li>
<li><a href="../pt463649/index.html">Nota anal√≠tica. Revis√£o da ordem do Minist√©rio da Energia da Federa√ß√£o da R√∫ssia de 6 de novembro de 2018 N 1015</a></li>
<li><a href="../pt463651/index.html">Matem√°tica discreta para WMS: algoritmo para comprimir mercadorias nas c√©lulas (parte 2)</a></li>
<li><a href="../pt463655/index.html">O nascimento de um projeto ou como escrever seu pr√≥prio CMS</a></li>
<li><a href="../pt463657/index.html">Chatbots √© uma merda</a></li>
<li><a href="../pt463663/index.html">10 livros para entender a estrutura do mercado de a√ß√µes, investimento na bolsa de valores e negocia√ß√£o automatizada</a></li>
<li><a href="../pt463665/index.html">1,1 bilh√£o de viagens de t√°xi: cluster ClickHouse de 108 n√∫cleos</a></li>
<li><a href="../pt463667/index.html">Floresta n√£o se rende √† pesquisa de tecnologia, mas engenheiros revidam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>