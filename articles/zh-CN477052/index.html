<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏾 🧚🏻 🌳 一个简单示例的Reactor，WebFlux，Kotlin协程或异步 ⤴️ 🤸🏿 🗒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在现代世界中，许多服务大部分都“无所作为”。 他们的任务减少为对其他数据库/服务/缓存的请求，并根据各种规则和各种业务逻辑汇总所有这些数据。 因此，出现诸如Golang之类的语言，并具有方便的内置竞争系统使组织非阻塞代码变得容易也就不足为奇了。 


 在JVM世界中，事情要复杂一些。 有大量的框架...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>一个简单示例的Reactor，WebFlux，Kotlin协程或异步</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/477052/"><img src="https://habrastorage.org/webt/oc/vm/jy/ocvmjybd42pjwnaqjaxeyz_dxlo.png"><br><br><p> 在现代世界中，许多服务大部分都“无所作为”。 他们的任务减少为对其他数据库/服务/缓存的请求，并根据各种规则和各种业务逻辑汇总所有这些数据。 因此，出现诸如Golang之类的语言，并具有方便的内置竞争系统使组织非阻塞代码变得容易也就不足为奇了。 </p><br><p> 在JVM世界中，事情要复杂一些。 有大量的框架和库在使用时会阻塞线程。 因此，stdlib本身有时可以做同样的事情。 而且在Java中，没有类似于Golang中的goroutines的类似机制。 </p><br><p> 但是，JVM正在积极开发，并且出现了许多有趣的机会。 有带有协程的Kotlin，它们的用法与Gorang goroutines非常相似（尽管它们以完全不同的方式实现）。 有JEP Loom，它将在将来将纤维引入JVM。 最受欢迎的Web框架之一-Spring最近增加了在Webflux上创建完全非阻塞服务的功能。 借助最近发布的Spring boot 2.2，与Kotlin的集成甚至更好。 </p><br><p> 我建议以一个用于将钱从一张卡转移到另一张卡的小型服务的示例为例，在Spring boot 2.2和Kotlin上编写一个应用程序，以与多个外部服务集成。 </p><a name="habracut"></a><br><p> 如果您已经熟悉Java，Kotlin，Gradle，Spring，Spring boot 2，Reactor， <s>Webflux，Tomcat，Netty，Kotlinoroutines，Gradle Kotlin DSL甚至拥有博士学位，那将是一个很好的选择。</s> 但是，如果没有，那没关系。 该代码将得到最大程度的简化，即使您不是来自JVM世界，也希望您能理解所有内容。 </p><br><p> 如果您打算自己编写服务，请确保已安装所需的一切： </p><br><ul><li>  Java 8+ </li><li>  Docker和Docker Compose; </li><li>  cURL，最好是<a href="https://stedolan.github.io/jq/download/">jq</a> ； </li><li> 吉特 </li><li> 最好是Kotlin的IDE（Intellij Idea，Eclipse，VS， <s>vim</s>等）。 但是在笔记本电脑上也是可以的。 </li></ul><br><p> 示例将包含服务中实现的空白和已编写的实现。 首先，运行安装和组装，并仔细查看服务及其API。 </p><br><blockquote>服务和API本身的示例仅用于说明目的；请勿将所有<code>AS IS</code>转移到您的产品上！ </blockquote><p> 首先，我们使用自己的服务克隆存储库，并进行集成，然后转到目录： </p><br><pre> <code class="plaintext hljs">git clone https://github.com/evgzakharov/spring-demo-services &amp;&amp; cd spring-demo-services</code> </pre> <br><p> 在单独的终端中，我们使用<code>gradle</code>收集所有应用程序，在构建成功之后，所有服务将使用<code>gradle</code> <code>docker-compose</code>启动。 </p><br><pre> <code class="plaintext hljs">./gradlew build &amp;&amp; docker-compose up</code> </pre> <br><p> 在下载并安装所有内容后，请考虑一个包含服务的项目。 </p><br><img src="https://habrastorage.org/webt/go/mp/mb/gompmbrgtjwsuz9pnpbaxbuksg8.png"><br><p> 服务入口（演示服务）将收到带有令牌，转账卡号和卡间转账金额的请求： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"authToken"</span></span>: <span class="hljs-string"><span class="hljs-string">"auth-token1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardFrom"</span></span>: <span class="hljs-string"><span class="hljs-string">"55593478"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardTo"</span></span>: <span class="hljs-string"><span class="hljs-string">"55592020"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"amount"</span></span>: <span class="hljs-string"><span class="hljs-string">"10.1"</span></span> }</code> </pre> <br><p> 根据<code>authToken</code>令牌， <code>authToken</code>需要转到<code>AUTH</code>服务并获取<code>userId</code> ，然后可以使用它向<code>USER</code>发出请求并提取有关该用户的所有其他信息。  <code>AUTH</code>还将返回有关我们可以访问这三个服务中的哪一个的信息。 来自<code>AUTH</code>示例响应： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"userId"</span></span>: <span class="hljs-number"><span class="hljs-number">158</span></span>, <span class="hljs-attr"><span class="hljs-attr">"cardAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"paymentAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"userAccess"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p> 要在卡之间进行转移，请首先使用卡中的每个<code>CARD</code> 。 响应请求，我们将收到<code>cardId</code> ，然后与他们一起向<code>PAYMENT</code>发送请求并进行转帐。 最后-我们再次使用<code>fromCardId</code>向<code>PAYMENT</code>发送请求，并找出当前余额。 </p><br><p> 为了模拟较小的服务延迟，将TIMEOUT环境变量的值引发到所有容器中，其中将响应延迟设置为毫秒。 为了使来自<code>AUTH</code>的响应多样化，可以更改<code>SUCCESS_RATE</code>的值，该值控制对服务进行<code>true</code>响应的可能性。 </p><br><p>  Docker-compose.yaml文件： </p><br><pre> <code class="plaintext hljs">version: '3' services: service-auth: build: service-auth image: service-auth:1.0.0 environment: - SUCCESS_RATE=1.0 - TIMEOUT=100 ports: - "8081:8080" service-card: build: service-card image: service-card:1.0.0 environment: - TIMEOUT=100 ports: - "8082:8080" service-payment: build: service-payment image: service-payment:1.0.0 environment: - TIMEOUT=100 ports: - "8083:8080" service-user: build: service-user image: service-user:1.0.0 environment: - TIMEOUT=100 ports: - "8084:8080"</code> </pre> <br><p> 对于所有服务，都完成了从8081到8084的端口转发，可以轻松直接到达它们。 </p><br><p> 让我们继续编写<code>Demo service</code> 。 首先，让我们尝试将实现编写得尽可能笨拙，不要出现异步和并发。 为此，请使用Spring boot 2.2.1，Kotlin和一个空白的服务。 我们克隆存储库，然后转到<code>spring-mvc-start</code>分支： </p><br><pre> <code class="plaintext hljs">git clone https://github.com/evgzakharov/demo-service &amp;&amp; cd demo-service &amp;&amp; git checkout spring-mvc-start</code> </pre> <br><p> 转到<code>demo.Controller</code>文件。 它具有必须为其编写实现的唯一空的<code>processRequest</code>方法。 </p><br><pre> <code class="kotlin hljs"> <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { .. }</code> </pre> <br><p> 该方法的入口处将收到卡之间的转移请求。 </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceRequest</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authToken: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFrom: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardTo: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount: BigDecimal )</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">对于那些不熟悉Spring的人</b> <div class="spoiler_text"><p>  Spring有一个基于注释的内置DI。  DemoController带有特殊的<code>RestController</code>注释：除了在DI中注册Bean之外，它还添加了其作为控制器的处理。  PostProcessor查找标记有<code>PostMapping</code>注释的所有方法，并使用<code>POST</code>方法将它们添加为服务的端点。 </p><br><p> 处理程序还为DemoController创建一个代理类，其中所有必需的参数都传递给<code>processRequest</code>方法。 在我们的例子中，这只是一个带有<code>@RequestBody</code>批注的参数。 因此，在代理中，将使用反序列化到<code>ServiceRequest</code>类中的JSON内容来调用此方法。 </p></div></div><br><p> 为了简化，已经完成了与其他服务集成的所有方法，您只需要正确连接它们即可。 只有五种方法，每个动作一个。 对其他服务本身的调用是在Spring <code>RestTemplate</code> <strong>阻塞</strong>调用上实现的。 </p><br><p> 调用<code>AUTH</code>示例方法： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAuthInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: AuthInfo { log.info(<span class="hljs-string"><span class="hljs-string">"getAuthInfo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restTemplate.getForEntity(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${demoConfig.auth}</span></span></span><span class="hljs-string">/{token}"</span></span>, AuthInfo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">token) .body ?: throw RuntimeException</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"couldn't find user by token='</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$token</span></span></span><span class="hljs-string">'"</span></span>) }</code> </pre> <br><p> 让我们继续该方法的实现。 注释说明了该过程以及在输出中期望得到什么响应： </p><br><pre> <code class="kotlin hljs"> <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-comment"><span class="hljs-comment">//1) get auth info from service by token -&gt; userId //2) find user info by userId from 1. //3) 4) find cards info for each card in serviceRequest // 5) make transaction for known cards by calling sendMoney(id1, id2, amount) // 6) after payment get payment info by fromCardId TODO("return SuccessResponse") // SuccessResponse( // amount = , // userName = , // userSurname = , // userAge = // ) }</span></span></code> </pre> <br><p> 首先，我们尽可能简单地实现该方法，而不考虑<code>AUTH</code>可以拒绝我们访问其他服务。 尝试自己做。 事实证明（或切换到<code>spring-mvc</code>分支后），您可以按以下方式检查服务的运行情况： </p><br><div class="spoiler">  <b class="spoiler_title">从spring-mvc分支实现</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfo = getAuthInfo(serviceRequest.authToken) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = findUser(authInfo.userId) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = findCardInfo(serviceRequest.cardFrom) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfo = findCardInfo(serviceRequest.cardTo) sendMoney(cardFromInfo.cardId, cardToInfo.cardId, serviceRequest.amount) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = getPaymentInfo(cardFromInfo.cardId) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p> 启动服务（从demo-service文件夹中）： </p><br><pre> <code class="plaintext hljs">./gradlew bootRun</code> </pre> <br><p> 我们向端点发送请求： </p><br><pre> <code class="plaintext hljs">./demo-request.sh</code> </pre> <br><p> 作为响应，我们得到如下信息： </p><br><pre> <code class="plaintext hljs">➜ demo-service git:(spring-mvc) ✗ ./demo-request.sh + curl -XPOST http://localhost:8080/ -d @demo-payment-request.json -H 'Content-Type: application/json; charset=UTF-8' + jq . % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 182 0 85 100 97 20 23 0:00:04 0:00:04 --:--:-- 23 { "amount": 989.9, "userName": "Vasia", "userSurname": "Pupkin", "userAge": 18, "status": true }</code> </pre> <br><p> 为了实施该服务，总共需要发出6个请求。 考虑到每个响应的延迟为100 ms，总时间不能少于600 ms。 实际上，考虑到所有开销，结果约为700毫秒。 到目前为止，代码非常简单，如果我们现在想添加<code>AUTH</code>响应检查以访问其他服务，这将不难做到（就像其他任何重构一样）。 </p><br><p> 但是，让我们考虑一下如何加快查询执行速度。 如果您不考虑对<code>AUTH</code>响应的验证，那么我们有两个独立的任务： </p><br><ul><li> 获取<code>userId</code>并向<code>USER</code>请求数据； </li><li> 接收每张卡的<code>cardId</code> ，进行付款并接收总金额。 </li></ul><br><p> 这些任务可以彼此独立地执行。 然后，总的执行时间将取决于最长的调用链（在这种情况下为第二个），总共将执行300 ms + X ms的开销。 </p><br><p> 鉴于调用本身是阻塞的，执行并行请求的唯一方法是在单独的线程上运行它们。 您可以为每个调用创建一个单独的线程，但这将非常昂贵。 另一种方法是在ThreadPool上运行任务。 乍一看，这样的解决方案看起来很合适，而且时间会真正减少。 例如，我们可以在CompletableFuture上执行查询。 它允许您通过使用<code>async</code>后缀调用方法来运行后台任务。 并且，如果在调用方法时未指定特定的ThreadPool，则将在<code>ForkJoinPool.commonPool()</code>上启动任务。 尝试自己编写一个实现，或者转到<code>spring-mvc-async</code>分支。 </p><br><div class="spoiler">  <b class="spoiler_title">从spring-mvc-async分支实现</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfoFuture = CompletableFuture.supplyAsync { getAuthInfo(serviceRequest.authToken) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoFuture = authInfoFuture.thenApplyAsync { findUser(it.userId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = CompletableFuture.supplyAsync { findCardInfo(serviceRequest.cardFrom) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfo = CompletableFuture.supplyAsync { findCardInfo(serviceRequest.cardTo) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> waitAll = CompletableFuture.allOf(cardFromInfo, cardToInfo) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoFuture = waitAll .thenApplyAsync { sendMoney(cardFromInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId, cardToInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId, serviceRequest.amount) } .thenApplyAsync { getPaymentInfo(cardFromInfo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().cardId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = paymentInfoFuture.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = userInfoFuture.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p> 如果现在测量请求时间，则该时间将在360毫秒左右。 与原始版本相比，总时间减少了将近2倍。 代码本身已经变得有些复杂，但是到目前为止，对其进行修改仍然不难。 如果在这里我们要添加来自<code>AUTH</code>的响应检查，那么这并不困难。 </p><br><p> 但是，如果我们对服务本身有大量传入请求怎么办？ 说大约1000个并发请求？ 通过这种方法，很快就会发现所有ThreadPool线程都在忙于进行阻塞调用。 我们得出的结论是当前版本也不适合。 </p><br><p> 剩下的事情仅仅是对服务本身进行一些处理。 您可以修改查询并使它们成为非阻塞。 然后，调用服务的方法将返回CompletableFuture，Flux，Observable，Deferred，Promise或在其上构建期望链的类似对象。 使用这种方法，我们不需要在单独的流上进行调用-拥有一个我们已经借来的用于处理请求的（或至少一个小的单独的流池）就足够了。 </p><br><p> 我们现在可以承受服务的沉重负担吗？ 要回答这个问题，请仔细阅读Tomcat，它在启动程序<code>org.springframework.boot:spring-boot-starter-web</code>中的Spring boot 2.2.1中使用。 它被构建为将ThreadPool中的线程分配给每个传入请求进行处理。 在没有自由流通的情况下，新的请求将成为等待的“队列”。 但是我们的服务本身仅向其他服务发送请求。 分配一个完整的流，并阻塞它，直到每个人的答案都出现为止，看上去，这是多余的。 </p><br><p> 幸运的是，Spring最近使使用基于Netty或Undertow的非阻塞Web服务器成为可能。 为此，您只需要将<code>spring-boot-starter-web</code>更改为<code>spring-boot-starter-webflux</code>并略微更改处理请求的方法，即可在Mono中“包装”请求和响应。 这是由于Webflux是基于Reactor构建的，因此现在您需要使用该方法来构建Mono转换链。 <br></p><p> 尝试编写自己的方法的非阻塞实现。 为此，请转到<code>spring-webflux-start</code>分支。 请注意，Spring Boot的启动程序已更改，现在使用带有Webflux的版本，并且对已重写为使用非阻塞<code>WebClient</code>其他服务的请求的实现也已更改。 </p><br><p> 调用AUTH的示例方法： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAuthInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Mono&lt;AuthInfo&gt; { log.info(<span class="hljs-string"><span class="hljs-string">"getAuthInfo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WebClient.create().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() .uri(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${demoConfig.auth}</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$token</span></span></span><span class="hljs-string">"</span></span>) .retrieve() .bodyToMono(AuthInfo::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) }</span></span></code> </pre> <br><p> 第一个示例的实现在注释中插入到<code>processRequest</code>方法的内容中。 尝试自己在Reactor上重写它。 像上次一样，首先制作版本而不考虑<code>AUTH</code>的检查，然后查看添加检查的难度： </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Mono</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Mono&lt;Response&gt; { <span class="hljs-comment"><span class="hljs-comment">// val authInfo = getAuthInfo(serviceRequest.authToken) // // val userInfo = findUser(authInfo.userId) // // val cardFromInfo = findCardInfo(serviceRequest.cardFrom) // val cardToInfo = findCardInfo(serviceRequest.cardTo) // // sendMoney(cardFromInfo.cardId, cardToInfo.cardId, serviceRequest.amount) // // val paymentInfo = getPaymentInfo(cardFromInfo.cardId) // // log.info("result") // // return SuccessResponse( // amount = paymentInfo.currentAmount, // userName = userInfo.name, // userSurname = userInfo.surname, // userAge = userInfo.age // ) TODO() }</span></span></code> </pre> <br><p> 处理<code>spring-webflux</code>之后，您可以从<code>spring-webflux</code>与我的实现进行比较： </p><br><div class="spoiler">  <b class="spoiler_title">从spring-webflux分支实现</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Mono</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Mono&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cacheRequest = serviceRequest.cache() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoMono = cacheRequest.flatMap { getAuthInfo(it.authToken) }.flatMap { findUser(it.userId) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfoMono = cacheRequest.flatMap { findCardInfo(it.cardFrom) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfoMono = cacheRequest.flatMap { findCardInfo(it.cardTo) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoMono = cardFromInfoMono.zipWith(cardToInfoMono) .flatMap { (cardFromInfo, cardToInfo) -&gt; cacheRequest.flatMap { request -&gt; sendMoney(cardFromInfo.cardId, cardToInfo.cardId, request.amount).map { cardFromInfo } } }.flatMap { getPaymentInfo(it.cardId) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userInfoMono.zipWith(paymentInfoMono) .map { (userInfo, paymentInfo) -&gt; log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) } }</code> </pre> </div></div><br><p> 同意现在编写实现（与以前的阻止方法相比）变得更加困难。 而且，如果我们想从<code>AUTH</code>添加“忘记的”支票，那么这将不是一件容易的事。 </p><br><p> 这是反应性方法的本质。 这对于构建无分支的处理链非常有用。 但是，如果出现分支，则代码不再那么简单。 </p><br><p>  Kotlin协程对于任何异步/反应式代码都非常友好，可以为您提供帮助。 此外， <a href="">Reactor</a> ， <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-jdk8">CompletableFuture</a>等还有大量书面包装。 但是，即使找不到合适的工具，也可以随时使用特殊的<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html">构建器</a>自己编写。 </p><br><p> 让我们自己重写协程的实现。 为此，请转到<code>spring-webflux-coroutines-start</code>分支。 必需的依赖项已添加到build.gradle.kts中： </p><br><pre> <code class="kotlin hljs">implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-core:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>) implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-reactive:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>) implementation(<span class="hljs-string"><span class="hljs-string">"org.jetbrains.kotlinx:kotlinx-coroutines-reactor:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$kotlinCoroutinesVersion</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><p> 并且<code>processRequest</code>方法有所变化： </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response = coroutineScope { <span class="hljs-comment"><span class="hljs-comment">//TODO() }</span></span></code> </pre> <br><p> 它不再需要Mono并可以简单地转换为暂停函数（由于Spring和Kotlin的集成）。 考虑到我们将在该方法中创建其他协程，我们将需要创建一个子侦察员<code>coroutineScope</code> （出于对创建附加范围的原因的理解，请参见Roman Elizarov的有关<a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952">结构化并发</a>的文章）。 请注意，其他服务电话完全没有改变。 它们返回相同的Mono，可以在其上调用awaitFirst <code>suspend</code>方法以“等待”查询结果。 </p><br><p> 如果协程对于您来说仍然是一个新概念，那么有一个很好的<a href="">指南</a> ，里面有详细的说明。 尝试编写您自己的<code>processRequest</code>方法实现，或转到<code>spring-webflux-coroutines</code>分支： </p><br><div class="spoiler">  <b class="spoiler_title">从spring-webflux-coroutines分支实现</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestBody</span></span></span></span><span class="hljs-function"><span class="hljs-params"> serviceRequest: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServiceRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Response = coroutineScope { log.info(<span class="hljs-string"><span class="hljs-string">"start"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfoDeferred = async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> authInfo = getAuthInfo(serviceRequest.authToken).awaitFirst() findUser(authInfo.userId).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfoDeferred = async { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfoDeferred = async { findCardInfo(serviceRequest.cardFrom).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardToInfoDeferred = async { findCardInfo(serviceRequest.cardTo).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardFromInfo = cardFromInfoDeferred.await() sendMoney(cardFromInfo.cardId, cardToInfoDeferred.await().cardId, serviceRequest.amount).awaitFirst() getPaymentInfo(cardFromInfo.cardId).awaitFirst() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userInfo = userInfoDeferred.await() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paymentInfo = paymentInfoDeferred.await() log.info(<span class="hljs-string"><span class="hljs-string">"result"</span></span>) SuccessResponse( amount = paymentInfo.currentAmount, userName = userInfo.name, userSurname = userInfo.surname, userAge = userInfo.age ) }</code> </pre> </div></div><br><p> 您可以将代码与反应性方法进行比较。 使用协程，您不必事先考虑所有分支点。 我们可以只调用<code>await</code>方法，并在正确的位置以<code>async</code>方式分支出异步任务。 该代码与原始的直接版本尽可能保持相似，这根本不难更改。 一个重要的因素是协程简单地嵌入到响应代码中。 </p><br><p> 您甚至可能更喜欢被动式方法来完成此任务，但是许多接受调查的人发现它比较困难。 通常，两种方法都可以解决它们的问题，您可以使用自己喜欢的一种。 顺便说一下，最近在Kotlin，也有机会使用Flow创建“冷”协程，这与Reactor非常相似。 没错，它们仍处于试验阶段，但是现在您可以查看当前的实现并在您的代码中进行尝试。 </p><br><p> 我想在这里结束，最后留下有用的链接： </p><br><ul><li>  <a href="">协程指南</a> </li><li>  <a href="">协程反应器</a> </li><li>  <a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/integration/kotlinx-coroutines-jdk8">协程完整的未来</a> </li><li>  <a href="https://www.youtube.com/results%3Fsearch_query%3D%25D0%25B5%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2580%25D0%25BE%25D0%25B2%2B%25D1%2580%25D0%25BE%25D0%25BC%25D0%25B0%25D0%25BD%2B%25D0%25BA%25D0%25BE%25D1%2580%25D1%2583%25D1%2582%25D0%25B8%25D0%25BD%25D1%258B">罗马·伊里扎洛夫（Roman Elizarov）关于协程</a> </li><li>  <a href="https://medium.com/%40elizarov/kotlin-flows-and-coroutines-256260fb3bdb">Kotlin流程和协程</a> </li><li>  <a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952">结构化并发</a> </li><li>  <a href="https://blog.karumi.com/spring-boot-loves-kotlin/">春季靴爱Kotlin</a> </li></ul><br><p> 希望您感兴趣，并且您设法自己为所有方法编写了该方法的实现。 而且，当然，我想相信您喜欢带有协程的选项more =） </p><br><p> 感谢所有读完本书的人！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN477052/">https://habr.com/ru/post/zh-CN477052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN477042/index.html">蒙特卡罗二十一点策略优化</a></li>
<li><a href="../zh-CN477044/index.html">集成信息系统的End-2-End测试自动化。 第2部分。技术</a></li>
<li><a href="../zh-CN477046/index.html">.Net在Raiffeisenbank的聚会28/11 +广播</a></li>
<li><a href="../zh-CN477048/index.html">一家市值550亿美元的公司为什么考虑离开交易所</a></li>
<li><a href="../zh-CN477050/index.html">黑色星期五2019用于视频监控和云。</a></li>
<li><a href="../zh-CN477054/index.html">Webasto宣布模块化汽车电池系统</a></li>
<li><a href="../zh-CN477058/index.html">企业敏捷俄罗斯在Raiffeisenbank 26/11 +广播</a></li>
<li><a href="../zh-CN477060/index.html">DataArt将主持圣彼得堡国立大学Matmekh系统编程系主任Andrei Terekhov的公开演讲</a></li>
<li><a href="../zh-CN477062/index.html">优化编译器如何工作</a></li>
<li><a href="../zh-CN477072/index.html">客户开发或如何成功推出产品？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>