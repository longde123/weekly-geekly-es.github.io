<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèø üöí üå¶Ô∏è √úber Linux-Treiberoptionen oder wie ich das Wochenende verbracht habe üßëüèΩ‚Äçü§ù‚Äçüßëüèª üéΩ üîµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Wir sind faul und neugierig" 


 Diesmal war der Grund f√ºr den Beitrag ein Artikel in einem guten Magazin, das dem Linux-Betriebssystem gewidmet war ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úber Linux-Treiberoptionen oder wie ich das Wochenende verbracht habe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431860/"><h3>  "Wir sind faul und neugierig" </h3><br><img src="https://habrastorage.org/webt/sh/n6/_h/shn6_hdnwzoz1wv0ifrfabhtbpg.jpeg"><br><br>  Diesmal war der Grund f√ºr den Beitrag ein Artikel in einem guten Magazin, das dem Linux-Betriebssystem gewidmet war (im Folgenden als L bezeichnet), in dem der angezogene "Experte" den Treiber lobte, der das LCD mit dem Raspbery-Board verband.  Da solche Dinge (Verbindung, nicht das Betriebssystem) in den Bereich meiner beruflichen Interessen fallen, habe ich den Artikel aufmerksam durchgesehen, dann den eigentlichen Text des ‚ÄûTreibers‚Äú gefunden und war leicht √ºberrascht, dass die IT gelobt werden konnte.  Nun, im Allgemeinen kann das Expertenlevel bestimmt werden, schon allein deshalb, weil er das Programm hartn√§ckig als Fahrer bezeichnet hat, obwohl es keineswegs so ist.  Es scheint, und Feigen mit ihm, Sie wissen nie, was jemand f√ºr sich selbst schreibt, aber dies √∂ffentlich zu ver√∂ffentlichen - "Ich wusste nicht, dass es m√∂glich ist." <br><br>  Besonders erfreulich war die Tatsache, dass die Ger√§teadresse auf dem I2C-Bus direkt im Programmtext festgelegt wurde und f√ºr deren √Ñnderung eine Neukompilierung erforderlich war (es ist gut, dass nicht der gesamte Kernel).  √úbrigens ist mir aufgefallen, dass in den Foren zu L die beliebteste Antwort auf alle Fragen zu Softwareproblemen darin besteht, "die neueste Kernel-Version neu zu erstellen".  Dieser Ansatz erscheint mir etwas seltsam, wahrscheinlich wei√ü ich nichts.  Dennoch stellte sich die Frage, wie die Parametrisierung des Treibers tats√§chlich in A implementiert wird (innen, nicht au√üen - alles ist einfach und klar), der Antwort, der dieser Beitrag gewidmet ist. <br><a name="habracut"></a><br>  Es ist nicht so, dass ich st√§ndig Treiber f√ºr L geschrieben habe, aber mit dem gesamten Prozess bin ich vertraut und Google hat vage Erinnerungen best√§tigt, dass es eine Reihe von Makros gibt, die beim Erstellen des Modulquellcodes verwendet werden sollten, um Betriebsparameter an ihn √ºbergeben zu k√∂nnen, z. B. die Ger√§teadresse an zum Bus.  Trotzdem wurde die Mechanik des Prozesses selbst nirgendwo beschrieben.  Ich habe den gleichen Text in zahlreichen Links gesehen (√ºbrigens eine interessante Frage - warum dies tun, dh den Text eines anderen auf meine Ressource setzen - ich verstehe die Bedeutung dieser Operation nicht wirklich), in der die obigen Makros beschrieben wurden.  Ich fand keine einzige Erw√§hnung des Mechanismus zur Durchf√ºhrung der Operation, f√ºr ein anderes bekanntes Betriebssystem (Windows) m√ºsste ich eine Tatsache angeben und mich darauf beschr√§nken, aber einer der Vorteile von A ist die Verf√ºgbarkeit von Quelltexten und die F√§higkeit, eine Antwort auf jede Frage zu seiner internen Struktur zu finden. was wir tun werden.  Ich stelle sofort fest, dass ich versuchen werde, die Informationen, die Sie aus anderen Quellen erhalten k√∂nnen, nicht zu duplizieren, und mich nur auf das beschr√§nken werde, was zum Verst√§ndnis des Textes erforderlich ist. <br><br>  Bevor Sie sich jedoch die Quelle ansehen, werden wir zun√§chst ein wenig dar√ºber nachdenken, aber wie w√ºrden wir es tun, wenn wir eine √§hnliche Aufgabe bekommen w√ºrden (und pl√∂tzlich, nach diesem Beitrag, werden sie mich zu den L-Bergleuten einladen, und Sie werden es nicht ablehnen).  Es besteht also die M√∂glichkeit, ein Modul zu erstellen - eine bestimmte speziell entwickelte Programmeinheit, die zur Ausf√ºhrung mit einem Systemdienstprogramm (Insmode - im Folgenden I) in den Speicher geladen werden kann, w√§hrend eine Zeichenfolge als Startparameter √ºbergeben wird.  Diese Zeile kann streng definierte lexikalische Einheiten enthalten, deren Formatbeschreibung beim Erstellen des Quelltextes des Moduls angegeben wird. Diese Einheiten enthalten Informationen, mit denen Sie den Wert der internen Variablen dieses Moduls √§ndern k√∂nnen. <br><br>  Betrachten wir die Art und Weise der Beschreibung der obigen lexikalischen Einheiten genauer. Wir ben√∂tigen diese, um verschiedene L√∂sungen zu betrachten.  Die Analyseeinheit wird durch Aufrufen des Makros bestimmt, das √ºber die erforderlichen Informationen informiert wird - den Namen der Variablen, die w√§hrend des Einrichtungsprozesses ge√§ndert werden soll, ihren externen Namen (normalerweise derselbe wie der vorherige), den Typ der Variablen aus der begrenzten Menge und Zugriffsrechte auf die Variable im Stil von rw-rw-rw.  Zus√§tzlich kann eine (optionale) Textzeichenfolge angegeben werden, die die Variable beschreibt.  Offensichtlich sind diese Informationen notwendig und ausreichend (in Verbindung mit den Regeln f√ºr den Entwurf syntaktischer Einheiten - Trennzeichen und Token), um den Parser der in Form einer Textzeichenfolge angegebenen Parameterliste zu erstellen, lassen jedoch Raum f√ºr die Implementierung der Funktionsverteilung zwischen den Prozessteilnehmern. <br><br>  Um das Modul zu konfigurieren, ben√∂tigen wir: <br><br><ol><li>  Form (nun, dies befindet sich in der Kompilierungsphase, Sie k√∂nnen es tun, wie Sie m√∂chten, obwohl es immer noch interessant ist, wie) und eine Tabelle mit den oben genannten Einstellungen speichern. </li><li>  Analyse der Eingabeparameter gem√§√ü dieser Tabelle und </li><li>  Nehmen Sie √Ñnderungen an bestimmten Speicherbereichen vor, die dem Ergebnis des Parsens einer syntaktischen Einheit entsprechen. </li></ol><br>  Wir werden ein bisschen im Stil von "Wenn ich der Regisseur w√§re" denken und m√∂gliche Implementierungen finden.  Wie wir das √§hnliche Verhalten des Systemdienstprogramms und des Moduls implementieren k√∂nnten - wir werden mit der Analyse der Optionen in zunehmender Komplexit√§t beginnen. <br><br>  Die erste L√∂sung ist, dass das Dienstprogramm And fast nichts tut, nur das angegebene Modul aufruft und die verbleibenden Parameter im Befehlszeilenstil an das Modul √ºbertr√§gt. Das Modul analysiert sie bereits, wobei es sich auf die darin verf√ºgbaren Informationen st√ºtzt und die erforderlichen √Ñnderungen vornimmt.  Diese L√∂sung ist einfach, verst√§ndlich und durchaus machbar, aber der folgende Umstand sollte ber√ºcksichtigt werden: Die Analyse der Parameter sollte in keiner Weise dem Willen des Autors des Moduls √ºberlassen werden, da dies ihm inakzeptablen Platz bietet und schlie√ülich zwei Programmierer immer drei Parseroptionen schreiben.  Und so gingen wir ihm entgegen und lie√üen ihm Parameter eines unbestimmten Typs zu, die eine Textzeichenfolge als Wert haben. <br><br>  Daher sollte ein bestimmter Standardparser automatisch in den Text des Moduls aufgenommen werden. Dies ist auf der Ebene der Makrosubstitution einfach zu implementieren. <br><br>  Diese L√∂sung hat zwei Nachteile: <br><br><ol><li>  Es ist nicht klar, warum wir es √ºberhaupt brauchen. Und Sie k√∂nnen das Modul sofort mit Parametern √ºber die Befehlszeile aufrufen. </li><li>  Der Modulcode (Initialisierungsteil) muss alle drei Abschnitte der erforderlichen Informationen enthalten. Diese Informationen sind nur erforderlich, wenn das Modul gestartet wird und in Zukunft nicht mehr verwendet wird. Es nimmt immer Platz ein.  Machen Sie sofort eine Reservierung, dass diese Informationen notwendigerweise Speicherplatz in der Datei beanspruchen, aber beim Laden des Moduls m√∂glicherweise nicht in den Speicher gelangen, wenn alles sorgf√§ltig ausgef√ºhrt wird.  Um genau das zu tun, erinnern wir uns an die Direktiven _init und _initdata (√ºbrigens, aber wie sie funktionieren, m√ºssten wir es herausfinden - das ist das Thema des n√§chsten Beitrags - werden Sie sich darauf freuen?).  Im letzteren Fall sind die Abschnitte 2 und 3 der Informationen in der Datei eindeutig redundant, da in vielen Modulen derselbe Code vorhanden ist, was b√∂swillig gegen das DRY-Prinzip verst√∂√üt. </li></ol><br>  Aufgrund der festgestellten M√§ngel ist die Umsetzung dieser Option h√∂chst unwahrscheinlich.  Dar√ºber hinaus ist unklar, warum dann im Makro Informationen √ºber den Parametertyp festgelegt werden sollen, da das Modul selbst sehr gut wei√ü, was es √§ndert (obwohl es f√ºr den Parser bei der √úberpr√ºfung der Parameter erforderlich sein kann).  Die Gesamtbewertung der Wahrscheinlichkeit einer solchen Entscheidung betr√§gt 2-3 Prozent. <br><br>  Der notwendige Exkurs √ºber den bekannten Nachteil Nummer 2 - Ich wurde als Spezialist in jenen Tagen gegr√ºndet, als 256 KByte RAM ausreichten, um 4 Workstations zu organisieren, 56 KByte ein Dual-Tasking-Betriebssystem hatten und ein Single-Tasking-Betriebssystem mit 16 KByte zu arbeiten begann.  Nun, 650 kb, was f√ºr jedes Programm ausreichen sollte, waren im Allgemeinen etwas aus dem Bereich der unwissenschaftlichen Fiktion.  Daher bin ich es gewohnt, RAM als knappe Ressource zu betrachten, und ich lehne seine verschwenderische Verwendung √§u√üerst ab, wenn es nicht durch einen Notfall verursacht wird (in der Regel Leistungsanforderungen), und in diesem Fall beobachte ich eine solche Situation nicht.  Da sich die meisten meiner Leser in unterschiedlichen Realit√§ten gebildet haben, k√∂nnen Sie Ihre eigenen Einsch√§tzungen √ºber die Pr√§ferenz dieser oder jener Option haben. <br><br>  Die zweite L√∂sung - der Parser selbst wird an AND √ºbertragen, das die extrahierten Daten an das Modul (seinen Initialisierungsteil) √ºbertr√§gt - Parameternummer und -wert.  Dann behalten wir die Einheitlichkeit der Parameter bei und reduzieren die Anforderungen an die Gr√∂√üe des Moduls.  Es bleibt die Frage, wie eine UND-Liste m√∂glicher Parameter bereitgestellt werden kann. Dies wird jedoch durch Makros bereitgestellt, indem eine vorbestimmte Struktur des Moduls und die Position des Blocks an einer bestimmten Stelle (Datei oder Speicher) erstellt werden.  Die L√∂sung ist besser als die vorherige, aber der √ºbersch√ºssige Speicher im Modul bleibt bestehen.  Im Allgemeinen gef√§llt mir die L√∂sung, weil mein Parser (der schlechter ist als alle anderen Programmierer, ich habe meinen eigenen Parser, nicht ohne Fehler, aber definitiv nicht schwerwiegend) nach diesem Schema arbeitet und die Nummer der identifizierten Regel und den Wert an das Hauptprogramm zur√ºckgibt Parameter.  Dennoch ist die Wahrscheinlichkeit, diese spezielle Option umzusetzen, nicht sehr hoch - 5 Prozent. <br><br>  Eine Unteroption der zweiten L√∂sung besteht darin, die extrahierten Parameter nicht in den Startteil des Moduls zu √ºbertragen, sondern direkt in den geladenen Arbeitsteil, beispielsweise √ºber ioctl - die Speicheranforderungen sind gleich.  Wir haben die einmalige M√∂glichkeit, Parameter "on the fly" zu √§ndern, was in anderen Versionen nicht implementiert ist.  Es ist nicht ganz klar, warum wir eine solche Funktion ben√∂tigen, aber sie sieht wundersch√∂n aus.  Der Nachteil ist, dass 1) Sie einen Teil des Funktionsbereichs im Voraus f√ºr eine m√∂glicherweise nicht verwendete Anforderung reservieren m√ºssen und 2) der Modifikatorcode st√§ndig im Speicher vorhanden sein muss.  Einsch√§tzung der Umsetzungswahrscheinlichkeit - Prozent 5. <br><br>  Die dritte L√∂sung besteht darin, auf Und auch die √Ñnderung der Parameter zu √ºbertragen.  Beim Laden des Bin√§rcodes des Moduls And kann es dann die Daten im Zwischenspeicher √§ndern und den Treibercode mit den ge√§nderten Parametern an den Ort der permanenten Bereitstellung laden oder diese √Ñnderungen direkt in dem Speicherbereich vornehmen, in den die Bin√§rdatei geladen wurde, und die in der Datei vorhandene Parametertabelle befindet sich im Speicher kann es sowohl laden als auch nicht belegen (denken Sie an die Anweisungen).  Die Entscheidung ist verantwortlich, sie erfordert wie die vorherige das Vorhandensein eines vordefinierten Kommunikationsbereichs zwischen dem Modul und AND, um die Beschreibung der Parameter zu speichern, reduziert jedoch die Anforderungen f√ºr √ºberm√§√üigen Speicher im Modul weiter.  Wir stellen sofort den Hauptnachteil einer solchen L√∂sung fest - die Unf√§higkeit, die Parameterwerte und ihre Konsistenz zu steuern, aber es gibt nichts zu tun.  Es ist eine ganz normale L√∂sung, h√∂chstwahrscheinlich 75 Prozent. <br><br>  Eine Variante der dritten L√∂sung - Informationen √ºber die Parameter werden nicht im Modul selbst gespeichert, sondern in einer Zusatzdatei, dann gibt es einfach keinen √ºbersch√ºssigen Speicher im Modul.  Im Prinzip kann das gleiche in der vorherigen Version gemacht werden, wenn das Modul den Konfigurationsteil enth√§lt, der UND w√§hrend des Startvorgangs verwendet wird, aber nicht in den RAM geladen wird, der den tats√§chlich ausf√ºhrbaren Teil des Moduls enth√§lt.  Im Vergleich zur vorherigen Version wurde eine zus√§tzliche Datei hinzugef√ºgt, und es ist unklar, wof√ºr wir bezahlen, aber m√∂glicherweise haben sie vor der Erfindung Initialisierungsanweisungen ausgef√ºhrt - 5 Prozent. <br><br>  Die restlichen 7 Prozent bleiben f√ºr andere Optionen √ºbrig, die ich mir nicht ausdenken konnte.  Nun, da sich unsere Fantasie ersch√∂pft hat (meine sicher, wenn es weitere Ideen gibt, fragen Sie bitte im Kommentar), werden wir beginnen, die Quelle von L. zu untersuchen. <br><br>  Zun√§chst stelle ich fest, dass anscheinend die Kunst, Quelltexte in Dateien zu verteilen, zusammen mit dem Betriebssystem, das in 16 KB passt, verloren gegangen ist, da die Verzeichnisstruktur, ihre Namen und Dateinamen ein wenig mehr als nichts mit dem Inhalt verbunden sind.  Angesichts des Vorhandenseins eingebetteter Einschl√ºsse wird das klassische Studium heruntergeladener Quellen mit Hilfe eines Editors zu einer seltsamen Aufgabe und wird unproduktiv.  Gl√ºcklicherweise gibt es ein charmantes Dienstprogramm Elixir, das online verf√ºgbar ist und das es Ihnen erm√∂glicht, kontextbezogene Suchen durchzuf√ºhren, und hier wird der Prozess viel interessanter und fruchtbarer.  Ich habe meine weiteren Forschungen auf der Website elixir.bootlin.com durchgef√ºhrt.  Ja, diese Seite ist im Gegensatz zu kernel.org keine offizielle Sammlung von Kernel-K√§se, aber hoffen wir, dass der Quellcode f√ºr sie identisch ist. <br><br>  Schauen wir uns zun√§chst ein Makro zur Bestimmung von Parametern an - erstens kennen wir seinen Namen und zweitens sollte es einfacher sein (ja, jetzt).  Es befindet sich in der Datei moduleparam.h - es ist durchaus vern√ºnftig, aber dies ist eine angenehme √úberraschung, wenn man bedenkt, was wir sp√§ter sehen werden.  Makro <br><br><pre><code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">0</span></span>}module_param(name,type,perm)</code> </pre> <br>  ist ein Wrapper vorbei <br><br><pre> <code class="cpp hljs"> {<span class="hljs-number"><span class="hljs-number">0</span></span>a}module_param_named(n,n,t,p)</code> </pre> <br>  - syntaktischer Zucker f√ºr den h√§ufigsten Fall.  Gleichzeitig wird aus irgendeinem Grund die Aufz√§hlung der zul√§ssigen Werte eines der Parameter, n√§mlich des Typs der Variablen, in den Kommentaren vor dem Wrapper-Text angegeben und nicht im zweiten Makro, das die Aufgabe wirklich erledigt und direkt verwendet werden kann. <br><br>  Makro {0a} enth√§lt einen Aufruf von drei Makros <br><br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">1</span></span>}param_check_#<span class="hljs-meta"><span class="hljs-meta">#t(n,&amp;v)</span></span></code> </pre> <br>  (Es gibt eine Reihe von Makros f√ºr alle g√ºltigen Typen) <br><br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">2</span></span>}module_param_cb(n,&amp;op##t,&amp;v,p)</code> </pre> <br>  und <br><br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">3</span></span>}__MODULE_PARM_TYPE(n,t)</code> </pre> <br>  (Achten Sie jedoch auf die Namen, Charme), und der erste von ihnen wird an anderer Stelle verwendet, dh die Empfehlungen von Occam und das KISS-Prinzip werden von den Machern von A ebenfalls k√ºhn vernachl√§ssigt - anscheinend eine Art Grundlage f√ºr die Zukunft.  Nat√ºrlich sind dies nur Makros, aber sie kosten nichts, aber trotzdem ... <br><br>  Das erste der drei Makros {1} √ºberpr√ºft, wie der Name schon sagt, die √úbereinstimmung von Parametertypen und Wraps <br><br><pre> <code class="cpp hljs">__param_check(n,p,t)</code> </pre> <br>  Beachten Sie, dass in der ersten Phase des Umbruchs die Ebene der Makroabstraktion abnimmt und in der zweiten Phase wahrscheinlich auf andere Weise zunimmt, und es scheint mir nur, dass dies einfacher und logischer sein k√∂nnte, insbesondere wenn man bedenkt, dass das durchschnittliche Makro nirgendwo anders verwendet wird.  Okay, lassen Sie uns einen anderen Weg einschlagen, um die Makroparameter im Sparschwein zu √ºberpr√ºfen und fortzufahren. <br><br>  Die n√§chsten beiden Makros generieren jedoch tats√§chlich ein Element der Parametertabelle.  Warum fragst du mich nicht zwei und nicht einen? Ich habe die Logik der Sch√∂pfer von L. schon lange nicht mehr verstanden. Aufgrund des unterschiedlichen Stils dieser beiden Makros, beginnend mit den Namen, wurde der zweite wahrscheinlich sp√§ter hinzugef√ºgt, um die Funktionalit√§t zu erweitern und die vorhandene Struktur zu √§ndern Es war unm√∂glich, weil sie es anfangs bereuten, einen Platz zur Angabe der Optionsparameter zugewiesen zu haben.  Das Makro {2} maskiert wie immer das Makro vor uns <br><br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">2</span></span>a}_module_param_call(MODULE_PARAM_PREFIX,n,ops,arg,p,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  (Es ist lustig, dass dieses Makro nirgendwo direkt aufgerufen wird, au√üer in 8250_core.c, wo es mit denselben zus√§tzlichen Parametern aufgerufen wird.) Letzteres erzeugt jedoch bereits den Quellcode. <br><br>  Eine kleine Bemerkung - w√§hrend der Suche stellen wir sicher, dass die Textnavigation gut funktioniert, aber es gibt zwei unangenehme Umst√§nde: Die Suche nach dem Namensfragment funktioniert nicht (check_param_ wurde nicht gefunden, obwohl check_param_byte gefunden wurde) und die Suche funktioniert nur bei Objektdeklarationen (die Variable wird dann nicht gefunden wird in dieser Datei von ctrF gefunden, aber die integrierte Suche nach Quelle wird nicht erkannt.  Nicht sehr ermutigend, da wir m√∂glicherweise nach einem Objekt au√üerhalb der aktuellen Datei suchen m√ºssen, aber "am Ende haben wir kein anderes". <br><br>  Als Ergebnis der Arbeit von {1} im Text des kompilierten Moduls in Gegenwart der folgenden zwei Zeilen <br><br><pre> <code class="cpp hljs">module_param_named(name, c, byte, <span class="hljs-number"><span class="hljs-number">0x444</span></span>); module_param_named(name1, i, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0x444</span></span>);</code> </pre> <br>  Ein Fragment des folgenden Typs wird angezeigt <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __param_str_name[] = <span class="hljs-string"><span class="hljs-string">"MODULE"</span></span> <span class="hljs-string"><span class="hljs-string">"."</span></span> <span class="hljs-string"><span class="hljs-string">"name"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kernel_param</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param_name</span></span></span><span class="hljs-class"> \ __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class">((__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">used__</span></span></span><span class="hljs-class">)) \ __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unused</span></span></span><span class="hljs-class">,__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">section__</span></span></span><span class="hljs-class"> ("__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param</span></span></span><span class="hljs-class">"),</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aligned</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> *)))) \ = {</span></span> __param_str_name, ((struct <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>), &amp;param_ops_byte, (<span class="hljs-number"><span class="hljs-number">0x444</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, { &amp;c } }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __UNIQUE_ID_nametype72[] \ __attribute__((__used__)) __attribute__((section(<span class="hljs-string"><span class="hljs-string">".modinfo"</span></span>), unused, aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) \ = <span class="hljs-string"><span class="hljs-string">"parmtype"</span></span> <span class="hljs-string"><span class="hljs-string">"="</span></span> <span class="hljs-string"><span class="hljs-string">"name"</span></span> <span class="hljs-string"><span class="hljs-string">":"</span></span> <span class="hljs-string"><span class="hljs-string">"byte"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __param_str_name1[] = <span class="hljs-string"><span class="hljs-string">"MODULE"</span></span> <span class="hljs-string"><span class="hljs-string">"."</span></span> <span class="hljs-string"><span class="hljs-string">"name1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kernel_param</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param_name1</span></span></span><span class="hljs-class"> \ __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class">((__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">used__</span></span></span><span class="hljs-class">)) \ __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unused</span></span></span><span class="hljs-class">,__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">section__</span></span></span><span class="hljs-class"> ("__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param</span></span></span><span class="hljs-class">"),</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aligned</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> *)))) \ = {</span></span> __param_str_name1, ((struct <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>), &amp;param_ops_int, (<span class="hljs-number"><span class="hljs-number">0x444</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, { &amp;i } }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __UNIQUE_ID_name1type73[] __attribute__((__used__)) \ __attribute__((section(<span class="hljs-string"><span class="hljs-string">".modinfo"</span></span>), unused, aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) \ = <span class="hljs-string"><span class="hljs-string">"parmtype"</span></span> <span class="hljs-string"><span class="hljs-string">"="</span></span> <span class="hljs-string"><span class="hljs-string">"name1"</span></span> <span class="hljs-string"><span class="hljs-string">":"</span></span> <span class="hljs-string"><span class="hljs-string">"int"</span></span>;</code> </pre> <br>  (Tats√§chlich werden dort einzeilige Dateien generiert, ich habe sie zur leichteren √úberpr√ºfung in Zeilen unterteilt.) Wir k√∂nnen sofort sagen, dass es keinen Hinweis auf die Aufnahme eines Parser-Programmabschnitts oder eines Moduls zum Zuweisen von Werten zu Parametern im Quelltext gibt, sodass die Optionen 1 und 2 dies k√∂nnen als von weiteren √úberlegungen ausgeschlossen betrachtet.  Das Vorhandensein spezieller Attribute f√ºr den Linker deutet sozusagen auf die Existenz eines Kommunikationsbereichs hin, der sich an einem vorbestimmten Ort befindet, √ºber den die Beschreibung der Parameter √ºbertragen wird.  Gleichzeitig stellen wir mit Verwirrung fest, dass keinerlei Beschreibung des generierten Blocks m√∂glicher Parameter in Form von Text vorliegt, der vom Parser-Modul verwendet werden k√∂nnte.  Es ist klar, dass gut geschriebener Code sich selbst dokumentiert, aber nicht in dem Ma√üe, wie dies wiederum die Wahrscheinlichkeit von Option 1 oder 2 nicht erh√∂ht, da der Parser vom Modulentwickler geschrieben wird. <br><br>  Die gleichzeitige Kombination der Attribute __used__ und nicht verwendet sieht in der zuletzt generierten Zeile lustig aus, insbesondere wenn Sie sich das n√§chste Fragment des Makrocodes ansehen <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> GCC_VERSION &lt; 30300 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __used __attribute__((__unused__)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __used __attribute__((__used__)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Was ist die Art von Beweglichkeit, die die Entwickler von A rauchen, die schmerzlich gewundene Art ihrer Gedanken, die im Code enthalten sind.  Ich wei√ü, dass Sie beide Formen des Attributschreibens verwenden k√∂nnen, aber warum dies in derselben Zeile tun - ich verstehe nicht. <br><br>  Ein weiteres interessantes Merkmal des resultierenden Codes kann festgestellt werden - das Duplizieren von Informationen √ºber den Variablennamen und seinen Typ.  Es ist noch nicht klar, warum dies getan wurde, aber die Tatsache selbst ist nicht zweifelhaft.  Nat√ºrlich sind diese Informationen koh√§rent, da sie im automatischen Modus erstellt wurden und diese Koh√§renz erhalten bleibt, wenn sich der Quelltext √§ndert (und das ist gut), aber sie werden dupliziert (und das ist schlecht). Vielleicht werden wir sp√§ter die Notwendigkeit einer solchen L√∂sung verstehen.  Au√üerdem bleibt die Notwendigkeit, unter Verwendung der Zeilennummer des Quellcodes einen eindeutigen Namen zu bilden, unklar, da die erste generierte Zeile darauf verzichtete. <br><br>  Ein weiterer Hinweis: Es war keine ganz triviale Aufgabe, genau herauszufinden, wie sich die Definition des Parameters entwickelt, aber dank MinGW war sie immer noch abgeschlossen.  Unter der Haube gab es eine Stringifizierung und doppelte Verklebung von Parametern, die Bildung eindeutiger Namen sowie andere knifflige Tricks bei der Arbeit mit Makros, aber ich pr√§sentiere nur die Ergebnisse.  Zusammenfassend kann ich sagen, dass das Studium von Makros A nicht das ist, wovon ich meinen Lebensunterhalt verdienen m√∂chte, es ist nur als Unterhaltung m√∂glich, aber wir fahren fort. <br><br>  Wir werden das Verst√§ndnis von Makros beim Verst√§ndnis der Aufgabe nicht weiter verbessern, daher wenden wir uns dem Quellcode des Dienstprogramms And zu und versuchen zu verstehen, was es tut. <br><br>  Zun√§chst einmal sind wir erstaunt zu sehen, dass die erforderlichen K√§sesorten nicht in den Kernelquellen enthalten sind.  Ja, ich bin bereit zuzustimmen, dass das I ein Dienstprogramm ist und √ºber den Einstiegspunkt zum Laden des Moduls mit dem Kernel interagiert. In jedem Buch √ºber L-Treiber wird jedoch √ºber dieses Dienstprogramm berichtet, sodass das Fehlen einer ‚Äûoffiziellen‚Äú Version der Quelle in der N√§he der Kernelquelle verursacht wird mich missverstehen.  Okay, Google hat uns nicht entt√§uscht und wir sind trotzdem mit dem K√§se rausgekommen. <br><br>  Das zweite Erstaunliche ist, dass dieses Dienstprogramm aus einem Paket besteht, dessen Name in keiner Weise mit seinem Namen verkn√ºpft ist. Es gibt mehr als ein solches Paket, und jedes wird an verschiedenen Stellen auf seine eigene Weise benannt - gelinde gesagt lustig.  Wenn Sie L installiert haben, k√∂nnen Sie mit dem Befehl herausfinden, aus welchem ‚Äã‚ÄãPaket das Dienstprogramm And zusammengestellt ist, und dann danach suchen. Wenn wir jedoch theoretische Untersuchungen durchf√ºhren (ich pers√∂nlich lasse L aus mehreren Gr√ºnden nicht auf meinem Heimcomputer, von denen einige ich habe Ich habe meine Beitr√§ge angegeben (so ein theoretischer Boxer), dann steht uns diese Methode nicht zur Verf√ºgung und alles, was bleibt, ist eine Suche im Internet, zum Gl√ºck gibt sie Ergebnisse. <br><br>  Das dritte Erstaunliche ist, dass der Name des Dienstprogramms selbst nirgendwo im Quellcode vorkommt, nicht in Dateinamen verwendet wird und nur in der make-Datei enthalten ist. Ich wei√ü, dass wir in C verpflichtet sind, die Hauptfunktion main zu benennen, und dies wird nicht besprochen (ich bin nicht pers√∂nlich) Ich freue mich dar√ºber, da Pascal verw√∂hnt ist, aber sie haben mich beim Entwerfen der Sprache nicht nach meiner Meinung gefragt, aber es w√§re zumindest m√∂glich, den externen Namen des Dienstprogramms in die Kommentare zu schreiben.  Notwendige Anmerkung - viele Dinge in Sprache C wurden nach dem Prinzip "es ist so √ºblich bei uns" gemacht, dass es wahrscheinlich schwierig war, Dinge manchmal anders oder sogar unm√∂glich zu machen, aber was k√∂nnen Sie jetzt tun, indem Sie einen Koffer ohne Griff weiter ziehen. <br><br>  Wir finden zwei Pakete, die den Quelltext enthalten. Und wir finden auch die K√§se auf Github. Wir sehen, dass sie identisch sind, und gehen davon aus, dass der Quellcode des Dienstprogramms so aussieht.  Als n√§chstes untersuchen wir nur die Datei auf git, zumal sie hier nur insmod.c hei√üt. Wir stellen fest, dass die Liste der Parameter zun√§chst in eine lange nullterminierte Zeichenfolge konvertiert wird, in der einzelne Elemente durch Leerzeichen getrennt sind.  Anschlie√üend ruft er zwei Funktionen auf, von denen die erste grub_file hei√üt und offensichtlich die Bin√§rdatei √∂ffnet, w√§hrend die zweite den Namen init_module hat und einen Zeiger auf eine ge√∂ffnete Datei mit der Modulbin√§rdatei und einer Folge von Parametern nimmt und als load_module bezeichnet wird, was den Zweck dieser Funktion als Laden nahe legt mit √Ñnderung der Parameter. <br><br>  Wir wenden uns dem Text der zweiten Funktion zu, der in der Datei liegt ... und hier ist ein Mist - nicht in einer der Dateien des untersuchten Repositorys auf dem Geet (nun, das ist nur logisch, dies ist Teil des Kernels und sein Platz ist nicht hier) ist es nicht.  Google hat es wieder eilig zu helfen und bringt uns zu den Kernel-K√§sesorten unter Elixir und der Datei module.c zur√ºck.  Es sollte beachtet werden, dass der Name der Datei, die die Funktionen f√ºr die Arbeit mit Modulen enth√§lt, √ºberraschenderweise logisch aussieht. Ich verstehe nicht einmal, wie ich das erkl√§ren soll. Es ist wahrscheinlich zuf√§llig passiert. <br><br>  Jetzt wurde uns der Mangel an Text klar. Und neben dem Kernel - es macht eigentlich fast nichts, es √ºbertr√§gt nur Parameter von einer Form in eine andere und √ºbertr√§gt die Kontrolle auf den Kern selbst, so dass es sogar unw√ºrdig ist, daneben zu liegen.  Von diesem Moment an wird klar, dass es keine klaren externen Informationen √ºber die Struktur der Parameter gibt, da der Kernel sie durch seine eigenen Makros √ºbersprungen hat und alles √ºber sie perfekt wei√ü und der Rest nichts √ºber die interne Struktur wissen muss (angesichts der Tatsache, dass die Quelle stehen zur Ansicht zur Verf√ºgung, ein paar Kommentare w√ºrden nicht schaden, aber im Prinzip ist es auch ohne sie wirklich immer klarer, aber bisher hat es fast nie Licht auf die Implementierung des Ausf√ºhrungsmechanismus selbst geworfen. <br><br>  Hinweis - In Bezug auf die √úbertragung der Kontrolle auf den Kernel war ich ein wenig aufgeregt. Wir sehen mit Sicherheit, wie die Funktion im Quellcode eines bestimmten verwendet wird und ob der Bin√§rteil mit dem Modul verkn√ºpft wird oder ob er tats√§chlich im Kernel-Image liegt. Weitere Untersuchungen sind erforderlich.  Die Tatsache, dass der Einstiegspunkt f√ºr die Verarbeitung dieser Funktion in besonderer Weise durch SYSCALL_DEFINE3 festgelegt ist, spricht indirekt f√ºr die zweite Option, aber ich habe lange verstanden, dass meine Vorstellungen √ºber das Logische und Unlogische, Akzeptable und Inakzeptable sowie √ºber das Zul√§ssige und Inakzeptable sehr bedeutsam sind von denen der Entwickler von L. abweichen <br><br>  Hinweis - ein weiterer Kieselstein im eingebauten Suchgarten - Als ich nach einer Definition f√ºr dieses Makro suchte, sah ich viele Stellen, an denen es als Funktion verwendet werden konnte, unter denen sich die Definition als Makro sehr bescheiden versteckte. <br><br>  Ich verstehe zum Beispiel nicht, warum ein externes Dienstprogramm erforderlich ist, um die Parameter aus dem Standardformular f√ºr das Betriebssystem (agrc, argv) in die Form einer nullterminierten Zeichenfolge mit Leerzeichen als Trennzeichen zu √ºbersetzen, die vom Systemmodul weiter verarbeitet wird - dieser Ansatz √ºbertrifft meinen etwas kognitive F√§higkeiten.  Insbesondere angesichts der Tatsache, dass der Benutzer eine Parameterzeichenfolge in Form einer nullterminierten Zeichenfolge mit Leerzeichen als Trennzeichen eingibt und das Dienstprogramm im Kernel diese in eine Form (argc, argv) konvertiert.  Erinnert stark an den alten Witz "Wir nehmen den Wasserkocher vom Herd, gie√üen Wasser heraus und bekommen ein Problem, dessen L√∂sung bereits bekannt ist."  Und da ich versuche, mich an das Prinzip zu halten: ‚ÄûBetrachten Sie Ihren Gespr√§chspartner nicht d√ºmmer als Sie selbst, bis er das Gegenteil beweist.  Und selbst danach k√∂nnen Sie sich irren. ‚ÄúIn Bezug auf die Entwickler von A ist der erste Satz definitiv g√ºltig. Das bedeutet, dass ich etwas falsch verstehe, aber ich bin nicht daran gew√∂hnt.  Wenn jemand eine vern√ºnftige Erkl√§rung f√ºr die angegebene Tatsache der doppelten Umwandlung liefern kann, dann frage ich im Kommentar.  Aber wir setzen die Untersuchung fort. <br><br>  Die Aussichten f√ºr die Implementierung der Optionen 1 und 2 werden ‚Äûsehr schwach sichtbar‚Äú (ein charmanter Wortlaut aus einem k√ºrzlich erschienenen Artikel √ºber die Aussichten f√ºr die Entwicklung von inl√§ndischen Hochgeschwindigkeits-ADCs), da es sehr seltsam w√§re, ein Modul mithilfe der Kernelfunktion in den Speicher zu laden und dann die Steuerung an ihn zu √ºbergeben, um den Kernel zu implementieren Funktion in seinen K√∂rper eingebaut.  Und sicher finden wir im Text der Funktion load_module ziemlich schnell den Aufruf parse_args - anscheinend sind wir auf dem richtigen Weg.  Als n√§chstes gehen wir schnell die Aufrufkette durch (wie immer werden wir Wrapper-Funktionen und Wrapper-Makros sehen, aber wir sind es bereits gewohnt, die Augen vor solch niedlichen Streiche von Entwicklern zu verschlie√üen) und finden die Funktion parse_one, die den erforderlichen Parameter an der richtigen Stelle platziert. <br><br>  Beachten Sie, dass die G√ºltigkeit der Parameter nicht wie erwartet √ºberpr√ºft wird, da der Kernel im Gegensatz zum Modul selbst nichts √ºber ihren Zweck wei√ü.  Es gibt Syntaxpr√ºfungen und die Anzahl der Elemente im Array (ja, es kann ein Array von Ganzzahlen als Parameter geben), und wenn Fehler dieser Art erkannt werden, stoppt das Laden des Moduls, aber nichts weiter.  Es geht jedoch nicht alles verloren, da nach dem Laden die Steuerung an die Funktion init_module √ºbertragen wird, die die erforderliche Validierung der eingestellten Parameter durchf√ºhren und, falls der <s>Sicherungswurf</s> erforderlich ist, den Startvorgang beenden kann. <br><br>  Wir haben jedoch die Frage, wie Parsing-Funktionen auf ein Array von Parameterbeispielen zugreifen, v√∂llig √ºbersehen, da das Parsen ohne dies etwas schwierig ist.  Ein kurzer Blick auf den Code zeigt, dass ein Dirty Hack angewendet wurde, ein offensichtlicher Trick. In der Bin√§rdatei sucht die Funktion find_module_sections nach dem benannten Abschnitt __param, dividiert seine Gr√∂√üe durch die Gr√∂√üe des Datensatzes (macht viel mehr) und gibt die erforderlichen Daten √ºber die Struktur zur√ºck.  Ich w√ºrde immer noch die Buchstaben p vor die Parameternamen dieser Funktion setzen, aber das ist Geschmackssache. <br><br>  Alles scheint klar und verst√§ndlich zu sein. Das einzige, was sich Sorgen macht, ist das Fehlen des Attributs __initdata f√ºr die generierten Daten. Kann es nach der Initialisierung wirklich im Speicher bleiben? Wahrscheinlich wird dieses Attribut, um ehrlich zu sein, irgendwo im allgemeinen Teil beschrieben, beispielsweise in den Linkerdaten , faul zu schauen, sehen Sie die Inschrift. <br><br>  Fazit: Das Wochenende war n√ºtzlich, es war interessant, den Quellcode von L zu verstehen, sich an etwas zu erinnern und etwas zu lernen, aber Wissen ist niemals √ºberfl√ºssig. <br>  Nun, in meinen Annahmen habe ich nicht vermutet, dass in L eine Option implementiert wurde, die sich als die verbleibenden 7 Prozent herausstellte, aber es war schmerzlich nicht offensichtlich. <br><br>  Nun, abschlie√üend Jaroslawnas Schrei (wie k√∂nnte man darauf verzichten), warum ich nach den notwendigen Informationen (ich meine nicht die interne K√ºche, sondern die externe Pr√§sentation) aus verschiedenen Quellen suchen muss, die keinen offiziellen Status haben, wo es ein Dokument gibt, das dem Buch √§hnlich ist <br>  ‚ÄûSoftware eines Computers.  Funktionales Betriebssystem. <br>  RAFOS.  System Programmer's Guide. ‚Äù, Oder nicht mehr? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431860/">https://habr.com/ru/post/de431860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431850/index.html">Heisenbug 2018 Moskau: kostenlose Online-√úbertragung, Party und vieles mehr</a></li>
<li><a href="../de431852/index.html">50.000 Netzwerkdrucker hacken und beliebigen Text drucken? Nichts ist einfacher</a></li>
<li><a href="../de431854/index.html">Datenkonsistenz in stark ausgelasteten Systemen</a></li>
<li><a href="../de431856/index.html">Erweitern des Unity-Editors um das Editorfenster, das skriptf√§hige Objekt und den benutzerdefinierten Editor</a></li>
<li><a href="../de431858/index.html">Mitap Sbertekh in Rostow am Don</a></li>
<li><a href="../de431862/index.html">Mitap Sbertekh in Jekaterinburg</a></li>
<li><a href="../de431864/index.html">PVS-Studio ROI: Wie man nicht Millionen verliert (Entwurfsversion des Artikels)</a></li>
<li><a href="../de431866/index.html">Programmierer falsche Vorstellungen √ºber Namen - mit Beispielen</a></li>
<li><a href="../de431868/index.html">Stunden auf Gasentladungslampen (GRI) sind sie Nixie Uhr</a></li>
<li><a href="../de431870/index.html">Entwickler interaktiver B√ºcher mit LEDs beschweren sich √ºber den Diebstahl von Ideen durch Google-Mitarbeiter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>