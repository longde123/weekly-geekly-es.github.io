<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏻 🦋 🈸 Cascade de complexité et architecture à la demande 🧚🏾 📷 🤲🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsqu'on parle de «mauvais code», les gens signifient presque certainement «code complexe» parmi d'autres problèmes courants. Le truc avec la complex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cascade de complexité et architecture à la demande</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472876/"><p><img src="https://habrastorage.org/webt/g9/_9/wk/g9_9wkgu4h6i8xyelaq9p5nwmjy.png" alt="Le logo"></p><br><p>  Lorsqu'on parle de «mauvais code», les gens signifient presque certainement «code complexe» parmi d'autres problèmes courants.  Le truc avec la complexité, c'est qu'elle vient de nulle part.  Un jour, vous commencez votre projet assez simple, l'autre jour vous le trouvez en ruine.  Et personne ne sait comment et quand cela s'est produit. </p><br><p>  Mais cela arrive finalement pour une raison!  La complexité du code entre dans votre base de code de deux manières possibles: avec de gros morceaux et des ajouts incrémentiels.  Et les gens sont mauvais pour les examiner et les trouver tous les deux. </p><a name="habracut"></a><br><p>  Lorsqu'un gros morceau de code arrive, le réviseur sera mis au défi de trouver l'emplacement exact où le code est complexe et ce qu'il faut faire à ce sujet.  Ensuite, l'examen devra prouver le point: pourquoi ce code est complexe en premier lieu.  Et d'autres développeurs pourraient ne pas être d'accord.  Nous connaissons tous ce genre de revues de code! </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/198/8ff/e0e/1988ffe0e3d5dc3b29b4743630b52e06.png" alt="Nombre de lignes à réviser et taux de commentaires"></p><br><p> Le deuxième moyen de complexité d'entrer dans votre code est l'ajout incrémentiel: lorsque vous soumettez une ou deux lignes à la fonction existante.  Et il est extrêmement difficile de remarquer que votre fonction était correcte il y a un commit, mais maintenant elle est trop complexe.  Il faut une bonne partie de concentration, un examen des compétences et de bonnes pratiques de navigation dans le code pour le détecter.  La plupart des gens (comme moi!) Manquent de ces compétences et permettent à la complexité d'entrer régulièrement dans la base de code. </p><br><p>  Alors, que peut-on faire pour éviter que votre code ne devienne complexe?  Nous devons utiliser l'automatisation!  Jetons un coup d'œil à la complexité du code et aux moyens de le trouver et enfin de le résoudre. </p><br><p>  Dans cet article, je vais vous guider à travers des endroits où vit la complexité et comment la combattre.  Ensuite, nous verrons dans quelle mesure le code simple et l'automatisation sont bien écrits et permettent de développer les styles de développement «Refactoring continu» et «Architecture à la demande». </p><br><h2 id="complexity-explained">  La complexité expliquée </h2><br><p>  On peut se demander: quelle est exactement la «complexité du code»?  Et même si cela semble familier, il existe des obstacles cachés dans la compréhension de l'emplacement exact de la complexité.  Commençons par les parties les plus primitives, puis passons aux entités de niveau supérieur. </p><br><p>  Rappelez-vous, que cet article est nommé "Complexity Waterfall"?  Je vais vous montrer comment la complexité des primitives les plus simples déborde dans les abstractions les plus élevées. </p><br><p> J'utiliserai <code>python</code> comme langue principale pour mes exemples et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>wemake-python-styleguide</code></a> comme outil principal de linting pour trouver les violations dans mon code et illustrer mon propos. </p><br><h3 id="expressions">  Expressions </h3><br><p>  Tout votre code se compose d'expressions simples telles <code>a + 1</code> et <code>print(x)</code> .  Bien que les expressions elles-mêmes soient simples, elles pourraient à certains moments déborder votre code de complexité.  Exemple: imaginez que vous avez un dictionnaire qui représente un modèle <code>User</code> et que vous l'utilisez comme ceci: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format_username</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user)</span></span></span><span class="hljs-function"> -&gt; str:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> user[<span class="hljs-string"><span class="hljs-string">'username'</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user[<span class="hljs-string"><span class="hljs-string">'email'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(user[<span class="hljs-string"><span class="hljs-string">'username'</span></span>]) &gt; <span class="hljs-number"><span class="hljs-number">12</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user[<span class="hljs-string"><span class="hljs-string">'username'</span></span>][:<span class="hljs-number"><span class="hljs-number">12</span></span>] + <span class="hljs-string"><span class="hljs-string">'...'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'@'</span></span> + user[<span class="hljs-string"><span class="hljs-string">'username'</span></span>]</code> </pre> <br><p>  Cela semble assez simple, non?  En fait, il contient deux problèmes de complexité basés sur l'expression.  Il sur- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>overuses 'username'</code></a> et utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le nombre magique</a> <code>12</code> (pourquoi utilisons-nous ce nombre en premier lieu, pourquoi pas <code>13</code> ou <code>10</code> ?).  Il est difficile de trouver ce genre de choses par vous-même.  Voici à quoi ressemblerait la meilleure version: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#: That's how many chars fit in the preview box. LENGTH_LIMIT: Final = 12 def format_username(user) -&gt; str: username = user['username'] if not username: return user['email'] elif len(username) &gt; LENGTH_LIMIT: # See? It is now documented return username[:LENGTH_LIMIT] + '...' return '@' + username</span></span></code> </pre> <br><p>  Il y a également différents problèmes d'expression.  Nous pouvons également avoir des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expressions surutilisées</a> : lorsque vous utilisez l'attribut <code>some_object.some_attr</code> partout au lieu de créer une nouvelle variable locale.  Nous pouvons également avoir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des conditions logiques trop complexes</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un accès point trop profond</a> . </p><br><p>  <strong>Solution</strong> : créez de nouvelles variables, arguments ou constantes.  Créez et utilisez de nouvelles fonctions ou méthodes utilitaires si nécessaire. </p><br><h3 id="lines">  Lignes </h3><br><p>  Les expressions forment des lignes de code (veuillez ne pas confondre les lignes avec les instructions: une seule instruction peut prendre plusieurs lignes et plusieurs instructions peuvent se trouver sur une seule ligne). </p><br><p>  La première et la métrique de complexité la plus évidente pour une ligne est sa longueur.  Oui, vous l'avez bien entendu.  C'est pourquoi nous (les programmeurs) préférons nous en tenir à la règle des <code>80</code> caractères par ligne et non pas parce qu'elle était <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">précédemment utilisée</a> dans les téléscripteurs.  Il y a beaucoup de rumeurs à ce sujet ces derniers temps, disant qu'il ne fait aucun sens d'utiliser <code>80</code> caractères pour votre code en 2k19.  Mais ce n'est évidemment pas vrai. </p><br><p>  L'idée est simple.  Vous pouvez avoir deux fois plus de logique dans une ligne avec <code>160</code> caractères qu'en ligne avec seulement <code>80</code> caractères.  C'est pourquoi cette limite doit être fixée et appliquée.  N'oubliez <em>pas que</em> ce n'est <em>pas un choix stylistique</em> .  C'est une métrique de complexité! </p><br><p>  La deuxième métrique de complexité de la ligne principale est moins connue et moins utilisée.  Cela s'appelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jones Complexity</a> .  L'idée derrière cela est simple: nous comptons les nœuds de code (ou <code>ast</code> ) sur une seule ligne pour obtenir sa complexité.  Jetons un coup d'œil à l'exemple.  Ces deux lignes sont fondamentalement différentes en termes de complexité mais ont exactement la même largeur en caractères: </p><br><pre> <code class="python hljs">print(first_long_name_with_meaning, second_very_long_name_with_meaning, third) print(first * <span class="hljs-number"><span class="hljs-number">5</span></span> + math.pi * <span class="hljs-number"><span class="hljs-number">2</span></span>, matrix.trans(*matrix), display.show(matrix, <span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre> <br><p>  Comptons les nœuds du premier: un appel, trois noms.  Quatre nœuds totalement.  Le second a vingt et un nœuds <code>ast</code> .  Eh bien, la différence est claire.  C'est pourquoi nous utilisons la métrique de complexité Jones pour autoriser la première ligne longue et interdire la seconde en fonction d'une complexité interne, et pas uniquement de la longueur brute. </p><br><p>  Que faire des lignes avec un score de complexité Jones élevé? </p><br><p>  <strong>Solution</strong> : divisez-les en plusieurs lignes ou créez de nouvelles variables intermédiaires, des fonctions utilitaires, de nouvelles classes, etc. </p><br><pre> <code class="python hljs">print( first * <span class="hljs-number"><span class="hljs-number">5</span></span> + math.pi * <span class="hljs-number"><span class="hljs-number">2</span></span>, matrix.trans(*matrix), display.show(matrix, <span class="hljs-number"><span class="hljs-number">2</span></span>), )</code> </pre> <br><p>  Maintenant, c'est beaucoup plus lisible! </p><br><h3 id="structures">  Structures </h3><br><p>  L'étape suivante consiste à analyser les structures du langage comme <code>if</code> , <code>for</code> , <code>with</code> , etc. qui sont formées à partir de lignes et d'expressions.  Je dois dire que ce point est très spécifique à la langue.  Je présenterai également plusieurs règles de cette catégorie en utilisant <code>python</code> . </p><br><p>  Nous commencerons par <code>if</code> .  Quoi de plus facile qu'un bon vieux <code>if</code> ?  En fait, <code>if</code> commence à devenir difficile très rapidement.  Voici un exemple de la façon dont on peut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>reimplement switch</code></a> avec <code>if</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(some, int): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, float): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, complex): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, str): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, bytes): ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(some, list): ...</code> </pre> <br><p>  Quel est le problème avec ce code?  Eh bien, imaginez que nous ayons des dizaines de types de données qui devraient être couverts, y compris ceux des douanes que nous ne connaissons pas encore.  Ensuite, ce code complexe est un indicateur que nous choisissons ici un mauvais modèle.  Nous devons refactoriser notre code pour résoudre ce problème.  Par exemple, on peut utiliser des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>typeclass</code> es</a> ou une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>singledispatch</code></a> .  Ils ont le même travail, mais plus gentils. </p><br><p>  <code>python</code> ne cesse de nous amuser.  Par exemple, vous pouvez écrire <code>with</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un nombre arbitraire de cas</a> , ce qui est trop complexe mentalement et déroutant: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> first(), second(), third(), fourth(): ...</code> </pre> <br><p>  Vous pouvez également écrire des compréhensions avec un nombre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>if</code></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>for</code></a> expressions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>if</code></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>for</code></a> , ce qui peut conduire à un code complexe et illisible: </p><br><pre> <code class="python hljs">[ (x, y, z) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x_coords <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> y_coords <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> z <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> z_coords <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x + y &lt;= z <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x + z &lt;= y <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y + z &lt;= x ]</code> </pre> <br><p>  Comparez-le avec la version simple et lisible: </p><br><pre> <code class="python hljs">[ (x, y, z) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x, y, x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> itertools.product(x_coords, y_coords, z_coords) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> valid_coordinates(x, y, z) ]</code> </pre> <br><p>  Vous pouvez également accidentellement inclure <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>multiple statements inside a try</code></a> cas d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>multiple statements inside a try</code></a> , ce qui n'est pas sûr car il peut déclencher et gérer une exception à un emplacement attendu: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: user = fetch_user() <span class="hljs-comment"><span class="hljs-comment"># Can also fail, but don't expect that log.save_user_operation(user.email) # Can fail, and we know it except MyCustomException as exc: ...</span></span></code> </pre> <br><p>  Et ce n'est même pas 10% des cas qui peuvent et vont mal avec votre code <code>python</code> .  Il y a beaucoup, beaucoup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus de cas marginaux</a> qui devraient être suivis et analysés. </p><br><p>  <strong>Solution</strong> : La seule solution possible est d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un bon linter</a> pour la langue de votre choix.  Et refactoriser les endroits complexes que ce linter met en valeur.  Sinon, vous devrez réinventer la roue et définir des politiques personnalisées pour les mêmes problèmes. </p><br><h3 id="functions">  Les fonctions </h3><br><p>  Les expressions, les instructions et les structures forment des fonctions.  La complexité de ces entités se transforme en fonctions.  Et c'est là que les choses commencent à devenir intrigantes.  Parce que les fonctions ont littéralement des dizaines de mesures de complexité: à la fois bonnes et mauvaises. </p><br><p>  Nous commencerons par les plus connus: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">complexité cyclomatique</a> et longueur de fonction mesurée en lignes de code.  La complexité cyclomatique indique le nombre de tours que peut prendre votre flux d'exécution: il est presque égal au nombre de tests unitaires requis pour couvrir entièrement le code source.  C'est une bonne métrique car elle respecte la sémantique et aide le développeur à refactoriser.  D'un autre côté, la longueur d'une fonction est une mauvaise métrique.  Il ne coopère pas avec la métrique de complexité de Jones expliquée précédemment, car nous le savons déjà: plusieurs lignes sont plus faciles à lire qu'une seule grande ligne avec tout à l'intérieur.  Nous nous concentrerons uniquement sur les bonnes mesures et ignorerons les mauvaises. </p><br><p>  Sur la base de mon expérience, plusieurs métriques de complexité utiles devraient être comptées au lieu de la longueur de la fonction régulière: </p><br><ul><li>  Nombre de décorateurs de fonction;  plus c'est bas </li><li>  Nombre d'arguments;  plus c'est bas </li><li>  Nombre d'annotations;  plus c'est mieux </li><li>  Nombre de variables locales;  plus c'est bas </li><li>  Nombre de retours, rendements, attentes;  plus c'est bas </li><li>  Nombre de déclarations et d'expressions;  plus c'est bas </li></ul><br><p>  La combinaison de toutes ces vérifications vous permet vraiment d'écrire des fonctions simples (toutes les règles s'appliquent également aux méthodes). </p><br><p>  Lorsque vous essaierez de faire des choses désagréables avec votre fonction, vous casserez sûrement au moins une métrique.  Et cela décevra notre linter et soufflera votre construction.  En conséquence, votre fonction sera enregistrée. </p><br><p>  <strong>Solution</strong> : lorsqu'une fonction est trop complexe, la seule solution que vous avez est de diviser cette fonction en plusieurs. </p><br><h3 id="classes">  Cours </h3><br><p>  Le niveau suivant d'abstraction après les fonctions sont les classes.  Et comme vous l'avez déjà deviné, elles sont encore plus complexes et fluides que les fonctions.  Parce que les classes peuvent contenir plusieurs fonctions à l'intérieur (appelées méthode) et avoir d'autres fonctionnalités uniques comme l'héritage et les mixins, les attributs au niveau de la classe et les décorateurs au niveau de la classe.  Nous devons donc vérifier toutes les méthodes en tant que fonctions et le corps de classe lui-même. </p><br><p>  Pour les classes, nous devons mesurer les métriques suivantes: </p><br><ul><li>  Nombre de décorateurs au niveau de la classe;  plus c'est bas </li><li>  Nombre de classes de base;  plus c'est bas </li><li>  Nombre d'attributs publics au niveau de la classe;  plus c'est bas </li><li>  Nombre d'attributs publics au niveau de l'instance;  plus c'est bas </li><li>  Nombre de méthodes;  plus c'est bas </li></ul><br><p>  Lorsque l'un de ces éléments est trop compliqué - nous devons sonner l'alarme et échouer la construction! </p><br><p>  <strong>Solution</strong> : refactorisez votre classe ratée!  Divisez une classe complexe existante en plusieurs classes simples ou créez de nouvelles fonctions utilitaires et utilisez la composition. </p><br><p>  Mention notable: on peut également suivre les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mesures de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cohésion</a> et de couplage pour valider la complexité de votre conception POO. </p><br><h3 id="modules">  Modules </h3><br><p>  Les modules contiennent plusieurs instructions, fonctions et classes.  Et comme vous l'avez peut-être déjà mentionné, nous vous conseillons généralement de diviser les fonctions et les classes en nouvelles.  C'est pourquoi nous devons garder à l'œil la complexité des modules: elle coule littéralement dans les modules des classes et des fonctions. </p><br><p>  Pour analyser la complexité du module, nous devons vérifier: </p><br><ul><li>  Le nombre d'importations et de noms importés;  plus c'est bas </li><li>  Le nombre de classes et de fonctions;  plus c'est bas </li><li>  La complexité moyenne des fonctions et des classes à l'intérieur;  plus c'est bas </li></ul><br><p>  Que fait-on dans le cas d'un module complexe? </p><br><p>  <strong>Solution</strong> : oui, vous avez bien compris.  Nous avons divisé un module en plusieurs modules. </p><br><h3 id="packages">  Forfaits </h3><br><p>  Les packages contiennent plusieurs modules.  Heureusement, c'est tout ce qu'ils font. </p><br><p>  Ainsi, le nombre de modules dans un package peut bientôt devenir trop volumineux, vous vous retrouverez donc avec un trop grand nombre d'entre eux.  Et c'est la seule complexité que l'on puisse trouver avec les packages. </p><br><p>  <strong>Solution</strong> : vous devez diviser les packages en sous-packages et packages de différents niveaux. </p><br><h2 id="complexity-waterfall-effect">  Effet cascade complexe </h2><br><p>  Nous avons maintenant couvert presque tous les types d'abstractions possibles dans votre base de code.  Qu'en avons-nous appris?  Le principal point à retenir, pour l'instant, est que la plupart des problèmes peuvent être résolus en éjectant la complexité au même niveau d'abstraction ou au niveau supérieur. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9b6/8ad/453/9b68ad45340cdf61f51a8deb2c07930d.png" alt="Cascade de complexité"></p><br><p>  Cela nous amène à l'idée la plus importante de cet article: ne laissez pas votre code déborder de complexité.  Je vais donner plusieurs exemples de la façon dont cela se produit habituellement. </p><br><p>  Imaginez que vous implémentez une nouvelle fonctionnalité.  Et c'est le seul changement que vous apportez: </p><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">+++ if user.is_active and user.has_sub() and sub.is_due(tz.now() + delta): --- if user.is_active and user.has_sub():</span></span></code> </pre> <br><p>  Semble ok, je passerais ce code lors de l'examen.  Et rien de mal ne se passerait.  Mais, le point qui me manque, c'est que la complexité a débordé cette ligne!  C'est ce que <code>wemake-python-styleguide</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c87/b9e/0e5/c87b9e0e584a8cd01235e0ae7695a6c0.png" alt="wemake-python-styleguide-output"></p><br><p>  Ok, nous devons maintenant résoudre cette complexité.  Faisons une nouvelle variable: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">can_be_purchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user_id)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ... is_sub_paid = sub.is_due(tz.now() + delta) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> user.is_active <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> user.has_sub() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_sub_paid: ... ... ...</code> </pre> <br><p>  Maintenant, la complexité de la ligne est résolue.  Mais attendez une minute.  Et si notre fonction a trop de variables maintenant?  Parce que nous avons créé une nouvelle variable sans vérifier d'abord leur nombre dans la fonction.  Dans ce cas, nous devrons diviser cette méthode en plusieurs comme ceci: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">can_be_purchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user_id)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._has_paid_sub(user, sub, delta): ... ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_has_paid_sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user, sub, delta)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> is_sub_paid = sub.is_due(tz.now() + delta) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user.is_active <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> user.has_sub() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_sub_paid ...</code> </pre> <br><p>  Maintenant, nous avons terminé!  Non?  Non, car nous devons maintenant vérifier la complexité de la classe <code>Product</code> .  Imaginez qu'il a maintenant trop de méthodes puisque nous en avons créé une nouvelle <code>_has_paid_sub</code> . </p><br><p>  Ok, nous exécutons notre linter pour vérifier à nouveau la complexité.  Et il s'avère que notre classe de <code>Product</code> est en effet trop complexe en ce moment.  Nos actions?  Nous l'avons divisé en plusieurs classes! </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Policy</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubcsriptionPolicy</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Policy)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">can_be_purchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user_id)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._has_paid_sub(user, sub, delta): ... ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_has_paid_sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, user, sub, delta)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> is_sub_paid = sub.is_due(tz.now() + delta) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user.is_active <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> user.has_sub() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_sub_paid <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> _purchasing_policy: Policy ... ...</code> </pre> <br><p>  Veuillez me dire que c'est la dernière itération!  Eh bien, je suis désolé, mais nous devons maintenant vérifier la complexité du module.  Et devinez quoi?  Nous avons maintenant trop de membres du module.  Nous devons donc diviser les modules en modules séparés!  Ensuite, nous vérifions la complexité du package.  Et aussi éventuellement le diviser en plusieurs sous-packages. </p><br><p>  L'avez-vous vu?  En raison des règles de complexité bien définies, notre modification sur une seule ligne s'est avérée être une énorme session de refactoring avec plusieurs nouveaux modules et classes.  Et nous n'avons pas pris une seule décision nous-mêmes: tous nos objectifs de refactoring étaient motivés par la complexité interne et le linter qui le révèle. </p><br><p>  C'est ce que j'appelle un processus de "Refactoring continu".  Vous êtes obligé de refactoriser.  Toujours. </p><br><p>  Ce processus a également une conséquence intéressante.  Il vous permet d'avoir "Architecture à la demande".  Laisse-moi t'expliquer.  Avec la philosophie «Architecture à la demande», vous commencez toujours petit.  Par exemple avec un seul fichier <code>logic/domains/user.py</code>  Et vous commencez à y mettre tout ce qui concerne l' <code>User</code> .  Parce qu'en ce moment, vous ne savez probablement pas à quoi ressemblera votre architecture.  Et tu t'en fous.  Vous n'avez que trois fonctions. </p><br><p>  Certaines personnes tombent dans le piège de l'architecture contre la complexité du code.  Ils peuvent trop compliquer leur architecture dès le début avec les couches complètes de référentiel / service / domaine.  Ou ils peuvent compliquer excessivement le code source sans séparation claire.  Luttez et vivez comme ça pendant des années (s'ils pourront vivre pendant des années avec le code comme ça!). </p><br><p>  Le concept «Architecture à la demande» résout ces problèmes.  Vous commencez petit, le moment venu - vous divisez et remodelez les choses: </p><br><ol><li>  Vous commencez avec la <code>logic/domains/user.py</code> et vous y mettez tout </li><li>  Plus tard, vous créez <code>logic/domains/user/repository.py</code> lorsque vous avez suffisamment de choses liées à la base de données </li><li>  Ensuite, vous le <code>logic/domains/user/repository/queries.py</code> en <code>logic/domains/user/repository/queries.py</code> et <code>logic/domains/user/repository/commands.py</code> lorsque la complexité vous le demande </li><li>  Ensuite, vous créez <code>logic/domains/user/services.py</code> avec des éléments liés à <code>http</code> </li><li>  Ensuite, vous créez un nouveau module appelé <code>logic/domains/order.py</code> </li><li>  Et ainsi de suite et ainsi de suite </li></ol><br><p>  Voilà.  C'est un outil parfait pour équilibrer votre architecture et la complexité du code.  Et obtenez autant d'architecture que vous en avez vraiment besoin en ce moment. </p><br><h2 id="conclusion">  Conclusion </h2><br><p>  Un bon linter fait bien plus que trouver des virgules manquantes et de mauvaises citations.  Un bon linter vous permet de vous y fier pour les décisions d'architecture et de vous aider dans le processus de refactoring. </p><br><p>  Par exemple, <code>wemake-python-styleguide</code> peut vous aider avec la complexité du code source <code>python</code> , il vous permet de: </p><br><ul><li>  Combattez avec succès la complexité à tous les niveaux </li><li>  Appliquez une énorme quantité de normes de dénomination, de meilleures pratiques et de contrôles de cohérence </li><li>  Intégrez-le facilement dans une base de code héritée à l'aide de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">option <code>diff</code></a> ou de l'outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>flakehell</code></a> , donc les anciennes violations seront pardonnées, mais les nouvelles ne seront pas autorisées </li><li>  Activez-le dans votre [CI] (), même en tant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qu'action Github</a> </li></ul><br><p>  Ne laissez pas la complexité déborder votre code, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisez un bon linter</a> ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472876/">https://habr.com/ru/post/fr472876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472862/index.html">Invalidation du cache en cascade. 2e partie</a></li>
<li><a href="../fr472864/index.html">Check Point: optimisation CPU et RAM</a></li>
<li><a href="../fr472866/index.html">Talisman pour une communication stable</a></li>
<li><a href="../fr472868/index.html">Gestion du serveur téléphonique: client mobile RUVDS</a></li>
<li><a href="../fr472872/index.html">Comment augmenter le démarrage à 50 employés sans perdre la culture</a></li>
<li><a href="../fr472884/index.html">Comment les stéréotypes d'un développeur novice s'effondrent au début du jeu</a></li>
<li><a href="../fr472886/index.html">Comment implémenter un analyseur statique dans le développement pour que tout le monde soit content?</a></li>
<li><a href="../fr472890/index.html">DeepPavlov pour les développeurs: # 1 outils NLP et créer des chatbots</a></li>
<li><a href="../fr472892/index.html">Pourquoi les antivirus traditionnels ne conviennent pas aux clouds publics. Et que faire?</a></li>
<li><a href="../fr472894/index.html">DartUP 2019: conférence sur Dart et Flutter à Saint-Pétersbourg le 23 novembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>