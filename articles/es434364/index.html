<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è∏Ô∏è üíã üêà Hangfire Queue Support ü§ñ üë®üèº‚Äç‚öïÔ∏è üÜö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hangfire es una biblioteca para .net (core), que permite la ejecuci√≥n as√≠ncrona de alg√∫n c√≥digo seg√∫n el principio de "disparar y olvidar". Un ejemplo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hangfire Queue Support</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434364/"><p>  Hangfire es una biblioteca para .net (core), que permite la ejecuci√≥n as√≠ncrona de alg√∫n c√≥digo seg√∫n el principio de "disparar y olvidar".  Un ejemplo de dicho c√≥digo puede ser el env√≠o de correo electr√≥nico, procesamiento de video, sincronizaci√≥n con otro sistema, etc.  Adem√°s de "disparar y olvidar", hay soporte para tareas diferidas, as√≠ como tareas programadas en formato Cron. </p><br><p>  Actualmente, hay muchas bibliotecas de este tipo.  Algunos de los beneficios de Hangfire son: </p><br><ul><li>  Configuraci√≥n simple, API conveniente </li><li>  Fiabilidad  Hangfire garantiza que la tarea creada se ejecutar√° al menos una vez </li><li>  Capacidad para realizar tareas en paralelo y excelente rendimiento </li><li>  Extensibilidad (aqu√≠ la usaremos a continuaci√≥n) </li><li>  Documentaci√≥n bastante completa y comprensible </li><li>  Panel de control en el que puede ver todas las estad√≠sticas sobre las tareas </li></ul><br><p>  No entrar√© en demasiados detalles, ya que hay muchos buenos art√≠culos sobre Hangfire y c√≥mo usarlo.  En este art√≠culo discutir√© c√≥mo usar el soporte de varias colas (o grupos de tareas), c√≥mo arreglar la funcionalidad de reintento est√°ndar y hacer que cada cola tenga una configuraci√≥n individual. </p><a name="habracut"></a><br><h3 id="suschestvuyuschaya-podderzhka-psevdo-ocheredey">  Soporte existente para (pseudo) colas </h3><br><p>  Nota importante: en el t√≠tulo, utilic√© el t√©rmino pseudo-cola porque Hangfire no garantiza que las tareas se realizar√°n en un orden espec√≠fico.  Es decir  El principio de "Primero en entrar, primero en salir" no se aplica y no confiaremos en √©l.  Adem√°s, el autor de la biblioteca recomienda que las tareas sean idempotentes, es decir  estable contra ejecuci√≥n m√∫ltiple imprevista.  Adem√°s, usar√© solo la palabra "cola", porque  Hangfire usa el t√©rmino "Cola". </p><br><p>  Hangfire tiene soporte de cola simple.  Aunque no ofrece la flexibilidad de los sistemas de cola de mensajes, como rabbitMQ o Azure Service Bus, a menudo es suficiente para resolver una amplia gama de tareas. </p><br><p>  Cada tarea tiene la propiedad "Cola", es decir, el nombre de la cola en la que debe ejecutarse.  De manera predeterminada, la tarea se env√≠a a la cola con el nombre "predeterminado" a menos que se especifique lo contrario.  Se necesita soporte para m√∫ltiples colas para gestionar por separado la ejecuci√≥n de tareas de diferentes tipos.  Por ejemplo, podr√≠amos querer que las tareas de procesamiento de video caigan en la cola "video_queue" y env√≠en correos electr√≥nicos a la cola "email_queue".  Por lo tanto, podemos realizar de forma independiente estos dos tipos de tareas.  Si queremos mover el procesamiento de video a un servidor dedicado, podemos hacerlo f√°cilmente ejecutando un servidor Hangfire separado como una aplicaci√≥n de consola que procesar√° la cola "video_queue". </p><br><h3 id="pereydem-k-praktike">  Pasemos a practicar </h3><br><p>  La configuraci√≥n del servidor Hangfire en asp.net core es la siguiente: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.UseHangfireServer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundJobServerOptions { WorkerCount = <span class="hljs-number"><span class="hljs-number">2</span></span>, Queues = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"email_queue"</span></span>, <span class="hljs-string"><span class="hljs-string">"video_queue"</span></span> } }); }</code> </pre> <br><h3 id="problema-1---zadachi-pri-povtore-popadayut-v-ochered-default">  Problema 1: las tareas de reproducci√≥n entran en la cola predeterminada </h3><br><p>  Como mencion√© anteriormente, hay una cola predeterminada en Hangfire llamada "predeterminada".  Si una tarea colocada en la cola, por ejemplo, "video_queue", fall√≥ y necesita ser reintentada, se enviar√° nuevamente a la cola "predeterminada" y no "video_queue" y, como resultado, nuestra tarea no se realizar√° en absoluto La instancia del servidor Hangfire que nos gustar√≠a, si es que lo desea.  Este comportamiento fue establecido por m√≠ experimentalmente y es probablemente un error en el propio Hangfire. </p><br><h4 id="job-filters">  Filtros de trabajo </h4><br><p>  Hangfire nos brinda la posibilidad de expandir la funcionalidad con la ayuda de los llamados filtros (filtros de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trabajo</a> ), que son similares en principio a los filtros de acciones en ASP.NET MVC.  El hecho es que la l√≥gica interna de Hangfire se implementa como una m√°quina de estado.  Este es un motor que transfiere secuencialmente las tareas en el grupo de un estado a otro (por ejemplo, creado -&gt; en cola -&gt; procesado -&gt; exitoso), y los filtros nos permiten "interceptar" la tarea que se ejecuta cada vez que cambia su estado y manipularla.  Un filtro se implementa como un atributo que se puede aplicar a un √∫nico m√©todo, clase o globalmente. </p><br><h4 id="job-parameters">  Par√°metros de trabajo </h4><br><p>  El objeto ElectStateContext se pasa como argumento al m√©todo de filtro.  Este objeto contiene informaci√≥n completa sobre la tarea actual.  Entre otras cosas, tiene los m√©todos GetJobParameter &lt;&gt; (...) y SettJobParameter &lt;&gt; (...).  Los par√°metros de trabajo le permiten guardar informaci√≥n relacionada con una tarea en una base de datos.  Es en los Par√°metros del trabajo donde se almacena el nombre de la cola a la que se envi√≥ originalmente la tarea, solo por alguna raz√≥n esta informaci√≥n se ignora durante el pr√≥ximo reintento. </p><br><h3 id="reshenie">  Soluci√≥n </h3><br><p>  Entonces, tenemos una tarea que termin√≥ en error y deber√≠a enviarse para volver a ejecutarla en la cola correcta (en la misma que se le asign√≥ en el momento de la creaci√≥n inicial).  La repetici√≥n de una tarea que se complet√≥ con un error es una transici√≥n del estado "fallido" al estado "en cola".  Para resolver el problema, cree un filtro que, cuando la tarea ingrese al estado "en cola", verifique en qu√© cola se envi√≥ la tarea inicialmente y ponga el par√°metro "QueueName" en el valor deseado: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireUseCorrectQueueFilter</span></span> : <span class="hljs-title"><span class="hljs-title">JobFilterAttribute</span></span>, <span class="hljs-title"><span class="hljs-title">IElectStateFilter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStateElection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElectStateContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.CandidateState <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> EnqueuedState enqueuedState) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queueName = context.GetJobParameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"QueueName"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(queueName)) { context.SetJobParameter(<span class="hljs-string"><span class="hljs-string">"QueueName"</span></span>, enqueuedState.Queue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { enqueuedState.Queue = queueName; } } } }</code> </pre> <br><p>  Para aplicar el filtro predeterminado a todas las tareas (es decir, globalmente), agregue el siguiente c√≥digo a nuestra configuraci√≥n: </p><br><pre> <code class="cs hljs">GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireUseCorrectQueueFilter { Order = <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre> <br><p>  Otro peque√±o inconveniente es que la colecci√≥n GlobalJobFilters por defecto contiene una instancia de la clase AutomaticRetryAttribute.  Este es un filtro est√°ndar que se encarga de volver a ejecutar las tareas fallidas.  Tambi√©n env√≠a la tarea a la cola "predeterminada", ignorando la cola original.  Para que nuestra bicicleta circule, debe eliminar este filtro de la colecci√≥n y dejar que nuestro filtro se responsabilice de las tareas repetidas.  Como resultado, el c√≥digo de configuraci√≥n se ver√° as√≠: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultRetryFilter = GlobalJobFilters.Filters .FirstOrDefault(f =&gt; f.Instance <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> AutomaticRetryAttribute); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (defaultRetryFilter != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; defaultRetryFilter.Instance != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { GlobalJobFilters.Filters.Remove(defaultRetryFilter.Instance); } GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireUseCorrectQueueFilter { Order = <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre> <br><p>  Cabe se√±alar que AutomaticRetryAttribute implementa la l√≥gica de aumentar autom√°ticamente el intervalo entre intentos (el intervalo aumenta con cada intento posterior), y al eliminar AutomaticRetryAttribute de la colecci√≥n GlobalJobFilters, abandonamos esta funcionalidad (consulte la implementaci√≥n del m√©todo <a href="">ScheduleAgainLater</a> ) </p><br><p>  Por lo tanto, hemos logrado que nuestras tareas se puedan realizar en diferentes colas, y esto nos permite gestionar de forma independiente su ejecuci√≥n, incluido el procesamiento de diferentes colas en diferentes m√°quinas.  Solo que ahora no sabemos cu√°ntas veces y en qu√© intervalo se repetir√°n nuestras tareas en caso de error, ya que eliminamos AutomaticRetryAttribute de la colecci√≥n de filtros. </p><br><h3 id="problema-2---individualnye-nastroyki-dlya-kazhdoy-ocheredi">  Problema 2: configuraciones individuales para cada cola </h3><br><p>  Queremos poder configurar el intervalo y el n√∫mero de repeticiones por separado para cada cola, y tambi√©n, si para alguna cola no especificamos valores expl√≠citamente, queremos que se apliquen los valores predeterminados.  Para hacer esto, implementamos otro filtro y lo llamamos <code>HangfireRetryJobFilter</code> . </p><br><p>  Idealmente, el c√≥digo de configuraci√≥n deber√≠a verse as√≠: </p><br><pre> <code class="cs hljs">GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireRetryJobFilter { Order = <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-string"><span class="hljs-string">"email_queue"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { DelayInSeconds = <span class="hljs-number"><span class="hljs-number">120</span></span>, RetryAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span> }, [<span class="hljs-string"><span class="hljs-string">"video_queue"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { DelayInSeconds = <span class="hljs-number"><span class="hljs-number">60</span></span>, RetryAttempts = <span class="hljs-number"><span class="hljs-number">5</span></span> } });</code> </pre> <br><h3 id="reshenie-1">  Soluci√≥n </h3><br><p>  Para hacer esto, primero agregue la clase <code>HangfireQueueSettings</code> , que servir√° como contenedor para nuestra configuraci√≥n. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireQueueSettings</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RetryAttempts { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DelayInSeconds { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Luego agregamos la implementaci√≥n del filtro en s√≠, que, cuando las tareas se repiten despu√©s de un error, aplicar√° la configuraci√≥n seg√∫n la configuraci√≥n de la cola y supervisar√° el n√∫mero de reintentos: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireRetryJobFilter</span></span> : <span class="hljs-title"><span class="hljs-title">JobFilterAttribute</span></span>, <span class="hljs-title"><span class="hljs-title">IElectStateFilter</span></span>, <span class="hljs-title"><span class="hljs-title">IApplyStateFilter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HangfireQueueSettings _defaultQueueSettings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { RetryAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span>, DelayInSeconds = <span class="hljs-number"><span class="hljs-number">10</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, HangfireQueueSettings&gt; _settings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, HangfireQueueSettings&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HangfireQueueSettings <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> queueName] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _settings.TryGetValue(queueName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> HangfireQueueSettings queueSettings) ? queueSettings : _defaultQueueSettings; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _settings[queueName] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStateElection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElectStateContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(context.CandidateState <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> FailedState failedState)) { <span class="hljs-comment"><span class="hljs-comment">// This filter accepts only failed job state. return; } var retryAttempt = context.GetJobParameter&lt;int&gt;("RetryCount") + 1; var queueName = context.GetJobParameter&lt;string&gt;("QueueName"); if (retryAttempt &lt;= this[queueName].RetryAttempts) { ScheduleAgainLater(context, retryAttempt, failedState, queueName); } else { TransitionToDeleted(context, failedState, queueName); } } public void OnStateApplied( ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.NewState is ScheduledState &amp;&amp; context.NewState.Reason != null &amp;&amp; context.NewState.Reason.StartsWith("Retry attempt")) { transaction.AddToSet("retries", context.BackgroundJob.Id); } } public void OnStateUnapplied( ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.OldStateName == ScheduledState.StateName) { transaction.RemoveFromSet("retries", context.BackgroundJob.Id); } } private void ScheduleAgainLater( ElectStateContext context, int retryAttempt, FailedState failedState, string queueName) { context.SetJobParameter("RetryCount", retryAttempt); var delay = TimeSpan.FromSeconds(this[queueName].DelayInSeconds); const int maxMessageLength = 50; var exceptionMessage = failedState.Exception.Message.Length &gt; maxMessageLength ? failedState.Exception.Message.Substring(0, maxMessageLength - 1) + "‚Ä¶" : failedState.Exception.Message; // If attempt number is less than max attempts, we should // schedule the job to run again later. var reason = $"Retry attempt {retryAttempt} of {this[queueName].RetryAttempts}: {exceptionMessage}"; context.CandidateState = delay == TimeSpan.Zero ? (IState)new EnqueuedState { Reason = reason } : new ScheduledState(delay) { Reason = reason }; } private void TransitionToDeleted( ElectStateContext context, FailedState failedState, string queueName) { context.CandidateState = new DeletedState { Reason = this[queueName].RetryAttempts &gt; 0 ? "Exceeded the maximum number of retry attempts." : "Retries were disabled for this job." }; } }</span></span></code> </pre> <br><blockquote>  Nota para el c√≥digo: al implementar la clase <code>HangfireRetryJobFilter</code> , se tom√≥ como base la clase <code>AutomaticRetryAttribute</code> de <code>HangfireRetryJobFilter</code> , por lo tanto, la implementaci√≥n de algunos m√©todos coincide parcialmente con los m√©todos correspondientes de esta clase. </blockquote><br><h3 id="problema-3---kak-otpravit-zadachu-na-vypolnenie-v-konkretnuyu-ochered">  Problema 3: ¬øc√≥mo enviar una tarea a una cola espec√≠fica? </h3><br><p>  Logr√© encontrar dos formas de asignar la tarea a la cola: documentada y - no. </p><br><p>  <strong>1er m√©todo</strong> : cuelgue el atributo correspondiente en el m√©todo </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Queue(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"video_queue"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } BackgroundJob.Enqueue(() =&gt; SomeMethod());</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://docs.hangfire.io/en/latest/background-processing/configuring-queues.html</a> </p><br><p>  <strong>Segundo m√©todo</strong> (no documentado): use la clase <code>BackgroundJobClient</code> </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundJobClient(); client.Create(() =&gt; MyMethod(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnqueuedState(<span class="hljs-string"><span class="hljs-string">"video_queue"</span></span>));</code> </pre> <br><p>  La ventaja del segundo m√©todo es que no crea dependencias innecesarias en Hangfire y le permite decidir durante qu√© proceso debe realizarse la tarea.  Desafortunadamente, en la documentaci√≥n oficial, no encontr√© menci√≥n de la clase <code>BackgroundJobClient</code> y c√≥mo aplicarla.  Utilic√© el segundo m√©todo en mi soluci√≥n, por lo que se prueba en la pr√°ctica. </p><br><h3 id="zaklyuchenie">  Conclusi√≥n </h3><br><p>  En este art√≠culo, utilizamos el soporte de m√∫ltiples colas en Hangfire para separar el procesamiento de diferentes tipos de tareas.  Implementamos nuestro mecanismo para repetir tareas completadas sin √©xito con la posibilidad de una configuraci√≥n individual para cada cola, expandiendo la funcionalidad de Hangfire usando los filtros de trabajo, y tambi√©n aprendimos c√≥mo enviar tareas a la cola deseada para su ejecuci√≥n. </p><br><p>  Espero que este art√≠culo sea √∫til para alguien.  Estar√© encantado de comentar. </p><br><h3 id="poleznye-ssylki">  Enlaces utiles </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentaci√≥n de Hangfire</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo fuente de Hangfire</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Scott Hanselman - C√≥mo ejecutar tareas en segundo plano en ASP.NET</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434364/">https://habr.com/ru/post/es434364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434354/index.html">Crear un modelo de reconocimiento facial utilizando el aprendizaje profundo en Python</a></li>
<li><a href="../es434356/index.html">Python Stiller con correo electr√≥nico</a></li>
<li><a href="../es434358/index.html">Sustituci√≥n de importaciones de sistemas operativos. ¬øC√≥mo veo el sistema operativo dom√©stico?</a></li>
<li><a href="../es434360/index.html">Charla explicada sobre programaci√≥n asincr√≥nica en Javascript</a></li>
<li><a href="../es434362/index.html">NO pronosticado para 2019</a></li>
<li><a href="../es434368/index.html">Aprendizaje autom√°tico para encontrar errores en el c√≥digo: c√≥mo hice pr√°cticas en JetBrains Research</a></li>
<li><a href="../es434370/index.html">Otro conquistador de la sombra en Phaser, o el uso de bicicletas.</a></li>
<li><a href="../es434374/index.html">Comprobaci√≥n de RBAC en Kubernetes</a></li>
<li><a href="../es434380/index.html">Conceptos b√°sicos de inyecci√≥n de dependencia</a></li>
<li><a href="../es434382/index.html">Portar Alpine Linux a RISC-V</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>