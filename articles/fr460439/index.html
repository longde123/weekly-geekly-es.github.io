<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏻 😭 📮 Langage de programmation P4 🐀 🛅 👴🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="P4 est un langage de programmation conçu pour programmer des règles de routage de paquets. Contrairement à un langage à usage général tel que C ou Pyt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Langage de programmation P4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fgts/blog/460439/"><div style="text-align:center;"><img width="670" height="330" src="https://habrastorage.org/webt/hb/w7/o-/hbw7o-cd3zovgayloqdt6cfirjg.png"></div><br>  P4 est un langage de programmation conçu pour programmer des règles de routage de paquets.  Contrairement à un langage à usage général tel que C ou Python, P4 est un langage spécifique au domaine avec un certain nombre de constructions optimisées pour le routage réseau. <br><br>  P4 est un langage open source sous licence et pris en charge par une organisation à but non lucratif appelée P4 Language Consortium.  Il est également soutenu par l'Open Networking Foundation (ONF) et la Linux Foundation (LF), les deux plus grandes organisations faîtières dans les projets de mise en réseau open source. <a name="habracut"></a><br>  Le langage a été initialement inventé en 2013 et décrit en 2014 dans un document SIGCOMM CCR intitulé «Protocol Independent, Packet Routing Processor Programming». <br><br>  Depuis sa création, P4 a connu une croissance exponentielle et a évolué, devenant rapidement la norme pour décrire la transmission de paquets par les périphériques réseau, y compris les adaptateurs réseau, les commutateurs et les routeurs. <br><br>  «SDN a transformé l'industrie des réseaux et P4 fait passer SDN à un niveau supérieur, offrant une programmabilité dans le domaine du routage», a déclaré Guru Parulkar, directeur exécutif de l'Open Networking Foundation. <br><br>  Le langage P4 a été créé à l'origine par un groupe d'ingénieurs et de chercheurs de Google, Intel, Microsoft Research, Barefoot, Princeton et Stanford.  L'objectif était simple: créer un langage facile à utiliser qu'un développeur de logiciels peut apprendre en une journée et l'utiliser pour décrire avec précision la façon dont les paquets sont envoyés sur le réseau. <br><br>  Dès le début, P4 a été conçu pour être indépendant de l'objectif (c'est-à-dire qu'un programme écrit en P4 pourrait être compilé tel quel à diverses fins, comme ASIC, FPGA, CPU, NPU et GPU). <br><br>  De plus, le langage est indépendant du protocole (c'est-à-dire que le programme P4 peut décrire des protocoles standard existants ou peut être utilisé pour indiquer de nouveaux modes d'adressage personnalisés). <br><br>  Dans l'industrie, P4 est utilisé pour programmer des appareils.  Peut-être qu'à l'avenir, les normes Internet-RFC et IEEE incluront également la spécification P4. <br><br>  P4 peut être utilisé pour les appareils programmables et à fonction fixe.  Par exemple, il est utilisé pour enregistrer avec précision le comportement du pipeline de commutateurs dans les API Switch Abstraction Interface (SAI) utilisées par le système d'exploitation de commutateur SONiC open source.  P4 est également utilisé dans le projet ONF Stratum pour décrire le comportement de commutation sur une variété d'appareils fixes et programmables. <br><br>  La première description du comportement du commutateur et des adaptateurs réseau vous permet de créer un modèle exécutable précis de l'ensemble du réseau avant le déploiement.  Les grands fournisseurs de cloud peuvent tester et déboguer entièrement le réseau à l'aide d'un logiciel, ce qui réduit considérablement le temps et le coût des tests des interactions de laboratoire sans nécessiter d'équipement coûteux. <br><br>  À l'aide de P4, les fournisseurs d'équipements réseau peuvent s'appuyer sur un comportement de routage de base commun à tous les produits, ce qui permet la réutilisation de l'infrastructure de test, simplifie le développement de logiciels de gestion et garantit en fin de compte l'interopérabilité. <br><br>  Bien sûr, P4 peut être utilisé pour écrire des programmes qui décrivent des méthodes de routage complètement nouvelles.  Par exemple, P4 est largement utilisé pour la télémétrie et les mesures dans les centres de données, les réseaux d'entreprise et les fournisseurs de services. <br><br>  La communauté des chercheurs s'est également intensifiée.  Plusieurs grands groupes de recherche en technologie de réseau universitaire ont publié de nouvelles applications intéressantes basées sur des programmes P4, notamment l'équilibrage de charge, des protocoles cohérents et la mise en cache des valeurs clés.  Un nouveau paradigme de programmation est en cours de création, les innovations passent du matériel au logiciel, ce qui permet à de nombreuses idées inattendues, nouvelles et brillantes d'apparaître. <br><br>  La communauté de développement a apporté des contributions importantes au développement de code, notamment des compilateurs, des pipelines, des modèles comportementaux, des API, des environnements de test, des applications, etc.  Il existe des développeurs dédiés dans des sociétés telles que Alibaba, AT&amp;T, Barefoot, Cisco, Fox Networks, Google, Intel, IXIA, Juniper Networks, Mellanox, Microsoft, Netcope, Netronome, VMware, Xilinx et ZTE;  des universités, y compris BUPT, Cornell, Harvard, MIT, NCTU, Princeton, Stanford, Technion, Tsinghua, UMass et USI;  et les projets open source, notamment CORD, FD.io, OpenDaylight, ONOS, OvS, SAI et Stratum, mettent en évidence le fait que P4 est un projet communautaire indépendant. <br><br>  Génération typique d'un contrôleur P4: <br><br><div style="text-align:center;"><img width="602" height="409" src="https://habrastorage.org/webt/7q/07/am/7q07amo-jzmkmtiut50ptueiesu.png"></div><br><br><h2>  <font color="#1B469F">Perspectives d'application</font> </h2><br><div style="text-align:center;"><img width="467" height="300" src="https://habrastorage.org/webt/eq/h0/e2/eqh0e289qu_lsq8-cgx_jprgwjw.png"></div><br>  Étant donné que le langage est destiné au routage d'applications, la liste des exigences et des options de conception est différente de celle des langages de programmation à usage général.  Les principales caractéristiques du langage sont: <br><br><ol><li>  Indépendance par rapport à la mise en œuvre de l'objectif; </li><li>  Indépendance du ou des protocoles utilisés; </li><li>  Reconfigurabilité sur le terrain. </li></ol><br>  <b>Indépendance par rapport à la mise en œuvre cible</b> <br><br>  Les programmes P4 sont conçus pour être indépendants de l'implémentation, ce qui signifie qu'ils peuvent être compilés pour de nombreux types différents de machines exécutives, telles que les processeurs à usage général, les FPGA, les systèmes sur puce, les processeurs de réseau et les ASIC.  Ces différents types de machines sont appelés cibles P4, et un compilateur est requis pour chaque cible pour convertir le code source P4 en modèle de commutateur cible.  Le compilateur peut être intégré dans l'appareil cible, un logiciel externe ou même un service cloud.  Étant donné que bon nombre des objectifs d'origine des programmes P4 étaient utilisés pour une simple commutation de paquets, vous pouvez souvent entendre le terme «commutateur P4», même si l'utilisation de «P4 cible» est plus correcte. <br><br>  <b>Indépendance du ou des protocoles utilisés</b> <br><br>  P4 est indépendant du protocole.  Cela signifie que la langue n'a pas de prise en charge intégrée pour les protocoles courants tels que IP, Ethernet, TCP, VxLAN ou MPLS.  Au lieu de cela, le programmeur P4 décrit les formats d'en-tête et les noms de champ des protocoles requis dans le programme, qui à leur tour sont interprétés et traités par le programme compilé et le périphérique cible. <br><br>  <b>Reconfigurabilité sur le terrain</b> <br><br>  L'indépendance du protocole et le modèle de langage abstrait permettent une reconfigurabilité - les cibles P4 devraient pouvoir modifier le traitement des paquets après le déploiement du système.  Cette fonctionnalité est traditionnellement associée au routage via des processeurs à usage général ou des processeurs de réseau, plutôt que des circuits intégrés à fonctions fixes. <br><br>  Bien qu'aucun langage ne puisse empêcher l'optimisation d'un certain ensemble de protocoles, ces optimisations sont invisibles pour l'auteur de la langue et peuvent, à terme, réduire la flexibilité du système et du but et leur reconfigurabilité. <br><br>  Ces caractéristiques de la langue ont été à l'origine posées par ses créateurs avec une orientation vers son utilisation répandue dans l'infrastructure de réseau. <br><br>  Déjà, la langue est utilisée dans de nombreuses entreprises: <br><br>  <b>1) Centres de données hyperscales;</b> <br><br>  La société chinoise Tencent est la plus grande société d'investissement au monde et l'une des plus grandes sociétés de capital-risque.  Les filiales de Tencent, tant en Chine que dans d'autres pays du monde, se spécialisent dans divers domaines des activités de haute technologie, y compris divers services Internet, les développements dans le domaine de l'intelligence artificielle et du divertissement électronique. <br><br>  P4 et le routage programmable sont des technologies avancées utilisées dans l'architecture de réseau de l'entreprise. <br><br>  En tant que créateur, Google est fier de noter l'introduction rapide du P4 dans l'industrie des réseaux et, en particulier, dans le domaine de la conception architecturale des centres de données. <br><br>  <b>2) sociétés commerciales;</b> <br><br>  Goldman Sachs, profitant de sa collaboration avec la communauté open source et du développement de normes et de solutions communes, apporte déjà l'innovation à l'infrastructure réseau et propose les meilleures solutions aux clients. <br><br>  <b>3) Production;</b> <br><br>  L'ensemble de l'industrie des réseaux bénéficiera d'un langage comme P4, qui définit de manière unique le comportement de renvoi d'appel.  Considérez également dans Cisco, le transfert de leurs gammes de produits pour utiliser cette langue. <br><br>  Juniper Networks a inclus le Runtime P4 et P4 dans un certain nombre de produits et fournit un accès programmatique au processeur intégré Juniper et à son code de programme. <br><br>  Ruijie Networks est un partisan actif du P4 et des avantages qu'il apporte aux réseaux.  Avec P4, une entreprise peut créer et fournir des solutions de pointe pour un large éventail de clients. <br><br>  <b>4) Fournisseurs de télécommunications;</b> <br><br>  AT&amp;T a été l'un des premiers partisans de P4, l'un des premiers à utiliser P4 pour déterminer le comportement qu'il voulait voir sur les réseaux et à utiliser des dispositifs de transfert programmables P4 sur son réseau. <br><br>  Deutsche Telekom utilise le langage pour prototyper les fonctions clés du réseau dans le cadre d'Access 4.0. <br><br>  <b>5) Industrie des semi-conducteurs;</b> <br><br>  Le langage a permis de mettre en œuvre un nouveau paradigme pour le transfert de capacités logicielles vers le plan de routage réseau par Barefoot. <br><br>  Xilinx a été l'un des fondateurs de P4.org et a participé activement au développement du langage P4 et l'a implémenté dans des plates-formes programmables FPGA pour les équipements SmartNIC et NFV, libérant l'un des premiers compilateurs P4 <sub>16</sub> dans le cadre de la conception SDNet. <br><br>  <b>6) Logiciel.</b> <br><br>  VMware estime que P4 crée une énergie, une innovation et une communauté formidables qui mènent à une transformation significative et nécessaire du réseau.  VMware faisait à l'origine partie de ce mouvement de l'industrie, car une nouvelle vague d'innovation est entraînée par des approches logicielles qui étendent les capacités de l'infrastructure et la mettent en œuvre dans les derniers produits. <br><br>  Ainsi, P4 est un langage de programmation indépendant du but et du protocole utilisé par l'industrie et la communauté scientifique pour déterminer de manière unique le comportement du routage de paquets en tant que programme, qui, à son tour, peut être compilé à plusieurs fins.  Les objectifs actuels incluent les commutateurs matériels et logiciels, les commutateurs d'hyperviseur, les NPU, les GPU, les FPGA, les SmartNIC et les ASIC. <br><br>  Les principales caractéristiques du langage élargissent considérablement le champ d'application de son application et assurent sa mise en œuvre rapide dans l'architecture de réseau. <br><br><h2>  <font color="#1B469F">Par où commencer</font> </h2><br>  P4 est un projet open source; toutes les informations actuelles sont sur le site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P4.org</a> <br><br>  Lien vers le référentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/p4lang</a> , où vous pouvez obtenir le code source des exemples et des supports de formation. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Plugin</a> pour Eclipse avec prise en charge P4, mais nous pouvons recommander <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P4 Studio</a> de Barefoot. <br><br><div style="text-align:center;"><img width="602" height="358" src="https://habrastorage.org/webt/b0/62/dv/b062dvii5juvwxcnulh4pfrxbj0.jpeg"></div><br><br>  Analysons les principales abstractions du noyau: <br><br>  <b>Définition des en</b> - <b>têtes</b> - avec leur aide, les en-têtes du protocole sont définis. <br><br>  La définition des en-têtes définit: <br><br><ul><li>  description des formats de package et des noms de champ d'en-tête </li><li>  champs autorisés fixes et variables </li></ul><br>  Par exemple <br><br> <code><b>header</b> Ethernet_h{ <br> <b>bit</b> &lt;48&gt;  dstAddr; <br> <b>bit</b> &lt;48&gt;  srcAddr; <br> <b>bit</b> &lt;16&gt;  etherType; <br> } <br></code> <br><br> <code><b>header</b> IPv4_h{ <br> <b>bit</b> &lt;4&gt;  version; <br> <b>bit</b> &lt;4&gt;  ihl; <br> <b>bit</b> &lt;8&gt;  diffserv; <br> <b>bit</b> &lt;16&gt;  totalLen; <br> <b>bit</b> &lt;16&gt;  identification; <br> <b>bit</b> &lt;3&gt;  flags; <br> <b>bit</b> &lt;13&gt;  fragOffset; <br> <b>bit</b> &lt;8&gt;  ttl; <br> <b>bit</b> &lt;8&gt;  protocol; <br> <b>bit</b> &lt;16&gt;  hdrChecksum; <br> <b>bit</b> &lt;32&gt;  srcAddr; <br> <b>bit</b> &lt;32&gt;  dstAddr; <br> <b>varbit</b> &lt;320&gt;  options; <br> } <br></code> <br><br>  <b>Les analyseurs</b> sont leur tâche pour analyser les en-têtes. <br><br>  L'exemple d'analyse suivant déterminera la transition de l'état final d'une machine d'un état initial à l'un des deux états finaux: <br><br><div style="text-align:center;"><img width="400" height="200" src="https://habrastorage.org/webt/mm/hc/8w/mmhc8wkkyn1jkvlldtyszv6q8om.png"></div><br><br> <code><b>parser</b> MyParser(){ <br> state  start{transition parse_ethernet;} <br> state  parse_ethernet{ <br> packet.extract(hdr.ethernet); <br> transition select(hdr.ethernet.etherType){ <br> TYPE_IPV4: parse_ipv4; <br> default: accept; <br> } <br> }… <br> } <br></code> <br><br>  <b>Tables</b> - contiennent l'état de la machine associant les clés utilisateur aux actions.  <b>Actions</b> - Une description de la façon dont le package doit être manipulé. <br><br>  Les tableaux contiennent des états (définis au niveau de la gestion) pour le transfert des paquets, décrivent l'unité d'action de correspondance <br><br>  La correspondance des paquets est effectuée par: <br><br><ul><li>  Correspondance exacte </li><li>  Correspondance la plus longue avec un préfixe (LPM) </li><li>  Triple correspondance (masquage) </li></ul><br> <code><b>table</b> ipv4_lpm{ <br> <b>reads</b> { <br> ipv4.dstAddr: lpm; <br> } <b>actions</b> { <br> forward(); <br> } <br> }</code> <br> <br>  Toutes les actions possibles doivent être définies à l'avance dans les tableaux. <br><br>  Les actions consistent en du code et des données.  Les données arrivent au niveau de la gestion (par exemple, adresses IP / numéros de port).  Certaines primitives sans boucle peuvent être spécifiées directement en action, mais le nombre de commandes doit être prévisible.  Par conséquent, les actions ne peuvent contenir aucune boucle ni instruction conditionnelle. <br><br> <code><b>action</b> ipv4_forward(macAddr_t dstAddr, egressSpec_t port){ <br> standard_metadata.egress_spec = port; <br> hdr.ethernet.srcAddr = hdr.ethernet.dstAddr; <br> hdr.ethernet.dstAddr = dstAddr; <br> hdr.ipv4.ttl = hdr.ipv4.ttl - 1; <br> } <br></code> <br><br>  <b>Modules Match-Action</b> - actions pour créer une clé de recherche, rechercher dans un tableau, effectuer des actions. <br><br>  Un exemple de module typique est illustré dans la figure: <br><br><div style="text-align:center;"><img width="602" height="389" src="https://habrastorage.org/webt/wu/fs/xo/wufsxojasau1t4jrpnyljydudyg.png"></div><br><br>  <b>Flux de contrôle</b> - indique l'ordre d'application des modules Match-Action.  Il s'agit d'un programme impératif qui définit la logique de haut niveau et la séquence Match-Action.  Le flux de contrôle relie tous les objets, définissant le niveau de contrôle. <br><br>  <b>Les objets externes</b> sont des objets spécifiques avec une architecture et des API clairement définies.  Par exemple, calcul de la somme de contrôle, registres, compteurs, compteurs, etc. <br><br> <code><b>extern</b> register{ <br> register(bit&lt;32&gt; size); <br> <b>void</b> read(out T result, in bit&lt;32&gt; index); <br> <b>void</b> write(in bit&lt;32&gt; index, in T value); <br> } <br></code> <br><br> <code><b>extern</b> Checksum16{ <br> Checksum16();    //constructor <br> <b>void</b> clear();    //prepare unit for computation <br> <b>void</b> update(in T data);    //add data to checksum <br> <b>void</b> remove(in T data);  /remove data from existing checksum <br> <b>bit</b> &lt;16&gt; get(); //get the checksum for the data added since last clear <br> } <br></code> <br>  <b>Les métadonnées</b> sont la structure de données associée à chaque package. <br><br>  Il existe 2 types de métadonnées: <br><br>  <b>Métadonnées personnalisées (structure vide pour tous les packages)</b> <br>  Vous pouvez mettre tout ce que vous voulez ici <br>  Disponible partout dans le pipeline <br>  pratique pour votre propre usage, par exemple, pour stocker le hachage d'un paquet <br><br>  <b>Métadonnées internes - fournies par l'architecture</b> <br>  Le port d'entrée et le port de sortie sont définis ici <br>  Horodatage de la mise en file d'attente du paquet, profondeur de la file d'attente <br>  hachage de multidiffusion / file d'attente de multidiffusion <br>  Priorité du package, importance du package <br>  Spécification du port de sortie (par exemple, file d'attente de sortie) <br><br><h2>  <font color="#1B469F">Compilateur P4</font> </h2><br>  Le compilateur P4 (P4C) génère: <br><br><ol><li>  Exécution du plan de données </li><li>  API pour le contrôle de l'état de la machine dans le plan de données </li></ol><br><div style="text-align:center;"><img width="602" height="252" src="https://habrastorage.org/webt/py/6u/ub/py6uubwvudieedqy31iuica4w4u.png"></div><br><h2>  <font color="#1B469F">Un exemple de commutateur logiciel dans P4</font> </h2><br>  Les codes source peuvent être téléchargés à partir du référentiel. <br><br>  p4lang / p4c-bm: crée une configuration JSON pour bmv2 <br>  p4lang / bmv2: un commutateur logiciel qui comprend les configurations JSON de la version bmv2 <br><br>  La figure montre le diagramme de compilation du projet: <br><br><div style="text-align:center;"><img width="602" height="292" src="https://habrastorage.org/webt/um/ai/gi/umaigihuirmpetawiiozcyupug4.png"></div><br><br>  Manipulations avec tableaux, lecture de registres, compteur: <br><br><ul><li> <code>table_set_default &lt;table name&gt; &lt;action name&gt; &lt;action parameters&gt; table_add &lt;table name&gt; &lt;action name&gt; &lt;match fields&gt; =&gt; &lt;action <br> parameters&gt; [priority] table_delete &lt;table name&gt; &lt;entry handle&gt;</code> </li> <li> <code>table_set_default &lt;table name&gt; &lt;action name&gt; &lt;action parameters&gt; table_add &lt;table name&gt; &lt;action name&gt; &lt;match fields&gt; =&gt; &lt;action <br> parameters&gt; [priority] table_delete &lt;table name&gt; &lt;entry handle&gt;</code> </li> <li> <code>table_set_default &lt;table name&gt; &lt;action name&gt; &lt;action parameters&gt; table_add &lt;table name&gt; &lt;action name&gt; &lt;match fields&gt; =&gt; &lt;action <br> parameters&gt; [priority] table_delete &lt;table name&gt; &lt;entry handle&gt;</code> </li> </ul><br>  Le code source contient le programme simple_switch_CLI pour une utilisation pratique de l'API du commutateur logiciel. <br><br>  Vous pouvez télécharger cet exemple et d'autres dans le référentiel. <br><br><div style="text-align:center;"><img width="511" height="286" src="https://habrastorage.org/webt/fu/xv/dd/fuxvdd-cq7g1h8nrhcz6qyj5iqw.png"></div><br><br>  <b>PS</b> Au début de l'été, Intel a signé un accord pour acquérir Barefoot Networks, dans le but de répondre rapidement aux besoins des utilisateurs d'Hyperscale Cloud.  Selon Navin Shenoy (vice-président exécutif et directeur général du groupe Data Center chez Intel Corporation) - cela permettra à Intel de fournir des charges de travail plus importantes et plus d'opportunités aux clients des centres de données. <br><br>  À mon avis, n'oubliez pas qu'Intel est un leader dans la production de puces FPGA et qu'il dispose d'un excellent environnement Quartus.  Vous pouvez donc vous attendre à ce qu'avec l'avènement d'Intel, Barefoot élargisse non seulement sa gamme de produits, mais Quartus et P4 Studio recevront également de sérieuses mises à jour et ajouts aux gammes Toffino et Toffino 2. <br><br>  Le membre officiel de la communauté P4 est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Factor Group</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460439/">https://habr.com/ru/post/fr460439/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460425/index.html">Rhume infernal, lévitation et plasma: passé, présent et futur de la supraconductivité</a></li>
<li><a href="../fr460431/index.html">Création d'un pipeline de tests automatisés sur Azure DevOps</a></li>
<li><a href="../fr460433/index.html">Risques et menaces sur l'Internet des objets</a></li>
<li><a href="../fr460435/index.html">Petty Little Joy # 8: Petits plaisirs pour travailler avec la base de données</a></li>
<li><a href="../fr460437/index.html">Comment nous mettons un vélo de support technique</a></li>
<li><a href="../fr460441/index.html">Gleb Nitzman: «J'ai trouvé la toute fin d'une époque où les gens n'avaient pas encore chassé l'or contenu dans les éléments radio»</a></li>
<li><a href="../fr460443/index.html">Concepteurs vs développeurs: sur l'histoire de la création de l'application «Ma ville intelligente»</a></li>
<li><a href="../fr460445/index.html">Cours magistral "Fondamentaux du traitement numérique du signal"</a></li>
<li><a href="../fr460451/index.html">L'homme a fait sa troisième oreille pour que le monde entier l'utilise - pour l'art</a></li>
<li><a href="../fr460453/index.html">Imprimante intelligente. Amélioration d'Octoprint</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>