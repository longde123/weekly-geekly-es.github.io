<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöå üëµ ü•ë O MIRO √© uma plataforma de rob√¥ indoor aberta. Parte 5 - Componente de software: ARDUINO (AVR), subimos "sob o cap√¥" üìû üéì ü§¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desta vez, vamos examinar um pouco mais a fundo a implementa√ß√£o de alguns m√©todos principais da biblioteca para o ARDUINO (AVR), respons√°veis ‚Äã‚Äãpor mo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O MIRO √© uma plataforma de rob√¥ indoor aberta. Parte 5 - Componente de software: ARDUINO (AVR), subimos "sob o cap√¥"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477118/"><img src="https://habrastorage.org/webt/m-/j7/gm/m-j7gmvwywlwzlopp5x-27y_jta.png" alt="imagem"><br><br>  Desta vez, vamos examinar um pouco mais a fundo a implementa√ß√£o de alguns m√©todos principais da biblioteca para o ARDUINO (AVR), respons√°veis ‚Äã‚Äãpor mover o rob√¥ MIRO.  Esta parte ser√° interessante para todos que se perguntaram como controlar a velocidade linear e angular do rob√¥ no ARDUINO, equipado com motores com os codificadores mais simples. <br><a name="habracut"></a><br>  √çndice: <a href="https://habr.com/ru/post/472380/">Parte 1</a> , <a href="https://habr.com/ru/post/472802/">Parte 2</a> , <a href="https://habr.com/ru/post/473368/">Parte 3</a> , <a href="https://habr.com/ru/post/475512/">Parte 4</a> , <a href="https://habr.com/ru/post/477118/">Parte 5</a> . <br><br>  Os m√©todos respons√°veis ‚Äã‚Äãpela condu√ß√£o com odometria ainda s√£o um problema para explicar como, o que e por qu√™.  A primeira coisa que voc√™ precisa saber sobre como controlar o movimento do rob√¥ √© o fato simples e √≥bvio de que os motores coletores do rob√¥ nunca giram na mesma velocidade sem ajustes adicionais.  Embreagem diferente, caracter√≠sticas de sa√≠da diferentes dos canais do motorista, motores el√©tricos ligeiramente diferentes e lubrifica√ß√£o na caixa de c√¢mbio. <br><br>  O segundo fato que voc√™ deve entender e conhecer √© a presen√ßa de in√©rcia no motor, mesmo com uma rela√ß√£o de transmiss√£o suficientemente grande.  I.e.  ao remover a tens√£o dos terminais do motor, a roda, mesmo sem carga, faz um movimento mais alguns graus.  A magnitude dessa rota√ß√£o adicional depende da for√ßa de carga na roda, da velocidade de rota√ß√£o antes de aliviar o estresse e dos mesmos fatores invis√≠veis, como o tipo e a quantidade de lubrificante na caixa de engrenagens. <br><br>  Esses fatos determinam a implementa√ß√£o de um grupo de m√©todos relacionados ao movimento de um chassi equipado com sensores odom√©tricos (no caso do MIRO, codificadores digitais de cada roda). <br><br>  Como descobrimos na quarta parte, no modelo de software existe a classe <b>Chassis</b> , que implementa o controle de rota√ß√£o de motores de chassi individuais.  Quero enfatizar - n√£o o controle do movimento do chassi, do carrinho, mas o controle dos motores do carrinho.  O controle direto do carrinho √© implementado nas classes <b>Robot</b> e <b>Miro</b> . <br><br>  Vamos come√ßar de cima.  Abaixo est√° um m√©todo da classe <b>Miro</b> que implementa o movimento de um rob√¥ a uma certa dist√¢ncia (dist√¢ncia, metros) com uma determinada <b>velocidade</b> linear ( <b>velocidade da linha</b> , m / s) e velocidade angular ( <b>velocidade da ang</b> , graus / s).  <b>Ainda</b> n√£o estamos prestando aten√ß√£o no par√¢metro <b>en_break</b> . <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Miro::moveDist(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lin_speed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ang_speed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> en_break) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _wheelSetAngSpeed[WHEEL_COUNT]; _wheelSetAngSpeed[LEFT] = MIRO_PI2ANG * (lin_speed - (ROBOT_DIAMETER * ang_speed / (<span class="hljs-number"><span class="hljs-number">2</span></span> * MIRO_PI2ANG))) / WHEEL_RADIUS; _wheelSetAngSpeed[RIGHT] = MIRO_PI2ANG * (lin_speed + (ROBOT_DIAMETER * ang_speed / (<span class="hljs-number"><span class="hljs-number">2</span></span> * MIRO_PI2ANG))) / WHEEL_RADIUS; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _wheelSetAng[WHEEL_COUNT]; _wheelSetAng[RIGHT] = _wheelSetAngSpeed[RIGHT] * dist / lin_speed; _wheelSetAng[LEFT] = _wheelSetAngSpeed[LEFT] * dist / lin_speed; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;chassis.wheelRotateAng(_wheelSetAngSpeed, _wheelSetAng, en_break); }</code> </pre> <br>  Neste m√©todo, as velocidades angulares NECESS√ÅRIAS para os motores esquerdo e direito s√£o calculadas primeiro.  De acordo com f√≥rmulas bastante √≥bvias, o que n√£o √© um problema para deduzir.  S√≥ √© necess√°rio ter em mente que a velocidade linear no m√©todo √© especificada em metros por segundo e a velocidade angular em graus por segundo (n√£o em radianos).  Portanto, pr√©-calculamos a constante <b>MIRO_PI2ANG = 57.29 = 180 / pi.</b>  <b>ROBOT_DIAMETER</b> - dist√¢ncia entre as rodas esquerda e direita do rob√¥ (em metros), <b>WHEEL_RADIUS</b> - raio da roda (tamb√©m em metros).  Todas as constantes num√©ricas para esses casos est√£o contidas no arquivo defs.h, e os par√¢metros personalizados do rob√¥ e do chassi est√£o no arquivo config.h. <br><br>  Depois disso, o √¢ngulo √© calculado pelo qual cada roda deve ser girada para que o rob√¥ percorra a dist√¢ncia <b>dist</b> (tamb√©m em metros). <br><br>  Portanto, nesta fase, obtemos a que velocidade e em que √¢ngulo voc√™ precisa girar cada roda do chassi do rob√¥.  E ent√£o o m√©todo <b>wheelRotateAng ()</b> do objeto <b>chassi</b> √© chamado. <br><br>  O m√©todo <b>wheelRotateAng (float * speed, float * ang, bool en_break)</b> √© usado para girar as rodas do rob√¥ com as velocidades angulares especificadas pelo array <b>speed []</b> (em m / s) pelos √¢ngulos especificados pelo array <b>ang []</b> (em graus).  O √∫ltimo par√¢metro <b>en_break</b> (j√° encontrado por n√≥s anteriormente) define o requisito para uma parada <b>for√ßada</b> das rodas depois de fazer uma curva aplicando tens√£o reversa de curto prazo a elas.  Isso √© necess√°rio para suprimir a in√©rcia do rob√¥, impedindo que ele se mova al√©m da dist√¢ncia necess√°ria j√° ap√≥s remover a tens√£o de controle dos motores.  Para satisfa√ß√£o completa, √© claro, existe o m√©todo <b>wheelRotateAngRad ()</b> , semelhante ao <b>wheelRotateAng (),</b> com a diferen√ßa de considerar os valores dos √¢ngulos de rota√ß√£o e das velocidades angulares em radianos e radianos por segundo como par√¢metros. <br><br>  O algoritmo do m√©todo <b>wheelRotateAng ()</b> √© o seguinte. <br><br>  1. Primeiro, a correspond√™ncia dos valores de <b>velocidade []</b> e <b>ang [] para</b> algumas condi√ß√µes de contorno √© verificada.  Obviamente, o chassi tem limita√ß√µes f√≠sicas tanto na velocidade angular m√°xima de rota√ß√£o das rodas quanto na m√≠nima (velocidade m√≠nima de afastamento).  Al√©m disso, os √¢ngulos em <b>ang []</b> n√£o podem ser menores que o √¢ngulo fixo m√≠nimo de rota√ß√£o, determinado pela precis√£o dos codificadores. <br><br>  2. Em seguida, o sentido de rota√ß√£o de cada roda √© calculado.  Obviamente, atrav√©s do sinal do produto <b>ang [i] * velocidade [i]</b> ; <br><br>  3. A ‚Äúdist√¢ncia de rota√ß√£o‚Äù <b>Dw [i]</b> para cada roda √© calculada - o n√∫mero de amostras do codificador que devem ser feitas para girar pelo <b>√¢ngulo [i]</b> fornecido. <br>  Este valor √© determinado pela f√≥rmula: <br><br>  <b>Dw [i] = ang [i] * WHEEL_SEGMENTS / 360</b> , <br>  onde <b>WHEEL_SEGMENTS</b> √© o n√∫mero de segmentos da roda do codificador (rota√ß√£o completa). <br><br>  4. O valor da tens√£o no acionador do motor √© registrado. <br><br><div class="spoiler">  <b class="spoiler_title">Sobre a tens√£o nos motores</b> <div class="spoiler_text">  * O <i>PWM √© usado para controlar a rota√ß√£o dos motores; portanto, para conhecer a tens√£o fornecida a cada motor, √© necess√°rio conhecer a tens√£o de alimenta√ß√£o do acionador do motor.</i>  <i>No rob√¥ MIRO, o driver √© conectado diretamente ao circuito de energia da bateria.</i>  <i>Fun√ß√£o float getVoltage ();</i>  <i>retorna a voltagem de um divisor de voltagem com um fator de VOLTAGE_DIVIDER.</i>  <i>Tens√£o de refer√™ncia ADC: 5V.</i>  <i>No momento, o valor de VOLTAGE_DIVIDER no rob√¥ √© 2 e a tens√£o de um banco (1S) da bateria √© fornecida √† entrada ADC (PIN_VBAT).</i>  <i>Isso n√£o est√° totalmente correto devido ao fato de que os bancos de baterias podem descarregar de maneiras diferentes e perder o equil√≠brio, mas, como a pr√°tica demonstrou, com uma carga constante de uma bateria com balanceamento, a solu√ß√£o est√° funcionando.</i>  <i>No futuro, planejamos fazer um divisor normal com duas latas de bateria.</i> <br></div></div><br>  5. De acordo com a tabela de calibra√ß√£o de cada roda, √© determinado o valor inicial do sinal PWM, o que garante a rota√ß√£o da roda com a velocidade necess√°ria <b>[i]</b> .  Que tipo de tabela de calibra√ß√£o e de onde ela veio - analisaremos mais adiante. <br><br>  6. A rota√ß√£o dos motores √© iniciada de acordo com os valores calculados de velocidade e dire√ß√£o de rota√ß√£o.  No texto da implementa√ß√£o da classe, o m√©todo privado <b>_wheel_rotate_sync ()</b> √© respons√°vel por isso. <br><br>  N√≥s vamos ainda mais fundo.  O m√©todo <b>_wheel_rotate_sync ()</b> funciona de acordo com o seguinte algoritmo: <br><br>  1. Em um loop infinito, √© feita uma verifica√ß√£o para atingir o contador das respostas do encoder da dist√¢ncia de giro <b>Dw [i]</b> para cada roda.  Se QUALQUER um dos contadores <b>Dw [i]</b> for alcan√ßado, todas as rodas param e saem do ciclo e depois saem da fun√ß√£o (passo 5).  Isso √© feito pelos seguintes motivos.  Devido √† discri√ß√£o de medir o √¢ngulo de rota√ß√£o, √© uma situa√ß√£o muito comum quando a dist√¢ncia calculada <b>Dw [i] de</b> uma roda √© obtida arredondando um valor n√£o inteiro para um lado menor e <b>Dw [j] da</b> segunda roda para um maior.  Isso leva ao fato de que, depois de parar uma das rodas, a segunda roda continua a girar.  Para um chassi com uma unidade diferencial (e para muitos outros), isso leva a uma "virada" n√£o planejada do rob√¥ no final da tarefa.  Portanto, no caso de organizar o movimento espacial de todo o chassi, √© necess√°rio parar todos os motores de uma s√≥ vez. <br><br>  2. Se <b>Dw [i]</b> n√£o <b>for</b> alcan√ßado, no loop √© verificado o fato da pr√≥xima opera√ß√£o do codificador (a vari√°vel <b>_syncloop [w]</b> , atualizada a partir da interrup√ß√£o do codificador e redefinida neste loop infinito).  Quando a pr√≥xima interse√ß√£o ocorre, o programa calcula o m√≥dulo da velocidade angular atual de cada roda (graus / s), de acordo com a f√≥rmula √≥bvia: <br><br>  <b>W [i] = (360 * tau [i]) / WHEEL_SEGMENTS</b> , <br>  onde: <br>  <b>tau [i]</b> - o valor m√©dio do tempo entre as duas √∫ltimas respostas dos codificadores.  A "profundidade" do filtro de m√©dia √© determinada por <b>MEAN_DEPTH</b> e o padr√£o √© 8. <br><br>  3. Com base nas velocidades calculadas das rodas, os erros absolutos s√£o calculados como as diferen√ßas entre as velocidades angulares definidas e reais. <br><br>  4. Com base nos erros calculados, a a√ß√£o de controle (valor do sinal PWM) √© corrigida para cada motor. <br><br>  5. Ap√≥s atingir <b>Dw [i]</b> , no caso de uma <b>quebra</b> ativa, a tens√£o de curto prazo reversa √© aplicada aos motores.  A dura√ß√£o desse efeito √© determinada na tabela de calibra√ß√£o (veja abaixo) e geralmente varia de 15 a 40 ms. <br><br>  6. H√° uma libera√ß√£o completa de tens√£o dos motores e saia <b>_wheel_rotate_sync ()</b> . <br><br>  Eu j√° mencionei certa tabela de calibra√ß√£o duas vezes.  Portanto, na biblioteca, h√° uma tabela especial de valores armazenados na EEPROM da mem√≥ria do rob√¥ e contendo registros de tr√™s valores relacionados: <br><br>  1. Tens√£o nos terminais do motor.  √â calculado convertendo o valor do sinal PWM na tens√£o real.  Para isso, na etapa 4 do m√©todo <b>wheelRotateAng ()</b> , a tens√£o real no driver do motor √© registrada. <br><br>  2. A velocidade angular de rota√ß√£o da roda (sem carga) correspondente a uma determinada tens√£o. <br><br>  3. A dura√ß√£o do sinal de parada for√ßada correspondente a essa velocidade angular. <br>  Por padr√£o, o tamanho da tabela de calibra√ß√£o √© de 10 registros (determinados pela constante <b>WHEEL_TABLE_SIZE</b> no arquivo <b>config.h</b> ) - 10 triplos dos valores ‚Äútens√£o - velocidade angular - dura√ß√£o do sinal de parada‚Äù. <br><br>  Para determinar os valores das entradas 2 e 3 nesta tabela, √© usado um m√©todo especial - <b>wheelCalibrate (byte wheel)</b> . <br><br>  Vamos dar uma olhada nisso.  Este m√©todo implementa uma sequ√™ncia de a√ß√µes para determinar os valores ausentes na tabela de calibra√ß√£o do motor / roda, bem como descobrir a velocidade angular m√≠nima de partida e a velocidade angular m√°xima da roda. <br><br>  Para executar a calibra√ß√£o, o rob√¥ √© montado em um suporte; toda a rota√ß√£o da roda durante a calibra√ß√£o √© realizada sem carga. <br><br>  1. Primeiro voc√™ precisa determinar a velocidade inicial m√≠nima.  Isso √© feito de maneira muito simples.  Em um ciclo, o controle PWM √© alimentado ao motor, iniciando em 0, com um incremento de 1. A cada etapa, o programa aguarda algum tempo, determinado pela constante <b>WHEEL_TIME_MAX</b> ( <b>atraso</b> normal <b>()</b> ).  Ap√≥s o tempo de espera, ele verifica se o in√≠cio foi conclu√≠do (alterando o valor do contador do codificador).  Se a retirada for conclu√≠da, a velocidade angular de rota√ß√£o da roda √© calculada.  Para maior seguran√ßa, o valor 10 √© adicionado ao valor do PWM correspondente a essa velocidade inicial, o que d√° o primeiro par de valores ‚Äútens√£o no motor‚Äù - ‚Äúvelocidade angular‚Äù. <br><br>  2. Depois que a velocidade inicial for encontrada, a etapa PWM √© calculada para preencher uniformemente a tabela de calibra√ß√£o. <br><br>  3. No ciclo, para cada novo valor de PWM, a roda √© girada 2 voltas completas e a velocidade angular √© medida de acordo com um algoritmo semelhante ao m√©todo <b>_wheel_rotate_sync ()</b> .  No mesmo ciclo, tamb√©m por aproxima√ß√£o sucessiva, √© medido o valor √≥timo da dura√ß√£o do sinal de parada for√ßada.  Inicialmente, algum valor obviamente grande √© obtido.  E ent√£o √© testado no modo "turn-stop".  Como o ideal, o valor m√°ximo da dura√ß√£o do sinal de parada √© selecionado, no qual a ‚Äúdist√¢ncia de rota√ß√£o‚Äù definida n√£o √© excedida.  Em outras palavras, esse valor da dura√ß√£o do sinal, quando o suprimento √© fornecido ao motor, por um lado, a in√©rcia √© suprimida e, por outro lado, n√£o h√° movimento reverso de curto prazo (que √© fixado pelo mesmo codificador). <br><br>  4. Ap√≥s a calibra√ß√£o, a tens√£o de controle do motor calibrado deixa de ser aplicada e a tabela de calibra√ß√£o dessa roda √© registrada na EEPROM. <br><br>  Omiti todos os tipos de trivialidades de implementa√ß√£o e tentei afirmar a ess√™ncia.  Voc√™ pode perceber que os <b>m√©todos wheelRotateAng ()</b> e <b>wheelRotateAngRad ()</b> est√£o bloqueando fun√ß√µes.  Esse √© o pre√ßo pela precis√£o do movimento e por uma integra√ß√£o bastante simples nos esbo√ßos do usu√°rio.  Seria poss√≠vel criar um gerenciador de tarefas pequeno com tempo fixo, mas isso exigiria que o usu√°rio incorporasse sua funcionalidade estritamente na cota de tempo alocada. <br><br>  E para um aplicativo sem bloqueio, a API tem a fun√ß√£o <b>wheelRotate (float * speed)</b> .  Como pode ser visto na lista de par√¢metros, simplesmente executa a rota√ß√£o das rodas com as velocidades definidas.  E a velocidade de rota√ß√£o √© ajustada no m√©todo <b>Sync ()</b> do chassi do rob√¥, chamado no m√©todo <b>Sync ()</b> do objeto da classe Miro com o mesmo nome.  E de acordo com os requisitos para a estrutura do esbo√ßo do usu√°rio, esse m√©todo deve ser chamado a cada itera√ß√£o do <b>loop</b> principal <b>() do loop</b> ARDUINO. <br><br>  Na etapa 4, na descri√ß√£o do m√©todo <b>_wheel_rotate_sync ()</b> , mencionei a "corre√ß√£o de controle" do mecanismo.  Como voc√™ adivinhou)?  Este √© o controlador PID).  Bem, mais precisamente controlador PD.  Como voc√™ sabe (de fato - nem sempre), a melhor maneira de determinar os coeficientes do regulador √© a sele√ß√£o).  H√° uma defini√ß√£o no arquivo de configura√ß√£o config.h: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEBUG_WHEEL_PID</span></span></code> </pre><br>  Se voc√™ descoment√°-lo, quando voc√™ chamar o m√©todo <b>moveDist ()</b> da classe Miro, o seguinte gr√°fico invertido do erro relativo no controle da velocidade angular de uma das rodas do rob√¥ (esquerda) ser√° exibido no console do rob√¥. <br><br> <a href=""><img src="https://habrastorage.org/webt/_v/4i/hr/_v4ihrxfnzpq-fvnofq_3kjkcz0.png"></a> <br><br>  N√£o se parece com nada)?  Down √© o tempo (cada barra √© uma etapa do ciclo de controle) e o valor do erro √© salvo √† direita (com o sinal preservado).  Aqui est√£o dois pares de gr√°ficos na mesma escala com diferentes coeficientes do controlador PD.  "Humps" s√£o apenas as "ondas" do overshoot.  Os n√∫meros nas barras horizontais s√£o um erro relativo (com preserva√ß√£o do sinal).  Visualiza√ß√£o simples do regulador, ajudando a ajustar manualmente os coeficientes.  Com o tempo, espero fazer uma configura√ß√£o autom√°tica, mas por enquanto. <br><br>  Aqui est√° uma del√≠cia :-) <br><br>  Bem, por fim, vejamos um exemplo.  Diretamente da biblioteca API_Miro_moveDist: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Miro.h&gt; using namespace miro; byte PWM_pins[2] = { 5, 6 }; byte DIR_pins[2] = { 4, 7 }; byte ENCODER_pins[2] = { 2, 3 }; Miro robot(PWM_pins, DIR_pins, ENCODER_pins); int laps = 0; void setup() { Serial.begin(115200); } void loop() { for (unsigned char i = 0; i &lt; 4; i++) { robot.moveDist(robot.getOptLinSpeed(), 0, 1, true); delay(500); robot.rotateAng(0.5*robot.getOptAngSpeed(), -90, true); delay(500); } Serial.print("Laps: "); Serial.println(laps); laps++; }</span></span></span></span></code> </pre><br>  A partir do texto do programa, tudo deve ficar claro.  Como funciona - no v√≠deo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Bd96kgY2YsY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ladrilhos de 600 x 600 mm e intervalos de 5 mm.  Em teoria, o rob√¥ deve contornar um quadrado com um lado de 1 metro.  Obviamente, a trajet√≥ria ‚Äúflutua‚Äù.  Mas, para ser sincero, vale a pena dizer que na vers√£o do rob√¥ que me resta para os testes, existem motores bastante rotativos que s√£o dif√≠ceis de conduzir lentamente.  Mas em alta velocidade e derrapagem, h√° um lugar para se estar, e a in√©rcia n√£o √© f√°cil de lidar.  Motores com uma rela√ß√£o de transmiss√£o mais alta (como mesmo em nossos rob√¥s MIRO, n√£o estavam dispon√≠veis durante o teste) devem se comportar um pouco melhor. <br><br>  Se houver momentos incompreens√≠veis, fico feliz em esclarecer, discutir e melhorar.  O feedback geralmente √© interessante. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt477118/">https://habr.com/ru/post/pt477118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt477098/index.html">Lidamos com transmiss√£o de v√≠deo em resolu√ß√£o 4K a 60 Hz atrav√©s de um hub USB-C</a></li>
<li><a href="../pt477100/index.html">Maratona T√©cnica do Microsoft Dynamics 365</a></li>
<li><a href="../pt477104/index.html">IntelliSense assistido por IA para a base de c√≥digo de sua equipe</a></li>
<li><a href="../pt477110/index.html">Planejamento divertido</a></li>
<li><a href="../pt477114/index.html">Implementa√ß√£o do interpretador MSH</a></li>
<li><a href="../pt477120/index.html">Software de monitoramento cont√≠nuo de glicose no sangue para Windows</a></li>
<li><a href="../pt477122/index.html">O c√©rebro da empresa. Parte 3</a></li>
<li><a href="../pt477124/index.html">Bitcoin em uma gaiola?</a></li>
<li><a href="../pt477126/index.html">Admin em 5 minutos. Front-end - react-admin, back-end - Flask-RESTful</a></li>
<li><a href="../pt477128/index.html">Detetive Habra no fim de semana</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>