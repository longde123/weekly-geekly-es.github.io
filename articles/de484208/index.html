<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÅ üéâ üßöüèΩ Verwendung des maschinellen Lernens bei der statischen Analyse des Programmquellcodes üí® üßë ‚õ∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Maschinelles Lernen ist in verschiedenen Bereichen der menschlichen T√§tigkeit tief verwurzelt: von der Spracherkennung bis zur medizinischen Diagnosti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwendung des maschinellen Lernens bei der statischen Analyse des Programmquellcodes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484208/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/0e0/738/38e0e0738ea8b928bdecb77040a207c1.png" alt="Verwendung des maschinellen Lernens bei der statischen Analyse des Programmquellcodes"></div><br>  Maschinelles Lernen ist in verschiedenen Bereichen der menschlichen T√§tigkeit tief verwurzelt: von der Spracherkennung bis zur medizinischen Diagnostik.  Die Popularit√§t dieses Ansatzes ist so gro√ü, dass sie versuchen, ihn zu verwenden, wo immer dies m√∂glich ist.  Einige Versuche, die klassischen Ans√§tze durch neuronale Netze zu ersetzen, sind nicht so erfolgreich.  Betrachten wir das maschinelle Lernen unter dem Gesichtspunkt der Erstellung effektiver statischer Code-Analysatoren zum Auffinden von Fehlern und potenziellen Schwachstellen. <br><a name="habracut"></a><br>  Das PVS-Studio-Team wird h√§ufig gefragt, ob wir mit dem maschinellen Lernen beginnen m√∂chten, um Fehler im Quellcode von Programmen zu finden.  Kurze Antwort: Ja, aber sehr begrenzt.  Wir glauben, dass der Einsatz von maschinellem Lernen bei Code-Analyse-Problemen viele Fallstricke mit sich bringt.  Im zweiten Teil des Artikels werden wir dar√ºber sprechen.  Beginnen wir mit einer √úberpr√ºfung neuer L√∂sungen und Ideen. <br><br><h2>  Neue Ans√§tze </h2><br>  Derzeit gibt es bereits viele Implementierungen von statischen Analysatoren, die auf maschinellem Lernen basieren oder dieses verwenden, einschlie√ülich Deep Learning und NLP zur Fehlererkennung.  Nicht nur Enthusiasten, sondern auch gro√üe Unternehmen wie Facebook, Amazon oder Mozilla machten auf das Potenzial des maschinellen Lernens bei der Fehlersuche aufmerksam.  Einige Projekte sind keine vollwertigen statischen Analyseger√§te, sondern stellen nur zwischenzeitlich bestimmte Fehler bei Commits fest. <br><br>  Interessanterweise sind fast alle als wegweisende Produkte positioniert, die mithilfe k√ºnstlicher Intelligenz den Entwicklungsprozess ver√§ndern werden. <p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/cde/532/28ccde53241d54d5b927234ff729a19d.png"></div><br>  Betrachten Sie einige bekannte Beispiele: <br><br><ol><li>  Deepcode </li><li> Infer, Sapienz, SapFix </li><li>  Embold </li><li>  Quelle {d} </li><li>  Clever-Commit, Commit-Assistent </li><li>  CodeGuru </li></ol><br><h3>  Deepcode </h3><br>  Deep Code ist ein Schwachstellensuchwerkzeug im Code von Programmen, die in Java, JavaScript, TypeScript und Python geschrieben sind und in denen maschinelles Lernen als Komponente vorhanden ist.  Laut Boris Paskalev gelten bereits mehr als 250.000 Regeln.  Dieses Tool basiert auf √Ñnderungen, die Entwickler am Quellcode offener Projekte vorgenommen haben (eine Million Repositories).  Das Unternehmen selbst sagt, ihr Projekt sei Grammatik f√ºr Entwickler. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/f09/8df/0c0f098dfabd07a95df228b434ab3bfb.png"></div><br><br>  Im Wesentlichen vergleicht dieser Analyzer Ihre L√∂sung mit der Projektdatenbank und bietet Ihnen die gesch√§tzte beste L√∂sung aus der Erfahrung anderer Entwickler. <br><br>  Im Mai 2018 schrieben Entwickler, dass die Unterst√ºtzung f√ºr die C ++ - Sprache vorbereitet wird. Diese Sprache wird jedoch immer noch nicht unterst√ºtzt.  Obwohl auf der Site selbst angegeben ist, dass innerhalb weniger Wochen eine neue Sprache hinzugef√ºgt werden kann, h√§ngt nur ein Schritt von der Sprachanalyse ab. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/68e/7e5/a3868e7e5efa50016e7a7858054da47a.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/984/4f5/1119844f5406645778271c64f12d0df9.png"></div><br><br>  Auf der Website wird auch eine Gruppe von Ver√∂ffentlichungen zu den Methoden ver√∂ffentlicht, auf denen der Analysator basiert. <br><br><h3>  Infer </h3><br>  Facebook ist sehr bem√ºht, neue Ans√§tze in seine Produkte einzuf√ºhren.  Sie haben ihre Aufmerksamkeit und ihr maschinelles Lernen nicht umgangen.  2013 kauften sie ein Startup, das einen maschinenbasierten statischen Analysator entwickelte.  Und im Jahr 2015 wurde der Quellcode des Projekts <a href="https://github.com/facebook/infer">ge√∂ffnet</a> . <br><br>  Infer ist ein statischer Analysator f√ºr Projekte, die in Java, C, C ++ und Objective-C geschrieben wurden und von Facebook entwickelt wurden.  Laut der Website wird es auch in Amazon Web Services, Oculus, Uber und anderen beliebten Projekten verwendet. <br><br>  Infer kann derzeit Fehler im Zusammenhang mit der Dereferenzierung eines Nullzeigers und Speicherlecks erkennen.  Infer basiert auf Hoars Logik, Trennungslogik und Biabduktion sowie auf der Theorie der abstrakten Interpretation.  Mit diesen Ans√§tzen kann der Analysator das Programm in kleine Bl√∂cke (Chunks) aufteilen und diese unabh√§ngig voneinander analysieren. <br><br>  Sie k√∂nnen versuchen, Infer f√ºr Ihre Projekte zu verwenden. Entwickler warnen jedoch davor, dass bei Facebook-Projekten n√ºtzliche Antworten 80% der Ergebnisse ausmachen, bei anderen Projekten jedoch eine geringe Anzahl von Fehlalarmen nicht garantiert ist.  Einige der Fehler, die Infer noch nicht finden kann, aber die Entwickler arbeiten daran, solche Trigger einzuf√ºhren: <br><br><ul><li>  Verlassen des Arrays; </li><li>  typisierte Ausnahmen; </li><li>  Verlust nicht verifizierter Daten; </li><li>  Rennen Race Condition. </li></ul><br><h3>  Sapfix </h3><br>  SapFix ist ein automatisiertes Bearbeitungswerkzeug.  Es erh√§lt Informationen von Sapienz, einem Testautomatisierungstool, und dem statischen Infer-Analysator. Basierend auf den neuesten √Ñnderungen und Meldungen w√§hlt Infer eine von mehreren Strategien zur Fehlerbehebung. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/de6/baa/547de6baa2d74f4e3be984a78c704d45.png"></div><br><br>  In einigen F√§llen setzt SapFix die √Ñnderungen ganz oder teilweise zur√ºck.  In anderen F√§llen versucht er, das Problem zu l√∂sen, indem er einen Patch aus seinen Fixmustern generiert.  Dieser Satz wird aus den Bearbeitungsvorlagen gebildet, die die Programmierer selbst aus den bereits einmal vorgenommenen Bearbeitungen zusammengestellt haben.  Wenn eine solche Vorlage den Fehler nicht behebt, versucht SapFix, die Vorlage an die Situation anzupassen, und nimmt kleine √Ñnderungen im abstrakten Syntaxbaum vor, bis eine potenzielle L√∂sung gefunden wird. <br><br>  Eine m√∂gliche L√∂sung reicht jedoch nicht aus, daher sammelt SapFix mehrere L√∂sungen, die anhand von drei Fragen ausgew√§hlt werden: Gibt es Kompilierungsfehler, gibt es einen Absturz, f√ºhrt die Bearbeitung neue Abst√ºrze ein?  Nachdem die Bearbeitungen vollst√§ndig getestet wurden, werden die Patches zur √úberpr√ºfung an den Programmierer gesendet, der entscheidet, welche der Bearbeitungen das Problem am besten l√∂st. <br><br><h3>  Embold </h3><br>  Embold ist eine Startplattform zur statischen Analyse des Quellcodes von Programmen, die vor der Umbenennung Gamma hie√ü.  Die statische Analyse wird auf der Grundlage unserer eigenen Diagnose sowie auf der Grundlage von eingebauten Analyseger√§ten wie Cppheck, SpotBugs, SQL Check und anderen durchgef√ºhrt. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/406/bd8/f40406bd824b5eeb1815de357d95565b.png"></div><br><br>  Neben der eigentlichen Diagnose liegt der Schwerpunkt auf der visuellen Anzeige von Infografiken anhand der Codebasis und der bequemen Anzeige der gefundenen Fehler sowie der Suche nach Refactoring-M√∂glichkeiten.  Dar√ºber hinaus verf√ºgt dieser Analyzer √ºber eine Reihe von Anti-Patterns, mit denen Sie Probleme in der Codestruktur auf Klassen- und Methodenebene erkennen und verschiedene Metriken zur Berechnung der Systemqualit√§t verwenden k√∂nnen. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/74f/abb/22074fabb8b67de2ce5d5427729387f7.png"></div><br><br>  Einer der Hauptvorteile ist das intelligente L√∂sungs- und √Ñnderungsvorschlagsystem, das neben der √ºblichen Diagnose auch √Ñnderungen anhand von Informationen √ºber fr√ºhere √Ñnderungen √ºberpr√ºft. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/122/c46/6e5122c462cd33320eafecd4deac2a49.png"></div><br><br>  Mit NLP zerlegt Embold den Code in Teile und sucht nach Zusammenh√§ngen und Abh√§ngigkeiten zwischen Funktionen und Methoden, wodurch Umgestaltungszeit gespart wird. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94e/129/3fe/94e1293fe9e031d4065beb9ea1b21932.png"></div><br><br>  Embold bietet daher haupts√§chlich eine komfortable Visualisierung der Analyseergebnisse Ihres Quellcodes durch verschiedene Analyseger√§te sowie eine eigene Diagnose, die teilweise auf maschinellem Lernen basiert. <br><br><h3>  Quelle {d} </h3><br>  Source {d} ist in Bezug auf die Implementierung der von uns untersuchten Analyseger√§te am offensten.  Es ist auch eine <a href="https://github.com/src-d/sourced-ce">Open Source-L√∂sung</a> .  Auf ihrer Website k√∂nnen Sie (im Austausch f√ºr Ihre E-Mail-Adresse) eine Brosch√ºre mit einer Beschreibung der von ihnen verwendeten Technologien erhalten.  Dar√ºber hinaus enth√§lt es einen <a href="https://github.com/src-d/awesome-machine-learning-on-source-code">Link</a> zur Publikationsbasis, die sie im Zusammenhang mit der Verwendung von maschinellem Lernen f√ºr die Codeanalyse gesammelt haben, sowie ein <a href="https://github.com/src-d/datasets/tree/master/PublicGitArchive">Repository</a> mit einem Datensatz f√ºr die Codeschulung.  Das Produkt selbst ist eine Plattform zur Analyse des Quellcodes und des Softwareprodukts und konzentriert sich nicht auf Entwickler, sondern auf die Verkn√ºpfung der Manager.  Zu seinen F√§higkeiten geh√∂rt eine Funktion zum Ermitteln des Volumens der technischen Schulden, von Engp√§ssen im Entwicklungsprozess und anderer globaler Statistiken zum Projekt. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/b8c/425/af2b8c42537b1a2628c95773165ed190.png"></div><br><br>  Sie st√ºtzen ihren Ansatz zur maschinengest√ºtzten Code-Analyse auf die Natural-Hypothese, die im Artikel " <a href="https://people.inf.ethz.ch/suz/publications/natural.pdf">√úber die Nat√ºrlichkeit von Software</a> " formuliert ist. <br><br>  <i>‚ÄûProgrammiersprachen sind theoretisch komplex, flexibel und leistungsf√§hig, aber die Programme, die echte Menschen tats√§chlich schreiben, sind gr√∂√ütenteils einfach und ziemlich repetitiv, und deshalb haben sie n√ºtzliche und vorhersagbare statistische Eigenschaften, die sich in Statistiken ausdr√ºcken lassen Sprachmodelle und Verwendung f√ºr Softwareentwicklungsaufgaben. ‚Äú</i> <br><br>  Basierend auf dieser Hypothese sind die statistischen Eigenschaften umso ausgepr√§gter und genauer, je gr√∂√üer die Codebasis f√ºr das Training des Analysators ist. <br><br>  F√ºr die Analyse des Codes verwendet source {d} den Babelfish-Dienst, der eine Codedatei in einer der verf√ºgbaren Sprachen analysieren, einen abstrakten Syntaxbaum abrufen und in einen universellen Syntaxbaum konvertieren kann. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/bbd/c4d/39ebbdc4d561895c1f7b9e251d44e17c.png"></div><br><br>  Quelle {d} sucht jedoch nicht nach Fehlern im Code.  Basierend auf dem Baum zeigt source {d} beim maschinellen Lernen auf der Grundlage des gesamten Projekts, wie der Code formatiert ist, welcher Codierungsstil im Projekt verwendet wird und wann der Code festgeschrieben wird. Wenn der neue Code nicht mit dem Codierungsstil des Projekts √ºbereinstimmt, werden die entsprechenden √Ñnderungen vorgenommen. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/196/c0a/e7f196c0a742ba8f68436b157708c109.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/f51/7bd/debf517bd5d74c2553a9b7fbd112a1b2.png"></div><br><br>  Das Training wird von verschiedenen Grundelementen geleitet: Leerzeichen, Tabulatoren, Zeilenumbr√ºche usw. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/ade/8c5/39aade8c5ea77cb3bf89d4a0e999c5f7.png"></div><br><br>  Lesen Sie mehr dazu in ihrer Publikation: " <a href="https://arxiv.org/abs/1904.00935">STYLE-ANALYZER: Beheben von Inkonsistenzen im Codestil mit interpretierbaren, nicht √ºberwachten Algorithmen</a> ". <br><br>  Im Allgemeinen ist source {d} eine umfassende Plattform f√ºr die Erfassung einer Vielzahl von Statistiken zum Quellcode und zum Projektentwicklungsprozess, von der Berechnung der Wirksamkeit von Entwicklern bis zur Ermittlung von Zeitkosten f√ºr Code√ºberpr√ºfungen. <br><br><h3>  Clever begehen </h3><br>  Clever-Commit ist ein Analysator, der von Mozilla in Zusammenarbeit mit Ubisoft erstellt wurde.  Es basiert auf der <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">CLEVER</a> - <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">Studie</a> (Combining Levels of Bug Prevention and Resolution Techniques) von Ubisoft und dem darauf basierenden Assistant-Produkt, das verd√§chtige Commits identifiziert, die wahrscheinlich einen Fehler enthalten.  Aufgrund der Tatsache, dass CLEVER auf einem Codevergleich basiert, weist es nicht nur auf einen gef√§hrlichen Code hin, sondern macht auch Vorschl√§ge zu m√∂glichen Korrekturen.  Nach der Beschreibung findet Clever-Commit in 60-70% der F√§lle Problembereiche und bietet in der gleichen H√§ufigkeit korrekte Korrekturen an.  Im Allgemeinen gibt es nur wenige Informationen zu diesem Projekt und zu den Fehlern, die es finden kann. <br><br><h3>  CodeGuru </h3><br>  In j√ºngerer Zeit wurde die Liste der Analyseger√§te, die maschinelles Lernen verwenden, mit einem Produkt von Amazon namens CodeGuru erg√§nzt.  Dieser Service basiert auf maschinellem Lernen, mit dem Sie Fehler im Code finden und kostspielige Abschnitte darin identifizieren k√∂nnen.  Bisher ist die Analyse nur f√ºr Java-Code gedacht, aber sie beschreiben die Unterst√ºtzung f√ºr andere Sprachen in der Zukunft.  Andy Jassi, CEO von AWS (Amazon Web Services), gab bekannt, dass er es bereits seit langer Zeit in Amazon selbst verwendet. <br><br>  Der Website zufolge wurden Schulungen auf der Codebasis von Amazon selbst sowie f√ºr mehr als 10.000 Open Source-Projekte durchgef√ºhrt. <br><br>  Tats√§chlich besteht der Dienst aus zwei Teilen: CodeGuru Reviewer, der durch Suchen nach assoziativen Regeln und Suchen nach Fehlern im Code geschult wird, und CodeGuru Profiler, der die Anwendungsleistung √ºberwacht. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/662/3a6/ee06623a61ab3f1345d05f169f3325ac.png"></div><br><br>  Im Allgemeinen wurden nicht viele Informationen zu diesem Projekt ver√∂ffentlicht.  Um zu erfahren, wie Abweichungen von "Best Practices" festgestellt werden, analysiert Reviewer die Amazon-Codebasen und sucht nach Pull-Requests, die AWS-API-Aufrufe enthalten.  Anschlie√üend betrachtet er die vorgenommenen √Ñnderungen und vergleicht sie mit den Daten aus der Dokumentation, die parallel analysiert wird.  Das Ergebnis ist ein Modell f√ºr "Best Practices". <br><br>  Es wird auch gesagt, dass sich die Empfehlungen f√ºr benutzerdefinierten Code verbessern, nachdem Feedback zu den Empfehlungen eingegangen ist. <br><br>  Die Liste der Fehler, auf die der Pr√ºfer reagiert, ist ziemlich verschwommen, da keine spezifische Dokumentation f√ºr Fehler ver√∂ffentlicht wurde: <ul><li>  AWS Best Practices </li><li>  Parallelit√§t </li><li>  Ressourcenlecks </li><li>  Leck vertraulicher Informationen </li><li>  Allgemeine "Best Practices" f√ºr die Codierung </li></ul><br><h2>  Unsere Skepsis </h2><br>  Betrachten wir nun das Problem der Fehlersuche mit den Augen unseres Teams, das seit vielen Jahren statische Analyseger√§te entwickelt.  Wir sehen eine Reihe von Problemen auf hoher Ebene bei der Anwendung von Schulungen, √ºber die wir sprechen m√∂chten.  Aber am Anfang teilen wir alle ML-Ans√§tze grob in zwei Typen ein: <br><br><ol><li>  Trainieren Sie einen statischen Analysator manuell, um anhand von Beispielen f√ºr synthetischen und realen Code nach verschiedenen Problemen zu suchen. </li><li>  Trainieren Sie die Algorithmen mit einer gro√üen Anzahl von Open-Source-Code (GitHub) und der √Ñnderungshistorie, wonach der Analysator selbst beginnt, Fehler zu erkennen und sogar Korrekturen vorzuschlagen. </li></ol><br>  Wir werden √ºber jede Richtung getrennt sprechen, da sie verschiedene M√§ngel aufweisen.  Danach, denke ich, wird es den Lesern klar, warum wir die M√∂glichkeit des maschinellen Lernens nicht verweigern, aber auch nicht die Begeisterung teilen. <br><br>  <b>Hinweis</b>  Wir betrachten die Entwicklung eines universellen statischen Analyseger√§ts f√ºr allgemeine Zwecke.  Wir konzentrieren uns auf die Entwicklung eines Analysators, der sich nicht auf eine bestimmte Codebasis konzentriert, sondern den jedes Team in jedem Projekt verwenden kann. <br><br><h3>  Manuelles Training des statischen Analysators </h3><br>  Angenommen, wir m√∂chten ML verwenden, damit der Analysator nach Anomalien der folgenden Form im Code sucht: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == A)</code> </pre> <br>  Es ist seltsam, eine Variable mit sich selbst zu vergleichen.  Wir k√∂nnen viele Beispiele f√ºr korrekten und inkorrekten Code schreiben und den Analysator so trainieren, dass er nach solchen Fehlern sucht.  Zus√§tzlich ist es m√∂glich, den Tests reale Beispiele bereits gefundener Fehler hinzuzuf√ºgen.  Die Frage ist nat√ºrlich, woher diese Beispiele stammen.  Wir werden jedoch in Betracht ziehen, dass dies m√∂glich ist.  Beispielsweise haben wir eine Reihe von Beispielen f√ºr solche Fehler <a href="https://www.viva64.com/ru/examples/v501/">gesammelt</a> : <a href="https://www.viva64.com/ru/examples/v501/">V501</a> , <a href="https://www.viva64.com/ru/examples/v3001/">V3001</a> , <a href="https://www.viva64.com/ru/examples/v6001/">V6001</a> . <br><br>  Ist es also m√∂glich, solche Fehler im Code mithilfe von Algorithmen f√ºr maschinelles Lernen zu suchen?  Sie k√∂nnen.  Es ist jedoch nicht klar, warum dies getan werden soll. <br><br>  Sehen Sie, um den Analysator zu trainieren, m√ºssen wir viel Aufwand betreiben, um Beispiele f√ºr das Training vorzubereiten.  Oder kennzeichnen Sie den Code echter Anwendungen und geben Sie an, wo Sie schw√∂ren sollen und wo nicht.  In jedem Fall muss viel Arbeit geleistet werden, da es Tausende von Beispielen f√ºr Schulungen geben sollte.  Oder Zehntausende. <br><br>  Schlie√ülich wollen wir nicht nur nach F√§llen (A == A) suchen, sondern auch nach: <br><br><ul><li>  if (X &amp;&amp; A == A) </li><li>  if (A + 1 == A + 1) </li><li>  if (A [i] == A [i]) </li><li>  if ((A) == (A)) </li><li>  usw. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/a51/95d/19ea5195d9075802dbdcd3feda3c4aad.png"></div><br><br>  Nun wollen wir sehen, wie eine so einfache Diagnose in PVS-Studio implementiert wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RulePrototype_V501</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VivaWalker &amp;walker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *operation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SafeEq(operation, <span class="hljs-string"><span class="hljs-string">"=="</span></span>) &amp;&amp; SafeEqual(left, right)) { walker.AddError(<span class="hljs-string"><span class="hljs-string">" , !"</span></span>, left, <span class="hljs-number"><span class="hljs-number">501</span></span>, Level_1, <span class="hljs-string"><span class="hljs-string">"CWE-571"</span></span>); } }</code> </pre> <br>  Und alle.  Keine Beispielschulungsbasis erforderlich! <br><br>  Zuk√ºnftig sollte die Diagnose so unterrichtet werden, dass sie eine Reihe von Ausnahmen ber√ºcksichtigt und Sie verstehen, dass Sie (A [0] == A [1-1]) beschw√∂ren m√ºssen.  All dies ist jedoch sehr einfach zu programmieren.  Aber nur mit der Basis von Beispielen f√ºr das Training wird alles schlecht sein. <br><br>  Beachten Sie, dass in beiden F√§llen weiterhin ein Testsystem, das Verfassen von Dokumentationen usw. erforderlich ist.  Der Aufwand f√ºr die Erstellung einer neuen Diagnose liegt jedoch eindeutig auf der Seite des klassischen Ansatzes, bei dem die Regel einfach im Code fest codiert ist. <br><br>  Schauen wir uns jetzt eine andere Regel an.  Zum Beispiel, dass das Ergebnis einiger Funktionen verwendet werden muss.  Es macht keinen Sinn, sie anzurufen, ohne ihr Ergebnis zu verwenden.  Hier sind einige dieser Funktionen: <ul><li>  Malloc </li><li>  memcmp </li><li>  Zeichenfolge :: leer </li></ul><br>  In der Regel ist dies bei der in PVS-Studio implementierten Diagnose von <a href="https://www.viva64.com/ru/w/v530/">V530</a> der <a href="https://www.viva64.com/ru/w/v530/">Fall</a> . <br><br>  Wir m√∂chten also nach Aufrufen f√ºr solche Funktionen suchen, bei denen das Ergebnis ihrer Arbeit nicht verwendet wird.  Dazu k√∂nnen Sie viele Tests generieren.  Und wir denken, dass alles gut funktionieren wird.  Aber auch hier ist nicht klar, warum dies notwendig ist. <br><br>  Die Implementierung der V530-Diagnose mit allen Ausnahmen im PVS-Studio-Analysator umfasst 258 Codezeilen, von denen 64 Kommentarzeilen sind.  Au√üerdem gibt es eine Tabelle mit Anmerkungen zu Funktionen, in der darauf hingewiesen wird, dass deren Ergebnis verwendet werden sollte.  Das Auff√ºllen dieser Tabelle ist viel einfacher als das Erstellen von synthetischen Beispielen. <br><br>  Bei Diagnosen mit Datenflussanalyse wird die Situation noch schlimmer.  Zum Beispiel kann der PVS-Studio-Analysator den Wert von Zeigern verfolgen, was das Auffinden eines solchen Speicherverlusts erm√∂glicht: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* BnNew() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>[kBigIntSize]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(result, <span class="hljs-number"><span class="hljs-number">0</span></span>, kBigIntSize * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AndroidRSAPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(crypto::RSAPrivateKey* key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* n = BnNew(); .... RSAPublicKey pkey; pkey.len = kRSANumWords; pkey.exponent = <span class="hljs-number"><span class="hljs-number">65537</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Fixed public exponent pkey.n0inv = 0 - ModInverse(n0, 0x100000000LL); if (pkey.n0inv == 0) return kDummyRSAPublicKey; // &lt;= .... }</span></span></code> </pre> <br>  Ein Beispiel stammt aus dem Artikel " <a href="https://www.viva64.com/ru/b/0555/">Chrom: Speicherlecks</a> ".  Wenn die Bedingung <i>(pkey.n0inv == 0) erf√ºllt ist</i> , wird die Funktion beendet, ohne den Puffer <i>freizugeben</i> , auf den der Zeiger in der Variablen <i>n</i> gespeichert ist. <br><br>  Aus Sicht von PVS-Studio ist nichts kompliziert.  Der Analysator hat die <i>BnNew-</i> Funktion untersucht und sich daran erinnert, dass sie einen Zeiger auf einen zugewiesenen Speicherblock zur√ºckgibt.  In einer anderen Funktion bemerkte er, dass eine Situation m√∂glich ist, in der der Puffer nicht freigegeben wird und der Zeiger darauf verloren geht, wenn die Funktion beendet wird. <br><br>  Ein allgemeiner Werteverfolgungsalgorithmus funktioniert.  Es ist egal, wie der Code geschrieben ist.  Es spielt keine Rolle, was sich in der Funktion noch befindet, das nicht mit dem Arbeiten mit Zeigern zusammenh√§ngt.  Der Algorithmus ist universell und die V773-Diagnose findet in verschiedenen Projekten viele Fehler.  Sehen Sie, wie unterschiedlich die <a href="https://www.viva64.com/ru/examples/v773/">Codefragmente</a> sind, in denen die Fehler erkannt werden! <br><br>  Wir sind keine Experten f√ºr maschinelles Lernen, aber es scheint, dass es gro√üe Probleme geben wird.  Es gibt unglaublich viele M√∂glichkeiten, wie Sie Code mit Speicherlecks schreiben k√∂nnen.  Selbst wenn die Maschine f√ºr die Verfolgung des Werts von Variablen geschult ist, muss sie geschult werden, um zu verstehen, dass Funktionsaufrufe vorliegen. <br><br>  Es besteht der Verdacht, dass f√ºr das Training so viele Beispiele erforderlich sind, dass die Aufgabe entmutigend wird.  Wir sagen nicht, dass es nicht realisierbar ist.  Wir bezweifeln, dass sich die Kosten f√ºr die Erstellung eines Analyseger√§ts auszahlen werden. <br><br>  <b>Analogie.</b>  Eine Analogie kommt einem Taschenrechner in den Sinn, bei dem anstelle der Diagnose arithmetische Operationen programmiert werden m√ºssen.  Wir sind sicher, dass Sie einem Taschenrechner, der auf ML basiert, beibringen k√∂nnen, Zahlen gut zu addieren, indem Sie eine Wissensbasis √ºber das Ergebnis der Operationen 1 + 1 = 2, 1 + 2 = 3, 2 + 1 = 3, 100 + 200 = 300 usw. einf√ºhren.  Wie Sie wissen, ist die Zweckm√§√üigkeit der Entwicklung eines solchen Taschenrechners eine gro√üe Frage (wenn kein Zuschuss daf√ºr gew√§hrt wird :).  Ein viel einfacher, schneller, genauer und zuverl√§ssiger Taschenrechner kann unter Verwendung der normalen "+" - Operation im Code geschrieben werden. <br><br>  <b>Fazit</b>  Die Methode wird funktionieren.  Aber es zu benutzen, macht unserer Meinung nach keinen praktischen Sinn.  Die Entwicklung wird zeitaufw√§ndiger und das Ergebnis ist weniger zuverl√§ssig und genau, insbesondere wenn komplexe Diagnosen auf der Grundlage der Analyse des Datenstroms durchgef√ºhrt werden sollen. <br><br><h3>  Von viel Open Source lernen </h3><br>  Nun, wir haben manuelle Synthesebeispiele herausgefunden, aber es gibt GitHub.  Sie k√∂nnen den Verlauf von Commits verfolgen und Muster von Code√§nderungen / -korrekturen ableiten.  Dann k√∂nnen Sie nicht nur auf Teile des verd√§chtigen Codes hinweisen, sondern auch eine M√∂glichkeit vorschlagen, dies zu beheben. <br><br>  Wenn Sie bei dieser Detailebene stehen bleiben, sieht alles gut aus.  Der Teufel steckt wie immer im Detail.  Sprechen wir √ºber diese Details. <br><br>  <b>Die erste Nuance.</b>  <b>Datenquelle.</b> <br><br>  Die Bearbeitungen auf GitHub sind ziemlich chaotisch und abwechslungsreich.  Die Leute sind oft zu faul, um atomare Verpflichtungen einzugehen und mehrere √Ñnderungen am Code gleichzeitig vorzunehmen.  Sie selbst wissen, wie es passiert: Sie haben den Fehler behoben und gleichzeitig ein wenig √ºberarbeitet (‚ÄûUnd hier werde ich gleichzeitig die Bearbeitung eines solchen Falls hinzuf√ºgen ...‚Äú).  Selbst dann kann es f√ºr eine Person nicht klar sein, ob diese √Ñnderungen miteinander zusammenh√§ngen oder nicht. <br><br>  Das Problem ist, wie man die tats√§chlichen Fehler vom Hinzuf√ºgen neuer Funktionen oder etwas anderem unterscheidet.  Sie k√∂nnen nat√ºrlich 1.000 Personen manuell anpflanzen, um Commits zu markieren.  Die Benutzer m√ºssen angeben, dass sie den Fehler hier korrigiert, hier umgestaltet, hier neue Funktionen implementiert, die Anforderungen hier ge√§ndert usw. haben. <br><br>  Ist dieses Markup m√∂glich?  M√∂glich.  Achten Sie jedoch darauf, wie schnell die √Ñnderung erfolgt.  Anstatt "den Algorithmus selbst auf der Basis von GitHub zu lernen", diskutieren wir bereits, wie man Hunderte von Menschen f√ºr eine lange Zeit r√§tselt.  Die Arbeitskosten und die Kosten f√ºr die Erstellung eines Werkzeugs steigen stark an. <br><br>  Sie k√∂nnen versuchen, automatisch zu identifizieren, wo genau die Fehler behoben wurden.  Dazu sollten Sie Kommentare zu Commits analysieren und auf kleine lokale √Ñnderungen achten, bei denen es sich h√∂chstwahrscheinlich genau um die Fehlerrevision handelt.  Es ist schwer zu sagen, wie gut Sie automatisch nach Fehlerkorrekturen suchen k√∂nnen.  In jedem Fall ist dies eine gro√üe Aufgabe, die getrennte Forschung und Programmierung erfordert. <br><br>  Also, wir haben das Training noch nicht erreicht, aber es gibt schon Nuancen :). <br><br>  <b>Die zweite Nuance.</b>  <b>Verz√∂gerung in der Entwicklung.</b> <br><br>  Analysatoren, die auf der Basis von Datenbanken wie GitHub trainiert werden, sind immer einem Syndrom wie "geistiger Behinderung" ausgesetzt.  Dies liegt daran, dass sich die Programmiersprachen im Laufe der Zeit √§ndern. <br><br>  In C # 8.0 <a href="https://www.viva64.com/ru/b/0631/">wurden</a> nullf√§hige Referenztypen <a href="https://www.viva64.com/ru/b/0631/">eingef√ºhrt</a> , um den Umgang mit Nullreferenzausnahmen (NREs) zu erleichtern.  JDK 12 f√ºhrt eine neue switch-Anweisung ein ( <a href="https://openjdk.java.net/jeps/325">JEP 325</a> ).  In C ++ 17 wurde es m√∂glich, bedingte Konstruktionen in der Kompilierungsphase auszuf√ºhren ( <a href="https://www.bfilipek.com/2018/03/ifconstexpr.html">constexpr if</a> ).  Usw. <br><br>  Programmiersprachen entwickeln sich weiter.  Dar√ºber hinaus wie C ++ sind sehr schnell und aktiv.  Darin erscheinen neue Designs, neue Standardfunktionen werden hinzugef√ºgt und so weiter.  Neben neuen Funktionen treten auch neue Fehlermuster auf, die wir auch mithilfe der statischen Codeanalyse identifizieren m√∂chten. <br><br>  Und hier hat die betrachtete Lehrmethode ein Problem: Das Fehlermuster ist m√∂glicherweise bereits bekannt, es besteht der Wunsch, es zu identifizieren, aber es gibt nichts, woraus man lernen kann. <br><br>  Schauen wir uns dieses Problem an einem konkreten Beispiel an.  Die bereichsbasierte for-Schleife wurde in C ++ 11 angezeigt.  Sie k√∂nnen den folgenden Code schreiben und dabei alle Elemente im Container durchlaufen: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) foo(num);</code> </pre> <br>  Der neue Zyklus brachte ein neues Fehlermuster mit sich.  Wenn der Container innerhalb der Schleife ge√§ndert wird, f√ºhrt dies zur Ung√ºltigkeit der ‚ÄûSchatten‚Äú -Iteratoren. <br><br>  Betrachten Sie den folgenden falschen Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Der Compiler wird es in so etwas verwandeln: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __begin = begin(numbers), __end = end(numbers); __begin != __end; ++__begin) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = *__begin; numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  W√§hrend der <i>Push_back-</i> Operation kann eine <i>Ung√ºltigmachung der</i> Iteratoren <i>__begin</i> und <i>__end</i> auftreten, wenn eine Speicherzuweisung innerhalb des Vektors auftritt.  Das Ergebnis ist ein undefiniertes Programmverhalten. <br><br>  Daher ist das Fehlermuster seit langem bekannt und in der Literatur beschrieben.  Der PVS-Studio-Analysator diagnostiziert es mithilfe der <a href="https://www.viva64.com/ru/w/v789/">V789-</a> Diagnose und hat in offenen Projekten bereits <a href="https://www.viva64.com/ru/examples/v789/">echte Fehler</a> gefunden. <br><br>  Wann wird es genug neuen Code auf GitHub geben, um dieses Muster zu bemerken?  Gute Frage ... Sie m√ºssen verstehen, dass, wenn eine bereichsbezogene for-Schleife angezeigt wird, dies nicht bedeutet, dass alle Programmierer sofort damit begonnen haben, sie massiv zu verwenden.  Es kann Jahre dauern, bis mit einer neuen Schleife viel Code angezeigt wird.  Dar√ºber hinaus m√ºssen viele Fehler festgeschrieben und anschlie√üend korrigiert werden, damit der Algorithmus das Muster in den √Ñnderungen erkennen kann. <br><br>  Wie viele Jahre sollten vergehen?  F√ºnf?  Zehn? <br><br>  Zehn ist zu viel, und sind wir Pessimisten?  Gar nicht.  Acht Jahre sind vergangen, als dieser Artikel geschrieben wurde, da die bereichsbasierte for-Schleife in C ++ 11 erschien.  Bisher wurden jedoch nur <a href="https://www.viva64.com/ru/examples/v789/">drei F√§lle eines</a> solchen Fehlers in unsere Datenbank geschrieben.  Drei Fehler sind nicht viel und nicht wenig.  Aus ihrer Anzahl sollte keine Schlussfolgerung gezogen werden.  Die Hauptsache ist, dass Sie best√§tigen k√∂nnen, dass ein solches Fehlermuster real ist und es sinnvoll ist, es zu erkennen. <br><br>  Vergleichen Sie nun diesen Betrag beispielsweise mit diesem Fehlermuster: Der <a href="https://www.viva64.com/ru/examples/v595/">Zeiger wird vor der √úberpr√ºfung dereferenziert</a> .  Insgesamt haben wir bei der Pr√ºfung von Open-Source-Projekten bereits 1716 solcher F√§lle identifiziert. <br><br>  Vielleicht sollten Sie √ºberhaupt nicht nach bereichsbasierten Schleifenfehlern suchen?  Nein.  Nur Programmierer sind tr√§ge, und dieser Operator gewinnt sehr langsam an Popularit√§t.  Allm√§hlich wird es eine Menge Code mit seiner Teilnahme geben, und dementsprechend wird es auch mehr Fehler geben. <br><br>  Dies wird h√∂chstwahrscheinlich erst 10-15 Jahre nach dem Erscheinen von C ++ 11 geschehen.  Und jetzt eine philosophische Frage.  Da wir das Fehlermuster bereits kennen, werden wir viele Jahre warten, bis sich in offenen Projekten viele Fehler ansammeln. <br><br>  Wenn die Antwort "Ja" lautet, ist es m√∂glich, die Diagnose "geistige Behinderung" f√ºr alle Analyseger√§te auf der Grundlage von ML angemessen zu diagnostizieren. <br><br>  Wenn die Antwort nein ist, was soll ich dann tun?  Es gibt keine Beispiele.  Um sie manuell zu schreiben?  Aber dann kehren wir zum vorherigen Kapitel zur√ºck, in dem wir dar√ºber nachdachten, einer Person viele Beispiele f√ºr das Lernen zu schreiben. <br><br>  Dies kann getan werden, aber auch hier stellt sich die Frage nach der Zweckm√§√üigkeit.  Die Implementierung der V789-Diagnose mit allen Ausnahmen im PVS-Studio-Analysator umfasst nur 118 Codezeilen, von denen 13 Kommentarzeilen sind.  Das hei√üt  Dies ist eine sehr einfache Diagnose, die auf klassische Weise leicht durchgef√ºhrt und programmiert werden kann. <br><br>  Eine √§hnliche Situation wird es bei allen anderen Innovationen geben, die in einer anderen Sprache erscheinen.  Wie sie sagen, gibt es etwas zu √ºberlegen. <br><br>  <b>Die dritte Nuance.</b>  <b>Dokumentation</b> <br><br>  Eine wichtige Komponente jedes statischen Analyseger√§ts ist die Dokumentation, in der die einzelnen Diagnosen beschrieben werden.  Ohne diesen kann der Analysator nur sehr schwer oder gar nicht verwendet werden.  In der <a href="https://www.viva64.com/ru/w/">Dokumentation</a> zu PVS-Studio finden Sie eine Beschreibung der einzelnen Diagnosen, die ein Beispiel f√ºr einen fehlerhaften Code und dessen Behebung enth√§lt.  Es gibt auch einen Link zu <a href="https://cwe.mitre.org/">CWE,</a> wo Sie eine alternative Beschreibung des Problems lesen k√∂nnen.  Und trotzdem ist manchmal etwas f√ºr Benutzer unverst√§ndlich und sie stellen uns kl√§rende Fragen. <br><br>  Bei statischen Analysatoren, die auf Algorithmen f√ºr maschinelles Lernen basieren, ist das Dokumentationsproblem irgendwie vertuscht.  Es wird davon ausgegangen, dass der Analysator lediglich einen Ort anzeigt, der ihm verd√§chtig erscheint, und m√∂glicherweise sogar vorschl√§gt, wie er diesen Fehler beheben kann.  Die Entscheidung, eine √Ñnderung vorzunehmen oder nicht, bleibt bei der Person.  Und hier ... √§hm ... Es ist nicht einfach, eine Entscheidung zu treffen, auf deren Grundlage der Analysator die eine oder andere Stelle im Code verd√§chtigt. <br><br>  Nat√ºrlich wird in einigen F√§llen alles offensichtlich sein.  Angenommen, der Analysator verweist auf diesen Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Und wird anbieten, es zu ersetzen durch: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Es ist sofort klar, dass der Programmierer versiegelt und 1 an der falschen Stelle hinzugef√ºgt hat.  Infolgedessen wird weniger Speicher zugewiesen. <br><br>  Hier ist ohne Dokumentation alles klar.  Dies wird jedoch nicht immer der Fall sein. <br><br>  Stellen Sie sich vor, der Analysator verweist stillschweigend auf diesen Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Und schl√§gt vor, den Typ des R√ºckgabewerts von char in int zu √§ndern: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Es gibt keine Dokumentation f√ºr die Warnung.  Und anscheinend wird der Text der Warnung selbst, wie wir ihn verstehen, auch nicht sein, wenn wir √ºber einen v√∂llig unabh√§ngigen Analysator sprechen. <br><br>  Was zu tun ist?  Was ist der unterschied  Soll ich so einen Ersatz machen? <br><br>  Im Prinzip k√∂nnen Sie hier eine Chance nutzen und sich darauf einigen, den Code zu reparieren.  Obwohl √Ñnderungen akzeptiert werden, ohne sie zu verstehen, ist dies eine <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>einfache</i></a> √úbung ... :) Sie k√∂nnen sich die Beschreibung der <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>memcmp-</i></a> Funktion <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>ansehen</i></a> und lesen, dass die Funktion <i>int</i> : 0-Werte <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>zur√ºckgibt</i></a> , die gr√∂√üer als Null und kleiner als Null sind.  Es ist jedoch m√∂glicherweise nicht klar, warum √Ñnderungen vorgenommen werden m√ºssen, wenn der Code bereits erfolgreich funktioniert. <br><br>  Wenn Sie jetzt nicht wissen, wozu eine solche Bearbeitung gut ist, lesen Sie die Beschreibung der <a href="https://www.viva64.com/ru/w/v642/">V642-</a> Diagnose.  Es wird sofort klar, dass dies ein echter Fehler ist.  Dar√ºber hinaus kann es zu Sicherheitsl√ºcken kommen. <br><br>  Vielleicht schien das Beispiel nicht zu √ºberzeugen.  Immerhin schlug der Analysator einen Code vor, der wahrscheinlich besser ist.  Ok  Schauen wir uns zur Abwechslung ein weiteres Beispiel f√ºr Pseudocode in Java an. <br><br><pre> <code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj.state = <span class="hljs-number"><span class="hljs-number">200</span></span>; out.writeObject(obj); out.close();</code> </pre> <br>  Es gibt eine Art Objekt.  Es ist serialisiert.  Dann √§ndert sich der Status des Objekts und es wird erneut serialisiert.  Alles scheint in Ordnung zu sein.  Stellen Sie sich nun vor, der Analysator mag diesen Code pl√∂tzlich nicht mehr und schl√§gt vor, ihn durch folgenden Code zu ersetzen: <br><br><pre> <code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); <span class="hljs-comment"><span class="hljs-comment">//    obj.state = 200; out.writeObject(obj); out.close();</span></span></code> </pre> <br>  Anstatt das Objekt zu √§ndern und erneut aufzuzeichnen, wird ein neues Objekt erstellt und es ist bereits serialisiert. <br><br>  Es gibt keine Beschreibung des Problems.  Keine Dokumentation.  Der Code ist l√§nger geworden.  Aus irgendeinem Grund wurde die Erstellung eines neuen Objekts hinzugef√ºgt.  Sind Sie bereit, eine solche √Ñnderung in Ihrem Code vorzunehmen? <br><br>  Sie werden sagen, dass es nicht klar ist.  In der Tat ist es nicht klar.  Und so wird es die ganze Zeit unverst√§ndlich sein.  Die Arbeit mit einem solchen "stillen" Analyseger√§t ist eine endlose Untersuchung, um zu verstehen, warum das Analyseger√§t etwas nicht mag. <br><br>  Wenn es Dokumentation gibt, wird alles transparent.  Die f√ºr die Serialisierung verwendete Klasse <i>java.io.ObjectOuputStream speichert</i> beschreibbare Objekte im Cache.  Dies bedeutet, dass dasselbe Objekt nicht zweimal serialisiert wird.  Sobald die Klasse das Objekt serialisiert und das zweite Mal einfach einen Link zum selben ersten Objekt in den Stream schreibt.  <a href="https://www.viva64.com/ru/w/v6076/">Weiterlesen</a> : <a href="https://www.viva64.com/ru/w/v6076/">V6076</a> - Bei der wiederkehrenden Serialisierung wird der Status des zwischengespeicherten Objekts aus der ersten Serialisierung verwendet. <br><br>  Wir hoffen, wir konnten die Wichtigkeit der Dokumentation erkl√§ren.  Und jetzt die Frage.  Wie erscheint die Dokumentation f√ºr ein auf ML basierendes Analyseger√§t? <br><br>  Wenn ein klassischer Code-Analysator entwickelt wird, ist alles einfach und klar.  Es gibt ein bestimmtes Fehlermuster.  Wir beschreiben es in der Dokumentation und f√ºhren die Diagnose durch. <br><br>  Im Fall von ML ist das Gegenteil der Fall.  Ja, der Analysator kann eine Abweichung im Code feststellen und darauf hinweisen.  Aber er wei√ü nichts √ºber das Wesen des Mangels.  Er versteht nicht und wird nicht sagen, warum Code nicht so geschrieben werden kann.  Dies sind zu hochrangige Abstraktionen.  Dann muss der Analysator auch lernen, <b>die</b> Dokumentation der Funktionen zu lesen und zu <b>verstehen</b> . <br><br>  Wie gesagt, da das Thema Dokumentation in Artikeln zum maschinellen Lernen behandelt wird, sind wir nicht bereit, weiter zu sprechen.  Nur eine weitere gro√üe Nuance, die wir zur √úberpr√ºfung brachten. <br><br>  <b>Hinweis</b>  Es kann argumentiert werden, dass die Dokumentation optional ist.  Der Analyzer kann zu vielen Beispielen f√ºr Korrekturen auf GitHub f√ºhren, und eine Person, die sich Commits und Kommentare dazu ansieht, wird herausfinden, was was ist.  Ja das stimmt.  Aber die Idee sieht nicht attraktiv aus.  Anstelle eines Assistenten fungiert der Analysator als Werkzeug, das den Programmierer weiter verwirrt. <br><br>  <b>Die vierte Nuance.</b>  <b>Hochspezialisierte Sprachen.</b> <br><br>  Der beschriebene Ansatz ist nicht f√ºr hochspezialisierte Sprachen anwendbar, f√ºr die die statische Analyse ebenfalls √§u√üerst n√ºtzlich sein kann.  Der Grund daf√ºr ist, dass GitHub und andere Quellen nicht √ºber eine ausreichende Quellcodebasis verf√ºgen, um ein effektives Training zu erm√∂glichen. <br><br>  Betrachten Sie dies anhand eines konkreten Beispiels.  Um zu beginnen, gehen Sie zu GitHub und suchen Sie nach Repositorys f√ºr die beliebte Java-Sprache. <br><br>  Ergebnis: Sprache: "Java": <b>3.128.884</b> verf√ºgbare Repository-Ergebnisse <br><br>  Nehmen wir nun die Fachsprache "1C Enterprise", die in Buchhaltungsanwendungen der russischen Firma <a href="https://ru.wikipedia.org/wiki/1%25D0%25A1">1C verwendet wird</a> . <br><br>  Ergebnis: Sprache: "1C Enterprise": <b>551</b> verf√ºgbare Repository-Ergebnisse <br><br>  M√∂glicherweise werden keine Analysatoren f√ºr diese Sprache ben√∂tigt?  Gebraucht werden.  Es besteht ein praktischer Bedarf f√ºr die Analyse derartiger Programme, und entsprechende Analyseger√§te existieren bereits.  Zum Beispiel gibt es ein SonarQube 1C (BSL) -Plugin, das von <a href="https://silverbulleters.org/">Silver Bullet hergestellt wird</a> . <br><br> , -    ,          . <br><br> <b> . C, C++, #include</b> . <br><br> ,          ML,    ,  Java, JavaScript, Python.     .    C  C++ -  ,      . <br><br>    ,     /,   ,    C  C++  .    ¬´¬ª     . <br><br>  c/cpp-    .   ,      GitHub,  - cpp-    .   ,       ML. <br><br> ,    .    GitHub .     ,    .  ,         .  ,    .cpp-     . <br><br>     .    .    .     ,     ,        .       <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25B8"></a> . <br><br>  .    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name == <span class="hljs-string"><span class="hljs-string">"ML"</span></span>; }</code> </pre> <br>   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_name, <span class="hljs-string"><span class="hljs-string">"ML"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>        ,      <i>(x == ¬´y¬ª)</i>  strcmp(x, ¬´y¬ª)? <br><br>      ,  ,    <i>m_name</i>  .  , ,  : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_name; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; };</code> </pre> <br>      ,      .     ,          (  <i>std::string</i> ). <br><br>  ,  ,    .h .        ,     .  ,    C  C++. <br><br>  - ,     ,    ,       C  C++. <br><br>     ,    .    ,      ,      .    ,    cpp-. <br><br>     .       (,   ,     ).  ,    .      ,      ,      . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/be0/9dd/e95be09ddb94d84555c134d961ce9566.png"></div><br><br>  ,     GitHub  .     ,    ,   .    -        .   -   ,    .     .           ¬´ ¬ª.    ,    ,     .cpp    (.i) .      . <br><br>  , ,     ,   .      ,   .       .      ,    -  , ,   . <br><br>  ,     .          .   C  C++  ,   GitHub,      .    ,     . <br><br> <b></b> .      ,      .   GitHub   C++       ,     .cpp    .         :). <br><br>       ,   C  C++   . <br><br> <b> .    .</b> <br><br>            ,    . <br><br>       <a href="https://www.viva64.com/ru/w/v789/">V789</a> ,     Range-based for loop. ,       ,      .  ,     ,      ,     .     ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { numbers.push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// , , return } }</span></span></code> </pre> <br> ,  .         .  PVS-Studio      26  . <br><br>       ,      . ,   ,      ,    . <br><br>      ,   .  ,      ,   ,      ML.  Das hei√üt           . <br><br> <b> .      .</b> <br><br>     ,         .       (, WinAPI,     ..). <br><br>        C,  <i>strcmp</i> ,      . GitHub, available code results: <br><br><ul><li> strcmp ‚Äî 40,462,158 </li><li> stricmp ‚Äî 1,256,053 </li></ul><br> ,   . ,   , ,  : <ul><li> ,     .  . </li><li> ,     NULL.  . </li><li> ,       .  . </li><li>   . </li></ul><br>  ?  Nein.     ¬´ ¬ª.    ¬´ ¬ª  .       Top50      . ,     , ,  100  ,      .       , ,  ,   . , - Amazon.com      ,     130  ¬´  ¬ª. <br><br>      .  ,   . ,        : <br><br><ul><li> g_ascii_strncasecmp ‚Äî 35,695 </li><li> lstrcmpiA ‚Äî 27,512 </li><li> _wcsicmp_l ‚Äî 5,737 </li><li> _strnicmp_l ‚Äî 5,848 </li><li> _mbscmp_l ‚Äî 2,458 </li><li>  usw. </li></ul><br>  ,    ,          .      .      .     ,         ,   .       ¬´ ¬ª. <br><br>  PVS-Studio    . ,  C  ++      7200 .  : <br><br><ul><li> WinAPI </li><li>   C, </li><li>    (STL), </li><li> glibc (GNU C Library) </li><li> Qt </li><li> MFC </li><li> zlib </li><li> libpng </li><li> OpenSSL </li><li>  usw. </li></ul><br>   ,    .   .   ,  . <br><br>  .     ML?    ,   . <br><br>  ,  ,   ML,            . ,  .         ,  <i>strcmp</i>  <i>malloc</i> . <br><br> C     .  ,   .       ,  ,        ,     . <br><br>     ,  <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> . ,   ,  <i>fread</i> .          . ,     .      ,       .        : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buffer[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = _fread_nolock(buffer, size_of(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-number"><span class="hljs-number">100</span></span>, stream);</code> </pre> <br>        PVS-Studio: <br><br><pre> <code class="cpp hljs">C_<span class="hljs-string"><span class="hljs-string">"size_t _fread_nolock"</span></span> <span class="hljs-string"><span class="hljs-string">"(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);"</span></span> ADD(HAVE_STATE | RET_SKIP | F_MODIFY_PTR_1, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"_fread_nolock"</span></span>, POINTER_1, BYTE_COUNT, COUNT, POINTER_2). Add_Read(from_2_3, to_return, buf_1). Add_DataSafetyStatusRelations(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>        , ,   ,    ,   .   ,   write-only .   .   . <br><br>         ML. GitHub   .   15000   .     .      : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> fread_unlocked _fread_nolock</span></span></code> </pre> <br>   ? <br><br><ol><li>   .    . </li><li>  ,        ,          . ,   ,    .    . </li><li>   ,  ,       . ,  .   ML       :).        . </li></ol><br>  , ML         . <br><br>  ,    ML,    ,     ,       ,   . , ,     ,     . <br><br>     . ,    ,   WinAPI.     ,    ,   ?   ,        Google,   ,   <b> </b> .  ,      .   <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a>        ,    .       ,        ,    C++. ,            20. <br><br>     ,       .   ,  <i>memmove</i> .    - : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memmove</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin___memmove_chk(dest, src, len, __builtin_object_size(dest, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br>    <i>__builtin___memmove_chk</i> ?  intrinsic ,     .      . <br><br>  <i>memmove</i>   - : <a href="">    </a> .         ,  -   . <br><br> Ok,     .  ,        .  ,    ML   ,     ,     . <br><br>        .    .      . ,        ,   .    ,        AI? ,  AI    ,    .       ,               . ,      20   . <br><br> <b> </b> <br><br>    ,      ,       .     .      ,     . <ul><li> <b> </b> .   ,  ,      .           ,    -     .  Ein Beispiel.  C++         <a href="http://www.cplusplus.com/reference/memory/auto_ptr/"><i>auto_ptr</i></a> .          <i>unique_ptr</i> . </li><li> <b> </b> .  ,   C  C++   ,  <a href="https://www.viva64.com/ru/t/0012/"> </a> .  ,         .    ,     . ,  <i>long</i>  Windows 32/64    32 .    Linux       32/64      .    ,           .       -.  , ,  .       ,      (   ).     ,       . </li><li> <b> </b> .     ML,   ,  ,    .  Das hei√üt     ,   ‚Äî ,    ,   .     ,       .    ,     ,   ‚Äî ,  .          .      ,    /  , ,   ,       .        .   : " <a href="https://www.viva64.com/ru/b/0612/">   PVS-Studio:    </a> ".       ,   , . </li></ul><br><h2>  </h2><br>       ,   ,     .    ML    ,    ,    (   )     .       ,   ,  ML    . <br><br>      ,    ,     ML.           ,  ,            . <br><br>  ,     ML      . ,   .  ML    ¬´¬ª               . <br><br>    ,       ,    ,     ,     . <br><br>         ML,       . <br><br><h2>  PS </h2><br>       ,  -  ,       <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D1%2583%25D0%25B4%25D0%25B4%25D0%25B8%25D1%2582%25D1%258B"></a>   ML,      . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/659/1f4/7fa/6591f47faa384c2ac9472bc1f5eeacb9.png" alt="Luddite Einh√∂rner"></div><br><br> ,   .               PVS-Studio.          ML.  ,         .          ,     ,   ,     if- :).      ,     :). <br><br>      ,            -,     . <br><br>   .      " <a href="https://www.viva64.com/ru/b/0687/">        PVS-Studio</a> ". <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/484202/"><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>        ,      : Andrey Karpov, Victoria Khanieva. <a href="https://habr.com/en/company/pvs-studio/blog/484202/">Machine Learning in Static Analysis of Program Source Code</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484208/">https://habr.com/ru/post/de484208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484198/index.html">R√ºckseite der Medaille: Wer hat beim Wachstum der Tesla-Aktien gewonnen und verloren?</a></li>
<li><a href="../de484200/index.html">Wie man Ziele setzt, um sie zu erreichen</a></li>
<li><a href="../de484202/index.html">Maschinelles Lernen in der statischen Analyse von Programmquellcode</a></li>
<li><a href="../de484204/index.html">FTCODE fileless Ransomware stiehlt jetzt Konten</a></li>
<li><a href="../de484206/index.html">Verwendung von Mixins in Dart</a></li>
<li><a href="../de484212/index.html">Free stuff for karma - die Geschichte eines belarussischen Startups, das das Konsumprinzip √§ndert</a></li>
<li><a href="../de484214/index.html">Tensoren in TensorFlow</a></li>
<li><a href="../de484216/index.html">Zweite Zabbix-Konferenz in Russland: Anmeldung und wichtige Termine</a></li>
<li><a href="../de484218/index.html">Wir optimieren die Automatisierung: So haben wir die Autotests um das 3-4-fache beschleunigt und dabei die alten Entwicklungen bewahrt</a></li>
<li><a href="../de484220/index.html">Haben Sie Lieferung bestellt? So liefert Crossroads 6.000 Bestellungen pro Tag</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>