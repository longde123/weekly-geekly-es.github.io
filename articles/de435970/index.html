<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤣 🎩 🎱 Anfängerhandbuch zur Webserverentwicklung mit Node.js. 👄 👩‍🌾 🎇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Während des größten Teils meiner Webkarriere habe ich ausschließlich auf Kundenseite gearbeitet. Entwerfen adaptiver Layouts, Erstellen von Visualisie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anfängerhandbuch zur Webserverentwicklung mit Node.js.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435970/"> Während des größten Teils meiner Webkarriere habe ich ausschließlich auf Kundenseite gearbeitet.  Entwerfen adaptiver Layouts, Erstellen von Visualisierungen aus großen Datenmengen, Erstellen von Anwendungs-Dashboards usw. Aber ich musste mich nie direkt mit Routing- oder HTTP-Anforderungen befassen.  Bis vor kurzem. <br><br>  Dieser Beitrag beschreibt, wie ich mehr über die serverseitige Webentwicklung mit Node.js erfahren habe, und einen kurzen Vergleich des Schreibens eines einfachen HTTP-Servers mit drei verschiedenen Umgebungen, Express, Koa.js und Hapi.js. <br><br>  Hinweis: Wenn Sie ein erfahrener Node.js-Entwickler sind, werden Sie wahrscheinlich denken, dass dies alles elementar / einfach ist.  ¯ \ _ (ツ) _ / ¯. <br><a name="habracut"></a><br><h3>  Einige Grundlagen des Netzwerks </h3><br>  Als ich vor ein paar Jahren anfing, in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webbranche</a> zu arbeiten, stieß ich auf einen Kurs über Computernetzwerke von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Professor David Veteral</a> auf Coursera.  Leider ist es nicht mehr verfügbar, aber Vorträge sind weiterhin auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Pearson-Website</a> verfügbar. <br><br>  Dieser Kurs hat mir sehr gut gefallen, weil er auf verständliche Weise erklärt hat, was unter der Haube passiert. Wenn Sie also <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das</a> Lehrbuch für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Computernetzwerke</a> lesen können, lesen Sie alle Details zu den Wundern des Netzwerks. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tz/ij/my/tzijmyfk0da6oiy2_qljlgiz7yi.jpeg" alt="Bild"></div><br>  Hier werde ich jedoch nur kurz auf den Kontext eingehen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP (Hypertext Transfer Protocol)</a> ist ein Kommunikationsprotokoll, das in Computernetzwerken verwendet wird.  Es gibt viele im Internet, wie z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMTP (Simple Mail Transfer Protocol)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FTP (File Transfer Protocol)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POP3 (Post Office Protocol 3)</a> und so weiter. <br><br>  Diese Protokolle ermöglichen Geräten mit völlig unterschiedlicher Hardware / Software die Kommunikation miteinander, da sie genau definierte Nachrichtenformate, Regeln, Syntax und Semantik usw. bereitstellen.  Dies bedeutet, dass das Gerät zwar ein bestimmtes Protokoll unterstützt, jedoch mit jedem anderen Gerät kommunizieren kann.  im Netz. <br><br><img src="https://habrastorage.org/webt/p6/vd/mw/p6vdmwx1vzpq_bbkzbpqzrepvq8.png" alt="Bild"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Von TCP / IP vs OSI: Was ist der Unterschied zwischen den beiden Modellen?</a> <br><br>  Betriebssysteme werden normalerweise standardmäßig mit Netzwerkprotokollen wie HTTP unterstützt. Dies erklärt, warum wir keine explizite zusätzliche Software installieren müssen, um auf das Internet zugreifen zu können.  Die meisten Netzwerkprotokolle unterstützen eine offene Verbindung zwischen zwei Geräten, sodass sie Daten hin und her übertragen können. <br><br>  Das HTTP, auf dem das Netzwerk ausgeführt wird, ist unterschiedlich.  Es ist als verbindungsloses Protokoll bekannt, da es auf einem Anforderungs- / Antwortmodus basiert.  Webbrowser senden Anforderungen für Bilder, Schriftarten, Inhalte usw. an den Server. Nach Abschluss der Anforderung wird jedoch die Verbindung zwischen dem Browser und dem Server getrennt. <br><br><img src="https://habrastorage.org/webt/go/q5/bg/goq5bgxj17-zzxi4sjdovt1y37m.png" alt="Bild"><br><br><h3>  Server und Clients </h3><br>  Der Begriff Server kann für Personen, die zum ersten Mal in der Branche neu sind, etwas verwirrend sein, da er sich sowohl auf Hardware (physische Computer, auf denen alle für Websites erforderlichen Dateien und Software gehostet werden) als auch auf Software (ein Programm, das dies tut) beziehen kann ermöglicht Benutzern den Online-Zugriff auf diese Dateien). <br><br>  Heute werden wir über die Software-Seite der Dinge sprechen.  Aber zuerst ein paar Definitionen.  Die URL steht für Universal Resource Locator und besteht aus drei Teilen: <b>Protokoll</b> , <b>Server</b> und der <b>angeforderten Datei</b> . <br><br><img src="https://habrastorage.org/webt/lj/gd/2f/ljgd2fxjq0rzhabqnqawi5tm4ie.png" alt="Bild"><br>  URL-Struktur <br><br>  Das HTTP-Protokoll definiert verschiedene Methoden, mit denen der Browser den Server auffordern kann, eine Reihe verschiedener Aktionen auszuführen, von denen die häufigsten GET und POST sind.  Wenn ein Benutzer auf einen Link klickt oder eine URL in die Adressleiste eingibt, sendet der Browser eine GET-Anforderung an den Server, um die in der URL angegebene Ressource abzurufen. <br><br>  Der Server muss wissen, wie diese HTTP-Anforderung verarbeitet wird, um die richtige Datei zu erhalten, und sie dann an den Browser zurücksenden, der sie angefordert hat.  Die beliebteste Webserver-Software, die dies handhabt, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://">Apache</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NGINX</a> . <br><br><img src="https://habrastorage.org/webt/om/tm/0-/omtm0-wfyp4aokdrgre1c9p2mi8.png" alt="Bild"><br>  <i>Webserver verarbeiten eingehende Anfragen und reagieren entsprechend</i> <br><br>  Bei beiden handelt es sich um Open-Source-Softwarepakete mit vollem Funktionsumfang, die Funktionen wie Authentifizierungsschemata, Umschreiben von URLs, Protokollierung und Proxy enthalten, um nur einige zu nennen.  Apache und NGINX sind in C geschrieben. Technisch gesehen können Sie einen Webserver in jeder Sprache schreiben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.python.org/3/library/">Python</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/">golang.org/pkg/net/http</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://blog.appsignal.com/2016/11/23/ruby-magic-building-a-30-line-">Ruby</a> , diese Liste kann einige Zeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/">dauern</a> .  Es ist nur so, dass einige Sprachen bestimmte Dinge besser können als andere. <br><br><h3>  Erstellen eines HTTP-Servers mit Node.js. </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js</a> ist eine Javascript-Laufzeit, die auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrome V8-Javascript-Engine</a> basiert.  Es wird mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://nodejs.org/api/">http-Modul geliefert</a> , das eine Reihe von Funktionen und Klassen zum Erstellen eines HTTP-Servers bereitstellt. <br><br>  Für diesen grundlegenden HTTP-Server verwenden wir auch das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateisystem</a> , den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pfad</a> und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">URL</a> , die native Module von Node.j sind. <br><br>  Importieren Sie zunächst die erforderlichen Module. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   HTTP-  Node.js const fs = require('fs') //      const path = require('path') //        const url = require('url') //     URL</span></span></code> </pre> <br>  Wir werden auch ein MIME-Typwörterbuch erstellen, damit wir der angeforderten Ressource basierend auf ihrer Erweiterung den entsprechenden MIME-Typ zuweisen können.  Eine vollständige Liste der MIME-Typen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Internet Assigned Numbers Authority</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mimeTypes = { <span class="hljs-string"><span class="hljs-string">'.html'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/html'</span></span>, <span class="hljs-string"><span class="hljs-string">'.js'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/javascript'</span></span>, <span class="hljs-string"><span class="hljs-string">'.css'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/css'</span></span>, <span class="hljs-string"><span class="hljs-string">'.ico'</span></span>: <span class="hljs-string"><span class="hljs-string">'image/x-icon'</span></span>, <span class="hljs-string"><span class="hljs-string">'.png'</span></span>: <span class="hljs-string"><span class="hljs-string">'image/png'</span></span>, <span class="hljs-string"><span class="hljs-string">'.jpg'</span></span>: <span class="hljs-string"><span class="hljs-string">'image/jpeg'</span></span>, <span class="hljs-string"><span class="hljs-string">'.gif'</span></span>: <span class="hljs-string"><span class="hljs-string">'image/gif'</span></span>, <span class="hljs-string"><span class="hljs-string">'.svg'</span></span>: <span class="hljs-string"><span class="hljs-string">'image/svg+xml'</span></span>, <span class="hljs-string"><span class="hljs-string">'.json'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'.woff'</span></span>: <span class="hljs-string"><span class="hljs-string">'font/woff'</span></span>, <span class="hljs-string"><span class="hljs-string">'.woff2'</span></span>: <span class="hljs-string"><span class="hljs-string">'font/woff2'</span></span> }</code> </pre><br>  Jetzt können wir einen HTTP-Server mit der Funktion <code>http.createServer()</code> erstellen, der eine neue Instanz von <code>http.Server</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer()</code> </pre> <br>  Wir werden die Request-Handler-Funktion mit den <code>createServer()</code> und Response-Objekten an <code>createServer()</code> .  Diese Funktion wird jedes Mal einmal aufgerufen, wenn eine HTTP-Anforderung beim Server eintrifft. <br><br><pre> <code class="javascript hljs">server.on(<span class="hljs-string"><span class="hljs-string">'request'</span></span>, (req, res) =&gt; { <span class="hljs-comment"><span class="hljs-comment">//     })</span></span></code> </pre><br>  Der Server wird gestartet, indem die <code>listen</code> Methode des <code>server</code> mit der Portnummer aufgerufen wird, die der Server abhören soll, z. B. <code>5000</code> . <br><br><pre> <code class="javascript hljs">server.listen(<span class="hljs-number"><span class="hljs-number">5000</span></span>)</code> </pre> <br>  Das <code>request</code> ist eine Instanz von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://nodejs.org/api/http.html&amp;usg=ALkJrhgZsGkpsnihHTPHWPu_TgP1P6Um4g#http_class_">IncomingMessage</a> und ermöglicht den Zugriff auf alle Informationen zur Anforderung, z. B. Antwortstatus, Header und Daten. <br><br>  Das <code>response</code> ist eine Instanz von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://nodejs.org/api/http.html&amp;usg=ALkJrhgZsGkpsnihHTPHWPu_TgP1P6Um4g#http_class_">ServerResponse</a> , einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschreibbaren Stream,</a> der viele Methoden zum Zurücksenden von Daten an den Client bietet. <br><br>  Im Abfrage-Handler möchten wir Folgendes tun: <br><br><ul><li>  Analysieren Sie eingehende Anfragen und verarbeiten Sie sie ohne Erweiterungen <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parsedUrl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(req.url, <span class="hljs-string"><span class="hljs-string">'https://node-http.glitch.me/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pathName = parsedUrl.pathname <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ext = path.extname(pathName) <span class="hljs-comment"><span class="hljs-comment">//   URL    '/',   '/' //      URL    'Location' if (pathName !== '/' &amp;&amp; pathName[pathName.length - 1] === '/') { res.writeHead(302, {'Location': pathName.slice(0, -1)}) res.end() return } //     ,  index.html //     «.html»       if (pathName === '/') { ext = '.html' pathName = '/index.html' } else if (!ext) { ext = '.html' pathName += ext }</span></span></code> </pre> <br></li><li>  Führen Sie einige elementare Überprüfungen durch, um festzustellen, ob die angeforderte Ressource vorhanden ist, und reagieren Sie entsprechend <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,       const filePath = path.join(process.cwd(), '/public', pathName) // ,       fs.exists(filePath, function (exists, err) { //     ,  404 Not Found if (!exists || !mimeTypes[ext]) { console.log('  : ' + pathName) res.writeHead(404, {'Content-Type': 'text/plain'}) res.write('404 Not Found') res.end() return } //        200 OK, //       res.writeHead(200, {'Content-Type': mimeTypes[ext]}) //        const fileStream = fs.createReadStream(filePath) fileStream.pipe(res) })</span></span></code> </pre> <br></li></ul><br>  Der gesamte Code wird auf Glitch gehostet, und Sie können das Projekt neu mischen, wenn Sie möchten. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://glitch.com/edit/&amp;usg=ALkJrhhsZCf07YJJia3K_pJoJzkb91qH_w#!/node-">https://glitch.com/edit/#!/node-http</a> <br><br><h3>  Erstellen eines HTTP-Servers mit Node.js-Frameworks </h3><br>  Node.js Frameworks wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Express</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koa.js</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hapi.js bieten</a> neben vielen anderen praktischen Funktionen verschiedene nützliche Middleware-Funktionen, die es Entwicklern ersparen, selbst schreiben zu müssen. <br><br>  Persönlich denke ich, dass es besser ist, zuerst die Grundlagen ohne Frameworks zu lernen, nur um zu verstehen, was unter der Haube passiert, und dann mit jedem Framework, das Sie mögen, verrückt zu werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Express</a> verfügt über ein eigenes integriertes Plugin zum Bereitstellen statischer Dateien, sodass der Code, der zum Ausführen derselben Aktionen wie in seiner eigenen Node.js erforderlich ist, viel kürzer ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express() <span class="hljs-comment"><span class="hljs-comment">//         app.use(express.static('public')) //  index.html,      //     res.sendFile() app.get('/', (req, res) =&gt; { res.sendFile(__dirname + '/public/index.html') }) app.listen(5000)</span></span></code> </pre> <br>  Koa.js hat kein ähnliches Plugin in seinem Kern, daher muss jedes erforderliche Plugin separat installiert werden.  Die neueste Version von Koa.js verwendet asynchrone Funktionen zugunsten von Rückrufen.  Sie können das <code>koa-static</code> Plugin verwenden, um statische Dateien bereitzustellen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> serve = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'koa-static'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> koa = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'koa'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> koa() <span class="hljs-comment"><span class="hljs-comment">//         //   koa-static    index.html    app.use(serve(__dirname + '/public')) app.listen(5000)</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hapi.js</a> unterstützt die Anpassung und dreht sich um die Anpassung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serverobjekts</a> .  Es verwendet Plugins, um Funktionen wie Routing, Authentifizierung usw. zu erweitern.  Um statische Dateien bereitzustellen, benötigen wir ein Plugin namens <code>inert</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hapi = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'hapi'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inert = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'inert'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//        const server = new hapi.Server({ port: 5000, routes: { files: { relativeTo: path.join(__dirname, 'public') } } }) const init = async () =&gt; { // server.register()      await server.register(inert) // inert     //       server.route({ method: 'GET', path: '/{param*}', handler: { directory: { path: '.', redirectToSlash: true, index: true } } }) await server.start() } init()</span></span></code> </pre> <br>  Jede dieser Plattformen hat ihre Vor- und Nachteile. Sie sind für größere Anwendungen und nicht nur für die Bereitstellung einer einzelnen HTML-Seite offensichtlicher.  Die Wahl der Struktur hängt stark von den tatsächlichen Anforderungen des Projekts ab, an dem Sie arbeiten. <br><br><h3>  Fertigstellung </h3><br>  Wenn die Netzwerkseite für Sie schon immer eine Black Box war, hoffe ich, dass dieser Artikel als nützliche Einführung in das Protokoll dienen kann, das das Netzwerk bereitstellt.  Ich empfehle außerdem dringend, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API-Dokumentation zu Node.js zu</a> lesen, die sehr gut geschrieben und für jeden Neuling bei Node.js im Allgemeinen sehr nützlich ist. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTP von MDN</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://nodejs.org/en/docs/guides/anatomy-of-an-">Anatomie einer HTTP-Transaktion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://medium.com/from-the-scratch/http-server-what-do-you-need-to-know-to-build-a-simple-">HTTP-Server: Alles, was Sie wissen müssen, um einen einfachen HTTP-Server von Grund auf neu zu erstellen</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435970/">https://habr.com/ru/post/de435970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435958/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 347 (7. - 13. Januar 2019)</a></li>
<li><a href="../de435960/index.html">Gedankenexperiment: Flattern unterwegs</a></li>
<li><a href="../de435962/index.html">25 Jahre Aeron: Sensationen und Eindrücke der aktualisierten Version von Aeron Remastered</a></li>
<li><a href="../de435964/index.html">Ethereum plant, 99% wirtschaftlicher zu sein</a></li>
<li><a href="../de435968/index.html">Übersicht über Deep Machine Learning-Algorithmen für Roboter</a></li>
<li><a href="../de435972/index.html">Einführung der reaktiven Programmierung im Frühjahr</a></li>
<li><a href="../de435974/index.html">Three.js - Steuerelemente für Weltraum oder Planetarium</a></li>
<li><a href="../de435976/index.html">WebAssembly in der Produktion und das „Minenfeld“ von Smart TV: ein Interview mit Andrei Nagih</a></li>
<li><a href="../de435978/index.html">Problemumgehungen für den biometrischen Schutz</a></li>
<li><a href="../de435984/index.html">Neuronale Netze und Sprachphilosophie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>