<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>す   Solo eche un vistazo a SObjectizer si desea usar Actores o CSP en su proyecto C ++  锔 </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algunas palabras sobre SObjectizer y su historia 


 SObjectizer es un marco C ++ bastante peque帽o que simplifica el desarrollo de aplicaciones multip...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Solo eche un vistazo a SObjectizer si desea usar Actores o CSP en su proyecto C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458202/"><p><img src="https://habrastorage.org/webt/qq/0_/at/qq0_atvjcf2gb0uklnpqjbl31hw.jpeg"></p><br><h1 id="a-few-words-about-sobjectizer-and-its-history">  Algunas palabras sobre SObjectizer y su historia </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">SObjectizer</a> es un marco C ++ bastante peque帽o que simplifica el desarrollo de aplicaciones multiproceso.  SObjectizer permite a un desarrollador utilizar enfoques de modelos de Actor, Publicar-Suscribirse y Procesos secuenciales de comunicaci贸n (CSP).  Es un proyecto OpenSource que se distribuye bajo licencia BSD-3-CLAUSE. </p><br><p>  SObjectizer tiene una larga historia.  SObjectizer en s铆 naci贸 en 2002 como proyecto SObjectizer-4.  Pero se bas贸 en ideas del anterior SCADA Objectizer que se desarroll贸 entre 1995 y 2000. SObjectizer-4 fue de c贸digo abierto en 2006, pero su evoluci贸n se detuvo poco despu茅s.  Una nueva versi贸n de SObjectizer con el nombre SObjectizer-5 se inici贸 en 2010 y fue de c贸digo abierto en 2013. La evoluci贸n de SObjectizer-5 todav铆a est谩 en progreso y SObjectizer-5 ha incorporado muchas caracter铆sticas nuevas desde 2013. </p><br><p>  SObjectizer es m谩s o menos conocido en el segmento ruso de Internet, pero casi desconocido fuera del exUSSR.  Se debe a que SObjectizer se utiliz贸 principalmente para proyectos locales en pa铆ses exUSSR y muchos art铆culos, presentaciones y charlas sobre SObjectizer est谩n en ruso. </p><br><h1 id="a-niche-for-sobjectizer-and-similar-tools">  Un nicho para SObjectizer y herramientas similares </h1><br><p>  Multithreading se utiliza en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">computaci贸n paralela</a> , as铆 como en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">computaci贸n concurrente</a> .  Pero hay una gran diferencia entre la computaci贸n paralela y concurrente.  Y, como consecuencia, hay herramientas dirigidas a la computaci贸n paralela, y hay herramientas para la computaci贸n concurrente, y son diferentes. </p><a name="habracut"></a><br><p>  En t茅rminos generales, la computaci贸n paralela se trata de usar varios n煤cleos para reducir los tiempos de c谩lculo.  Por ejemplo, transcodificar un archivo de video de un formato a otro puede llevar una hora en un n煤cleo de CPU, pero solo 15 minutos en cuatro n煤cleos de CPU.  Herramientas como OpenMP, Intel TBB, HPX o cpp-taskflow est谩n dise帽adas para ser utilizadas en computaci贸n paralela.  Y esas herramientas son compatibles con los enfoques de esa 谩rea, como la programaci贸n basada en tareas o el flujo de datos. </p><br><p>  La computaci贸n concurrente consiste en tratar muchas tareas (probablemente diferentes) al mismo tiempo.  El servidor de bases de datos o MQ-broker pueden ser buenos ejemplos: un servidor debe aceptar una conexi贸n, leer y analizar datos de las conexiones aceptadas, manejar las solicitudes recibidas (realizar varias acciones para cada solicitud), enviar respuestas, etc.  Estrictamente hablando, no hay necesidad de usar subprocesos m煤ltiples en la inform谩tica concurrente: todas esas tareas se pueden realizar en un solo subproceso de trabajo.  Pero el uso de subprocesos m煤ltiples y varios n煤cleos de CPU puede hacer que su aplicaci贸n sea m谩s eficiente, escalable y receptiva. </p><br><p>  Enfoques como Actor Model o CSP est谩n destinados a tratar con la computaci贸n concurrente.  Buenos ejemplos de actores de uso en el 谩rea de computaci贸n concurrente son el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">proyecto InfineSQL</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Yandex Message-Queue</a> .  Ambos proyectos usan actores dentro. </p><br><p>  Entonces, las herramientas como SObjectizer, QP / C ++ o CAF, que son compatibles con Actor Model, son 煤tiles para resolver tareas desde el 谩rea de computaci贸n concurrente.  Significa que el uso de SObjectizer probablemente no le dar谩 nada en tareas como la conversi贸n de transmisiones de video.  Pero puede obtener un resultado muy diferente implementando un intermediario de mensajes sobre SObjectizer. </p><br><h2 id="disclaimer">  Descargo de responsabilidad </h2><br><p>  El uso de modelos Actor o CSP puede brindarle enormes beneficios en algunas tareas, pero no hay garant铆as de que esos modelos sean apropiados para su problema particular.  La charla sobre la aplicabilidad de los modelos Actor o CSP est谩 m谩s all谩 del alcance de ese art铆culo.  Supongamos que el modelo Actor y / o CSP es aplicable para sus tareas y usted sabe c贸mo usarlas de manera eficiente. </p><br><h1 id="what-sobjectizer-can-give-to-a-user">  驴Qu茅 SObjectizer puede dar a un usuario? </h1><br><h2 id="shared-nothing-and-fire-and-forget-principles-just-out-of-box">  Principios de nada compartido y disparar y olvidar reci茅n salidos de la caja </h2><br><p>  El uso de actores supone la ausencia de datos compartidos.  Cada actor posee sus datos y estos datos no son visibles para nadie m谩s.  Este es <em>un principio de nada compartido</em> que es bien conocido en el desarrollo de aplicaciones distribuidas, por ejemplo.  En la aplicaci贸n multiproceso, el principio de nada compartido tiene un beneficio importante: permite evitar problemas tan peligrosos para trabajar con datos compartidos como puntos muertos y carreras de datos. </p><br><p>  La interacci贸n entre actores (agentes) en SObjectizer se realiza solo a trav茅s de mensajes asincr贸nicos.  Un agente env铆a un mensaje a otro agente y esta operaci贸n no bloquea al remitente (en un caso com煤n). </p><br><p>  La interacci贸n asincr贸nica permite usar otro principio 煤til: <em>disparar y olvidar</em> .  Cuando un agente necesita realizar alguna operaci贸n, env铆a (dispara) un mensaje y contin煤a su trabajo.  En la mayor铆a de los casos, el mensaje ser谩 recibido y procesado. </p><br><p>  Por ejemplo, puede haber un agente que lea las conexiones aceptadas y analice los datos entrantes.  Si toda la PDU se lee y analiza, el agente solo env铆a esa PDU a otro agente-procesador y vuelve a leer / analizar nuevos datos entrantes. </p><br><h2 id="dispatchers">  Despachadores </h2><br><p>  Los despachadores son uno de los pilares de SObjectizer.  Los despachadores proporcionan un contexto de trabajo (tambi茅n conocido como hilo de trabajo) en el que un agente manejar谩 los mensajes entrantes.  En lugar de crear subprocesos de trabajo (o grupos de subprocesos) manualmente, un usuario crea despachadores y les vincula agentes.  Un usuario puede crear tantos despachadores en una aplicaci贸n como desee. </p><br><p>  Lo mejor con los despachadores y los agentes en SObjectizer es la separaci贸n de conceptos: los despachadores son responsables de administrar el contexto de trabajo y las propias colas de mensajes, los agentes realizan la l贸gica de la aplicaci贸n y no se preocupan por el contexto del trabajador.  Permite mover un agente de un despachador a otro literalmente con un clic.  Ayer, un agente trabaj贸 en one_thread dispatcher, hoy podemos volver a vincularlo a active_obj dispatcher, y ma帽ana podemos volver a vincularlo a thread_pool dispatcher.  Sin cambiar una l铆nea en la implementaci贸n del agente. </p><br><p>  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">ocho tipos de despachadores en SObjectizer-5.6.0</a> (y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">se</a> puede encontrar otro en el proyecto complementario so5extra): desde los muy simples (one_thread o thread_pool) hasta los sofisticados (como adv_thread_pool o prio_dedicated_threads :: one_per_prio).  Y un usuario puede escribir su propio despachador para condiciones espec铆ficas. </p><br><h2 id="hierarchical-state-machines-are-built-in-functionality">  Las m谩quinas de estado jer谩rquicas son funciones integradas </h2><br><p>  Los agentes (actores) en SObjectizer son m谩quinas de estado: la reacci贸n en un mensaje entrante depende del estado actual del agente.  SObjectizer es compatible con la mayor铆a de las caracter铆sticas de m谩quinas de estado jer谩rquico (HSM): estados anidados, historial profundo y superficial para un estado, controladores on_enter / on_exit, l铆mites de tiempo para permanecer en un estado.  Solo los estados ortogonales no son compatibles con SObjectizer ahora (no vimos la necesidad de esa caracter铆stica en nuestros proyectos, y nadie nos pidi贸 que agreguemos soporte para esa caracter铆stica). </p><br><h2 id="csp-like-channels-just-out-of-box">  Canales similares a CSP reci茅n listos </h2><br><p> No es necesario usar los agentes de SObjectizer (tambi茅n conocidos como actores).  Toda la aplicaci贸n se puede desarrollar simplemente usando objetos <code>std::thread</code> y mchains de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">SObjectizer (tambi茅n conocidos como canales CSP)</a> .  En ese caso, el desarrollo de aplicaciones con SObjectizer ser谩 algo similar al desarrollo en lenguaje Go (incluido un an谩logo de la construcci贸n <code>select</code> de Go que permite esperar mensajes de varios canales). </p><br><p>  Las cadenas de SObjectizer pueden tener una caracter铆stica muy importante: mecanismo de contrapresi贸n incorporado.  Si un usuario crea un mchain de tama帽o limitado y luego intenta insertar un mensaje en el mchain completo, la operaci贸n de env铆o puede bloquear al remitente durante alg煤n tiempo.  Permite resolver un problema famoso con un productor r谩pido y un consumidor lento. </p><br><p>  Los mchains de SObjectizer tienen otra caracter铆stica interesante: un mchain se puede usar como una herramienta de distribuci贸n de carga muy simple.  Varios hilos pueden esperar <em>recibir</em> de la misma cadena al mismo tiempo.  Si se env铆a un nuevo mensaje a ese mchain, solo un hilo leer谩 y manejar谩 ese mensaje. </p><br><h2 id="only-a-part-of-an-application-can-use-sobjectizer">  Solo una parte de una aplicaci贸n puede usar SObjectizer </h2><br><p>  No es necesario usar SObjectizer en cada parte de una aplicaci贸n.  Solo se puede desarrollar una parte de una aplicaci贸n utilizando SObjectizer.  Entonces, si ya usa Qt o wxWidgets, o Boost.Asio como marco principal para su aplicaci贸n, es posible usar SObjectize en solo un subm贸dulo de su aplicaci贸n. </p><br><p>  Ten铆amos experiencia en el uso de SObjectizer para el desarrollo de bibliotecas que ocultan el uso de SObjectizer como detalle de implementaci贸n.  La API p煤blica de esas bibliotecas no expuso la presencia de SObjectizer en absoluto.  SObjectizer estaba completamente bajo el control de una biblioteca: la biblioteca se inici贸 y detuvo SObjectizer cuando era necesario.  Esas bibliotecas se usaron en aplicaciones que desconoc铆an por completo la presencia de SObjectizer. </p><br><p>  Si SObjectizer se usa solo en una parte de una aplicaci贸n, existe una tarea de comunicaci贸n entre las partes SObjectizer y no SObjectizer de la aplicaci贸n.  Esta tarea se resuelve f谩cilmente: los mensajes de una parte que no es SObjectizer a la parte SObjectizer se pueden enviar a trav茅s del mecanismo ordinario de SObjectizer de entrega de mensajes.  Los mensajes en la direcci贸n opuesta se pueden entregar a trav茅s de mchains. </p><br><h2 id="you-can-run-several-instances-of-sobjectizer-at-the-same-time">  Puede ejecutar varias instancias de SObjectizer al mismo tiempo </h2><br><p>  SObjectizer permite ejecutar varias instancias de SObjectizer (denominado SObjectizer Environment) en una aplicaci贸n al mismo tiempo.  Cada entorno SObjectizer ser谩 independiente de otros entornos similares. </p><br><p>  Esta caracter铆stica es invaluable en situaciones en las que tiene que construir una aplicaci贸n a partir de varios m贸dulos independientes.  Algunos m贸dulos pueden usar SObjectizer, otros no.  Los m贸dulos que requieren SObjectizer pueden ejecutar su copia de SObjectizer Environment y eso no influir谩 en otros m贸dulos de la aplicaci贸n. </p><br><h2 id="timers-are-part-of-sobjectizer">  Los temporizadores son parte de SObjectizer </h2><br><p>  El soporte de temporizadores en forma de mensajes retrasados y peri贸dicos es otra de las piedras angulares de SObjectizer.  SObjectizer tiene varias implementaciones de mecanismos de temporizador (timer_wheel, timer_heap y timer_list) y puede manejar decenas, cientos y miles de millones de temporizadores en una aplicaci贸n.  Un usuario puede elegir el mecanismo de temporizador m谩s apropiado para una aplicaci贸n.  Adem谩s, un usuario puede proporcionar su propia implementaci贸n de timer_thread / timer_manager si ninguno de los est谩ndares es apropiado para las condiciones del usuario. </p><br><h2 id="sobjectizer-has-various-customization-points-and-tuning-options">  SObjectizer tiene varios puntos de personalizaci贸n y opciones de ajuste </h2><br><p>  SObjectizer permite la personalizaci贸n de varios mecanismos importantes.  Por ejemplo, un usuario puede seleccionar una de las implementaciones est谩ndar de timer_thread (o timer_manager).  O puede proporcionar su propia implementaci贸n.  Un usuario puede seleccionar una implementaci贸n de objetos de bloqueo utilizados por las colas de mensajes en los despachadores de SObjectizer.  O puede proporcionar su propia implementaci贸n. </p><br><p>  Un usuario puede implementar su propio despachador.  Un usuario puede implementar su propio cuadro de mensaje.  Un usuario puede implementar su propio sobre de mensaje.  Un usuario puede implementar su propio event_queue_hook.  Y as铆 sucesivamente. </p><br><h1 id="where-sobjectizer-can-or-cant-be-used">  驴D贸nde se puede o no se puede utilizar SObjectizer? </h1><br><p>  Es mucho m谩s f谩cil decir d贸nde SObjectizer no se puede usar por razones objetivas.  Entonces, comenzamos la discusi贸n enumerando tales 谩reas y luego daremos algunos ejemplos del uso de SObjectizer en el pasado (y no solo en el pasado). </p><br><h2 id="where-sobjectizer-cant-be-used">  驴D贸nde no se puede utilizar SObjectizer? </h2><br><h3 id="tasks-related-to-parallel-computing">  Tareas relacionadas con la computaci贸n paralela </h3><br><p>  Como se ha dicho anteriormente, los modelos Actor y CSP no son una buena opci贸n para la inform谩tica de alto rendimiento y otras 谩reas de la inform谩tica paralela.  Entonces, si tiene que hacer m煤ltiples matrices o transcodificar transmisiones de video, entonces las herramientas como OpenMP, Intel TBB, cpp-taskflow, HPX o MPI ser谩n m谩s adecuadas. </p><br><h3 id="hard-real-time-systems">  Sistemas duros en tiempo real </h3><br><p>  A pesar de que SObjectizer tiene sus ra铆ces en los sistemas SCADA, la implementaci贸n actual de SObjectizer (tambi茅n conocido como SObjectizer-5) no se puede utilizar en sistemas de tiempo real dif铆ciles.  Se debe principalmente al uso de memoria din谩mica en la implementaci贸n de SObjectizer: los mensajes son objetos asignados din谩micamente (sin embargo, SObjectizer puede usar objetos preasignados como mensajes), los despachadores usan memoria din谩mica para las colas de mensajes, incluso los l铆mites de tiempo para los estados del agente usan objetos asignados din谩micamente para realizar comprobaciones de tiempo. </p><br><p>  Desafortunadamente, el t茅rmino "tiempo real" se usa en exceso en el mundo moderno.  A menudo se dice sobre servicios web en tiempo real, como "aplicaci贸n web en tiempo real" o "an谩lisis web en tiempo real", etc.  El t茅rmino "en l铆nea" o "en vivo" es m谩s apropiado para tales aplicaciones que el t茅rmino "en tiempo real", incluso en forma de "tiempo real suave".  Por lo tanto, si hablamos de algo como "aplicaci贸n web en tiempo real", entonces SObjectizer puede usarse f谩cilmente en tales sistemas "en tiempo real". </p><br><h3 id="constrained-embedded-systems">  Sistemas embebidos restringidos </h3><br><p>  SObjectizer se basa en la biblioteca est谩ndar de C ++: <code>std::thread</code> se usa para la gesti贸n de hilos, <code>std::atomic</code> , <code>std::mutex</code> , <code>std::condition_variable</code> se usan para la sincronizaci贸n de datos, RTTI y <code>dynamic_cast</code> se usan en SOizeject (por ejemplo , <code>std::type_index</code> se usan para la identificaci贸n del tipo de mensaje), las excepciones de C ++ se usan para informar errores. </p><br><p>  Significa que SObjectizer no se puede usar en entornos donde tales instalaciones de la biblioteca est谩ndar no est谩n disponibles.  Por ejemplo, en el desarrollo de sistemas embebidos restringidos donde solo se puede usar una parte de C ++ y C ++ stdlib. </p><br><h2 id="where-sobjectizer-was-used-in-the-past">  驴D贸nde se utiliz贸 SObjectizer en el pasado? </h2><br><p>  Ahora intentamos hablar brevemente sobre algunos casos de uso del uso de SObjectizer en el pasado (y no solo en el pasado).  Desafortunadamente, no es informaci贸n completa porque hay algunos problemas. </p><br><p>  En primer lugar, no conocemos todos los usos de SObjectizer.  SObjectizer es un software gratuito que puede usarse incluso en proyectos propietarios.  Por lo tanto, algunas personas simplemente obtienen SObjectizer y lo usan sin proporcionarnos ning煤n comentario.  A veces adquirimos informaci贸n sobre el uso de SObjectizer (pero sin ning煤n detalle), a veces no sabemos nada. </p><br><p>  El segundo problema es el permiso para compartir informaci贸n sobre el uso de SObjectizer en un proyecto en particular.  Hemos recibido ese permiso muy raramente, en la mayor铆a de los casos, los usuarios de SObjectizer no desean abrir los detalles de implementaci贸n de sus proyectos (a veces entendemos las razones, a veces no). </p><br><p>  Nos disculpamos por el hecho de que la informaci贸n proporcionada es muy escasa y no contiene ning煤n detalle.  Sin embargo, hay algunos ejemplos de uso de SObjectizer: </p><br><ul><li>  Gateway de agregaci贸n SMS / USSD que maneja m谩s de 500 millones de mensajes por mes; </li><li>  parte del sistema que atiende pagos en l铆nea a trav茅s de cajeros autom谩ticos de uno de los mayores bancos rusos; </li><li>  simulaci贸n de modelos de procesos econ贸micos (como parte de la investigaci贸n de doctorado); </li><li>  Sistema distribuido de adquisici贸n de datos y anal铆tico.  Datos recopilados en puntos distribuidos en todo el mundo por los comandos del nodo central.  MQTT se utiliz贸 como transporte para el control y la distribuci贸n de datos adquiridos; </li><li>  entorno de prueba para verificar el sistema de control en tiempo real para equipos ferroviarios; </li><li>  Sistema de control autom谩tico para escenarios de teatro.  M谩s detalles se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> ; </li><li>  componentes de la plataforma de gesti贸n de datos en un sistema de publicidad en l铆nea. </li></ul><br><h1 id="a-taste-of-sobjectizer">  Una muestra de SObjectizer </h1><br><p>  Veamos varios ejemplos simples para probar SObjectizer.  Esos son ejemplos muy simples que, esperamos, no requieren explicaciones adicionales, excluyendo los comentarios en el c贸digo. </p><br><h2 id="the-traditional-hello-world-example-in-actor-models-style">  El tradicional ejemplo "Hello, World" en el estilo de Actor Model </h2><br><p>  El ejemplo m谩s simple con un solo agente que reacciona al mensaje de <code>hello</code> y termina su trabajo: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to an agent. struct hello { std::string greeting_; }; // Demo agent. class demo final : public so_5::agent_t { void on_hello(mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; // Now agent can finish its work. so_deregister_agent_coop_normally(); } public: // There is no need is a separate constructor. using so_5::agent_t::agent_t; // Preparation of agent to work inside SObjectizer. void so_define_agent() override { // Subscription to 'hello' message. so_subscribe_self().event(&amp;demo::on_hello); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Make and register an instance of demo agent. auto mbox = env.introduce_coop([](so_5::coop_t &amp; coop) { auto * a = coop.make_agent&lt;demo&gt;(); return a-&gt;so_direct_mbox(); }); // Send hello message to registered agent. so_5::send&lt;hello&gt;(mbox, "Hello, World!"); }); }</span></span></span></span></code> </pre> <br><h2 id="another-version-of-hello-world-with-agents-and-publishsubscribe-model">  Otra versi贸n de "Hello, World" con agentes y modelo de publicaci贸n / suscripci贸n </h2><br><p>  El ejemplo m谩s simple con varios agentes, todos reaccionan a la misma instancia de mensaje de <code>hello</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; using namespace std::string_literals; // Message to be sent to an agent. struct hello { std::string greeting_; }; // Demo agent. class demo final : public so_5::agent_t { const std::string name_; void on_hello(mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; name_ &lt;&lt; ": greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; // Now agent can finish its work. so_deregister_agent_coop_normally(); } public: demo(context_t ctx, std::string name, so_5::mbox_t board) : agent_t{std::move(ctx)} , name_{std::move(name)} { // Create a subscription for hello message from board. so_subscribe(board).event(&amp;demo::on_hello); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Mbox to be used for speading hello message. auto board = env.create_mbox(); // Create several agents in separate coops. for(const auto &amp; n : {"Alice"s, "Bob"s, "Mike"s}) env.register_agent_as_coop(env.make_agent&lt;demo&gt;(n, board)); // Spread hello message to all subscribers. so_5::send&lt;hello&gt;(board, "Hello, World!"); }); }</span></span></span></span></code> </pre> <br><p>  Si ejecutamos ese ejemplo, podemos recibir algo as铆: </p><br><pre> <code class="plaintext hljs">Alice: greeting received: Hello, World! Bob: greeting received: Hello, World! Mike: greeting received: Hello, World!</code> </pre> <br><h2 id="hello-world-example-in-csp-style">  Ejemplo de "Hola mundo" en estilo CSP </h2><br><p>  Veamos un ejemplo de SObjectizer sin ning煤n actor, solo <code>std::thread</code> y canales similares a CSP. </p><br><h3 id="very-simple-version">  Versi贸n muy simple </h3><br><p>  Esta es una versi贸n muy simple que no es segura a excepci贸n: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to a channel. struct hello { std::string greeting_; }; void demo_thread_func(so_5::mchain_t ch) { // Wait while hello received. so_5::receive(so_5::from(ch).handle_n(1), [](so_5::mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; }); } int main() { // Run SObjectizer in a separate thread. so_5::wrapped_env_t sobj; // Channel to be used. auto ch = so_5::create_mchain(sobj); std::thread demo_thread{demo_thread_func, ch}; // Send a greeting. so_5::send&lt;hello&gt;(ch, "Hello, World!"); // Wait for demo thread. demo_thread.join(); }</span></span></span></span></code> </pre> <br><h3 id="more-robust-but-still-simple-version">  Versi贸n m谩s robusta, pero a煤n simple. </h3><br><p>  Esta es una versi贸n modificada del ejemplo que se muestra arriba con la adici贸n de seguridad de excepci贸n: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // Message to be sent to a channel. struct hello { std::string greeting_; }; void demo_thread_func(so_5::mchain_t ch) { // Wait while hello received. so_5::receive(so_5::from(ch).handle_n(1), [](so_5::mhood_t&lt;hello&gt; cmd) { std::cout &lt;&lt; "Greeting received: " &lt;&lt; cmd-&gt;greeting_ &lt;&lt; std::endl; }); } int main() { // Run SObjectizer in a separate thread. so_5::wrapped_env_t sobj; // Demo thread. We need object now, but thread will be started later. std::thread demo_thread; // Auto-joiner for the demo thread. auto demo_joiner = so_5::auto_join(demo_thread); // Channel to be used. This channel will be automatically closed // in the case of an exception. so_5::mchain_master_handle_t ch_handle{ so_5::create_mchain(sobj), so_5::mchain_props::close_mode_t::retain_content }; // Now we can run demo thread. demo_thread = std::thread{demo_thread_func, *ch_handle}; // Send a greeting. so_5::send&lt;hello&gt;(*ch_handle, "Hello, World!"); // There is no need to wait for something explicitly. }</span></span></span></span></code> </pre> <br><h2 id="a-rather-simple-hsm-example-blinking_led">  Un ejemplo de HSM bastante simple: blinking_led </h2><br><p>  Este es un ejemplo est谩ndar de la distribuci贸n de SObjectizer.  El agente principal de este ejemplo es un HSM que puede describirse en el siguiente diagrama de estado: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eca/679/59d/eca67959d472d154ce57878d4ffe0120.png" alt="diagrama de estado de parpadeo"></p><br><p>  El c贸digo fuente del ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;so_5/all.hpp&gt; class blinking_led final : public so_5::agent_t { state_t off{ this }, blinking{ this }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; public : struct turn_on_off final : public so_5::signal_t {}; blinking_led( context_t ctx ) : so_5::agent_t{ ctx } { this &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ std::cout &lt;&lt; "ON" &lt;&lt; std::endl; } ) .on_exit( []{ std::cout &lt;&lt; "off" &lt;&lt; std::endl; } ) .time_limit( std::chrono::milliseconds{1500}, blink_off ); blink_off .time_limit( std::chrono::milliseconds{750}, blink_on ); } }; int main() { try { so_5::launch( []( so_5::environment_t &amp; env ) { auto m = env.introduce_coop( []( so_5::coop_t &amp; coop ) { auto led = coop.make_agent&lt; blinking_led &gt;(); return led-&gt;so_direct_mbox(); } ); auto pause = []( unsigned int v ) { std::this_thread::sleep_for( std::chrono::seconds{v} ); }; std::cout &lt;&lt; "Turn blinking on for 10s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 10 ); std::cout &lt;&lt; "Turn blinking off for 5s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 5 ); std::cout &lt;&lt; "Turn blinking on for 5s" &lt;&lt; std::endl; so_5::send&lt; blinking_led::turn_on_off &gt;( m ); pause( 5 ); std::cout &lt;&lt; "Stopping..." &lt;&lt; std::endl; env.stop(); } ); } catch( const std::exception &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre> <br><h2 id="timers-overload-control-for-an-agent-and-active_obj-dispatcher">  Temporizadores, control de sobrecarga para un agente y despachador active_obj </h2><br><p>  El control de sobrecarga es uno de los principales problemas para los actores: las colas de mensajes para los actores suelen ser ilimitadas y esto puede conducir a un crecimiento descontrolado de las colas si un productor de mensajes r谩pidos env铆a mensajes m谩s r谩pido de lo que el receptor puede manejarlos.  El siguiente ejemplo muestra la caracter铆stica de SObjectizer como <em>l铆mites de mensajes</em> .  Permite limitar el recuento de mensajes en la cola del agente y defender al receptor de mensajes redundantes. </p><br><p>  Este ejemplo tambi茅n muestra el uso del temporizador en forma de mensaje peri贸dico.  El enlace de los agentes al despachador active_obj tambi茅n se muestra all铆.  La vinculaci贸n a ese despachador significa que cada agente de la cooperativa trabajar谩 en su propio subproceso de trabajo (por ejemplo, un agente se convierte en un objeto activo). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; using namespace std::chrono_literals; // Message to be sent to the consumer. struct task { int task_id_; }; // An agent for utilization of unhandled tasks. class trash_can final : public so_5::agent_t { public: // There is no need is a separate constructor. using so_5::agent_t::agent_t; // Preparation of agent to work inside SObjectizer. void so_define_agent() override { // Subscription to 'task' message. // Event-handler is specified in the form of a lambda-function. so_subscribe_self().event([](mhood_t&lt;task&gt; cmd) { std::cout &lt;&lt; "unhandled task: " &lt;&lt; cmd-&gt;task_id_ &lt;&lt; std::endl; }); } }; // The consumer of 'task' messages. class consumer final : public so_5::agent_t { public: // We need the constructor. consumer(context_t ctx, so_5::mbox_t trash_mbox) : so_5::agent_t{ctx + // Only three 'task' messages can wait in the queue. limit_then_redirect&lt;task&gt;(3, // All other messages will go to that mbox. [trash_mbox]{ return trash_mbox; })} { // Define a reaction to incoming 'task' message. so_subscribe_self().event([](mhood_t&lt;task&gt; cmd) { std::cout &lt;&lt; "handling task: " &lt;&lt; cmd-&gt;task_id_ &lt;&lt; std::endl; std::this_thread::sleep_for(75ms); }); } }; // The producer of 'test' messages. class producer final : public so_5::agent_t { const so_5::mbox_t dest_; so_5::timer_id_t task_timer_; int id_counter_{}; // Type of periodic signal to produce new 'test' message. struct generate_next final : public so_5::signal_t {}; void on_next(mhood_t&lt;generate_next&gt;) { // Produce a new 'task' message. so_5::send&lt;task&gt;(dest_, id_counter_); ++id_counter_; // Should the work be stopped? if(id_counter_ &gt;= 10) so_deregister_agent_coop_normally(); } public: producer(context_t ctx, so_5::mbox_t dest) : so_5::agent_t{std::move(ctx)} , dest_{std::move(dest)} {} void so_define_agent() override { so_subscribe_self().event(&amp;producer::on_next); } // This method will be automatically called by SObjectizer // when agent starts its work inside SObjectizer Environment. void so_evt_start() override { // Initiate a periodic message with no initial delay // and repetition every 25ms. task_timer_ = so_5::send_periodic&lt;generate_next&gt;(*this, 0ms, 25ms); } }; int main() { // Run SObjectizer instance. so_5::launch([](so_5::environment_t &amp; env) { // Make and register coop with agents. // All agents will be bound to active_obj dispatcher and will // work on separate threads. env.introduce_coop( so_5::disp::active_obj::make_dispatcher(env).binder(), [](so_5::coop_t &amp; coop) { auto * trash = coop.make_agent&lt;trash_can&gt;(); auto * handler = coop.make_agent&lt;consumer&gt;(trash-&gt;so_direct_mbox()); coop.make_agent&lt;producer&gt;(handler-&gt;so_direct_mbox()); }); }); }</span></span></span></span></code> </pre> <br><p>  Si ejecutamos ese ejemplo, podemos ver el siguiente resultado: </p><br><pre> <code class="plaintext hljs">handling task: 0 handling task: 1 unhandled task: 5 unhandled task: 6 handling task: 2 unhandled task: 8 unhandled task: 9 handling task: 3 handling task: 4 handling task: 7</code> </pre> <br><p>  Este resultado muestra que varios mensajes que no pueden encajar en el l铆mite definido son rechazados y redirigidos a otro receptor. </p><br><h2 id="more-examples">  M谩s ejemplos </h2><br><p>  Un ejemplo m谩s o menos similar al c贸digo de las aplicaciones de la vida real se puede encontrar en nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">proyecto de demostraci贸n de Shrimp</a> .  Se puede encontrar otro conjunto de ejemplos interesantes en esta mini serie sobre el cl谩sico "problema de los fil贸sofos gastron贸micos": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">parte 1</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">parte 2</a> .  Y, por supuesto, hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">muchos ejemplos en SObjectizer</a> . </p><br><h1 id="what-about-the-performance">  驴Qu茅 pasa con el rendimiento? </h1><br><p>  Hay una respuesta muy simple: es m谩s que suficiente para nosotros.  SObjectizer puede distribuir millones de mensajes por segundo, y la velocidad real depende de los tipos de despachadores utilizados, tipos de mensajes, perfil de carga, hardware / SO / compilador utilizado, etc.  En una aplicaci贸n real, usualmente usamos solo una fracci贸n de la velocidad de SObjectizer. </p><br><p>  El rendimiento de SObjectizer para su tarea particular depende en gran medida de su tarea, la soluci贸n particular de esa tarea, de su hardware o entorno virtual, de la versi贸n de su compilador y su sistema operativo.  Entonces, la mejor manera de encontrar una respuesta a esa pregunta es crear un punto de referencia propio que sea espec铆fico para su tarea y experimentar con ella. </p><br><p>  Si desea n煤meros de algunos puntos de referencia sint茅ticos, entonces hay algunos programas en la carpeta test / so_5 / bench de distribuci贸n SObjectizer. </p><br><h2 id="a-note-about-comparison-with-different-tools">  Una nota sobre la comparaci贸n con diferentes herramientas. </h2><br><p>  Creemos que un juego de evaluaci贸n comparativa que compara la velocidad de diferentes herramientas es un juego de marketing.  Intentamos en el pasado, pero r谩pidamente nos dimos cuenta de que es solo una p茅rdida de tiempo.  Entonces no jugamos ese juego ahora.  Gastamos nuestro tiempo y nuestros recursos solo en puntos de referencia que nos permiten verificar la ausencia de degradaci贸n del rendimiento, para resolver algunos casos esquimales (como el rendimiento de mboxes de MPMC con gran cantidad de suscriptores o el rendimiento de un agente con cientos de miles de suscripciones), acelerar algunas operaciones espec铆ficas de SObjectizer (como el registro / desregistro de una cooperativa). </p><br><p>  As铆 que dejamos la comparaci贸n de velocidad a aquellos a quienes les gusta ese juego y tienen tiempo para jugarlo. </p><br><h1 id="why-sobjectizer-does-look-exactly-as-it-is">  驴Por qu茅 SObjectizer se ve exactamente como es? </h1><br><p>  Hay varios "marcos de actores" para C ++, y todos se ven diferentes.  Parece que tiene algunas razones objetivas: cada marco tiene sus caracter铆sticas 煤nicas y objetivos diferentes.  Adem谩s, los actores en C ++ pueden implementarse de manera muy diferente.  Entonces, la pregunta principal no es "驴por qu茅 el marco X no se parece al marco Y?", Sino "驴por qu茅 el marco X se ve como es?" </p><br><p>  Ahora intentaremos describir algunas razones detr谩s de las caracter铆sticas principales del SObjectizer brevemente.  Esperamos que permita una mejor comprensi贸n de las habilidades de SObjectizer.  Pero antes de comenzar, es necesario mencionar una cosa muy importante: SObjectizer nunca ha sido un experimento.  Fue creado para resolver el trabajo en la vida real y ha ido evolucionando en funci贸n de la experiencia de la vida real. </p><br><h2 id="agents-are-objects-of-classes-derived-from-agent_t">  Los agentes son objetos de clases derivadas de agent_t </h2><br><p>  Los agentes (tambi茅n conocidos como actores) en SObjectzer son objetos de clases definidas por el usuario que deben derivarse de una clase especial <code>agent_t</code> .  Puede parecer redundante en peque帽os ejemplos de juguetes, pero nuestra experiencia muestra que el enfoque simplifica enormemente el desarrollo de software real donde los agentes generalmente tienen el tama帽o en varios cientos de l铆neas (puede ver uno de los ejemplos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">aqu铆</a> , pero esta publicaci贸n de blog est谩 en Ruso).  A veces incluso en varios miles de l铆neas. </p><br><p>  La experiencia nos muestra que un agente simple con la primera versi贸n en cien l铆neas se vuelve mucho m谩s gordo y complejo en varios a帽os de evoluci贸n.  Entonces, despu茅s de cinco a帽os, puedes encontrar un monstruo en mil l铆neas con docenas de m茅todos. </p><br><p>  El uso de clases nos permite gestionar la complejidad de los agentes.  Podemos usar la herencia de clases.  Y tambi茅n podemos usar clases de plantilla.  Estas son t茅cnicas muy 煤tiles que simplifican enormemente el desarrollo de familias de agentes con una l贸gica similar en su interior. </p><br><h2 id="messages-as-objects-of-user-structsclasses">  Mensajes como objetos de estructuras / clases de usuario </h2><br><p>  Los mensajes en SObjectizer son objetos de estructuras o clases definidas por el usuario.  Hay al menos dos razones para eso: </p><br><ul><li>  El desarrollo de SObjectizer-5 comenz贸 en 2010 cuando C ++ 11 a煤n no estaba estandarizado.  Entonces, al principio, no pod铆amos usar caracter铆sticas de C ++ 11 como plantillas variadas y clase <code>std::tuple</code> .  La 煤nica opci贸n que ten铆amos era el uso de un objeto de una clase heredada de una clase especial <code>message_t</code> .  Ahora no es necesario derivar el tipo de mensaje de <code>message_t</code> , pero SObjectizer envuelve un objeto de usuario en <code>message_t</code> -derived object de todos modos bajo el cap贸; </li><li>  El contenido de un mensaje se puede cambiar f谩cilmente sin modificar las firmas de los controladores de eventos.  Y hay un control desde un compilador: si elimina alg煤n campo de un mensaje o cambia su tipo, el compilador le informar谩 sobre el acceso incorrecto a ese campo. </li></ul><br><p>  El uso de mensajes como objetos tambi茅n permite trabajar con mensajes preasignados y almacenar un mensaje recibido en alg煤n contenedor y reenviarlo m谩s tarde. </p><br><h2 id="coops-of-agents">  Cooperativas de agentes </h2><br><p>  Una cooperativa de agentes es probablemente una de las caracter铆sticas 煤nicas de SObjectizer.  Una cooperativa es un grupo de agentes que deben agregarse y eliminarse de SObjectizer de manera transaccional.  Significa que si una cooperativa contiene tres agentes, entonces todos esos agentes deben agregarse a SObjectizer con 茅xito o ninguno de ellos debe agregarse.  Del mismo modo, los tres agentes deben eliminarse de SObjectizer o los tres agentes deben continuar su trabajo. </p><br><p>  La necesidad en las cooperativas se descubri贸 poco despu茅s del comienzo de la vida de SObjectizer.  Se hizo evidente que los agentes ser铆an creados por grupos, no por instancias 煤nicas.  Las cooperativas se inventaron para simplificar la vida de un desarrollador: no es necesario controlar la creaci贸n del siguiente agente y eliminar agentes creados previamente si falla la creaci贸n de un nuevo agente. </p><br><p>  Una cooperativa tambi茅n se puede ver como un supervisor en el modo todo en uno: si un agente de la cooperativa falla, entonces se eliminar谩 toda la cooperativa del entorno SObjectizer y se destruir谩 (un usuario puede reaccionar a eso y volver a crear la cooperativa). </p><br><h2 id="message-boxes">  Cuadros de mensaje </h2><br><p>  Los cuadros de mensaje son otra caracter铆stica 煤nica de SObjectizer.  Los mensajes en SObjectizer se env铆an a un cuadro de mensaje (mbox), no a un agente directamente.  Puede haber un receptor detr谩s del mbox, o puede haber un mill贸n de suscriptores, o no puede haber nadie. </p><br><p>  Mboxes nos permite admitir la funcionalidad b谩sica del modelo Publicar-Suscribir.  Un mbox puede verse como MQ-broker y el tipo de mensaje puede verse como un tema. </p><br><p>  Mboxes tambi茅n nos permite implementar varias formas interesantes de entrega de mensajes.  Por ejemplo, hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">mbox round-robin</a> que difunde mensajes entre suscriptores de manera round-robin.  Tambi茅n hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">mbox retenido</a> que contiene el 煤ltimo mensaje enviado y lo reenv铆a autom谩ticamente para cada nuevo suscriptor.  Tambi茅n hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">contenedor simple alrededor de libmosquitto</a> que permite usar MQTT como transporte para una aplicaci贸n distribuida. </p><br><h2 id="agents-as-hsm">  Agentes como HSM </h2><br><p>  Los agentes en SObjectizer son m谩quinas de estado.  Fue desde el principio simplemente porque SObjectizer tiene ra铆ces en el campo SCADA, donde las m谩quinas de estado se usan activamente.  Pero r谩pidamente se hizo evidente que los agentes en forma de m谩quina de estado pueden ser 煤tiles incluso en diferentes nichos (como aplicaciones de telecomunicaciones y finanzas). </p><br><p>  Se agreg贸 compatibilidad con m谩quinas de estados jer谩rquicos (por ejemplo, controladores on_enter / on_exit, estados anidados, l铆mites de tiempo, etc.) despu茅s de alg煤n tiempo de usar SObjectizer en producci贸n.  Y esta caracter铆stica convirti贸 a SObjectizer en una herramienta a煤n m谩s potente y conveniente. </p><br><h2 id="usage-of-c-exceptions">  Uso de excepciones de C ++ </h2><br><p>  Las excepciones de C ++ se utilizan en SObjectizer como el principal mecanismo de informe de errores.  A pesar de que el uso de la excepci贸n C ++ a veces puede ser costoso, decidimos usar excepciones en lugar de c贸digos de error. </p><br><p>  Tuvimos una experiencia negativa con los c贸digos de error en SObjectizer-4, donde no se utilizaron excepciones.  Esto condujo a la ignorancia de errores en el c贸digo de la aplicaci贸n y, a veces, no se realizaron acciones importantes porque hubo un error al crear una nueva cooperativa o al enviar un mensaje.  Pero este error fue ignorado y ese hecho fue descubierto mucho m谩s tarde. </p><br><p>  El uso de excepciones de C ++ en SObjectizer-5 permite escribir c贸digo m谩s correcto y robusto.  En casos habituales, SObjectizer genera excepciones muy raramente, por lo que el uso de la excepci贸n no tiene un impacto negativo en el rendimiento de SObjectizer o el rendimiento de las aplicaciones escritas sobre SObjectizer. </p><br><h2 id="no-support-for-distributed-applications-out-of-box">  No hay soporte para aplicaciones distribuidas "fuera de la caja" </h2><br><p>  SObjectzer-5 no tiene soporte incorporado para aplicaciones distribuidas.  Significa que SObjectizer distribuye mensajes solo dentro de un proceso.  Si necesita organizar la distribuci贸n de mensajes entre procesos o entre notas, debe integrar alg煤n tipo de IPC en su aplicaci贸n. </p><br><p>  Esto no se debe a que no podemos implementar alguna forma de IPC en SObjectizer.  Ya lo ten铆amos en SObjectizer-4.  Y debido a que tenemos esa experiencia, decidimos no hacerlo en SObjectizer-5.  Aprendimos que no hay un tipo de IPC que se ajuste perfectamente a diferentes condiciones. </p><br><p>  Si desea tener una buena comunicaci贸n entre nodos en su aplicaci贸n, debe seleccionar los protocolos subyacentes apropiados.  Por ejemplo, si tiene que distribuir millones de paquetes peque帽os con algunos datos de corta duraci贸n (como la distribuci贸n de la medici贸n de las condiciones clim谩ticas actuales), entonces debe usar un IPC.  Pero si tiene que transferir enormes BLOB (como transmisiones de video 4K / 8K o archivos con datos financieros dentro), entonces debe usar otro tipo de IPC. </p><br><p>  Y no hablamos de introperabilidad con software escrito en diferentes idiomas ... </p><br><p>  Puede creer que un "marco de actores" universal puede proporcionarle un IPC que ser谩 bueno para diferentes condiciones.  Pero sabemos que es solo una mierda de marketing.  Nuestra experiencia nos muestra que es mucho m谩s simple y seguro agregar el IPC que necesita en su aplicaci贸n que confiar en las ideas, necesidades y conocimiento de los autores de un "marco de actores" de terceros. </p><br><p>  SObjectizer permite incorporar varios tipos de IPC en forma de mboxes personalizados.  Por lo tanto, permite ocultar el hecho de la distribuci贸n de mensajes a trav茅s de una red de los usuarios de SObjectizer. </p><br><h1 id="instead-of-the-conclusion">  En lugar de la conclusi贸n </h1><br><p>  El marco SObjectizer no es grande, pero no es peque帽o.  Por lo tanto, es imposible dar al lector una impresi贸n bastante profunda sobre SObjectizer en una sola descripci贸n general.  Por eso, te invitamos a echar un vistazo al proyecto SObjectizer. </p><br><p>  SObjectizer s铆 mismo vive en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">GitHub</a> .  Existe el Wiki del proyecto en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">GitHub</a> y recomendamos comenzar desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">SObjectizer 5.6 Basics</a> y luego ir a art铆culos de series en profundidad.  Para aquellos que quieran profundizar, podemos recomendar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Veamos debajo de la secci贸n del cap贸 de SObjectizer</a> . </p><br><p>  Si tiene alguna pregunta, puede preguntarnos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">el grupo de SObjectizer</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">los grupos</a> de Google. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458202/">https://habr.com/ru/post/458202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458176/index.html">La barrera de exaflops se superar谩 en 2021</a></li>
<li><a href="../458180/index.html">Servidor DHCP de conmutaci贸n por error basado en Kea</a></li>
<li><a href="../458182/index.html">Leemos VKontakte a trav茅s de RSS</a></li>
<li><a href="../458188/index.html">Como hice una red social en 2019</a></li>
<li><a href="../458190/index.html">Ya veo, significa que existo: revisi贸n de Deep Learning en Computer Vision (parte 2)</a></li>
<li><a href="../458204/index.html">C贸mo evaluar el rendimiento del almacenamiento en Linux: evaluaci贸n comparativa utilizando herramientas abiertas</a></li>
<li><a href="../458218/index.html">驴Cirug铆a maxilofacial o no? Esa es la pregunta</a></li>
<li><a href="../458220/index.html">El resumen de materiales interesantes para el desarrollador m贸vil # 304 (del 24 al 30 de junio)</a></li>
<li><a href="../458222/index.html">Romper un juego de memoria: toda una historia de detectives</a></li>
<li><a href="../458224/index.html">El software para el Boeing-737 Max fue escrito por subcontratistas que ganan $ 9 por hora</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>