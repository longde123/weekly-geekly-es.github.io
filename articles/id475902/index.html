<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµüèΩ üìó üéí Workflow Core - mesin proses bisnis untuk .Net Core üåò ‚öîÔ∏è üßëüèΩ‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 


 Kami memutuskan untuk mendukung tema migrasi proyek menggunakan Windows Workflow Foundation ke .Net Core , yang dimulai oleh rekan-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Workflow Core - mesin proses bisnis untuk .Net Core</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avanpost/blog/475902/"><p><img src="https://habrastorage.org/webt/hp/ll/of/hpllof4hjsvcpfxbkl_q-epwfew.jpeg" alt="gambar"></p><br><p>  Halo semuanya! </p><br><p>  Kami memutuskan untuk mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tema migrasi proyek menggunakan Windows Workflow Foundation ke .Net Core</a> , yang dimulai oleh rekan-rekan dari DIRECTUM, karena kami menghadapi masalah serupa beberapa tahun yang lalu dan berjalan dengan cara kami sendiri. </p><a name="habracut"></a><br><h2>  Mari kita mulai dengan ceritanya </h2><br><p>  Produk unggulan kami, Avanpost IDM, adalah siklus hidup akun dan sistem manajemen akses karyawan.  Dia tahu cara mengelola akses baik secara otomatis berdasarkan model peran, dan sesuai permintaan.  Pada awal pembentukan produk, kami memiliki sistem swalayan yang cukup sederhana dengan alur kerja langkah demi langkah yang sederhana, yang pada prinsipnya mesin tidak diperlukan. </p><br><p><img src="https://habrastorage.org/webt/hl/uo/c1/hluoc1imf_ejbdyzynpumdefmaa.png" alt="gambar"></p><br><p>  Namun, ketika berhadapan dengan klien besar, kami menyadari bahwa alat yang jauh lebih fleksibel diperlukan, karena persyaratan mereka untuk proses koordinasi hak akses mencari aturan alur kerja yang baik.  Setelah menganalisis persyaratan, kami memutuskan untuk mengembangkan editor proses kami sendiri dalam format BPMN, sesuai untuk kebutuhan kami.  Kami akan berbicara tentang pengembangan editor menggunakan React.js + SVG sedikit kemudian, dan hari ini kita akan membahas topik backend - <strong>mesin alur kerja</strong> atau mesin proses bisnis. </p><br><h2>  Persyaratan </h2><br><p>  Pada awal pengembangan sistem, kami memiliki persyaratan berikut untuk mesin: </p><br><ul><li>  Dukungan untuk diagram proses, format yang dapat dimengerti, kemampuan untuk menyiarkan dari format kami ke format mesin </li><li>  Penyimpanan status proses </li><li>  Mendukung Proses Pembuatan Versi </li><li>  Dukungan untuk eksekusi paralel (cabang) dari proses </li><li>  Lisensi yang sesuai untuk menggunakan solusi dalam produk komersial yang direplikasi </li><li>  Dukungan untuk penskalaan horizontal </li></ul><br><p>  Setelah menganalisis pasar (untuk 2014), kami menetapkan solusi yang hampir tidak alternatif untuk .Net: Windows Workflow Foundation. </p><br><h2>  Windows Workflow Foundation (WWF) </h2><br><p>  WWF adalah teknologi Microsoft untuk mendefinisikan, mengeksekusi, dan mengelola alur kerja. </p><br><p>  Dasar dari logikanya adalah seperangkat wadah untuk tindakan (kegiatan) dan kemampuan untuk membangun proses berurutan dari wadah ini.  Wadah mungkin biasa - langkah tertentu dalam proses di mana aktivitas dilakukan.  Ini bisa menjadi manajer - berisi logika percabangan. </p><br><p>  Anda dapat menggambar proses secara langsung di Visual Studio.  Diagram proses bisnis yang dikompilasi disimpan dalam Haml, yang sangat nyaman - formatnya dijelaskan, adalah mungkin untuk membuat perancang proses yang ditulis sendiri.  Ini di satu sisi.  Di sisi lain, Xaml bukan format yang paling nyaman untuk menyimpan deskripsi - skema yang dikompilasi untuk proses nyata lebih atau kurang ternyata sangat besar, paling tidak karena redundansi.  Sangat sulit untuk dipahami, tetapi Anda harus memahaminya. </p><br><p>  Tetapi jika, cepat atau lambat, seseorang dapat memahami zen dengan skema dan belajar membacanya, maka kurangnya transparansi dalam pengoperasian mesin itu sendiri menambah kerumitan saat pengguna menggunakan sistem.  Ketika kesalahan berasal dari usus Wf, tidak selalu mungkin untuk mengetahui 100% apa sebenarnya alasan kegagalan tersebut.  Sumber tertutup dan monstrositas relatif tidak membantu kasus ini.  Seringkali perbaikan bug disebabkan oleh gejala. </p><br><p> Dalam keadilan, perlu diperjelas di sini bahwa masalah yang dijelaskan di atas, sebagian besar, telah mengganggu kami karena kustomisasi yang kuat atas Wf.  Salah satu pembaca akan mengatakan dengan pasti bahwa kita sendiri menciptakan banyak masalah, dan kemudian menyelesaikannya dengan heroik.  Itu perlu untuk membuat mesin buatan sendiri sejak awal.  Secara umum, mereka akan benar. </p><br><p>  Pada intinya, solusinya bekerja cukup stabil dan berhasil masuk ke produksi.  Tetapi transisi dari produk kami ke .Net Core memaksa kami untuk meninggalkan WWF dan mencari mesin proses bisnis lainnya, karena  Pada Mei 2019, Windows Workflow Foundation belum dimigrasi ke .Net Core.  Saat kami sedang mencari mesin baru - topik dari artikel yang terpisah, tetapi pada akhirnya kami memilih Workflow Core. </p><br><h2>  Inti alur kerja </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Workflow Core</a> adalah mesin proses bisnis gratis.  Ini dikembangkan di bawah lisensi MIT, yaitu dapat digunakan dengan aman dalam pengembangan komersial. </p><br><p>  Ini dilakukan secara aktif oleh satu orang, beberapa orang lagi secara berkala melakukan permintaan penarikan.  Ada port untuk bahasa lain (Java, Python, dan beberapa lainnya). </p><br><p>  Mesin diposisikan sebagai ringan.  Faktanya, ini hanya sebuah host untuk eksekusi tindakan berurutan yang dikelompokkan berdasarkan aturan bisnis apa pun. </p><br><p>  Proyek ini memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi wiki</a> .  Sayangnya, itu tidak menggambarkan semua fitur mesin.  Namun, akan kurang bijaksana untuk memerlukan dokumentasi lengkap - proyek opensource didukung oleh satu penggemar.  Oleh karena itu, Wiki akan cukup untuk memulai. </p><br><p>  Di luar kotak ada dukungan untuk menyimpan status proses dalam penyimpanan eksternal (penyimpanan persistensi).  Penyedia adalah standar untuk: </p><br><ul><li>  Mongodb </li><li>  SQL Server </li><li>  PostgreSQL </li><li>  Sqlite </li><li>  Amazon DynamoDB </li></ul><br><p>  Tulis penyedia Anda tidak masalah.  Kami mengambil sumber dari standar apa pun dan melakukan sebagai contoh. </p><br><p>  Penskalaan horizontal didukung, yaitu, Anda dapat menjalankan mesin pada beberapa node sekaligus, sekaligus memiliki satu titik penyimpanan status proses (satu penyimpanan persistensi).  Dalam hal ini, penempatan antrian tugas internal mesin harus dalam penyimpanan umum (rabbitMQ, sebagai opsi).  Untuk mengecualikan pelaksanaan satu tugas oleh beberapa node, manajer kunci disediakan pada saat yang sama.  Dengan analogi dengan penyedia penyimpanan eksternal, ada implementasi standar: </p><br><ul><li>  Sewa penyimpanan Azure </li><li>  Redis </li><li>  AWS DynamoDB </li><li>  SQLServer (di sumbernya ada, tapi tidak ada yang dikatakan dalam dokumentasi) </li></ul><br><p>  Mengenal sesuatu yang baru adalah yang paling mudah untuk memulai dengan sebuah contoh.  Jadi mari kita lakukan.  Saya akan menjelaskan konstruksi proses sederhana dari awal, bersama dengan penjelasannya.  Sebuah contoh mungkin tampak sangat sederhana.  Saya setuju - itu sederhana.  Yang paling awal. </p><br><p>  Ayo pergi. </p><br><h4>  Langkah </h4><br><p>  Langkah adalah langkah dalam proses di mana tindakan dilakukan.  Seluruh proses dibangun dari urutan langkah-langkah.  Satu langkah dapat melakukan banyak tindakan, dapat diulangi, misalnya untuk beberapa acara dari luar.  Ada serangkaian langkah yang diberkahi dengan logika "di luar kotak": </p><br><ul><li>  Menunggu </li><li>  Jika </li><li>  Sementara </li><li>  Foreach </li><li>  Tunda </li><li>  Paralel </li><li>  Jadwalkan </li><li>  Berulang </li></ul><br><p>  Tentu saja, pada beberapa primitif bawaan Anda tidak tahan proses.  Kami membutuhkan langkah-langkah yang menyelesaikan tugas bisnis.  Karena itu, untuk saat ini, kesampingkan mereka dan ambil langkah dengan logika kita sendiri.  Untuk melakukan ini, Anda harus mewarisi dari abstraksi <strong>StepBody</strong> . </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StepBody</span></span> : <span class="hljs-title"><span class="hljs-title">IStepBody</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> ExecutionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStepExecutionContext context</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><p>  Metode <strong>Run</strong> dijalankan ketika proses memasuki langkah.  Adalah perlu untuk menempatkan logika yang diperlukan ke dalamnya. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StepBody</span></span> : <span class="hljs-title"><span class="hljs-title">IStepBody</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> ExecutionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStepExecutionContext context</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><p>  Langkah-langkah ini mendukung injeksi ketergantungan.  Untuk melakukan ini, cukup mendaftarkannya dalam wadah yang sama dengan dependensi yang diperlukan. </p><br><p>  Jelas, proses membutuhkan konteksnya sendiri - tempat di mana hasil antara eksekusi dapat ditambahkan.  Inti Wf memiliki konteksnya sendiri untuk pelaksanaan suatu proses yang menyimpan informasi tentang keadaan saat ini.  Anda dapat mengaksesnya menggunakan variabel <strong>konteks</strong> dari metode <strong>Run</strong> ().  Selain built-in, kita dapat menggunakan konteks kita. </p><br><p>  Kami akan menganalisis cara menggambarkan dan mendaftarkan proses secara lebih rinci di bawah ini, untuk saat ini, kami hanya mendefinisikan kelas tertentu - konteksnya. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ProcessContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Number1 {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Number2 {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> StepResult {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Number1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; Number2 = <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br><p>  Dalam <strong>Number</strong> variabel kita menulis angka;  ke dalam variabel <strong>StepResult</strong> - hasil dari langkah tersebut. </p><br><p>  Kami memutuskan konteksnya.  Anda dapat menulis langkah Anda sendiri: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomStep</span></span> : <span class="hljs-title"><span class="hljs-title">StepBody</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Ilogger _log; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Input1 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Input2 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Action { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Result { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomStep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ilogger log</span></span></span><span class="hljs-function">)</span></span> { _log = log; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> ExecutionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStepExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { Result = ‚Äùnone‚Äù; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Action ==‚Äùsum‚Äù) { Result = Number1 + Number2; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Action ==‚Äùdif‚Äù){ Result = Number1 - Number2; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExecutionResult.Next(); } }</code> </pre> <br><p>  Logikanya sangat sederhana: dua angka dan nama operasi sampai pada input.  Hasil operasi ditulis ke <strong>Hasil</strong> variabel output.  Jika operasi tidak ditentukan, hasilnya <em>tidak</em> akan <em>ada</em> . </p><br><p>  Kami memutuskan pada konteksnya, ada langkah dengan logika yang kami butuhkan juga.  Sekarang kita perlu mendaftarkan proses kita di mesin. </p><br><h4>  Deskripsi proses.  Registrasi di mesin. </h4><br><p>  Ada dua cara untuk menggambarkan suatu proses.  Yang pertama adalah deskripsi dalam kode - hardcode. </p><br><p>  Prosesnya dijelaskan melalui <strong>antarmuka yang lancar</strong> .  Hal ini diperlukan untuk mewarisi dari antarmuka <strong>IWorkflow &lt;T&gt; yang</strong> digeneralisasi, di mana T adalah kelas konteks model.  Dalam kasus kami, ini adalah <strong>ProcessContext</strong> . </p><br><p>  Ini terlihat seperti ini: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleWorkflow</span></span> : <span class="hljs-title"><span class="hljs-title">IWorkflow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ProcessContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IWorkflowBuilder&lt;ProcessContext&gt; builder</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    } public string Id =&gt; "SomeWorkflow"; public int Version =&gt; 1; }</span></span></code> </pre> <br><p>  Deskripsi itu sendiri akan berada di dalam metode <strong>Build</strong> .  Kolom <strong>Id</strong> dan <strong>Versi</strong> juga diperlukan.  Jika inti mendukung proses versi - Anda dapat mendaftarkan dan versi proses dengan pengidentifikasi yang sama.  Ini nyaman ketika Anda perlu memperbarui proses yang ada dan pada saat yang sama memberikan "hidup" untuk tugas yang ada. </p><br><p>  Kami menggambarkan proses sederhana: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleWorkflow</span></span> : <span class="hljs-title"><span class="hljs-title">IWorkflow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ProcessContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IWorkflowBuilder&lt;ProcessContext&gt; builder</span></span></span><span class="hljs-function">)</span></span> { builder.StartWith&lt;CustomStep&gt;() .Input(step =&gt; step.Input1, data =&gt; data.Number1) .Input(step =&gt; step.Input2, data =&gt; data.Number2) .Input(step =&gt; step.Action, data =&gt; ‚Äúsum‚Äù) .Output(data =&gt; data.StepResult, step =&gt; step.Result) .EndWorkflow(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Id =&gt; <span class="hljs-string"><span class="hljs-string">"SomeWorkflow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Version =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  Jika diterjemahkan ke bahasa "manusia", itu akan berubah menjadi seperti ini: proses dimulai dengan langkah <strong>CustomStep</strong> .  Nilai bidang pitch <strong>Input1</strong> diambil dari bidang konteks <strong>Number1</strong> , Nilai bidang lapangan <strong>Input2</strong> diambil dari bidang konteks <strong>Number2</strong> , bidang <strong>tindakan</strong> secara kaku ditunjukkan dengan nilai <strong>"jumlah"</strong> .  Output dari bidang <strong>Hasil</strong> ditulis ke <strong>bidang</strong> konteks <strong>StepResult</strong> .  Selesaikan prosesnya. </p><br><p>  Setuju, kode itu ternyata sangat mudah dibaca, sangat mungkin untuk mengetahuinya bahkan tanpa pengetahuan khusus dalam C #. </p><br><p>  Tambahkan satu langkah lagi ke proses kami, yang akan menampilkan hasil dari langkah sebelumnya ke log: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomStep</span></span> : <span class="hljs-title"><span class="hljs-title">StepBody</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Ilogger _log; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TextToOutput { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomStep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ilogger log</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    _log = log; } public override ExecutionResult Run(IStepExecutionContext context) { _log.Debug(TextToOutput); return ExecutionResult.Next(); } }</span></span></code> </pre> <br><p>  Dan perbarui proses: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleWorkflow</span></span> : <span class="hljs-title"><span class="hljs-title">IWorkflow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ProcessContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IWorkflowBuilder&lt;ProcessContext&gt; builder</span></span></span><span class="hljs-function">)</span></span> { builder.StartWith&lt;CustomStep&gt;() .Input(step =&gt; step.Input1, data =&gt; data.Number1) .Input(step =&gt; step.Input2, data =&gt; data.Number2) .Input(step =&gt; step.Action, data =&gt; ‚Äúsum‚Äù) .Output(data =&gt; data.StepResult, step =&gt; step.Result) .Then&lt;OutputStep&gt;.Input(step =&gt; step.TextToOutput, data =&gt; data.StepResult) .EndWorkflow(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Id =&gt; <span class="hljs-string"><span class="hljs-string">"SomeWorkflow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Version =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><p>  Sekarang, setelah langkah dengan operasi penjumlahan, langkah mengeluarkan hasil ke log berikut.  Untuk input, kami meneruskan variabel <strong>Hasil</strong> dan konteks ke mana hasil eksekusi ditulis pada langkah terakhir.  Saya akan mengambil kebebasan menyatakan bahwa deskripsi seperti itu melalui kode (hardcode) dalam sistem nyata akan sedikit berguna.  Kecuali untuk beberapa proses kantor.  Jauh lebih menarik untuk dapat menyimpan sirkuit secara terpisah.  Minimal, kami tidak perlu memasang kembali proyek setiap kali kami perlu mengubah sesuatu dalam proses atau menambahkan yang baru.  Wf core menyediakan fitur ini dengan menyimpan skema json.  Kami terus memperluas contoh kami. </p><br><h4>  Deskripsi proses Json </h4><br><p>  <i>Lebih lanjut saya tidak akan memberikan deskripsi melalui kode.</i>  <i>Ini tidak terlalu menarik, dan hanya akan mengembang artikel.</i> </p><br><p>  Wf core mendukung deskripsi skema di json.  Menurut pendapat saya, json lebih visual daripada xaml (topik yang bagus untuk holivar di komentar :)).  Struktur file sangat sederhana: </p><br><pre> <code class="plaintext hljs">{ "Id": "SomeWorkflow", "Version": 1, "DataType": "App.ProcessContext, App", "Steps": [ { /*step1*/ }, { /*step2*/ } ] }</code> </pre> <br><p>  Bidang <strong>DataType</strong> menunjukkan nama kelas konteks yang sepenuhnya memenuhi syarat dan nama majelis yang dijelaskan.  <strong>Langkah</strong> menyimpan koleksi semua langkah dalam proses.  Isi elemen <strong>Langkah</strong> : </p><br><pre> <code class="plaintext hljs">{ "Id": "SomeWorkflow", "Version": 1, "DataType": "App.ProcessContext, App", "Steps": [ { "Id": "Eval", "StepType": "App.CustomStep, App", "NextStepId": "Output", "Inputs": { "Input1": "data.Number1", "Input2": "data.Number2" }, "Outputs": { "StepResult": "step.Result" } }, { "Id": "Output", "StepType": "App.OutputStep, App", "Inputs": { "TextToOutput": "data.StepResult" } } ] }</code> </pre> <br><p>  Mari kita lihat lebih dekat struktur deskripsi langkah via json. </p><br><p>  Bidang <strong>Id</strong> dan <strong>NextStepId</strong> menyimpan pengidentifikasi langkah ini dan indikator langkah mana yang mungkin berikutnya.  Apalagi urutan elemen-elemen koleksi tidak penting. </p><br><p>  <strong>StepType</strong> mirip dengan bidang <strong>DataType</strong> , ini berisi nama lengkap kelas step (tipe yang mewarisi dari <strong>StepBody</strong> dan mengimplementasikan logika langkah) dan nama majelis.  Lebih menarik adalah objek <strong>Input</strong> dan <strong>Output</strong> .  Mereka diatur dalam bentuk pemetaan. </p><br><p>  Dalam hal <strong>Input,</strong> nama elemen json adalah nama bidang kelas dari langkah kami;  nilai elemen adalah nama bidang di kelas, konteks proses. </p><br><p>  Untuk <strong>Output,</strong> sebaliknya, nama elemen json adalah nama bidang dalam kelas, konteks proses;  nilai elemen adalah nama bidang kelas dari langkah kami. </p><br><p>  Mengapa bidang konteks ditentukan melalui <em>data. {Field_name}</em> , dan dalam hal <strong>Output</strong> , <em>langkah. {Field_name}</em> ?  Karena wf inti, nilai elemen dieksekusi sebagai ekspresi C # ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dynamic Expressions library</a> digunakan).  Ini adalah hal yang agak berguna, dengan bantuannya Anda dapat meletakkan beberapa logika bisnis langsung di dalam skema, jika, tentu saja, arsitek menyetujui aib seperti itu :). </p><br><p>  Kami mendiversifikasi skema dengan primitif standar.  Tambahkan langkah kondisional <strong>If</strong> dan proses peristiwa eksternal. </p><br><h5>  Jika </h5><br><p>  Primitif <strong>Jika</strong> .  Di sini kesulitan dimulai.  Jika Anda terbiasa dengan bpmn dan menggambar proses dalam notasi ini, maka Anda akan menemukan pengaturan yang mudah.  Menurut dokumentasi, langkah tersebut dijelaskan sebagai berikut: </p><br><pre> <code class="plaintext hljs">{ "Id": "IfStep", "StepType": "WorkflowCore.Primitives.If, WorkflowCore", "NextStepId": "nextStep", "Inputs": { "Condition": "&lt;&lt;expression to evaluate&gt;&gt;" }, "Do": [ [ { /*do1*/ }, { /*do2*/ } ] ] }</code> </pre> <br><p>  Tidak ada perasaan ada yang salah di sini?  Saya punya satu.  Input langkah diatur ke <em>Kondisi</em> - ekspresi.  Selanjutnya, kita mengatur daftar langkah-langkah di dalam <strong>Do</strong> array (tindakan).  Jadi, di mana cabang <strong>Salah</strong> ?  Mengapa tidak ada Do array untuk False?  Sebenarnya ada.  Dipahami bahwa cabang <strong>False</strong> hanyalah sebuah pass lebih jauh di sepanjang proses, yaitu, mengikuti pointer di <strong>NextStepId</strong> .  Pada awalnya, saya selalu bingung karena ini.  Oke, bereskan.  Meski tidak.  Jika proses tindakan dalam kasus <em>True</em> perlu dimasukkan ke dalam <strong>Do</strong> , inilah json yang "cantik" nantinya.  Dan jika ada ini <strong>Jika</strong> tertutup dengan selusin?  Semuanya akan berjalan menyamping.  Mereka juga mengatakan bahwa skema pada xaml sulit dibaca.  Ada hack kecil.  Hanya bawa monitor lebih lebar.  Disebutkan sedikit di atas bahwa urutan langkah-langkah dalam koleksi tidak masalah, transisi mengikuti tanda-tanda.  Itu bisa digunakan.  Tambahkan satu langkah lagi: </p><br><pre> <code class="plaintext hljs">{ "Id": "Jump", "StepType": "App.JumpStep, App", "NextStepId": "" }</code> </pre> <br><p>  Coba tebak apa yang saya tuju?  Benar, kami memperkenalkan langkah layanan, yang dalam perjalanan membawa proses ke langkah di <strong>NextStepId</strong> . </p><br><p>  Perbarui skema kami: </p><br><pre> <code class="plaintext hljs">{ "Id": "SomeWorkflow", "Version": 1, "DataType": "App.ProcessContext, App", "Steps": [ { "Id": "Eval", "StepType": "App.CustomStep, App", "NextStepId": "MyIfStep", "Inputs": { "Input1": "data.Number1", "Input2": "data.Number2" }, "Outputs": { "StepResult": "step.Result" } }, { "Id": "MyIfStep", "StepType": "WorkflowCore.Primitives.If, WorkflowCore", "NextStepId": "OutputEmptyResult", "Inputs": { "Condition": "!String.IsNullOrEmpty(data.StepResult)" }, "Do": [ [ { "Id": "Jump", "StepType": "App.JumpStep, App", "NextStepId": "Output" } ] ] }, { "Id": "Output", "StepType": "App.OutputStep, App", "Inputs": { "TextToOutput": "data.StepResult" } }, { "Id": "OutputEmptyResult", "StepType": "App.OutputStep, App", "Inputs": { "TextToOutput": "\"Empty result\"" } } ] }</code> </pre> <br><p>  Langkah <strong>Jika</strong> memeriksa untuk melihat apakah hasil dari langkah <strong>Eval</strong> kosong.  Jika tidak kosong, maka kami tampilkan hasilnya, jika kosong, maka pesan " <em>Empty result</em> ".  Langkah <strong>Langsung</strong> membawa proses ke langkah <strong>Output</strong> , yang berada di luar koleksi Do.  Dengan demikian, kami telah mempertahankan "vertikalitas" skema tersebut.  Juga, dengan cara ini, seseorang dapat melompat n langkah mundur, mis.  untuk mengatur siklus.  Ada built-in primitif untuk loop di wf core, tetapi mereka tidak selalu nyaman.  Dalam bpmn, misalnya, loop diatur melalui <strong>If</strong> . </p><br><p>  Gunakan pendekatan atau standar ini, terserah Anda.  Bagi kami, organisasi seperti itu adalah langkah yang lebih mudah. </p><br><h5>  Menunggu </h5><br><p>  Primitif <strong>WaitFor</strong> memungkinkan dunia luar untuk memengaruhi proses ketika sudah berjalan.  Sebagai contoh, jika pada tahap proses persetujuan dari kursus lebih lanjut oleh setiap pengguna diperlukan.  Proses akan berdiri pada langkah <strong>WaitFor</strong> sampai menerima acara yang dilangganinya. </p><br><p>  Struktur primitif: </p><br><pre> <code class="plaintext hljs">{ "Id": "Wait", "StepType": "WorkflowCore.Primitives.WaitFor, WorkflowCore", "NextStepId": "NextStep", "CancelCondition": "If(cancel==true)", "Inputs": { "EventName": "\"UserAction\"", "EventKey": "\"DoSum\"", "EffectiveDate": "DateTime.Now" } }</code> </pre> <br><p>  Saya akan menjelaskan parameternya sedikit. </p><br><p>  <strong>CancelCondition</strong> - syarat untuk menginterupsi penantian.  Memberikan kemampuan untuk menginterupsi penantian suatu acara dan melanjutkan prosesnya.  Sebagai contoh, jika suatu proses menunggu n peristiwa yang berbeda pada saat yang sama (jika inti mendukung pelaksanaan langkah-langkah paralel), tidak perlu menunggu semua <strong>tiba</strong> , dalam hal ini <strong>CancelCondition</strong> akan membantu <strong>kami</strong> .  Kami menambahkan flag logis ke variabel konteks dan setelah menerima acara kami mengatur flag menjadi <em>true</em> - semua langkah <strong>WaitFor</strong> selesai. </p><br><p>  <strong>EventName</strong> dan <strong>EventKey</strong> - nama dan kunci acara.  Bidang diperlukan untuk membedakan peristiwa, mis., Dalam sistem nyata dengan sejumlah besar proses yang bekerja secara bersamaan.  sehingga mesin mengerti acara apa yang dimaksudkan untuk proses apa dan langkah apa. </p><br><p>  <strong>EffectiveDate</strong> - bidang opsional yang menambahkan cap waktu acara.  Ini mungkin berguna jika Anda perlu mempublikasikan acara "ke masa depan".  Agar segera dipublikasikan, Anda dapat membiarkan parameter kosong atau mengatur waktu saat ini. </p><br><p>  Tidak dalam semua kasus, lebih baik mengambil langkah terpisah untuk memproses reaksi dari luar, bahkan biasanya akan berlebihan.  Langkah tambahan dapat dihindari dengan menambahkan harapan dari peristiwa eksternal dan logika pemrosesannya ke langkah biasa.  Kami <strong>melengkapi</strong> langkah <strong>CustomStep dengan</strong> berlangganan ke acara eksternal: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomStep</span></span> : <span class="hljs-title"><span class="hljs-title">StepBody</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Ilogger _log; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TextToOutput { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomStep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ilogger log</span></span></span><span class="hljs-function">)</span></span> { _log = log; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> ExecutionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStepExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//-  return ExecutionResult.WaitForEvent("eventName", "eventKey", DateTime.Now); } }</span></span></code> </pre> <br><p>  Kami menggunakan metode ekstensi <strong>WaitForEvent ()</strong> standar.  Ini menerima parameter yang disebutkan sebelumnya <strong>EventName</strong> , <strong>EventKey</strong> dan <strong>EffectiveDate</strong> .  Setelah menyelesaikan logika langkah tersebut, proses akan menunggu acara yang dijelaskan dan kembali memanggil metode <strong>Run ()</strong> pada saat acara tersebut diterbitkan di bus mesin.  Namun, dalam formulir saat ini, kami tidak dapat membedakan antara saat-saat entri awal ke langkah dan entri setelah acara.  Tetapi saya ingin memisahkan logika sebelum-setelah pada tingkat langkah.  Dan bendera <strong>EventPublished</strong> akan membantu kita dengan ini.  Itu terletak di dalam konteks umum proses, Anda bisa mendapatkannya seperti ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ifEvent=context.ExecutionPointer.EventPublished;</code> </pre> <br><p>  Berdasarkan bendera ini, Anda dapat dengan aman membagi logika menjadi sebelum dan sesudah peristiwa eksternal. </p><br><p>  Klarifikasi penting - sesuai dengan ide pembuat mesin, satu langkah hanya dapat ditandatangani pada satu acara dan bereaksi sekali saja.  Untuk beberapa tugas, ini adalah batasan yang sangat tidak menyenangkan.  Kami bahkan harus "menyelesaikan" mesin untuk melepaskan diri dari nuansa ini.  Kami akan melewatkan deskripsi mereka di artikel ini, kalau tidak artikel itu tidak akan pernah berakhir :).  Praktik penggunaan yang lebih kompleks dan contoh peningkatan akan dibahas dalam artikel selanjutnya. </p><br><h4>  Proses pendaftaran di mesin.  Publikasi acara di bus. </h4><br><p>  Jadi, dengan implementasi logika langkah-langkah dan deskripsi proses dipecahkan.  Yang tersisa adalah hal yang paling penting, yang tanpanya proses tidak akan berfungsi - deskripsi perlu didaftarkan. </p><br><p>  Kami akan menggunakan metode ekstensi <strong>AddWorkflow ()</strong> standar, yang akan menempatkan dependensinya dalam wadah IoC kami. </p><br><p>  Ini terlihat seperti ini: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IServiceCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWorkflow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IServiceCollection services, Action&lt;WorkflowOptions&gt; setupAction = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p>  <strong>IServiceCollection</strong> - interface - kontrak untuk kumpulan deskripsi layanan.  Dia tinggal di dalam DI dari Microsoft (lebih lanjut tentang itu dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibaca di sini</a> ) </p><br><p>  <strong>WorkflowOptions</strong> - pengaturan engine dasar.  Tidak perlu mengaturnya sendiri, nilai standar cukup dapat diterima untuk kenalan pertama.  Kita melangkah lebih jauh. </p><br><p>  Jika prosesnya dijelaskan dalam kode, maka pendaftaran terjadi seperti ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> host = _serviceProvider.GetService&lt;IWorkflowHost&gt;(); host.RegisterWorkflow&lt;SomeWorkflow, ProcessContext&gt;();</code> </pre> <br><p>  Jika proses dijelaskan melalui json, maka harus didaftarkan sebagai berikut (tentu saja, deskripsi json harus dimuat dari lokasi penyimpanan): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> host = _serviceProvider.GetService&lt;IWorkflowHost&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> definitionLoader = _serviceProvider.GetService&lt;IDefinitionLoader&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> definition = loader.LoadDefinition({*json  *});</code> </pre> <br><p>  Lebih lanjut, untuk kedua opsi, kode akan sama: </p><br><pre> <code class="cs hljs">host.Start(); <span class="hljs-comment"><span class="hljs-comment">//      host.StartWorkflow(definitionId, version, context); //      /// host.Stop(); / /    </span></span></code> </pre> <br><p>  Parameter <strong>definitionId</strong> adalah pengidentifikasi proses.  Apa yang tertulis di kolom Id proses.  Dalam hal ini, id = <strong>SomeWorkflow</strong> . </p><br><p>  Parameter <strong>versi</strong> menentukan versi proses yang akan dijalankan.  Mesin menyediakan kemampuan untuk segera mendaftar di versi proses dengan satu pengidentifikasi.  Ini nyaman ketika Anda perlu membuat perubahan pada deskripsi proses tanpa melanggar tugas yang sudah berjalan - yang baru akan dibuat sesuai dengan versi baru, yang lama akan hidup diam-diam pada yang lama. </p><br><p>  Parameter <strong>konteks</strong> adalah turunan dari konteks proses. </p><br><p>  Metode <strong>host.Start ()</strong> dan <strong>host.Stop ()</strong> memulai dan menghentikan proses hosting.  Jika dalam aplikasi peluncuran proses adalah tugas yang diterapkan dan dilakukan secara berkala, maka hosting harus dihentikan.  Jika aplikasi memiliki fokus utama pada implementasi berbagai proses, maka hosting tidak dapat dihentikan. </p><br><p>  Ada metode untuk mengirim pesan dari dunia luar ke bus mesin, yang kemudian akan mendistribusikannya di antara pelanggan: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublishEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventKey, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventData, DateTime effectiveDate = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  Deskripsi parameternya lebih tinggi di artikel ( <em>lihat bagian primitif WaitFor</em> ). </p><br><h2>  Kesimpulan </h2><br><p>  Kami benar-benar mengambil risiko ketika kami memutuskan untuk mendukung Workflow Core - proyek opensource, yang secara aktif dikembangkan oleh satu orang, dan bahkan dengan dokumentasi yang sangat buruk.  Dan Anda kemungkinan besar tidak akan menemukan praktik nyata menggunakan inti WF dalam sistem produksi (kecuali milik kami).  Tentu saja, setelah memilih lapisan abstraksi yang terpisah, kami mengasuransikan diri terhadap kasus kegagalan dan kebutuhan untuk segera kembali ke WWF, misalnya, atau solusi yang ditulis sendiri, tetapi semuanya berjalan dengan baik dan kegagalan tidak datang. </p><br><p>  Beralih ke engine Core Alur Kerja opensource memecahkan sejumlah masalah yang mencegah kami hidup damai di WWF.  Yang paling penting di antara mereka adalah, tentu saja, mendukung .Net Core dan tidak adanya WWF. </p><br><p>  Berikut ini adalah sumber terbuka.  Bekerja dengan WWF dan mendapatkan berbagai kesalahan dari perutnya, kemampuan untuk setidaknya membaca sumbernya akan sangat membantu.  Belum lagi mengubah sesuatu di dalamnya.  Di sini, dengan Workflow Core, kebebasan penuh (termasuk lisensi - MIT).  Jika kesalahan tiba-tiba muncul dari perut mesin, cukup unduh sumber dari github dan dengan tenang mencari penyebab kemunculannya.  Ya, hanya kemampuan untuk menghidupkan mesin dalam mode debug dengan breakpoint sudah sangat memudahkan proses. </p><br><p>  Tentu saja, memecahkan beberapa masalah, Workflow Core membawa yang baru.  Kami harus melakukan sejumlah besar perubahan pada inti mesin.  Tapi  Bekerja pada "penyelesaian" untuk diri mereka sendiri lebih murah dalam waktu daripada mengembangkan mesin Anda sendiri dari awal.  Solusi akhir cukup dapat diterima dalam hal kecepatan dan stabilitas, itu memungkinkan kami untuk melupakan masalah dengan mesin dan fokus pada pengembangan nilai bisnis produk. </p><br><p>  <em>PS Jika topiknya ternyata menarik, maka akan ada lebih banyak artikel tentang inti, dengan analisis yang lebih dalam dari mesin dan solusi untuk masalah bisnis yang kompleks.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475902/">https://habr.com/ru/post/id475902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475888/index.html">Manfaat pengenalan wajah cloud</a></li>
<li><a href="../id475892/index.html">Bagaimana kami meningkatkan urutan makan siang di kantor (tanpa akses ke server)</a></li>
<li><a href="../id475894/index.html">Tiga protokol lulus</a></li>
<li><a href="../id475896/index.html">Reaktor C / I Naked Penuh</a></li>
<li><a href="../id475900/index.html">6 Kursus Azure Terbaru</a></li>
<li><a href="../id475904/index.html">5 catatan untuk manajer baru</a></li>
<li><a href="../id475908/index.html">10 kursus Microsoft paling populer di Rusia</a></li>
<li><a href="../id475912/index.html">Cara mengevaluasi dan membandingkan perangkat enkripsi untuk jaringan Ethernet</a></li>
<li><a href="../id475916/index.html">Tambahkan mata ke robot</a></li>
<li><a href="../id475920/index.html">Bukan pada saat runtime, tetapi pada waktu desain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>