<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüëß‚Äçüëß üïõ üßöüèø C n'est pas un langage de bas niveau ü§© üë®‚Äçüé® üåÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Votre ordinateur n'est pas une version rapide de PDP-11 
 Bonjour, Habr! 

 Je m'appelle Anton Dovgal, je suis d√©veloppeur C (et pas seulement) chez B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C n'est pas un langage de bas niveau</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/420407/"><img src="https://habrastorage.org/webt/8n/tg/og/8ntgogmuur_qld0ho0701jc83du.jpeg"><br><br><h3>  <i>Votre ordinateur n'est pas une version rapide de PDP-11</i> </h3><br>  Bonjour, Habr! <br><br>  Je m'appelle Anton Dovgal, je suis d√©veloppeur C (et pas seulement) chez Badoo. <br><br>  Je suis tomb√© sur un article de David Chiznell, chercheur √† l'Universit√© de Cambridge, dans lequel il conteste l'opinion g√©n√©ralement accept√©e selon laquelle C est un langage de bas niveau, et ses arguments m'ont paru suffisamment int√©ressants. <br><br>  √Ä la lumi√®re des vuln√©rabilit√©s r√©cemment d√©couvertes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Meltdown et Spectre</a> devraient prendre le temps de d√©couvrir les raisons de leur apparition.  Ces deux vuln√©rabilit√©s exploitaient l'ex√©cution sp√©culative d'instructions par des processeurs et permettaient √† un attaquant de recevoir des r√©sultats via des canaux tiers.  Des vuln√©rabilit√©s dans les fonctionnalit√©s du processeur, ainsi que d'autres, ont √©t√© ajout√©es afin que les programmeurs C continuent de croire qu'ils programment dans un langage de bas niveau, bien que cela n'ait pas √©t√© le cas depuis des d√©cennies. <br><br>  Les fabricants de processeurs ne sont pas seuls dans ce domaine.  Les d√©veloppeurs de compilateurs C / C ++ ont √©galement contribu√©. <br><a name="habracut"></a><br><h2>  Qu'est-ce qu'une langue de bas niveau? </h2><br>  L'informaticien am√©ricain et premier laur√©at du prix Turing Alan Perlis a donn√© la d√©finition suivante: <br><blockquote>  "Un langage de programmation est de bas niveau si les programmes √©crits dessus n√©cessitent une attention au non essentiel." </blockquote><br>  Bien que cette d√©finition fasse r√©f√©rence √† C, elle ne permet pas de comprendre ce que les gens veulent voir dans un langage de bas niveau.  Diverses propri√©t√©s font que les gens consid√®rent le langage comme bas.  Imaginez une √©chelle de langages de programmation avec l'assembleur √† une extr√©mit√© et une interface avec un ordinateur d'entreprise √† l'autre.  Les langues de bas niveau sont plus proches du fer, tandis que les langues de haut niveau sont plus proches de la fa√ßon dont les gens pensent. <br><br>  Pour √™tre ¬´plus proche du mat√©riel¬ª, le langage doit fournir des abstractions qui correspondent aux abstractions de la plateforme cible.  Il est facile de prouver que C √©tait un langage de bas niveau dans PDP-11.  L'ex√©cution s√©quentielle des programmes, un espace d'adressage plat, m√™me les op√©rateurs pr√© et post-incr√©mentation, tombaient parfaitement sur les modes d'adressage PDP-11. <br><br><h2>  √âmulateurs PDP-11 rapides </h2><br>  La principale raison des vuln√©rabilit√©s de Spectre et Meltdown est que les cr√©ateurs des processeurs ne se sont pas content√©s de fabriquer des processeurs rapides, ils ont cr√©√© des processeurs rapides avec une interface PDP-11.  Ceci est important car il permet aux programmeurs C de continuer √† croire que leur langage est proche du mat√©riel. <br><br>  Le code C fournit un automate abstrait principalement s√©quentiel (jusqu'√† C11, il est compl√®tement s√©quentiel, si les extensions non standard sont exclues).  La cr√©ation d'un nouveau thread est un appel √† une fonction de biblioth√®que, une op√©ration assez co√ªteuse.  Par cons√©quent, les processeurs, d√©sireux de continuer √† ex√©cuter du code C, s'appuient sur le parall√©lisme au niveau de l'instruction (ILP).  Ils analysent les op√©rations voisines et effectuent des op√©rations ind√©pendantes en parall√®le.  Cela complique consid√©rablement les processeurs et entra√Æne une augmentation de la consommation d'√©nergie, mais permet aux programmeurs d'√©crire principalement du code s√©quentiel.  En revanche, les processeurs graphiques (GPU) atteignent des performances √©lev√©es d'une autre mani√®re: ils n√©cessitent l'√©criture de programmes parall√®les. <br><br>  Une concurrence √©lev√©e au niveau de la commande est la cause directe de Spectre et Meltdown.  Le processeur Intel moderne ex√©cute jusqu'√† 180 instructions simultan√©ment (contrairement √† la machine s√©quentielle C abstraite, qui s'attend √† ce que l'instruction pr√©c√©dente soit ex√©cut√©e avant que la suivante ne d√©marre).  Une heuristique typique du code C montre qu'il y a une branche en moyenne pour sept instructions.  Si vous voulez garder le pipeline d'instructions complet, vous devez deviner les 25 prochaines branches.  Cela, √† son tour, ajoute de la complexit√© - le processeur calcule d'abord la branche incorrectement devin√©e, puis renvoie les r√©sultats des calculs, ce qui affecte n√©gativement la consommation d'√©nergie.  Ces donn√©es lanc√©es ont des r√©sultats indirects visibles, qui ont √©t√© utilis√©s dans les attaques Spectre et Meltdown. <br><br>  Renommer les registres consomme beaucoup d'√©nergie et de puces dans les processeurs modernes.  Il ne peut pas √™tre d√©sactiv√© ou sa consommation d'√©nergie r√©duite, ce qui le rend incommode √† l'√®re du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">silicium noir</a> , lorsque les transistors sont faibles, mais les transistors impliqu√©s sont une ressource pr√©cieuse.  Ce p√©riph√©rique est absent du GPU, o√π la concurrence est obtenue en utilisant des threads au lieu d'essayer d'ex√©cuter en parall√®le du code initialement s√©quentiel.  Si les instructions n'ont pas de d√©pendances √† reconstruire, il n'est pas non plus n√©cessaire de renommer les registres. <br><br>  Prenons un autre √©l√©ment fondamental de la conception C: la m√©moire plate.  Cela n'existe pas depuis quelques d√©cennies.  Un processeur moderne a souvent trois niveaux de mise en cache entre les registres et la m√©moire principale, r√©duisant ainsi le temps n√©cessaire pour acc√©der √† cette derni√®re. <br><br>  Le cache est cach√© au programmeur et donc inaccessible √† C.L'utilisation efficace du cache est l'un des moyens d'acc√©l√©rer l'ex√©cution du code sur un processeur moderne, mais il est compl√®tement cach√© de la machine abstraite et les programmeurs sont oblig√©s de s'appuyer sur la connaissance des d√©tails de l'impl√©mentation du cache (par exemple, deux align√©s 64 bits les valeurs peuvent appara√Ætre sur une ligne du cache) pour √©crire du code efficace. <br><br><h2>  Optimisation C </h2><br>  L'une des caract√©ristiques communes attribu√©es aux langues de bas niveau est la vitesse.  En particulier, ils devraient √™tre faciles √† traduire en code rapide sans compilateur compliqu√©.  L'argument selon lequel un compilateur suffisamment intelligent peut rendre un langage rapide est souvent ignor√© par les partisans de C lorsqu'ils parlent d'autres langages. <br><br>  Malheureusement, en utilisant une simple traduction, vous ne pouvez pas obtenir de code rapide √† partir de C. <br>  Les architectes de processeurs font des efforts h√©ro√Øques pour cr√©er des puces capables d'ex√©cuter rapidement du code C.  Mais les niveaux de performances que les programmeurs s'attendent √† voir ne sont atteints qu'avec l'aide d'optimisations incroyablement complexes effectu√©es par le compilateur. <br>  Le compilateur Clang (y compris les parties correspondantes de LLVM) comprend environ 2 millions de lignes de code.  Pour l'analyse et la transformation du code, n√©cessaires √† l'acc√©l√©ration de C, environ 200 000 lignes de code sont n√©cessaires (hors commentaires et lignes vierges). <br><br>  Par exemple, pour traiter une grande quantit√© de donn√©es en C, vous devez √©crire une boucle qui traite chaque √©l√©ment s√©quentiellement.  Pour l'ex√©cution optimale de ce cycle sur un processeur moderne, le compilateur doit d√©terminer que les it√©rations du cycle sont ind√©pendantes les unes des autres.  Le mot cl√© restrict peut aider dans ce cas - il garantit que les √©critures sur un pointeur n'interf√®rent pas avec la lecture d'un autre pointeur.  Ces informations en C sont beaucoup plus limit√©es que dans un langage tel que Fortran, qui est la principale raison pour laquelle C n'a pas √©t√© en mesure de les sortir du calcul haute performance. <br><br>  Une fois que le compilateur a d√©termin√© que les it√©rations sont ind√©pendantes les unes des autres, l'√©tape suivante est une tentative de vectorisation du r√©sultat, car le d√©bit des processeurs modernes est quatre √† huit fois plus √©lev√© pour le code vectoris√© que pour le code scalaire.  Un langage de bas niveau pour de tels processeurs aurait ses propres types vectoriels de longueur arbitraire.  De tels types sont pr√©sents dans la repr√©sentation LLVM interm√©diaire, car il est toujours plus facile de diviser de grandes op√©rations avec des vecteurs en plusieurs petites que de construire de plus grandes op√©rations vectorielles. <br><br>  √Ä ce stade, les optimiseurs doivent faire face aux r√®gles de m√©moire C. C garantit que les structures avec le m√™me pr√©fixe peuvent √™tre utilis√©es de mani√®re interchangeable, et donne acc√®s aux champs de champs d√©cal√©s des structures dans le langage.  Cela signifie que le compilateur ne peut pas modifier l'ordre des champs dans la structure ou ajouter un alignement pour am√©liorer la vectorisation (par exemple, transformer une structure de tableaux en un tableau de structures ou vice versa).  Ce n'est g√©n√©ralement pas un probl√®me dans les langages de bas niveau, o√π il est possible de contr√¥ler l'emplacement des champs dans la structure, mais cela rend la t√¢che d'acc√©l√©ration de C. plus difficile. <br><br>  C n√©cessite √©galement un alignement √† la fin de la structure, car il garantit qu'il n'y a pas d'alignement dans les tableaux.  L'alignement est une partie assez complexe de la sp√©cification C, qui interagit mal avec les autres parties du langage.  Par exemple, vous devriez pouvoir comparer deux structures √† l'aide de la m√©thode de comparaison sans type (c'est-√†-dire la fonction memcmp ()), de sorte que la copie de la structure doit √©galement √™tre align√©e.  Dans certains cas, la copie de l'alignement prend beaucoup de temps. <br><br>  Consid√©rez les deux optimisations de base que le compilateur C produit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SROA</a> (remplacement scalaire des agr√©gats, remplacement scalaire des agr√©gats) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ouverture de boucle</a> . <br><br>  SROA essaie de remplacer les structures et les tableaux de taille fixe par des variables distinctes.  Cela permet au compilateur de traiter leur acc√®s ind√©pendamment les uns des autres et d'ignorer l'op√©ration, s'il est √©vident que son r√©sultat n'est pas utilis√©.  Dans certains cas, l'effet indirect de cette optimisation est de supprimer l'alignement. <br><br>  La deuxi√®me optimisation, l'ouverture de la boucle, convertit la boucle avec la condition en une condition avec diff√©rentes boucles dans les deux branches.  Cela change l'ordre d'ex√©cution par opposition √† l'affirmation que le programmeur sait ce qui sera ex√©cut√© dans un langage de bas niveau.  Et cela cr√©e √©galement de s√©rieux probl√®mes avec la fa√ßon dont C g√®re les variables non d√©finies et le comportement non d√©fini. <br><br>  En C, une variable non initialis√©e a une valeur non d√©finie, qui peut √™tre diff√©rente √† chaque appel.  Ceci est important car il vous permet d'impl√©menter le recyclage paresseux des pages m√©moire.  Par exemple, dans FreeBSD, l'impl√©mentation malloc () indique au syst√®me que les pages ne sont plus utilis√©es et que le syst√®me utilise la premi√®re entr√©e de la page comme preuve que ce n'est pas le cas.  Faire appel √† la m√©moire nouvellement allou√©e peut obtenir l'ancienne valeur, puis le syst√®me d'exploitation peut r√©utiliser la page de m√©moire, puis la remplacer par une page remplie de z√©ros la prochaine fois que vous √©crivez √† un autre endroit de la page.  Le deuxi√®me appel au m√™me endroit sur la page obtiendra une valeur nulle. <br><br>  Si la condition utilise une valeur non d√©finie, le r√©sultat n'est pas non plus d√©fini - tout peut arriver.  Imaginez une optimisation de boucle ouverte o√π une boucle est ex√©cut√©e z√©ro fois.  Dans l'original, la boucle enti√®re est du code mort.  Dans la version ouverte, il y a maintenant une condition avec une variable qui ne peut pas √™tre initialis√©e. <br>  Par cons√©quent, le code mort peut √™tre converti en un comportement non d√©fini.  Ce n'est l√† qu'une des nombreuses optimisations qui, lorsqu'elles explorent plus en profondeur la s√©mantique de C, ne sont pas fiables. <br><br>  En fin de compte, vous pouvez faire fonctionner le code C rapidement, mais seulement apr√®s avoir pass√© des milliers d'ann√©es-homme √† cr√©er un compilateur suffisamment intelligent.  Mais cela n'est possible que si certaines r√®gles de la langue sont viol√©es.  Les cr√©ateurs de compilateurs permettent aux programmeurs C d'imaginer qu'ils √©crivent du code "proche du mat√©riel", mais ils doivent g√©n√©rer du code machine qui se comporte diff√©remment afin que les programmeurs continuent de croire qu'ils √©crivent dans un langage rapide. <br><br><h2>  Comprendre C </h2><br>  L'un des attributs de base d'un langage de bas niveau est que les programmeurs peuvent facilement comprendre comment une machine de langage abstrait est transf√©r√©e vers une machine physique.  C'√©tait certainement le cas sur PDP-11, o√π les expressions C √©taient traduites en une ou deux instructions.  De m√™me, le compilateur place les variables dans les emplacements de pile et convertit les types simples en compr√©hensibles pour PDP-11. <br><br>  Depuis lors, les impl√©mentations C sont devenues beaucoup plus compliqu√©es - pour maintenir l'illusion que C est facilement port√© sur une plate-forme mat√©rielle et s'ex√©cute rapidement.  En 2015, une enqu√™te aupr√®s des programmeurs C, des auteurs de compilateurs et des membres du comit√© de normalisation a montr√© qu'il y avait des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√®mes pour comprendre C.</a>  Par exemple, ce langage permet √† une impl√©mentation d'ajouter un alignement aux structures (mais pas aux tableaux) pour garantir que tous les champs sont correctement align√©s pour la plate-forme cible.  Si vous remplissez cette structure de z√©ros puis sp√©cifiez une valeur pour certains champs, y aura-t-il des z√©ros dans les bits d'alignement?  Selon l'enqu√™te, 36% √©taient s√ªrs qu'ils le feraient et 29% ne connaissaient pas la r√©ponse.  Selon le compilateur et le niveau d'optimisation, cela peut √™tre vrai (ou non). <br><br>  Ceci est un exemple assez banal, mais de nombreux programmeurs donnent la mauvaise r√©ponse ou ne peuvent pas r√©pondre du tout. <br><br>  Si vous ajoutez des pointeurs, la s√©mantique de C devient encore plus confuse.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le mod√®le BCPL</a> √©tait assez simple: toutes les significations sont des mots.  Chaque mot est soit une donn√©e, soit une adresse en m√©moire.  La m√©moire est un tableau plat de cellules index√©es par adresse. <br><br>  Le mod√®le C permet la mise en ≈ìuvre de diff√©rentes plates-formes, y compris des architectures segment√©es, o√π le pointeur peut √™tre compos√© d'ID de segment et de d√©calages, ainsi que de machines virtuelles avec un garbage collector.  La sp√©cification C limite les op√©rations de pointeur autoris√©es pour √©viter les probl√®mes avec de tels syst√®mes.  La r√©ponse au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport de d√©fauts 260</a> mentionne l'origine du pointeur: <br><blockquote>  ¬´Les impl√©mentations peuvent suivre l'origine d'un ensemble de bits et g√©rer ceux qui contiennent une valeur non d√©finie diff√©remment de ceux qui en contiennent un sp√©cifique.  "Ils peuvent g√©rer les pointeurs diff√©remment selon leur origine, m√™me s'ils sont identiques en termes de valeur binaire." </blockquote><br>  Malheureusement, le mot "origine" est absent de la sp√©cification C11, donc les compilateurs d√©cident eux-m√™mes de ce qu'il signifie.  GCC et Clang, par exemple, diff√®rent quant √† savoir si le pointeur qui a √©t√© converti en entier et en arri√®re conserve son origine.  Les compilateurs peuvent d√©cider que deux pointeurs vers les r√©sultats de malloc () donnent toujours un r√©sultat n√©gatif lors de la comparaison, m√™me s'ils pointent vers la m√™me adresse. <br><br>  Ces malentendus ne sont pas purement acad√©miques.  Par exemple, des vuln√©rabilit√©s ont d√©j√† √©t√© observ√©es, qui r√©sultaient du d√©bordement d'un entier sign√© (comportement non d√©fini en C) ou du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©r√©f√©rencement d'un pointeur avant de le v√©rifier pour NULL</a> , malgr√© le fait que le compilateur a √©t√© inform√© que le pointeur ne pouvait pas √™tre NULL. <br><br>  S'il y a de tels probl√®mes, il est difficile de s'attendre √† ce qu'un programmeur comprenne parfaitement comment un programme C se traduit par l'architecture appropri√©e. <br><br><h2>  Pr√©sentation d'un processeur pas pour C </h2><br>  Les correctifs propos√©s pour prot√©ger contre Spectre et Meltdown provoquent une grave d√©gradation des performances, annulant toutes les r√©alisations de la microarchitecture au cours de la derni√®re d√©cennie.  Il est peut-√™tre temps d'arr√™ter de r√©fl√©chir √† la fa√ßon d'acc√©l√©rer le code C et de penser √† la place √† de nouveaux mod√®les de programmation sur des processeurs con√ßus pour la vitesse. <br><br>  Il existe de nombreux exemples d'architectures qui ne se sont pas concentr√©es sur le code C traditionnel et sur lesquelles s'inspirer.  Par exemple, les processeurs orient√©s multithreading tels que Sun / Oracle UltraSPARC Tx ne n√©cessitent pas autant de cache pour occuper leurs actionneurs.  Les processeurs de recherche ont √©tendu ce concept √† un tr√®s grand nombre de threads pr√©vus par le mat√©riel.  L'id√©e cl√© est qu'avec suffisamment de threads, le processeur peut suspendre les threads en attente de donn√©es et remplir les actionneurs avec des instructions provenant d'autres threads.  Le probl√®me est que les programmes C ont g√©n√©ralement tr√®s peu de threads. <br><br>  SVE (Scalar Vector Extensions, extensions de vecteur scalaire) d'ARM est un autre travail similaire de Berkeley, qui offre un aper√ßu de l'interface am√©lior√©e entre le programme et le mat√©riel.  Les blocs de vectorisation r√©guliers impl√©mentent des op√©rations avec des vecteurs de taille fixe et s'attendent √† ce que le compilateur adapte l'algorithme √† la taille sp√©cifi√©e.  En revanche, l'interface SVE invite le programmeur √† d√©crire ind√©pendamment le niveau de parall√©lisme et attend du mat√©riel qu'il l'adapte aux actionneurs disponibles.  Son utilisation en C est difficile car l'auto-vectoriseur doit calculer le parall√©lisme en fonction des boucles dans le code. <br><br>  Les caches sont volumineux, mais ce n'est pas la seule raison de leur complexit√©.  Le protocole de prise en charge de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">coh√©rence du cache</a> est l'un des composants les plus complexes d'un processeur moderne.  La majeure partie de la difficult√© vient du fait de devoir maintenir un langage dans lequel les donn√©es peuvent √™tre partag√©es et modifiables.  Comme exemple oppos√©, nous pouvons utiliser une machine abstraite de style Erlang, o√π chaque objet est soit local soit immuable.  Le protocole de coh√©rence d'ant√©m√©moire pour un tel syst√®me n'aurait que deux cas: les donn√©es mutables et les donn√©es partag√©es.  Le cache du flux de programme qui a √©t√© transf√©r√© vers un autre processeur doit √™tre explicitement d√©sactiv√©, mais c'est une op√©ration relativement rare. <br><br>  Les objets immuables peuvent simplifier encore plus les caches et rendre certaines op√©rations moins co√ªteuses.  Dans un projet Maxwell de Sun Labs, il a √©t√© not√© que les objets dans le cache et les objets r√©cemment cr√©√©s sont presque toujours les m√™mes.  Si des objets meurent avant d'√™tre exclus du cache, vous ne pouvez pas les √©crire dans la m√©moire principale et ainsi √©conomiser de l'√©nergie.  Le projet Maxwell proposait un garbage collector qui fonctionnait dans le cache et vous permettait de recycler rapidement la m√©moire.  Avec des objets immuables sur le tas et la pile mutable, le garbage collector devient une machine d'√©tat tr√®s simple, qui est facilement impl√©ment√©e dans le mat√©riel et vous permet d'utiliser efficacement un cache relativement petit. <br><br>  Un processeur con√ßu uniquement pour la vitesse, et non pour le compromis entre la vitesse et la prise en charge C, devrait probablement prendre en charge un grand nombre de threads, avoir de grands blocs de vectorisation et un mod√®le de m√©moire plus simple.  Il sera difficile d'ex√©cuter du code C sur un tel processeur, par cons√©quent, √©tant donn√© le volume de l'ancien code C dans le monde, il est peu probable qu'il ait un succ√®s commercial. <br><br>  Dans le domaine du d√©veloppement logiciel, il existe un mythe selon lequel la programmation parall√®le est difficile.  Alan Kay serait tr√®s surpris d'entendre cela: il a appris aux enfants √† utiliser le mod√®le de l'acteur, avec lequel ils ont √©crit des programmes sur plus de 200 streams.  Cela est √©galement inconnu des programmeurs Erlang, qui √©crivent souvent des programmes avec des milliers de composants parall√®les.  Il est plus correct de dire que la programmation parall√®le est difficile dans un langage avec une machine abstraite comme C. Et si vous faites attention √† la pr√©dominance du mat√©riel parall√®le (des processeurs multic≈ìurs aux GPU multic≈ìurs), alors c'est juste une autre fa√ßon de dire que C ne convient pas au mat√©riel moderne fournir. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420407/">https://habr.com/ru/post/fr420407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420391/index.html">Salaires IT mi-2018</a></li>
<li><a href="../fr420393/index.html">PHP, YII2 et la formation de gros fichiers Excel</a></li>
<li><a href="../fr420395/index.html">Tablettes "gratuites" pour les d√©tenus - pas du tout gratuites</a></li>
<li><a href="../fr420397/index.html">Les scientifiques ont trouv√© un moyen d'inverser le processus de vieillissement des cellules</a></li>
<li><a href="../fr420405/index.html">Recherche sur le processus de vente informatique</a></li>
<li><a href="../fr420409/index.html">Apprenez OpenGL. Le√ßon 5.7 - HDR</a></li>
<li><a href="../fr420413/index.html">SQLite et NW.js - instructions pas √† pas pour cr√©er des amiti√©s solides</a></li>
<li><a href="../fr420415/index.html">Tout ce que vous vouliez savoir sur les tests d'adaptateurs Wi-Fi, mais aviez peur de demander</a></li>
<li><a href="../fr420419/index.html">Coureurs pour ceux qui aiment l'humiliation ou comment nous avons chang√© et modifi√© PixJam</a></li>
<li><a href="../fr420423/index.html">Probl√®mes d'interface avec le passage au sol</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>