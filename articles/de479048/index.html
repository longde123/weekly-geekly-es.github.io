<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüöí üåá üë®üèæ‚Äçüè≠ Node.js Streams f√ºr Dummies oder wie man mit Streams arbeitet üëßüèæ ‚ôªÔ∏è üëÉüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich denke, viele haben schon mehr als einmal von Node js Streams geh√∂rt, es aber nie benutzt oder benutzt, ohne dar√ºber nachzudenken, wie sie funktion...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js Streams f√ºr Dummies oder wie man mit Streams arbeitet</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479048/">  Ich denke, viele haben schon mehr als einmal von Node js Streams geh√∂rt, es aber nie benutzt oder benutzt, ohne dar√ºber nachzudenken, wie sie funktionieren, Streams und Normen weitergeleitet.  Lassen Sie uns herausfinden, was Streams sind: Pipe (Pipe), Chunks (Chunk - Teil der Daten) und all das. <br><br><img src="https://habrastorage.org/webt/m8/iv/cp/m8ivcpkrvfaq1vfm53mhxafmzna.jpeg"><br><a name="habracut"></a><br>  Warum ist es wichtig zu verstehen, wie Streams in Node js funktionieren?  Die Antwort ist einfach: Viele der in Node js integrierten Module implementieren Streams, z. B. HTTP-Anforderungen / -Antworten, fs-Lese- / Schreibzugriff, zlib, Krypto, TCP-Sockets und andere.  Sie ben√∂tigen auch Streams, wenn Sie beispielsweise gro√üe Dateien verarbeiten oder mit Bildern arbeiten.  Sie schreiben vielleicht nicht Ihren eigenen Stream, aber wenn Sie verstehen, wie er funktioniert, werden Sie zu einem kompetenteren Entwickler. <br><br>  Also, was genau ist ein Stream (im Folgenden werde ich anstelle von Stream (stream) verwenden).  Stream ist ein Konzept, mit dem Sie Daten in kleinen Teilen verarbeiten k√∂nnen, wodurch Sie eine kleine Menge an RAM verwenden k√∂nnen.  Mit seiner Hilfe k√∂nnen wir auch die Verarbeitung jedes Teils in voneinander unabh√§ngige Module (Funktionen oder Klassen) aufteilen.  Zum Beispiel k√∂nnen wir einen Teil der Daten sofort komprimieren, dann verschl√ºsseln und in eine Datei schreiben.  Die Hauptidee ist nicht, mit den gesamten Daten zu arbeiten, sondern einen Teil der Daten nach dem anderen zu verarbeiten. <br><br>  Es gibt 4 Arten von Streams in Node js: <br><br><ul><li>  Lesbar </li><li>  Beschreibbar - Schreiben </li><li>  Duplex - Lesen und Schreiben </li><li>  Transformieren - eine Art Duplex-Stream, der Daten √§ndern kann </li></ul><br>  Ausf√ºhrlichere Informationen finden Sie auf der offiziellen Website. Lassen Sie uns nun mit dem √úben fortfahren. <br><br><h3>  Einfaches Beispiel </h3><br>  Ich denke, dass viele Streams bereits benutzt haben, ohne es zu merken.  In diesem Beispiel senden wir die Datei einfach an den Client. <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 - ( )      ,         const getFile = async (req, res, next) =&gt; { const fileStream = fs.createReadStream('path to file'); res.contentType('application/pdf'); fileStream.pipe(res); }; // 2 - (  )         const getFile = async (req, res, next) =&gt; { const file = fs.readFileSync('path to file'); res.contentType('application/pdf'); res.send(file); };</span></span></code> </pre> <br>  Der einzige Unterschied besteht darin, dass wir im ersten Fall einen Teil der Datei herunterladen und senden und somit nicht den Arbeitsspeicher des Servers laden.  Im zweiten Fall laden wir sofort die gesamte Datei in den Arbeitsspeicher und senden sie erst dann. <br><br>  Weiter im Artikel werden wir jeden Stream separat analysieren.  Sie k√∂nnen einen Stream mithilfe der Vererbung oder der Konstruktorfunktion erstellen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Readable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 1 -   const myReadable = new Readable(opt); // 2 -   class myReadable extends Readable { constructor(opt) { super(opt); } }</span></span></code> </pre><br>  In allen Beispielen verwende ich 2 Methoden. <br><br><h3>  Lesbarer Stream </h3><br>  Schauen wir uns an, wie wir in NodeJS einen lesbaren Stream erstellen k√∂nnen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Readable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myReadable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Readable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); } _read(size) {} }</code> </pre><br>  Wie Sie aus dem obigen Beispiel sehen k√∂nnen, akzeptiert diese Klasse eine Reihe von Parametern.  Wir betrachten nur diejenigen, die f√ºr ein allgemeines Verst√§ndnis des Readable-Streams erforderlich sind, den Rest k√∂nnen Sie in der Dokumentation sehen.  Wir interessieren uns f√ºr den Parameter highWaterMark und die Methode _read. <br><br>  highWaterMark - Dies ist die maximale Anzahl von Bytes des internen Stream-Puffers (standardm√§√üig 16 KB), bei deren Erreichen der Lesevorgang von der Ressource unterbrochen wird.  Um weiterlesen zu k√∂nnen, m√ºssen wir den internen Puffer freigeben.  Wir k√∂nnen dies tun, indem wir die Pipe aufrufen, Methoden fortsetzen oder das Datenereignis abonnieren. <br><br>  _read ist eine Implementierung einer privaten Methode, die von internen Methoden der Readable-Klasse aufgerufen wird.  Es wird kontinuierlich aufgerufen, bis die Datengr√∂√üe highWaterMark erreicht. <br><br>  Nun, die letzte Methode, die uns interessiert, ist readable.push. Sie f√ºgt Daten direkt zum internen Puffer hinzu.  Es gibt true zur√ºck, aber sobald der Puffer voll ist, beginnt ein Aufruf dieser Methode, false zur√ºckzugeben.  Sie kann mit der readable._read-Methode gesteuert werden. <br><br>  Lassen Sie uns nun ein Beispiel sehen, um die Situation zu kl√§ren. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Readable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _read() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._index}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Added: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._index}</span></span></span><span class="hljs-string">. Could be added? `</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(buf)); } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${counter.read().toString()}</span></span></span><span class="hljs-string">`</span></span>);</code> </pre><br>  Zun√§chst m√∂chte ich sagen, dass counter.read () nicht das _read ist, das wir in der Klasse implementiert haben.  Diese Methode ist privat und diese ist √∂ffentlich und gibt Daten aus dem internen Puffer zur√ºck.  Wenn wir diesen Code ausf√ºhren, sehen wir in der Konsole Folgendes: <br><br><img src="https://habrastorage.org/webt/lg/yt/ih/lgytihuwtk4wpqbwz2p5xz2iudo.jpeg"><br><br>  Was ist hier passiert?  Beim Erstellen des neuen Counter-Streams ({highWaterMark: 2}) haben wir angegeben, dass die Gr√∂√üe unseres internen Puffers 2 Byte betragen w√ºrde, d. H.  kann 2 Zeichen speichern (1 Zeichen = 1 Byte).  Nach dem Aufruf von counter.read () beginnt der Stream mit dem Lesen, schreibt '1' in den internen Puffer und gibt ihn zur√ºck.  Dann liest er weiter und schreibt '2'.  Wenn '3' geschrieben wird, ist der Puffer voll, readable.push gibt false zur√ºck und der Stream wartet, bis der interne Puffer freigegeben ist.  Weil  In unserem Beispiel gibt es keine Logik, um den Puffer freizugeben. Das Skript wird beendet. <br><br>  Wie bereits erw√§hnt, m√ºssen wir den internen Puffer st√§ndig l√∂schen, um sicherzustellen, dass der Lesevorgang nicht unterbrochen wird.  Dazu abonnieren wir das Datenereignis.  Ersetzen Sie die letzten 2 Zeilen durch den folgenden Code. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); counter.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, chunk =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${chunk.toString()}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br>  Wenn wir jetzt dieses Beispiel ausf√ºhren, werden wir sehen, dass alles so funktioniert hat, wie es sollte, und die Zahlen von 1 bis 1000 werden in der Konsole angezeigt. <br><br><h3>  Schriftlicher Stream </h3><br>  Tats√§chlich ist es einem lesbaren Stream sehr √§hnlich, der nur zum Schreiben von Daten vorgesehen ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Writable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myWritable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); } _write(chunk, encoding, callback) {} }</code> </pre><br>  Es akzeptiert √§hnliche Parameter wie Readable Stream.  Wir interessieren uns f√ºr highWaterMark und _write. <br><br>  _write ist eine private Methode, die von den internen Methoden der Writable-Klasse zum Schreiben von Daten aufgerufen wird.  Es werden 3 Parameter ben√∂tigt: Chunk (Teil der Daten), Codierung (Codierung, wenn Chunk eine Zeichenfolge ist), R√ºckruf (eine Funktion, die nach einem erfolgreichen oder erfolglosen Schreibvorgang aufgerufen wird). <br><br>  highWaterMark ist die maximale Anzahl von Bytes des internen Stream-Puffers (standardm√§√üig 16 KB). Sobald stream.write erreicht ist, wird false zur√ºckgegeben. <br><br>  Lassen Sie uns das vorherige Beispiel mit einem Z√§hler umschreiben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Writable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writable</span></span></span><span class="hljs-class"> </span></span>{ _write(chunk, encoding, callback) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chunk.toString()); callback(); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { counter.write(Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>)); }</code> </pre><br>  In der Tat ist alles einfach, aber es gibt eine interessante Nuance, an die es sich zu erinnern lohnt!  Beim Erstellen des neuen Counter-Streams ({highWaterMark: 2}) haben wir angegeben, dass die Gr√∂√üe unseres internen Puffers 2 Byte betragen w√ºrde, d. H.  kann 2 Zeichen speichern (1 Zeichen = 1 Byte).  Wenn der Z√§hler zehn erreicht, wird der Puffer mit jedem Aufruf zum Schreiben gef√ºllt. Wenn also der Schreibvorgang auf eine langsame Quelle ausgef√ºhrt wird, werden alle anderen Daten beim Aufrufen von write im RAM gespeichert, was zu einem √úberlauf f√ºhren kann (in diesem Beispiel: Nat√ºrlich spielt es keine Rolle, da unser Puffer 2 Byte gro√ü ist. Bei gro√üen Dateien m√ºssen Sie sich dies merken.)  Wenn eine solche Situation auftritt, m√ºssen wir warten, bis der Stream den aktuellen Teil der Daten schreibt, den internen Puffer freigibt (das Drain-Ereignis ausl√∂st), und dann k√∂nnen wir die Aufzeichnung der Daten fortsetzen.  Lassen Sie uns unser Beispiel umschreiben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Writable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { once } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writable</span></span></span><span class="hljs-class"> </span></span>{ _write(chunk, encoding, callback) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chunk.toString()); callback(); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canWrite = counter.write(Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Can we write bunch of data? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${canWrite}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canWrite) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> events.once(counter, <span class="hljs-string"><span class="hljs-string">'drain'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'drain event fired.'</span></span>); } } })();</code> </pre><br>  Die events.once-Methode wurde in Version 11.13.0 hinzugef√ºgt und erm√∂glicht es Ihnen, ein Versprechen zu erstellen und auf die einmalige Ausf√ºhrung eines bestimmten Ereignisses zu warten.  In diesem Beispiel wird gepr√ºft, ob Daten in den Stream geschrieben werden k√∂nnen. Wenn nicht, warten Sie, bis der Puffer freigegeben ist, und fahren Sie mit der Aufzeichnung fort. <br><br>  Auf den ersten Blick scheint dies eine unn√∂tige Aktion zu sein. Wenn Sie jedoch mit gro√üen Datenmengen arbeiten, z. B. Dateien mit einem Gewicht von mehr als 10 GB, kann dies zu einem Speicherverlust f√ºhren. <br><br><h3>  Duplex-Stream </h3><br>  Es kombiniert lesbare und schreibbare Streams, dh, wir m√ºssen eine Implementierung der beiden Methoden _read und _write schreiben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Duplex } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myDuplex</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Duplex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); } _read(size) {} _write(chunk, encoding, callback) {} }</code> </pre><br>  Hier interessieren uns 2 Parameter, die wir an den Konstruktor √ºbergeben k√∂nnen, n√§mlich readableHighWaterMark und writableHighWaterMark, mit denen wir die Gr√∂√üe des internen Puffers f√ºr lesbare bzw. schreibbare Streams angeben k√∂nnen.  So sieht die Implementierung der beiden vorherigen Beispiele mit Hilfe des Duplex-Streams aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Duplex } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> events = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Duplex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _read() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._index}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(buf); } } _write(chunk, encoding, callback) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chunk.toString()); callback(); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">readableHighWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">writableHighWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chunk = counter.read(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (chunk !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canWrite = counter.write(chunk); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Can we write bunch of data? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${canWrite}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canWrite) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> events.once(counter, <span class="hljs-string"><span class="hljs-string">'drain'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'drain event fired.'</span></span>); } chunk = counter.read(); } })();</code> </pre><br>  Ich denke, dieser Code muss nicht erkl√§rt werden, da er derselbe ist wie zuvor, nur in einer Klasse. <br><br><h3>  Stream transformieren </h3><br>  Dieser Stream ist ein Duplex-Stream.  Es wird ben√∂tigt, um einen Teil der Daten zu konvertieren und weiter in der Kette zu senden.  Es kann auf die gleiche Weise wie der Rest des Streams implementiert werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Transform } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myTransform</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transform</span></span></span><span class="hljs-class"> </span></span>{ _ transform(chunk, encoding, callback) {} }</code> </pre><br>  Wir interessieren uns f√ºr die _transform-Methode. <br><br>  _transform ist eine private Methode, die von den internen Methoden der Transform-Klasse aufgerufen wird, um einen Datenblock zu transformieren.  Es werden 3 Parameter ben√∂tigt: chunk (Teil der Daten), encoding (Codierung, wenn chunk eine Zeichenfolge ist), callback (eine Funktion, die nach einem erfolgreichen oder erfolglosen Schreibvorgang aufgerufen wird). <br><br>  Mit dieser Methode wird ein Teil der Daten ge√§ndert.  Innerhalb dieser Methode k√∂nnen wir transform.push () null oder mehrmals aufrufen, wodurch die √Ñnderungen festgeschrieben werden.  Wenn wir die Datenkonvertierung abgeschlossen haben, m√ºssen wir einen R√ºckruf aufrufen, der alles sendet, was wir zu transform.push () hinzugef√ºgt haben.  Der erste Parameter dieser R√ºckruffunktion ist ein Fehler.  Au√üerdem k√∂nnen wir transform.push () nicht verwenden, sondern die ge√§nderten Daten als zweiten Parameter an die R√ºckruffunktion senden (Beispiel: R√ºckruf (null, Daten)).  Um zu verstehen, wie dieser Streamtyp verwendet wird, analysieren wir die stream.pipe-Methode. <br><br>  stream.pipe - Diese Methode wird verwendet, um den Readable-Stream mit dem Writable-Stream zu verbinden und Stream-Ketten zu erstellen.  Dies bedeutet, dass wir einen Teil der Daten lesen und zur Verarbeitung an den n√§chsten Stream und dann an den n√§chsten usw. √ºbertragen k√∂nnen. <br><br>  Schreiben wir einen Transformations-Stream, der das Zeichen * am Anfang und am Ende jedes Datenelements anf√ºgt. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterReader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Readable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _read() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._index}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(buf); } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterWriter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writable</span></span></span><span class="hljs-class"> </span></span>{ _write(chunk, encoding, callback) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chunk.toString()); callback(); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterTransform</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transform</span></span></span><span class="hljs-class"> </span></span>{ _transform(chunk, encoding, callback) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resultString = <span class="hljs-string"><span class="hljs-string">`*</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${chunk.toString(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'utf8'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">*`</span></span>; callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, resultString); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { callback(err); } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counterReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CounterReader({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counterWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CounterWriter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counterTransform = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CounterTransform({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); counterReader.pipe(counterTransform).pipe(counterWriter);</code> </pre><br>  In diesem Beispiel habe ich Readable- und Writable-Streams aus den vorherigen Beispielen verwendet und au√üerdem Transform hinzugef√ºgt.  Wie Sie sehen, hat es sich als ziemlich einfach erwiesen. <br><br>  Also haben wir uns angesehen, wie die Streams angeordnet sind.  Ihr Hauptkonzept ist die teilweise Datenverarbeitung, die sehr komfortabel ist und keine gro√üen Ressourcen erfordert.  Streams k√∂nnen auch mit Iteratoren verwendet werden, was ihre Verwendung noch komfortabler macht, aber dies ist eine ganz andere Geschichte. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479048/">https://habr.com/ru/post/de479048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479036/index.html">Intel kann die Nachfrage nach Prozessoren nicht befriedigen. HP und Dell leiden darunter</a></li>
<li><a href="../de479038/index.html">Digitale Transformation Leroy Merlin: Entwerfen einer Schnittstelle f√ºr die Arbeit mit Kundenanrufen</a></li>
<li><a href="../de479040/index.html">Visuelle Regressionstests. Starten Sie neu</a></li>
<li><a href="../de479042/index.html">Mit der Y-Methode k√∂nnen Sie ganz einfach einen Rubik's Cube erstellen</a></li>
<li><a href="../de479044/index.html">Meine Ringpuffer-Implementierung in NOR-Flash</a></li>
<li><a href="../de479050/index.html">Patentrecherche in der IT. Der Kurs des jungen K√§mpfers. Teil II Informationsquellen f√ºr die Patentrecherche</a></li>
<li><a href="../de479052/index.html">[Supercomputing 2019]. Multi-Cloud-Speicher als Anwendung f√ºr neue Kingston DC1000M-Laufwerke</a></li>
<li><a href="../de479054/index.html">Mobile Umfrage am Freitag</a></li>
<li><a href="../de479056/index.html">√úber das Leben reden? DREAM Team bei der Alexa Prize Socialbot Challenge 3</a></li>
<li><a href="../de479058/index.html">√úberwachung als Ereignisverwaltungsprozess</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>