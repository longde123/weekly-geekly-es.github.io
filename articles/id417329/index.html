<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎩 🍤 🦒 Anda dan Brad Pitt 99% 📏 👩🏾‍🏫 🧚🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami di departemen analitik sinema daring Okko senang mengotomatiskan perhitungan biaya film Alexander Nevsky sebanyak mungkin, dan di waktu luang unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anda dan Brad Pitt 99%</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/okko/blog/417329/"><p><img src="https://habrastorage.org/webt/bg/8z/-p/bg8z-pmvxneor2kulnu9tmg3qoy.jpeg" alt="Besok sedang liburan"></p><br><p>  Kami di departemen analitik sinema daring <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Okko</a> senang mengotomatiskan perhitungan biaya film Alexander Nevsky sebanyak mungkin, dan di waktu luang untuk mempelajari hal-hal baru dan menerapkan hal-hal keren yang karena alasan tertentu biasanya diterjemahkan menjadi bot untuk Telegram.  Misalnya, sebelum dimulainya Piala Dunia FIFA 2018, kami meluncurkan bot untuk obrolan yang berfungsi, yang mengumpulkan taruhan pada distribusi tempat terakhir, dan setelah final, kami menghitung hasil berdasarkan metrik yang telah ditemukan sebelumnya dan menentukan pemenang.  Kroasia belum menempatkan empat di empat besar. </p><br><p>  Waktu luang terakhir dari menyusun komedi TOP-10 Rusia yang kami persembahkan untuk membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bot</a> yang menemukan selebriti yang paling mirip dengan pengguna.  Dalam obrolan yang berhasil, semua orang sangat menghargai gagasan itu sehingga kami memutuskan untuk membuat bot tersedia untuk umum.  Pada artikel ini, kami mengingat teori secara singkat, berbicara tentang pembuatan bot kami dan bagaimana melakukannya sendiri. </p><a name="habracut"></a><br><h1 id="nemnogo-teorii-v-osnovnom-v-kartinkah">  Sedikit teori (kebanyakan dalam gambar) </h1><br><p> Secara rinci tentang bagaimana sistem pengenalan wajah diatur, saya bicarakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu artikel saya sebelumnya</a> .  Pembaca yang tertarik dapat mengikuti tautan, dan saya akan menguraikan di bawah ini hanya poin utama. </p><br><p>  Jadi, Anda memiliki foto di mana, mungkin, bahkan wajah ditampilkan dan Anda ingin memahami siapa itu.  Untuk melakukan ini, Anda harus mengikuti 4 langkah sederhana: </p><br><ol><li>  Pilih persegi panjang yang membatasi wajah. </li><li>  Sorot titik-titik kunci wajah. </li><li>  Sejajarkan dan potong wajah Anda. </li><li>  Ubah gambar wajah menjadi representasi yang diinterpretasikan dengan mesin. </li><li>  Bandingkan tampilan ini dengan yang lain yang Anda miliki. </li></ol><br><h3 id="vydelenie-lica">  Seleksi wajah </h3><br><p>  Meskipun jaringan saraf convolutional baru-baru ini belajar bagaimana menemukan wajah dalam gambar tidak lebih buruk dari metode klasik, mereka masih kalah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HOG</a> klasik dalam kecepatan dan kemudahan penggunaan. </p><br><p>  HOG - Histogram Gradien Berorientasi.  Orang ini mengaitkan setiap piksel dari gambar sumber dengan gradiennya - vektor ke arah yang paling banyak mengubah kecerahan piksel.  Keuntungan dari pendekatan ini adalah bahwa ia tidak peduli dengan nilai absolut dari kecerahan piksel, hanya rasio mereka cukup.  Oleh karena itu, wajah normal, dan gelap, dan kurang terang, dan berisik akan ditampilkan dalam kira-kira histogram gradien yang sama. </p><br><p><img src="https://habrastorage.org/webt/ke/_h/b_/ke_hb_cyd3odkvkwmqb0soancka.png" alt="Histogram gradien wajah Arah"></p><br><p> Tidak perlu menghitung gradien untuk setiap piksel, cukup untuk menghitung gradien rata-rata untuk setiap kotak kecil <code>n</code> oleh <code>n</code> .  Menggunakan bidang vektor yang diterima, Anda kemudian dapat pergi melalui beberapa detektor dengan jendela dan menentukan untuk setiap jendela seberapa besar kemungkinan wajah di dalamnya.  Detektor dapat berupa SVM, hutan acak, atau apa pun. </p><br><p><img src="https://habrastorage.org/webt/mz/hk/2y/mzhk2ycaurneywpy32a0linnm3o.png" alt="Deteksi wajah"></p><br><h3 id="vydelenie-klyuchevyh-tochek">  Sorot Poin-Poin Utama </h3><br><p><img src="https://habrastorage.org/webt/wd/bi/dc/wdbidcix45fpf74iglc7f0f1rpg.png" alt="Poin-poin penting dari wajah"></p><br><p>  Poin kunci adalah poin yang membantu mengidentifikasi seseorang di luar angkasa.  Lemah dan tidak aman Para ilmuwan biasanya membutuhkan 68 poin utama, dan terutama dalam kasus yang diabaikan, bahkan lebih.  Anak laki-laki normal dan percaya diri, berpenghasilan 300rb per detik, selalu punya cukup lima: sudut dalam dan luar mata dan hidung. </p><br><p><img src="https://habrastorage.org/webt/6t/tb/-8/6ttb-8bq0ugffanbs0qcrihy2a4.jpeg" alt="Meme tua"></p><br><p>  Poin-poin seperti itu dapat diekstraksi, misalnya, dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kaskade regressor</a> . </p><br><h3 id="vyravnivanie-lica">  Perataan wajah </h3><br><p>  Aplikasi terpaku di masa kecil?  Di sini semuanya persis sama: Anda membangun transformasi affine yang menerjemahkan tiga titik arbitrer ke posisi standar mereka.  Hidung bisa dibiarkan apa adanya, tetapi agar mata menghitung pusatnya - ini adalah tiga poin yang siap. </p><br><p><img src="https://habrastorage.org/webt/ms/3q/s7/ms3qs7hagupsaooas-eqrjjmqpy.png" alt="Putar muka"></p><br><h3 id="preobrazovanie-izobrazheniya-lica-v-vektor">  Ubah gambar wajah menjadi vektor </h3><br><p><img src="https://habrastorage.org/webt/ab/8w/jo/ab8wjody73ybfs_opnftpipbcz0.png" alt="Meme kurang tua"></p><br><p>  Tiga tahun telah berlalu sejak penerbitan artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FaceNet</a> , selama ini banyak skema pelatihan yang menarik dan fungsi kerugian muncul, tetapi dialah yang mendominasi di antara solusi OpenSource yang tersedia.  Tampaknya, semuanya adalah kombinasi dari kemudahan pemahaman, implementasi dan hasil yang layak.  Terima kasih setidaknya untuk fakta bahwa selama tiga tahun terakhir arsitektur telah diubah menjadi ResNet. </p><br><p><img src="https://habrastorage.org/webt/af/pt/cx/afptcx5ixcu2r0_mjkckckpt2zo.jpeg" alt="Meme baru"></p><br><p>  FaceNet belajar dari tiga kali lipat contoh: (jangkar, positif, negatif).  Anchor dan contoh positif adalah milik satu orang, sedangkan negatif dipilih sebagai wajah orang lain, yang karena beberapa alasan jaringan terlalu dekat dengan yang pertama.  Fungsi kerugian dirancang sedemikian rupa untuk memperbaiki kesalahpahaman ini, menyatukan contoh-contoh yang diperlukan dan memindahkan yang tidak perlu dari mereka. </p><br><p><img src="https://habrastorage.org/webt/tp/yf/sw/tpyfswhgnyco4w_0ap3zy8i5zhs.png" alt="Guccinet"></p><br><p><img src="https://habrastorage.org/webt/gj/fi/zq/gjfizqzcwjybnypbv-ugovr5hl0.png" alt="Wajah wajah dan Dmitry Malikov"></p><br><p>  Output dari lapisan terakhir dari jaringan disebut embedding - representasi representatif dari seseorang dalam ruang tertentu dari dimensi kecil (biasanya 128 dimensi). </p><br><h3 id="sravnenie-lic">  Perbandingan wajah </h3><br><p>  Keindahan embeddings terlatih adalah bahwa wajah satu orang ditampilkan di beberapa lingkungan kecil ruang, jauh dari embed wajah orang lain.  Jadi, untuk ruang ini Anda dapat memasukkan ukuran kesamaan, kebalikan dari jarak: Euclidean atau cosinus, tergantung pada jarak yang dilatih jaringan. </p><br><p><img src="https://habrastorage.org/webt/pn/u8/ba/pnu8barwdzvdryma24yezil7kvo.jpeg" alt="Contoh embedding yang sepenuhnya buatan"></p><br><p>  Jadi, sebelumnya kita perlu membuat embed untuk semua orang di antaranya pencarian akan dilakukan, dan kemudian, untuk setiap permintaan, temukan vektor terdekat di antara mereka.  Atau, dengan cara lain, selesaikan masalah menemukan <code>k</code> tetangga terdekat, di mana <code>k</code> mungkin sama dengan satu, atau mungkin tidak, jika kita ingin menggunakan beberapa logika bisnis yang lebih maju.  Orang yang memiliki vektor hasil akan paling mirip dengan orang yang meminta. </p><br><p><img src="https://habrastorage.org/webt/6f/uz/nx/6fuznxdig3uiw1mjuv1eezx5h3u.jpeg" alt="Kesamaan tatap muka tidak dengan tatap muka"></p><br><h3 id="kakuyu-biblioteku-ispolzovat">  Perpustakaan mana yang digunakan? </h3><br><p>  Pilihan perpustakaan terbuka yang menerapkan berbagai bagian pipa sangat bagus.  <code>dlib</code> dan <code>OpenCV</code> dapat menemukan wajah dan titik kunci, dan versi jaringan yang sudah dilatih sebelumnya dapat ditemukan untuk kerangka kerja jaringan saraf besar.  Ada proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenFace di</a> mana Anda dapat memilih arsitektur untuk kebutuhan kecepatan dan kualitas Anda.  Tetapi hanya satu perpustakaan yang memungkinkan Anda untuk menerapkan semua 5 poin pengenalan wajah dalam panggilan ke tiga fungsi tingkat tinggi: <code>dlib</code> .  Pada saat yang sama, ini ditulis dalam C ++ modern, menggunakan BLAS, memiliki pembungkus untuk Python, tidak memerlukan GPU, dan bekerja cukup cepat pada CPU.  Pilihan kita jatuh padanya. </p><br><h1 id="delaem-sobstvennogo-bota">  Membuat bot Anda sendiri </h1><br><p>  Bagian ini telah dijelaskan dalam setiap panduan untuk membuat bot, tetapi setelah kami menulisnya, kami harus mengulanginya.  Kami menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@BotFather</a> dan meminta tanda untuk bot baru kami. </p><br><p><img src="https://habrastorage.org/webt/um/qe/ew/umqeewdk64wtealh1ldudqsv0m8.png" alt="Mengaburkan tanda xs Fakta"></p><br><p>  <code>643075690:AAFC8ola8WRdhGbJtzjmkOhne1FGfu1BFg</code> terlihat seperti ini: <code>643075690:AAFC8ola8WRdhGbJtzjmkOhne1FGfu1BFg</code> .  Diperlukan otorisasi pada setiap permintaan ke API bot Telegram. </p><br><p>  Saya harap tidak ada seorang pun di tahap ini yang memiliki keraguan ketika memilih bahasa pemrograman.  Tentu saja, Anda harus menulis di Haskell.  Mari kita mulai dengan modul utama. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Process main :: IO () main = do (<span class="hljs-title"><span class="hljs-title">_</span></span>, <span class="hljs-title"><span class="hljs-title">_</span></span>, <span class="hljs-title"><span class="hljs-title">_</span></span>, <span class="hljs-title"><span class="hljs-title">handle</span></span>) &lt;- createProcess (<span class="hljs-title"><span class="hljs-title">shell</span></span> "<span class="hljs-title"><span class="hljs-title">python</span></span> <span class="hljs-title"><span class="hljs-title">bot</span></span>.<span class="hljs-title"><span class="hljs-title">py</span></span>") _ &lt;- waitForProcess handle putStrLn "Done!"</code> </pre> <br><p>  Seperti yang dapat Anda lihat dari kode, di masa depan kita akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DSL</a> khusus untuk menulis bot telegram.  Kode pada DSL ini ditulis dalam file terpisah.  Instal bahasa domain dan semua yang diperlukan. </p><br><pre> <code class="bash hljs">python -m venv .env <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> .env/bin/activate pip install python-telegram-bot</code> </pre> <br><p>  <code>python-telegram-bot</code> saat ini merupakan kerangka kerja yang paling nyaman untuk membuat bot.  Mudah dipelajari, fleksibel, dapat diskalakan, mendukung multithreading.  Sayangnya, saat ini tidak ada kerangka asinkron normal tunggal dan utas kuno harus digunakan sebagai pengganti coroutine ilahi. </p><br><p><img src="https://habrastorage.org/webt/t2/8b/qv/t28bqvhxxznqmzsobr4hjmuxlta.jpeg" alt="asyncio adalah satu-satunya tuhan saya"></p><br><p>  Memulai bot dengan <code>python-telegram-bot</code> mudah.  Tambahkan kode berikut ke <code>bot.py</code> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Updater <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MessageHandler, Filters <span class="hljs-comment"><span class="hljs-comment">#      TOKEN = '&lt;TOKEN&gt;' def echo(bot, update): bot.send_message(chat_id=update.message.chat_id, text=update.message.text) updater = Updater(token=TOKEN) dispatcher = updater.dispatcher echo_handler = MessageHandler(Filters.text, echo) dispatcher.add_handler(echo_handler)</span></span></code> </pre> <br><p>  Jalankan bot.  Untuk keperluan debugging, ini bisa dilakukan dengan perintah <code>python bot.py</code> tanpa menjalankan kode Haskell. </p><br><p>  Bot sederhana semacam itu mampu mempertahankan percakapan minimum, dan karenanya, dapat dengan mudah diatur untuk berfungsi sebagai pengembang front-end. </p><br><p><img src="https://habrastorage.org/webt/xs/pk/sm/xspksm1d8ehnslmqjsj33dzyekm.png" alt="Dialog khas dengan pengembang front-end"></p><br><p>  Tetapi ujung depan pengembang sudah terlalu banyak, jadi kami akan membunuhnya sesegera mungkin dan melanjutkan untuk mengimplementasikan fungsi utama.  Demi kesederhanaan, bot kami hanya akan membalas pesan yang berisi foto dan mengabaikan yang lainnya.  Ubah kode menjadi yang berikut. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Updater <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MessageHandler, Filters <span class="hljs-comment"><span class="hljs-comment">#      TOKEN = '&lt;TOKEN&gt;' def handle_photo(bot, update): bot.send_message(chat_id=update.message.chat_id, text='nice') updater = Updater(token=TOKEN) dispatcher = updater.dispatcher photo_handler = MessageHandler(Filters.photo, handle_photo) dispatcher.add_handler(photo_handler) updater.start_polling() updater.idle()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/-8/1k/hq/-81khq5z9redcz29_ut7sunfrpg.png" alt="Sudah bukan pengembang front-end"></p><br><p>  Ketika gambar memasuki server Telegram, gambar itu secara otomatis disesuaikan ke beberapa ukuran yang telah ditentukan.  Bot, pada gilirannya, dapat mengunduh gambar dalam berbagai ukuran dari yang ada di daftar <code>message.photo</code> diurutkan dalam urutan menaik.  Opsi termudah: ambil gambar terbesar.  Tentu saja, di lingkungan toko bahan makanan, Anda perlu memikirkan tentang beban jaringan dan waktu muat serta memilih gambar dengan ukuran minimum yang sesuai.  Tambahkan kode unduhan gambar ke bagian atas fungsi <code>handle_photo</code> . </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io</code> </pre> <br><pre> <code class="python hljs">message = update.message photo = message.photo[~<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> io.BytesIO() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fd: file_id = bot.get_file(photo.file_id) file_id.download(out=fd) fd.seek(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  Gambar telah diunduh dan ada di memori.  Untuk menafsirkannya dan menyajikannya dalam bentuk matriks intensitas piksel, kami menggunakan perpustakaan <code>Pillow</code> dan <code>numpy</code> . </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre> <br><p>  Kode berikut perlu ditambahkan ke blok <code>with</code> . </p><br><pre> <code class="python hljs">image = Image.open(fd) image.load() image = np.asarray(image)</code> </pre> <br><p>  Waktunya telah tiba dlib.  Di luar fungsinya, buat pendeteksi wajah. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dlib</code> </pre> <br><pre> <code class="python hljs">face_detector = dlib.get_frontal_face_detector()</code> </pre> <br><p>  Dan di dalam fungsi kita menggunakannya. </p><br><pre> <code class="python hljs">face_detects = face_detector(image, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Parameter kedua dari fungsi berarti perbesaran yang harus diterapkan sebelum mencoba untuk mendeteksi wajah.  Semakin besar, semakin kecil dan kompleks wajah detektor akan dapat dideteksi, tetapi semakin lama akan berfungsi.  <code>face_detects</code> - daftar wajah yang diurutkan dalam urutan menurun dari kepercayaan detektor bahwa wajah ada di depannya.  Dalam aplikasi nyata, Anda kemungkinan besar akan ingin menerapkan beberapa logika memilih orang utama, dan dalam studi kasus kami akan membatasi diri untuk memilih yang pertama. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> face_detects: bot.send_message(chat_id=update.message.chat_id, text=<span class="hljs-string"><span class="hljs-string">'no faces'</span></span>) face = face_detects[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br><p>  Kami melanjutkan ke tahap berikutnya - mencari poin-poin penting.  Unduh <a href="">model yang terlatih</a> dan pindahkan muatannya ke luar fungsi. </p><br><pre> <code class="python hljs">shape_predictor = dlib.shape_predictor(<span class="hljs-string"><span class="hljs-string">'path/to/shape_predictor_5_face_landmarks.dat'</span></span>)</code> </pre> <br><p>  Temukan poin kunci. </p><br><pre> <code class="python hljs">landmarks = shape_predictor(image, face)</code> </pre> <br><p>  Satu-satunya yang tersisa adalah kecil: untuk meluruskan wajah, mengendarainya melalui ResNet dan mendapatkan embedding 128 dimensi.  Untungnya, dlib memungkinkan Anda melakukan semua ini dengan satu panggilan.  Anda hanya perlu mengunduh model <a href="">pra-terlatih</a> . </p><br><pre> <code class="python hljs">face_recognition_model = dlib.face_recognition_model_v1(<span class="hljs-string"><span class="hljs-string">'path/to/dlib_face_recognition_resnet_model_v1.dat'</span></span>)</code> </pre> <br><pre> <code class="python hljs">embedding = face_recognition_model.compute_face_descriptor(image, landmarks) embedding = np.asarray(embedding)</code> </pre> <br><p>  Lihat saja betapa indahnya waktu kita hidup.  Seluruh kerumitan jaringan saraf convolutional, metode vektor dukungan, dan transformasi affine yang diterapkan untuk pengenalan wajah dirangkum dalam tiga panggilan perpustakaan. </p><br><p>  Karena kita belum tahu bagaimana melakukan sesuatu yang berarti, mari kembali kepada pengguna nilai rata-rata penanamannya, dikalikan dengan seribu. </p><br><pre> <code class="python hljs">bot.send_message( chat_id=update.message.chat_id, text=<span class="hljs-string"><span class="hljs-string">f'yours embedding mean: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{embedding.mean() * </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1e3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">:</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">.2</span></span></span></span><span class="hljs-string"><span class="hljs-subst">f}</span></span></span><span class="hljs-string">'</span></span> )</code> </pre> <br><p><img src="https://habrastorage.org/webt/ud/av/o6/udavo6i5srwrl93jbopenn84tae.png" alt="Saya tidak tahu apa yang harus saya lakukan"></p><br><p>  Agar bot kami dapat menentukan selebriti mana yang disukai pengguna, kami sekarang perlu menemukan setidaknya satu foto dari setiap selebriti, membuat embedding di atasnya dan menyimpannya di suatu tempat.  Kami hanya akan menambahkan 10 selebritas ke bot pelatihan kami, menemukan foto-foto mereka dengan tangan dan meletakkannya di direktori <code>photos</code> .  Seperti inilah seharusnya tampilannya: </p><br><p><img src="https://habrastorage.org/webt/yz/rd/1o/yzrd1ockvqezvybwzo-yulsivqq.png" alt="Dengar, aku tidak punya cukup uang untuk MacBook."></p><br><p>  Jika Anda ingin memiliki satu juta selebritas dalam basis data, semuanya akan terlihat sama persis, hanya ada lebih banyak file dan tidak mungkin Anda bisa mencarinya dengan tangan Anda.  Sekarang mari kita buat utilitas <code>build_embeddings.py</code> menggunakan panggilan <code>dlib</code> sudah kita ketahui dan menyimpan embeddings selebriti beserta nama mereka dalam format biner. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image face_detector = dlib.get_frontal_face_detector() shape_predictor = dlib.shape_predictor(<span class="hljs-string"><span class="hljs-string">'assets/shape_predictor_5_face_landmarks.dat'</span></span>) face_recognition_model = dlib.face_recognition_model_v1(<span class="hljs-string"><span class="hljs-string">'assets/dlib_face_recognition_resnet_model_v1.dat'</span></span>) fs = os.listdir(<span class="hljs-string"><span class="hljs-string">'photos'</span></span>) es = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fs: print(f) image = np.asarray(Image.open(os.path.join(<span class="hljs-string"><span class="hljs-string">'photos'</span></span>, f))) face_detects = face_detector(image, <span class="hljs-number"><span class="hljs-number">1</span></span>) face = face_detects[<span class="hljs-number"><span class="hljs-number">0</span></span>] landmarks = shape_predictor(image, face) embedding = face_recognition_model.compute_face_descriptor(image, landmarks, num_jitters=<span class="hljs-number"><span class="hljs-number">10</span></span>) embedding = np.asarray(embedding) name, _ = os.path.splitext(f) es.append((name, embedding)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'assets/embeddings.pickle'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: pickle.dump(es, f)</code> </pre> <br><p>  Tambahkan pemuatan sematan ke kode bot kami. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'assets/embeddings.pickle'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: star_embeddings = pickle.load(f)</code> </pre> <br><p>  Dan dengan pencarian lengkap kami akan menemukan siapa pengguna kami yang sama. </p><br><pre> <code class="python hljs">ds = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name, emb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> star_embeddings: distance = np.linalg.norm(embedding - emb) ds.append((name, distance)) best_match, best_distance = min(ds, key=itemgetter(<span class="hljs-number"><span class="hljs-number">1</span></span>)) bot.send_message( chat_id=update.message.chat_id, text=<span class="hljs-string"><span class="hljs-string">f'your look exactly like *</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{best_match}</span></span></span><span class="hljs-string">*'</span></span>, parse_mode=<span class="hljs-string"><span class="hljs-string">'Markdown'</span></span> )</code> </pre> <br><p>  Harap dicatat bahwa kami menggunakan jarak Euclidean sebagai jarak, karena  jaringan di dlib dilatih dengan tepat dengan bantuannya. </p><br><p><img src="https://habrastorage.org/webt/yd/fl/wi/ydflwigundswx6_qbctjir_itge.png" alt="Saya kecewa dengan artikel itu"></p><br><p>  Itu saja, selamat!  Kami telah membuat bot sederhana yang dapat menentukan selebriti yang disukai pengguna.  Tetap menemukan lebih banyak foto, menambahkan branding, skalabilitas, sedikit logging dan semuanya dapat dirilis dalam produksi.  Semua topik ini terlalu tebal untuk dibicarakan secara rinci dengan daftar kode besar, jadi saya hanya akan menguraikan poin utama dalam format tanya jawab di bagian berikutnya. </p><br><p>  Kode bot pelatihan lengkap tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . </p><br><h1 id="rasskazyvaem-pro-nashego-bota">  Kami berbicara tentang bot kami </h1><br><h3 id="skolko-u-vas-v-baze-znamenitostey-gde-vy-ih-nashli">  Berapa banyak selebriti yang Anda miliki di basis data Anda?  Di mana Anda menemukannya? </h3><br><p>  Keputusan paling logis saat membuat bot sepertinya mengambil data selebritas dari basis konten internal kami.  Dia dalam format grafik menyimpan film dan semua entitas yang terkait dengan film, termasuk aktor dan sutradara.  Untuk setiap orang, kami tahu namanya, login dan kata sandi dari iCloud, film terkait dan alias, yang dapat digunakan untuk menghasilkan tautan ke situs.  Setelah membersihkan dan mengekstraksi hanya informasi yang diperlukan, file <code>json</code> tetap sebagai berikut: </p><br><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"alias"</span></span>: <span class="hljs-string"><span class="hljs-string">"tilda-swinton"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"role"</span></span>: <span class="hljs-string"><span class="hljs-string">"actor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"n_movies"</span></span>: <span class="hljs-number"><span class="hljs-number">14</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"alias"</span></span>: <span class="hljs-string"><span class="hljs-string">"michael-shannon"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"role"</span></span>: <span class="hljs-string"><span class="hljs-string">"actor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"n_movies"</span></span>: <span class="hljs-number"><span class="hljs-number">22</span></span> }, ... ]</code> </pre> <br><p>  Ada <strong>22.000</strong> entri seperti itu di katalog.  Ngomong-ngomong, bukan katalog, tapi katalog. </p><br><h3 id="gde-nayti-fotografii-dlya-vseh-etih-lyudey">  Di mana menemukan foto untuk semua orang ini? </h3><br><p><img src="https://habrastorage.org/webt/_n/5i/pl/_n5iplsi4yqnrm2lpvzyjwhjigm.jpeg" alt="Di masa-masa berbahaya kita hidup"></p><br><p>  Ya, Anda tahu, <em>di sana-sini</em> .  Misalnya, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan</a> yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">luar biasa</a> yang memungkinkan Anda untuk mengunggah hasil permintaan gambar dari Google.  22 ribu orang - tidak banyak, menggunakan 56 aliran kami berhasil mengunduh foto untuk mereka dalam waktu kurang dari satu jam. </p><br><p>  Di antara foto yang diunduh, Anda harus membuang foto yang rusak, berisik, dalam format yang salah.  Kemudian tinggalkan hanya yang ada wajah dan yang memenuhi kondisi tertentu: jarak minimum antara mata, kemiringan kepala.  Semua ini memberi kita <strong>12.000</strong> foto. </p><br><p>  Dari 12 ribu selebritas, pengguna hanya menemukan 2 saat ini, yaitu ada sekitar 8 ribu selebritas yang masih belum seperti orang lain.  Jangan biarkan begitu saja!  Buka telegram dan temukan semuanya. </p><br><h3 id="kak-opredelit-procent-shozhesti-dlya-evklidovoy-distancii">  Bagaimana cara menentukan persentase kesamaan untuk jarak Euclidean? </h3><br><p>  Pertanyaan bagus!  Memang, jarak Euclidean, berbeda dengan cosinus, tidak dibatasi di atas.  Oleh karena itu, muncul pertanyaan yang masuk akal, bagaimana menunjukkan kepada pengguna sesuatu yang lebih bermakna daripada "Selamat, jarak antara penyematan Anda dan penyematan Angelina Jolie adalah 0,27635462738"?  Salah satu anggota tim kami mengusulkan solusi sederhana dan cerdik berikut ini.  Jika Anda membangun distribusi jarak antara embed, itu akan menjadi normal.  Jadi, baginya, Anda dapat menghitung rata-rata dan standar deviasi, dan kemudian untuk setiap pengguna, menurut parameter ini, pertimbangkan <em>berapa persen orang yang kurang seperti selebritas mereka daripada dirinya</em> .  Ini sama dengan mengintegrasikan fungsi kerapatan probabilitas dari <code>d</code> hingga plus tak terhingga, di mana <code>d</code> adalah jarak antara pengguna dan demonstrasi selebriti. </p><br><p><img src="https://habrastorage.org/webt/fh/yc/4r/fhyc4r87otryweg9v-xznackhfq.png" alt="Ini bukan seaborn"></p><br><p>  Berikut adalah fungsi persis yang kami gunakan: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_transform_dist_to_sim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, dist)</span></span></span><span class="hljs-function">:</span></span> p = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> + erf((dist - self._dist_mean) / (self._dist_std * <span class="hljs-number"><span class="hljs-number">1.4142135623730951</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(min(<span class="hljs-number"><span class="hljs-number">1</span></span> - p, <span class="hljs-number"><span class="hljs-number">1.0</span></span>), self._min_similarity)</code> </pre> <br><h3 id="neuzheli-nuzhno-perebirat-spisok-vseh-embedingov-chtoby-nayti-sovpadenie">  Apakah benar-benar perlu untuk mengulangi daftar semua serikat pekerja untuk menemukan kecocokan? </h3><br><p>  Tentu saja tidak, ini tidak optimal dan membutuhkan banyak waktu.  Cara termudah untuk mengoptimalkan perhitungan adalah dengan menggunakan operasi matriks.  Alih-alih mengurangi vektor dari satu sama lain, Anda dapat menyusun matriks dari mereka dan mengurangi vektor dari matriks, dan kemudian menghitung norma L2 dalam baris. </p><br><pre> <code class="python hljs">scores = np.linalg.norm(emb - embeddings, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) best_idx = scores.argmax()</code> </pre> <br><p>  Ini sudah memberi peningkatan besar dalam produktivitas, tetapi, ternyata, Anda bahkan bisa lebih cepat.  Pencarian dapat dipercepat secara signifikan dengan kehilangan sedikit dalam akurasinya menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nmslib</a> .  Ia menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HNSW</a> untuk memperkirakan pencarian <code>k</code> tetangga terdekat.  Untuk semua vektor yang tersedia, indeks yang disebut harus dibangun, di mana kemudian pencarian akan dilakukan.  Anda dapat membuat dan menyimpan indeks untuk jarak Euclidean sebagai berikut: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> nmslib index = nmslib.init(method=<span class="hljs-string"><span class="hljs-string">'hnsw'</span></span>, space=<span class="hljs-string"><span class="hljs-string">'l2'</span></span>, data_type=nmslib.DataType.DENSE_VECTOR) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx, emb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(embeddings): index.addDataPoint(idx, emb) index_time_params = { <span class="hljs-string"><span class="hljs-string">'indexThreadQty'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'skip_optimized_index'</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'post'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'delaunay_type'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'M'</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'efConstruction'</span></span>: <span class="hljs-number"><span class="hljs-number">2000</span></span> } index.createIndex(index_time_params, print_progress=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) index.saveIndex(<span class="hljs-string"><span class="hljs-string">'./assets/embeddings.bin'</span></span>)</code> </pre> <br><p>  Parameter <code>M</code> dan <code>efConstruction</code> dijelaskan secara rinci dalam <a href="">dokumentasi</a> dan dipilih secara eksperimental berdasarkan akurasi yang diperlukan, waktu konstruksi indeks dan kecepatan pencarian.  Sebelum menggunakan indeks, Anda harus mengunduh: </p><br><pre> <code class="python hljs">index = nmslib.init(method=<span class="hljs-string"><span class="hljs-string">'hnsw'</span></span>, space=<span class="hljs-string"><span class="hljs-string">'l2'</span></span>, data_type=nmslib.DataType.DENSE_VECTOR) index.loadIndex(<span class="hljs-string"><span class="hljs-string">'./assets/embeddings.bin'</span></span>) query_time_params = {<span class="hljs-string"><span class="hljs-string">'efSearch'</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>} index.setQueryTimeParams(query_time_params)</code> </pre> <br><p>  Parameter <code>efSearch</code> memengaruhi keakuratan dan kecepatan kueri dan mungkin tidak cocok dengan <code>efConstruction</code> .  Sekarang Anda dapat membuat permintaan. </p><br><pre> <code class="python hljs">ids, dists = index.knnQuery(embedding, k=<span class="hljs-number"><span class="hljs-number">1</span></span>) best_dx = ids[<span class="hljs-number"><span class="hljs-number">0</span></span>] best_dist = dists[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br><p>  Dalam kasus kami, <code>nmslib</code> adalah 20 kali lebih cepat dari versi linier vektor, dan satu permintaan diproses rata-rata <code>0.005</code> detik. </p><br><h3 id="kak-sdelat-moego-bota-gotovym-k-prodakshenu">  Bagaimana cara membuat bot saya siap untuk produksi? </h3><br><h5 id="1-asinhronnost">  1. Asynchrony </h5><br><p>  Pertama, Anda perlu membuat fungsi <code>handle_photo</code> asinkron.  Seperti yang sudah saya katakan, <code>python-telegram-bot</code> menawarkan multithreading untuk ini dan mengimplementasikan dekorator yang nyaman. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext.dispatcher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> run_async @run_async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_photo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bot, update)</span></span></span><span class="hljs-function">:</span></span> ...</code> </pre> <br><p>  Sekarang framework itu sendiri akan meluncurkan handler Anda di utas terpisah di kumpulannya.  Ukuran kumpulan diatur saat membuat <code>Updater</code> .  "Tapi dengan python tidak ada multithreading!"  yang paling tidak sabar dari Anda sudah berseru.  Dan ini tidak sepenuhnya benar.  Karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GIL,</a> kode Python biasa benar-benar tidak dapat dieksekusi secara paralel, tetapi GIL dirilis untuk menunggu semua operasi IO, dan itu juga dapat dirilis oleh perpustakaan yang menggunakan ekstensi C. </p><br><p>  Sekarang menganalisis fungsi <code>handle_photo</code> kami: itu hanya terdiri dari menunggu operasi IO (mengunggah foto, mengirim respons, membaca foto dari disk, dll.) Dan memanggil fungsi dari perpustakaan <code>numpy</code> , <code>nmslib</code> dan <code>Pillow</code> . </p><br><p>  Saya tidak menyebutkan <code>dlib</code> karena suatu alasan.  Perpustakaan yang memanggil kode asli tidak diperlukan untuk merilis GIL dan <code>dlib</code> hak ini.  Dia tidak membutuhkan kunci ini, dia hanya tidak membiarkannya pergi.  Penulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> bahwa ia akan dengan senang hati menerima Permintaan Tarik yang sesuai, tetapi saya terlalu malas. </p><br><h5 id="2-mnogoprocessnost">  2. Multiprocessing </h5><br><p>  Cara termudah untuk berurusan dengan <code>dlib</code> adalah merangkum model dalam entitas terpisah dan menjalankannya dalam proses terpisah.  Dan lebih baik di pool proses. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_worker_initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> model model = Model(config) model.load_state() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_worker_do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.process_image(image) pool = multiprocessing.Pool(<span class="hljs-number"><span class="hljs-number">8</span></span>, initializer=_worker_initialize, initargs=(config,))</code> </pre> <br><pre> <code class="python hljs">result = pool.apply(_worker_do, (image,))</code> </pre> <br><h5 id="3-zhelezo">  3. Besi </h5><br><p>  Jika bot Anda perlu terus-menerus membaca foto dari disk, pastikan disk tersebut adalah SSD.  Atau bahkan memasangnya ke RAM.  Ping ke server telegram dan kualitas saluran juga penting. </p><br><h5 id="4-flood-control">  4. Kontrol banjir </h5><br><p>  Telegram tidak mengizinkan bot mengirim lebih dari 30 pesan per detik.  Jika bot Anda populer dan banyak orang menggunakannya pada saat yang bersamaan, maka sangat mudah untuk mendapatkan larangan selama beberapa detik, yang akan berubah menjadi kekecewaan dari harapan banyak pengguna.  Untuk mengatasi masalah ini, <code>python-telegram-bot</code> menawarkan kepada kami antrian yang tidak dapat mengirim lebih dari batas pesan yang ditentukan per detik, mempertahankan interval yang sama antara pengiriman. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.ext.messagequeue <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MessageQueue</code> </pre> <br><p>  Untuk menggunakannya, Anda perlu mendefinisikan bot Anda sendiri dan menggantinya saat membuat <code>Updater</code> . </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telegram.utils.promise <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Promise <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MQBot</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Bot)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self._message_queue = MessageQueue( all_burst_limit=<span class="hljs-number"><span class="hljs-number">30</span></span>, all_time_limit_ms=<span class="hljs-number"><span class="hljs-number">1000</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__del__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self._message_queue.stop() <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: super().__del__() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> is_group = kwargs.get(<span class="hljs-string"><span class="hljs-string">'chat_id'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._message_queue(Promise(super().send_message, args, kwargs), is_group)</code> </pre> <br><pre> <code class="python hljs">bot = MQBot(token=TOKEN) updater = Updater(bot=bot)</code> </pre> <br><h5 id="5-web-hooks">  5. Kait web </h5><br><p>  Dalam lingkungan produk, Web Hooks harus selalu digunakan daripada Long Polling sebagai cara untuk menerima pembaruan dari server Telegram.  Tentang apa semua ini dan bagaimana menggunakannya dapat dibaca di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h5 id="6-melochi">  6. Trivia </h5><br><p>              <code>json</code> .    ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ultrajson</a> . </p><br><p>          IO-:    ,  ,  .      ,         . </p><br><h5 id="6-analitika"> 6.  </h5><br><p>   ,   .        ,   ,  ,       .        ,        . </p><br><p> , ,      BI-tool <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Splunk</a>     . </p><br><p><img src="https://habrastorage.org/webt/oh/8e/ve/oh8eve_hczr4pahrzum56fonxxg.jpeg" alt="Papan Iklan (harap berikan kami lisensi)"></p><br><p>   ,         .     ,                       . </p><br><p>    ,         .      ,    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@OkkoFaceBot</a> . </p><br><p><del>        </del> ,     . ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417329/">https://habr.com/ru/post/id417329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417319/index.html">Sistem dalam kasus atau Apa yang sebenarnya di bawah penutup mikroprosesor</a></li>
<li><a href="../id417321/index.html">Bagaimana kita mencari guru kursus online di antara pengembang?</a></li>
<li><a href="../id417323/index.html">Masalah memastikan aksesibilitas proyek 100%</a></li>
<li><a href="../id417325/index.html">Netrology Open Day, Tema Ilmu Data</a></li>
<li><a href="../id417327/index.html">Pemantauan anggaran suhu di Ruang Server (MP707 + nettop dengan Linux + PRTG)</a></li>
<li><a href="../id417331/index.html">Security Week 26: Updated Spectre, rekaman sekarang enak</a></li>
<li><a href="../id417333/index.html">Peringkat sosial</a></li>
<li><a href="../id417337/index.html">Prinsip operasi dan fitur aplikasi pertukaran atom</a></li>
<li><a href="../id417339/index.html">3DTouch - Timbangan pada iPhone: Penyelesaian</a></li>
<li><a href="../id417345/index.html">Ancaman Berburu dengan Visibilitas Cisco</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>