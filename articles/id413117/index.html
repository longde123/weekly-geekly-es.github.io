<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚹 👨🏻‍🌾 🌝 Cara memprogram dengan aman di bash 🏿 🖕🏻 💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa bash 
 Ada array dan safe mode di bash. Ketika digunakan dengan benar, bash hampir konsisten dengan praktik pengkodean yang aman. 

 Lebih sul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara memprogram dengan aman di bash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413117/"><h1>  Mengapa bash </h1><br>  Ada array dan safe mode di bash.  Ketika digunakan dengan benar, bash hampir konsisten dengan praktik pengkodean yang aman. <br><br>  Lebih sulit membuat kesalahan pada ikan, tetapi tidak ada mode aman.  Oleh karena itu, membuat prototipe pada ikan dan kemudian menerjemahkan dari ikan ke bash harus menjadi ide yang baik jika Anda tahu cara melakukannya dengan benar. <br><br><h1>  Kata Pengantar </h1><br>  Panduan ini menyertai ShellHarden, tetapi penulis juga merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ShellCheck</a> sehingga aturan ShellHarden tidak menyimpang dari ShellCheck. <br><br>  Bash bukan bahasa di mana cara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paling tepat untuk menyelesaikan masalah pada saat yang sama adalah yang termudah</a> .  Jika Anda mengikuti ujian pemrograman bash safe, maka aturan pertama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BashPitfalls</a> adalah: selalu menggunakan tanda kutip. <br><br><h1>  Hal utama yang perlu Anda ketahui tentang pemrograman di bash </h1><br>  <b>Tanda kutip manik!</b>  Variabel yang tidak dikutip harus dianggap sebagai bom cocked: meledak pada kontak dengan ruang.  Ya, itu meledak dalam arti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membagi string menjadi sebuah array</a> .  Secara khusus, ekstensi variabel seperti <code>$var</code> dan substitusi perintah seperti <code>$(cmd)</code> oleh <i>kata</i> ketika string bagian dalam diperluas menjadi array karena pemisahan dalam variabel <code>$IFS</code> khusus dengan ruang default.  Ini biasanya tidak terlihat, karena paling sering hasilnya adalah array dari 1 elemen, tidak dapat dibedakan dari string yang diharapkan. <br><a name="habracut"></a><br>  Tidak hanya ini diperluas, tetapi juga wildcard ( <code>*?</code> ).  Proses ini terjadi setelah memisahkan kata, jadi jika kata tersebut memiliki setidaknya satu wildcard, kata tersebut berubah menjadi wildcard yang berlaku untuk setiap jalur file yang sesuai.  Jadi fitur ini mulai berlaku untuk sistem file! <br><br>  Kutipan menekan pemisahan kata dan perluasan pola untuk variabel dan penggantian perintah. <br><br>  Ekstensi variabel: <br><br><ul><li>  Bagus: <code>"$my_var"</code> </li><li>  Buruk: <code>$my_var</code> </li></ul><br>  Substitusi perintah: <br><br><ul><li>  Bagus: <code>"$(cmd)"</code> </li><li>  Buruk: <code>$(cmd)</code> </li></ul><br>  Ada pengecualian dengan tanda kutip opsional, tetapi tanda kutip tidak akan menyakiti, dan aturan umum adalah berhati-hati untuk tidak mengutip variabel yang tidak dikutip, jadi kami tidak akan mencari pengecualian perbatasan untuk keuntungan Anda.  Tampaknya salah, dan praktik yang salah cukup luas untuk menimbulkan kecurigaan: banyak skrip telah ditulis dengan pemrosesan yang rusak dari nama file dan spasi di dalamnya ... <br><br>  ShellHarden hanya menyebutkan sedikit pengecualian - apakah variabel-variabel ini dengan konten numerik seperti <code>$?</code>  , <code>$#</code> dan <code>${#array[@]}</code> . <br><br><h3>  Apakah saya perlu menggunakan backticks? </h3><br>  Pergantian perintah juga dapat memiliki bentuk berikut: <br><br><ul><li>  Benar: <code>"`cmd`"</code> </li><li>  Buruk: <code>`cmd`</code> </li></ul><br>  Meskipun gaya ini dapat digunakan dengan benar, itu terlihat kurang nyaman dalam tanda kutip dan kurang dapat dibaca saat bersarang.  Konsensus di sini cukup jelas: hindari. <br><br>  ShellHarden menulis ulang tanda centang dalam tanda kurung dalam dolar. <br><br><h3>  Apakah kurung kurawal perlu digunakan? </h3><br>  Kurung digunakan untuk menyisipkan string, sehingga biasanya berlebihan: <br><br><ul><li>  Buruk: <code>some_command $arg1 $arg2 $arg3</code> </li><li>  Miskin dan verbose: <code>some_command ${arg1} ${arg2} ${arg3}</code> </li><li>  Bagus, tetapi verbose: <code>some_command "${arg1}" "${arg2}" "${arg3}"</code> </li><li>  Bagus: <code>some_command "$arg1" "$arg2" "$arg3"</code> </li></ul><br>  Secara teoritis, selalu menggunakan kurung kurawal bukanlah masalah, tetapi menurut pengalaman penulis Anda, ada korelasi negatif yang kuat antara penggunaan kurung kurawal yang tidak perlu dan penggunaan tanda kutip yang benar - hampir semua orang memilih bentuk "buruk dan bertele-tele" alih-alih bentuk "baik tetapi bertulang"! <br><br>  Teori penulis Anda: <br><br><ul><li>  Karena takut melakukan sesuatu yang salah: alih-alih bahaya nyata (kurangnya tanda kutip), pemula mungkin khawatir bahwa variabel <code>$prefix</code> akan menyebabkan variabel <code>"$prefix_postfix"</code> meluas, tetapi tidak berfungsi seperti itu. </li><li>  Kultus muatan: menulis kode dalam perjanjian ketakutan salah yang mendahuluinya. </li><li>  Kurung bersaing dengan tanda kutip untuk batas verbositas yang diizinkan. </li></ul><br>  Oleh karena itu, diputuskan untuk melarang kurung kurawal yang tidak perlu: ShellHarden mengganti opsi ini dengan bentuk yang paling sederhana. <br><br>  Dan sekarang tentang interpolasi string, di mana kurung kurawal sangat berguna: <br><br><ul><li>  Buruk (gabungan): <code>$var1"more string content"$var2</code> </li><li>  Bagus (gabungan): <code>"$var1""more string content""$var2"</code> </li><li>  Bagus (interpolasi): <code>"${var1}more string content${var2}"</code> </li></ul><br>  Penggabungan dan interpolasi dalam bash adalah setara bahkan dalam array (yang konyol). <br><br>  Karena ShellHarden tidak memformat gaya, itu tidak seharusnya mengubah kode yang benar.  Ini berlaku untuk opsi "baik (interpolasi)": dari sudut pandang ShellHarden, ini akan menjadi bentuk yang benar secara kanonik. <br><br>  ShellHarden sekarang menambahkan dan menghapus kurung kurawal sesuai kebutuhan: dalam contoh yang buruk, var1 disediakan dengan kurung, tetapi mereka tidak diizinkan untuk var2 bahkan dalam kasus "baik (interpolasi)", karena mereka tidak pernah diperlukan pada akhir baris.  Persyaratan terakhir mungkin dapat dibalik. <br><br><h4>  Gotcha: argumen bernomor </h4><br>  Tidak seperti nama <i>pengenal</i> variabel normal (dalam regex: <code>[_a-zA-Z][_a-zA-Z0-9]*</code> ), argumen bernomor memerlukan tanda kurung (interpolasi garis tidak).  ShellCheck mengatakan: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$10</span></span></span><span class="hljs-string">"</span></span> ^-- SC1037: Braces are required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> positionals over 9, eg <span class="hljs-variable"><span class="hljs-variable">${10}</span></span>.</code> </pre> <br>  ShellHarden menolak untuk memperbaikinya (menganggap perbedaannya terlalu halus). <br><br>  Karena tanda kurung diizinkan hingga 9, ShellHarden memungkinkannya untuk semua argumen bernomor. <br><br><h1>  Menggunakan Array </h1><br>  Untuk dapat mengutip semua variabel, Anda harus menggunakan array nyata, bukan string pseudo-masif yang dipisahkan oleh spasi. <br><br>  Sintaksnya adalah verbose, tetapi Anda harus menanganinya.  Bashism ini hanyalah salah satu alasan untuk meninggalkan kompatibilitas POSIX untuk sebagian besar skrip shell. <br><br>  Baik: <br><br><pre> <code class="bash hljs">array=( a b ) array+=(c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">${#array[@]}</span></span> -gt 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${array[@]}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Buruk: <br><br><pre> <code class="bash hljs">pseudoarray=<span class="hljs-string"><span class="hljs-string">" \ a \ b \ "</span></span> pseudoarray=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string"> c"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ! [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-variable"><span class="hljs-variable">$pseudoarray</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Itu sebabnya array adalah fungsi dasar untuk shell: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">argumen perintah pada dasarnya adalah array</a> (dan skrip shell adalah perintah dan argumen).  Kita dapat mengatakan bahwa shell, yang secara artifisial tidak memungkinkan untuk melewati beberapa argumen, akan menjadi lucu dan tidak berharga.  Beberapa shell umum dari kategori ini termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dash</a> dan Busybox Ash.  Ini adalah shell kompatibel POSIX minimal - tetapi apa gunanya kompatibilitas jika hal terpenting <i>tidak ada</i> pada POSIX? <br><br><h3>  Kasus luar biasa ketika Anda benar-benar akan melanggar batas </h3><br>  Contoh dengan <code>\v</code> sebagai pemisah data (perhatikan kejadian kedua): <br><br><pre> <code class="bash hljs">IFS=$<span class="hljs-string"><span class="hljs-string">'\v'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -d <span class="hljs-string"><span class="hljs-string">''</span></span> -ra a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>) || <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Dengan cara ini kami menghindari perluasan templat, dan metode ini berfungsi bahkan jika pemisah data adalah <code>\n</code> .  Munculnya kedua pemisah data melindungi elemen terakhir jika ternyata menjadi spasi.  Untuk beberapa alasan, opsi <code>-d</code> harus <code>-rad ''</code> , jadi <code>-rad ''</code> opsi di <code>-rad ''</code> menggoda, tetapi itu tidak akan berhasil.  Karena baca mengembalikan nilai bukan nol dalam kasus ini, itu harus dilindungi dari errexit ( <code>|| true</code> ), jika diaktifkan.  Diuji dalam bash 4.0, 4.1, 4.2, 4.3 dan 4.4. <br><br>  Alternatif untuk bash 4.4: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">readarray</span></span> -td $<span class="hljs-string"><span class="hljs-string">'\v'</span></span> a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><h1>  Di mana memulai skrip bash </h1><br>  Dari sesuatu seperti ini: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash if test "$BASH" = "" || "$BASH" -uc "a=();true \"\${a[@]}\"" 2&gt;/dev/null; then # Bash 4.4, Zsh set -euo pipefail else # Bash 4.3 and older chokes on empty arrays with set -u. set -eo pipefail fi shopt -s nullglob globstar</span></span></code> </pre> <br>  Ini termasuk: <br><br><ul><li>  Shebang: <br><ul><li>  Masalah portabilitas: Path absolut ke <code>env</code> mungkin lebih baik untuk portabilitas daripada path absolut ke <code>bash</code> .  Anda dapat melihat contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NixOS</a> .  POSIX membutuhkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">env</a> , tetapi bukan bash. </li><li>  Masalah Keamanan: Tanpa bahasa, opsi seperti <code>-euo pipefail</code> tidak akan diterima dengan baik di <code>-euo pipefail</code> !  Ini menjadi tidak mungkin ketika menggunakan pengalihan <code>env</code> , tetapi bahkan jika shebang Anda mulai dengan <code>#!/bin/bash</code> , ini bukan tempat untuk parameter yang mempengaruhi nilai skrip, karena mereka dapat diganti, yang akan memungkinkan untuk mengeksekusi skrip secara salah.  Namun, sebagai bonus, opsi yang tidak memengaruhi nilai skrip, seperti <code>set -x</code> , jika digunakan, dapat didefinisikan ulang. </li></ul></li><li>  Apa yang kita butuhkan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mode ketat Bash tidak resmi</a> , dengan <code>set -u</code> fitur <code>set -u</code> -check.  Kami tidak memerlukan semua mode Bash yang ketat, karena kompatibilitas shellcheck / shellharden berarti mengutip segala sesuatu dan segala sesuatu yang jauh lebih ketat.  Selain itu, opsi <code>set -u</code> <b>tidak boleh digunakan</b> di Bash 4.3 dan sebelumnya.  Karena opsi ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menganggap array kosong sebagai dibuang</a> di versi itu, array tidak dapat digunakan untuk tujuan yang dijelaskan di sini.  Menggunakan array adalah tip terpenting kedua dari panduan ini (setelah tanda kutip) dan satu-satunya alasan kami mengorbankan kompatibilitas dengan POSIX, jadi ini sama sekali tidak dapat diterima: tidak menggunakan <code>set -u</code> , atau menggunakan Bash 4.4 atau shell normal lainnya seperti Zsh.  Ini lebih mudah diucapkan daripada dilakukan, karena ada kemungkinan seseorang akan tetap menjalankan skrip Anda di versi kuno Bash.  Untungnya, semua yang bekerja dengan <code>set -u</code> akan bekerja tanpanya (untuk <code>set -e</code> Anda tidak bisa mengatakan itu).  Inilah sebabnya mengapa penting untuk menggunakan pemeriksaan versi.  Waspadalah terhadap asumsi bahwa pengujian dan pengembangan berlangsung di shell yang kompatibel dengan Bash 4.4 (sehingga aspek <code>set -u</code> diuji).  Jika ini mengganggu Anda, maka opsi lain adalah menolak kompatibilitas (skrip gagal saat verifikasi versi gagal), atau menolak <code>set -u</code> . </li><li>  <code>shopt -s nullglob</code> memaksa <code>for f in *.txt</code> berfungsi dengan benar jika <code>*.txt</code> tidak menemukan file.  Perilaku default (alias <i>passglob</i> ) melewati templat tidak berubah, yang dalam kasus hasil nol berbahaya karena beberapa alasan.  Untuk <i>globstar,</i> ini mengaktifkan pencarian rekursif.  Pergantian lebih mudah digunakan daripada <code>find</code> .  Jadi, gunakan itu. </li></ul><br>  Tapi tidak: <br><br><pre> <code class="bash hljs">IFS=<span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -f <span class="hljs-built_in"><span class="hljs-built_in">shopt</span></span> -s failglob</code> </pre> <br><ul><li>  Mengatur <i>pembatas bidang internal ke</i> string kosong membuat tidak mungkin untuk membagi kata.  Kedengarannya seperti solusi sempurna.  Sayangnya, ini adalah pengganti yang tidak lengkap untuk mengutip variabel dan penggantian perintah, dan karena Anda akan menggunakan tanda kutip, itu tidak memberikan apa pun.  Alasan mengapa kutipan masih perlu digunakan adalah karena jika string kosong menjadi array kosong (seperti dalam <code>test $x = ""</code> ) dan perluasan template tidak langsung masih dimungkinkan.  Selain itu, masalah dengan variabel ini juga akan menyebabkan masalah dengan perintah seperti <code>read</code> , yang memecah konstruksi seperti <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code>  <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> . </li><li>  Ekstensi templat dinonaktifkan: tidak hanya ekstensi tidak langsung yang terkenal, tetapi juga ekstensi langsung tanpa gangguan, yang, seperti yang saya katakan, harus Anda gunakan.  Jadi sulit diterima.  Dan ini juga sepenuhnya opsional untuk skrip yang kompatibel dengan shellcheck / shellharden. </li><li>  Tidak seperti <i>nullglob</i> , <i>failglob</i> gagal dengan hasil nol.  Meskipun untuk sebagian besar perintah, ini masuk akal, misalnya, <code>rm -- *.txt</code> (karena untuk sebagian besar perintah masih tidak diharapkan untuk mengeksekusi dengan hasil nol), jelas <i>failglob</i> dapat digunakan hanya jika Anda tidak mengharapkan hasil nol.  Ini berarti bahwa biasanya Anda tidak akan menempatkan templat grup dalam argumen perintah kecuali Anda menganggap yang sama.  Tapi yang selalu bisa terjadi adalah menggunakan <i>nullglob</i> dan memperluas template ke argumen null dalam konstruk yang dapat mengambilnya, seperti loop atau menetapkan nilai ke array ( <code>txt_files=(*.txt)</code> ). </li></ul><br><h1>  Cara menyelesaikan skrip bash </h1><br>  Status keluar skrip adalah status dari perintah terakhir yang dijalankan.  Pastikan itu menunjukkan keberhasilan atau kegagalan nyata. <br><br>  Yang terburuk adalah meninggalkan solusi ke kondisi yang tidak terkait dalam bentuk daftar DAN di akhir skrip.  Jika kondisinya salah, maka perintah yang dieksekusi terakhir adalah kondisinya sendiri. <br><br>  Untuk errexit, kondisi dalam bentuk daftar DAN tidak pernah digunakan di tempat pertama.  Jika errexit tidak digunakan, pertimbangkan menangani kesalahan bahkan untuk perintah terakhir, jadi status keluarnya tidak akan ditutup-tutupi jika kode tambahan ditambahkan ke skrip. <br><br>  Buruk: <br><br><pre> <code class="bash hljs">condition &amp;&amp; extra_stuff</code> </pre> <br>  Bagus (opsi errexit): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Bagus (opsi penanganan kesalahan): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0</code> </pre> <br><h1>  Cara menggunakan errexit </h1><br>  Seperti <code>set -e</code> . <br><br><h3>  Tingkat Program Pembersihan Tertunda </h3><br>  Jika errexit berfungsi sebagaimana mestinya, gunakan ini untuk menginstal pembersihan yang diperlukan saat keluar. <br><br><pre> <code class="bash hljs">tmpfile=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(mktemp -t myprogram-XXXXXX)</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span></span>() { rm -f <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$tmpfile</span></span></span><span class="hljs-string">"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> cleanup EXIT</code> </pre> <br><h3>  Tertangkap: errexit diabaikan dalam argumen perintah </h3><br>  Ini adalah "bom" percabangan yang sangat rumit, yang pengertiannya sangat berarti bagi saya.  Skrip build saya berfungsi dengan baik pada mesin pengembangan yang berbeda, tetapi membuat server build berlutut: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed make -j"$(nproc)"</span></span></code> </pre> <br>  Benar (pergantian perintah dalam tugas): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  Peringatan: perintah built-in <code>local</code> dan <code>export</code> tetap menjadi perintah, jadi ini masih salah: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  ShellCheck hanya memperingatkan tentang perintah khusus seperti <code>local</code> dalam kasus ini. <br><br>  Untuk menggunakan <code>local</code> , pisahkan deklarasi dari pekerjaan: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br><h3>  Tertangkap: errexit diabaikan tergantung pada konteks pemanggil </h3><br>  Terkadang POSIX mengerikan.  Errexit diabaikan dalam fungsi, perintah grup, dan bahkan subkulit jika penelepon memeriksa keberhasilannya.  Semua contoh ini mencetak <code>Unreachable</code> dan <code>Great success</code> , betapapun anehnya itu tampak. <br><br>  Subshell: <br><br><pre> <code class="bash hljs">( <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable ) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Tim Grup: <br><br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Fungsi: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } f &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Karena itu, bash dengan errexit secara praktis tidak cocok untuk menautkan: ya, <i>dimungkinkan untuk</i> membungkus fungsi errexit agar berfungsi, tetapi ada keraguan bahwa upaya yang disimpan (penanganan kesalahan eksplisit) sepadan.  Sebagai gantinya, pertimbangkan untuk memisah menjadi skrip yang sepenuhnya otonom. <br><br><h1>  Menghindari memanggil shell dengan kutipan yang salah </h1><br>  Saat menjalankan perintah dari bahasa pemrograman lain, paling mudah untuk membuat kesalahan dan secara implisit memanggil shell.  Jika perintah shell ini statis, itu bagus - itu berfungsi atau tidak.  Tetapi jika program Anda entah bagaimana memproses baris untuk membangun perintah ini, maka Anda perlu memahami - Anda <b>membuat skrip shell</b> !  Saya jarang ingin melakukan ini, dan sangat melelahkan untuk mengatur semuanya dengan benar: <br><br><ul><li>  mengutip setiap argumen; </li><li>  keluar dari karakter yang sesuai dalam argumen. </li></ul><br>  Tidak peduli apa bahasa pemrograman Anda melakukan ini, setidaknya ada tiga cara untuk membangun tim dengan benar.  Dalam urutan pilihan: <br><br><h3>  Paket A: lakukan tanpa shell </h3><br>  Jika ini hanya perintah dengan argumen (yaitu, tidak ada fungsi shell seperti pipelining atau redirect), lalu pilih opsi array. <br><br><ul><li>  Buruk (python3): <code>subprocess.check_call('rm -rf ' + path)</code> </li><li>  Bagus (python3): <code>subprocess.check_call(['rm', '-rf', path])</code> </li></ul><br>  Buruk (C ++): <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> cmd = <span class="hljs-string"><span class="hljs-string">"rm -rf "</span></span>; cmd += path; system(cmd);</code> </pre> <br>  Baik (C / POSIX), minus penanganan kesalahan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args[] = {<span class="hljs-string"><span class="hljs-string">"rm"</span></span>, <span class="hljs-string"><span class="hljs-string">"-rf"</span></span>, path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child; posix_spawnp(&amp;child, args[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, args, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status; waitpid(child, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h3>  Paket B: skrip shell statis </h3><br>  Jika shell diperlukan, biarkan argumen menjadi argumen.  Anda mungkin berpikir bahwa menulis skrip shell khusus di file Anda sendiri tidak praktis dan mengaksesnya sampai Anda melihat trik seperti itu: <br><br>  Buruk (python3): <code>subprocess.check_call('docker exec {} bash -ec "printf %s {} &gt; {}"'.format(instance, content, path))</code> <br>  Bagus (python3): <code>subprocess.check_call(['docker', 'exec', instance, 'bash', '-ec', 'printf %s "$0" &gt; "$1"', content, path])</code> <br><br>  Bisakah Anda perhatikan skrip shell? <br><br>  Itu benar, perintah printf diarahkan.  Perhatikan argumen bernomor yang dikutip dengan benar.  Menerapkan skrip shell statis baik-baik saja. <br><br>  Contoh-contoh ini berjalan di Docker karena kalau tidak mereka tidak akan begitu berguna, tetapi Docker juga merupakan contoh yang bagus dari perintah yang menjalankan perintah lain berdasarkan argumen.  Tidak seperti Ssh, seperti yang akan kita lihat nanti. <br><br><h3>  Opsi terakhir: pemrosesan garis </h3><br>  Jika <i>harus</i> berupa string (misalnya, karena harus bekerja melalui <code>ssh</code> ), maka itu tidak dapat dilewati.  Anda harus mengutip setiap argumen dan melarikan diri karakter apa pun yang diperlukan untuk keluar dari kutipan ini.  Cara termudah adalah beralih ke tanda kutip tunggal, karena mereka memiliki aturan pelarian paling sederhana.  Hanya satu aturan: <code>'</code> → <code>'\"</code> . <br><br>  Nama file kutipan tunggal: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Don'</span></span>\<span class="hljs-string"><span class="hljs-string">''</span></span>t stop (12<span class="hljs-string"><span class="hljs-string">" dub mix).mp3'</span></span></code> </pre> <br>  Bagaimana cara menggunakan trik ini untuk menjalankan perintah ssh dengan aman?  Ini tidak mungkin!  Nah, inilah solusi "sering benar": <br><br><ul><li>  Solusi "sering benar" (python3): <code>subprocess.check_call(['ssh', 'user@host', "sha1sum '{}'".format(path.replace("'", "'\\''"))])</code> </li></ul><br>  Kita sendiri harus menggabungkan semua argumen menjadi string sehingga Ssh tidak melakukannya dengan salah: jika Anda mencoba untuk melewati beberapa argumen ssh, itu akan mulai menggabungkan argumen tersebut tanpa tanda kutip. <br><br>  Alasan ini biasanya tidak mungkin adalah karena keputusan yang tepat tergantung pada preferensi pengguna di ujung yang lain, yaitu remote shell, yang bisa berupa apa saja.  Pada dasarnya, itu bahkan bisa menjadi ibumu.  “Sering benar” untuk mengasumsikan bahwa shell jarak jauh adalah bash atau shell yang kompatibel dengan POSIX, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fish tidak kompatibel pada tahap ini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413117/">https://habr.com/ru/post/id413117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413105/index.html">Catatan dari penyedia IoT. Aktivasi dan keamanan di LoraWAN</a></li>
<li><a href="../id413107/index.html">Terjemahan dari wiki proyek Svelto.ECS. Kerangka kerja ECS untuk Unity3D</a></li>
<li><a href="../id413109/index.html">Cara Membangun Platform Integrasi Produk SaaS: Pengalaman Cloud Checkout Poster</a></li>
<li><a href="../id413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../id413113/index.html">Dukungan serialisasi JavaScript JavaScript</a></li>
<li><a href="../id413119/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 317 (28 Mei - 3 Juni 2018)</a></li>
<li><a href="../id413121/index.html">Tur foto rekan kerja Moskow #tceh</a></li>
<li><a href="../id413123/index.html">BERGABUNG di Basis Data NoSQL</a></li>
<li><a href="../id413125/index.html">Terapi gen memberi pasien kecil dengan atrofi otot kesempatan untuk bertahan hidup</a></li>
<li><a href="../id413127/index.html">Beberapa kata tentang kinerja nyata dari hypervisor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>