<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòù üë®üèº‚Äç‚úàÔ∏è üêµ Usamos as m√°scaras de mosaico, pixela√ß√£o e geom√©tricas de Voronoi em shaders para decorar o local ü•ì üåì üë©üèæ‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo √© uma continua√ß√£o l√≥gica da introdu√ß√£o de shaders de programa√ß√£o para designers de layout . Nele, criamos um modelo para criar v√°rios efei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usamos as m√°scaras de mosaico, pixela√ß√£o e geom√©tricas de Voronoi em shaders para decorar o local</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421821/"><img src="https://habrastorage.org/webt/tw/dv/y5/twdvy5bonlmr47omgfhgmi9rjqu.jpeg" alt="imagem"><br><br><p> Este artigo √© uma continua√ß√£o l√≥gica da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">introdu√ß√£o de shaders de programa√ß√£o para designers de layout</a> .  Nele, criamos um modelo para criar v√°rios efeitos bidimensionais com fotos usando shaders e analisamos alguns exemplos.  Neste artigo, adicionaremos mais algumas texturas, aplicaremos a divis√£o de Voronoi na pr√°tica para criar mosaicos a partir deles, falar sobre a cria√ß√£o de v√°rias m√°scaras em shaders, sobre pixeliza√ß√£o e tamb√©m abordar alguns problemas da antiga sintaxe GLSL que ainda existe em nossos navegadores. </p><br><p>  Assim como da √∫ltima vez, haver√° um m√≠nimo de teoria e um m√°ximo de pr√°tica e racioc√≠nio em uma linguagem cotidiana mundana.  Os iniciantes encontrar√£o aqui uma sequ√™ncia de a√ß√µes com dicas e notas √∫teis, e fornecedores experientes de front-end podem encontrar algumas id√©ias para se inspirar. </p><a name="habracut"></a><br><p>  <em>Uma pesquisa em um artigo anterior mostrou que o t√≥pico de efeitos WebGL para sites pode ser de interesse n√£o apenas para os tip√≥grafos, mas tamb√©m para nossos colegas de outras especializa√ß√µes.</em>  <em>Para n√£o confundi-los com os recursos mais recentes de ES, nos restringimos deliberadamente a constru√ß√µes de sintaxe mais tradicionais que todos entendem.</em>  <em>E, novamente, chamo a aten√ß√£o dos leitores para o fato de que os editores internos do CodePen afetam o desempenho do que √© feito neles.</em> </p><br><p>  Mas vamos come√ßar ... </p><br><h2 id="shablon-dlya-raboty-s-sheyderami">  Modelo para trabalhar com shaders </h2><br><p>  Para quem n√£o leu o artigo anterior, criamos este modelo para trabalhar com shaders: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/ZMBMPJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  √â criado um plano (no nosso caso, um quadrado) no qual a textura da imagem √© "desenhada".  Sem depend√™ncias desnecess√°rias e um shader de v√©rtice muito simples.  Em seguida, desenvolvemos esse modelo, mas agora come√ßaremos a partir do momento em que ainda n√£o h√° l√≥gica no sombreador de fragmentos. </p><br><h2 id="mozaika">  Mosaico </h2><br><p>  Mosaico √© um plano dividido em pequenas √°reas, onde cada uma das √°reas √© preenchida com uma determinada cor ou, como no nosso caso, textura.  Como podemos at√© quebrar nosso avi√£o em peda√ßos?  Obviamente, voc√™ pode dividi-lo em ret√¢ngulos.  Mas isso j√° √© t√£o f√°cil com a ajuda do SVG, arrastar o WebGL para esta tarefa e colocar tudo do nada sem absolutamente nenhum prop√≥sito. </p><br><p>  Para que o mosaico seja interessante, ele deve ter fragmentos diferentes, tanto na forma quanto no tamanho.  Existe uma abordagem muito simples, mas ao mesmo tempo divertida, para a constru√ß√£o dessa parti√ß√£o.  √â conhecido como mosaico de Voronoi ou parti√ß√£o de Dirichlet, e na Wikipedia eles escrevem que Descartes usou algo semelhante no distante s√©culo XVII.  A ideia √© mais ou menos assim: </p><br><ul><li>  Pegue um conjunto de pontos no avi√£o. </li><li>  Para cada ponto no plano, encontre o ponto mais pr√≥ximo deste conjunto. </li><li>  S√≥ isso.  O plano √© dividido em √°reas poligonais, cada uma das quais √© determinada por um dos pontos do conjunto. </li></ul><br><p>  Provavelmente √© melhor mostrar esse processo com um exemplo pr√°tico.  Existem algoritmos diferentes para gerar essa parti√ß√£o, mas agiremos na testa, porque calcular algo para cada ponto no plano √© apenas a tarefa do shader.  Primeiro, precisamos fazer um conjunto de pontos aleat√≥rios.  Para n√£o carregar o c√≥digo dos exemplos, criaremos uma vari√°vel global para eles. </p><br><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS.push([<span class="hljs-type"><span class="hljs-type">Math.random</span></span>(), <span class="hljs-type"><span class="hljs-type">Math.random</span></span>()]); } }</code> </pre> <br><p>  Agora precisamos pass√°-los para os shaders.  Como os dados s√£o globais, usaremos o modificador <code>uniform</code> .  Mas h√° um ponto sutil: n√£o podemos simplesmente passar uma matriz.  Parece que o s√©culo XXI est√° no quintal, mas, no entanto, nada resultar√° disso.  Como resultado, voc√™ deve transferir uma matriz de pontos, um de cada vez. </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { GL.uniform2fv(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_points['</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-string"><span class="hljs-string">']'</span></span>), POINTS[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); }</code> </pre> <br><p>  Hoje, frequentemente encontramos problemas semelhantes de inconsist√™ncia entre o que √© esperado e o que est√° em navegadores reais.  Geralmente, os tutoriais do WebGL usam THREE.js e essa biblioteca oculta parte da sujeira, como o jQuery fazia em suas tarefas, mas se voc√™ a remover, isso realmente prejudicar√° seu c√©rebro. </p><br><p>  No shader de fragmento, temos uma vari√°vel de matriz para pontos.  S√≥ podemos criar matrizes de comprimento fixo.  Vamos come√ßar com 10 pontos: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_POINTS 10 uniform vec2 u_points[NUMBER_OF_POINTS];</span></span></code> </pre> <br><p>  Certifique-se de que tudo isso esteja funcionando, desenhando c√≠rculos nos locais dos pontos.  Esse desenho de v√°rias primitivas geom√©tricas √© frequentemente usado durante a depura√ß√£o - elas s√£o claramente vis√≠veis e voc√™ pode entender imediatamente o que est√° localizado e para onde est√° se movendo. </p><br><blockquote>  Use o "desenho" de c√≠rculos, linhas e outros pontos de refer√™ncia para os objetos invis√≠veis nos quais as anima√ß√µes s√£o constru√≠das.  Isso fornecer√° pistas √≥bvias sobre como eles funcionam, especialmente se os algoritmos forem complexos para entender rapidamente sem prepara√ß√£o pr√©via.  Ent√£o, tudo isso pode ser comentado e deixado para os colegas - eles agradecem. </blockquote><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>) { gl_FragColor = WHITE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/pONOme" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Bom  Vamos tamb√©m adicionar algum movimento aos pontos.  Deixe que eles se movam em c√≠rculo para come√ßar, depois retornaremos a esse problema.  Os coeficientes tamb√©m s√£o colocados no olho, apenas para desacelerar levemente o movimento e reduzir a amplitude das oscila√ß√µes. </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movePoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timeStamp) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += Math.sin(i * timeStamp / <span class="hljs-number"><span class="hljs-number">5000.0</span></span>) / <span class="hljs-number"><span class="hljs-number">500.0</span></span>; POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += Math.cos(i * timeStamp / <span class="hljs-number"><span class="hljs-number">5000.0</span></span>) / <span class="hljs-number"><span class="hljs-number">500.0</span></span>; } } }</code> </pre> <br><p>  Volte para o shader.  Para experimentos futuros, encontraremos n√∫meros √∫teis de √°reas nas quais tudo ser√° dividido.  Portanto, encontramos o ponto mais pr√≥ximo ao pixel atual do conjunto e salvamos o n√∫mero desse ponto - √© o n√∫mero da √°rea. </p><br><pre> <code class="hljs matlab">float min_distance = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; int area_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { float current_distance = distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current_distance &lt; min_distance) { min_distance = current_distance; area_index = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } }</code> </pre> <br><p>  Para testar o desempenho, pintamos tudo novamente em cores brilhantes: </p><br><pre> <code class="hljs pgsql">gl_FragColor = texture2D(u_texture, texture_coord); gl_FragColor.g = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index))); gl_FragColor.b = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index)));</code> </pre> <br><blockquote>  A combina√ß√£o de m√≥dulo (abs) e fun√ß√µes limitadas (em particular sin e cos) s√£o frequentemente usadas quando se trabalha com efeitos semelhantes.  Por um lado, isso adiciona um pouco de aleatoriedade e, por outro lado, fornece imediatamente um resultado normalizado de 0 a 1, o que √© muito conveniente - temos muitos valores que est√£o exatamente dentro desses limites. </blockquote><p>  Tamb√©m encontraremos pontos mais ou menos equidistantes de v√°rios pontos do conjunto e os coloriremos.  Essa a√ß√£o n√£o carrega uma carga √∫til especial, mas observar o resultado ainda √© interessante. </p><br><pre> <code class="hljs matlab">int number_of_near_points = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; min_distance + EPSILON) { number_of_near_points++; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number_of_near_points &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor.rgb = vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Voc√™ deve obter algo como isto: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/xaRavJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Ainda √© um rascunho, ainda estaremos finalizando.  Mas agora o conceito geral de tal separa√ß√£o do avi√£o est√° claro. </p><br><h2 id="mozaika-iz-fotografiy">  Mosaico de fotos </h2><br><p>  √â claro que, em sua forma pura, n√£o h√° muitos benef√≠cios com essa parti√ß√£o.  Para ampliar seus horizontes e apenas por divers√£o, voc√™ pode brincar com ele, mas em um site real vale a pena adicionar mais algumas fotos e fazer um mosaico delas.  Vamos refazer um pouco a fun√ß√£o de criar texturas, para que haja mais de uma. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTextures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt; URLS.textures.length; i++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crossOrigin</span></span></span><span class="hljs-function"> = '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anonymous</span></span></span><span class="hljs-function">'; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onload</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt; { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texture</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activeTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL['TEXTURE' + index])</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, texture)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixelStorei</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.UNPACK_FLIP_Y_WEBGL, true)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texImage2D</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, 0, GL.RGB, GL.RGB, GL.UNSIGNED_BYTE, image)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniform1i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.getUniformLocation(PROGRAM, 'u_textures[' + index + ']')</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function">); }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">src</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLS</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[index]</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  Nada de anormal aconteceu, apenas substitu√≠mos os zeros pelo par√¢metro <code>index</code> e reutilizamos o c√≥digo existente para carregar as tr√™s texturas.  No shader, agora temos uma variedade de texturas: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_TEXTURES 3 uniform sampler2D u_textures[NUMBER_OF_TEXTURES];</span></span></code> </pre> <br><p>  Agora podemos usar o n√∫mero da √°rea salvo anteriormente para selecionar uma das tr√™s texturas.  Mas ... </p><br><p>  Mas antes disso eu gostaria de fazer uma pequena digress√£o.  Sobre dor.  Sobre a sintaxe.  Javascript moderno (condicionalmente ES6 +) √© uma linguagem agrad√°vel.  Ele permite que voc√™ expresse seus pensamentos √† medida que surgem, n√£o limita a estrutura a nenhum paradigma de programa√ß√£o espec√≠fico, completa alguns pontos para n√≥s e permite que voc√™ se concentre mais na id√©ia do que na sua implementa√ß√£o.  Para o criador - √© isso.  Algumas pessoas acreditam que isso d√° muita liberdade e mudam para o TypeScript, por exemplo.  Pure C √© uma linguagem mais rigorosa.  Tamb√©m permite muito, voc√™ pode atrair qualquer coisa, mas ap√≥s o JS √© percebido como um pouco estranho, antiquado ou algo assim.  No entanto, ele ainda √© bom.  GLSL como existe nos navegadores √© apenas algo.  Al√©m de ser uma ordem de magnitude mais rigorosa que C, ainda falta muitos operadores e constru√ß√µes de sintaxe conhecidos.  Este √© provavelmente o maior problema ao escrever shaders mais ou menos complexos para o WebGL.  Por tr√°s do horror em que o c√≥digo se transforma, pode ser muito dif√≠cil dar uma olhada no algoritmo original.  Alguns programadores pensam que at√© aprender C, o caminho para os shaders est√° fechado para eles.  Portanto: o conhecimento de C n√£o ajudar√° particularmente aqui.  Aqui est√° algum tipo de mundo pr√≥prio.  O mundo da loucura, dinossauros e muletas. </p><br><p>  Como posso escolher uma das tr√™s texturas com um n√∫mero - o n√∫mero da √°rea.  O restante vem √† mente de dividir o n√∫mero pelo n√∫mero de texturas.  √ìtima ideia.  Somente o operador <code>%</code> , que as pr√≥prias m√£os j√° escrevem, n√£o est√° aqui.  A impress√£o de entender esse fato √© bem descrita pela figura: </p><br><p><img src="https://habrastorage.org/webt/3j/w3/on/3jw3on4pazjczkana82degd6gcc.png" alt="imagem"></p><br><p>  Claro, voc√™ diz: "Sim, n√£o h√° problema, existe uma fun√ß√£o <code>mod</code> - vamos aceit√°-la!".  Mas acontece que ela n√£o aceita dois inteiros, apenas fracion√°rios.  Ok, bem, fa√ßa-os <code>float</code> .  Tamb√©m temos um <code>float</code> , mas precisamos de um <code>int</code> .  Voc√™ precisa converter tudo de volta, caso contr√°rio, h√° uma chance n√£o falsa de obter um erro de compila√ß√£o. </p><br><pre> <code class="hljs lisp">int texture_index = int(<span class="hljs-name"><span class="hljs-name">mod</span></span>(<span class="hljs-name"><span class="hljs-name">float</span></span>(<span class="hljs-name"><span class="hljs-name">area_index</span></span>), float(<span class="hljs-name"><span class="hljs-name">NUMBER_OF_TEXTURES</span></span>)))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  E aqui est√° uma pergunta ret√≥rica: talvez seja mais f√°cil realizar sua fun√ß√£o do restante da divis√£o inteira do que tentar mont√°-la a partir de m√©todos padr√£o?  E essa ainda √© uma fun√ß√£o simples, e acontece que sequ√™ncias muito profundamente arraigadas de tais transforma√ß√µes s√£o obtidas nas quais n√£o est√° mais claro o que est√° acontecendo. </p><br><p>  Ok, vamos deixar como est√° por enquanto.  Basta pegar a cor do pixel desejado na textura selecionada e atribu√≠-la √† vari√°vel <code>gl_FragColor</code> .  Ent√£o  N√≥s j√° fizemos isso?  E ent√£o este gato aparece novamente.  Voc√™ n√£o pode usar um n√£o-constante ao acessar uma matriz.  E tudo o que calculamos n√£o √© mais uma constante.  Ba-dum-tsss !!! </p><br><p>  Voc√™ precisa fazer algo assim: </p><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">0</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">2</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">2</span></span>], texture_coord); }</code> </pre> <br><p>  Concordo que esse c√≥digo √© um caminho direto para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">govnokod.ru</a> , mas, mesmo assim, √© diferente de qualquer maneira.  Mesmo a <code>switch-case</code> n√£o est√° aqui para, pelo menos de alguma forma, enobrecer essa desgra√ßa.  Existe realmente outra muleta menos √≥bvia que resolve o mesmo problema: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>], texture_coord); } }</code> </pre> <br><p>  Contadores de ciclo, que aumentam em um, o compilador pode contar como uma constante.  Mas isso n√£o funcionou com uma variedade de texturas - no √∫ltimo Chrome, ocorreu um erro dizendo que era imposs√≠vel fazer isso com uma variedade de texturas.  Com uma s√©rie de n√∫meros, funcionou.  Adivinha por que funciona com uma matriz, mas n√£o com outra?  Se voc√™ pensou que o sistema de convers√£o de tipos em JS estava cheio de magia - resolva o sistema "constante - n√£o constante" no GLSL.  O engra√ßado √© que os resultados tamb√©m dependem da placa de v√≠deo usada, portanto, as muletas complicadas que funcionavam na placa de v√≠deo NVIDIA podem muito bem quebrar a AMD. </p><br><blockquote>  √â melhor evitar essas decis√µes com base em suposi√ß√µes sobre o compilador.  Eles tendem a quebrar e s√£o dif√≠ceis de testar. </blockquote><p>  Tristeza √© tristeza.  Mas, se queremos fazer coisas interessantes, precisamos abstrair tudo isso e continuar. </p><br><p>  No momento, temos um mosaico de fotos.  Mas h√° um detalhe: se os pontos se aproximam muito, h√° uma transi√ß√£o r√°pida de duas √°reas.  N√£o √© muito bonito.  Voc√™ precisa adicionar um algoritmo que n√£o permita que os pontos se aproximem.  Voc√™ pode fazer uma op√ß√£o simples, na qual as dist√¢ncias entre os pontos s√£o verificadas e, se for menor que um determinado valor, ent√£o as separamos.  Essa op√ß√£o n√£o apresenta desvantagens, em particular, √†s vezes leva a um pequeno tremor nos pontos, mas em muitos casos pode ser suficiente, principalmente porque n√£o h√° muitos c√°lculos aqui.  Op√ß√µes mais avan√ßadas seriam um sistema de cargas m√≥veis e uma "teia de aranha" na qual pares de pontos s√£o conectados por fontes invis√≠veis.  Se voc√™ estiver interessado em implement√°-las, poder√° encontrar facilmente todas as f√≥rmulas no livro de refer√™ncia de f√≠sica do ensino m√©dio. </p><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let j = i; j &lt; NUMBER_OF_POINTS; j++) { let deltaX = POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] - POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; let deltaY = POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] - POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]; let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) { POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaX); POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaY); POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaX); POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaY); } } }</code> </pre> <br><p>  O principal problema dessa abordagem, bem como o que usamos no shader, √© comparar todos os pontos com todos.  Voc√™ n√£o precisa ser um grande matem√°tico para entender que o n√∫mero de c√°lculos de dist√¢ncia ser√° incr√≠vel se n√£o fizermos 10 pontos, mas 1000. Sim, at√© 100 s√£o suficientes para que tudo diminua a velocidade.  Portanto, faz sentido aplic√°-lo apenas a um pequeno n√∫mero de pontos. </p><br><p>  Se queremos fazer esse mosaico para um grande n√∫mero de pontos, podemos usar a divis√£o familiar do plano em quadrados id√™nticos.  A id√©ia √© colocar um ponto em cada quadrado e realizar todas as compara√ß√µes apenas com pontos de quadrados vizinhos.  Uma boa id√©ia, mas os experimentos mostraram que, com um grande n√∫mero de pontos, laptops baratos com placas de v√≠deo integradas ainda n√£o conseguem lidar.  Portanto, vale a pena pensar dez vezes antes de decidir fazer esse mosaico em seu site a partir de um grande n√∫mero de fragmentos. </p><br><blockquote>  N√£o seja rabanete, verifique o desempenho de seus trabalhos n√£o apenas em sua fazenda de minera√ß√£o, mas tamb√©m em laptops comuns.  Usu√°rios ser√£o basicamente os √∫nicos. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEYN" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="razbienie-ploskosti-na-chasti-po-grafiku-funkcii">  Particionando um plano de acordo com um gr√°fico de fun√ß√µes </h2><br><p>  Vamos ver outra op√ß√£o para dividir um plano em partes.  N√£o ser√° mais necess√°rio grande poder de computa√ß√£o.  A id√©ia principal √© pegar algumas fun√ß√µes matem√°ticas e construir seu gr√°fico.  A linha resultante apenas dividir√° o plano em duas partes.  Se usarmos uma fun√ß√£o da forma <code>y = f(x)</code> , obteremos a divis√£o na forma de um corte.  Substituindo X por Y, podemos alterar a se√ß√£o horizontal para vertical.  Se voc√™ assumir a fun√ß√£o em coordenadas polares, precisar√° traduzir tudo em cartesiano e vice-versa, mas a ess√™ncia dos c√°lculos n√£o ser√° alterada.  Nesse caso, o resultado n√£o √© um corte em duas partes, mas um corte de furo.  Mas veremos a primeira op√ß√£o. </p><br><p>  Para cada Y, calcularemos o valor de X para fazer uma se√ß√£o vertical.  Poder√≠amos pegar uma onda senoidal para esses prop√≥sitos, por exemplo, mas √© muito chato.  √â melhor pegar alguns peda√ßos de uma s√≥ vez e dobr√°-los. </p><br><p>  Tomamos v√°rios sinus√≥ides, cada um deles vinculado a uma coordenada ao longo de Y e ao tempo, e os adicionamos.  Os f√≠sicos chamariam essa adi√ß√£o de superposi√ß√£o.  Obviamente, multiplicando o resultado inteiro por algum n√∫mero, alteramos a amplitude.  Retire-o em uma macro separada.  Se voc√™ multiplicar a coordenada - o par√¢metro seno, a frequ√™ncia mudar√°.  J√° vimos isso em um artigo anterior.  Tamb√©m removemos o modificador de frequ√™ncia comum a todos os sinus√≥ides da f√≥rmula.  N√£o ser√° sup√©rfluo jogar com o tempo; um sinal negativo dar√° o efeito de mover a linha na dire√ß√£o oposta. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span> = u_time * SPEED; <span class="hljs-type"><span class="hljs-type">float</span></span> x = (sin(texture_coord.y * FREQUENCY) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.1</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">1.72</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">1.121</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.221</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">0.437</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">3.1122</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">4.269</span></span>)) * AMPLITUDE;</code> </pre> <br><p>  Depois de definir essas configura√ß√µes globais para nossa fun√ß√£o, enfrentaremos o problema de repetir o mesmo movimento em intervalos bastante curtos.  Para resolver esse problema, precisamos multiplicar tudo por coeficientes para os quais o menor m√∫ltiplo comum √© muito grande.  Algo semelhante tamb√©m √© usado no gerador de n√∫meros aleat√≥rios, lembra?  Nesse caso, n√£o pensamos e pegamos n√∫meros prontos de algum exemplo da Internet, mas ningu√©m se incomoda em experimentar nossos valores. </p><br><p>  Resta apenas escolher uma das duas texturas para pontos acima do nosso gr√°fico de fun√ß√µes e a segunda para os pontos abaixo dele.  Mais precisamente √† esquerda e √† direita, todos nos viramos: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (texture_coord.x - <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> &gt; x) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); }</code> </pre> <br><p>  O que recebemos se assemelha a ondas sonoras.  Mais precisamente, sua imagem no oscilosc√≥pio.  De fato, em vez de nossos sinus√≥ides poder√≠amos transmitir dados de algum tipo de arquivo de som.  Mas trabalhar com som √© um t√≥pico para um artigo separado. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEeO" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="maski">  M√°scaras </h2><br><p>  Os exemplos anteriores devem levar a uma observa√ß√£o bastante l√≥gica: tudo isso se parece com o trabalho de m√°scaras no SVG (se voc√™ n√£o trabalhou com eles, veja exemplos no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√°scaras SVG e efeitos uau</a> ).  S√≥ que aqui n√≥s os fazemos de maneira um pouco diferente.  E o resultado √© o mesmo - algumas √°reas s√£o pintadas com uma textura, outras com outra.  Apenas transi√ß√µes suaves ainda n√£o foram.  Ent√£o vamos fazer um. </p><br><p>  N√≥s removemos todos os desnecess√°rios e retornamos as coordenadas do mouse.  Fa√ßa um gradiente radial com o centro na localiza√ß√£o do cursor e use-o como uma m√°scara.  Neste exemplo, o comportamento do sombreador se assemelhar√° mais √† l√≥gica das m√°scaras no SVG do que nos exemplos anteriores.  Precisamos de uma fun√ß√£o de <code>mix</code> e alguma fun√ß√£o de dist√¢ncia.  A primeira mistura os valores das cores dos pixels das duas texturas, tomando como terceiro par√¢metro um coeficiente (de 0 a 1) que determina qual dos valores prevalecer√° como resultado.  Tomamos o m√≥dulo seno em fun√ß√£o da dist√¢ncia - ele fornecer√° apenas uma mudan√ßa suave no valor entre 0 e 1. </p><br><pre> <code class="hljs lisp">gl_FragColor = mix( <span class="hljs-name"><span class="hljs-name">texture2D</span></span>(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord), texture2D(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord), abs(<span class="hljs-name"><span class="hljs-name">sin</span></span>(<span class="hljs-name"><span class="hljs-name">length</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span> - u_mouse_position / u_canvas_size))))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  S√≥ isso.  Vejamos o resultado: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/bxBmwB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  A principal vantagem sobre o SVG √© √≥bvia: </p><br><blockquote>  Ao contr√°rio do SVG, aqui podemos facilmente fazer gradientes suaves para v√°rias fun√ß√µes matem√°ticas, e n√£o colet√°-los de muitos gradientes lineares. </blockquote><p>  Se voc√™ tiver uma tarefa mais simples que n√£o exija transi√ß√µes suaves ou formul√°rios complexos calculados no processo, provavelmente ser√° mais f√°cil implementar sem o uso de shaders.  Sim, e o desempenho em hardware fraco provavelmente ser√° melhor.  Escolha uma ferramenta com base em suas tarefas. </p><br><p>  Para fins educacionais, vamos ver outro exemplo.  Primeiro, fa√ßa um c√≠rculo no qual a textura permanecer√° como est√°: </p><br><pre> <code class="hljs objectivec">gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = distance(texture_coord, u_mouse_position / u_canvas_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  E preencha o resto com listras diagonais: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = sin((texture_coord.y - texture_coord.x) * <span class="hljs-number"><span class="hljs-number">200.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { gl_FragColor.rgb *= dist; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gl_FragColor.rgb *= dist / <span class="hljs-number"><span class="hljs-number">10.0</span></span>; }</code> </pre> <br><p>  As aceita√ß√µes s√£o as mesmas - multiplicamos o par√¢metro para o seno para aumentar a frequ√™ncia das faixas;  divida os valores obtidos em duas partes;  para cada uma das metades, transformamos a cor dos pixels √† nossa maneira.  √â √∫til lembrar que o desenho de linhas diagonais geralmente est√° associado √† adi√ß√£o de coordenadas em X e Y. Observe que tamb√©m usamos a dist√¢ncia do cursor do mouse ao alterar as cores, criando assim um tipo de sombra.  Da mesma forma, voc√™ pode us√°-lo com transforma√ß√µes geom√©tricas, em breve veremos isso no exemplo da pixeliza√ß√£o.  Enquanto isso, d√™ uma olhada no resultado desse shader: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/rZWqyK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Simples e bonito. </p><br><blockquote>  E sim, se voc√™ ficar um pouco confuso, poder√° criar texturas n√£o a partir de imagens, mas a partir de quadros de v√≠deos (existem muitos exemplos na rede, voc√™ pode facilmente descobrir) e aplicar todos os nossos efeitos a eles.  Muitos sites de diret√≥rio como o Awwwards usam esses efeitos em conjunto com o v√≠deo. </blockquote><p>  Vale lembrar mais um pensamento: </p><br><blockquote>  Ningu√©m se incomoda em usar uma das texturas como m√°scara.  Podemos tirar uma foto e usar os valores de cores de seus pixels em nossas transforma√ß√µes, sejam mudan√ßas em outras cores, mudan√ßas para os lados ou qualquer outra coisa que lhe vier √† mente. </blockquote><p>  Mas voltando a dividir o avi√£o em partes. </p><br><h2 id="pikselizaciya">  Pixeliza√ß√£o </h2><br><p>  Esse efeito √© um tanto √≥bvio, mas ao mesmo tempo √© t√£o comum que seria errado passar por aqui.  Divida nosso plano em quadrados, da mesma maneira que no exemplo com o gerador de ru√≠do e, em seguida, para todos os pixels dentro de cada quadrado, definimos a mesma cor.  √â obtido atrav√©s da mistura de valores dos cantos de um quadrado, j√° fizemos algo semelhante.  Para esse efeito, n√£o precisamos de f√≥rmulas complexas, portanto, some todos os valores e divida por 4 - o n√∫mero de √¢ngulos do quadrado. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin(u_time)) / <span class="hljs-number"><span class="hljs-number">20.0</span></span>; vec2 block_position = floor(texture_coord / block_size) * block_size; gl_FragColor = ( texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) ) / <span class="hljs-number"><span class="hljs-number">4.0</span></span>;</code> </pre> <br><p>  Novamente, amarramos um dos par√¢metros ao tempo no m√≥dulo senoidal para ver visualmente o que acontece quando ele muda. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/eLBPej" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="pikselnye-volny">  Ondas de pixel </h2><br><p>            ,       . </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin( length(texture_coord - u_mouse_position / u_canvas_size) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - u_time)) / <span class="hljs-number"><span class="hljs-number">100.0</span></span> + <span class="hljs-number"><span class="hljs-number">0.001</span></span>;</code> </pre> <br><p>   ,       0  1;        , ,    ,     .       ,      . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/sfi0zy/embed/preview/EeNdEr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>    "" ,              ,    -.     .       " ",     ,         .     .      ‚Äî  .       . </p><br><h2 id="itogi">  Sum√°rio </h2><br><p>         ,     ,  ,    ,           .                    -.     -       -  .          .          .    ,      ,      ,      . </p><br><hr><br><p> <em>PS:  ,   WebGL (      )          ?     ,   ,   .          ?</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt421821/">https://habr.com/ru/post/pt421821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt421809/index.html">API de simultaneidade Java EE</a></li>
<li><a href="../pt421811/index.html">A IETF prop√¥s um novo padr√£o para mensagens - o que voc√™ precisa saber</a></li>
<li><a href="../pt421815/index.html">Metal l√≠quido em um laptop seis meses depois</a></li>
<li><a href="../pt421817/index.html">Trabalhando com formul√°rios no React.js usando ferramentas b√°sicas</a></li>
<li><a href="../pt421819/index.html">ELK Stack para armazenar logs de aplicativos Django</a></li>
<li><a href="../pt421823/index.html">Como trouxemos o X-Ray x64</a></li>
<li><a href="../pt421827/index.html">O que ler sobre Java agora?</a></li>
<li><a href="../pt421829/index.html">Anomalia de Frango - um romance fant√°stico com pessoas reais de TI</a></li>
<li><a href="../pt421833/index.html">Escrevemos nosso programa mais simples para o ARM Cortex-M3</a></li>
<li><a href="../pt421835/index.html">Comiss√£o Interinstitucional desenvolve nova tecnologia para bloquear o Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>