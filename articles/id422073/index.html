<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🏭 🧝 ↔️ Cara termudah untuk mendukung pengintegrasian klien java dengan server java 🏠 👌🏿 🖖🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat menyelesaikan tugas sehari-hari dengan antarmuka aplikasi desktop berbasis JavaFX, Anda harus tetap membuat permintaan ke server web. Setelah mas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara termudah untuk mendukung pengintegrasian klien java dengan server java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422073/"><p>  Saat menyelesaikan tugas sehari-hari dengan antarmuka aplikasi desktop berbasis JavaFX, Anda harus tetap membuat permintaan ke server web.  Setelah masa J2EE dan singkatan RMI yang mengerikan, banyak yang telah berubah, dan panggilan server menjadi lebih ringan.  Standar untuk soket web dan pertukaran pesan teks sederhana dari konten apa pun cocok untuk masalah seperti itu.  Tetapi masalah dengan aplikasi perusahaan adalah bahwa keragaman dan jumlah permintaan membuat membuat dan melacak <em>EndPoints</em> dengan layanan bisnis yang dipilih secara terpisah menjadi rutinitas yang mengerikan dan menambahkan baris kode tambahan. </p><br><p> Tetapi bagaimana jika kita mengambil strategi yang diketik ketat dengan RMI sebagai dasar, di mana ada <em>antarmuka</em> java standar antara klien dan server yang menggambarkan metode, argumen dan jenis pengembalian, di mana beberapa anotasi ditambahkan, dan klien bahkan tidak secara ajaib melihat bahwa panggilan itu dilakukan melalui jaringan?  Bagaimana jika bukan hanya teks, tetapi objek java serial ditransmisikan melalui jaringan?  Bagaimana jika kita menambahkan kemudahan soket web dan keuntungannya pada kemungkinan panggilan klien dari server ke strategi ini?  Bagaimana jika respons asinkron dari soket web untuk klien diekang ke panggilan pemblokiran yang biasa, dan untuk panggilan yang tertunda, tambahkan kemungkinan untuk mengembalikan <em>Masa Depan</em> atau bahkan <em>CompletableFuture</em> ?  Bagaimana jika kita menambahkan kemampuan untuk berlangganan klien ke acara-acara tertentu dari server?  Bagaimana jika server memiliki sesi dan koneksi ke setiap klien?  Mungkin berubah menjadi bundel transparan yang baik yang akrab bagi setiap programmer java, karena sihir akan disembunyikan di balik antarmuka, dan dalam pengujian antarmuka dapat dengan mudah diganti.  Tapi itu tidak semua untuk aplikasi dimuat yang memproses, misalnya, kutipan pasar saham. </p><a name="habracut"></a><br><p>  Dalam aplikasi perusahaan dari praktik saya, kecepatan mengeksekusi kueri sql dan mentransfer data yang dipilih dari DBMS tidak dapat dibandingkan dengan overhead serialisasi dan panggilan reflektif.  Selain itu, jejak panggilan EJB yang mengerikan, menambah waktu eksekusi menjadi 4-10 ms bahkan untuk permintaan yang paling sederhana, bukan masalah, karena durasi permintaan tipikal adalah di koridor dari 50 ms hingga 250 ms. </p><br><p>  Mari kita mulai dengan yang paling sederhana - kita akan menggunakan pola objek Proxy untuk menerapkan keajaiban di balik metode antarmuka.  Misalkan saya memiliki metode untuk mendapatkan riwayat korespondensi pengguna dengan lawan-lawannya: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerChat</span></span></span></span>{ Map&lt;String, &lt;List&lt;String&gt;&gt; getHistory(Date when, String login); }</code> </pre> <br><p>  Kami akan membuat objek proxy menggunakan alat java standar dan memanggil metode yang diperlukan di dalamnya: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientProxyUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> BiFunction&lt;String, Class, RMIoverWebSocketProxyHandler&gt; defaultFactory = RMIoverWebSocketProxyHandler::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; clazz, String jndiName)</span></span></span><span class="hljs-function"> </span></span>{ T f = (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class[]{clazz}, defaultFactory.apply(jndiName, clazz)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f; } } <span class="hljs-comment"><span class="hljs-comment">//    //... ServerChat chat = ClientProxyUtils.create(ServerChat.class, "java:global/test_app/ServerChat"); Map&lt;String, &lt;List&lt;String&gt;&gt; history = chat.getHistory(new Date(), "tester"); //... //   </span></span></code> </pre> <br><p>  Jika pada saat yang sama Anda mengatur pabrik, dan mengimplementasikan instance objek proxy melalui antarmuka melalui cdi-injection, Anda akan mendapatkan keajaiban dalam bentuk paling murni.  Pada saat yang sama, membuka / menutup soket setiap saat tidak diperlukan sama sekali.  Sebaliknya, dalam aplikasi saya soket selalu terbuka dan siap untuk menerima dan memproses pesan.  Sekarang layak melihat apa yang terjadi di <em>RMIoverWebSocketProxyHandler</em> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RMIoverWebSocketProxyHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvocationHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OVERHEAD = <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CLIENT_INPUT_BUFFER_SIZE = <span class="hljs-number"><span class="hljs-number">0x1000000</span></span>;<span class="hljs-comment"><span class="hljs-comment">// 16mb public static final int SERVER_OUT_BUFFER_SIZE = CLIENT_INPUT_BUFFER_SIZE - OVERHEAD; String jndiName; Class interfaze; public RMIoverWebSocketProxyHandler(String jndiName, Class interfaze) { this.jndiName = jndiName; this.interfaze = interfaze; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Request request = new Request(); request.guid = UUID.randomUUID().toString(); request.jndiName = jndiName; request.methodName = method.getName(); request.args = args; request.argsType = method.getParameterTypes(); request.interfaze = interfaze; WaitList.putRequest(request, getRequestRunnable(request)); checkError(request, method); return request.result; } public static Runnable getRequestRunnable(Request request) throws IOException { final byte[] requestBytes = write(request); return () -&gt; { try { sendByByteBuffer(requestBytes, ClientRMIHandler.clientSession); } catch (IOException ex) { WaitList.clean(); ClientRMIHandler.notifyErrorListeners(new RuntimeException(FATAL_ERROR_MESSAGE, ex)); } }; } public static byte[] write(Object object) throws IOException { try (ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream ous = new ObjectOutputStream(baos)) { ous.writeObject(object); return baos.toByteArray(); } } public static void sendByByteBuffer(byte[] responseBytes, Session wsSession) throws IOException { ... } public static void checkError(Request request, Method method) throws Throwable { ... } @FunctionalInterface public interface Callback&lt;V&gt; { V call() throws Throwable; } }</span></span></code> </pre><br><p>  Dan inilah <em>EndPoint</em> klien yang sebenarnya <em>itu sendiri</em> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ClientEndpoint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientRMIHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Session clientSession; <span class="hljs-meta"><span class="hljs-meta">@OnOpen</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOpen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Session session)</span></span></span><span class="hljs-function"> </span></span>{ clientSession = session; } <span class="hljs-meta"><span class="hljs-meta">@OnMessage</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteBuffer message, Session session)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object readInput = read(message); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readInput <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Response) { standartResponse((Response) readInput); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { WaitList.clean(); notifyErrorListeners(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(FATAL_ERROR_MESSAGE, ex)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">standartResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Response response)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> RuntimeException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.guid == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { notifyErrorListeners(response.error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } WaitList.clean(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RuntimeException runtimeException = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(FATAL_ERROR_MESSAGE); notifyErrorListeners(runtimeException); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> runtimeException; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { WaitList.processResponse(response); } } <span class="hljs-meta"><span class="hljs-meta">@OnClose</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Session session, CloseReason closeReason)</span></span></span><span class="hljs-function"> </span></span>{ WaitList.clean(); } <span class="hljs-meta"><span class="hljs-meta">@OnError</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Session session, Throwable error)</span></span></span><span class="hljs-function"> </span></span>{ notifyErrorListeners(error); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteBuffer message)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ClassNotFoundException, IOException </span></span>{ Object readObject; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[message.remaining()]; <span class="hljs-comment"><span class="hljs-comment">// don't use message.array() becouse it is optional message.get(b); try (ByteArrayInputStream bais = new ByteArrayInputStream(b); ObjectInputStream ois = new ObjectInputStream(bais)) { readObject = ois.readObject(); } return readObject; } }</span></span></code> </pre><br><p>  Dengan demikian, untuk memanggil metode apa pun dari objek proxy, kami mengambil sesi soket terbuka, mengirim argumen yang dikirimkan dan rincian metode yang harus dipanggil di server, dan menunggu respons dengan panduan yang ditentukan dalam permintaan yang akan diterima.  Setelah menerima respons, kami memeriksa pengecualian, dan jika semuanya baik-baik saja, kami memasukkan hasil respons dalam Permintaan dan memberi tahu aliran yang menunggu respons di WaitList.  Saya tidak akan memberikan implementasi WaitList tersebut, karena sepele.  Utas tunggu, paling-paling, akan terus berfungsi setelah baris <em>WaitList.putRequest (request, getRequestRunnable (request));</em>  .  Setelah bangun, utas akan memeriksa pengecualian yang dinyatakan di bagian <em>lemparan</em> , dan akan mengembalikan hasilnya melalui <em>pengembalian</em> . </p><br><p>  Contoh kode di atas adalah kutipan dari perpustakaan, yang belum siap untuk dikirim ke github.  Hal ini diperlukan untuk mengatasi masalah perizinan.  Masuk akal untuk melihat implementasi dari sisi server sudah dalam kode sumber itu sendiri setelah publikasi.  Tapi tidak ada yang istimewa di sana - pencarian dilakukan untuk objek ejb yang mengimplementasikan antarmuka yang ditentukan dalam jndi melalui InitialContext dan panggilan reflektif dibuat menggunakan rincian yang dikirim.  Tentu saja masih ada banyak hal menarik, tetapi volume informasi seperti itu tidak akan cocok dengan artikel mana pun.  Di perpustakaan itu sendiri, skrip panggilan pemblokiran di atas diimplementasikan pertama-tama, karena itu adalah yang paling sederhana.  Dukungan kemudian untuk panggilan non-blocking melalui <em>Future</em> dan <em>CompletableFuture &lt;&gt;</em> telah ditambahkan.  Perpustakaan berhasil digunakan di semua produk dengan klien java desktop.  Saya akan senang jika seseorang berbagi pengalaman mereka membuka kode sumber yang terhubung dengan gnu gpl 2.0 ( <em>tyrus-standalone-client</em> ). </p><br><p>  Akibatnya, tidak sulit untuk membangun hierarki pemanggilan metode menggunakan alat IDE standar ke bentuk UI itu sendiri, di mana penangan tombol menarik layanan jarak jauh.  Pada saat yang sama, kami mendapatkan ketikan yang ketat dan konektivitas yang lemah dari lapisan integrasi klien dan server.  Struktur kode sumber aplikasi dibagi menjadi klien, server, dan kernel, yang dihubungkan oleh kecanduan klien dan server.  Di dalamnya semua antarmuka <em>jarak jauh</em> dan objek yang ditransfer berada.  Dan rutin pengembang yang terkait dengan permintaan dalam database memerlukan metode baru dalam antarmuka dan implementasinya di sisi server.  Menurut saya, lebih mudah ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422073/">https://habr.com/ru/post/id422073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422057/index.html">Penelitian: Java adalah bahasa paling populer di cloud - siapa yang menggunakannya dan mengapa</a></li>
<li><a href="../id422059/index.html">Bongkar data di Excel. Beradab</a></li>
<li><a href="../id422061/index.html">Server kompak dengan pemuatan kode yang disesuaikan dan log sql oleh satu tim pakar untuk pengembangan produktif</a></li>
<li><a href="../id422069/index.html">PHP Digest No. 138 (20 Agustus - 2 September 2018)</a></li>
<li><a href="../id422071/index.html">Cukup untuk semua orang, atau bagaimana menyampaikan Internet ke negara-negara berkembang</a></li>
<li><a href="../id422077/index.html">Apakah injeksi JavaScript relevan?</a></li>
<li><a href="../id422079/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 329 (27 Agustus - 2 September 2018)</a></li>
<li><a href="../id422081/index.html">Aplikasi untuk kerangka kerja untuk bot multi-platform</a></li>
<li><a href="../id422083/index.html">Situs satu halaman di Kotlin dan SpringBoot tanpa menggunakan JSP</a></li>
<li><a href="../id422085/index.html">Sortir berdasarkan pilihan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>