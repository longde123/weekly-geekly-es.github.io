<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ©Ô∏è üé´ üîá Como acelerar o trabalho com a API da linguagem R usando computa√ß√£o paralela, usando o exemplo da API Yandex.Direct (Parte 1) üìî üè∏ üëâüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje, a linguagem R √© uma das ferramentas mais poderosas e multifuncionais para trabalhar com dados, mas como sabemos quase sempre, em qualquer barril...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como acelerar o trabalho com a API da linguagem R usando computa√ß√£o paralela, usando o exemplo da API Yandex.Direct (Parte 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437078/"><p>  Hoje, a linguagem R √© uma das ferramentas mais poderosas e multifuncionais para trabalhar com dados, mas como sabemos quase sempre, em qualquer barril de mel h√° uma mosca na pomada.  O fato √© que R √© thread √∫nico por padr√£o. </p><br><p>  Provavelmente, isso n√£o vai incomod√°-lo por um tempo suficientemente longo, e √© improv√°vel que voc√™ fa√ßa essa pergunta.  Mas, por exemplo, se voc√™ tiver a tarefa de coletar dados de um grande n√∫mero de contas de publicidade da API, como Yandex.Direct, poder√° reduzir significativamente, pelo menos duas a tr√™s vezes, o tempo necess√°rio para coletar dados usando o multithreading. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/86f/042/b60/86f042b609e10a79893f2dfbc24fd6f8.jpg" alt="imagem"></p><a name="habracut"></a><br><p> O t√≥pico multithreading em R n√£o √© novo e foi levantado repetidamente em Habr√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , mas a √∫ltima publica√ß√£o remonta a 2013 e, como se costuma dizer, tudo o que √© novo est√° bem esquecido.  Al√©m disso, o multithreading foi discutido anteriormente para calcular modelos e treinar redes neurais, e falaremos sobre o uso de assincronia para trabalhar com a API.  No entanto, gostaria de aproveitar esta oportunidade para agradecer aos autores desses artigos porque  eles me ajudaram muito a escrever este artigo com suas publica√ß√µes. </p><br><h2 id="soderzhanie">  Conte√∫do </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que √© multithreading</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quais pacotes usaremos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desafio</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Autoriza√ß√£o no pacote Yandex.Direct, ryandexdirect</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Solu√ß√£o sequencial de thread √∫nico usando o loop for</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Solu√ß√£o multithreading em R</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pacote DoSNOW e recursos multithread</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pacote DoParallel</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de velocidade entre as tr√™s abordagens revisadas, pacote rbenchmark</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclus√£o</a> </li></ul><br><p>  A segunda parte do artigo, que trata de op√ß√µes mais modernas para implementar multithreading em R, est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><h2 id="chto-takoe-mnogopotochnost">  O que √© multithreading </h2><br><p>  <u><strong>One-threading (c√°lculos seq√ºenciais)</strong></u> - um modo de c√°lculo no qual todas as a√ß√µes (tarefas) s√£o executadas seq√ºencialmente, a dura√ß√£o total de todas as opera√ß√µes especificadas nesse caso ser√° igual √† soma da dura√ß√£o de todas as opera√ß√µes. </p><br><p>  <u><strong>Multithreading (computa√ß√£o paralela)</strong></u> - um modo de computa√ß√£o no qual as a√ß√µes (tarefas) especificadas s√£o executadas em paralelo, ou seja,  ao mesmo tempo, enquanto o tempo total de execu√ß√£o de todas as opera√ß√µes n√£o ser√° igual √† soma da dura√ß√£o de todas as opera√ß√µes. </p><br><p>  Para simplificar a percep√ß√£o, vejamos a tabela a seguir: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f01/295/d5d/f01295d5dcf31db7d8ea8826c724f271.png" alt="imagem"></p><br><p>  A primeira linha da tabela fornecida √© de unidades de tempo condicionais. Nesse caso, n√£o importa para n√≥s segundos, minutos ou outros per√≠odos. </p><br><p>  Neste exemplo, precisamos executar 4 opera√ß√µes, cada opera√ß√£o neste caso tem uma dura√ß√£o de c√°lculo diferente, no modo de thread √∫nico, todas as 4 opera√ß√µes ser√£o executadas sequencialmente uma ap√≥s a outra, portanto, o tempo total para sua execu√ß√£o ser√° t1 + t2 + t3 + t4, 3 + 1 + 5 + 4 = 13. </p><br><p>  No modo multiencadeado, todas as 4 tarefas ser√£o executadas em paralelo, ou seja,  para iniciar a pr√≥xima tarefa, n√£o h√° necessidade de esperar at√© que a anterior seja conclu√≠da; portanto, se iniciarmos nossa tarefa em 4 threads, o tempo total de c√°lculo ser√° igual ao tempo de c√°lculo da maior tarefa; no nosso caso, √© a tarefa t3, cuja dura√ß√£o do c√°lculo em nosso exemplo √© 5 unidades tempor√°rias, respectivamente, e o tempo de execu√ß√£o de todas as 4 opera√ß√µes nesse caso ser√° igual a 5 unidades tempor√°rias. </p><br><h2 id="kakie-pakety-my-budem-ispolzovat">  Quais pacotes usaremos </h2><br><p> Para c√°lculos no modo multithread, usaremos os <code>doParallel</code> <code>foreach</code> , <code>doSNOW</code> e <code>doParallel</code> . </p><br><p>  O pacote <code>foreach</code> permite que voc√™ use a constru√ß√£o <code>foreach</code> , que √© essencialmente um loop for aprimorado. </p><br><p>  Os <code>doParallel</code> e <code>doParallel</code> s√£o essencialmente irm√£os g√™meos, permitindo criar clusters virtuais e us√°-los para realizar c√°lculos paralelos. </p><br><p>  No final do artigo, usando o pacote <code>rbenchmark</code> mediremos e comparamos a dura√ß√£o das opera√ß√µes de coleta de dados da API Yandex.Direct usando todos os m√©todos descritos abaixo. </p><br><p>  Para trabalhar com a API Yandex.Direct, usaremos o pacote ryandexdirect; neste artigo, usaremos como exemplo, mais detalhes sobre seus recursos e fun√ß√µes podem ser encontrados na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o oficial</a> . </p><br><p>  C√≥digo para instalar todos os pacotes necess√°rios: </p><br><pre> <code class="plaintext hljs">install.packages("foreach") install.packages("doSNOW") install.packages("doParallel") install.packages("rbenchmark") install.packages("ryandexdirect")</code> </pre> <br><h2 id="zadacha">  Desafio </h2><br><p>  Voc√™ deve escrever um c√≥digo que solicite uma lista de palavras-chave de qualquer n√∫mero de contas de publicidade Yandex.Direct.  O resultado deve ser coletado em um per√≠odo, no qual haver√° um campo adicional com o login da conta de publicidade √† qual a palavra-chave pertence. </p><br><p>  Al√©m disso, nossa tarefa √© escrever um c√≥digo que execute essa opera√ß√£o o mais r√°pido poss√≠vel em qualquer n√∫mero de contas de publicidade. </p><br><h2 id="avtorizaciya-v-yandeksdirekt">  Autoriza√ß√£o no Yandex.Direct </h2><br><p>  Para trabalhar com a API da plataforma de publicidade Yandex.Direct, inicialmente √© necess√°rio passar por uma autoriza√ß√£o em cada conta da qual planejamos solicitar uma lista de palavras-chave. </p><br><p>  Todo o c√≥digo fornecido neste artigo reflete um exemplo de trabalho com contas de publicidade Yandex.Direct regulares, se voc√™ estiver trabalhando em uma conta de agente, precisar√° usar o argumento <em>AgencyAccount</em> e passar o login da conta do agente para ele.  Voc√™ pode descobrir mais sobre como trabalhar com contas de agente do Yandex.Direct usando o pacote ryandexdirect <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Para autoriza√ß√£o, √© necess√°rio executar a fun√ß√£o <code>yadirAuth</code> partir do pacote <code>yadirAuth</code> , repetir o c√≥digo abaixo √© necess√°rio para cada conta da qual voc√™ solicitar√° uma lista de palavras-chave e seus par√¢metros. </p><br><pre> <code class="plaintext hljs">ryandexdirect::yadirAuth(Login = "    ")</code> </pre> <br><p>  O processo de autoriza√ß√£o no Yandex.Direct atrav√©s do pacote <code>ryandexdirect</code> totalmente seguro, apesar de ser transmitido por um site de terceiros.  Eu j√° falei detalhadamente sobre a seguran√ßa de seu uso no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Qu√£o seguro √© usar pacotes R para trabalhar com a API de sistemas de publicidade"</a> </p><br><p>  Ap√≥s a autoriza√ß√£o, um arquivo <em>login.yadirAuth.RData</em> ser√° criado em cada conta no seu diret√≥rio de trabalho, que armazenar√° as credenciais para cada conta.  O nome do arquivo ser√° iniciado no login especificado no argumento <em>Login</em> .  Se voc√™ precisar salvar arquivos que n√£o est√£o no diret√≥rio de trabalho atual, mas em alguma outra pasta, use o argumento <em>TokenPath</em> , mas, neste caso, ao consultar palavras-chave usando a fun√ß√£o <code>yadirGetKeyWords</code> tamb√©m ser√° necess√°rio usar o argumento <em>TokenPath</em> e especificar o caminho para a pasta onde voc√™ salvou os arquivos com credenciais. </p><br><h2 id="reshenie-v-odnopotochnom-posledovatelnom-rezhime-s-ispolzovaniem-cikla-for">  Solu√ß√£o sequencial de thread √∫nico usando o loop for </h2><br><p>  A maneira mais f√°cil de coletar dados de v√°rias contas ao mesmo tempo √© usar o loop <code>for</code> .  Simples, mas n√£o o mais eficaz, porque  Um dos princ√≠pios de desenvolvimento na linguagem R √© evitar o uso de loops no c√≥digo. </p><br><p>  Abaixo est√° um c√≥digo de exemplo para coletar dados de 4 contas usando o loop for; na verdade, voc√™ pode usar este exemplo para coletar dados de qualquer n√∫mero de contas de publicidade. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 1: processamos 4 contas usando o loop for usual</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(ryandexdirect) #   logins &lt;- c("login_1", "login_2", "login_3", "login_4") #    res1 &lt;- data.frame() #    for (login in logins) { temp &lt;- yadirGetKeyWords(Login = login) temp$login &lt;- login res1 &lt;- rbind(res1, temp) }</code> </pre> </div></div><br><p>  A medi√ß√£o do tempo de execu√ß√£o usando a fun√ß√£o system.time mostrou o seguinte resultado: </p><br><p>  <strong>Tempo de trabalho:</strong> <br>  <u>Usu√°rio:</u> 178.83 <br>  <u>sistema:</u> 0.63 <br>  <u>passou:</u> 320.39 </p><br><p>  A coleta de palavras-chave para 4 contas levou 320 segundos e, a partir das mensagens informativas que a fun√ß√£o <code>yadirGetKeyWords</code> exibe durante a opera√ß√£o, a maior conta √© vista, das quais 5970 palavras-chave foram recebidas, 142 segundos foram processados. </p><br><h2 id="reshenie-s-pomoschyu-mnogopotochnosti-v-r">  Solu√ß√£o multithreading em R </h2><br><p>  Eu j√° escrevi acima que, para multithreading, usaremos os <code>doParallel</code> e <code>doParallel</code> . </p><br><p>  Quero chamar a aten√ß√£o para o fato de que quase qualquer API tem suas pr√≥prias limita√ß√µes, e a API Yandex.Direct n√£o √© exce√ß√£o.  De fato, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ajuda</a> para trabalhar com a API Yandex.Direct diz: </p><br><blockquote>  N√£o s√£o permitidas mais de cinco solicita√ß√µes simult√¢neas de API em nome de um usu√°rio. </blockquote><p>  Portanto, apesar de, neste caso, considerarmos um exemplo com a cria√ß√£o de 4 fluxos, ao trabalhar com o Yandex.Direct, voc√™ pode criar 5 fluxos, mesmo que envie todas as solicita√ß√µes sob o mesmo usu√°rio.  Mas √© mais racional usar 1 encadeamento por 1 n√∫cleo do seu processador, voc√™ pode determinar o n√∫mero de n√∫cleos f√≠sicos do processador usando o comando <code>parallel::detectCores(logical = FALSE)</code> , o n√∫mero de n√∫cleos l√≥gicos pode ser encontrado usando o <code>parallel::detectCores(logical = TRUE)</code> .  Uma compreens√£o mais detalhada do que √© poss√≠vel ter um n√∫cleo l√≥gico e f√≠sico na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wikipedia</a> . </p><br><p>  Al√©m do limite no n√∫mero de solicita√ß√µes, h√° um limite di√°rio no n√∫mero de pontos para acessar a API Yandex.Direct, pode ser diferente para todas as contas, cada solicita√ß√£o tamb√©m consome um n√∫mero diferente de pontos, dependendo da opera√ß√£o que est√° sendo executada.  Por exemplo, para consultar uma lista de palavras-chave, ser√£o deduzidos 15 pontos para uma consulta conclu√≠da e 3 pontos para cada 2000 palavras, voc√™ pode descobrir como os pontos s√£o baixados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">certificado oficial</a> .  Voc√™ tamb√©m pode ver informa√ß√µes sobre o n√∫mero de pontos marcados e dispon√≠veis, bem como o limite di√°rio das mensagens de informa√ß√µes retornadas ao console pela fun√ß√£o <code>yadirGetKeyWords</code> . </p><br><pre> <code class="plaintext hljs">Number of API points spent when executing the request: 60 Available balance of daily limit API points: 993530 Daily limit of API points:996000</code> </pre> <br><p>  Vamos lidar com <code>doSNOW</code> e <code>doParallel</code> em ordem. </p><br><h3 id="paket-dosnow-i-osobennosti-raboty-v-mnogopotochnom-rezhime">  Pacote DoSNOW e recursos multithread </h3><br><p>  Reescrevemos a mesma opera√ß√£o para o modo de c√°lculos multithread, criamos 4 threads nesse caso e, em vez do loop <code>for</code> , usamos a constru√ß√£o <code>foreach</code> . </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 2: computa√ß√£o paralela com doSNOW</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(foreach) library(doSNOW) #   logins &lt;- c("login_1", "login_2", "login_3", "login_4") cl &lt;- makeCluster(4) registerDoSNOW(cl) res2 &lt;- foreach(login = logins, #  -  .combine = 'rbind', #        .packages = "ryandexdirect", #   .inorder=F ) %dopar% {cbind(yadirGetKeyWords(Login = login), login) } stopCluster(cl)</code> </pre> </div></div><br><p>  Nesse caso, a medi√ß√£o do tempo de execu√ß√£o usando a fun√ß√£o system.time mostrou o seguinte resultado: </p><br><p>  <strong>Tempo de trabalho:</strong> <br>  <u>usu√°rio:</u> 0,17 <br>  <u>sistema:</u> 0.08 <br>  <u>aprovada:</u> 151.47 </p><br><p>  O mesmo resultado, ou seja,  recebemos a cole√ß√£o de palavras-chave de 4 contas Yandex.Diretas em 151 segundos, ou seja,  2 vezes mais r√°pido.  Al√©m disso, escrevi no √∫ltimo exemplo quanto tempo levou para carregar uma lista de palavras-chave da maior conta (142 segundos), ou seja,  neste exemplo, o tempo total √© quase id√™ntico ao tempo de processamento da maior conta.  O fato √© que, com a ajuda da fun√ß√£o <code>foreach</code> , lan√ßamos simultaneamente o processo de coleta de dados em 4 fluxos, ou seja,  ao mesmo tempo, coletamos dados das 4 contas, respectivamente, o tempo total √© igual ao tempo de processamento da maior conta. </p><br><p>  <code>makeCluster</code> dar uma pequena explica√ß√£o para o <em>c√≥digo 2</em> , a fun√ß√£o <code>makeCluster</code> respons√°vel pelo n√∫mero de threads, nesse caso, criamos um cluster de 4 n√∫cleos de processador, mas como escrevi anteriormente ao trabalhar com a API Yandex.Direct, voc√™ pode criar 5 threads, independentemente de quantas contas voc√™ precisa processar 5-15-100 ou mais, pode enviar 5 solicita√ß√µes para a API ao mesmo tempo. </p><br><p>  Em seguida, a fun√ß√£o <code>registerDoSNOW</code> inicia o cluster criado. </p><br><p>  Depois disso, usamos a constru√ß√£o <code>foreach</code> , como eu disse anteriormente, essa constru√ß√£o √© um loop for aprimorado.  Voc√™ define o contador como o primeiro argumento, no exemplo que chamei de <em>login</em> e ele iterar√° sobre os elementos do vetor <em>logins</em> a cada itera√ß√£o; obter√≠amos o mesmo resultado no loop for se escrev√™ssemos <code>for ( login in logins)</code> . </p><br><p>  Em seguida, voc√™ precisa indicar no argumento <em>.combine</em> a fun√ß√£o com a qual voc√™ combinar√° os resultados obtidos em cada itera√ß√£o, as op√ß√µes mais comuns s√£o: </p><br><ul><li>  <code>rbind</code> - une as tabelas resultantes linha por linha, uma sob a outra; </li><li>  <code>cbind</code> - une as tabelas resultantes em colunas; </li><li>  <code>"+"</code> - resume o resultado obtido em cada itera√ß√£o. </li></ul><br><p>  Voc√™ tamb√©m pode usar qualquer outra fun√ß√£o, mesmo auto-escrita. </p><br><p>  O argumento <em>.inorder = F</em> permite acelerar um pouco mais a fun√ß√£o se voc√™ n√£o se importa em que ordem combinar os resultados; nesse caso, a ordem n√£o √© importante para n√≥s. </p><br><p>  A seguir, vem o operador <code>%dopar%</code> , que inicia o loop no modo de computa√ß√£o paralela; se voc√™ usar o operador <code>%do%</code> , as itera√ß√µes ser√£o executadas sequencialmente, como no loop <code>for</code> usual. </p><br><p>  A fun√ß√£o <code>stopCluster</code> para o cluster. </p><br><p>  Multithreading, ou melhor, a constru√ß√£o <code>foreach</code> no modo multithread, possui alguns recursos; de fato, nesse caso, iniciamos cada processo paralelo em uma nova sess√£o R limpa.  Portanto, para usar as fun√ß√µes e objetos gen√©ricos dentro dele que foram definidos fora da constru√ß√£o <code>foreach</code> , voc√™ precisa export√°-los usando o argumento <em>.export</em> .  Esse argumento usa um vetor de texto que cont√©m os nomes dos objetos que voc√™ usar√° dentro do <code>foreach</code> . </p><br><p>  Al√©m disso, o <code>foreach</code> , no modo paralelo, n√£o v√™ os pacotes conectados anteriormente por padr√£o, portanto, eles tamb√©m precisam ser passados ‚Äã‚Äãdentro do foreach usando o argumento <em>.packages</em> .  Tamb√©m √© necess√°rio transferir pacotes listando seus nomes em um vetor de texto, por exemplo <code>.packages = c("ryandexdirect", "dplyr", "lubridate")</code> .  No exemplo de <em>c√≥digo 2</em> acima, dessa maneira, carregamos o pacote <strong>ryandexdirect</strong> a cada itera√ß√£o do <code>foreach</code> . </p><br><h3 id="paket-doparallel">  Pacote DoParallel </h3><br><p>  Como escrevi acima, os <code>doParallel</code> e <code>doParallel</code> s√£o g√™meos, portanto, eles t√™m a mesma sintaxe. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 5: computa√ß√£o paralela com doParallel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(foreach) library(doParallel) logins &lt;- c("login_1", "login_2", "login_3", "login_4") cl &lt;- makeCluster(4) registerDoParallel(cl) res3 &lt;- data.frame() res3 &lt;- foreach(login=logins, .combine= 'rbind', .inorder=F) %dopar% {cbind(ryandexdirect::yadirGetKeyWords(Login = login), login) stopCluster(cl)</code> </pre> </div></div><br><p>  <strong>Tempo de trabalho:</strong> <br>  <u>usu√°rio:</u> 0,25 <br>  <u>sistema:</u> 0.01 <br>  <u>aprovada:</u> 173.28 </p><br><p>  Como voc√™ pode ver neste caso, o tempo de execu√ß√£o difere um pouco do exemplo anterior de c√≥digo de computa√ß√£o paralela usando o pacote <code>doSNOW</code> . </p><br><h2 id="test-skorosti-mezhdu-tremya-rassmotrennymi-podhodami">  Teste de velocidade entre as tr√™s abordagens revisadas </h2><br><p>  Agora execute o teste de velocidade usando o pacote <code>rbenchmark</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a63/b9d/2d4/a63b9d2d476203e701c1c789f013793b.png" alt="imagem"></p><br><p>  Como voc√™ pode ver, mesmo em um teste de 4 contas, os <code>doParallel</code> e <code>doParallel</code> receberam dados por palavras-chave 2 vezes mais r√°pido que o loop for sequencial, se voc√™ criar um cluster de 5 n√∫cleos e processar 50 ou 100 contas, a diferen√ßa ser√° ainda mais significativa. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo 6: Script para comparar a velocidade da multithreading e da computa√ß√£o seq√ºencial</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#   library(ryandexdirect) library(foreach) library(doParallel) library(doSNOW) library(rbenchmark) #         for for_fun &lt;- function(logins) { res1 &lt;- data.frame() for (login in logins) { temp &lt;- yadirGetKeyWords(Login = login) res1 &lt;- rbind(res1, temp) } return(res1) } #         foreach   doSNOW dosnow_fun &lt;- function(logins) { cl &lt;- makeCluster(4) registerDoSNOW(cl) res2 &lt;- data.frame() system.time({ res2 &lt;- foreach(login=logins, .combine= 'rbind') %dopar% {temp &lt;- ryandexdirect::yadirGetKeyWords(Login = login } }) stopCluster(cl) return(res2) } #         foreach   doParallel dopar_fun &lt;- function(logins) { cl &lt;- makeCluster(4) registerDoParallel(cl) res2 &lt;- data.frame() system.time({ res2 &lt;- foreach(login=logins, .combine= 'rbind') %dopar% {temp &lt;- ryandexdirect::yadirGetKeyWords(Login = login) } }) stopCluster(cl) return(res2) } #          within(benchmark(for_cycle = for_fun(logins = logins), dosnow = dosnow_fun(logins = logins), doparallel = dopar_fun(logins = logins), replications = c(20), columns=c('test', 'replications', 'elapsed'), order=c('elapsed', 'test')), { average = elapsed/replications })</code> </pre></div></div><br><p>  Concluindo, darei uma explica√ß√£o do <em>c√≥digo 5</em> acima, com o qual testamos a velocidade do trabalho. </p><br><p>  Inicialmente, criamos tr√™s fun√ß√µes: </p><br><p>  <code>for_fun</code> - uma fun√ß√£o que solicita palavras-chave de v√°rias contas, classificando-as sequencialmente em um ciclo regular. </p><br><p>  <code>dosnow_fun</code> - uma fun√ß√£o que solicita uma lista de palavras-chave no modo multithread, usando o pacote <code>doSNOW</code> . </p><br><p>  <code>dopar_fun</code> - uma fun√ß√£o que solicita uma lista de palavras-chave no modo multithread, usando o pacote <code>doParallel</code> . </p><br><p>  Em seguida, dentro da constru√ß√£o inside, executamos a fun√ß√£o <code>benchmark</code> no pacote <code>rbenchmark</code> , especificamos os nomes dos testes (for_cycle, dosnow, doparallel) e cada fun√ß√£o especificamos as fun√ß√µes, respectivamente: <code>for_fun(logins = logins)</code> ;  <code>dosnow_fun(logins = logins)</code> ;  <code>dopar_fun(logins = logins)</code> . </p><br><p>  O argumento de <em>replica√ß√£o</em> √© respons√°vel pelo n√∫mero de testes, ou seja,  quantas vezes executaremos cada fun√ß√£o. </p><br><p>  O argumento de <em>colunas</em> permite especificar quais colunas voc√™ deseja receber, no nosso caso 'teste', 'replica√ß√µes', 'decorrido' significa retornar as colunas: nome do teste, n√∫mero de testes, tempo total de execu√ß√£o de todos os testes. </p><br><p>  Voc√™ tamb√©m pode adicionar colunas calculadas ( <code>{ average = elapsed/replications }</code> ), ou seja,  a sa√≠da ser√° uma coluna m√©dia que dividir√° o tempo total pelo n√∫mero de testes, portanto calculamos o tempo m√©dio de execu√ß√£o de cada fun√ß√£o. </p><br><p>  <em>O pedido</em> √© respons√°vel pela classifica√ß√£o dos resultados do teste. </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  Neste artigo, em princ√≠pio, √© descrito um m√©todo bastante universal para acelerar o trabalho com a API, mas cada API tem seus limites, portanto, especificamente neste formul√°rio, com tantos threads, o exemplo acima √© adequado para trabalhar com a API Yandex.Direct, para us√°-lo com a API. de outros servi√ßos, √© necess√°rio inicialmente ler a documenta√ß√£o sobre os limites da API no n√∫mero de solicita√ß√µes enviadas simultaneamente, caso contr√°rio, voc√™ poder√° receber um erro de <code>Too Many Requests</code> excesso. </p><br><p>  A continua√ß√£o deste artigo est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437078/">https://habr.com/ru/post/pt437078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437068/index.html">ILV desbloqueia 2,7 milh√µes de endere√ßos IP</a></li>
<li><a href="../pt437070/index.html">Ferramentas de Ci√™ncia de Dados da Pesquisa 2019</a></li>
<li><a href="../pt437072/index.html">Nozes enfraquecidas nas regras Habr</a></li>
<li><a href="../pt437074/index.html">Google pode bloquear seu servi√ßo de not√≠cias na Europa</a></li>
<li><a href="../pt437076/index.html">A queda e recupera√ß√£o de um molde</a></li>
<li><a href="../pt437084/index.html">De Uncharted a Obra Dinn: Lucas Pope fala sobre sua carreira no desenvolvimento de jogos</a></li>
<li><a href="../pt437086/index.html">M√≠dia: hackers invadiram o banco de dados da US Securities Commission e ganharam milh√µes com informa√ß√µes privilegiadas</a></li>
<li><a href="../pt437088/index.html">Promo√ß√£o de uma startup no exterior: como alcan√ßar centenas de milhares de leitores que falam ingl√™s com o Medium</a></li>
<li><a href="../pt437092/index.html">A seguran√ßa dos algoritmos de aprendizado de m√°quina. Ataques de Python</a></li>
<li><a href="../pt437094/index.html">Impulsionamos o Atlassian Service Desk - o an√∫ncio da mitap e transmiss√£o ao vivo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>