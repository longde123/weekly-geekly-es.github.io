<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèª üò£ üßòüèº OpenSceneGraph: Gr√°fico de escena y punteros inteligentes üöµüèº üßÄ üéõÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 En un art√≠culo anterior, miramos el ensamblado OpenSceneGraph desde la fuente y escribimos un ejemplo elemental en el que un avi√≥n gris...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Gr√°fico de escena y punteros inteligentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429914/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="imagen"><br><br><h1>  Introduccion </h1><br>  En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior,</a> miramos el ensamblado OpenSceneGraph desde la fuente y escribimos un ejemplo elemental en el que un avi√≥n gris cuelga en un mundo p√∫rpura vac√≠o.  Estoy de acuerdo, no demasiado impresionante.  Sin embargo, como dije antes, en este peque√±o ejemplo, existen los conceptos principales en los que se basa este motor gr√°fico.  Consideremos con m√°s detalle.  El material a continuaci√≥n utiliza ilustraciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del blog</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alexander Bobkov sobre OSG</a> (es una pena que el autor haya abandonado la escritura sobre OSG ...).  El art√≠culo tambi√©n se basa en material y ejemplos del libro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenSceneGraph 3.0.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a para principiantes</a> <br><br>  Debo decir que la publicaci√≥n anterior fue objeto de algunas cr√≠ticas, con lo cual estoy parcialmente de acuerdo: el material sali√≥ sin decir y fuera de contexto.  Intentar√© arreglar esta omisi√≥n debajo del corte. <br><a name="habracut"></a><br><h1>  1. Brevemente sobre el gr√°fico de la escena y sus nodos. </h1><br>  El concepto central del motor es el llamado <i>gr√°fico de escena</i> (no es coincidencia que se haya quedado atascado en el nombre del marco mismo), una estructura jer√°rquica de √°rbol que le permite organizar una representaci√≥n l√≥gica y espacial de una escena tridimensional.  El gr√°fico de escena contiene el nodo ra√≠z y sus nodos o <i>nodos</i> intermedios y terminales asociados. <br><br>  Por ejemplo <br><br><img src="https://habrastorage.org/webt/va/m7/l4/vam7l4ap2qwqgyev2ofzlcbt-vo.png"><br><br>  Este gr√°fico representa una escena que consiste en una casa y una mesa en ella.  La casa tiene una cierta representaci√≥n geom√©trica y est√° ubicada de cierta manera en el espacio en relaci√≥n con alg√∫n sistema de coordenadas b√°sico asociado con el nodo ra√≠z (ra√≠z).  La tabla tambi√©n se describe mediante cierta geometr√≠a, ubicada de alguna manera en relaci√≥n con la casa, y junto con la casa, en relaci√≥n con el nodo ra√≠z.  Todos los nodos, que tienen una propiedad com√∫n, porque heredan de una clase osg :: Node, se dividen en tipos de acuerdo con su prop√≥sito funcional <br><br><ol><li>  Nodos de grupo (osg :: Group): son la clase base para todos los nodos intermedios y est√°n dise√±ados para combinar otros nodos en grupos </li><li>  Nodos de transformaci√≥n (osg :: Transform y sus descendientes): dise√±ados para describir la transformaci√≥n de coordenadas de objeto </li><li>  Nodos geom√©tricos (osg :: Geode): nodos terminales (hoja) del gr√°fico de escena que contienen informaci√≥n sobre uno o m√°s objetos geom√©tricos. </li></ol><br>  La geometr√≠a de los objetos de escena en OSG se describe en su propio sistema de coordenadas local del objeto.  Los nodos de transformaci√≥n ubicados entre este objeto y el nodo ra√≠z implementan transformaciones de coordenadas de matriz para obtener la posici√≥n del objeto en el sistema de coordenadas base. <br><br>  Los nodos realizan muchas funciones importantes, en particular, almacenan el estado de la visualizaci√≥n de objetos, y este estado afecta solo el subgrafo asociado con este nodo.  Se pueden asociar varias devoluciones de llamada con nodos en el gr√°fico de escena, controladores de eventos que le permiten cambiar el estado del nodo y el subgrafo asociado con √©l. <br><br>  El motor realiza autom√°ticamente todas las operaciones globales en el gr√°fico de escena asociadas con la obtenci√≥n del resultado final en la pantalla, recorriendo peri√≥dicamente el gr√°fico en profundidad. <br><br>  En el ejemplo examinado la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√∫ltima vez</a> , nuestra escena consist√≠a en un solo objeto: un modelo de avi√≥n cargado desde un archivo.  Mirando muy lejos, dir√© que este modelo es el nodo hoja del gr√°fico de escena.  Est√° firmemente soldado al sistema de coordenadas de base global del motor. <br><br><h1>  2. gesti√≥n de la memoria OSG </h1><br>  Dado que los nodos del gr√°fico de escena almacenan una gran cantidad de datos sobre objetos de escena y operaciones en ellos, es necesario asignar memoria, incluso din√°micamente, para almacenar estos datos.  En este caso, al manipular el gr√°fico de escena y, por ejemplo, al eliminar algunos de sus nodos, debe controlar cuidadosamente que los nodos eliminados del gr√°fico ya no se procesen.  Este proceso siempre va acompa√±ado de errores, depuraci√≥n que lleva mucho tiempo, ya que es bastante dif√≠cil para el desarrollador rastrear qu√© punteros a objetos se refieren a datos existentes y cu√°les deben eliminarse.  Sin una administraci√≥n de memoria efectiva, es m√°s probable que ocurran errores de segmentaci√≥n y p√©rdidas de memoria. <br><br>  La gesti√≥n de la memoria es una tarea cr√≠tica en OSG y su concepto se basa en dos puntos: <br><br><ol><li>  Asignaci√≥n de memoria: asegura la asignaci√≥n de la cantidad de memoria necesaria para almacenar un objeto. <br></li><li>  Liberar memoria: devuelve la memoria asignada al sistema cuando no es necesario. <br></li></ol><br>  Muchos lenguajes de programaci√≥n modernos, como C #, Java, Visual Basic .Net y similares, utilizan el llamado recolector de basura para liberar memoria asignada.  El concepto del lenguaje C ++ no proporciona tal enfoque, pero podemos imitarlo usando los llamados punteros inteligentes. <br><br>  Hoy en d√≠a, C ++ tiene punteros inteligentes en su arsenal, que se llama "listo para usar" (y el est√°ndar C ++ 17 ya ha logrado eliminar el lenguaje de algunos tipos obsoletos de punteros inteligentes), pero este no siempre ha sido el caso.  La primera de las versiones oficiales de OSG numeradas 0.9 naci√≥ en 2002, y hubo tres a√±os m√°s antes del primer lanzamiento oficial.  En ese momento, el est√°ndar C ++ a√∫n no proporcionaba punteros inteligentes, e incluso si cree en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una digresi√≥n hist√≥rica</a> , el lenguaje en s√≠ estaba pasando por tiempos dif√≠ciles.  Por lo tanto, la apariencia de una bicicleta en forma de sus propios punteros inteligentes, que se implementan en OSG, no es nada sorprendente.  Este mecanismo est√° profundamente integrado en la estructura del motor, por lo que comprender su funcionamiento es absolutamente necesario desde el principio. <br><br><h1>  3. Las clases referenciadas osg :: ref_ptr &lt;&gt; y osg :: </h1><br>  OSG proporciona su propio mecanismo de puntero inteligente basado en la clase de plantilla osg :: ref_ptr &lt;&gt; para implementar la recolecci√≥n autom√°tica de basura.  Para su correcto funcionamiento, OSG proporciona otra clase osg :: Referenced para administrar bloques de memoria para los cuales se cuenta la referencia a ellos. <br><br>  La clase osg :: ref_ptr &lt;&gt; proporciona varios operadores y m√©todos. <br><br><ul><li>  get () es un m√©todo p√∫blico que devuelve un puntero sin formato, por ejemplo, cuando se usa la plantilla osg :: Node como argumento, este m√©todo devolver√° osg :: Node *. <br></li><li>  operator * () es en realidad el operador de desreferencia. <br></li><li>  operator -&gt; () y operator = () - le permite usar osg :: ref_ptr &lt;&gt; como un puntero cl√°sico al acceder a los m√©todos y propiedades de los objetos descritos por este puntero. <br></li><li>  operator == (), operator! = () y operator! (): le permiten realizar operaciones de comparaci√≥n en punteros inteligentes. <br></li><li>  valid () es un m√©todo p√∫blico que devuelve true si el puntero administrado tiene el valor correcto (no NULL).  La expresi√≥n some_ptr.valid () es equivalente a la expresi√≥n some_ptr! = NULL si some_ptr es un puntero inteligente. <br></li><li>  release () es un m√©todo p√∫blico, √∫til cuando desea devolver una direcci√≥n administrada de una funci√≥n.  Sobre esto se describir√° con m√°s detalle m√°s adelante. <br></li></ul><br>  La clase osg :: Referenced es la clase base para todos los elementos del gr√°fico de escena, como nodos, geometr√≠a, estados de representaci√≥n y otros objetos colocados en el escenario.  Por lo tanto, al crear el nodo ra√≠z de la escena, heredamos indirectamente toda la funcionalidad proporcionada por la clase osg :: Referenced.  Por lo tanto, en nuestro programa hay un anuncio <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root;</code> </pre> <br>  La clase osg :: Referenced contiene un contador entero para referencias al bloque de memoria asignado.  Este contador se inicializa a cero en el constructor de la clase.  Se incrementa en uno cuando se crea el objeto osg :: ref_ptr &lt;&gt;.  Este contador disminuye en cuanto se elimina cualquier referencia al objeto descrito por este puntero.  Un objeto se destruye autom√°ticamente cuando los punteros inteligentes dejan de hacer referencia a √©l. <br><br>  La clase osg :: Referenced tiene tres m√©todos p√∫blicos: <br><br><ul><li>  ref () es un m√©todo p√∫blico que se incrementa en 1 recuento de referencia. <br></li><li>  unref () es un m√©todo p√∫blico, que disminuye en 1 recuento de referencia. <br></li><li>  referenceCount () es un m√©todo p√∫blico que devuelve el valor actual del contador de referencia, que es √∫til al depurar c√≥digo. <br></li></ul><br>  Estos m√©todos est√°n disponibles en todas las clases derivadas de osg :: Referenced.  Sin embargo, debe recordarse que el control manual del contador de enlaces puede tener consecuencias impredecibles, y al usar esto debe comprender claramente lo que est√° haciendo. <br><br><h1>  4. C√≥mo OSG recolecta basura y por qu√© es necesaria </h1><br>  Hay varias razones por las cuales se deben utilizar punteros inteligentes y recolecci√≥n de basura: <br><br><ul><li>  Minimizaci√≥n de errores cr√≠ticos: el uso de punteros inteligentes le permite automatizar la asignaci√≥n y la liberaci√≥n de memoria.  No hay punteros crudos peligrosos. <br></li><li>  Gesti√≥n eficaz de la memoria: la memoria asignada para el objeto se libera inmediatamente, tan pronto como el objeto se vuelve innecesario, lo que conduce al uso econ√≥mico de los recursos del sistema. <br></li><li>  Facilitaci√≥n de la depuraci√≥n de aplicaciones: al tener la capacidad de rastrear claramente el n√∫mero de enlaces a un objeto, tenemos oportunidades para varios tipos de optimizaciones y experimentos. <br></li></ul><br>  Suponga que un gr√°fico de escena consta de un nodo ra√≠z y varios niveles de nodos secundarios.  Si el nodo ra√≠z y todos los nodos secundarios se administran utilizando la clase osg :: ref_ptr &lt;&gt;, la aplicaci√≥n solo puede rastrear el puntero al nodo ra√≠z.  Eliminar este nodo dar√° como resultado una eliminaci√≥n secuencial y autom√°tica de todos los nodos secundarios. <br><br><img src="https://habrastorage.org/webt/5r/az/ri/5razrigi8nvg-75jwcm4vhhurda.png"><br><br>  Los punteros inteligentes se pueden usar como variables locales, variables globales, miembros de la clase y disminuyen autom√°ticamente el recuento de referencia cuando el puntero inteligente se sale del alcance. <br><br>  Los desarrolladores de OSG recomiendan encarecidamente los punteros inteligentes para su uso en proyectos, pero hay algunos puntos fundamentales a los que debe prestar atenci√≥n: <br><br><ul><li>  Las instancias de osg :: Referenced y sus derivados se pueden crear exclusivamente en el mont√≥n.  No se pueden crear en la pila como variables locales, ya que los destructores de estas clases se declaran protegidos.  Por ejemplo <br></li></ul><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Node; <span class="hljs-comment"><span class="hljs-comment">//  osg::Node node; // </span></span></code> </pre><br><ul><li>  Puede crear nodos de escena temporales utilizando punteros regulares de C ++, sin embargo, este enfoque ser√° inseguro.  Es mejor utilizar punteros inteligentes para garantizar que el gr√°fico de la escena se gestione correctamente. <br></li></ul><br><pre> <code class="cpp hljs">osg::Node *tmpNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Node; <span class="hljs-comment"><span class="hljs-comment">//  ,  ... osg::ref_ptr&lt;osg::Node&gt; node = tmpNode; //         !</span></span></code> </pre><br><ul><li>  En ning√∫n caso debe usar escenas de enlace c√≠clico en el √°rbol cuando el nodo se refiere a s√≠ mismo directa o indirectamente a trav√©s de varios niveles <br></li></ul><br><img src="https://habrastorage.org/webt/ds/af/er/dsafertsy4m2doboaeb9cgjdzyk.png"><br><br>  En el gr√°fico de ejemplo del gr√°fico de escena, el nodo Child 1.1 se refiere a s√≠ mismo, y el nodo Child 2.2 tambi√©n se refiere al nodo Child 1.2.  Este tipo de enlaces puede conducir a un c√°lculo incorrecto del n√∫mero de enlaces y al comportamiento indefinido del programa. <br><br><h1>  5. Seguimiento de objetos gestionados </h1><br>  Para ilustrar el funcionamiento del mecanismo de puntero inteligente en OSG, escribimos el siguiente ejemplo sint√©tico <br><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ref_ptr&gt; #include &lt;osg/Referenced&gt; #include &lt;iostream&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> class MonitoringTarget : public osg::Referenced { public: MonitoringTarget(int id) : _id(id) { std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Constructing target " &lt;&lt; _id &lt;&lt; std::endl; } protected: virtual ~MonitoringTarget() { std::cout &lt;&lt; "Dsetroying target " &lt;&lt; _id &lt;&lt; std::endl; } int _id; }; int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;MonitoringTarget&gt; target = new MonitoringTarget(0); std::cout &lt;&lt; "Referenced count before referring: " &lt;&lt; target-&gt;referenceCount() &lt;&lt; std::endl; osg::ref_ptr&lt;MonitoringTarget&gt; anotherTarget = target; std::cout &lt;&lt; "Referenced count after referring: " &lt;&lt; target-&gt;referenceCount() &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br>  Creamos una clase descendiente osg :: referenciada que no hace nada excepto en el constructor y destructor que informa que su instancia se cre√≥ y muestra el identificador que se determina cuando se crea la instancia.  Cree una instancia de la clase utilizando el mecanismo de puntero inteligente <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;MonitoringTarget&gt; target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  A continuaci√≥n, mostramos el contador de referencia para el objeto de destino. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Referenced count before referring: "</span></span> &lt;&lt; target-&gt;referenceCount() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Despu√©s de eso, cree un nuevo puntero inteligente, asign√°ndole el valor del puntero anterior <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;MonitoringTarget&gt; anotherTarget = target;</code> </pre><br>  y nuevamente muestra el contador de referencia <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Referenced count after referring: "</span></span> &lt;&lt; target-&gt;referenceCount() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Veamos qu√© obtuvimos analizando la salida del programa. <br><br><pre> <code class="plaintext hljs">15:42:39:   Constructing target 0 Referenced count before referring: 1 Referenced count after referring: 2 Dsetroying target 0 15:42:42:  </code> </pre><br>  Cuando se inicia el constructor de la clase, se muestra un mensaje correspondiente que nos dice que la memoria para el objeto est√° asignada y que el constructor funcion√≥ bien.  Adem√°s, despu√©s de crear un puntero inteligente, vemos que el contador de referencia para el objeto creado ha aumentado en uno.  Crear un nuevo puntero, asignarle el valor del viejo puntero es esencialmente crear un nuevo enlace al mismo objeto, por lo que el contador de referencia se incrementa en otro.  Cuando el programa sale, se llama al destructor de la clase MonitoringTarget. <br><br><img src="https://habrastorage.org/webt/oi/hv/gh/oihvghcjfhchgrjkd0wpxm_hmr4.png"><br><br>  Realicemos otro experimento agregando dicho c√≥digo al final de la funci√≥n main () <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { osg::ref_ptr&lt;MonitoringTarget&gt; subTarget = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(i); }</code> </pre><br>  conduciendo a tal programa de "escape" <br><br><pre> <code class="plaintext hljs">16:04:30:   Constructing target 0 Referenced count before referring: 1 Referenced count after referring: 2 Constructing target 1 Dsetroying target 1 Constructing target 2 Dsetroying target 2 Constructing target 3 Dsetroying target 3 Constructing target 4 Dsetroying target 4 Dsetroying target 0 16:04:32:  </code> </pre><br>  Creamos varios objetos en el cuerpo del bucle, utilizando un puntero inteligente.  Dado que el alcance del puntero se extiende en este caso solo al cuerpo del bucle, cuando sale, se llama autom√°ticamente al destructor.  Esto no suceder√≠a, obviamente, usar√≠amos los punteros habituales. <br><br>  Con la liberaci√≥n autom√°tica de memoria es otra caracter√≠stica importante de trabajar con punteros inteligentes.  Dado que el destructor de clase derivada osg :: Referenced est√° protegido, no podemos llamar expl√≠citamente al operador delete para eliminar el objeto.  La √∫nica forma de eliminar un objeto es restablecer el n√∫mero de enlaces a √©l.  Pero luego nuestro c√≥digo se vuelve inseguro durante el procesamiento de datos de subprocesos m√∫ltiples: podemos acceder a un objeto ya eliminado desde otro hilo. <br><br>  Afortunadamente, OSG proporciona una soluci√≥n a este problema con la ayuda de su programador de eliminaci√≥n de objetos.  Este planificador se basa en el uso de la clase osg :: DeleteHandler.  Funciona de tal manera que no realiza la operaci√≥n de eliminar un objeto inmediatamente, sino que lo realiza despu√©s de un tiempo.  Todos los objetos que se eliminar√°n se almacenan temporalmente hasta que llegue el momento de una eliminaci√≥n segura, y luego se eliminan todos a la vez.  El programador de eliminaci√≥n osg :: DeleteHandler es controlado por el backend de renderizado OSG. <br><br><h1>  6. Regreso de la funci√≥n </h1><br>  Agregue la siguiente funci√≥n a nuestro c√≥digo de ejemplo <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MonitoringTarget *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createMonitoringTarget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;MonitoringTarget&gt; target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target.release(); }</code> </pre><br>  y reemplace la llamada al nuevo operador en el bucle con la llamada a esta funci√≥n <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { osg::ref_ptr&lt;MonitoringTarget&gt; subTarget = createMonitoringTarget(i); }</code> </pre><br>  La llamada release () reducir√° el n√∫mero de referencias al objeto a cero, pero en lugar de eliminar la memoria, devuelve el puntero real a la memoria asignada directamente.  Si este puntero se asigna a otro puntero inteligente, no habr√° p√©rdidas de memoria. <br><br><h1>  Conclusiones </h1><br>  Los conceptos del gr√°fico de escena y los punteros inteligentes son b√°sicos para comprender el principio de funcionamiento y, por lo tanto, el uso efectivo de OpenSceneGraph.  En cuanto a los punteros inteligentes OSG, recuerde que su uso es absolutamente esencial cuando <br><br><ul><li>  Se espera el almacenamiento a largo plazo de la instalaci√≥n. </li><li>  Un objeto almacena un enlace a otro objeto </li><li>  Debe devolver un puntero de una funci√≥n. </li></ul><br>  El c√≥digo de muestra proporcionado en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">est√° disponible aqu√≠</a> . <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√° ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429914/">https://habr.com/ru/post/es429914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es429902/index.html">Page Rank en la era de la Web 2.0 - Parte 1</a></li>
<li><a href="../es429904/index.html">Historias divertidas y tristes sobre el desarrollo de juegos de computadora</a></li>
<li><a href="../es429908/index.html">C√≥mo usar corutinas en la comida y dormir tranquilo por la noche</a></li>
<li><a href="../es429910/index.html">AppsConf Rises</a></li>
<li><a href="../es429912/index.html">Desarrollo de bibliotecas: de API a lanzamiento p√∫blico</a></li>
<li><a href="../es429916/index.html">C√≥mo construir y construir</a></li>
<li><a href="../es429918/index.html">Mundo virtual Intel. Parte 2: SMP</a></li>
<li><a href="../es429920/index.html">Tragicomedia en actos de NaN: c√≥mo creamos un juego en JS y lo lanzamos en Steam</a></li>
<li><a href="../es429922/index.html">C√≥mo convertir un proyecto simple en una construcci√≥n a largo plazo o cortar todo lo innecesario</a></li>
<li><a href="../es429928/index.html">Todo lo que necesitas saber sobre el estr√©s y las emociones fuertes.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>