<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏼 👨🏼‍💻 🐡 QEMU.js: maintenant sérieusement et avec WASM 👩🏾‍🌾 🍂 🎞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il était une fois, pour rire, j'ai décidé de prouver la réversibilité du processus et d'apprendre à générer JavaScript (ou plutôt Asm.js) à partir du ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>QEMU.js: maintenant sérieusement et avec WASM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451306/"><p>  Il était une fois, pour rire, j'ai décidé de <em>prouver la réversibilité du processus</em> et d'apprendre à générer JavaScript (ou plutôt Asm.js) à partir du code machine.  QEMU a été choisi pour l'expérience, quelque temps plus tard, un article a été écrit sur Habr.  Dans les commentaires, on m'a conseillé de refaire le projet sur WebAssembly, et moi-même je n'avais pas envie de quitter le projet <em>presque terminé</em> moi-même ... Le travail a continué, mais très lentement, et maintenant, dans cet article, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commentaire</a> est apparu sur le sujet "Alors, comment ça s'est <em>terminé</em> ?".  Pour ma réponse détaillée, j'ai entendu "Cela tire sur un article."  Eh bien, si ça tire, il y aura un article.  Peut-être que quelqu'un vous sera utile.  À partir de là, le lecteur apprend quelques faits sur la génération de code QEMU de backends de l'appareil, ainsi que sur la façon d'écrire un compilateur Just-in-Time pour une application Web. </p><a name="habracut"></a><br><h2 id="zadachi">  Les tâches </h2><br><p>  Comme j'ai déjà appris à "porter" QEMU sur JavaScript, cette fois, il a été décidé de le faire judicieusement et de ne pas répéter les anciennes erreurs. </p><br><h3 id="oshibka-nomer-raz-otvetvitsya-ot-point-release">  Nombre de fois d'erreur: branche à partir de la libération de points </h3><br><p> Ma première erreur a été de dériver ma version de la version amont 2.4.1.  Ensuite, cela m'a semblé une bonne idée: s'il existe une version ponctuelle, elle est probablement plus stable qu'une simple 2.4, et plus encore <code>master</code> branche <code>master</code> .  Et comme je prévoyais d'ajouter une bonne quantité de mes bugs, je n'avais pas du tout besoin d'étrangers.  Alors c'est probablement arrivé.  Mais voici la malchance: QEMU ne reste pas immobile, et à un moment donné, ils ont même annoncé l'optimisation du code de pourcentage généré par 10. "Ouais, maintenant je gèle", je pensais <del>  et rompit </del>  .  Ici, nous devons faire une digression: en raison de la nature à un seul thread de QEMU.js et du fait que le QEMU d'origine n'implique pas l'absence de multithreading (c'est-à-dire, il est essentiel qu'il puisse exploiter plusieurs chemins de code non liés en même temps, et pas seulement «brancher tous les noyaux»), les principales fonctions des threads a dû "tourner" pour la possibilité d'un appel de l'extérieur.  Cela a créé des problèmes de fusion naturels.  Cependant, le fait que certaines des modifications de la branche principale, avec lesquelles j'ai essayé de fusionner mon code, ont également été choisies dans la version ponctuelle (et, par conséquent, dans ma branche), n'ajouterait probablement pas la commodité. </p><br><p>  En général, j'ai décidé que de toute façon le prototype avait du sens <del>  jeter </del>  démonter pour les pièces et construire une nouvelle version à partir de zéro basée sur quelque chose de plus frais et maintenant de <code>master</code> . </p><br><h3 id="oshibka-nomer-dva-tlp-metodologiya">  Erreur numéro deux: méthodologie TLP </h3><br><p>  En fait, ce n'est pas une erreur, en général - c'est juste une caractéristique de créer un projet dans des conditions de méconnaissance totale de "où et comment se déplacer?", Et en général "allons-nous y arriver?".  Dans ces conditions, la <em>programmation</em> était une option justifiable, mais, bien sûr, je ne voulais absolument pas la répéter inutilement.  Cette fois, je voulais le faire avec sagesse: commits atomiques, changements délibérés de code (et non «enchaîner des caractères aléatoires jusqu'à ce qu'il compile (avec des avertissements)», comme Linus Torvalds l'a dit un jour à propos de quelqu'un, si vous croyez Wikitatnik), etc. </p><br><h3 id="oshibka-nomer-tri-ne-znaya-brodu-lezt-v-vodu">  Erreur numéro trois: ne pas savoir que le gué monte dans l'eau </h3><br><p>  Je ne me suis pas encore complètement débarrassé de cela, mais maintenant j'ai décidé de ne pas suivre le chemin de la moindre résistance, et de le faire "à la manière d'un adulte", à savoir, écrire mon backend TCG à partir de zéro afin de ne pas dire plus tard, "Oui, il Bien sûr, lentement, mais je ne peux pas tout contrôler - TCI est écrit comme ça ... ".  De plus, au début, cela semblait être une solution évidente, car <em>je générais du code binaire</em> .  Comme le dit le proverbe, "J'ai récupéré Gand, mais pas celui-là": le code est, bien sûr, binaire, mais le contrôle ne peut pas être transféré comme ça - il doit être explicitement poussé dans le navigateur pour la compilation, résultant en un certain objet du monde JS, qui encore besoin d'enregistrer quelque part.  Cependant, le <del>  normal </del>  Pour les architectures RISC, si je comprends bien, une situation typique est la nécessité de vider explicitement le cache d'instructions pour le code régénéré - si ce n'est pas ce dont nous avons besoin, alors au moins c'est proche.  De plus, lors de ma dernière tentative, j'ai appris que le contrôle ne semble pas être transféré au milieu du bloc de traduction, par conséquent, nous n'avons pas vraiment besoin que le bytecode soit interprété à partir de n'importe quel décalage, et nous pouvons simplement générer par fonction sur TB. </p><br><h2 id="prishli-i-pnuli">  Entré et coups de pied </h2><br><p>  Bien que j'ai commencé à réécrire le code en juillet, le Pendel magique s'est glissé inaperçu: généralement des lettres de GitHub viennent comme des notifications de réponses aux problèmes et aux demandes Pull, puis, <em>tout à coup</em> , le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Binaryen en tant que backend qemu</a> dans le contexte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dit</a> : «Le voici - il a fait quelque chose comme ça, peut-être qu'il dira quelque chose. »  Il s'agissait d'utiliser la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Binaryen</a> liée à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Emscripten</a> pour créer un WASM JIT.  Eh bien, j'ai dit que vous disposez d'une licence Apache 2.0 et que QEMU dans son ensemble est distribué sous GPLv2, et ils ne sont pas très compatibles.  Il s'est avéré que la licence pouvait être <em>corrigée d'une manière ou d'</em> une <em>autre</em> (je ne sais pas: peut-être, changer, peut-être doubler la licence, peut-être autre chose ...).  Bien sûr, cela m'a fait plaisir, car j'avais déjà regardé le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">format binaire</a> WebAssembly plusieurs fois à ce moment-là, et j'étais en quelque sorte triste et incompréhensible pour moi.  Il y avait une bibliothèque ici qui engloutirait les blocs de base avec le graphe de transition, et émettrait le bytecode, et même le lancerait dans l'interpréteur si nécessaire. </p><br><p>  Ensuite, il y avait aussi une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lettre</a> sur la liste de diffusion QEMU, mais celle-ci est plus susceptible de se poser la question: "Qui en a besoin?"  Et cela, <strong>soudain</strong> , était nécessaire.  Au minimum, vous pouvez regrouper de tels cas d'utilisation si cela fonctionne plus ou moins intelligemment: </p><br><ul><li>  lancer quoi que ce soit d'enseignement sans aucune installation du tout </li><li>  virtualisation sur iOS, où selon les rumeurs la seule application qui a le droit de générer du code à la volée est le moteur JS (est-ce vrai?) </li><li>  démonstration mini-OS - un seul disque, intégré, toutes sortes de firmware, etc ... </li></ul><br><h2 id="osobennosti-brauzernoy-sredy-vypolneniya">  Caractéristiques du runtime du navigateur </h2><br><p>  Comme je l'ai dit, QEMU est lié au multithreading, mais il n'est pas dans le navigateur.  Eh bien, c'est comme si non ... Au début, ce n'était pas là du tout, puis les WebWorkers sont apparus - si je comprends bien, c'est du multithreading basé sur le passage de messages <strong>sans variables</strong> mutuellement <strong>variables</strong> .  Naturellement, cela crée des problèmes importants lors du portage de code existant basé sur un modèle de mémoire partagée.  Puis, sous la pression du public, il a été implémenté sous le nom <code>SharedArrayBuffers</code> .  Ils l'ont progressivement introduit, ont célébré son lancement dans différents navigateurs, puis ont célébré la nouvelle année, puis Meltdown ... Après quoi ils sont arrivés à la conclusion que grossier, ne pas grossier la mesure du temps, mais avec l'aide de la mémoire partagée et d'un flux incrémentant le compteur, c'est toujours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">assez précis</a> .  Ils ont donc désactivé le multithreading avec la mémoire partagée.  Il semble qu'ils l'ont réactivé plus tard, mais, comme il est devenu clair à partir de la première expérience, il y a de la vie sans elle, et si c'est le cas, nous essaierons de le faire sans compter sur le multithreading. </p><br><p>  La deuxième caractéristique est l'impossibilité de manipulations de bas niveau avec la pile: vous ne pouvez pas simplement prendre, enregistrer le contexte actuel et passer à un nouveau avec une nouvelle pile.  La pile d'appels est gérée par la machine virtuelle JS.  Il semblerait, quel est le problème, puisque nous avons quand même décidé de gérer les anciens flux complètement manuellement?  Le fait est que le bloc entrée-sortie dans QEMU est implémenté via des coroutines, et ici des manipulations de pile de bas niveau nous seraient utiles.  Heureusement, Emscipten contient déjà un mécanisme pour les opérations asynchrones, même deux: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Asyncify</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Emterpreter</a> .  Le premier fonctionne grâce à un ballonnement important du code JavaScript généré et n'est plus pris en charge.  La seconde est la "voie correcte" actuelle et fonctionne grâce à la génération de bytecode pour son propre interprète.  Cela fonctionne, bien sûr, lentement, mais cela ne gonfle pas le code.  Certes, la prise en charge de la coroutine pour ce mécanisme devait être attribuée seule (il y avait déjà des coroutines écrites sous Asyncify et il y avait une implémentation d'environ la même API pour Emterpreter, vous deviez simplement les connecter). </p><br><p>  Pour le moment, je n'ai pas encore réussi à diviser le code en compilé dans WASM et interprété en utilisant Emterpreter, donc les périphériques de blocs ne fonctionnent pas encore (voir la prochaine série, comme on dit ...).  Autrement dit, à la fin, vous devriez obtenir quelque chose de super drôle: </p><br><ul><li>  E / S de bloc interprétées.  Eh bien, qu'attendiez-vous vraiment d'un NVMe émulé avec des performances natives?  :) </li><li>  code QEMU principal compilé statiquement (traducteur, autres périphériques émulés, etc.) </li><li>  Code invité WASM compilé dynamiquement </li></ul><br><h2 id="osobennosti-ishodnikov-qemu">  Caractéristiques des sources QEMU </h2><br><p>  Comme vous l'avez probablement déjà deviné, le code d'émulation pour les architectures invitées et le code pour générer des instructions de machine hôte à partir de QEMU sont séparés.  En fait, il y a même un peu plus délicat: </p><br><ul><li>  il y a des architectures invitées </li><li>  il existe des <em>accélérateurs</em> , à savoir KVM pour la virtualisation matérielle sous Linux (pour les systèmes hôtes et hôtes compatibles), TCG pour la génération de code JIT n'importe où.  À partir de QEMU 2.9, la prise en charge de la norme de virtualisation matérielle HAXM sous Windows est apparue ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">détails</a> ) </li><li>  si TCG est utilisé, et non la virtualisation matérielle, il prend en charge séparément la génération de code pour chaque architecture hôte, ainsi que pour un interpréteur universel </li><li>  ... et tout autour - périphériques émulés, interface utilisateur, migration, relecture d'enregistrement, etc. </li></ul><br><p>  <em>Au fait, le saviez-vous:</em> QEMU peut émuler non seulement l'ordinateur entier, mais aussi le processeur pour un processus utilisateur séparé dans le noyau hôte, qui est utilisé, par exemple, par le flou AFL pour l'instrumentation des binaires.  Peut-être que quelqu'un veut porter ce mode de fonctionnement QEMU sur JS?  ;) </p><br><p>  Comme la plupart des programmes gratuits de longue date, QEMU est construit via un appel à <code>configure</code> et à <code>make</code> .  Supposons que vous décidiez d'ajouter quelque chose: un backend TCG, une implémentation de thread, autre chose.  Ne vous précipitez pas pour vous réjouir / être horrifié (souligner si nécessaire) la perspective de communiquer avec Autoconf - en fait, la <code>configure</code> à QEMU semble être auto-écrite et il n'y a rien à générer. </p><br><h2 id="webassembly">  Webassembly </h2><br><p>  Alors, quelle est cette chose - WebAssembly (aka WASM)?  Il s'agit d'un remplacement pour Asm.js, qui ne prétend plus être un code JavaScript valide.  Au contraire, il est purement binaire et optimisé, et même simplement y écrire un entier n'est pas très simple: il est stocké au format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LEB128</a> pour plus de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compacité</a> . </p><br><p>  Vous avez peut-être entendu parler de l'algorithme de relooping pour Asm.js - restauration des instructions de contrôle de flux d'exécution «de haut niveau» (c'est-à-dire, si-alors-sinon, boucles, etc.) sous lesquelles les moteurs JS sont réglés à partir du LLVM IR de bas niveau, plus proche du code machine exécuté par le processeur.  Naturellement, la représentation intermédiaire de QEMU est plus proche de la seconde.  Il semblerait que le voici, bytecode, la fin du tourment ... Et puis les blocs, if-then-else et les boucles! .. </p><br><p>  Et c'est une autre raison pour laquelle Binaryen est utile: il peut, bien sûr, accepter des blocs de haut niveau proches de ce qui sera stocké dans WASM.  Mais il peut également produire du code à partir du graphe des blocs de base et des transitions entre eux.  Eh bien, j'ai déjà dit qu'il cache le format de stockage WebAssembly derrière l'API C / C ++ pratique. </p><br><h2 id="tcg-tiny-code-generator">  TCG (Générateur de code minuscule) </h2><br><p>  TCG <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">était à l'origine un</a> backend pour le compilateur C. Puis, apparemment, il ne pouvait pas supporter la concurrence de GCC, mais à la fin il a trouvé sa place dans QEMU en tant que mécanisme de génération de code pour la plate-forme hôte.  Il y a aussi un backend TCG qui génère du bytecode abstrait, qui est immédiatement exécuté par l'interpréteur, mais j'ai décidé de quitter cette fois cette fois.  Cependant, le fait que QEMU ait déjà la possibilité d'activer la transition vers la TB générée via la fonction <code>tcg_qemu_tb_exec</code> été très utile. </p><br><p>  Pour ajouter un nouveau backend TCG à QEMU, vous devez créer un sous-répertoire <code>tcg/&lt; &gt;</code> (dans ce cas, <code>tcg/binaryen</code> ), et il <code>tcg/binaryen</code> deux fichiers: <code>tcg-target.h</code> et <code>tcg-target.inc.c</code> et tout <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">enregistrer</a> c'est <code>configure</code> .  Vous pouvez y placer d'autres fichiers, mais, comme vous pouvez le deviner d'après les noms de ces deux, ils seront tous les deux inclus quelque part: l'un en tant que fichier d'en-tête normal (il sera inclus dans <code>tcg/tcg.h</code> , et celui-ci sera déjà dans d'autres fichiers dans les répertoires <code>tcg</code> , <code>accel</code> et pas seulement), l'autre uniquement comme extrait de code dans <code>tcg/tcg.c</code> , mais il a accès à ses fonctions statiques. </p><br><p>  Ayant décidé que je passerais trop de temps sur les procédures détaillées, comment cela fonctionne, j'ai simplement copié les «squelettes» de ces deux fichiers à partir d'une autre implémentation backend, en l'indiquant honnêtement dans l'en-tête de la licence. </p><br><p>  Le <code>tcg-target.h</code> contient principalement des paramètres sous la forme de <code>#define</code> s: </p><br><ul><li>  combien de registres et quelle largeur sont sur l'architecture cible (nous en avons - autant que nous voulons, il y en a tellement - la question est plus que ce que le navigateur va générer dans un code plus efficace sur une architecture "complètement cible" ...) </li><li>  alignement des instructions de l'hôte: sur x86, et dans TCI, les instructions ne s'alignent pas du tout, je vais mettre dans le tampon de code pas des instructions du tout, mais des pointeurs sur les structures de la bibliothèque Binaryen, donc je dirai: 4 octets </li><li>  quelles instructions facultatives le backend peut générer - allumez tout ce que nous trouvons dans Binaryen, laissez l'accélérateur diviser le reste en plus simples </li><li>  quelle taille approximative du cache TLB est demandée par le backend.  Le fait est que dans QEMU, tout est sérieux: bien qu'il existe des fonctions d'assistance qui se chargent / stockent en tenant compte de la MMU invitée (et où maintenant sans elle?), Ils enregistrent leur cache de traduction sous la forme d'une structure, dont le traitement est pratique à intégrer directement aux blocs de traduction.  La question est de savoir quel décalage dans cette structure est géré le plus efficacement par une petite séquence de commandes rapide </li><li>  ici, vous pouvez tordre le but d'un ou deux registres réservés, activer l'appel de TB via une fonction et éventuellement décrire quelques petites fonctions en <code>inline</code> comme <code>flush_icache_range</code> (mais ce n'est pas notre cas) </li></ul><br><p>  Le <code>tcg-target.inc.c</code> , bien sûr, est généralement beaucoup plus volumineux et contient plusieurs fonctions requises: </p><br><ul><li>  initialisation, indiquant, entre autres, les restrictions quant à l'instruction avec laquelle les opérandes peuvent fonctionner.  Insolemment copié par moi depuis un autre backend </li><li>  fonction acceptant une instruction de bytecode interne </li><li>  ici vous pouvez mettre des fonctions auxiliaires, et aussi ici vous pouvez utiliser des fonctions statiques de <code>tcg/tcg.c</code> </li></ul><br><p>  Pour ma part, j'ai choisi la stratégie suivante: dans les premiers mots du bloc de traduction suivant, j'ai noté quatre pointeurs: la marque de départ (une certaine valeur au voisinage de <code>0xFFFFFFFF</code> , qui a déterminé l'état actuel de TB), le contexte, le module généré et le nombre magique pour le débogage.  Tout d'abord, le libellé a été défini sur <code>0xFFFFFFFF - n</code> , où <code>n</code> est un petit nombre positif, et chaque fois via l'interpréteur, il a augmenté de 1. Lorsqu'il a atteint <code>0xFFFFFFFE</code> , la compilation s'est produite, le module a été stocké dans la table de fonction, importé dans un petit "lanceur", dans lequel l'exécution a quitté <code>tcg_qemu_tb_exec</code> et le module a été supprimé de la mémoire QEMU. </p><br><p>  Pour paraphraser les classiques, "Crutch, combien proger s'est entrelacé dans ce son pour le coeur ...".  Cependant, la mémoire fuyait quelque part.  Et c'était une mémoire gérée par QEMU!  J'avais un code qui, lors de l'écriture de l'instruction suivante (enfin, c'est-à-dire un pointeur), a supprimé celui dont le lien était à cet endroit plus tôt, mais cela n'a pas aidé.  En fait, dans le cas le plus simple, QEMU alloue de la mémoire au démarrage et y écrit le code généré.  Lorsque le tampon se termine, le code est jeté et le suivant commence à être écrit à sa place. </p><br><p>  Après avoir étudié le code, j'ai réalisé que la béquille avec nombre magique nous permettait de ne pas tomber sur la destruction du tas, libérant quelque chose de mal sur le tampon non initialisé lors du premier passage.  Mais qui écrase le tampon en contournant ma fonction plus tard?  Comme les développeurs d'Emscripten l'ont conseillé, après avoir rencontré un problème, j'ai porté le code résultant vers l'application native, défini Mozilla Record-Replay dessus ... En général, en conséquence, j'ai réalisé une chose simple: une <code>struct TranslationBlock</code> avec sa description est allouée à chaque bloc.  Devinez où ... C'est vrai, juste en face du bloc juste dans le tampon.  Après avoir réalisé cela, j'ai décidé de le lier avec des béquilles (au moins certaines), et j'ai simplement jeté le numéro magique et transféré les mots restants dans la <code>struct TranslationBlock</code> , créant une liste à lien unique que vous pouvez parcourir rapidement lors de la réinitialisation du cache de traduction et libérer de la mémoire. </p><br><p>  Certaines béquilles sont restées: par exemple, des pointeurs marqués dans le tampon de code - certains d'entre eux sont simplement <code>BinaryenExpressionRef</code> , c'est-à-dire qu'ils examinent les expressions qui doivent être linéairement placées dans l'unité de base générée, partie - la condition de transition entre les WB, partie - où aller.  Eh bien, il existe déjà des blocs préparés pour Relooper, qui doivent être connectés en fonction des conditions.  Pour les distinguer, l'hypothèse est utilisée qu'ils sont tous alignés sur au moins quatre octets, de sorte que vous pouvez utiliser en toute sécurité les deux bits inférieurs de l'étiquette, il vous suffit de vous rappeler de le supprimer si nécessaire.  Soit dit en passant, ces étiquettes sont déjà utilisées dans QEMU pour indiquer la raison de la sortie du cycle TCG. </p><br><h2 id="ispolzovanie-binaryen">  Utilisation de Binaryen </h2><br><p>  Les modules de WebAssembly contiennent des fonctions, chacune contenant un corps représentant une expression.  Les expressions sont des opérations unaires et binaires, des blocs constitués de listes d'autres expressions, un flux de contrôle, etc.  Comme je l'ai déjà dit, le flux de contrôle est organisé précisément comme des branches de haut niveau, des boucles, des appels de fonction, etc.  Les arguments des fonctions ne sont pas transmis sur la pile, mais explicitement, comme dans JS.  Il y a des variables globales, mais je ne les ai pas utilisées, donc je n'en parlerai pas. </p><br><p>  Les fonctions ont également des variables locales, numérotées à partir de zéro, du type: int32 / int64 / float / double.  Les n premières variables locales sont les arguments passés à la fonction.  Veuillez noter que bien que tout ici ne soit pas entièrement de bas niveau en termes de flux de contrôle, les entiers ne portent toujours pas le signe / signe sans signe: le comportement du nombre dépend du code d'opération. </p><br><p>  De manière générale, Binaryen fournit une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API C simple</a> : vous créez un module, <strong>vous y</strong> créez des expressions - unaires, binaires, blocs à partir d'autres expressions, flux de contrôle, etc.  Ensuite, vous créez une fonction, dont le corps dont vous avez besoin pour spécifier une expression.  Si vous, comme moi, avez un graphe de transition de bas niveau, le composant relooper vous aidera.  Pour autant que je comprends, il est possible d'utiliser un contrôle de haut niveau du flux d'exécution dans le bloc, tant qu'il ne dépasse pas les limites du bloc - c'est-à-dire qu'il est possible de créer une branche de chemin rapide / chemin lent interne à l'intérieur du code de traitement du cache TLB intégré, mais il n'y a aucun moyen d'interférer avec le flux de contrôle «externe» .  Lorsque vous relâchez relooper, ses blocs sont libérés, lorsque vous libérez un module, les expressions, fonctions, etc., allouées dans son <em>arène</em> disparaissent. </p><br><p>  Cependant, si vous souhaitez interpréter le code à la volée sans création et suppression inutiles de l'instance d'interpréteur, il peut être judicieux de transférer cette logique dans un fichier C ++, et de là contrôler directement la bibliothèque API C ++ entière, en contournant les wrappers finis. </p><br><p>  Ainsi, pour générer le code, vous avez besoin </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    (  ) BinaryenSetAPITracing(0); BinaryenSetOptimizeLevel(3); BinaryenSetShrinkLevel(2); //   BinaryenModuleRef MODULE = BinaryenModuleCreate(); //    ( ,   ) helper_type BinaryenAddFunctionType(MODULE, "helper-func", BinaryenTypeInt32(), int32_helper_args, ARRAY_SIZE(int32_helper_args)); // (int23_helper_args ^W ) //  -  // ...     -  :) //    BinaryenAddFunction(MODULE, "tb_fun", tb_func_type, func_locals, FUNC_LOCALS_COUNT, expr); BinaryenAddFunctionExport(MODULE, "tb_fun", "tb_fun"); ... BinaryenSetMemory(MODULE, (1 &lt;&lt; 15) - 1, -1, NULL, NULL, NULL, NULL, NULL, 0, 0); BinaryenAddMemoryImport(MODULE, NULL, "env", "memory", 0); BinaryenAddTableImport(MODULE, NULL, "env", "tb_funcs"); //       assert (BinaryenModuleValidate(MODULE)); BinaryenModuleOptimize(MODULE);</span></span></code> </pre> <br><p> …    — ,     ,   —   . </p><br><p>    --,  : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>]; BinaryenModuleOptimize(MODULE); BinaryenSetMemory(MODULE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sz = BinaryenModuleWrite(MODULE, buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf)); BinaryenModuleDispose(MODULE); EM_ASM({ var <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebAssembly.Module(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uint8Array(wasmMemory.buffer, $<span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">1</span></span>)); var fptr = $<span class="hljs-number"><span class="hljs-number">2</span></span>; var instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebAssembly.Instance(<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>, { <span class="hljs-string"><span class="hljs-string">'env'</span></span>: { <span class="hljs-string"><span class="hljs-string">'memory'</span></span>: wasmMemory, <span class="hljs-comment"><span class="hljs-comment">// ... } ); //       instance! }, buf, sz);</span></span></code> </pre> <br><p>  -     QEMU  JS        ,    (     ),     .    ,         translation block,   ,           <code>struct TranslationBlock</code> . </p><br><p> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> <em>(    )</em>     Firefox.  Chrome  <em>-  </em>  ,  -       WebAssembly,          ... </p><br><p>     . ,    ,   - .  ,    <em> </em>    . ,      WebAssembly  ,       JS,      ,     ,     . </p><br><p> <strong><strong> :</strong></strong>     32- ,         Binaryen, -     -   2  32-  .   ,     Binaryen       .   ? </p><br><div class="spoiler"> <b class="spoiler_title">-</b> <div class="spoiler_text"><p>      ,     « ,   32- Linux?»        .    ,   : 1  2 Gb. </p></div></div><br><div class="spoiler"> <b class="spoiler_title">- (  )</b> <div class="spoiler_text"><p>       .    ,    —   <strong></strong>   .  « :    ,     ...». </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2gbubble.c // Usage: LD_PRELOAD=2gbubble.so &lt;program&gt; #include &lt;sys/mman.h&gt; #include &lt;assert.h&gt; void __attribute__((constructor)) constr(void) { assert(MAP_FAILED != mmap(1u &gt;&gt; 31, (1u &gt;&gt; 31) - (1u &gt;&gt; 20), PROT_NONE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0)); }</span></span></code> </pre> <br><p> …  Valgrind-, ,  , ,  , Valgrind       :) </p><br><p> <em>, -   ,     ...</em> </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451306/">https://habr.com/ru/post/fr451306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451294/index.html">Comme j'ai ajouté des fonctions à la voiture via CAN, je ne pouvais pas programmer</a></li>
<li><a href="../fr451296/index.html">Annoncé par ML.NET 1.0</a></li>
<li><a href="../fr451298/index.html">Comment faire une console de jeu avec un étui en commandant une carte de circuit imprimé</a></li>
<li><a href="../fr451302/index.html">Les meilleures sociétés d'externalisation informatique</a></li>
<li><a href="../fr451304/index.html">«Astuce» Yandex: comment maximiser les profits sur un abonnement payant</a></li>
<li><a href="../fr451310/index.html">Vous manquez le PDA?</a></li>
<li><a href="../fr451314/index.html">Production de circuits imprimés LUT'om de A à Z</a></li>
<li><a href="../fr451316/index.html">À propos d'une faculté de physique</a></li>
<li><a href="../fr451318/index.html">Dart 2.3 annoncé: optimisé pour le développement de l'interface utilisateur</a></li>
<li><a href="../fr451320/index.html">Pourquoi le firmware ouvert est important pour la sécurité</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>