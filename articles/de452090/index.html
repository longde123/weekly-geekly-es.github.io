<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☑️ 🗂️ 💴 Erstellen eines prozeduralen Puzzle-Generators 🐀 🤴🏿 🎰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Beitrag beschreibt den Levelgenerator für mein Linjat- Puzzlespiel. Ein Beitrag kann ohne Vorbereitung gelesen werden, aber es ist einfacher zu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines prozeduralen Puzzle-Generators</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452090/"> Dieser Beitrag beschreibt den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Levelgenerator</a> für mein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linjat-</a> Puzzlespiel.  Ein Beitrag kann ohne Vorbereitung gelesen werden, aber es ist einfacher zu assimilieren, wenn Sie in mehreren Levels spielen.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Quellcode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf github gepostet</a> .  Alles, was im Artikel besprochen wird, befindet sich in der <code>src/main.cc</code> <br><br>  Beispiel für einen Postplan: <br><br><ul><li>  Linjat ist ein Logikspiel, bei dem Sie alle Zahlen und Punkte im Raster mit Linien schließen müssen. </li><li>  Die Rätsel werden prozedural mit einer Kombination aus Solver, Generator und Optimierer generiert. </li><li>  Solver versucht, die Rätsel so zu lösen, wie es eine Person tun würde, und weist jedem Rätsel eine Bewertung von Interesse zu. </li><li>  Der Puzzle-Generator ist so konzipiert, dass ein Teil des Puzzles (Nummer) leicht geändert werden kann und gleichzeitig alle anderen Teile (Punkte) geändert werden, sodass das Puzzle lösbar bleibt. </li><li>  Der Puzzle-Optimierer löst wiederholt die Level und generiert neue Variationen aus den derzeit interessantesten. </li></ul><br><h3>  Die Regeln </h3><br>  Um zu verstehen, wie der Levelgenerator funktioniert, müssen Sie leider die Spielregeln verstehen.  Zum Glück sind sie sehr einfach.  Das Puzzle besteht aus einem Gitter mit leeren Quadraten, Zahlen und Punkten.  Ein Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/641/0d0/547/6410d0547bc14faae51beb3942867cb0.png"></div><br>  Das Ziel des Spielers ist es, unter drei Bedingungen eine vertikale oder horizontale Linie durch jede der Zahlen zu ziehen: <br><br><ul><li>  Eine Linie durch eine Zahl muss dieselbe Länge wie die Zahl haben. </li><li>  Linien können sich nicht schneiden. </li><li>  Alle Punkte müssen mit Linien geschlossen werden. </li></ul><br>  Beispiellösung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/3ce/91c/7e13ce91c2da2e2d64bd98f523010671.png"></div><br>  Hurra!  Das Spieldesign ist fertig, die Benutzeroberfläche ist implementiert, und jetzt müssen nur noch mehrere hundert gute Rätsel gefunden werden.  Und für solche Spiele ist es normalerweise nicht sinnvoll, solche Rätsel manuell zu erstellen.  Dies ist ein Computerjob. <br><a name="habracut"></a><br><h3>  Anforderungen </h3><br>  Was macht das Puzzle für dieses Spiel gut?  Ich neige dazu zu glauben, dass Puzzlespiele in zwei Kategorien unterteilt werden können.  Es gibt Spiele, in denen Sie einen komplexen Zustandsraum von Anfang bis Ende erkunden (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sokoban</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rush Hour</a> ) und in denen möglicherweise nicht klar ist, welche Zustände im Spiel vorhanden sind.  Und es gibt Spiele, in denen alle Zustände von Anfang an bekannt sind, und wir gestalten den Zustandsraum schrittweise so, dass unnötige (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sudoku</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Picross</a> ) eliminiert werden.  Mein Spiel fällt definitiv in die zweite Kategorie. <br><br>  Spieler haben sehr unterschiedliche Anforderungen an diese verschiedenen Arten von Rätseln.  Im zweiten Fall erwarten sie, dass das Rätsel nur durch Abzug gelöst werden kann und dass sie niemals zurückgehen / raten / versuchen und irren müssen <sup>[0]</sup> <sup>[1]</sup> . <br><br>  Es reicht nicht aus zu wissen, ob ein Rätsel nur durch Logik gelöst werden kann.  Außerdem müssen wir irgendwie verstehen, wie gut die erstellten Rätsel sind.  Andernfalls sind die meisten Ebenen nur triviale Schlacken.  Im Idealfall kann dieses Prinzip auch verwendet werden, um eine reibungslose Fortschrittskurve zu erstellen, sodass die Level im Verlauf des Spiels allmählich schwieriger werden. <br><br><h3>  Löser </h3><br>  Der erste Schritt zur Erfüllung dieser Anforderungen besteht darin, einen für diesen Zweck optimierten Spiellöser zu erstellen.  Mit dem Backtracking-Solver können Sie schnell und genau feststellen, ob das Puzzle lösbar ist.  Darüber hinaus kann es geändert werden, um festzustellen, ob die Lösung eindeutig ist.  Aber er kann keine Vorstellung davon geben, wie kompliziert das Rätsel wirklich ist, weil die Leute sie anders lösen.  Solver muss menschliches Verhalten imitieren. <br><br>  Wie löst eine Person dieses Rätsel?  Hier sind einige offensichtliche Schritte, die das In-Game-Tutorial lehrt: <br><br><ul><li>  Wenn ein Punkt nur von einer Zahl aus erreicht werden kann, müssen Sie zum Schließen eines Punktes eine Linie von dieser Zahl ziehen.  In diesem Beispiel kann der Punkt nur von den drei, nicht aber von den vier erreicht werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76d/1d4/e3e/76d1d4e3e87a0cc9efdebbd586420c84.png"></div><br>  Und das führt zu dieser Situation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a15/db3/05f/a15db305fa78a149ee614de0b4b8ed54.png"></div></li><li>  Wenn die Linie nicht in eine Richtung passt, muss sie in eine andere Richtung gelegt werden.  Im obigen Beispiel können die vier nicht mehr vertikal positioniert werden, sodass wir wissen, dass sie horizontal sind: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ef/048/99f/5ef04899f1c9da5a5b8492e1316ddcbf.png"></div></li><li>  Wenn bekannt ist, dass sich die Linie der Länge X an einer bestimmten Position (vertikal / horizontal) befinden muss und nicht genügend Leerraum vorhanden ist, um eine Linie von X leeren Zellen auf beiden Seiten zu platzieren, müssen Sie mehrere Quadrate in der Mitte abdecken.  Wenn die vier in dem oben gezeigten Beispiel drei wären, würden wir nicht wissen, ob sie sich ganz nach rechts oder links erstrecken.  Aber wir würden wissen, dass die Linie zwei mittlere Quadrate abdecken sollte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02c/bfa/021/02cbfa02113362bc6e3c5217baee3ff3.png"></div></li></ul><br>  Ähnliche Überlegungen sind die Grundlage des Spiels.  Der Spieler sucht nach Möglichkeiten, eine kleine Linie zu strecken, und untersucht dann das Feld erneut, da er Informationen erhalten kann, um eine weitere logische Schlussfolgerung zu ziehen.  Das Erstellen eines Lösers, der diesen Regeln folgt, reicht aus, um festzustellen, <i>ob eine</i> Person das Rätsel lösen kann, ohne zurückzukehren. <br><br>  Dies sagt jedoch nichts über die Komplexität oder Interessantheit des Levels aus.  Neben der Lösbarkeit müssen wir auch die Komplexität quantifizieren. <br><br>  Eine offensichtliche erste Idee für die Bewertungsfunktion: Je mehr Züge Sie benötigen, um das Rätsel zu lösen, desto schwieriger wird es.  Dies ist wahrscheinlich eine gute Metrik in anderen Spielen, aber meine ist höchstwahrscheinlich wichtiger als die Anzahl der erlaubten Züge, die ein Spieler hat.  Wenn ein Spieler 10 logische Schlussfolgerungen ziehen kann, wird er höchstwahrscheinlich sehr schnell eine davon finden.  Wenn es nur einen richtigen Zug gibt, dauert es länger. <br><br>  Das heißt, in erster Näherung muss der Entscheidungsbaum tief und eng sein: Es gibt eine lange Abhängigkeit der Bewegungen von Anfang bis Ende, und zu jedem Zeitpunkt gibt es nur wenige Möglichkeiten, die Kette nach oben zu bewegen <sup>[2]</sup> . <br><br>  Wie bestimmen wir die Breite und Tiefe eines Baumes?  Eine einzige Lösung für das Rätsel und die Bewertung des erstellten Baums gibt keine genaue Antwort.  Die genaue Reihenfolge, in der Bewegungen ausgeführt werden, wirkt sich auf die Form des Baums aus.  Wir müssen alle möglichen Lösungen in Betracht ziehen und damit so etwas wie eine Optimierung für die besten und schlechtesten Fälle durchführen.  Ich bin mit der Technik der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">groben Suche nach Suchgraphen in Puzzlespielen</a> vertraut, aber für dieses Projekt wollte ich einen One-Pass-Solver erstellen und keine erschöpfende Suche.  Aufgrund der Optimierungsphase habe ich versucht sicherzustellen, dass die Laufzeit des Solvers nicht in Sekunden, sondern in Millisekunden gemessen wurde. <br><br>  Ich habe mich dagegen entschieden.  Stattdessen macht mein Löser nicht jeweils einen Zug, sondern löst das Rätsel in Schichten: Wenn er einen Zustand annimmt, findet er alle gültigen Züge, die ausgeführt werden können.  Wendet dann alle diese Züge gleichzeitig an und beginnt in einem neuen Zustand von vorne.  Die Anzahl der Ebenen und die maximale Anzahl der auf einer Ebene gefundenen Bewegungen werden dann als ungefähre Werte für die Tiefe und Breite des gesamten Suchbaums verwendet. <br><br>  Hier erfahren Sie, wie Sie eines der schwierigen Rätsel mit diesem Modell lösen können.  Gepunktete Linien sind Linien, die auf dieser Schicht des Lösers gestreckt sind. Durchgezogene Linien sind solche, die sich nicht geändert haben.  Die grünen Linien haben die richtige Länge, die roten sind noch nicht vollständig. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2af/1de/cfb/2af1decfbc170ec8965ae8b1cce2cbea.png"></div><br>  Das nächste Problem ist, dass alle vom Spieler ausgeführten Züge gleich sind.  Was wir am Anfang dieses Abschnitts aufgelistet haben, ist nur gesunder Menschenverstand.  Hier ist ein Beispiel für eine komplexere Abzugsregel, deren Suche etwas mehr Nachdenken erfordert.  Betrachten Sie das folgende Feld: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c18/772/9c4c187726bf50f03bbffa748137cf44.png"></div><br>  Die Punkte in C und D können nur von den fünf und den mittleren vier abgedeckt werden (und keine einzige Zahl kann beide Punkte gleichzeitig abdecken).  Dies bedeutet, dass die vier in der Mitte einen der beiden Punkte abdecken sollten und daher nicht zur Abdeckung von A verwendet werden können. Daher sollte der Punkt A die vier in der unteren linken Ecke schließen. <br><br>  Offensichtlich wäre es dumm, diese Argumentationskette als gleichbedeutend mit der einfachen Schlussfolgerung zu betrachten, dass "dieser Punkt nur von dieser Zahl aus erreicht werden kann".  Ist es möglich, diesen komplexeren Regeln in der Bewertungsfunktion mehr Gewicht zu verleihen?  Leider ist dies in einem schichtbasierten Löser nicht möglich, da nicht garantiert wird, dass eine Lösung zu den niedrigsten Kosten gefunden wird.  Dies ist nicht nur ein theoretisches Problem - in der Praxis kommt es häufig vor, dass ein Teil des Feldes entweder durch ein einzelnes komplexes Argument oder durch eine Kette viel einfacherer Schritte gelöst werden kann.  Tatsächlich findet ein schichtbasierter Löser den kürzesten und nicht den kostengünstigsten Weg, und dies kann nicht in der Bewertungsfunktion widergespiegelt werden. <br><br>  Als Ergebnis kam ich zu dieser Entscheidung: Ich habe den Löser so geändert, dass jede Ebene nur aus einer Art von Argumentation bestand.  Der Algorithmus umgeht die Argumentationsregeln in einer ungefähren Reihenfolge der Komplexität.  Wenn die Regel einige Züge findet, werden sie angewendet, und die Iteration endet, und die nächste Iteration beginnt die Liste von Anfang an. <br><br>  Anschließend wird der Entscheidung eine Bewertung zugewiesen: Jeder Schicht werden Kosten zugewiesen, die auf einer darin verwendeten Regel basieren.  Dies garantiert immer noch nicht, dass die Lösung am kostengünstigsten ist. Wenn die Gewichte jedoch richtig ausgewählt werden, findet der Algorithmus zumindest keine kostspielige Lösung, wenn es eine billige gibt. <br><br>  Darüber hinaus ist es sehr ähnlich, wie Menschen Rätsel lösen.  Sie versuchen zunächst, einfache Lösungen zu finden, und beginnen nur dann, ihr Gehirn aktiv zu bewegen, wenn es keine einfachen Bewegungen gibt. <br><br><h3>  Generator </h3><br>  Im vorherigen Abschnitt wurde festgestellt, ob ein bestimmtes Niveau gut oder schlecht war.  Aber nur das ist nicht genug, wir müssen immer noch irgendwie Level generieren, damit der Solver sie auswerten kann.  Es ist sehr unwahrscheinlich, dass eine zufällig erzeugte Welt lösbar ist, ganz zu schweigen von interessant. <br><br>  Die Hauptidee (keineswegs neu) ist die alternative Verwendung von Solver und Generator.  Beginnen wir mit einem Rätsel, das wahrscheinlich unlösbar ist: Platzieren Sie einfach zwei bis fünf Zahlen in zufälligen Quadraten der Zelle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cf/164/3c5/8cf1643c568477bc2c774d33a0994f96.png"></div><br>  Solver funktioniert, bis es sich weiterentwickeln kann: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/9b4/a5c/64f9b4a5c022b2560c1a26746a0c3539.png"></div><br>  Anschließend fügt der Generator dem Puzzle weitere Informationen in Form eines Punkts hinzu. Anschließend wird die Ausführung des Lösers fortgesetzt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b4/397/23f/1b439723f7d229887c8392ebc07053f3.png"></div><br>  In diesem Fall reicht der dem Löser hinzugefügte Punkt für die weitere Entwicklung nicht aus.  Dann fügt der Generator weiterhin neue Punkte hinzu, bis er den Löser erfüllt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/3a0/48d/6b23a048dc66700a3eadf94206705c7c.png"></div><br>  Und dann setzt der Löser seine übliche Arbeit fort: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8e/b9a/77a/b8eb9a77a027a741ce259a1b95fe9c89.png"></div><br>  Dieser Vorgang wird entweder fortgesetzt, bis das Rätsel gelöst ist oder bis weitere Informationen hinzugefügt werden müssen (z. B. wenn jede Zelle, die über die Nummer erreichbar ist, bereits einen Punkt enthält). <br><br>  Diese Methode funktioniert nur, wenn die hinzugefügten neuen Informationen keine der zuvor gemachten Schlussfolgerungen falsch machen können.  Dies wäre beim Hinzufügen von Zahlen zum Raster schwierig <sup>[3]</sup> .  Das Hinzufügen neuer Punkte zum Feld hat jedoch diese Eigenschaft.  Zumindest für die Argumentationsregeln, die ich in diesem Programm verwende. <br><br>  Wo soll der Algorithmus Punkte hinzufügen?  Am Ende habe ich beschlossen, sie dem leeren Raum hinzuzufügen, der im Ausgangszustand mit so vielen Zeilen wie möglich geschlossen werden kann, damit jeder Punkt so wenig Informationen wie möglich preisgibt.  Ich habe nicht versucht, den Punkt an der Stelle zu platzieren, an der er nützlich wäre, um das Rätsel zu lösen, wenn der Löser stecken bleibt.  Dies erzeugt einen sehr praktischen Effekt: Die meisten Punkte am Anfang des Puzzles scheinen völlig nutzlos zu sein, was das Puzzle schwieriger macht als es wirklich ist.  Wenn all dies eine Menge offensichtlicher Bewegungen ist, die ein Spieler machen kann, aber aus irgendeinem Grund funktioniert keiner von ihnen nicht richtig.  Als Ergebnis stellte sich heraus, dass sich der Puzzle-Generator ein bisschen wie ein Schwein verhält. <br><br>  Dieser Prozess erstellt nicht immer eine Lösung, ist jedoch recht schnell (ca. 50 bis 100 Millisekunden). Um ein Level zu generieren, können Sie es einfach mehrmals wiederholen.  Leider schafft er normalerweise mittelmäßige Rätsel.  Von Anfang an gibt es zu viele offensichtliche Bewegungen, das Feld füllt sich sehr schnell und der Entscheidungsbaum ist eher flach. <br><br><h3>  Optimierer </h3><br>  Der oben beschriebene Prozess erzeugte mittelmäßige Rätsel.  In der letzten Phase verwende ich diese Ebenen als Grundlage für den Optimierungsprozess.  Es funktioniert wie folgt. <br><br>  Der Optimierer erstellt einen Pool mit bis zu 10 Puzzle-Optionen.  Der Pool wird mit einem neu generierten zufälligen Puzzle initialisiert.  Bei jeder Iteration wählt der Optimierer ein Puzzle aus dem Pool aus und führt seine Mutation durch. <br><br>  Die Mutation löscht alle Punkte und ändert dann die Zahlen geringfügig (d. H. Verringert / erhöht den Wert einer zufällig ausgewählten Zahl oder verschiebt die Zahl in eine andere Zelle im Gitter).  Sie können mehrere Mutationen gleichzeitig auf das Feld anwenden.  Anschließend führen wir den Solver im speziellen Level-Generierungsmodus aus, der im vorherigen Abschnitt beschrieben wurde.  Er fügt dem Puzzle genügend Punkte hinzu, damit es wieder lösbar wird. <br><br>  Danach starten wir den Solver erneut, diesmal im normalen Modus.  Während dieses Laufs überwacht der Löser a) die Tiefe des Entscheidungsbaums, b) die Häufigkeit des Bedarfs an verschiedenen Arten von Regeln, c) die Breite des Entscheidungsbaums zu verschiedenen Zeitpunkten.  Das Puzzle wird anhand der oben beschriebenen Kriterien bewertet.  Die Bewertungsfunktion bevorzugt tiefe und enge Lösungen, und die zunehmende Komplexität erhöht auch das Gewicht von Rätseln, bei denen komplexere Argumentationsregeln erforderlich sind. <br><br>  Dann wird dem Pool ein neues Puzzle hinzugefügt.  Wenn der Pool mehr als 10 Rätsel enthält, wird das Schlimmste verworfen. <br><br>  Dieser Vorgang wird mehrmals wiederholt (ungefähr 10.000 bis 50000 Iterationen haben mich gekostet).  Danach wird die am höchsten bewertete Version des Puzzles in der Puzzle-Level-Datenbank gespeichert.  So sieht der Fortschritt des besten Puzzles in einem Optimierungslauf aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/e61/40c/504e6140c20049ca3424456de0985aaf.png"></div><br>  Ich habe versucht, die Optimierung auf andere Weise zu strukturieren.  In einer Version wurde simuliertes Tempern verwendet, andere waren genetische Algorithmen mit verschiedenen Überkreuzungsoperationen.  Keine der Lösungen war so gut wie ein naiver Algorithmus mit einem Pool von Optionen, die wieder nach oben gehen. <br><br><h3>  Einzigartige Einzellösung </h3><br>  Wenn ein Puzzle eine einzigartige, einzigartige Lösung hat, entsteht eine interessante Schwierigkeit.  Ist es möglich, dem Spieler zu erlauben, anzunehmen, dass es eine Lösung gibt, und daraus Schlussfolgerungen zu ziehen?  Wäre es fair, wenn der Puzzle-Generator dem Spieler dies vorschlagen würde? <br><br>  In einem Beitrag auf HackerNews sagte ich, dass es vier Möglichkeiten gibt, sich dieser Situation zu nähern: <br><br><ul><li>  Erklären Sie die Eindeutigkeit der Lösung von Anfang an und zwingen Sie den Generator, Ebenen zu erstellen, die diese Art von Argumentation erfordern.  Dies ist eine schlechte Entscheidung, da dies das Verständnis der Regeln erschwert.  Und normalerweise sind dies die Details, die die Leute vergessen. </li><li>  Garantieren Sie nicht die Einzigartigkeit einer Entscheidung: Treffen Sie möglicherweise viele Entscheidungen und treffen Sie alle.  Tatsächlich löst dies das Problem nicht, sondern schiebt es weg. </li><li>  Nehmen Sie einfach an, dass dies ein sehr seltenes Ereignis ist, das in der Praxis nicht wichtig ist.  (Dies ist die Lösung, die bei der ersten Implementierung verwendet wurde.) </li><li>  Ändern Sie den Puzzle-Generator so, dass keine Puzzles generiert werden, bei denen die Kenntnis der Einzigartigkeit der Lösung hilfreich wäre.  (Wahrscheinlich die richtige Lösung, erfordert aber zusätzliche Arbeit.) </li></ul><br>  Anfangs habe ich mich für die letztere Option entschieden, und das war ein schrecklicher Fehler.  Es stellte sich heraus, dass ich nur einen Weg berücksichtigt habe, auf dem die Einzigartigkeit der Lösung zu Informationslecks führte, und dies ist tatsächlich ziemlich selten.  Aber es gibt noch andere;  Einer von ihnen war tatsächlich auf jeder von mir generierten Ebene präsent und führte oft dazu, dass die Lösung trivial wurde.  Daher habe ich im Mai 2019 den Hard- und den Expertenmodus mit der dritten Option geändert. <br><br>  Der nervigste Fall ist eine Zwei mit einer gestrichelten Linie in diesem Feld: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af9/ecf/34f/af9ecf34f96e0d74ae1f514207940020.png"></div><br>  Warum kann ein schlauer Spieler eine solche Schlussfolgerung ziehen?  Eine Zwei kann jedes der vier benachbarten Felder bedecken.  Keiner von ihnen hat Punkte, daher müssen sie nicht durch eine Linie abgedeckt werden.  Und das Quadrat darunter hat keine Überlagerungen mit anderen Zahlen.  Wenn es eine einzige Lösung gibt, sollte dies der Fall sein, wenn andere Zahlen die verbleibenden drei Quadrate abdecken und die beiden das Quadrat darunter schließen. <br><br>  Die Lösung besteht darin, beim Erkennen solcher Fälle einige weitere Punkte hinzuzufügen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7d/d45/ebd/d7dd45ebd5d0a7aebbc78e7da61e1cd9.png"></div><br>  Ein weiterer häufiger Fall ist ein Strich mit einer gepunkteten Linie in diesem Feld: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/252/fc8/13e/252fc813e342f503a2c189645590e7f1.png"></div><br>  Die Quadrate links und oben sind nicht unterschiedlich.  Keiner von ihnen hat einen Punkt und keiner kann von einer anderen Nummer aus erreicht werden.  Jede Lösung, bei der eine Zwei das obere Quadrat bedeckt, hat eine entsprechende Lösung, bei der das linke Quadrat geschlossen wird und umgekehrt.  Wenn es eine einzige einzigartige Lösung gäbe, könnte dies nicht sein, und die Zwei hätte das untere Quadrat bedecken sollen. <br><br>  Ich habe mich für diese Art von Fall entschieden: "Wenn es weh tut, berühren Sie es nicht."  Solver hat diese Regel frühzeitig in der Prioritätenliste angewendet und solchen Bewegungen ein solches negatives Gewicht zugewiesen.  Rätsel mit dieser Funktion werden normalerweise vom Optimierer verworfen, und die wenigen verbleibenden Rätsel werden in der Phase der endgültigen Auswahl der Ebenen für das veröffentlichte Spiel verworfen. <br><br>  Dies ist keine vollständige Liste. Während des Spieltests mit einer absichtlichen Suche nach Fehlern habe ich viele andere Regeln für eindeutige Lösungen gefunden.  Aber die meisten von ihnen schienen selten zu sein und sie waren genug zu finden, so dass sie das Spiel nicht wesentlich vereinfachten.  Wenn jemand das Rätsel mit solchen Überlegungen löst, werde ich es ihnen nicht vorwerfen. <br><br><h3>  Fazit </h3><br>  Ursprünglich wurde das Spiel als Experiment zur prozeduralen Generierung von Rätseln entwickelt.  Das Design und der Generator des Spiels gingen Hand in Hand, so dass es schwierig ist, die Techniken selbst direkt auf andere Spiele anzuwenden. <br><br>  Die Frage, auf die ich keine Antwort habe: Hat sich die Investition solcher Bemühungen in die Verfahrensgenerierung gerechtfertigt?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Feedback der Spieler zum Leveldesign war sehr kontrovers. In positiven Kommentaren wurde normalerweise gesagt, dass in Rätseln immer ein kniffliger Trick zu spüren ist. In den meisten negativen Bewertungen haben sie mir geschrieben, dass dem Spiel ein Gradient der Komplexität fehlt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe noch ein paar Rätsel in den Kinderschuhen und ich mochte den Generator so sehr, dass ich höchstwahrscheinlich einen ähnlichen prozeduralen Ansatz für sie verwende. Ich werde nur eines ändern: Ich werde von Anfang an aktive Spieltests mit der Suche nach Fehlern durchführen.</font></font><br><br><h3>  Anmerkungen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0] Oder zumindest schien es mir. Aber als ich die Spieler live beobachtete, machte fast die Hälfte von ihnen nur Vermutungen und durchlief sie dann. Na ja. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] Leser meines Artikels sollten auch den Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minesweeper lösen und verbessern</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Magnus Hoff </font><font style="vertical-align: inherit;">lesen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] Ich werde klarstellen, dass die Tiefe / Enge eines Baumes eine Metrik ist, die ich für mein Spiel und nicht für alle anderen Rätsel als wichtig erachtet habe. Zum Beispiel gibt es ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20130703141244/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gutes Argument dafür,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dass das Rush Hour-Puzzle interessant ist, wenn es mehrere Möglichkeiten hat, fast, aber nicht genau dieselbe Länge zu lösen. Aber es ist passiert, weil Rush Hour ein Spiel ist, um die kürzeste Lösung zu finden, und nicht irgendeine Lösung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] Ohne Hinzufügen von Einheiten. </font><font style="vertical-align: inherit;">In der ersten Version des Puzzles gab es keine Punkte, und der Generator sollte bei Bedarf Einheiten hinzufügen. </font><font style="vertical-align: inherit;">Aber das schien zu restriktiv.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452090/">https://habr.com/ru/post/de452090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452076/index.html">UC-Browser brechen</a></li>
<li><a href="../de452078/index.html">Kubernetes Reservierung: Es besteht</a></li>
<li><a href="../de452082/index.html">Flexibler Ablauf von In-App-Updates: Beschleunigen Sie den App-Update-Prozess unter Android</a></li>
<li><a href="../de452086/index.html">Was ist in meinem Pixel für Sie: Erstellen von Nanopixeln mit Plasmon-Metaoberflächen</a></li>
<li><a href="../de452088/index.html">Straßenerkennung durch semantische Segmentierung</a></li>
<li><a href="../de452092/index.html">In-App-Updates: Beschleunigen von Android-Anwendungsupdates</a></li>
<li><a href="../de452094/index.html">.NET: Tools zum Arbeiten mit Multithreading und Asynchronität. Teil 1</a></li>
<li><a href="../de452098/index.html">Protokolle des Frontend-Entwicklers Habr: Refactor und Reflex</a></li>
<li><a href="../de452102/index.html">Fotospiel für Drohnenliebhaber: kurz über AirSelfie 2</a></li>
<li><a href="../de452106/index.html">Wir laden Redner zum Sommer-DIY-Meeting am 16. Juni 2019 ein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>