<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òëÔ∏è üóÇÔ∏è üí¥ Erstellen eines prozeduralen Puzzle-Generators üêÄ ü§¥üèø üé∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Beitrag beschreibt den Levelgenerator f√ºr mein Linjat- Puzzlespiel. Ein Beitrag kann ohne Vorbereitung gelesen werden, aber es ist einfacher zu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines prozeduralen Puzzle-Generators</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452090/"> Dieser Beitrag beschreibt den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Levelgenerator</a> f√ºr mein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linjat-</a> Puzzlespiel.  Ein Beitrag kann ohne Vorbereitung gelesen werden, aber es ist einfacher zu assimilieren, wenn Sie in mehreren Levels spielen.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Quellcode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf github gepostet</a> .  Alles, was im Artikel besprochen wird, befindet sich in der <code>src/main.cc</code> <br><br>  Beispiel f√ºr einen Postplan: <br><br><ul><li>  Linjat ist ein Logikspiel, bei dem Sie alle Zahlen und Punkte im Raster mit Linien schlie√üen m√ºssen. </li><li>  Die R√§tsel werden prozedural mit einer Kombination aus Solver, Generator und Optimierer generiert. </li><li>  Solver versucht, die R√§tsel so zu l√∂sen, wie es eine Person tun w√ºrde, und weist jedem R√§tsel eine Bewertung von Interesse zu. </li><li>  Der Puzzle-Generator ist so konzipiert, dass ein Teil des Puzzles (Nummer) leicht ge√§ndert werden kann und gleichzeitig alle anderen Teile (Punkte) ge√§ndert werden, sodass das Puzzle l√∂sbar bleibt. </li><li>  Der Puzzle-Optimierer l√∂st wiederholt die Level und generiert neue Variationen aus den derzeit interessantesten. </li></ul><br><h3>  Die Regeln </h3><br>  Um zu verstehen, wie der Levelgenerator funktioniert, m√ºssen Sie leider die Spielregeln verstehen.  Zum Gl√ºck sind sie sehr einfach.  Das Puzzle besteht aus einem Gitter mit leeren Quadraten, Zahlen und Punkten.  Ein Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/641/0d0/547/6410d0547bc14faae51beb3942867cb0.png"></div><br>  Das Ziel des Spielers ist es, unter drei Bedingungen eine vertikale oder horizontale Linie durch jede der Zahlen zu ziehen: <br><br><ul><li>  Eine Linie durch eine Zahl muss dieselbe L√§nge wie die Zahl haben. </li><li>  Linien k√∂nnen sich nicht schneiden. </li><li>  Alle Punkte m√ºssen mit Linien geschlossen werden. </li></ul><br>  Beispiell√∂sung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/3ce/91c/7e13ce91c2da2e2d64bd98f523010671.png"></div><br>  Hurra!  Das Spieldesign ist fertig, die Benutzeroberfl√§che ist implementiert, und jetzt m√ºssen nur noch mehrere hundert gute R√§tsel gefunden werden.  Und f√ºr solche Spiele ist es normalerweise nicht sinnvoll, solche R√§tsel manuell zu erstellen.  Dies ist ein Computerjob. <br><a name="habracut"></a><br><h3>  Anforderungen </h3><br>  Was macht das Puzzle f√ºr dieses Spiel gut?  Ich neige dazu zu glauben, dass Puzzlespiele in zwei Kategorien unterteilt werden k√∂nnen.  Es gibt Spiele, in denen Sie einen komplexen Zustandsraum von Anfang bis Ende erkunden (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sokoban</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rush Hour</a> ) und in denen m√∂glicherweise nicht klar ist, welche Zust√§nde im Spiel vorhanden sind.  Und es gibt Spiele, in denen alle Zust√§nde von Anfang an bekannt sind, und wir gestalten den Zustandsraum schrittweise so, dass unn√∂tige (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sudoku</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Picross</a> ) eliminiert werden.  Mein Spiel f√§llt definitiv in die zweite Kategorie. <br><br>  Spieler haben sehr unterschiedliche Anforderungen an diese verschiedenen Arten von R√§tseln.  Im zweiten Fall erwarten sie, dass das R√§tsel nur durch Abzug gel√∂st werden kann und dass sie niemals zur√ºckgehen / raten / versuchen und irren m√ºssen <sup>[0]</sup> <sup>[1]</sup> . <br><br>  Es reicht nicht aus zu wissen, ob ein R√§tsel nur durch Logik gel√∂st werden kann.  Au√üerdem m√ºssen wir irgendwie verstehen, wie gut die erstellten R√§tsel sind.  Andernfalls sind die meisten Ebenen nur triviale Schlacken.  Im Idealfall kann dieses Prinzip auch verwendet werden, um eine reibungslose Fortschrittskurve zu erstellen, sodass die Level im Verlauf des Spiels allm√§hlich schwieriger werden. <br><br><h3>  L√∂ser </h3><br>  Der erste Schritt zur Erf√ºllung dieser Anforderungen besteht darin, einen f√ºr diesen Zweck optimierten Spiell√∂ser zu erstellen.  Mit dem Backtracking-Solver k√∂nnen Sie schnell und genau feststellen, ob das Puzzle l√∂sbar ist.  Dar√ºber hinaus kann es ge√§ndert werden, um festzustellen, ob die L√∂sung eindeutig ist.  Aber er kann keine Vorstellung davon geben, wie kompliziert das R√§tsel wirklich ist, weil die Leute sie anders l√∂sen.  Solver muss menschliches Verhalten imitieren. <br><br>  Wie l√∂st eine Person dieses R√§tsel?  Hier sind einige offensichtliche Schritte, die das In-Game-Tutorial lehrt: <br><br><ul><li>  Wenn ein Punkt nur von einer Zahl aus erreicht werden kann, m√ºssen Sie zum Schlie√üen eines Punktes eine Linie von dieser Zahl ziehen.  In diesem Beispiel kann der Punkt nur von den drei, nicht aber von den vier erreicht werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76d/1d4/e3e/76d1d4e3e87a0cc9efdebbd586420c84.png"></div><br>  Und das f√ºhrt zu dieser Situation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a15/db3/05f/a15db305fa78a149ee614de0b4b8ed54.png"></div></li><li>  Wenn die Linie nicht in eine Richtung passt, muss sie in eine andere Richtung gelegt werden.  Im obigen Beispiel k√∂nnen die vier nicht mehr vertikal positioniert werden, sodass wir wissen, dass sie horizontal sind: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ef/048/99f/5ef04899f1c9da5a5b8492e1316ddcbf.png"></div></li><li>  Wenn bekannt ist, dass sich die Linie der L√§nge X an einer bestimmten Position (vertikal / horizontal) befinden muss und nicht gen√ºgend Leerraum vorhanden ist, um eine Linie von X leeren Zellen auf beiden Seiten zu platzieren, m√ºssen Sie mehrere Quadrate in der Mitte abdecken.  Wenn die vier in dem oben gezeigten Beispiel drei w√§ren, w√ºrden wir nicht wissen, ob sie sich ganz nach rechts oder links erstrecken.  Aber wir w√ºrden wissen, dass die Linie zwei mittlere Quadrate abdecken sollte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02c/bfa/021/02cbfa02113362bc6e3c5217baee3ff3.png"></div></li></ul><br>  √Ñhnliche √úberlegungen sind die Grundlage des Spiels.  Der Spieler sucht nach M√∂glichkeiten, eine kleine Linie zu strecken, und untersucht dann das Feld erneut, da er Informationen erhalten kann, um eine weitere logische Schlussfolgerung zu ziehen.  Das Erstellen eines L√∂sers, der diesen Regeln folgt, reicht aus, um festzustellen, <i>ob eine</i> Person das R√§tsel l√∂sen kann, ohne zur√ºckzukehren. <br><br>  Dies sagt jedoch nichts √ºber die Komplexit√§t oder Interessantheit des Levels aus.  Neben der L√∂sbarkeit m√ºssen wir auch die Komplexit√§t quantifizieren. <br><br>  Eine offensichtliche erste Idee f√ºr die Bewertungsfunktion: Je mehr Z√ºge Sie ben√∂tigen, um das R√§tsel zu l√∂sen, desto schwieriger wird es.  Dies ist wahrscheinlich eine gute Metrik in anderen Spielen, aber meine ist h√∂chstwahrscheinlich wichtiger als die Anzahl der erlaubten Z√ºge, die ein Spieler hat.  Wenn ein Spieler 10 logische Schlussfolgerungen ziehen kann, wird er h√∂chstwahrscheinlich sehr schnell eine davon finden.  Wenn es nur einen richtigen Zug gibt, dauert es l√§nger. <br><br>  Das hei√üt, in erster N√§herung muss der Entscheidungsbaum tief und eng sein: Es gibt eine lange Abh√§ngigkeit der Bewegungen von Anfang bis Ende, und zu jedem Zeitpunkt gibt es nur wenige M√∂glichkeiten, die Kette nach oben zu bewegen <sup>[2]</sup> . <br><br>  Wie bestimmen wir die Breite und Tiefe eines Baumes?  Eine einzige L√∂sung f√ºr das R√§tsel und die Bewertung des erstellten Baums gibt keine genaue Antwort.  Die genaue Reihenfolge, in der Bewegungen ausgef√ºhrt werden, wirkt sich auf die Form des Baums aus.  Wir m√ºssen alle m√∂glichen L√∂sungen in Betracht ziehen und damit so etwas wie eine Optimierung f√ºr die besten und schlechtesten F√§lle durchf√ºhren.  Ich bin mit der Technik der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">groben Suche nach Suchgraphen in Puzzlespielen</a> vertraut, aber f√ºr dieses Projekt wollte ich einen One-Pass-Solver erstellen und keine ersch√∂pfende Suche.  Aufgrund der Optimierungsphase habe ich versucht sicherzustellen, dass die Laufzeit des Solvers nicht in Sekunden, sondern in Millisekunden gemessen wurde. <br><br>  Ich habe mich dagegen entschieden.  Stattdessen macht mein L√∂ser nicht jeweils einen Zug, sondern l√∂st das R√§tsel in Schichten: Wenn er einen Zustand annimmt, findet er alle g√ºltigen Z√ºge, die ausgef√ºhrt werden k√∂nnen.  Wendet dann alle diese Z√ºge gleichzeitig an und beginnt in einem neuen Zustand von vorne.  Die Anzahl der Ebenen und die maximale Anzahl der auf einer Ebene gefundenen Bewegungen werden dann als ungef√§hre Werte f√ºr die Tiefe und Breite des gesamten Suchbaums verwendet. <br><br>  Hier erfahren Sie, wie Sie eines der schwierigen R√§tsel mit diesem Modell l√∂sen k√∂nnen.  Gepunktete Linien sind Linien, die auf dieser Schicht des L√∂sers gestreckt sind. Durchgezogene Linien sind solche, die sich nicht ge√§ndert haben.  Die gr√ºnen Linien haben die richtige L√§nge, die roten sind noch nicht vollst√§ndig. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2af/1de/cfb/2af1decfbc170ec8965ae8b1cce2cbea.png"></div><br>  Das n√§chste Problem ist, dass alle vom Spieler ausgef√ºhrten Z√ºge gleich sind.  Was wir am Anfang dieses Abschnitts aufgelistet haben, ist nur gesunder Menschenverstand.  Hier ist ein Beispiel f√ºr eine komplexere Abzugsregel, deren Suche etwas mehr Nachdenken erfordert.  Betrachten Sie das folgende Feld: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c18/772/9c4c187726bf50f03bbffa748137cf44.png"></div><br>  Die Punkte in C und D k√∂nnen nur von den f√ºnf und den mittleren vier abgedeckt werden (und keine einzige Zahl kann beide Punkte gleichzeitig abdecken).  Dies bedeutet, dass die vier in der Mitte einen der beiden Punkte abdecken sollten und daher nicht zur Abdeckung von A verwendet werden k√∂nnen. Daher sollte der Punkt A die vier in der unteren linken Ecke schlie√üen. <br><br>  Offensichtlich w√§re es dumm, diese Argumentationskette als gleichbedeutend mit der einfachen Schlussfolgerung zu betrachten, dass "dieser Punkt nur von dieser Zahl aus erreicht werden kann".  Ist es m√∂glich, diesen komplexeren Regeln in der Bewertungsfunktion mehr Gewicht zu verleihen?  Leider ist dies in einem schichtbasierten L√∂ser nicht m√∂glich, da nicht garantiert wird, dass eine L√∂sung zu den niedrigsten Kosten gefunden wird.  Dies ist nicht nur ein theoretisches Problem - in der Praxis kommt es h√§ufig vor, dass ein Teil des Feldes entweder durch ein einzelnes komplexes Argument oder durch eine Kette viel einfacherer Schritte gel√∂st werden kann.  Tats√§chlich findet ein schichtbasierter L√∂ser den k√ºrzesten und nicht den kosteng√ºnstigsten Weg, und dies kann nicht in der Bewertungsfunktion widergespiegelt werden. <br><br>  Als Ergebnis kam ich zu dieser Entscheidung: Ich habe den L√∂ser so ge√§ndert, dass jede Ebene nur aus einer Art von Argumentation bestand.  Der Algorithmus umgeht die Argumentationsregeln in einer ungef√§hren Reihenfolge der Komplexit√§t.  Wenn die Regel einige Z√ºge findet, werden sie angewendet, und die Iteration endet, und die n√§chste Iteration beginnt die Liste von Anfang an. <br><br>  Anschlie√üend wird der Entscheidung eine Bewertung zugewiesen: Jeder Schicht werden Kosten zugewiesen, die auf einer darin verwendeten Regel basieren.  Dies garantiert immer noch nicht, dass die L√∂sung am kosteng√ºnstigsten ist. Wenn die Gewichte jedoch richtig ausgew√§hlt werden, findet der Algorithmus zumindest keine kostspielige L√∂sung, wenn es eine billige gibt. <br><br>  Dar√ºber hinaus ist es sehr √§hnlich, wie Menschen R√§tsel l√∂sen.  Sie versuchen zun√§chst, einfache L√∂sungen zu finden, und beginnen nur dann, ihr Gehirn aktiv zu bewegen, wenn es keine einfachen Bewegungen gibt. <br><br><h3>  Generator </h3><br>  Im vorherigen Abschnitt wurde festgestellt, ob ein bestimmtes Niveau gut oder schlecht war.  Aber nur das ist nicht genug, wir m√ºssen immer noch irgendwie Level generieren, damit der Solver sie auswerten kann.  Es ist sehr unwahrscheinlich, dass eine zuf√§llig erzeugte Welt l√∂sbar ist, ganz zu schweigen von interessant. <br><br>  Die Hauptidee (keineswegs neu) ist die alternative Verwendung von Solver und Generator.  Beginnen wir mit einem R√§tsel, das wahrscheinlich unl√∂sbar ist: Platzieren Sie einfach zwei bis f√ºnf Zahlen in zuf√§lligen Quadraten der Zelle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cf/164/3c5/8cf1643c568477bc2c774d33a0994f96.png"></div><br>  Solver funktioniert, bis es sich weiterentwickeln kann: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/9b4/a5c/64f9b4a5c022b2560c1a26746a0c3539.png"></div><br>  Anschlie√üend f√ºgt der Generator dem Puzzle weitere Informationen in Form eines Punkts hinzu. Anschlie√üend wird die Ausf√ºhrung des L√∂sers fortgesetzt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b4/397/23f/1b439723f7d229887c8392ebc07053f3.png"></div><br>  In diesem Fall reicht der dem L√∂ser hinzugef√ºgte Punkt f√ºr die weitere Entwicklung nicht aus.  Dann f√ºgt der Generator weiterhin neue Punkte hinzu, bis er den L√∂ser erf√ºllt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/3a0/48d/6b23a048dc66700a3eadf94206705c7c.png"></div><br>  Und dann setzt der L√∂ser seine √ºbliche Arbeit fort: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8e/b9a/77a/b8eb9a77a027a741ce259a1b95fe9c89.png"></div><br>  Dieser Vorgang wird entweder fortgesetzt, bis das R√§tsel gel√∂st ist oder bis weitere Informationen hinzugef√ºgt werden m√ºssen (z. B. wenn jede Zelle, die √ºber die Nummer erreichbar ist, bereits einen Punkt enth√§lt). <br><br>  Diese Methode funktioniert nur, wenn die hinzugef√ºgten neuen Informationen keine der zuvor gemachten Schlussfolgerungen falsch machen k√∂nnen.  Dies w√§re beim Hinzuf√ºgen von Zahlen zum Raster schwierig <sup>[3]</sup> .  Das Hinzuf√ºgen neuer Punkte zum Feld hat jedoch diese Eigenschaft.  Zumindest f√ºr die Argumentationsregeln, die ich in diesem Programm verwende. <br><br>  Wo soll der Algorithmus Punkte hinzuf√ºgen?  Am Ende habe ich beschlossen, sie dem leeren Raum hinzuzuf√ºgen, der im Ausgangszustand mit so vielen Zeilen wie m√∂glich geschlossen werden kann, damit jeder Punkt so wenig Informationen wie m√∂glich preisgibt.  Ich habe nicht versucht, den Punkt an der Stelle zu platzieren, an der er n√ºtzlich w√§re, um das R√§tsel zu l√∂sen, wenn der L√∂ser stecken bleibt.  Dies erzeugt einen sehr praktischen Effekt: Die meisten Punkte am Anfang des Puzzles scheinen v√∂llig nutzlos zu sein, was das Puzzle schwieriger macht als es wirklich ist.  Wenn all dies eine Menge offensichtlicher Bewegungen ist, die ein Spieler machen kann, aber aus irgendeinem Grund funktioniert keiner von ihnen nicht richtig.  Als Ergebnis stellte sich heraus, dass sich der Puzzle-Generator ein bisschen wie ein Schwein verh√§lt. <br><br>  Dieser Prozess erstellt nicht immer eine L√∂sung, ist jedoch recht schnell (ca. 50 bis 100 Millisekunden). Um ein Level zu generieren, k√∂nnen Sie es einfach mehrmals wiederholen.  Leider schafft er normalerweise mittelm√§√üige R√§tsel.  Von Anfang an gibt es zu viele offensichtliche Bewegungen, das Feld f√ºllt sich sehr schnell und der Entscheidungsbaum ist eher flach. <br><br><h3>  Optimierer </h3><br>  Der oben beschriebene Prozess erzeugte mittelm√§√üige R√§tsel.  In der letzten Phase verwende ich diese Ebenen als Grundlage f√ºr den Optimierungsprozess.  Es funktioniert wie folgt. <br><br>  Der Optimierer erstellt einen Pool mit bis zu 10 Puzzle-Optionen.  Der Pool wird mit einem neu generierten zuf√§lligen Puzzle initialisiert.  Bei jeder Iteration w√§hlt der Optimierer ein Puzzle aus dem Pool aus und f√ºhrt seine Mutation durch. <br><br>  Die Mutation l√∂scht alle Punkte und √§ndert dann die Zahlen geringf√ºgig (d. H. Verringert / erh√∂ht den Wert einer zuf√§llig ausgew√§hlten Zahl oder verschiebt die Zahl in eine andere Zelle im Gitter).  Sie k√∂nnen mehrere Mutationen gleichzeitig auf das Feld anwenden.  Anschlie√üend f√ºhren wir den Solver im speziellen Level-Generierungsmodus aus, der im vorherigen Abschnitt beschrieben wurde.  Er f√ºgt dem Puzzle gen√ºgend Punkte hinzu, damit es wieder l√∂sbar wird. <br><br>  Danach starten wir den Solver erneut, diesmal im normalen Modus.  W√§hrend dieses Laufs √ºberwacht der L√∂ser a) die Tiefe des Entscheidungsbaums, b) die H√§ufigkeit des Bedarfs an verschiedenen Arten von Regeln, c) die Breite des Entscheidungsbaums zu verschiedenen Zeitpunkten.  Das Puzzle wird anhand der oben beschriebenen Kriterien bewertet.  Die Bewertungsfunktion bevorzugt tiefe und enge L√∂sungen, und die zunehmende Komplexit√§t erh√∂ht auch das Gewicht von R√§tseln, bei denen komplexere Argumentationsregeln erforderlich sind. <br><br>  Dann wird dem Pool ein neues Puzzle hinzugef√ºgt.  Wenn der Pool mehr als 10 R√§tsel enth√§lt, wird das Schlimmste verworfen. <br><br>  Dieser Vorgang wird mehrmals wiederholt (ungef√§hr 10.000 bis 50000 Iterationen haben mich gekostet).  Danach wird die am h√∂chsten bewertete Version des Puzzles in der Puzzle-Level-Datenbank gespeichert.  So sieht der Fortschritt des besten Puzzles in einem Optimierungslauf aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/e61/40c/504e6140c20049ca3424456de0985aaf.png"></div><br>  Ich habe versucht, die Optimierung auf andere Weise zu strukturieren.  In einer Version wurde simuliertes Tempern verwendet, andere waren genetische Algorithmen mit verschiedenen √úberkreuzungsoperationen.  Keine der L√∂sungen war so gut wie ein naiver Algorithmus mit einem Pool von Optionen, die wieder nach oben gehen. <br><br><h3>  Einzigartige Einzell√∂sung </h3><br>  Wenn ein Puzzle eine einzigartige, einzigartige L√∂sung hat, entsteht eine interessante Schwierigkeit.  Ist es m√∂glich, dem Spieler zu erlauben, anzunehmen, dass es eine L√∂sung gibt, und daraus Schlussfolgerungen zu ziehen?  W√§re es fair, wenn der Puzzle-Generator dem Spieler dies vorschlagen w√ºrde? <br><br>  In einem Beitrag auf HackerNews sagte ich, dass es vier M√∂glichkeiten gibt, sich dieser Situation zu n√§hern: <br><br><ul><li>  Erkl√§ren Sie die Eindeutigkeit der L√∂sung von Anfang an und zwingen Sie den Generator, Ebenen zu erstellen, die diese Art von Argumentation erfordern.  Dies ist eine schlechte Entscheidung, da dies das Verst√§ndnis der Regeln erschwert.  Und normalerweise sind dies die Details, die die Leute vergessen. </li><li>  Garantieren Sie nicht die Einzigartigkeit einer Entscheidung: Treffen Sie m√∂glicherweise viele Entscheidungen und treffen Sie alle.  Tats√§chlich l√∂st dies das Problem nicht, sondern schiebt es weg. </li><li>  Nehmen Sie einfach an, dass dies ein sehr seltenes Ereignis ist, das in der Praxis nicht wichtig ist.  (Dies ist die L√∂sung, die bei der ersten Implementierung verwendet wurde.) </li><li>  √Ñndern Sie den Puzzle-Generator so, dass keine Puzzles generiert werden, bei denen die Kenntnis der Einzigartigkeit der L√∂sung hilfreich w√§re.  (Wahrscheinlich die richtige L√∂sung, erfordert aber zus√§tzliche Arbeit.) </li></ul><br>  Anfangs habe ich mich f√ºr die letztere Option entschieden, und das war ein schrecklicher Fehler.  Es stellte sich heraus, dass ich nur einen Weg ber√ºcksichtigt habe, auf dem die Einzigartigkeit der L√∂sung zu Informationslecks f√ºhrte, und dies ist tats√§chlich ziemlich selten.  Aber es gibt noch andere;  Einer von ihnen war tats√§chlich auf jeder von mir generierten Ebene pr√§sent und f√ºhrte oft dazu, dass die L√∂sung trivial wurde.  Daher habe ich im Mai 2019 den Hard- und den Expertenmodus mit der dritten Option ge√§ndert. <br><br>  Der nervigste Fall ist eine Zwei mit einer gestrichelten Linie in diesem Feld: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af9/ecf/34f/af9ecf34f96e0d74ae1f514207940020.png"></div><br>  Warum kann ein schlauer Spieler eine solche Schlussfolgerung ziehen?  Eine Zwei kann jedes der vier benachbarten Felder bedecken.  Keiner von ihnen hat Punkte, daher m√ºssen sie nicht durch eine Linie abgedeckt werden.  Und das Quadrat darunter hat keine √úberlagerungen mit anderen Zahlen.  Wenn es eine einzige L√∂sung gibt, sollte dies der Fall sein, wenn andere Zahlen die verbleibenden drei Quadrate abdecken und die beiden das Quadrat darunter schlie√üen. <br><br>  Die L√∂sung besteht darin, beim Erkennen solcher F√§lle einige weitere Punkte hinzuzuf√ºgen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7d/d45/ebd/d7dd45ebd5d0a7aebbc78e7da61e1cd9.png"></div><br>  Ein weiterer h√§ufiger Fall ist ein Strich mit einer gepunkteten Linie in diesem Feld: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/252/fc8/13e/252fc813e342f503a2c189645590e7f1.png"></div><br>  Die Quadrate links und oben sind nicht unterschiedlich.  Keiner von ihnen hat einen Punkt und keiner kann von einer anderen Nummer aus erreicht werden.  Jede L√∂sung, bei der eine Zwei das obere Quadrat bedeckt, hat eine entsprechende L√∂sung, bei der das linke Quadrat geschlossen wird und umgekehrt.  Wenn es eine einzige einzigartige L√∂sung g√§be, k√∂nnte dies nicht sein, und die Zwei h√§tte das untere Quadrat bedecken sollen. <br><br>  Ich habe mich f√ºr diese Art von Fall entschieden: "Wenn es weh tut, ber√ºhren Sie es nicht."  Solver hat diese Regel fr√ºhzeitig in der Priorit√§tenliste angewendet und solchen Bewegungen ein solches negatives Gewicht zugewiesen.  R√§tsel mit dieser Funktion werden normalerweise vom Optimierer verworfen, und die wenigen verbleibenden R√§tsel werden in der Phase der endg√ºltigen Auswahl der Ebenen f√ºr das ver√∂ffentlichte Spiel verworfen. <br><br>  Dies ist keine vollst√§ndige Liste. W√§hrend des Spieltests mit einer absichtlichen Suche nach Fehlern habe ich viele andere Regeln f√ºr eindeutige L√∂sungen gefunden.  Aber die meisten von ihnen schienen selten zu sein und sie waren genug zu finden, so dass sie das Spiel nicht wesentlich vereinfachten.  Wenn jemand das R√§tsel mit solchen √úberlegungen l√∂st, werde ich es ihnen nicht vorwerfen. <br><br><h3>  Fazit </h3><br>  Urspr√ºnglich wurde das Spiel als Experiment zur prozeduralen Generierung von R√§tseln entwickelt.  Das Design und der Generator des Spiels gingen Hand in Hand, so dass es schwierig ist, die Techniken selbst direkt auf andere Spiele anzuwenden. <br><br>  Die Frage, auf die ich keine Antwort habe: Hat sich die Investition solcher Bem√ºhungen in die Verfahrensgenerierung gerechtfertigt?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Feedback der Spieler zum Leveldesign war sehr kontrovers. In positiven Kommentaren wurde normalerweise gesagt, dass in R√§tseln immer ein kniffliger Trick zu sp√ºren ist. In den meisten negativen Bewertungen haben sie mir geschrieben, dass dem Spiel ein Gradient der Komplexit√§t fehlt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe noch ein paar R√§tsel in den Kinderschuhen und ich mochte den Generator so sehr, dass ich h√∂chstwahrscheinlich einen √§hnlichen prozeduralen Ansatz f√ºr sie verwende. Ich werde nur eines √§ndern: Ich werde von Anfang an aktive Spieltests mit der Suche nach Fehlern durchf√ºhren.</font></font><br><br><h3>  Anmerkungen </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0] Oder zumindest schien es mir. Aber als ich die Spieler live beobachtete, machte fast die H√§lfte von ihnen nur Vermutungen und durchlief sie dann. Na ja. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] Leser meines Artikels sollten auch den Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minesweeper l√∂sen und verbessern</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Magnus Hoff </font><font style="vertical-align: inherit;">lesen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] Ich werde klarstellen, dass die Tiefe / Enge eines Baumes eine Metrik ist, die ich f√ºr mein Spiel und nicht f√ºr alle anderen R√§tsel als wichtig erachtet habe. Zum Beispiel gibt es ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20130703141244/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gutes Argument daf√ºr,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dass das Rush Hour-Puzzle interessant ist, wenn es mehrere M√∂glichkeiten hat, fast, aber nicht genau dieselbe L√§nge zu l√∂sen. Aber es ist passiert, weil Rush Hour ein Spiel ist, um die k√ºrzeste L√∂sung zu finden, und nicht irgendeine L√∂sung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] Ohne Hinzuf√ºgen von Einheiten. </font><font style="vertical-align: inherit;">In der ersten Version des Puzzles gab es keine Punkte, und der Generator sollte bei Bedarf Einheiten hinzuf√ºgen. </font><font style="vertical-align: inherit;">Aber das schien zu restriktiv.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452090/">https://habr.com/ru/post/de452090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452076/index.html">UC-Browser brechen</a></li>
<li><a href="../de452078/index.html">Kubernetes Reservierung: Es besteht</a></li>
<li><a href="../de452082/index.html">Flexibler Ablauf von In-App-Updates: Beschleunigen Sie den App-Update-Prozess unter Android</a></li>
<li><a href="../de452086/index.html">Was ist in meinem Pixel f√ºr Sie: Erstellen von Nanopixeln mit Plasmon-Metaoberfl√§chen</a></li>
<li><a href="../de452088/index.html">Stra√üenerkennung durch semantische Segmentierung</a></li>
<li><a href="../de452092/index.html">In-App-Updates: Beschleunigen von Android-Anwendungsupdates</a></li>
<li><a href="../de452094/index.html">.NET: Tools zum Arbeiten mit Multithreading und Asynchronit√§t. Teil 1</a></li>
<li><a href="../de452098/index.html">Protokolle des Frontend-Entwicklers Habr: Refactor und Reflex</a></li>
<li><a href="../de452102/index.html">Fotospiel f√ºr Drohnenliebhaber: kurz √ºber AirSelfie 2</a></li>
<li><a href="../de452106/index.html">Wir laden Redner zum Sommer-DIY-Meeting am 16. Juni 2019 ein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>