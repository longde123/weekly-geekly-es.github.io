<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåµ üë®üèø‚Äçüè≠ üçª Was n√ºtzt die dynamische Analyse, wenn Sie eine statische Analyse haben? ‚ú°Ô∏è üë®üèæ‚Äçüè´ üê§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um die Qualit√§t der Software zu √ºberpr√ºfen, m√ºssen Sie viele verschiedene Tools verwenden, einschlie√ülich statischer und dynamischer Analyseger√§te. In...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was n√ºtzt die dynamische Analyse, wenn Sie eine statische Analyse haben?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/461173/">  Um die Qualit√§t der Software zu √ºberpr√ºfen, m√ºssen Sie viele verschiedene Tools verwenden, einschlie√ülich statischer und dynamischer Analyseger√§te.  In diesem Artikel versuchen wir herauszufinden, warum nur eine Art von Analyse, ob statisch oder dynamisch, f√ºr eine umfassende Softwareanalyse m√∂glicherweise nicht ausreicht und warum es vorzuziehen ist, beide zu verwenden. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff6/72e/d2b/ff672ed2bf84a53f4170fef43c54a861.png" alt="Abbildung 1"></div><br><a name="habracut"></a><br>  Unser Team schreibt viel √ºber die N√ºtzlichkeit der statischen Analyse und die Vorteile, die sie f√ºr Ihre Projekte mit sich bringt.  Wir m√∂chten unser Tool in verschiedenen Open-Source-Projekten ausf√ºhren, um m√∂gliche Fehler zu finden. Auf diese Weise k√∂nnen wir die statische Code-Analysemethode bekannt machen.  Die statische Analyse tr√§gt wiederum dazu bei, Programme qualitativ hochwertiger und zuverl√§ssiger zu machen und die Anzahl potenzieller Schwachstellen zu verringern.  Vielleicht hat jeder, der direkt an der Arbeit am Quellcode beteiligt ist, das Gef√ºhl der Zufriedenheit, Fehler behoben zu haben.  Aber selbst wenn das erfolgreiche Erkennen (und Beheben) von Fehlern Ihre Endorphine nicht ausl√∂st, genie√üen Sie sicherlich den Gedanken, die Entwicklungskosten dank des statischen Analysators zu senken, der Ihren Programmierern geholfen hat, ihre Zeit effektiver und effizienter zu nutzen.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> erfahren Sie mehr dar√ºber, wie Sie von der Verwendung statischer Analysen in Bezug auf Geld profitieren k√∂nnen.  Es gibt eine ungef√§hre Sch√§tzung f√ºr PVS-Studio, aber diese Ergebnisse k√∂nnen auf andere auf dem Markt verf√ºgbare statische Analysewerkzeuge hochgerechnet werden. <br><br>  Alles oben Gesagte scheint darauf hinzudeuten, dass der Zweck der statischen Analyse darin besteht, Fehler im Quellcode so fr√ºh wie m√∂glich zu finden, wodurch die Kosten f√ºr die Fehlerbehebung reduziert werden.  Aber warum brauchen wir dann eine dynamische Analyse und warum kann es unzureichend sein, sich nur an eine der beiden Techniken zu halten?  Lassen Sie uns formellere und klarere Definitionen statischer und dynamischer Analysen geben und versuchen, diese Fragen zu beantworten. <br><br>  Bei der statischen Code-Analyse werden Fehler und Code-Ger√ºche im Quellcode der Software erkannt.  Um ein Programm zu analysieren, m√ºssen Sie es nicht ausf√ºhren.  Die Analyse wird auf der verf√ºgbaren Codebasis durchgef√ºhrt.  Die der statischen Analyse am n√§chsten kommende Analogie ist die sogenannte Code√ºberpr√ºfung, mit der Ausnahme, dass die statische Analyse eine automatisierte Version der Code√ºberpr√ºfung ist (dh von einem Bot-Programm durchgef√ºhrt wird). <br><br>  Die Hauptvorteile der statischen Analyse: <br><br><ol><li>  Fehlererkennung in der fr√ºhen Entwicklungsphase.  Dies tr√§gt dazu bei, die Fehlerbehebung viel billiger zu machen, da die Fehlerbehebung umso einfacher und damit umso billiger ist, je fr√ºher ein Fehler erkannt wird. </li><li>  Damit k√∂nnen Sie den potenziellen Fehler im Quellcode genau lokalisieren. </li><li>  Volle Codeabdeckung.  Unabh√§ngig davon, wie oft der eine oder andere Codeblock w√§hrend der Ausf√ºhrung die Kontrolle erh√§lt, √ºberpr√ºft die statische Analyse die gesamte Codebasis. </li><li>  Einfach zu bedienen.  Sie m√ºssen keine Eingabedatens√§tze vorbereiten, um eine √úberpr√ºfung durchzuf√ºhren. </li><li>  Statische Analyseger√§te erkennen Tippfehler und Fehler beim Kopieren und Einf√ºgen relativ schnell und einfach. </li></ol><br>  Die objektiven Nachteile der statischen Analyse: <br><br><ol><li>  Unvermeidliche Fehlalarme.  Ein statischer Analysator kann sich √ºber Codefragmente √§rgern, die tats√§chlich keine Fehler enthalten.  Nur der Programmierer kann dieses Problem l√∂sen und eine Warnung als falsch positiv markieren, was bedeutet, dass dies einen Teil seiner Arbeitszeit in Anspruch nimmt. </li><li>  Die statische Analyse ist im Allgemeinen schlecht darin, Speicherlecks und Fehler im Zusammenhang mit der Parallelit√§t zu erkennen.  Um solche Fehler zu erkennen, m√ºssten Sie tats√§chlich einen Teil des Programms im virtuellen Modus ausf√ºhren, was eine √§u√üerst schwierige Aufgabe ist.  Au√üerdem w√ºrden solche Algorithmen zu viel Speicher und CPU-Zeit erfordern.  Statische Analyseger√§te gehen normalerweise nicht weiter als die Analyse einiger einfacher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F√§lle</a> .  Dynamische Analyseger√§te eignen sich besser zur Diagnose von Speicherlecks und Fehlern im Zusammenhang mit der Parallelit√§t. </li></ol><br>  Es ist zu beachten, dass sich statische Analyseger√§te nicht ausschlie√ülich auf das Auffinden von Fehlern konzentrieren.  Sie k√∂nnen beispielsweise Empfehlungen zur Code-Formatierung geben.  Mit einigen Tools k√∂nnen Sie Ihren Code auf √úbereinstimmung mit dem Codierungsstandard √ºberpr√ºfen, an den sich Ihr Unternehmen h√§lt.  Dies umfasst das Einr√ºcken verschiedener Konstrukte, die Verwendung von Leerzeichen / Tabellierungszeichen usw.  Dar√ºber hinaus kann die statische Analyse zur Messung von Metriken hilfreich sein.  Eine Software-Metrik ist ein quantitatives Ma√ü daf√ºr, inwieweit ein Programm oder seine Spezifikationen eine Eigenschaft besitzen.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> erfahren Sie mehr √ºber andere Anwendungen der statischen Analyse. <br><br>  Dynamische Codeanalyse ist die Analyse, die zur Ausf√ºhrungszeit an einem Programm durchgef√ºhrt wird.  Dies bedeutet, dass Sie Ihren Quellcode zuerst in eine ausf√ºhrbare Datei konvertieren m√ºssen.  Mit anderen Worten, Code, der Kompilierungs- oder Erstellungsfehler enth√§lt, kann durch diese Art der Analyse nicht √ºberpr√ºft werden.  Die √úberpr√ºfung erfolgt mit einem Satz von Eingabedaten, die dem zu analysierenden Programm zugef√ºhrt werden.  Deshalb h√§ngt die Wirksamkeit der dynamischen Analyse direkt von der Qualit√§t und Quantit√§t der Testeingabedaten ab.  Diese Daten bestimmen den Umfang der Codeabdeckung am Ende des Tests. <br><br>  Mit dynamischen Tests k√∂nnen Sie die folgenden Metriken und Warnungen erhalten: <br><br><ol><li>  Verwendete Ressourcen: Ausf√ºhrungszeit des gesamten Programms oder seiner einzelnen Teile, Anzahl der externen Abfragen (z. B. an eine Datenbank), RAM-Gr√∂√üe und andere vom Programm verwendete Ressourcen. </li><li>  Der Umfang der Codeabdeckung durch Tests und andere Metriken. </li><li>  Softwarefehler: Division durch Null, Null-Dereferenzierung, Speicherlecks, Rennbedingungen. </li><li>  Einige Sicherheitsl√ºcken. </li></ol><br>  Die Hauptvorteile der dynamischen Analyse: <br><br><ol><li>  Sie m√ºssen keinen Zugriff auf den Quellcode des Programms haben, um ihn zu analysieren.  Es ist jedoch zu beachten, dass dynamische Analysewerkzeuge sich durch die Art und Weise unterscheiden, in der sie mit dem zu analysierenden Programm interagieren (dies wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ausf√ºhrlicher erl√§utert).  Beispielsweise beinhaltet eine ziemlich √ºbliche dynamische Analysetechnik die Code-Instrumentierung vor der Pr√ºfung, d. H. Das Hinzuf√ºgen spezieller Codefragmente zum Quellcode der Anwendung, damit der Analysator Fehler diagnostizieren kann.  In diesem Fall ben√∂tigen Sie den Quellcode des Programms. </li><li>  Es kann komplexe Speicherbehandlungsfehler erkennen, z. B. Indizierung √ºber Arraygrenzen hinweg und Speicherlecks. </li><li>  Es kann Multithread-Code zur Ausf√ºhrungszeit analysieren und so potenzielle Probleme erkennen, die mit dem Zugriff auf gemeinsam genutzte Ressourcen oder m√∂glichen Deadlocks zu tun haben. </li><li>  Die meisten Implementierungen von dynamischen Analysatoren erzeugen keine Fehlalarme, da Fehler beim Auftreten abgefangen werden.  Daher ist eine von einem dynamischen Analysator ausgegebene Warnung keine vom Tool auf der Grundlage der Analyse des Programmmodells erstellte Vorhersage, sondern lediglich eine Aussage dar√ºber, dass ein Fehler aufgetreten ist. </li></ol><br>  Die Nachteile der dynamischen Analyse: <br><br><ol><li>  Eine vollst√§ndige Codeabdeckung ist nicht garantiert.  Das hei√üt, es ist sehr unwahrscheinlich, dass Sie durch dynamische Tests eine 100% ige Abdeckung erhalten. </li><li>  Dynamische Analysatoren k√∂nnen Logikfehler nur schlecht erkennen.  Zum Beispiel ist eine immer wahre Bedingung aus Sicht eines dynamischen Analysators kein Fehler, da eine solche falsche Pr√ºfung einfach fr√ºher beim Kompilierungsschritt verschwindet. </li><li>  Es ist schwieriger, den Fehler im Code genau zu lokalisieren. </li><li>  Die dynamische Analyse ist im Vergleich zur statischen Analyse schwieriger zu verwenden, da Sie dem Programm gen√ºgend Daten zuf√ºhren m√ºssen, um bessere Ergebnisse zu erzielen und eine m√∂glichst vollst√§ndige Codeabdeckung zu erzielen. </li></ol><br>  Die dynamische Analyse ist besonders n√ºtzlich in Bereichen, in denen Programmzuverl√§ssigkeit, Reaktionszeit oder verbrauchte Ressourcen das Hauptanliegen sind.  Ein Echtzeitsystem, das einen kritischen Produktionssektor verwaltet, oder ein Datenbankserver sind einige Beispiele f√ºr solche Systeme.  Jeder Fehler in diesen Bereichen kann kritisch sein. <br><br>  Um auf die Frage zur√ºckzukommen, warum es m√∂glicherweise nicht ausreicht, nur an einer der beiden Analysetypen festzuhalten, werfen wir einen Blick auf einige recht triviale Beispiele f√ºr Fehler, bei denen eine Analysemethode keine Probleme bei der Diagnose hat, w√§hrend die andere nicht erkannt werden kann und umgekehrt. <br><br>  Das folgende Beispiel stammt aus dem Clang-Projekt: <br><br><pre><code class="cpp hljs">MapTy PerPtrTopDown; MapTy PerPtrBottomUp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearBottomUpPointers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PerPtrTopDown.clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearTopDownPointers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PerPtrTopDown.clear(); }</code> </pre> <br>  Ein statischer Analysator w√ºrde darauf hinweisen, dass die K√∂rper der beiden Funktionen identisch sind.  Nat√ºrlich sind zwei Funktionen mit identischen K√∂rpern nicht unbedingt ein eindeutiges Zeichen f√ºr einen Fehler, aber es ist sehr wahrscheinlich, dass sie auf die Verwendung der Copy-Paste-Technik in Kombination mit Nachl√§ssigkeit auf der Seite des Programmierers zur√ºckzuf√ºhren sind - und dies f√ºhrt zu unerwartetem Verhalten.  In diesem Fall sollte die Methode <i>clearBottomUpPointers die</i> Methode <i>PerPtrBottomUp.clear</i> aufrufen.  Die dynamische Analyse w√ºrde in diesem Beispiel nichts Falsches bemerken, da es sich aus seiner Sicht um einen absolut legitimen Code handelt. <br><br>  Ein weiteres Beispiel.  Angenommen, wir haben die folgende Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OutstandingIssue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *strCount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> nCount; sscanf_s(strCount, <span class="hljs-string"><span class="hljs-string">"%u"</span></span>, &amp;nCount); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, nCount * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); }</code> </pre> <br>  Theoretisch k√∂nnte ein statischer Analysator vermuten, dass mit diesem Code etwas nicht stimmt, aber die Implementierung einer solchen Diagnose ist eine sehr schwierige und sinnlose Aufgabe.  Das Beispiel stammt aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> , in dem auch erl√§utert wird, warum es eine schlechte Idee ist, statischen Analysatoren beizubringen, wie solche Fehler diagnostiziert werden.  Kurz <i>gesagt</i> , statische Analysatoren k√∂nnen sehr schlecht herausfinden, dass ein Aufruf der <i>Memset-</i> Funktion zu einer Indizierung √ºber die Array-Grenzen hinaus f√ºhren kann, da sie nicht vorhersehen k√∂nnen, welche Nummer aus der <i>strCount-</i> Zeichenfolge gelesen wird.  und wenn der Wert von <i>strCount</i> aus einer Datei gelesen wird, wird dies zu einer unm√∂glichen Aufgabe f√ºr die statische Analyse insgesamt.  Andererseits w√ºrde ein dynamischer Analysator keine Probleme haben, den Speicherbehandlungsfehler in diesem Code zu bemerken und darauf hinzuweisen (vorausgesetzt, das Programm erh√§lt die richtigen Daten). <br><br>  Dieser Artikel zielt nicht darauf ab, statische und dynamische Analysen zu vergleichen.  Es gibt keine einzige Technik, mit der die gesamte Vielfalt von Softwarefehlern diagnostiziert werden k√∂nnte.  Keine der beiden Analysetypen kann die andere vollst√§ndig ersetzen.  Um die Qualit√§t Ihrer Programme zu verbessern, m√ºssen Sie verschiedene Arten von Tools verwenden, damit sie sich erg√§nzen.  Ich hoffe, die oben gezeigten Beispiele √ºberzeugen genug. <br><br>  Ich m√∂chte nicht zu voreingenommen gegen√ºber statischen Analysen sein, aber es ist diese Technik, von der in letzter Zeit am meisten gesprochen wird und die vor allem von Unternehmen in ihre CI-Prozesse einbezogen wird.  Die statische Analyse ist einer der Schritte der sogenannten Qualit√§tstore zum Aufbau eines zuverl√§ssigen und qualitativ hochwertigen Softwareprodukts.  Wir glauben, dass statische Analysen in ein paar Jahren zu einer Standardpraxis f√ºr die Softwareentwicklung werden werden, genau wie einst Unit-Tests. <br><br>  Abschlie√üend m√∂chte ich noch einmal darauf hinweisen, dass dynamische Analyse und statische Analyse nur zwei verschiedene Methoden sind, die sich gegenseitig erg√§nzen.  Letztendlich dienen alle diese Techniken dem einzigen Zweck, die Softwarequalit√§t zu erh√∂hen und die Entwicklungskosten zu senken. <br><br>  <b>Referenzen:</b> <br><br><ol><li>  Terminologie.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statische Code-Analyse</a> . </li><li>  Terminologie.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dynamische Code-Analyse</a> . </li><li>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statische und dynamische Code-Analyse</a> . </li><li>  Andrey Karpov.  Mythen √ºber statische Analyse.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der dritte Mythos - dynamische Analyse ist besser als statische Analyse</a> . </li><li>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio ROI</a> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461173/">https://habr.com/ru/post/de461173/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461159/index.html">Ivideon Bridge: So verbinden Sie √§ltere CCTV-Systeme mit der Cloud</a></li>
<li><a href="../de461161/index.html">Delegierter f√ºr Android-Einstellungen</a></li>
<li><a href="../de461163/index.html">Was verbindet das Geburtstagsparadoxon und die Verwundbarkeit elektronischer Signaturen?</a></li>
<li><a href="../de461165/index.html">Die Biometrie r√ºckt n√§her</a></li>
<li><a href="../de461171/index.html">Telegramm lernte, sich als HTTPS zu tarnen</a></li>
<li><a href="../de461175/index.html">27 Dinge, die ich vor Beginn der Programmierung wissen m√∂chte</a></li>
<li><a href="../de461177/index.html">Internet-Verlauf: ARPANET - Subnetz</a></li>
<li><a href="../de461179/index.html">Warum der Beweis von Fermats gro√üem Theorem nicht verbessert werden muss</a></li>
<li><a href="../de461181/index.html">Wir stellen IdM vor. Ansicht vom Implementierungsingenieur</a></li>
<li><a href="../de461185/index.html">JsonDiscovery: √Ñndern der Anzeige von JSON in einem Browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>