<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙉 🏙️ 🗼 Utilisation de modules JavaScript en production: situation actuelle. Partie 1 👶🏽 🔥 💇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a deux ans, j'ai écrit sur une technique qui est maintenant communément appelée le modèle module / nomodule. Son application vous permet d'écrire...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation de modules JavaScript en production: situation actuelle. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/466537/"> Il y a deux ans, j'ai écrit sur une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">technique</a> qui est maintenant communément appelée le modèle module / nomodule.  Son application vous permet d'écrire du code JavaScript en utilisant les capacités d'ES2015 +, puis d'utiliser des bundlers et des transpilers pour créer deux versions de la base de code.  L'un d'eux contient une syntaxe moderne (il est chargé à l'aide d'une structure comme <code>&lt;script type="module"&gt;</code> , et le second est la syntaxe ES5 (il est chargé à l'aide de <code>&lt;script nomodule&gt;</code> ). Le modèle module / nomodule permet d'envoyer aux navigateurs qui prennent en charge les modules, beaucoup moins de code que les navigateurs qui ne prennent pas en charge cette fonctionnalité, ce modèle est désormais pris en charge par la plupart des frameworks Web et des outils de ligne de commande. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/sd/_p/je/sd_pjea-digdrv7bbr_b3n4wdtq.jpeg"></a> <br><br>  Auparavant, même en considérant la possibilité d'envoyer du code JavaScript moderne en production, et même si la plupart des navigateurs prenaient en charge les modules, je recommandais de collecter le code en bundles. <br><a name="habracut"></a><br>  Pourquoi?  Surtout parce que j'avais l'impression que le chargement des modules dans le navigateur était lent.  Même si les protocoles récents, tels que HTTP / 2, prenaient théoriquement en charge le chargement efficace de plusieurs fichiers, toutes les études de performances de l'époque ont conclu que l'utilisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bundlers</a> est toujours plus efficace que l'utilisation de modules. <br><br>  Mais il faut admettre que ces études étaient incomplètes.  Les cas de test utilisant les modules qui y étaient étudiés consistaient en des fichiers de code source non optimisés et non minimisés qui étaient déployés en production.  Il n'y avait aucune comparaison du bundle optimisé avec des modules avec le script classique optimisé. <br><br>  Cependant, pour être honnête, il n'existait aucun moyen optimal de déployer les modules à ce moment-là.  Mais maintenant, grâce à certaines améliorations modernes des technologies de bundler, il est possible de déployer du code de production sous la forme de modules ES2015 en utilisant à la fois des commandes d'importation statiques et dynamiques, et en même temps de recevoir des performances supérieures à celles qui peuvent être obtenues en utilisant les options disponibles, dans lesquelles les modules ne sont pas utilisés. <br><br>  Il est à noter que sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site</a> sur lequel le matériel original est publié, dont la première partie de la traduction est publiée aujourd'hui, les modules sont utilisés en production depuis plusieurs mois. <br><br><h2>  <font color="#3AC1EF">Idées fausses sur les modules</font> </h2><br>  Beaucoup de gens avec qui j'ai parlé rejettent complètement les modules, ne les considérant même pas comme l'une des options pour les applications de production à grande échelle.  Beaucoup d'entre eux citent l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">étude même</a> que j'ai déjà mentionnée.  À savoir, cette partie de celui-ci, qui stipule que les modules ne doivent pas être utilisés en production, sauf s'il s'agit de «petites applications Web qui comprennent moins de 100 modules qui diffèrent dans un arbre de dépendance relativement« petit »(c'est-à-dire - un dont la profondeur ne dépasse pas 5 niveaux). » <br><br>  Si vous avez déjà consulté le répertoire <code>node_modules</code> de l'un de vos projets, vous savez probablement que même une petite application peut facilement avoir plus de 100 modules de dépendance.  Je veux vous offrir un aperçu du nombre de modules disponibles dans certains des packages npm les plus populaires. <br><div class="scrollable-table"><table><tbody><tr><td>  Paquet <br></td><td>  Nombre de modules <br></td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">date-fns</a> <br></td><td>  729 <br></td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lodash-es</a> <br></td><td>  643 <br></td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rxjs</a> <br></td><td>  226 <br></td></tr></tbody></table></div><br>  C'est là que la principale idée fausse concernant les modules est enracinée.  Les programmeurs pensent que lorsqu'il s'agit d'utiliser des modules en production, ils n'ont que deux options.  La première consiste à déployer tout le code source dans sa forme existante (y compris le répertoire <code>node_modules</code> ).  La seconde est de ne pas utiliser du tout de modules. <br><br>  Cependant, si vous regardez attentivement les recommandations de l'étude citée ci-dessus, vous constaterez qu'il n'y a rien à dire que le chargement des modules est plus lent que le chargement des scripts réguliers.  Il ne dit pas que les modules ne devraient pas être utilisés du tout.  Il évoque simplement le fait que si quelqu'un déploie des centaines de fichiers de module non infectés en production, Chrome ne pourra pas les charger aussi rapidement qu'un seul ensemble réduit.  En conséquence, l'étude conseille de continuer à utiliser des bundlers, des compilateurs et des minificateurs. <br><br>  Mais tu sais quoi?  Le fait est que vous pouvez utiliser tout cela et utiliser des modules en production. <br><br>  En fait, les modules sont un format dans lequel nous devons nous efforcer de convertir le code, car les navigateurs savent déjà comment charger les modules (et les navigateurs qui ne peuvent pas le faire peuvent charger une solution de secours en utilisant le mécanisme du nomodule).  Si vous regardez le code généré par les bundlers les plus populaires, vous trouverez de nombreux fragments de modèle dont le but est uniquement de charger dynamiquement d'autres codes et de gérer les dépendances.  Mais tout cela ne sera pas nécessaire si nous utilisons simplement les modules et les expressions d' <code>import</code> et d' <code>export</code> . <br><br>  Heureusement, au moins l'un des bundlers modernes populaires ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rollup</a> ) prend en charge les modules sous forme de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">données</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sortie</a> .  Cela signifie que vous pouvez traiter le code avec un bundler et déployer des modules dans la production (sans utiliser de fragments de modèle pour charger le code).  Et, comme Rollup a une excellente implémentation de l'algorithme de tremblement d'arbre (le meilleur que j'ai vu dans les bundlers), la création de programmes sous forme de modules à l'aide de Rollup vous permet d'obtenir un code plus petit que la taille du même code obtenu lors de l'application. d'autres mécanismes disponibles aujourd'hui. <br><br>  Il convient de noter qu'ils <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prévoient d'</a> ajouter la prise en charge des modules dans la prochaine version de Parcel.  Webpack ne prend pas encore en charge les modules en tant que format de sortie, mais le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici</a> - des discussions qui se concentrent sur ce problème. <br><br>  Une autre idée fausse concernant les modules est que certaines personnes pensent que les modules ne peuvent être utilisés que si 100% des dépendances du projet utilisent des modules.  Malheureusement (je pense que c'est un grand regret), la plupart des packages npm sont toujours en cours de préparation pour publication au format CommonJS (certains modules, même ceux écrits à l'aide des fonctionnalités ES2015, sont traduits au format CommonJS avant d'être publiés au npm)! <br><br>  Ici, encore une fois, je tiens à noter que Rollup a un plugin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rollup-plugin-commonjs</a> ) qui prend le code source d'entrée écrit à l'aide de CommonJS et le convertit en code ES2015.  Certainement, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il</a> serait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">préférable</a> que le format de dépendance utilisé dès le début utilise le format de module ES2015.  Mais si certaines dépendances ne le sont pas, cela ne vous empêche pas de déployer des projets à l'aide de modules en production. <br><br>  Dans les parties suivantes de cet article, je vais vous montrer comment je collecte des projets dans des bundles qui utilisent des modules (y compris l'utilisation d'importations dynamiques et de séparation de code), je vais vous expliquer pourquoi ces solutions sont généralement plus productives que les scripts classiques, et montrer comment elles fonctionnent avec des navigateurs qui ne prennent pas en charge les modules. <br><br><h2>  <font color="#3AC1EF">Stratégie de création de code optimale</font> </h2><br>  Le code du bâtiment pour la production est toujours une tentative d'équilibrer les avantages et les inconvénients de diverses solutions.  D'une part, le développeur souhaite que son code se charge et s'exécute le plus rapidement possible.  En revanche, il ne souhaite pas télécharger de code qui ne sera pas utilisé par les utilisateurs du projet. <br><br>  De plus, les développeurs ont besoin de savoir que leur code est le mieux adapté à la mise en cache.  Le gros problème du regroupement de code est que tout changement dans le code, même une ligne modifiée, entraîne l'invalidation du cache de l'ensemble du paquet.  Si vous déployez une application composée de milliers de petits modules (présentés exactement sous la forme dans laquelle ils sont présents dans le code source), vous pouvez en toute sécurité apporter des modifications mineures au code et en même temps savoir que la plupart du code d'application sera mis en cache .  Mais, comme je l'ai déjà dit, une telle approche du développement peut probablement signifier que le chargement du code la première fois que vous visitez une ressource peut prendre plus de temps que l'utilisation d'approches plus traditionnelles. <br><br>  En conséquence, nous sommes confrontés à une tâche difficile, qui est de trouver la bonne approche pour diviser les faisceaux en plusieurs parties.  Nous devons trouver le bon équilibre entre la vitesse de chargement des matériaux et leur mise en cache à long terme. <br><br>  La plupart des bundlers utilisent par défaut des techniques de fractionnement de code basées sur des commandes d'importation dynamique.  Mais je dirais que diviser le code uniquement en mettant l'accent sur l'importation dynamique ne permet pas de le diviser en fragments suffisamment petits.  Cela est particulièrement vrai pour les sites avec de nombreux utilisateurs de retour (c'est-à-dire dans les situations où la mise en cache est importante). <br><br>  Je pense que le code doit être divisé en fragments aussi petits que possible.  Il vaut la peine de réduire la taille des fragments jusqu'à ce que leur nombre augmente tellement que cela affectera la vitesse de téléchargement du projet.  Et bien que je recommande définitivement à chacun de faire sa propre analyse de la situation, si vous croyez aux calculs approximatifs effectués dans l'étude que j'ai mentionnée, lors du chargement de moins de 100 modules, il n'y a pas de ralentissement notable du chargement.  Une étude distincte sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://medium.com/%40asyncmax/the-right-way-to-bundle-your-assets-for-faster-sites-over-">les performances HTTP / 2</a> n'a pas révélé de ralentissement notable du projet lors du téléchargement de moins de 50 fichiers.  Là, cependant, ils n'ont testé que des options dans lesquelles le nombre de fichiers était de 1, 6, 50 et 1000. En conséquence, probablement 100 fichiers sont une valeur à laquelle vous pouvez facilement naviguer sans craindre de perdre en vitesse de téléchargement. <br><br>  Alors, quelle est la meilleure façon de diviser le code de manière agressive, mais pas trop agressive?  En plus de diviser le code en fonction des commandes d'importation dynamique, je vous conseille de regarder de plus près le fractionnement du code en packages npm.  Avec cette approche, ce qui est importé dans le projet à partir du dossier <code>node_modules</code> tombe dans un fragment séparé du code fini basé sur le nom du package. <br><br><h2>  <font color="#3AC1EF">Séparation des colis</font> </h2><br>  J'ai dit ci-dessus que certaines des capacités modernes des bundlers permettent d'organiser un schéma haute performance pour le déploiement de projets basés sur des modules.  Ce dont je parlais est représenté par deux nouvelles fonctionnalités de cumul.  Le premier est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la séparation automatique du code</a> via <code>import()</code> commandes d' <code>import()</code> dynamique <code>import()</code> (ajoutées <a href="">dans la v1.0.0</a> ).  La deuxième option est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la séparation manuelle du code</a> effectuée par le programme sur la <code>manualChunks</code> option <code>manualChunks</code> (ajoutée dans la <a href="">v1.11.0</a> ). <br><br>  Grâce à ces deux fonctionnalités, il est désormais très facile de configurer le processus de construction, dans lequel le code est divisé au niveau du package. <br><br>  Voici un exemple de configuration qui utilise l'option <code>manualChunks</code> , grâce à laquelle chaque module importé de <code>node_modules</code> tombe dans un fragment de code distinct dont le nom correspond au nom du package (techniquement, le nom du répertoire du package dans le dossier <code>node_modules</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {  <span class="hljs-attr"><span class="hljs-attr">input</span></span>: {    <span class="hljs-attr"><span class="hljs-attr">main</span></span>: <span class="hljs-string"><span class="hljs-string">'src/main.mjs'</span></span>,  },  <span class="hljs-attr"><span class="hljs-attr">output</span></span>: {    <span class="hljs-attr"><span class="hljs-attr">dir</span></span>: <span class="hljs-string"><span class="hljs-string">'build'</span></span>,    <span class="hljs-attr"><span class="hljs-attr">format</span></span>: <span class="hljs-string"><span class="hljs-string">'esm'</span></span>,    <span class="hljs-attr"><span class="hljs-attr">entryFileNames</span></span>: <span class="hljs-string"><span class="hljs-string">'[name].[hash].mjs'</span></span>,  },  manualChunks(id) {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id.includes(<span class="hljs-string"><span class="hljs-string">'node_modules'</span></span>)) {      <span class="hljs-comment"><span class="hljs-comment">//   ,    `node_modules`.      //   - ,       .      const dirs = id.split(path.sep);      return dirs[dirs.lastIndexOf('node_modules') + 1];    }  }, }</span></span></code> </pre> <br>  L'option <code>manualChunk</code> accepte une fonction qui accepte, comme argument unique, le chemin d'accès au fichier de module.  Cette fonction peut renvoyer un nom de chaîne.  Ce qu'il renvoie pointera vers un fragment de l'assembly auquel le module actuel doit être ajouté.  Si la fonction ne renvoie rien, le module sera ajouté au fragment par défaut. <br><br>  Considérons une application qui importe les <code>cloneDeep()</code> , <code>debounce()</code> et <code>find()</code> du <code>lodash-es</code> .  Si vous appliquez la configuration ci-dessus lors de la création de cette application, chacun de ces modules (ainsi que chaque module <code>lodash</code> importé par ces modules) sera placé dans un seul fichier de sortie avec un nom comme <code>npm.lodash-es.XXXX.mjs</code> (ici <code>XXXX</code> est unique hachage du fichier module dans le fragment <code>lodash-es</code> ). <br><br>  À la fin du fichier, vous verrez une expression d'exportation comme celle-ci.  Veuillez noter que cette expression ne contient que des commandes d'exportation pour les modules ajoutés au fragment, et pas tous les modules <code>lodash</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> {cloneDeep, debounce, find};</code> </pre> <br>  Ensuite, si le code de l'un des autres fragments utilise ces modules <code>lodash</code> (peut-être uniquement la méthode <code>debounce()</code> ), dans ces fragments, dans leur partie supérieure, il y aura une expression d'importation qui ressemble à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {debounce} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./npm.lodash.XXXX.mjs'</span></span>;</code> </pre> <br>  Espérons que cet exemple clarifie la question du fonctionnement de la séparation manuelle du code dans le correctif cumulatif.  De plus, je pense que les résultats de la séparation de code utilisant les expressions d' <code>import</code> et d' <code>export</code> sont beaucoup plus faciles à lire et à comprendre que le code de fragments, dont la formation a utilisé des mécanismes non standard qui ne sont utilisés que dans un certain bundler. <br><br>  Par exemple, il est très difficile de comprendre ce qui se passe dans le fichier suivant.  Ceci est la sortie d'un de mes anciens projets qui utilisait webpack pour diviser le code.  Presque tout dans ce code n'est pas nécessaire dans les navigateurs qui prennent en charge les modules. <br><br><pre> <code class="javascript hljs">(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">"webpackJsonp"</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">"webpackJsonp"</span></span>] || []).push([[<span class="hljs-string"><span class="hljs-string">"import1"</span></span>],{ <span class="hljs-comment"><span class="hljs-comment">/***/</span></span> <span class="hljs-string"><span class="hljs-string">"tLzr"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*!*********************************!*\  !*** ./app/scripts/import-1.js ***!  \*********************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*! exports provided: import1 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/***/</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, __webpack_exports__, __webpack_require__</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; __webpack_require__.r(__webpack_exports__); <span class="hljs-comment"><span class="hljs-comment">/* harmony export (binding) */</span></span> __webpack_require__.d(__webpack_exports__, <span class="hljs-string"><span class="hljs-string">"import1"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> import1; }); <span class="hljs-comment"><span class="hljs-comment">/* harmony import */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _dep_1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="hljs-comment"><span class="hljs-comment">/*! ./dep-1 */</span></span> <span class="hljs-string"><span class="hljs-string">"6xPP"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> import1 = <span class="hljs-string"><span class="hljs-string">"imported: "</span></span> + _dep_1__WEBPACK_IMPORTED_MODULE_0__[<span class="hljs-string"><span class="hljs-string">"dep1"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/***/</span></span> }) }]);</code> </pre> <br><h2>  <font color="#3AC1EF">Et s'il y a des centaines de dépendances npm?</font> </h2><br>  Comme je l'ai dit, je crois que la séparation au niveau du code au niveau du package permet généralement au développeur de se placer dans une bonne position lorsque la séparation du code est agressive, mais pas trop agressive. <br><br>  Bien sûr, si votre application importe des modules à partir de centaines de packages npm différents, vous pouvez toujours être dans une situation où le navigateur ne peut pas tous les charger efficacement. <br><br>  Cependant, si vous avez vraiment de nombreuses dépendances npm, vous ne devez pas abandonner complètement cette stratégie pour l'instant.  N'oubliez pas que vous ne téléchargerez probablement pas toutes les dépendances npm sur chaque page.  Par conséquent, il est important de savoir combien de dépendances se chargent réellement. <br><br>  Néanmoins, je suis sûr qu'il existe de vraies applications qui ont tellement de dépendances npm que ces dépendances ne peuvent tout simplement pas être représentées comme des fragments séparés.  Si votre projet est juste cela - je vous recommande de chercher un moyen de regrouper les packages où le code dans lequel avec une forte probabilité peut changer en même temps (comme <code>react</code> et <code>react-dom</code> ) car l' <code>react-dom</code> cache de fragments avec ces packages sera également exécutée en même temps.  Plus tard, je montrerai un exemple dans lequel toutes les dépendances de React sont regroupées dans le même <a href="">fragment</a> . <br><br>  À suivre ... <br><br>  <b>Chers lecteurs!</b>  Comment abordez-vous le problème de la séparation du code dans vos projets? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466537/">https://habr.com/ru/post/fr466537/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466521/index.html">C for Metal - métal précieux pour l'informatique sur les cartes graphiques Intel</a></li>
<li><a href="../fr466525/index.html">Qu'est-ce qu'une disposition iPhone PSD et comment l'utiliser?</a></li>
<li><a href="../fr466527/index.html">Test de la fonctionnalité utilisateur du site Web avec les objets de page Capybara</a></li>
<li><a href="../fr466529/index.html">Types de compilation dans la JVM: exposer la session Black Magic</a></li>
<li><a href="../fr466535/index.html">Repenser deepClone</a></li>
<li><a href="../fr466539/index.html">Utilisation de modules JavaScript en production: situation actuelle. 2e partie</a></li>
<li><a href="../fr466541/index.html">Utilisation de DbTool pour amorcer des bases de données dans des applications .NET (Core)</a></li>
<li><a href="../fr466543/index.html">Les prêts Habr Weekly # 17 / Sberbank seront approuvés par AI - effrayant, publicité dans les produits open source - douteux</a></li>
<li><a href="../fr466547/index.html">Bonne fête du programmeur</a></li>
<li><a href="../fr466549/index.html">Principes généraux de fonctionnement de QEMU-KVM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>