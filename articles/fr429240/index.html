<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🚀 ㊗️ ♨️ Comment j'ai essayé de corriger une recherche de carte pour les pilotes 😫 👲🏿 🎌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C'est une histoire sur la façon dont j'ai essayé de résoudre un problème étrange qui m'a empêché moi-même. À plus long terme, je dirai que je suis sat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment j'ai essayé de corriger une recherche de carte pour les pilotes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429240/">  C'est une histoire sur la façon dont j'ai essayé de résoudre un problème étrange qui m'a empêché moi-même.  À plus long terme, je dirai que je suis satisfait de la solution qui en résulte et que l’application a atteint sa fin logique.  Cependant, pour l'exécuter pleinement, vous avez besoin de plus de ressources, j'ai donc décidé de faire une pause et de demander aux gens si quelqu'un d'autre en avait besoin.  A cet effet (et aussi juste pour parler) j'écris ici. <br><a name="habracut"></a><br>  Deux mots sur moi: je vis à Dublin, en Irlande, je travaille comme programmeur.  Il ne se trouve pas exactement sur place, c'est pourquoi pendant mon temps libre à la maison, j'ai vu divers projets, principalement sur la table.  J'écris sur Habré pour la première fois, même si je lis depuis de nombreuses années. <br><br><h3>  Le problème </h3><br>  Il y a très longtemps, alors que je devais beaucoup voyager dans des endroits inconnus pour le travail, j'ai commencé à remarquer que la recherche standard sur toutes les cartes n'est absolument pas applicable aux conducteurs aujourd'hui.  Regardez: vous conduisez dans une zone inconnue et vous avez une flèche d'essence à zéro.  Vos actions?  Si à ce moment je ne suis pas seul dans la voiture, alors je dis au passager: "Eh bien, cherchez une station-service à proximité pendant que je conduis."  Parce que si vous le faites vous-même, vous devez effectuer les actions suivantes: <br><br><ol><li>  Arrêter </li><li>  Dans l'application cartographique, entrez «essence» dans la recherche (ou cliquez sur l'un des boutons rapides que certaines cartes proposent maintenant) </li><li>  L'application effectue une recherche et vous montre une immense carte avec une douzaine de stations-service </li><li>  Vous essayez de déterminer lequel est le plus proche de vous et cliquez dessus pour construire un itinéraire </li></ol><br>  À mon avis, un cauchemar.  Tout d'abord, vous devez arrêter ou au moins attendre un feu de circulation.  Parce que les cartes sont complexes et les icônes sont petites.  Deuxièmement, la carte nifig ne vous dit pas quelle est la station-service la plus proche.  À cet égard, Google est le pire de tous: même dans les résultats sous forme de liste, il pousse constamment vers le haut, pas l'endroit le plus proche, et le plus noté / avec photos / payé / je n'en ai aucune idée. <br><br><img src="https://habrastorage.org/webt/nc/kj/mu/nckjmuxsfajkjffvk8bx0ksjtse.png" width="300"><br><br>  Eh bien, le troisième facteur: nous bougeons.  Le résultat que les cartes délivrées étaient pertinentes à un moment donné, mais nous en sommes déjà loin.  Avez-vous remarqué que même l'itinéraire tracé par Google n'est pas mis à jour automatiquement si nous avons changé?  Ce n'est que si la navigation a déjà été lancée qu'elle sera reconstruite. <br><br>  En général, le problème est clair.  Une logique qui fonctionne pour les piétons et leurs besoins, pour les conducteurs, ce n'est rien.  Je ne me soucie pas de la cote de l'endroit et du type de cuisine - j'ai besoin, sans être distrait de la route, d'obtenir en temps réel un itinéraire vers la station-service la plus proche, la recharge, le parking, le guichet automatique, etc. <br><br><h3>  Idée </h3><br>  Essayons maintenant de déterminer le scénario de recherche idéal.  Le critère est le suivant: <br><br><ul><li>  l'interaction est courte et claire pour ne pas distraire le conducteur </li><li>  sortie transparente basée sur la distance </li><li>  mise à jour en temps réel </li></ul><br>  La première chose qui le prie est de remplacer la recherche unique standard par une analyse.  Autrement dit, la chaîne d'actions est quelque chose comme ceci: <br><br><ol><li>  Lancement d'une analyse </li><li>  Rouler, regarder les résultats mis à jour en temps réel </li><li>  Quand j'ai aimé quelque chose, j'ai cliqué et tracé la route </li></ol><br>  Vous déterminez les critères de recherche à l'avance - en fait, c'est le type de lieu et le rayon du scan.  De plus, pendant que la voiture se déplace, l'application fonctionne comme un radar.  Assez rapidement, il est devenu clair que, premièrement, le rayon n'est pas rond, mais sous la forme d'une isoline.  Deuxièmement, elle doit être construite non pas par la distance, mais par le temps, car les minutes sont beaucoup plus faciles à percevoir que les kilomètres. <br><br>  Ensuite, j'ai pensé à un moyen de produire les résultats.  Plus précisément, ai-je besoin d'une carte?  Le conducteur regarde l'application d'un œil et interagit avec un doigt - il n'a pas besoin d'une carte, mais d'un gros texte et de gros boutons.  Par conséquent, j'ai immédiatement décidé que l'écran principal serait une liste, et je pourrais d'abord ajouter une carte, puis voir si je devais la quitter. <br><br><h3>  Plan </h3><br>  Connaissant ma propre particularité des projets d'étirement, j'ai décidé de me donner 2 mois pour tout - au final je me suis rencontré en 3. En principe, l'application est assez simple: <br><br><ol><li>  Client à partir d'une paire d'écrans (recherche, liste et carte) </li><li>  Envoie périodiquement au serveur ses coordonnées, son rayon de recherche et le type de lieux </li><li>  Le serveur construit une isoligne dans le temps (au fait, il a son nom en anglais - isochrone), fait une recherche par endroits et retourne une liste </li></ol><br>  Cela ressemble à un poumon plus léger.  J'avais déjà une certaine expérience en cartographie (il y a quelques années, j'ai fait un portail immobilier où la recherche était sur la carte), donc la pile sur le backend était immédiatement claire: <br><br><ul><li>  importer des données d'OpenStreetMaps dans Elasticsearch </li><li>  OpenTripPlanner pour créer des contours </li></ul><br>  Sur le client, j'ai pensé, décidé d'utiliser le nouveau framework de Google - Flutter.  Il est multiplateforme, assez flexible et vous permet de créer des applications à part entière avec un minimum de code.  Bien sûr, c'est brut et ce n'est pas clair ce qui est en production, mais ça a l'air parfait pour le prototypage.  Il convient de préciser qu'à ce stade, j'avais une expérience dans le développement natif pour Android (j'étais chef d'équipe) et j'ai décidé, pour ainsi dire, d'affronter l'ennemi.  L'ennemi n'était pas si effrayant. <br><br><h3>  Implémentation </h3><br>  Le premier prototype d'application a été prêt très rapidement - Flutter a un seuil d'entrée bas et une philosophie de type redux compréhensible.  Curieusement, la description déclarative des interfaces était également agréable, ainsi que le redémarrage à chaud (React Native, votre bitmap).  En général, l'impression était que Google était responsable de la plupart des maladies congénitales des tentatives précédentes.  Cependant, je comprends les gens qui peuvent ne pas vouloir s'y lancer - quelqu'un n'aime pas les fléchettes, un nombre limité de widgets et le «débogage visuel» proposé ici est quelque chose de très brut. <br><br>  Sur le backend, j'ai fait ce qui suit: <br><br><ol><li>  Livré Nominatim, téléchargé l'extrait de données OpenStreetMaps (pris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ) dans sa base de données en utilisant son utilitaire natif osm2pgsql.  Pourquoi me suis-je tourné vers le petit mais très agréable géocodeur aigre ouvert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Photon</a> .  Plus tôt, je l'ai déjà utilisé dans quelques projets - il génère un index Elasticsearch, y importe des données de la base de données Nominatim et recherche cet index.  Je l'aime avec la vitesse et la cartographie pure (par exemple, j'ai essayé Pelias et je l'aimais moins).  Son principal problème est l'ancienne version de l'élastique, mais dans mon cas, je n'avais pas besoin de la fonctionnalité du géocodeur lui-même, seulement des données, donc après l'importation, j'ai transféré l'index à l'installation de l'élastique de la dernière version avec une âme pure.  Au fait, pourquoi ai-je choisi Elasticsearch?  Il est très rapide et a pour fonction de trouver des coordonnées par polygone. </li><li>  La décharge - alias isochrone - a initialement généré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenTripPlanner</a> pour moi.  Il s'agit d'un très bon planificateur d'itinéraire open source.  Il fonctionne comme suit: il prend le même extrait OpenStreetMaps et le compile dans un grand graphique de route, qui, en tant qu'objet séparé, est enregistré sur le disque.  Lorsque le serveur démarre, ce graphique est chargé dans la RAM et toutes les routes y sont recherchées.  Avantages: prise en main rapide, fonctionnalités riches (par exemple, génère des contours à partir de la boîte) et bonne vitesse.  Inconvénients: cette vitesse dépend de la quantité de RAM et la documentation est extrêmement dégoûtante.  Documentation juste monstrueuse.  Flashbacks vietnamiens. </li><li>  J'ai jeté une petite API sur le python, qui prend le type de lieu et le rayon de recherche en quelques secondes, demande un polygone à OpenTripPlanner, puis le recherche dans Elasticsearch.  Il demande un itinéraire vers chaque emplacement trouvé (à nouveau depuis OpenTripPlanner), prend sa longueur et son temps.  Après cela, toutes les données collectées sont magnifiquement emballées et retournées. </li></ol><br>  J'ai fait la mise à jour des résultats en décalant les coordonnées de l'appareil de 5 mètres.  La carte est statique - je viens d'utiliser une api de cartes Google statiques (comme vous pouvez le voir, c'est le seul endroit où la société a quand même rampé dans notre monde confortable et ouvert).  La première implémentation ressemblait à ceci: <br><br><img src="https://habrastorage.org/webt/uu/re/ti/uuretiwzesv31fig6voucz43jx0.png" width="300"><br><br><img src="https://habrastorage.org/webt/_u/6y/ll/_u6yllx-mdeso0qlfdeaho65epg.png" width="300"><br><br><img src="https://habrastorage.org/webt/qt/le/ho/qtlehoo18mjchlj4eiybao_aei0.png" width="300">  ￼￼￼ <br><br>  Après avoir joué avec l'application, j'ai décidé de masquer la carte.  Elle a bien compris pour quel polygone la recherche avait été effectuée et elle avait l'air amusante - c'était intéressant de voir comment cette pieuvre change de forme en temps réel.  Cependant, ce divertissement n'a pas aidé l'application à remplir ses fonctions et occupait un tiers de l'écran. <br><br>  Il m'est également venu à l'esprit d'ajouter une flèche, qui indiquait la direction de chaque résultat.  Cela a fonctionné comme ceci: <br><br><ol><li>  Rappelez-vous vos coordonnées précédentes </li><li>  Lors du déplacement, nous établissons l'itinéraire de la position précédente à la position actuelle </li><li>  Nous prenons le dernier segment de notre itinéraire et comparons avec le premier segment de l'itinéraire chaque résultat.  Puisqu'ils sont posés le long du même réseau routier, avec une probabilité de 99%, l'angle entre eux est proche de 0 ou 180. </li></ol><br>  Cette astuce très simple facilite grandement la compréhension de savoir si nous nous dirigeons déjà vers l'endroit ou s'il faudra faire demi-tour. <br><br><img src="https://habrastorage.org/webt/rb/mp/h5/rbmph5eycajawl1s5b83eamgtwy.gif" width="300"><br>  ￼ <br>  À ce stade, j'étais très satisfait de l'application résultante et j'ai décidé d'essayer de la déployer dans plusieurs pays.  Pourtant, l'Irlande est un très petit État, respectivement, et l'indice élastique et le graphique routier étaient petits.  Pour les tests, j'ai décidé de connecter le Royaume-Uni voisin.  Il est environ 4 fois plus grand et possède un réseau routier beaucoup plus dense (en particulier la capitale et les grandes villes).  Et puis un problème est survenu. <br><br>  Elasticsearch aurait très bien digéré l'augmentation de l'indice, mais avec OpenTripPlanner, il y a eu un échec complet.  Il est écrit en Java et, comme je l'ai dit ci-dessus, génère un graphique des routes, de sorte qu'après le chargement dans la RAM.  Le graphique pour l'Irlande était de 1 gigaoctet, pour le Royaume-Uni, il en était déjà 5. Il était bien sûr possible de le diviser en pays, régions et même régions, puis de rediriger vers le graphique souhaité en fonction des coordonnées de l'utilisateur.  Cependant, cela n'a pas permis de tracer des routes entre les régions et, surtout, cela n'a pas résolu le besoin de conserver tous ces graphiques en mémoire.  Enfin, la simple compilation de chacun de ces objets a pris TRÈS de ressources et a duré une éternité.  Pour le plaisir, j'ai lancé sur ma machine (cadres 16 Go) l'assemblage du Comte de France, attendu une journée et annulé. <br><br>  Évidemment, une technologie qui a fait ses preuves dans les petites tâches n'est pas du tout conçue pour évoluer (du moins pas avec mes ressources).  Il doit donc soit admettre la défaite, soit ramper vers une autre technologie.  J'ai pris une pause de quelques jours et j'ai commencé à étudier quelles autres solutions open source existent dans le monde.  Il s'est avéré qu'il y en a essentiellement deux: <br><br><ul><li>  OpenTripPlanner </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Projet OSRM</a> </li></ul><br>  Si le premier est écrit en Java et charge le graphe routier dans la RAM, alors OSRM - Open Source Routing Machine - est déjà écrit en plus et conserve ses fichiers intermédiaires (non moins monstrueux) sur le disque.  Ainsi, la nécessité d'avoir une énorme quantité de RAM a été remplacée par l'exigence d'un disque grand et rapide.  C'est plus réel. <br><br><h3>  Ligne d'arrivée </h3><br>  Après quelques nuits de sélection dans la documentation, tout le code du serveur a été transféré vers une nouvelle solution.  Cela a vraiment fonctionné et a plutôt bien fonctionné.  Il a été possible de connecter plusieurs pays, et même la vitesse de recherche a augmenté.  Les principes généraux étaient les mêmes: à partir de l'extrait OpenStreetMaps, des fichiers intermédiaires ont été compilés pour le profil «machine» (un profil est un ensemble de poids et d'instructions pour les bords d'un graphique - il y a des profils «à pied», «vélo», etc.).  Ensuite, ces fichiers ont été placés dans un répertoire, et l'API OSRM les a déjà lus à partir du disque.  Api, soit dit en passant, s'est avéré être assez grand - les contours et la planification de l'itinéraire avec diverses nuances étaient pris en charge, il y avait même une génération de tuiles pour la carte.  J'ai décidé de m'attarder sur ce dernier plus en détail. <br><br>  En revenant à l'application et en continuant à la tester, j'ai réalisé quelques autres choses: <br><br><ul><li>  le menu en haut n'est pas bon, va bien loin </li><li>  la carte générale n'est certainement pas nécessaire, elle ne me lie qu'à google </li><li>  les cartes de résultat sont ennuyeuses et monotones </li></ul><br>  Il a heureusement jeté une carte Google (hourra, désormais 100% open source et ses données), simplifié le menu, baissé.  J'ai commencé à penser quoi faire avec les cartes.  Et puis les tuiles api sont apparues très opportunément, ce que j'ai mentionné ci-dessus.  Il vous permet de générer une vignette vectorielle pour les coordonnées et le niveau de zoom donnés.  Le résultat est émis sous la forme d'un blob binaire de type application / x-protobuf - un type de données assez peu pratique pour la manipulation.  Je n'entrerai pas dans les détails (j'ai dû transpirer un peu), mais en un mot mes actions ressemblaient à ceci: <br><br><ol><li>  Prendre la ligne de l'itinéraire construit jusqu'au point sous forme de polyligne </li><li>  Polyligne -&gt; GeoJSON </li><li>  Obtenez la boîte englobante de cette forme </li><li>  Demander toutes les tuiles capturées par cette boîte englobante </li><li>  Convertir les données de tuiles du format binaire en GeoJSON </li><li>  Coller les carreaux, couper par la boîte englobante, combiner avec la ligne de route, coloriser </li><li>  Le GeoJSON résultant est converti en bitmap </li></ol><br>  Au cours de l'action, il y avait différentes nuances, par exemple, indenter le cadre de sélection ou marquer des points avec des anneaux colorés (et rendre leur rayon constant pour tous les niveaux de zoom).  L'image résultante ressemblait à ceci: <br>  ￼ <br><img src="https://habrastorage.org/webt/r2/za/2u/r2za2us1ntmhvdfshs4hsnu2rj8.png" width="300"><br><br><h3>  Touche finale </h3><br>  Lorsque j'ai attaché un itinéraire visuel à chaque résultat, la liste a commencé à briller de nouvelles couleurs.  De plus, réalisant que chaque image, par défaut, chevauche le nord, je les ai fait tourner par rapport à la boussole.  Ainsi, en plus de l'effet visuel, cette puce est également devenue fonctionnelle - remplaçant la flèche de direction.  Maintenant que vous conduisez, vous pouvez voir avec certitude de quel côté de vous tel ou tel résultat est. <br><br>  Le troisième mois de développement a expiré et il fallait déjà terminer.  Plus vous en ajoutez, plus vous en voulez, donc à un moment donné, il vous suffit de vous ressaisir et de lâcher le projet.  J'ai peaufiné et peint un peu plus l'interface, et pour un sentiment d'achèvement, j'ai esquissé le logo de l'application: <br><br>  ￼ <img src="https://habrastorage.org/webt/kt/pv/hq/ktpvhqnibjmjewucwszvopdmgoe.png" width="150"><br><br>  et page d'introduction: <br><br>  ￼ <img src="https://habrastorage.org/webt/rq/no/l1/rqnol1usdtcguhyktktrowbdbdk.png" width="300"><br><br>  Et enfin, la version finale de l'application: <br><br>  ￼￼￼￼ <img src="https://habrastorage.org/webt/ue/4p/og/ue4pogbsgbzaqbinhj3mjmronha.png" width="300"><br><br><img src="https://habrastorage.org/webt/wo/34/sw/wo34swgdxsfk6tk6uw1njgwg90a.png" width="300"><br><br><img src="https://habrastorage.org/webt/17/5p/xr/175pxr7hgipc6dpylbejnxv5hb0.png" width="300"><br><br><img src="https://habrastorage.org/webt/6r/e1/xr/6re1xrvrtcmp2udr4lyc4iqai5u.png" width="300"><br><br><h3>  Résumé </h3><br>  Eh bien, merci d'avoir regardé.  J'espère que ce courant de conscience sera intéressant pour quelqu'un, et peut-être même utile.  A ce stade, je pense que l'application est prête: elle est rapide, sans bugs particuliers et peut fonctionner dans n'importe quel pays du monde.  À propos, vous avez peut-être remarqué que les captures d'écran provenaient à la fois de l'iPhone et d'Android, car grâce à Flutter, l'application fonctionne exactement de la même manière sur les deux plates-formes. <br><br>  Néanmoins, jusqu'à présent, j'ai décidé de tout geler - j'ai changé d'emploi, de nouvelles inquiétudes sont apparues.  Après quelques mois, j'ai dépoussiéré la poussière et décidé d'écrire une rétrospective.  Votre avis est intéressant: l'aimeriez-vous, l'utiliser, ce qui peut être changé. <br><br>  <b>PS</b> Bien sûr, la préparation de l'application est un non-sens.  Il est prêt en tant que prototype - si vous approchez d'une production sérieuse, vous devez créer des scripts pour synchroniser les données avec OpenStreetMaps, vérifier le fonctionnement au zoo des appareils, localiser les interfaces, etc.  Le même backend sur le nœud et python tombera sous n'importe quelle charge sérieuse. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429240/">https://habr.com/ru/post/fr429240/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429230/index.html">Rapport: des projecteurs Epson à Integrated Systems Russia 2018</a></li>
<li><a href="../fr429232/index.html">Stéroïdes de carrière. Les chiens</a></li>
<li><a href="../fr429234/index.html">Création du jeu "Like coins" sur Godot Engine. Partie 1</a></li>
<li><a href="../fr429236/index.html">De combien de Data Scientists avez-vous besoin pour allumer une ampoule (ou quelle équipe fera fonctionner les données pour l'entreprise)</a></li>
<li><a href="../fr429238/index.html">Encore une fois sur les niveaux</a></li>
<li><a href="../fr429242/index.html">«Ne soyez pas timide. Essayez-le! " Interviews sur la vie, les compilateurs et la vie dans les compilateurs avec Unity Alexandre Mutel</a></li>
<li><a href="../fr429244/index.html">Greedy Gnome: alors que j'écrivais des analyses de marché dans Lineage 2</a></li>
<li><a href="../fr429246/index.html">Stage d'été chez Mars IS: un regard intérieur</a></li>
<li><a href="../fr429248/index.html">Conseils polyglottes: comment apprendre n'importe quelle langue sans larmes et malédictions</a></li>
<li><a href="../fr429250/index.html">Cent recettes de tenue de livres numériques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>