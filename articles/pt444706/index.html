<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëºüèª üë©üèø‚Äç‚úàÔ∏è üò∏ Fotos em 3D do Facebook dentro: Parallax Shaders üöò üé± üìè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos √∫ltimos meses, o Facebook inundou fotos em 3D . Se voc√™ n√£o conseguiu v√™-las, explicarei: fotos 3D s√£o imagens dentro da postagem que alteram suav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fotos em 3D do Facebook dentro: Parallax Shaders</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444706/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/7e9/cda/6537e9cdaff76aa8cc2716b8b53ecba9.gif" alt="imagem"></div><br>  Nos √∫ltimos meses, o Facebook inundou <strong>fotos em 3D</strong> .  Se voc√™ n√£o conseguiu v√™-las, explicarei: fotos 3D s√£o imagens dentro da postagem que alteram suavemente o √¢ngulo ao rolar a p√°gina ou quando voc√™ passa o mouse sobre elas. <br><br>  Alguns meses antes desse recurso aparecer, o Facebook testou um recurso semelhante nos modelos 3D.  Embora voc√™ possa entender facilmente como o Facebook pode renderizar modelos 3D e gir√°-los de acordo com a posi√ß√£o do mouse, nas fotos em 3D a situa√ß√£o pode n√£o ser t√£o intuitiva. <br><br>  A t√©cnica usada pelo Facebook para criar tridimensionalidade de imagens bidimensionais √†s vezes √© chamada de <strong>deslocamento do mapa de eleva√ß√£o</strong> .  Ele usa um fen√¥meno √≥ptico chamado <strong>paralaxe</strong> . <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Exemplo de uma foto 3D do Facebook (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/0f6/cbd/a060f6cbde767809731fea11f26034a4.gif"></div></div></div><br><h2>  O que √© paralaxe </h2><br>  Se voc√™ jogou Super Mario, sabe exatamente o que √© paralaxe.  Embora Mario corra na mesma velocidade, parece que objetos distantes ao fundo se movem mais devagar (veja abaixo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/b4f/3b3/33ab4f3b3e14cc710feb881f935d5162.gif"></div><br>  Esse efeito cria a ilus√£o de que alguns elementos, como montanhas e nuvens, est√£o localizados mais longe.  √â eficaz porque nosso c√©rebro usa paralaxe (junto com outras pistas visuais) para estimar a dist√¢ncia a objetos distantes. <br><br><div class="spoiler">  <b class="spoiler_title">Como o c√©rebro avalia a dist√¢ncia?</b> <div class="spoiler_text">  Sup√µe-se que o c√©rebro humano use v√°rios mecanismos para estimar a dist√¢ncia.  Em faixas curtas e m√©dias, as dist√¢ncias s√£o calculadas comparando-se as diferen√ßas na posi√ß√£o do objeto vis√≠vel com o olho direito e esquerdo.  Isso √© chamado de <strong>vis√£o estereosc√≥pica</strong> e √© generalizada na natureza. <br><br>  No entanto, para objetos suficientemente distantes, uma vis√£o estereosc√≥pica n√£o √© suficiente.  Montanhas, nuvens e estrelas diferem muito pouco para olhos diferentes perceberem uma diferen√ßa significativa.  Portanto, a paralaxe relativa entra em jogo.  Os objetos em segundo plano movem-se menos que os objetos em primeiro plano.  √â o movimento relativo deles que permite definir a dist√¢ncia relativa. <br><br>  Na percep√ß√£o da dist√¢ncia, muitos outros mecanismos s√£o usados.  O mais famoso deles √© a neblina atmosf√©rica, que d√° aos objetos distantes uma tonalidade azul.  Em outros mundos, a maioria dessas pistas atmosf√©ricas n√£o existe, por isso √© t√£o dif√≠cil avaliar a escala de objetos em outros planetas e na lua.  O usu√°rio do YouTube Alex McCulgan explica isso em seu canal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener">Astrum</a> , mostrando o qu√£o dif√≠cil √© determinar o tamanho dos objetos lunares mostrados no v√≠deo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5yx3O9cZ5NM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><h2>  Paralaxe como uma mudan√ßa </h2><br>  Se voc√™ conhece a √°lgebra linear, provavelmente sabe como a matem√°tica das rota√ß√µes 3D pode ser complicada e n√£o trivial.  Portanto, existe uma maneira muito mais simples de entender a paralaxe, que requer apenas mudan√ßas. <br><br>  Vamos imaginar que estamos olhando para um cubo (veja abaixo).  Se estivermos precisamente alinhados com o centro, as faces frontal e traseira parecer√£o dois quadrados de tamanhos diferentes para nossos olhos.  Essa √© a <strong>perspectiva</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bac/1ac/714/bac1ac714202cd1fa2e3608646970dca.png"></div><br>  No entanto, o que acontece se abaixarmos a c√¢mera ou elevarmos o cubo?  Aplicando os mesmos princ√≠pios, podemos ver que as faces frontal e traseira mudaram em rela√ß√£o √† sua posi√ß√£o anterior.  Ainda mais interessante √© que eles se mudaram em rela√ß√£o um ao outro.  A face traseira, que est√° mais longe de n√≥s, como se se movesse menos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/25a/0e1/4d825a0e105c808d87e1b5995f2faef1.png"></div><br>  Se quisermos calcular as posi√ß√µes verdadeiras desses v√©rtices do cubo em nosso escopo projetado, teremos que levar a s√©rio a trigonometria.  No entanto, isso n√£o √© realmente necess√°rio.  Se o movimento da c√¢mera for pequeno o suficiente, podemos aproximar o deslocamento dos v√©rtices, movendo-os proporcionalmente √† sua dist√¢ncia. <br><br>  A √∫nica coisa que precisamos determinar √© escala.  Se movermos X metros para a direita, deve parecer que o objeto Y metros de dist√¢ncia se moveu Z metros.  Se X permanecer pequeno, a paralaxe se tornar√° a tarefa de <strong>interpola√ß√£o linear em</strong> vez de trigonometria.  Em ess√™ncia, isso significa que podemos simular pequenas rota√ß√µes 3D deslocando os pixels, dependendo da dist√¢ncia da c√¢mera. <br><br><h2>  Gere mapas de profundidade </h2><br>  Em princ√≠pio, o que o Facebook faz n√£o √© muito diferente do que est√° acontecendo no Super Mario.  Para uma determinada imagem, certos pixels s√£o deslocados na dire√ß√£o do movimento com base na dist√¢ncia da c√¢mera.  Para criar uma foto 3D do Facebook, voc√™ s√≥ precisa da foto e de um mapa informando a dist√¢ncia de cada pixel da c√¢mera.  Esse mapa tem o nome esperado - <strong>"mapa de profundidade"</strong> .  Tamb√©m √© chamado de <strong>mapa de altura,</strong> dependendo do contexto. <br><br>  Tirar uma foto √© bem simples, mas gerar o mapa de profundidade certo √© uma tarefa muito mais dif√≠cil.  Os dispositivos modernos usam v√°rias t√©cnicas.  Na maioria das vezes, use duas c√¢meras;  cada um tira uma foto do mesmo assunto, mas com uma perspectiva ligeiramente diferente.  O mesmo princ√≠pio √© usado na <strong>vis√£o estereosc√≥pica</strong> , usada pelas pessoas para avaliar a profundidade em dist√¢ncias curtas e m√©dias.  A imagem abaixo mostra como o iPhone 7 pode criar mapas de profundidade a partir de duas imagens muito pr√≥ximas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/903/ab0/c03/903ab0c0376f7978c771352d82b5f648.png"></div><br>  Os detalhes da implementa√ß√£o dessa reconstru√ß√£o est√£o descritos no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener">Instant 3D Photography</a> , apresentado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener">Peter Hedman</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener">Johannes Kopf</a> no SIGGRAPH2018. <br><br>  Ap√≥s criar um mapa de profundidade de alta qualidade, simular a tridimensionalidade se torna uma tarefa quase trivial.  A verdadeira limita√ß√£o dessa t√©cnica √© que, mesmo que voc√™ possa recriar um modelo 3D bruto, ela n√£o possui informa√ß√µes sobre como renderizar pe√ßas invis√≠veis na foto original.  No momento, esse problema n√£o pode ser resolvido e, portanto, todos os movimentos vis√≠veis nas fotografias em 3D s√£o bastante insignificantes. <br><br>  N√≥s nos familiarizamos com o conceito de fotografias em 3D e falamos brevemente sobre como os smartphones modernos podem cri√°-las.  Na segunda parte, aprenderemos como as mesmas t√©cnicas podem ser usadas para implementar fotos 3D no Unity usando shaders. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/7e9/cda/6537e9cdaff76aa8cc2716b8b53ecba9.gif"></div><br><h2>  Parte 2. Shaders de paralaxe e mapas de profundidade </h2><br><h4>  Modelo de sombreador </h4><br>  Se queremos recriar fotos em 3D do Facebook usando um shader, devemos primeiro decidir o que exatamente faremos.  Como esse efeito funciona melhor com imagens 2D, seria l√≥gico implementar uma solu√ß√£o compat√≠vel com os sprites do Unity.  Criaremos um shader que pode ser usado com o <strong>Sprite Renderer</strong> . <br><br>  Embora esse sombreador possa ser criado do zero, geralmente √© prefer√≠vel come√ßar com um modelo pronto.  √â melhor come√ßar a avan√ßar copiando o shader difuso existente de sprites, que o Unity usa por padr√£o para todos os sprites.  Infelizmente, o mecanismo n√£o vem com um arquivo <em>shader</em> que voc√™ pode editar por conta pr√≥pria. <br><br>  Para obt√™-lo, voc√™ precisa ir ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener">arquivo de download</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener">Unity</a> e baixar o pacote <em>Built-in shaders</em> (veja abaixo) para a vers√£o do mecanismo que voc√™ est√° usando. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d00/1b9/da8/d001b9da891e60ef4b93f89ffb8a9fda.png"></div><br>  Ap√≥s extrair o pacote, voc√™ pode visualizar o c√≥digo-fonte de todos os shaders que acompanham o Unity.  Estamos interessados ‚Äã‚Äãno arquivo <em>Sprites-Diffuse.shader</em> , que √© usado por padr√£o para todos os sprites criados. <br><br><h2>  Imagens </h2><br>  O segundo aspecto que precisa ser formalizado s√£o os dados que temos.  Imagine que temos a imagem que queremos animar e seu mapa de profundidade.  A √∫ltima ser√° uma imagem em preto e branco, na qual os pixels em preto e branco indicam a que dist√¢ncia ou dist√¢ncia est√£o da c√¢mera. <br><br>  As imagens usadas neste tutorial foram tiradas do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener">projeto de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener">gato Pickle</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener">Dennis Hotson</a> , e este √© sem d√∫vida o melhor que voc√™ ver√° hoje. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/9ee/9c0/03c9ee9c0a5f15908ea183bf0b4bea98.png"></div><br>  O mapa de altitude associado a esta imagem reflete a dist√¢ncia do focinho do gato da c√¢mera. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54c/f5b/d2d/54cf5bd2d93144efb7371c3076b6541c.jpg"></div><br>  √â f√°cil ver como bons resultados podem ser alcan√ßados com um mapa de profundidade t√£o simples.  Isso significa que √© f√°cil criar seus pr√≥prios mapas de profundidade para imagens existentes. <br><br><h2>  As propriedades </h2><br>  Agora que temos todos os recursos, podemos come√ßar a escrever o c√≥digo do sombreador de paralaxe.  Se importarmos a imagem principal como um sprite, o Unity a passar√° automaticamente para o shader por meio da propriedade <code>_MainTex</code> .  No entanto, precisamos disponibilizar o mapa de profundidade para o shader.  Isso pode ser implementado usando uma nova <strong>propriedade shader</strong> chamada <code>_HeightTex</code> .  Decidi intencionalmente n√£o cham√°-lo <code>_DepthTex</code> para n√£o confundi-lo com a <strong>textura de profundidade</strong> (este √© um conceito similar do Unity usado para renderizar o mapa de profundidade da cena). <br><br>  Para alterar a for√ßa do efeito, tamb√©m adicionaremos a propriedade <code>_Scale</code> . <br><br><pre> <code class="cpp hljs">Properties { ... _HeightTex (<span class="hljs-string"><span class="hljs-string">"Heightmap (R)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"gray"</span></span> {} _Scale (<span class="hljs-string"><span class="hljs-string">"Scale"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br>  Essas duas novas propriedades tamb√©m devem corresponder a duas vari√°veis ‚Äã‚Äãcom o mesmo nome que precisam ser adicionadas √† se√ß√£o <code>CGPROGRAM</code> / <code>ENDCG</code> : <br><br><pre> <code class="cpp hljs">sampler2D _HeightTex; fixed2 _Scale;</code> </pre> <br>  Agora est√° tudo pronto, e podemos come√ßar a escrever o c√≥digo que executar√° o deslocamento. <br><br>  O primeiro passo √© amostrar o valor do mapa de profundidade, o que pode ser feito usando a fun√ß√£o <code>tex2D</code> .  Como <code>_HeightTex</code> √© uma textura em preto e branco, podemos apenas pegar seu canal vermelho e descartar o restante.  O valor resultante mede a dist√¢ncia em algumas unidades arbitr√°rias do pixel atual at√© a c√¢mera. <br><br>  O valor da profundidade est√° entre <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhiX_YeD_BBdaQ1mhEfAE-ZwjDJR3g#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhiX_YeD_BBdaQ1mhEfAE-ZwjDJR3g#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  mas vamos estic√°-lo para o intervalo de <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhiX_YeD_BBdaQ1mhEfAE-ZwjDJR3g#MJMAIN-2212" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhiX_YeD_BBdaQ1mhEfAE-ZwjDJR3g#MJMAIN-31" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>‚àí</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> -1 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhiX_YeD_BBdaQ1mhEfAE-ZwjDJR3g#MJMAIN-2B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhiX_YeD_BBdaQ1mhEfAE-ZwjDJR3g#MJMAIN-31" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> + 1 </script>  .  Isso permite que voc√™ forne√ßa paralaxe positivo (cor branca) e negativo (cor preta). <br><br><h2>  Teoria </h2><br>  Para simular o efeito de paralaxe nesta fase, precisamos usar as informa√ß√µes de profundidade para mudar os pixels da imagem.  Quanto mais pr√≥ximo o pixel, mais forte ele precisa ser mudado.  Este processo √© explicado no diagrama abaixo.  O pixel vermelho da <em>imagem original,</em> de acordo com as informa√ß√µes do mapa de profundidade, deve deslocar dois pixels para a esquerda.  Da mesma forma, o pixel azul deve deslocar dois pixels para a direita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/457/008/e69/457008e692048d9b5ef8eb2964f35fe2.png"></div><br>  Embora <em>teoricamente</em> isso deva funcionar, n√£o h√° maneiras f√°ceis de implementar isso no shader.  O fato √© que um sombreador, por seu princ√≠pio, s√≥ pode mudar a cor do pixel <em>atual</em> .  Ao executar o c√≥digo de sombreador, ele deve desenhar um pixel espec√≠fico na tela;  n√£o podemos simplesmente mover esse pixel para outro local ou alterar a cor do vizinho.  Essa <em>restri√ß√£o de localidade</em> fornece uma opera√ß√£o paralela muito eficiente de shaders, mas n√£o nos permite implementar todos os tipos de efeitos que seriam triviais, desde que haja <em>acesso aleat√≥rio para grava√ß√£o</em> de cada pixel na imagem. <br><br>  Se quisermos ser precisos, precisamos amostrar o mapa de profundidade de todos os pixels vizinhos para descobrir qual deles deve (se deve) mover para a posi√ß√£o atual.  Se v√°rios pixels estiverem no mesmo local, podemos calcular a influ√™ncia deles.  Embora esse sistema funcione e forne√ßa o melhor resultado poss√≠vel, √© extremamente ineficiente e potencialmente centenas de vezes mais lento que o shader difuso original com o qual come√ßamos. <br><br>  A melhor alternativa seria a seguinte solu√ß√£o: obtemos a profundidade do pixel atual no mapa de profundidade;  se precisarmos desloc√°-lo <em>para a direita</em> , substitua a cor atual pelo pixel <em>√† esquerda</em> (veja a imagem abaixo).  Aqui assumimos que, se voc√™ deseja mover o pixel para a direita, os pixels vizinhos √† esquerda tamb√©m devem se mover da mesma maneira. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/cc8/7c0/699cc87c06761842edfc77449c195b43.png"></div><br>  √â f√°cil ver que essa √© apenas uma aproxima√ß√£o de baixo custo do que realmente quer√≠amos alcan√ßar.  No entanto, √© muito eficaz, porque os mapas de profundidade geralmente s√£o suaves. <br><br><h2>  C√≥digo </h2><br>  Seguindo o algoritmo descrito na se√ß√£o anterior, podemos implementar o sombreador de paralaxe com um <strong>deslocamento</strong> simples <strong>das coordenadas UV</strong> . <br><br>  Isso leva ao seguinte c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Displacement fixed height = tex2D(_HeightTex, IN.uv_MainTex).r; fixed2 displacement = _Scale * ((height - 0.5) * 2); fixed4 c = SampleSpriteTexture (IN.uv_MainTex - displacement) * IN.color; ... }</span></span></code> </pre> <br>  Essa t√©cnica funciona bem com objetos quase planos, como pode ser visto na anima√ß√£o abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ba/0c4/b8f/8ba0c4b8fa0fc51bf86c0874139feedb.gif"></div><br>  Mas ele realmente funciona muito bem com modelos 3D, porque √© muito f√°cil renderizar a textura de profundidade para uma cena 3D.  Abaixo est√° uma imagem renderizada em 3D e seu mapa de profundidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/701/179/d0f/701179d0f52d53b25f9d079d60dc8ae3.jpg"></div><br>  Os resultados finalizados s√£o mostrados aqui: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/134/28c/51d13428ce1f6b84cbb6b62984f86fe4.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444706/">https://habr.com/ru/post/pt444706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444692/index.html">MOSDROID # 16 Sulphur em Redmadrobot</a></li>
<li><a href="../pt444694/index.html">Como previmos a vaz√£o, abord√°-la como um desastre natural</a></li>
<li><a href="../pt444696/index.html">Aumente a densidade do cont√™iner em um n√≥ usando a tecnologia PFCACHE</a></li>
<li><a href="../pt444700/index.html">Bancos de dados aleat√≥rios. Oracle Enterprise Data Quality - Shield e Sword for Enterprise Storage</a></li>
<li><a href="../pt444704/index.html">Oportunidades nanoCAD SPDS Canteiro de obras em projetos de constru√ß√£o e reconstru√ß√£o em condi√ß√µes apertadas</a></li>
<li><a href="../pt444708/index.html">Aplicativo PentQL com GraphQL</a></li>
<li><a href="../pt444710/index.html">Compreendendo o Protocolo de Consenso Estelar</a></li>
<li><a href="../pt444712/index.html">"Atitude at√≠pica em rela√ß√£o ao financiamento" - e se os pr√≥prios funcion√°rios gerenciarem a receita. Conversa com Flant</a></li>
<li><a href="../pt444714/index.html">Como fizemos o overclock do CAD COMPASS-3D ‚Üí Parte 1</a></li>
<li><a href="../pt444716/index.html">Um telefone Samsung com uma tela dobr√°vel por US $ 2000 exibe um vinco</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>