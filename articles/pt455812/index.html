<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏 ⛹🏽 🧑 Construindo uma arquitetura de microsserviço em Golang e gRPC, parte 2 (janela de encaixe) 🍎 👨🏿‍✈️ 👨🏼‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="É hora de enfrentar os contêineres 
 Primeiro de tudo, usamos a imagem mais recente do Linux Alpine. Linux Alpine é uma distribuição Linux leve, proje...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Construindo uma arquitetura de microsserviço em Golang e gRPC, parte 2 (janela de encaixe)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455812/"><h3>  É hora de enfrentar os contêineres </h3><br>  Primeiro de tudo, usamos a imagem mais recente do Linux Alpine.  Linux Alpine é uma distribuição Linux leve, projetada e otimizada para a execução de aplicativos Web no Docker.  Em outras palavras, o Linux Alpine possui dependências e funcionalidades suficientes para executar a maioria dos aplicativos.  Isso significa que o tamanho da imagem é de cerca de 8 MB! <br><br>  Comparado a, digamos ... uma máquina virtual Ubuntu com capacidade de cerca de 1 GB, é por isso que as imagens do Docker se tornaram mais naturais para microsserviços e computação em nuvem. <br><br>  Portanto, agora espero que você veja valor na contêiner e que possamos iniciar o "Dockerising" nosso primeiro serviço.  Vamos criar um serviço de <b>consignação / Dockerfile $ Dockerfile</b> . <br><br><img src="https://habrastorage.org/webt/xf/a7/ex/xfa7exynloocyeogmno3p3le27m.jpeg"><br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Primeira parte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Repositório original do EwanValentine</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo original</a> <br><br>  No Dockerfile, adicione o seguinte: <br><br><pre><code class="plaintext hljs">FROM alpine:latest RUN mkdir /app WORKDIR /app ADD consignment-service /app/consignment-service CMD ["./consignment-service"]</code> </pre> <br>  Em seguida, criamos um novo diretório para hospedar nosso aplicativo.  Em seguida, adicionamos nosso binário compilado ao contêiner do Docker e o executamos. <br><br>  Agora, vamos atualizar o registro de compilação do nosso Makefile para criar uma imagem do Docker. <br><br><pre> <code class="plaintext hljs">build: ... GOOS=linux GOARCH=amd64 go build docker build -t consignment .</code> </pre><br>  Adicionamos mais duas etapas e gostaria de explicá-las com mais detalhes.  Primeiro de tudo, criamos nosso binário Go.  No entanto, você notará duas variáveis ​​de ambiente antes de executar o $ go build.  GOOS e GOARCH permitem que você faça uma compilação cruzada de seu binário para outro sistema operacional.  Como estou desenvolvendo um Macbook, não consigo compilar o executável go e executá-lo em um contêiner Docker que usa Linux.  O binário não terá sentido no seu contêiner do Docker e gerará um erro. <br><br>  A segunda etapa que adicionei é o processo de criação do docker.  O Docker lerá o seu Dockerfile e criará uma imagem denominada consignment-service, o ponto indica o caminho do diretório, portanto, aqui apenas queremos que o processo de criação observe o diretório atual. <br><br>  Vou adicionar uma nova entrada ao nosso Makefile: <br><br><pre> <code class="plaintext hljs">run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Aqui, lançamos nossa imagem do docker abrindo a porta 50051. Como o Docker opera em uma camada de rede separada, é necessário redirecionar a porta.  Por exemplo, se você deseja iniciar este serviço na porta 8080, altere o argumento -p para 8080: 50051.  Você também pode executar o contêiner em segundo plano, incluindo o sinalizador -d.  Por exemplo, a <b>janela de encaixe execute -d -p 50051: 50051 consignment-service</b> . <br><br>  Execute <b>$ make run e</b> , em um painel terminal separado, novamente <b>$ go run main.go</b> e verifique se ele ainda funciona. <br><br>  Ao executar a construção do $ docker, você incorpora seu código e tempo de execução na imagem.  Imagens do Docker são imagens portáteis do seu ambiente e de suas dependências.  Você pode compartilhar imagens do Docker postando-as no Docker Hub.  Que é semelhante ao npm ou ao repositório yum para imagens do docker.  Quando você define FROM no seu Dockerfile, solicita ao Docker que puxe essa imagem do repositório do Docker para usar como base.  Você pode expandir e redefinir partes desse arquivo base, redefinindo-as como desejar.  Não publicaremos nossas imagens do docker, mas fique à vontade para navegar no repositório do docker e observe que quase todos os softwares já foram empacotados em contêineres.  Algumas coisas realmente maravilhosas foram encaixotadas. <br><br>  Cada anúncio no Dockerfile é armazenado em cache na primeira vez em que é criado.  Isso elimina a necessidade de reconstruir todo o tempo de execução toda vez que você faz alterações.  A janela de encaixe é inteligente o suficiente para descobrir quais detalhes foram alterados e quais precisam ser reconstruídos.  Isso torna o processo de criação incrivelmente rápido. <br><br>  Chega de contêineres!  Vamos voltar ao nosso código. <br><br>  Ao criar o serviço gRPC, há muitos códigos padrão para a criação de conexões, e você precisa codificar o local do endereço do serviço no cliente ou em outro serviço para que ele possa se conectar a ele.  Isso é difícil porque, quando você inicia os serviços na nuvem, eles podem não usar o mesmo host ou o endereço ou o ip podem mudar após a reimplantação do serviço. <br><br>  É aqui que o serviço de descoberta entra em ação.  O serviço de descoberta atualiza o diretório de todos os seus serviços e seus locais.  Cada serviço é registrado em tempo de execução e cancela o registro de perto.  Cada serviço recebe um nome ou identificador.  Portanto, mesmo que possa ter um novo endereço IP ou um endereço de host, desde que o nome do serviço permaneça o mesmo, você não precisará atualizar as chamadas para esse serviço de outros serviços. <br><br>  Como regra, existem muitas abordagens para esse problema, mas, como a maioria das coisas na programação, se alguém já lidou com esse problema, não faz sentido reinventar a roda.  @Chuhnk (Asim Aslam), criador do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Go-micro</a> , resolve esses problemas com uma clareza fantástica e facilidade de uso.  Ele, sozinho, produz software fantástico.  Por favor, considere ajudá-lo se você gosta do que vê! <br><br><h3>  Go micro </h3><br>  O Go-micro é uma poderosa estrutura de microsserviço escrita em Go, para uso, em grande parte, com o Go.  No entanto, você pode usar o Sidecar para interagir com outros idiomas. <br><br>  O Go-micro possui recursos úteis para criar microsserviços no Go.  Mas começaremos talvez com o problema mais comum que ele resolve, e essa é a descoberta de um serviço. <br><br>  Precisamos fazer várias atualizações em nosso serviço para trabalhar com o go-micro.  O Go-micro se integra como um plug-in Protoc, neste caso substituindo o plug-in gRPC padrão que estamos usando no momento.  Então, vamos começar substituindo isso em nosso Makefile. <br><br>  Certifique-se de instalar as dependências go-micro: <br><br><pre> <code class="plaintext hljs">go get -u github.com/micro/protobuf/{proto,protoc-gen-go}</code> </pre> <br>  Atualize nosso Makefile para usar o plug-in go-micro em vez do plug-in gRPC: <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Agora precisamos atualizar nosso shippy-service-consignment / main.go para usar o go-micro.  Isso abstrai a maior parte do nosso código gRPC anterior.  Ele processa facilmente o registro e acelera a gravação de um serviço. <br><br><div class="spoiler">  <b class="spoiler_title">shippy-service-consignment / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// shippy-service-consignment/main.go package main import ( "fmt" //  protobuf  pb "github.com/EwanValentine/shippy/consignment-service/proto/consignment" "github.com/micro/go-micro" "context" ) //repository -   type repository interface { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } // Repository -    , //       type Repository struct { consignments []*pb.Consignment } func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil } func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //           . type service struct { repo repository } // CreateConsignment -        , //    create,      //     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { // Save our consignment consignment, err := s.repo.Create(req) if err != nil { return err } // Return matching the `Response` message we created in our // protobuf definition. res.Created = true res.Consignment = consignment return nil } //GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { repo := &amp;Repository{} //     Go-micro srv := micro.NewService( //           proto micro.Name("shippy.service.consignment"), ) // Init will parse the command line flags. srv.Init() //   pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo}) //   log.Println(" ") if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  A principal mudança aqui é a maneira como criamos o servidor gRPC, que foi abstraído de mico.NewService (), que lida com o registro do nosso serviço.  E, finalmente, a função service.Run (), que processa a própria conexão.  Como antes, registramos nossa implementação, mas desta vez com um método ligeiramente diferente. <br><br>  A segunda maior mudança diz respeito aos próprios métodos de serviço: os argumentos e os tipos de respostas são levemente modificados para aceitar a solicitação e as estruturas de resposta como argumentos, e agora retornam apenas um erro.  Em nossos métodos, definimos a resposta que os processos vão micro. <br><br>  Finalmente, não programamos mais a porta.  O Go-micro deve ser configurado usando variáveis ​​de ambiente ou argumentos de linha de comando.  Para definir o endereço, use MICRO_SERVER_ADDRESS =: 50051.  Por padrão, a Micro usa mdns (multicast dns) como um broker de descoberta de serviço para uso local.  Normalmente você não usa mdns para descobrir serviços em um ambiente de produção, mas queremos evitar a execução de algo como Consul ou etcd localmente para teste.  Mais sobre isso mais tarde. <br><br>  Vamos atualizar nosso Makefile para refletir isso. <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 \ -e MICRO_SERVER_ADDRESS=:50051 \ shippy-service-consignment</code> </pre><br>  -e é o sinalizador da variável de ambiente, permite passar variáveis ​​de ambiente para o contêiner do Docker.  Você deve ter um sinalizador para cada variável, por exemplo -e ENV = teste -e DB_HOST = localhost, etc. <br><br>  Agora, se você executar $ make run, terá um serviço Dockerised com descoberta de serviço.  Então, vamos atualizar nossa ferramenta Cli para usar isso. <br><br><div class="spoiler">  <b class="spoiler_title">consignação-cli</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> micro <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pb.Consignment, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consignment *pb.Consignment data, err := ioutil.ReadFile(file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } json.Unmarshal(data, &amp;consignment) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> consignment, err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service := micro.NewService(micro.Name(<span class="hljs-string"><span class="hljs-string">"shippy.cli.consignment"</span></span>)) service.Init() client := pb.NewShippingServiceClient(<span class="hljs-string"><span class="hljs-string">"shippy.service.consignment"</span></span>, service.Client()) <span class="hljs-comment"><span class="hljs-comment">// Contact the server and print out its response. file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("Could not parse file: %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("Could not greet: %v", err) } log.Printf("Created: %t", r.Created) getAll, err := client.GetConsignments(context.Background(), &amp;pb.GetRequest{}) if err != nil { log.Fatalf("Could not list consignments: %v", err) } for _, v := range getAll.Consignments { log.Println(v) } }</span></span></code> </pre><br></div></div><br>  Aqui, importamos as bibliotecas go-micro para criar clientes e substituímos o código de conexão existente pelo código go-micro client, que usa a permissão do serviço em vez de se conectar diretamente ao endereço. <br><br>  No entanto, se você executar isso, ele não funcionará.  Isso ocorre porque agora estamos lançando nosso serviço no contêiner do Docker, que possui seus próprios mdns, separado do host mdns que estamos usando no momento.  A maneira mais fácil de corrigir isso é garantir que o serviço e o cliente estejam em execução no dockerland, para que ambos trabalhem no mesmo host e usem a mesma camada de rede.  Então, vamos criar make consignment-cli / Makefile e criar algumas entradas. <br><br><pre> <code class="plaintext hljs">build: GOOS=linux GOARCH=amd64 go build docker build -t shippy-cli-consignment . run: docker run shippy-cli-consignment</code> </pre><br>  Como antes, queremos construir nosso binário para Linux.  Quando lançamos nossa imagem do docker, queremos passar uma variável de ambiente para fornecer o comando go-micro para usar mdns. <br><br>  Agora vamos criar um Dockerfile para nossa ferramenta CLI: <br><br><pre> <code class="plaintext hljs">FROM alpine:latest RUN mkdir -p /app WORKDIR /app ADD consignment.json /app/consignment.json ADD consignment-cli /app/consignment-cli CMD ["./shippy-cli-consignment"]</code> </pre><br>  Isso é muito semelhante ao nosso serviço Dockerfile, exceto que ele também extrai nosso arquivo de dados json. <br><br>  Agora, quando você executar $ make run em sua remessa shippy-cli, deverá ver Created: true, como antes. <br><br>  Agora, parece que é hora de dar uma olhada no novo recurso do Docker: construções em vários estágios.  Isso nos permite usar várias imagens do Docker em um arquivo Docker. <br><br>  Isso é especialmente útil no nosso caso, pois podemos usar uma imagem para criar nosso arquivo binário com todas as dependências corretas.  E então use a segunda imagem para iniciá-la.  Vamos tentar isso, vou deixar comentários detalhados junto com o código: <br><div class="spoiler">  <b class="spoiler_title">serviço de consignação / Dockerfile</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># consignment-service/Dockerfile #     golang,    #     .    `as builder`, #     ,      . FROM golang:alpine as builder RUN apk --no-cache add git #         gopath WORKDIR /app/shippy-service-consignment #       COPY . . RUN go mod download #     ,   #       Alpine. RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-consignment #      FROM, #   Docker        . FROM alpine:latest # ,    -     RUN apk --no-cache add ca-certificates #   ,     . RUN mkdir /app WORKDIR /app #   ,       , #         `builder` #       , #    ,    , #      . ! COPY --from=builder /app/shippy-service-consignment/shippy-service-consignment . #     !        #        # run time . CMD ["./shippy-service-consignment"]</code> </pre><br></div></div><br>  Agora vou passar para outros arquivos do Docker e adotar essa nova abordagem.  Ah, e não esqueça de remover $ go build dos seus Makefiles! <br><br><h3>  Serviço de navio </h3><br>  Vamos criar um segundo serviço.  Temos um serviço (shippy-service-consignment), que lida com a coordenação do lote de contêineres com o navio, o que é mais adequado para esse lote.  Para corresponder ao nosso lote, devemos enviar o peso e o número de contêineres para o nosso novo serviço de navio, que encontrará um navio capaz de lidar com esse lote. <br><br>  Crie um novo diretório em seu diretório raiz <b>$ mkdir ship-service</b> , agora crie um subdiretório para nossa nova definição de serviços protobuf, <b>$ mkdir -p shippy-service-ship / proto / ship</b> .  Agora vamos criar um novo arquivo protobuf, <b>$ touch shippy-service-ship / proto / ship / ship.proto</b> . <br><br>  Como a definição de protobuf é realmente o núcleo do design de nosso software, vamos começar com ela. <br><br><div class="spoiler">  <b class="spoiler_title">navio / navio.proto</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// shippy-service-vessel/proto/vessel/vessel.proto syntax = "proto3"; package vessel; service VesselService { rpc FindAvailable(Specification) returns (Response) {} } message Vessel { string id = 1; int32 capacity = 2; int32 max_weight = 3; string name = 4; bool available = 5; string owner_id = 6; } message Specification { int32 capacity = 1; int32 max_weight = 2; } message Response { Vessel vessel = 1; repeated Vessel vessels = 2; }</code> </pre><br></div></div><br>  Como você pode ver, isso é muito semelhante ao nosso primeiro serviço.  Criamos um serviço com um método rpc chamado FindAvailable.  Isso requer um tipo de especificação e retorna um tipo de resposta.  O tipo de resposta retorna o tipo de embarcação ou vários navios usando um campo de repetição. <br><br>  Agora precisamos criar um Makefile para lidar com nossa lógica de construção e nosso script de inicialização.  <b>$ touch shippy-service-ship / Makefile</b> .  Abra este arquivo e adicione o seguinte: <br><br><pre> <code class="plaintext hljs">// vessel-service/Makefile build: protoc -I. --go_out=plugins=micro:. \ proto/vessel/vessel.proto docker build -t shippy-service-vessel . run: docker run -p 50052:50051 -e MICRO_SERVER_ADDRESS=:50051 shippy-service-vessel</code> </pre><br>  Isso é quase idêntico ao primeiro Makefile que criamos para nosso serviço de consignação, no entanto, observe que os nomes dos serviços e portas mudaram um pouco.  Como não podemos executar dois contêineres de dock na mesma porta, usamos o encaminhamento de porta do Dockers para que esse serviço redirecione de 50051 para 50052 na rede host. <br><br>  Agora precisamos de um Dockerfile usando nosso novo formato de vários estágios: <br><br><pre> <code class="plaintext hljs"># vessel-service/Dockerfile FROM golang:alpine as builder RUN apk --no-cache add git WORKDIR /app/shippy-service-vessel COPY . . RUN go mod download RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-vessel FROM alpine:latest RUN apk --no-cache add ca-certificates RUN mkdir /app WORKDIR /app COPY --from=builder /app/shippy-service-vessel . CMD ["./shippy-service-vessel"]</code> </pre><br>  Por fim, podemos escrever nossa implementação: <br><br><div class="spoiler">  <b class="spoiler_title">serviço de embarcação / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// vessel-service/main.go package main import ( "context" "errors" "fmt" pb "github.com/EwanValentine/shippy/vessel-service/proto/vessel" "github.com/micro/go-micro" ) type Repository interface { FindAvailable(*pb.Specification) (*pb.Vessel, error) } type VesselRepository struct { vessels []*pb.Vessel } // FindAvailable -     , //           , //      . func (repo *VesselRepository) FindAvailable(spec *pb.Specification) (*pb.Vessel, error) { for _, vessel := range repo.vessels { if spec.Capacity &lt;= vessel.Capacity &amp;&amp; spec.MaxWeight &lt;= vessel.MaxWeight { return vessel, nil } } //     return nil, errors.New("     ") } //    grpc type service struct { repo repository } func (s *service) FindAvailable(ctx context.Context, req *pb.Specification, res *pb.Response) error { //     vessel, err := s.repo.FindAvailable(req) if err != nil { return err } //       res.Vessel = vessel return nil } func main() { vessels := []*pb.Vessel{ &amp;pb.Vessel{Id: "vessel001", Name: "Boaty McBoatface", MaxWeight: 200000, Capacity: 500}, } repo := &amp;VesselRepository{vessels} srv := micro.NewService( micro.Name("shippy.service.vessel"), ) srv.Init() //    pb.RegisterVesselServiceHandler(srv.Server(), &amp;service{repo}) if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Agora vamos para a parte interessante.  Quando criamos uma remessa, precisamos alterar nosso serviço de manuseio de carga para entrar em contato com o serviço de pesquisa de navios, encontrar o navio e atualizar o parâmetro ship_id na remessa criada: <br><br><div class="spoiler">  <b class="spoiler_title">shippy / consignment-service / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"sync"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> vesselProto <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-vessel/proto/vessel"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( port = <span class="hljs-string"><span class="hljs-string">":50051"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> repository <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } <span class="hljs-comment"><span class="hljs-comment">// Repository -    , //       type Repository struct { mu sync.RWMutex consignments []*pb.Consignment } //Create -     func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { repo.mu.Lock() updated := append(repo.consignments, consignment) repo.consignments = updated repo.mu.Unlock() return consignment, nil } //GetAll -       func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //            type service struct { repo repository vesselClient vesselProto.VesselServiceClient } // CreateConsignment -         create, //     ,     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { //         , //    vesselResponse, err := s.vesselClient.FindAvailable(context.Background(), &amp;vesselProto.Specification{ MaxWeight: req.Weight, Capacity: int32(len(req.Containers)), }) log.Printf(" : %s \n", vesselResponse.Vessel.Name) if err != nil { return err } //     id  req.VesselId = vesselResponse.Vessel.Id //      consignment, err := s.repo.Create(req) if err != nil { return err } res.Created = true res.Consignment = consignment return nil } // GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { //   repo := &amp;Repository{} //  micro srv := micro.NewService( micro.Name("shippy.service.consignment"), ) srv.Init() vesselClient := vesselProto.NewVesselServiceClient("shippy.service.vessel", srv.Client()) //      gRPC. pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo, vesselClient}) //   if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Aqui, criamos uma instância do cliente para o nosso serviço de remessa, o que nos permite usar o nome do serviço, ou seja,  shipy.service.vessel para chamar o serviço do navio como cliente e interagir com seus métodos.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse caso, apenas um método (FindAvailable). Enviamos o peso do lote juntamente com o número de contêineres que queremos enviar, como uma especificação para o serviço do navio. O que nos devolve a embarcação correspondente a esta especificação. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atualize o arquivo consignment-cli / consignment.json, exclua ship_id codificado, porque queremos confirmar que nosso serviço de pesquisa de navios está funcionando. Além disso, vamos adicionar mais alguns contêineres e aumentar o peso.</font></font> Por exemplo: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">55000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"containers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"--"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_002"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_003"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ] }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora execute </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ make build &amp;&amp; make run</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em consignment-cli. </font><font style="vertical-align: inherit;">Você deverá ver uma resposta com uma lista dos produtos criados. </font><font style="vertical-align: inherit;">Nos seus grupos, você deve ver que o parâmetro ship_id está definido. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, temos dois microsserviços interconectados e uma interface de linha de comando! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na próxima parte desta série, consideraremos salvar alguns desses dados usando o MongoDB. </font><font style="vertical-align: inherit;">Também adicionaremos um terceiro serviço e usaremos o docker-compose para gerenciar localmente nosso crescente ecossistema de contêineres. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte I </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repositório Original EwanValentine</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455812/">https://habr.com/ru/post/pt455812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455794/index.html">Introdução ao Spring, ou o que todo o projeto é @Autowired e @Component, e você não entende o que é</a></li>
<li><a href="../pt455796/index.html">Programação orientada a objetos em Java e Python: semelhanças e diferenças</a></li>
<li><a href="../pt455800/index.html">Matrix 1.0 - Liberação descentralizada do protocolo de mensagens</a></li>
<li><a href="../pt455806/index.html">Nascimento e morte de um álbum: entendemos como os formatos musicais mudaram nos últimos 100 anos</a></li>
<li><a href="../pt455808/index.html">Obtenha extratos do registro no site do STF usando python</a></li>
<li><a href="../pt455816/index.html">Como criar uma ação interessante para o Google Assistant. Lifehacks de Just AI</a></li>
<li><a href="../pt455820/index.html">Análise de desempenho da VM no VMware vSphere. Parte 2: Memória</a></li>
<li><a href="../pt455826/index.html">Rega automática com controle remoto</a></li>
<li><a href="../pt455828/index.html">Cientistas descobriram novas formas exóticas de sincronização</a></li>
<li><a href="../pt455830/index.html">Uma olhada em Vá pelos olhos de um desenvolvedor .NET. Semana # 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>