<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèø ü§≥üèΩ ü§öüèª Usando uma rede neural de v√°rias camadas para evitar obst√°culos nos jogos üë®‚ÄçüöÄ üòÄ ‚úåüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Encontrar maneiras de evitar obst√°culos nos jogos √© uma tarefa cl√°ssica com a qual todos os desenvolvedores de jogos precisam lidar. Existem v√°rios al...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando uma rede neural de v√°rias camadas para evitar obst√°culos nos jogos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419265/"><p>  Encontrar maneiras de evitar obst√°culos nos jogos √© uma tarefa cl√°ssica com a qual todos os desenvolvedores de jogos precisam lidar.  Existem v√°rios algoritmos conhecidos, com diferentes graus de efici√™ncia.  Todos eles, em um grau ou outro, analisam a posi√ß√£o relativa do obst√°culo e do jogador e, com base nos resultados, √© tomada uma ou outra decis√£o de se mover.  Tentei usar uma rede neural treinada para resolver o problema de evitar obst√°culos.  Quero compartilhar minha experi√™ncia na implementa√ß√£o dessa abordagem no Unity3D neste pequeno artigo. </p><a name="habracut"></a><br><h2>  Conceito </h2><br><p>  O terreno baseado no terreno padr√£o √© usado como espa√ßo de jogo.  Colis√µes com a superf√≠cie n√£o s√£o consideradas neste artigo.  Cada modelo √© equipado com um conjunto de coletores, com a maior precis√£o poss√≠vel, descrevendo a geometria dos obst√°culos.  O modelo, que deve contornar obst√°culos, possui quatro </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ej/s8/e6/ejs8e6yvjqzipq0khklf3g5ph2o.jpeg"></div><br><p>  sensor de colis√£o (na captura de tela, a localiza√ß√£o e a dist√¢ncia dos sensores s√£o indicadas por linhas turquesas).  Em ess√™ncia, os sensores s√£o reykast, cada um dos quais passa a dist√¢ncia do objeto de colis√£o no algoritmo de an√°lise.  A dist√¢ncia varia de 0 (o objeto est√° localizado o mais pr√≥ximo poss√≠vel) a 1 (sem colis√£o, essa dire√ß√£o est√° livre de obst√°culos). <br>  Em geral, o trabalho do algoritmo de preven√ß√£o de obst√°culos √© o seguinte: </p><br><ol><li>  Quatro valores dos sensores de colis√£o s√£o alimentados nas quatro entradas de uma rede neural treinada </li><li>  O estado da rede neural √© calculado.  Na sa√≠da, obtemos tr√™s valores: <br>  a.  A pot√™ncia de rota√ß√£o do modelo no sentido anti-hor√°rio (assume um valor de 0 a 1) <br>  b.  A pot√™ncia de rota√ß√£o do modelo no sentido hor√°rio (assume um valor de 0 a 1) <br>  c.  Acelera√ß√£o de frenagem (assume um valor de 0 a 1) </li><li>  Os esfor√ßos s√£o aplicados ao modelo com coeficientes apropriados. </li></ol><br><h2>  Implementa√ß√£o </h2><br><p>  Honestamente, eu n√£o tinha ideia se algo viria desse empreendimento.  Primeiro, implementei a classe neuroNet no Unity.  N√£o vou me debru√ßar sobre o c√≥digo de classe, pois √© um perceptron cl√°ssico de multicamadas.  No processo, surgiu imediatamente a quest√£o do n√∫mero de camadas da rede.  Quantos deles s√£o necess√°rios para fornecer a capacidade necess√°ria, por um lado, e uma velocidade de c√°lculo aceit√°vel, por outro?  Ap√≥s uma s√©rie de experimentos, estabeleci doze camadas (tr√™s condi√ß√µes b√°sicas para quatro entradas). </p><br><p>  Em seguida, foi necess√°rio implementar o processo de treinamento de uma rede neural.  Para fazer isso, tive que criar um aplicativo separado que usasse a mesma classe neuroNet.  E agora o problema dos dados para treinamento atingiu seu auge.  Inicialmente, eu queria usar valores obtidos diretamente do aplicativo do jogo.  Para fazer isso, organizei o registro de dados dos sensores, para que, no futuro, para cada conjunto de valores dos quatro sensores, indique ao programa de treinamento os valores de sa√≠da corretos.  Mas, olhando o resultado, fiquei desanimado.  O fato √© que n√£o basta indicar um valor adequado para cada conjunto de quatro valores do sensor; esses valores precisam ser consistentes.  Isso √© muito importante para o treinamento bem-sucedido da rede neural.  Al√©m disso, n√£o havia garantia de que a amostra resultante representasse todas as situa√ß√µes poss√≠veis. </p><br><p>  Uma solu√ß√£o alternativa foi uma tabela compilada manualmente de op√ß√µes b√°sicas para os valores dos sensores e sa√≠das.  As op√ß√µes b√°sicas foram tomadas: 0,01 - o obst√°culo est√° pr√≥ximo, 0,5 - o obst√°culo est√° no meio do caminho, 1 - a dire√ß√£o est√° livre.  Isso reduziu o tamanho da amostra de treinamento. </p><br><table><thead><tr><th><pre>  Sensor 1 </pre></th><th><pre>  Sensor 2 </pre></th><th><pre>  Sensor 3 </pre></th><th><pre>  Sensor 4 </pre></th><th>  Rota√ß√£o no sentido hor√°rio </th><th>  Rota√ß√£o no sentido anti-hor√°rio </th><th>  Travagem </th></tr></thead><tbody><tr><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td><td>  0,5 </td><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td><td>  0,999 </td><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,5 </td><td>  0,01 </td><td>  0,999 </td><td>  0,01 </td><td>  0,01 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,5 </td><td>  0,5 </td><td>  0,999 </td><td>  0,01 </td><td>  0,01 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,5 </td><td>  0,999 </td><td>  0,999 </td><td>  0,01 </td><td>  0,5 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,999 </td><td>  0,01 </td><td>  0,999 </td><td>  0,01 </td><td>  0,5 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,999 </td><td>  0,5 </td><td>  0,999 </td><td>  0,01 </td><td>  0,999 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,999 </td><td>  0,999 </td><td>  0,999 </td><td>  0,01 </td><td>  0,999 </td></tr></tbody></table><br><p>  A tabela mostra um pequeno fragmento da amostra de treinamento (total na tabela 81-a linha).  O resultado final do programa de treinamento foi uma tabela de pondera√ß√£o, que foi salva em um arquivo separado. </p><br><h2>  Resultados </h2><br><p>  Antecipando esfregar minhas m√£os, organizei o carregamento das probabilidades em um jogo de demonstra√ß√£o e iniciei o processo.  Mas, como se viu, claramente n√£o fiz o suficiente para o caso.  Desde o in√≠cio, o modelo testado girou em todos os obst√°culos seguidos, como um gatinho cego.  Em geral, o resultado foi muito mais ou menos.  Eu tive que me aprofundar no estudo do problema.  Uma fonte de comportamento desamparado foi descoberta rapidamente.  Com as respostas geralmente corretas da rede neural √†s leituras dos sensores, as a√ß√µes de controle transmitidas se mostraram muito fortes. </p><br><p>  Tendo resolvido esse problema, encontrei uma nova dificuldade - a dist√¢ncia do sensor reykast.  Com uma longa dist√¢ncia de detec√ß√£o de interfer√™ncia, o modelo realizou manobras prematuras que resultaram em distor√ß√£o significativa da rota (e mesmo em colis√µes imprevistas em obst√°culos aparentemente j√° ultrapassados).  Uma pequena dist√¢ncia levou a uma coisa - uma "impot√™ncia" impotente do modelo em todos os obst√°culos, com uma clara falta de tempo para resposta. </p><br><p>  Quanto mais eu brincava com o modelo de jogo de demonstra√ß√£o, tentando ensin√°-lo a evitar obst√°culos, mais me parecia que eu n√£o estava programando, mas tentando ensinar meu filho a andar.  E foi uma sensa√ß√£o incomum!  Foi ainda mais alegre ver que meus esfor√ßos trouxeram resultados tang√≠veis.  No final, o infeliz barco flutuando acima da superf√≠cie come√ßou a contornar as estruturas que surgiam na rota.  Os testes reais para o algoritmo come√ßaram quando eu conscientemente tentei empurrar o modelo para um beco sem sa√≠da.  Aqui foi necess√°rio alterar a l√≥gica do trabalho com acelera√ß√£o de frenagem, para fazer algumas corre√ß√µes na amostra de treinamento.  Vejamos exemplos pr√°ticos do que aconteceu como resultado. </p><br><h4 id="1-prostoy-obhod-odnogo-prepyatstviya">  1. Simples desvio de um obst√°culo </h4><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iX45Xe-ww5U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Como voc√™ pode ver, o desvio n√£o causou nenhuma dificuldade. </p><br><h4 id="2-dva-prepyatstviya-variant-1">  2. Dois obst√°culos (op√ß√£o 1) </h4><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xTd0Fdrvr-E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  O modelo encontrou facilmente uma passagem entre os dois edif√≠cios.  Tarefa f√°cil. </p><br><h4 id="3-dva-prepyatstviya-variant-2">  3. Dois obst√°culos (op√ß√£o 2) </h4><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Y4BkLGn4M5Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Os edif√≠cios est√£o mais pr√≥ximos, mas o modelo encontra uma passagem. </p><br><h4 id="4-dva-prepyatstviya-variant-3">  4. Dois obst√°culos (op√ß√£o 3) </h4><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JdCltkyot6c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  A op√ß√£o √© mais complicada, mas ainda est√° resolvida. </p><br><h4 id="5-tri-prepyatstviya">  5. Tr√™s obst√°culos </h4><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lgeHMbBp-ZM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  O problema foi resolvido rapidamente. </p><br><h4 id="6-tupik">  6. Beco sem sa√≠da </h4><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zWXk4QqApy8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Aqui o modelo teve problemas.  Os primeiros 30 segundos do v√≠deo mostram que o modelo trope√ßa impotente em uma configura√ß√£o simples de constru√ß√£o.  O problema aqui provavelmente n√£o est√° tanto no modelo de rede neural como no algoritmo principal para se mover ao longo da rota - ele est√° constantemente tentando recuperar o navio de rumo, apesar das tentativas desesperadas de evitar uma colis√£o. </p><br><p>  Depois de v√°rias execu√ß√µes sem √™xito dessa situa√ß√£o com par√¢metros diferentes, consegui obter um resultado positivo.  A partir do trig√©simo segundo do v√≠deo, √© poss√≠vel observar como um modelo com uma dist√¢ncia maior de sensores e uma for√ßa de frenagem mais poderosa √© selecionado a partir do beco sem sa√≠da.  Para isso, ela precisou de quase cinco minutos de tempo (cortei o tormento e deixei apenas os √∫ltimos 30 segundos do v√≠deo).  √â improv√°vel que, em um jogo real, isso seja considerado um bom resultado, portanto, obviamente, h√° espa√ßo para melhorias no algoritmo. </p><br><h2>  Conclus√£o </h2><br><p>  Em geral, o problema foi resolvido.  A efic√°cia dessa solu√ß√£o √© uma quest√£o em aberto e s√£o necess√°rias mais pesquisas.  Por exemplo, n√£o se sabe como o modelo se comportar√° quando obst√°culos din√¢micos (outros objetos em movimento) aparecerem.  Outro problema √© a falta de sensores de colis√£o apontando para tr√°s, o que leva a dificuldades em evitar obst√°culos complexos. </p><br><p>  O desenvolvimento √≥bvio da id√©ia de um algoritmo para evitar obst√°culos na rede neural √© visto na introdu√ß√£o do treinamento.  Para fazer isso, uma avalia√ß√£o do resultado da decis√£o tomada deve ser introduzida e, com as corre√ß√µes subsequentes sem altera√ß√µes significativas na posi√ß√£o do objeto, a avalia√ß√£o deve se deteriorar.  Ao atingir um determinado valor, o modelo deve entrar no modo de treinamento e, digamos, alterar aleatoriamente as decis√µes tomadas para encontrar uma sa√≠da. </p><br><p>  Outra caracter√≠stica do modelo me parece a variabilidade do treinamento inicial.  Isso possibilita, por exemplo, ter v√°rios comportamentos para modelos diferentes sem a necessidade de programar cada um deles separadamente.  Em outras palavras, se tivermos, digamos, um tanque pesado e um reconhecimento leve, sua maneira de evitar obst√°culos pode variar significativamente.  Para alcan√ßar esse efeito, usamos o mesmo perceptron, mas treinado em amostras diferentes. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419265/">https://habr.com/ru/post/pt419265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt419253/index.html">Relat√≥rio do Clube de Roma de 2018, cap√≠tulo 3.6: Urbanismo regenerativo: Ec√≥polis</a></li>
<li><a href="../pt419255/index.html">No√ß√µes b√°sicas de seguran√ßa da Internet das coisas</a></li>
<li><a href="../pt419257/index.html">√çndia apresenta nova lei de prote√ß√£o contra DP - outro an√°logo ao GDPR?</a></li>
<li><a href="../pt419259/index.html">Rust 1.28 Release</a></li>
<li><a href="../pt419261/index.html">A√ß√µes no Google: escrevendo um aplicativo simples para o Google Assistant no Dialogflow e Cloud Functions for Firebase</a></li>
<li><a href="../pt419267/index.html">Excurs√£o SOK Coworking</a></li>
<li><a href="../pt419269/index.html">Recusas no c√≥digo e como descriptograf√°-las. O poder secreto dos identificadores</a></li>
<li><a href="../pt419271/index.html">An√°logos em Python e JavaScript. Parte quatro</a></li>
<li><a href="../pt419273/index.html">Escrevendo um m√≥dulo do kernel Linux: GPIO com suporte a IRQ</a></li>
<li><a href="../pt419277/index.html">Fitas t√©rmicas com classe de prote√ß√£o IP68. Apropriado para a luz em uma casa de banho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>