<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÜ üë∏üèæ ü•† Die Autoren des Spiels 0 AD - gut gemacht ‚ò¢Ô∏è üëµüèª ‚õìÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="0 AD ist ein dreidimensionales Spiel im Genre der historischen Strategie in Echtzeit, das von der Freiwilligengemeinschaft entwickelt wurde. Die Gr√∂√üe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Autoren des Spiels 0 AD - gut gemacht</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/420267/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/b41/bfb/6c5b41bfb68b23ef10d61f6ecd1a6665.png" alt="PVS-Studio &amp; 0 A.D."></div><br>  0 AD ist ein dreidimensionales Spiel im Genre der historischen Strategie in Echtzeit, das von der Freiwilligengemeinschaft entwickelt wurde.  Die Gr√∂√üe der Codebasis ist klein und ich habe beschlossen, das Spiel als Pause von gro√üen Projekten wie Android und XNU Kernel zu √ºberpr√ºfen.  Vor uns liegt also ein Projekt mit 165.000 Codezeilen in C ++.  Mal sehen, was daran interessant ist, kann mit dem statischen Analyseger√§t PVS-Studio ermittelt werden. <br><a name="habracut"></a><br><h2>  0 AD </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">0 AD</a> (0 A.D.) ist ein kostenloses dreidimensionales Spiel im Genre der historischen Strategie in Echtzeit, das von einer Community von Freiwilligen entwickelt wurde (die Hauptentwickler sind im Wildfire Games-Team vereint).  Das Spiel erm√∂glicht es Ihnen, Zivilisationen zu kontrollieren, die in der Zeit von 500 v. Chr. Existierten.  - 1 Jahr v.  e.  Ab Sommer 2018 ist das Projekt in Alpha-Version.  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschreibung</a> aus Wikipedia]. <br><br>  Warum genau 0 n. Chr.? <br><br>  Ich bat einen Kollegen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Egor Bredikhin</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">EgorBredikhin</a> ), ein kleines offenes Projekt auszuw√§hlen und f√ºr mich zu pr√ºfen, mit dem ich zwischen anderen Aufgaben arbeiten konnte.  Er schickte mir ein Protokoll f√ºr das 0 AD-Projekt. Auf die Frage: "Warum dieses Projekt?"  - Es gab eine Antwort: "Ja, ich habe gerade dieses Spiel gespielt, eine gute Echtzeitstrategie."  Ok, dann ist es 0 AD :). <br><br><h2>  Fehlerdichte </h2><br>  Ich m√∂chte die Autoren von 0 AD f√ºr die gute Qualit√§t des C ++ - Codes loben.  Gut gemacht, schaffen Sie es selten, eine so geringe Fehlerdichte zu erreichen.  Dies sind nat√ºrlich nicht alle Fehler, sondern diejenigen, die mit PVS-Studio erkannt werden k√∂nnen.  Wie gesagt, obwohl PVS-Studio nicht alle Fehler findet, k√∂nnen wir dennoch sicher √ºber die Beziehung zwischen der Fehlerdichte und der Qualit√§t des Codes als Ganzes sprechen. <br><br>  Ein paar Zahlen.  Die Gesamtzahl der nicht leeren Codezeilen betr√§gt 231270. Davon sind 28,7% Kommentare.  Insgesamt 165.000 Zeilen reinen C ++ - Codes. <br><br>  Die Anzahl der vom Analyseger√§t ausgegebenen Nachrichten war gering, und nachdem ich sie alle angesehen hatte, schrieb ich 19 Fehler aus.  Ich werde all diese Fehler sp√§ter in diesem Artikel betrachten.  Vielleicht habe ich etwas verpasst, weil der Fehler ein harmloser, schlampiger Code ist.  Im Allgemeinen √§ndert dies jedoch nichts am Bild. <br><br>  Also habe ich 19 Fehler in 165.000 Codezeilen gefunden.  Wir berechnen die Fehlerdichte: 19 * 1000/165000 = 0,115. <br><br>  Der Einfachheit halber runden wir ab und gehen davon aus, dass der PVS-Studio-Analysator 0,1 Fehler pro 1000 Codezeilen im Spielcode erkennt. <br><br>  Tolles Ergebnis!  Zum Vergleich habe ich in meinem letzten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel √ºber Android</a> berechnet, dass ich mindestens 0,25 Fehler pro 1000 Codezeilen festgestellt habe.  Tats√§chlich ist die Fehlerdichte dort sogar noch gr√∂√üer. Ich habe einfach nicht die Kraft gefunden, den gesamten Bericht sorgf√§ltig zu analysieren. <br><br>  Oder nehmen Sie als Beispiel die EFL-Kernbibliotheken, die ich sorgf√§ltig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">untersucht</a> und die Anzahl der Fehler berechnet habe.  Darin erkennt PVS-Studio 0,71 Fehler pro 1000 Codezeilen. <br><br>  Die Autoren von 0 AD sind also gut gemacht. Aus Gr√ºnden der Fairness sollte jedoch beachtet werden, dass ihnen die geringe Menge an in C ++ geschriebenem Code hilft.  Leider w√§chst die Komplexit√§t des Projekts umso schneller, je gr√∂√üer das Projekt ist, und die Fehlerdichte steigt nicht linear ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehr</a> ) an. <br><br><h2>  Fehler </h2><br>  Schauen wir uns nun die 19 Fehler an, die ich im Spiel gefunden habe.  Zur Analyse des Projekts habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> Version 6.24 verwendet.  Ich schlage vor, Sie versuchen, die Demoversion herunterzuladen und die Projekte zu √ºberpr√ºfen, an denen Sie arbeiten. <br><br>  <b>Hinweis</b>  Wir positionieren PVS-Studio als B2B-L√∂sung.  F√ºr kleine Projekte und einzelne Entwickler haben wir eine kostenlose Lizenzoption: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So nutzen Sie PVS-Studio kostenlos</a> ." <br><br>  <b>Fehler N1</b> <br><br>  Betrachten wir zun√§chst einen komplexen Fehler.  In der Tat ist es nicht kompliziert, aber Sie m√ºssen sich mit einem ziemlich gro√üen St√ºck Code vertraut machen. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WaterManager::CreateWaveMeshes() { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nbNeighb = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; nbNeighb = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; p &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; ++p) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CoastalPointsSet.count(xx+around[p][<span class="hljs-number"><span class="hljs-number">0</span></span>] + (yy + around[p][<span class="hljs-number"><span class="hljs-number">1</span></span>])*SideSize)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nbNeighb &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { CoastalPointsSet.erase(xx + yy*SideSize); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ++nbNeighb; <span class="hljs-comment"><span class="hljs-comment">// We've found a new point around us. // Move there xx = xx + around[p][0]; yy = yy + around[p][1]; indexx = xx + yy*SideSize; if (i == 0) Chain.push_back(CoastalPoint(indexx,CVector2D(xx*2,yy*2))); else Chain.push_front(CoastalPoint(indexx,CVector2D(xx*2,yy*2))); CoastalPointsSet.erase(xx + yy*SideSize); found = true; break; } } if (!found) endedChain = true; .... }</span></span></code> </pre> <br>  PVS-Studio- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warnung</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547</a> CWE-570 Ausdruck 'nbNeighb&gt; = 2' ist immer falsch.  WaterManager.cpp 581 <br><br>  Auf den ersten Blick erscheint die Meldung des Analysators seltsam.  Warum ist die Bedingung <i>nbNeighb&gt; = 2</i> immer falsch?  In der Tat gibt es im K√∂rper der Schleife ein Inkrement der Variablen <i>nbNeighb</i> ! <br><br>  Wenn Sie unten nachsehen, sehen Sie eine <i>break-</i> Anweisung, die die Ausf√ºhrung der Schleife unterbricht.  Wenn daher die Variable <i>nbNeighb</i> erh√∂ht wird, wird der Zyklus gestoppt.  Somit erreicht der Wert der Variablen <i>nbNeighb</i> niemals einen Wert gr√∂√üer als 1. <br><br>  Der Code enth√§lt eindeutig einen logischen Fehler. <br><br>  <b>Fehler N2</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CmpRallyPointRenderer::MergeVisibilitySegments( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;SVisibilitySegment&gt;&amp; segments) { .... segments.erase(segments.end()); .... }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V783</a> CWE-119 Es kann zu einer Dereferenzierung des ung√ºltigen Iterators 'segment.end ()' kommen.  CCmpRallyPointRenderer.cpp 1290 <br><br>  Sehr, sehr seltsamer Code.  Vielleicht wollte der Programmierer das letzte Element aus dem Container entfernen.  In diesem Fall sollte der Code folgenderma√üen aussehen: <br><br><pre> <code class="cpp hljs">segments.erase(segments.end() - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Obwohl es dann einfacher w√§re zu schreiben: <br><br><pre> <code class="cpp hljs">segments.pop_back();</code> </pre> <br>  Um ehrlich zu sein, ist mir nicht ganz klar, was genau hier h√§tte geschrieben werden sollen. <br><br>  <b>Fehler N3, N4</b> <br><br>  Ich habe beschlossen, zwei Fehler zusammen zu betrachten, da sie mit einem Ressourcenleck zusammenh√§ngen und zun√§chst zeigen m√ºssen, was das Makro <i>WARN_RETURN ist</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WARN_RETURN(status)\ do\ {\ DEBUG_WARN_ERR(status);\ return status;\ }\ while(0)</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, bewirkt das Makro <i>WARN_RETURN,</i> dass die Funktion den Body verl√§sst.  Schauen wir uns nun ungenaue M√∂glichkeiten zur Verwendung dieses Makros an. <br><br>  Das erste Fragment. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sys_generate_random_bytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ FILE* f = fopen(<span class="hljs-string"><span class="hljs-string">"/dev/urandom"</span></span>, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!f) WARN_RETURN(ERR::FAIL); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> numread = fread(buf, <span class="hljs-number"><span class="hljs-number">1</span></span>, count, f); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numread == <span class="hljs-number"><span class="hljs-number">0</span></span>) WARN_RETURN(ERR::FAIL); buf += numread; count -= numread; } fclose(f); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> INFO::OK; }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V773</a> CWE-401 Die Funktion wurde beendet, ohne das ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f'</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handle loszulassen</a> .  Ein Ressourcenleck ist m√∂glich.  unix.cpp 332 <br><br>  Wenn die <i>Fread-</i> Funktion die Daten nicht lesen kann, wird die Funktion <i>sys_generate_random_bytes beendet</i> , ohne den Dateideskriptor freizugeben.  In der Praxis ist dies kaum m√∂glich.  Es ist zweifelhaft, dass Sie keine Daten aus "/ dev / urandom" lesen k√∂nnen.  Der Code ist jedoch schlampig. <br><br>  Das zweite Fragment. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sys_cursor_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... sys_cursor_impl* impl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> sys_cursor_impl; impl-&gt;image = image; impl-&gt;cursor = XcursorImageLoadCursor(wminfo.info.x11.display, image); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(impl-&gt;cursor == None) WARN_RETURN(ERR::FAIL); *cursor = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;sys_cursor&gt;(impl); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> INFO::OK; }</code> </pre> <br>  PVS-Studio Warnung: V773 CWE-401 Die Funktion wurde beendet, ohne den 'impl'-Zeiger loszulassen.  Ein Speicherverlust ist m√∂glich.  x.cpp 421 <br><br>  Wenn der Cursor nicht geladen werden kann, tritt ein Speicherverlust auf. <br><br>  <b>Fehler N5</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadHeightmapImageOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;u8&gt; fileData = <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;u8&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> u8[fileSize]); .... }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V554</a> CWE-762 Falsche Verwendung von shared_ptr.  Der mit 'new []' zugewiesene Speicher wird mit 'delete' bereinigt.  MapIO.cpp 54 <br><br>  Die richtige Option: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;u8[]&gt; fileData = <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;u8&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> u8[fileSize]);</code> </pre> <br>  <b>Fehler N6</b> <br><br><pre> <code class="cpp hljs">FUTrackedPtr(ObjectClass* _ptr = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) : ptr(_ptr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) FUTracker::TrackObject((FUTrackable*) ptr); ptr = ptr; }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V570</a> Die Variable 'ptr' wird sich selbst zugewiesen.  FUTracker.h 122 <br><br>  <b>Fehler N7, N8</b> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wstring TraceEntry::EncodeAsText() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> action = (<span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>)m_action; <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> buf[<span class="hljs-number"><span class="hljs-number">1000</span></span>]; swprintf_s(buf, ARRAY_SIZE(buf), <span class="hljs-string"><span class="hljs-string">L"%#010f: %c \"%ls\" %lu\n"</span></span>, m_timestamp, action, m_pathname.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>().c_str(), (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)m_size); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf; }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V576</a> CWE-628 Falsches Format.  √úberpr√ºfen Sie das f√ºnfte tats√§chliche Argument der Funktion 'swprintf_s'.  Das Argument vom Typ char wird erwartet.  trace.cpp 93 <br><br>  Hier sto√üen wir auf eine verwirrte und undeutliche Geschichte einer alternativen Implementierung der <i>swprintf-</i> Funktion in Visual C ++.  Ich werde es nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nacherz√§hlen</a> , sondern mich auf die Dokumentation zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V576-</a> Diagnose beziehen (siehe Abschnitt "Breite Linien"). <br><br>  In diesem Fall funktioniert dieser Code h√∂chstwahrscheinlich beim Kompilieren in Visual C ++ f√ºr Windows und beim Erstellen f√ºr Linux oder MacOS korrekt. <br><br>  √Ñhnlicher Fehler: V576 CWE-628 Falsches Format.  √úberpr√ºfen Sie das vierte tats√§chliche Argument der Funktion 'swprintf_s'.  Das Argument vom Typ char wird erwartet.  vfs_tree.cpp 211 <br><br>  <b>Fehler N9, N10, N11</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klassisch</a>  Zu Beginn wird der Zeiger verwendet und erst dann √ºberpr√ºft. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TEST_CAT2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* dst, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(dst, dst_val); <span class="hljs-comment"><span class="hljs-comment">// &lt;= int ret = strcat_s(dst, max_dst_chars, src); TS_ASSERT_EQUALS(ret, expected_ret); if(dst != 0) // &lt;= TS_ASSERT(!strcmp(dst, expected_dst)); }</span></span></code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595</a> CWE-476 Der Zeiger 'dst' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 140, 143. test_secure_crt.h 140 <br><br>  Ich denke, der Fehler bedarf keiner Erkl√§rung.  √Ñhnliche Warnungen: <br><br><ul><li>  V595 CWE-476 Der Zeiger 'dst' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 150, 153. test_secure_crt.h 150 </li><li>  V595 CWE-476 Der Zeiger 'dst' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 314, 317. test_secure_crt.h 314 </li></ul><br>  <b>Fehler N12</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tbool; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MikkTSpace::setTSpace(...., <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tbool bIsOrientationPreserving, ....) { .... m_NewVertices.push_back(bIsOrientationPreserving &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span> ? <span class="hljs-number"><span class="hljs-number">1.0f</span></span> : (<span class="hljs-number"><span class="hljs-number">-1.0f</span></span>)); .... }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V674</a> CWE-682 Das Literal '0.5' vom Typ 'double' wird mit einem Wert vom Typ 'int' verglichen.  √úberpr√ºfen Sie den Ausdruck 'bIsOrientationPreserving&gt; 0.5'.  MikktspaceWrap.cpp 137 <br><br>  Es macht keinen Sinn, eine Variable vom Typ <i>int</i> mit einer Konstanten von 0,5 zu vergleichen.  Dar√ºber hinaus ist dies in Bezug auf die Bedeutung im Allgemeinen eine Variable vom Typ Boolesch, was bedeutet, dass ein Vergleich mit 0,5 sehr seltsam aussieht.  Angenommen, anstelle von <i>bIsOrientationPreserving</i> sollte hier <i>eine</i> andere Variable verwendet werden. <br><br>  <b>Fehler N13</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VfsPath&amp; pathname, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;u8&gt;&amp; fileContents, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ ScopedLock s; VfsDirectory* directory; VfsFile* file; Status st; st = vfs_Lookup(pathname, &amp;m_rootDirectory, directory, &amp;file, VFS_LOOKUP_ADD|VFS_LOOKUP_CREATE); <span class="hljs-comment"><span class="hljs-comment">// There is no such file, create it. if (st == ERR::VFS_FILE_NOT_FOUND) { s.~ScopedLock(); return CreateFile(pathname, fileContents, size); } .... }</span></span></code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V749</a> CWE-675 Der Destruktor des 's'-Objekts wird nach Verlassen des Objektbereichs ein zweites Mal aufgerufen.  vfs.cpp 165 <br><br>  Vor dem Erstellen einer Datei muss ein Objekt vom Typ <i>ScopedLock</i> ein Objekt ‚Äûentsperren‚Äú.  Hierzu wird explizit ein Destruktor aufgerufen.  Das Problem ist, dass der Destruktor f√ºr das <i>s-</i> Objekt beim Beenden der Funktion automatisch wieder aufgerufen wird.  Das hei√üt,  Der Destruktor wird zweimal aufgerufen.  Ich habe das Ger√§t der <i>ScopedLock-</i> Klasse nicht studiert, aber Sie sollten dies auf keinen Fall tun.  Oft f√ºhrt ein solcher Doppelaufruf an den Destruktor zu undefiniertem Verhalten oder anderen unangenehmen Fehlern.  Selbst wenn der Code jetzt <i>einwandfrei</i> funktioniert, ist es sehr einfach, alles zu <i>besch√§digen,</i> indem Sie die Implementierung der <i>ScopedLock-</i> Klasse <i>√§ndern</i> . <br><br>  <b>Fehler N14, N15, N16, N17</b> <br><br><pre> <code class="cpp hljs">CFsmEvent* CFsm::AddEvent( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> eventType ) { .... pEvent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CFsmEvent( eventType ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pEvent ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... }</code> </pre> <br>  PVS-Studio Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V668</a> CWE-570 Es macht keinen Sinn, den Zeiger 'pEvent' gegen Null zu testen, da der Speicher mit dem Operator 'new' zugewiesen wurde.  Die Ausnahme wird bei einem Speicherzuordnungsfehler generiert.  fsm.cpp 259 <br><br>  Das √úberpr√ºfen des Zeigers ist nicht sinnvoll, da im Falle eines Speicherzuordnungsfehlers eine Ausnahme <i>std :: bad_alloc ausgel√∂st wird</i> . <br><br>  Die Pr√ºfung ist also √ºberfl√ºssig, aber der Fehler ist nicht schwerwiegend.  Alles ist jedoch viel schlimmer, wenn eine Logik im Hauptteil der <i>if-Anweisung ausgef√ºhrt wird</i> .  Betrachten Sie den folgenden Fall: <br><br><pre> <code class="cpp hljs">CFsmTransition* CFsm::AddTransition(....) { .... CFsmEvent* pEvent = AddEvent( eventType ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pEvent ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create new transition CFsmTransition* pNewTransition = new CFsmTransition( state ); if ( !pNewTransition ) { delete pEvent; return NULL; } .... }</span></span></code> </pre> <br>  Analyzer-Warnung: V668 CWE-570 Es macht keinen Sinn, den Zeiger 'pNewTransition' gegen Null zu testen, da der Speicher mit dem Operator 'new' zugewiesen wurde.  Die Ausnahme wird bei einem Speicherzuordnungsfehler generiert.  fsm.cpp 289 <br><br>  Es wird versucht, Speicher <i>freizugeben,</i> dessen Adresse im <i>pEvent-</i> Zeiger gespeichert ist.  Dies wird nat√ºrlich nicht passieren und ein Speicherverlust wird auftreten. <br><br>  Als ich anfing, mich mit diesem Code zu besch√§ftigen, stellte sich heraus, dass alles komplizierter war und es vielleicht nicht einen Fehler gab, sondern zwei.  Jetzt werde ich erkl√§ren, was mit diesem Code falsch ist.  Dazu m√ºssen wir uns mit dem <i>AddEvent-</i> Funktionsger√§t vertraut machen. <br><br><pre> <code class="cpp hljs">CFsmEvent* CFsm::AddEvent( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> eventType ) { CFsmEvent* pEvent = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Lookup event by type EventMap::iterator it = m_Events.find( eventType ); if ( it != m_Events.end() ) { pEvent = it-&gt;second; } else { pEvent = new CFsmEvent( eventType ); if ( !pEvent ) return NULL; // Store new event into internal map m_Events[ eventType ] = pEvent; } return pEvent; }</span></span></code> </pre> <br>  Beachten Sie, dass die Funktion nicht immer einen Zeiger auf ein neues Objekt zur√ºckgibt, das mit dem <i>neuen</i> Operator erstellt wurde.  Manchmal wird ein vorhandenes Objekt aus dem Container <i>m_Events √ºbernommen</i> .  Der Zeiger auf das neu erstellte Objekt wird √ºbrigens auch in <i>m_Events</i> platziert. <br><br>  Und hier stellt sich die Frage: <i>Wem</i> geh√∂ren die Objekte, deren Zeiger im Container <i>m_Events</i> gespeichert sind, und welche sollen sie zerst√∂ren?  Ich bin mit dem Projekt nicht vertraut, aber h√∂chstwahrscheinlich gibt es irgendwo Code, der all diese Objekte zerst√∂rt.  Das L√∂schen eines Objekts in der <i>Funktion CFsm :: AddTransition ist dann im</i> Allgemeinen √ºberfl√ºssig. <br><br>  Ich hatte den Eindruck, dass Sie einfach das folgende Codefragment l√∂schen k√∂nnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pNewTransition ) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pEvent; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  Andere Fehler: <br><br><ul><li>  V668 CWE-571 Es macht keinen Sinn, den Zeiger 'ret' gegen null zu testen, da der Speicher mit dem Operator 'new' zugewiesen wurde.  Die Ausnahme wird bei einem Speicherzuordnungsfehler generiert.  TerrainTextureEntry.cpp 120 </li><li>  V668 CWE-571 Es macht keinen Sinn, den 'Antwort'-Zeiger gegen Null zu testen, da der Speicher mit dem' neuen 'Operator zugewiesen wurde.  Die Ausnahme wird bei einem Speicherzuordnungsfehler generiert.  SoundManager.cpp 542 </li></ul><br>  <b>Fehler N18, N19</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dir_scan_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct de *de, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dir_scan_data</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dsd</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dir_scan_data</span></span></span><span class="hljs-class"> *) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dsd-&gt;entries == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || dsd-&gt;num_entries &gt;= dsd-&gt;arr_size) { dsd-&gt;arr_size *= <span class="hljs-number"><span class="hljs-number">2</span></span>; dsd-&gt;entries = (struct de *) <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(dsd-&gt;entries, dsd-&gt;arr_size * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dsd-&gt;entries[<span class="hljs-number"><span class="hljs-number">0</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dsd-&gt;entries == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// TODO(lsm): propagate an error to the caller dsd-&gt;num_entries = 0; } else { dsd-&gt;entries[dsd-&gt;num_entries].file_name = mg_strdup(de-&gt;file_name); dsd-&gt;entries[dsd-&gt;num_entries].st = de-&gt;st; dsd-&gt;entries[dsd-&gt;num_entries].conn = de-&gt;conn; dsd-&gt;num_entries++; } }</span></span></code> </pre> <br>  PVS-Studio- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warnung</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V701</a> CWE-401 realloc () m√∂gliches Leck: Wenn realloc () beim Zuweisen von Speicher fehlschl√§gt, geht der urspr√ºngliche Zeiger 'dsd-&gt; entry' verloren.  Ziehen Sie in Betracht, einem tempor√§ren Zeiger realloc () zuzuweisen.  mongoose.cpp 2462 <br><br>  Wenn die Gr√∂√üe des Arrays nicht mehr ausreicht, wird der Speicher mithilfe der <i>Realloc-</i> Funktion zugewiesen.  Der Fehler besteht darin, dass der Wert des Zeigers auf den urspr√ºnglichen Speicherblock sofort mit dem neuen Wert √ºberschrieben wird, der von der <i>Realloc-</i> Funktion zur√ºckgegeben wird. <br><br>  Wenn die Speicherzuordnung fehlschl√§gt, gibt die <i>Realloc-</i> Funktion NULL zur√ºck, und diese NULL wird in die Variable <i>dsd-&gt; entry</i> geschrieben.  Danach ist es unm√∂glich, den Speicherblock <i>freizugeben,</i> dessen Adresse zuvor in <i>dsd-&gt; Eintr√§gen</i> gespeichert wurde.  Ein Speicherverlust tritt auf. <br><br>  Ein weiterer Fehler: V701 CWE-401 realloc () m√∂gliches Leck: Wenn realloc () beim Zuweisen von Speicher fehlschl√§gt, geht der urspr√ºngliche Zeiger 'Buffer' verloren.  Ziehen Sie in Betracht, einem tempor√§ren Zeiger realloc () zuzuweisen.  Preprocessor.cpp 84 <br><br><h2>  Fazit </h2><br>  Ich kann nicht sagen, dass sich der Artikel diesmal als faszinierend herausgestellt hat oder dass ich viele schreckliche Fehler gezeigt habe.  Was zu tun ist, ist nicht erforderlich.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ich sehe, dann schreibe ich</a> . <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit.  Zur Abwechslung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beende</a> ich den Artikel mit einer Einladung, mir auf Instagram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@pvs_studio_unicorn</a> und auf Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Code_Analysis</a> zu folgen. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gute Arbeit, Autoren des Spiels 0 AD!</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420267/">https://habr.com/ru/post/de420267/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420257/index.html">Installieren Sie noch Windows 2008? Ich auch, und deshalb</a></li>
<li><a href="../de420259/index.html">Singapore Alterning Diagnostic Panel</a></li>
<li><a href="../de420261/index.html">Was werden wir messen? So w√§hlen Sie die richtigen ML-Metriken f√ºr Gesch√§ftsaufgaben aus</a></li>
<li><a href="../de420263/index.html">ServiceNow-Konferenz "Knowledge18"</a></li>
<li><a href="../de420265/index.html">Sieben Scrum-Implementierungsprobleme, von denen wir nichts wussten</a></li>
<li><a href="../de420269/index.html">Geld den Bach runter: Warum erkennt Ihr Antiphishing keine Phishing-Sites und wie funktioniert Data Science?</a></li>
<li><a href="../de420271/index.html">Empathietraining: Stimulieren neuronaler Gehirnverbindungen durch ein Videospiel</a></li>
<li><a href="../de420273/index.html">Wie ein Personenkraftwagen angeordnet ist</a></li>
<li><a href="../de420275/index.html">Gro√üe Konferenzen im Internet der Dinge in den Jahren 2018-2019. Russland und die Welt</a></li>
<li><a href="../de420277/index.html">Nach dem Goldrausch: Perspektiven der Blockchain-Technologie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>