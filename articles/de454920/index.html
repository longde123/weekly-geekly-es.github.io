<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∂üèº üñ±Ô∏è üêä Front-End-Leistung: Analysieren wichtiger Metriken üõÄüèº ü•ï üî∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter Leistung wird normalerweise die Anzahl der Vorg√§nge f√ºr ein bestimmtes Zeitintervall verstanden. Je mehr davon, desto besser. Eine solche Defini...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Front-End-Leistung: Analysieren wichtiger Metriken</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/454920/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ou/4k/ny/ou4knymbtseyhgwt9_zcalajm4s.png"></div>  Unter Leistung wird normalerweise die Anzahl der Vorg√§nge f√ºr ein bestimmtes Zeitintervall verstanden. Je mehr davon, desto besser.  Eine solche Definition und der gesamte Ansatz sind jedoch f√ºr das Front-End kaum anwendbar, da jeder Benutzer sein eigenes ‚ÄûFront-End‚Äú hat.  Dar√ºber m√∂chte ich sprechen, was ‚Äûdort‚Äú passiert, mit dem Benutzer auf der anderen Seite, in der Realit√§t und nicht auf Ihrem Top-MacBook. <br><br>  Dar√ºber hinaus werde ich versuchen, kurz die allgemeinen Regeln f√ºr die Optimierung des Codes und einige Fehler zu betrachten, die es wert sind, beachtet zu werden.  Ich erz√§hle Ihnen auch von einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tool</a> , das nicht nur bei der Profilerstellung hilft, sondern auch sofort eine Reihe grundlegender Messdaten zur Leistung Ihrer Anwendung sammelt (und ich hoffe, Sie lesen diesen Beitrag bis zum Ende). <br><a name="habracut"></a><br>  Zuerst werden wir bestimmen, was Front-End-Leistung ist, und dann werden wir fortfahren, wie man sie misst.  Wie gesagt, wir werden einige Operationen / Sek. Nicht messen, wir brauchen echte Daten, die die Frage beantworten k√∂nnen, was genau mit unserem Projekt in jeder Phase seiner Arbeit passiert.  Dazu ben√∂tigen wir die folgenden Metriken: <br><br><ul><li>  Download-Geschwindigkeit; </li><li>  Zeitpunkt des ersten Renderns und der Interaktivit√§t (Time To Interactive); </li><li>  Reaktionsgeschwindigkeit auf Benutzeraktionen; </li><li>  FPS zum Scrollen und Animieren; </li><li>  Anwendungsinitialisierung; </li><li>  Wenn Sie √ºber ein SPA verf√ºgen, m√ºssen Sie die Zeit messen, die f√ºr den Wechsel zwischen Routen aufgewendet wurde. </li><li>  Speicher- und Verkehrsverbrauch; </li><li>  und ... genug f√ºr jetzt. </li></ul><br>  All dies sind grundlegende Metriken, ohne die es unm√∂glich ist zu verstehen, was genau im Front-End passiert.  Und das nicht nur am Frontend, sondern in Wirklichkeit beim Endbenutzer.  Um diese Metriken zu erfassen, m√ºssen Sie zun√§chst lernen, wie sie gemessen werden. Erinnern wir uns also daran, welche Methoden f√ºr die Leistungsanalyse verf√ºgbar sind. <br><br>  Das erste, was Sie anfangen m√ºssen, ist nat√ºrlich die Leistungs-API.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Performance.timing</a> , mit dem Sie herausfinden k√∂nnen, wie lange ein Benutzer zum √ñffnen Ihres Projekts gebraucht hat.  Die Leistungs-API deckt jedoch nur einen Teil der Metrik ab, der Rest muss von uns selbst gemessen werden, und daf√ºr verf√ºgen wir √ºber die folgenden Tools: <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  <sub>Vorteile</sub> </th><th>  <sub>Nachteile</sub> </th></tr><tr><td>  <sub>console.time ('label')</sub> </td><td>  <sub>Funktioniert sofort.</sub> <sub><br><br></sub>  <sub>Es wird in der Konsole angezeigt.</sub> <sub><br><br></sub>  <sub>Erscheint in DevTools -&gt; Leistung -&gt; Benutzer-Timing.</sub> </td><td> Die Ausgabe erfolgt nur in DevTools. Es gibt keine M√∂glichkeit, sie an den Server zu senden (d. H. Es gibt keine M√∂glichkeit, einen Wert f√ºr weitere Analysen abzurufen). <br><br>  Ben√∂tigt <code>console.timeEnd</code> mit dem Originaletikett. <br><br>  Keine Farbcodierung. <br><br>  Keine Gruppierung (so etwas wie <code>console.group</code> / <code>groupEnd</code> ). </td></tr><tr><td>  performance.now () </td><td>  Volle Kontrolle √ºber Anfang und Ende. <br><br>  Sie k√∂nnen an den Server senden. <br><br></td><td>  Es gibt keine Anzeige in der Konsole. <br><br>  In DevTools -&gt; Leistung -&gt; Benutzer-Timing wird keine Anzeige angezeigt. <br><br>  Sie m√ºssen die Variable "start" ziehen. <br><br>  Keine Gruppierung. </td></tr><tr><td>  Leistung.Marke / Ma√ünahme </td><td>  Volle Kontrolle √ºber Anfang und Ende. <br><br>  Sie k√∂nnen an den Server senden. <br><br>  Erscheint in DevTools -&gt; Leistung -&gt; Benutzer-Timing. </td><td>  Es gibt keine Anzeige in der Konsole. <br><br>  Um etwas zu messen, m√ºssen Sie drei eindeutige Beschriftungen festlegen und zwei Methoden aufrufen. In guter Weise ben√∂tigen Sie jedoch auch <code>performance.clearMarks</code> und <code>performance.clearMeasures</code> , was die Verwendung √§u√üerst unpraktisch macht. <br><br>  Keine Gruppierung. </td></tr></tbody></table></div>  In diesem Moment wurde mir klar, dass Sie ein Werkzeug sehen m√ºssen, das die oben genannten Vorteile kombiniert und, wenn m√∂glich, keine Minuspunkte aufweist.  Da war also <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PerfKeeper</a> . <br><br><br><h2>  Perfkeeper </h2><ul><li>  Volle Kontrolle √ºber Anfang und Ende. </li><li>  Sie k√∂nnen an den Server senden. </li><li>  Es wird in der Konsole angezeigt. </li><li>  Unterst√ºtzt DevTools -&gt; Leistung -&gt; Benutzer-Timing. </li><li>  Es gibt eine Gruppierung. </li><li>  Es gibt eine Farbcodierung (sowie Ma√üeinheiten, d. H. Sie k√∂nnen nicht nur die Zeit messen). </li><li>  Unterst√ºtzt Erweiterungen. </li></ul><br>  Jetzt werde ich die API hier nicht malen, ich habe keine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> daf√ºr geschrieben, und der Artikel handelt nicht davon, aber ich werde fortfahren, wie Metriken gesammelt werden. <br><br><br><h2>  Seiten-Download-Geschwindigkeit </h2>  Wie bereits erw√§hnt, k√∂nnen Sie die Download-Geschwindigkeit unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">performance.timing ermitteln</a> . Auf diese Weise k√∂nnen Sie den gesamten Zyklus vom Beginn des Seitenladens (Zeit zum Aufl√∂sen von DNS, Installieren von HTTP Handshake, Verarbeiten der Anforderung) bis zum vollst√§ndigen Laden der Seite (DomReady und OnLoad) ermitteln: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eaf/320/48c/eaf32048c515e0a77ebeaa63e862def4.png"><br><br>  Als Ergebnis sollten Sie die folgenden Metriken erhalten: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/051/23d/b6a/05123db6af6359cc9f364b939f22fbcf.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/0d7/297/cdb/0d7297cdbd0c28f16849706a72bc54b5.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/6c0/ddc/21b/6c0ddc21b01640151d9e48b0018f2190.png"></td></tr></tbody></table></div>  <i>Ein Beispiel f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Navigationserweiterung</a> f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Das reicht aber nicht, wir haben nur die Grundwerte und wissen immer noch nicht, was genau so viel Zeit gekostet hat.  Um dies herauszufinden, m√ºssen Sie auch HTML-Metriken eingeben. <br><br>  Wie ich bereits sagte, werde ich Beispiele mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PerfKeeper</a> zeigen. Das erste, was zu tun ist, ist Inline in <code>&lt;hed/&gt;</code> PerfKeeper selbst (2,5 KB) und weiter: <img src="https://habrastorage.org/getpro/habr/post_images/dc8/a62/0b1/dc8a620b1d143b6fd2d328fed332e6ee.png"><br><br>  Infolgedessen sehen Sie solche Sch√∂nheit in der Konsole: <br><img src="https://habrastorage.org/getpro/habr/post_images/463/655/c0c/463655c0c0b6d5c23f0edb0828a4040b.png" width="350"><br><br>  Dies ist eine klassische Gro√üvater-Messmethode, die zu 100% funktioniert.  Die Welt steht jedoch nicht still, und f√ºr genauere Messungen verf√ºgen wir jetzt √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Resource Timing API</a> (und wenn sich die Ressourcen in einer separaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Timing-Allow-Origin-</a> Dom√§ne befinden, um Ihnen zu helfen). <br><br>  Und hier lohnt es sich, √ºber klassische Fehler beim ersten Laden der Seite zu sprechen, n√§mlich: <br><br><ul><li>  Mangel an GZip und HTTP / 2 (ja, das ist immer noch √ºblich); </li><li>  unangemessene Verwendung von Schriftarten (manchmal wird eine Schrift nur wegen einer Kopfzeile oder sogar einer Telefonnummer in der Fu√üzeile 0_o verbunden); </li><li>  CSS / JS-Bundles zu allgemein. </li></ul><br>  M√∂glichkeiten zum Optimieren des Seitenladens: <br><br><ul><li>  Verwenden Sie Brotli (oder sogar SDCH) anstelle von GZip und aktivieren Sie HTTP / 2. </li><li>  Sammeln Sie nur das erforderliche CSS (kritisch) und vergessen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSSO nicht</a> . </li><li>  Minimieren Sie die Gr√∂√üe des JS-B√ºndels, indem Sie das minimale CORE-B√ºndel trennen, und laden Sie den Rest nach Bedarf, d. h.  asynchron; </li><li>  Laden Sie JS und CSS im nicht blockierenden Modus, indem Sie dynamisch <code>/&gt;  &lt;sript src="..."/&gt;</code> Laden Sie JS idealerweise nach dem Hauptinhalt. </li><li>  Verwenden Sie SVG anstelle von PNG. In Kombination mit JS werden redundante XML <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Dateien entfernt</a> (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">font-awesome</a> ). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden Sie das verz√∂gerte Laden</a> sowohl f√ºr Bilder als auch f√ºr Iframes (au√üerdem wird in naher Zukunft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">native Unterst√ºtzung</a> angezeigt). </li></ul><br><br><h2>  Erste Renderzeit und Interaktivit√§t (TTI) </h2>  Die n√§chste Phase nach dem Laden ist der Moment, in dem der Benutzer das Ergebnis sah und die Benutzeroberfl√§che in den interaktiven Modus √ºberging.  Daf√ºr ben√∂tigen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Performance Paint Timing</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PerformanceObserver</a> . <br><br>  Der erste ist einfach, wir rufen <code>performance.getEntriesByType('paint')</code> und erhalten zwei Metriken: <br><br><ul><li>  First-Paint - das erste Rendering; </li><li>  first-contentful-paint - und das vollst√§ndige erste Rendern. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/ef7/230/acb/ef7230acbfdcace32596ce157bb00706.png" width="350"><br>  <i>Ein Beispiel f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farberweiterung</a> f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Aber mit der n√§chsten Metrik, Time To Interactive, ist es etwas interessanter.  Es gibt keine genaue M√∂glichkeit, festzustellen, wann Ihre Anwendung interaktiv wurde, d. H.  f√ºr den Benutzer zug√§nglich, dies kann jedoch indirekt durch das Fehlen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Langzeitaufgaben verstanden werden</a> : <br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// TTI let ttiLastEntry: PerformanceEntry | undefined; let ttiPerfObserver: PerformanceObserver; try { ttiPerfObserver = new PerformanceObserver((list) =&gt; { ttiLastEntry = list.getEntries().pop(); }); ttiPerfObserver.observe({ entryTypes: ['longtask'], }); } catch (_) {} domReady(() =&gt; { // TTI Check if (ttiPerfObserver) { let tti: number; const check = () =&gt; { if (ttiLastEntry) { tti = ttiLastEntry.startTime + ttiLastEntry.duration; if (now() - tti &gt;= options.ttiDelay) { //  logntask  ,  , //     ;] send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { setTimeout(check, options.ttiDelay); } } else if (tti) { send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { //   logntask,         , //  ,       DOMReady! tti = now(); setTimeout(check, 500); } } //   check(); } });</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/dcb/6e1/a03dcb6e138ee982ab4cd90a2c1b7f09.png" width="350"><br>  <i>Ein Beispiel f√ºr die Leistungserweiterung f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Zus√§tzlich zu diesen grundlegenden Metriken wird auch Ihre Metrik f√ºr die Anwendungsbereitschaft ben√∂tigt, d. H.  Irgendwo in Ihrem Code sollte es so sein: <pre> <code class="javascript hljs">Import { system } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@perf-tools/keeper'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationBoot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(el, data); <span class="hljs-comment"><span class="hljs-comment">//     app.ready(() =&gt; { system.add('application-ready', 0, system.perf.now()); // Ô∏èapplication-ready: 3074.000ms }); return app; }</span></span></code> </pre> <br><br><h2>  Antwortrate auf Benutzeraktionen </h2>  Es gibt ein riesiges Feld f√ºr Metriken, und sie sind sehr individuell. Daher werde ich auf zwei grundlegende Metriken eingehen, die f√ºr jedes Projekt geeignet sind, n√§mlich: <br><br>  <b>Erstes Ereignis</b> - Der Zeitpunkt des ersten Ereignisses, z. B. der erste Klick (Teilen, wo der Benutzer gesto√üen hat). Diese Metrik ist besonders relevant f√ºr alle Arten von Suchergebnissen, eine Liste von Produkten, Newsfeeds usw.  Damit k√∂nnen Sie steuern, wie sich die Reaktionszeit und der Benutzerfluss aus Ihren Aktionen (√Ñnderungen in: Design / neue Funktionen / Optimierungen usw.) √§ndern <img src="https://habrastorage.org/getpro/habr/post_images/31a/f2c/e7e/31af2ce7e1ed48f7bfc4cacc6a6ddb0e.png" width="350"><br>  <i>Ein Beispiel f√ºr die Leistungserweiterung f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  <b>Latenz</b> - Verz√∂gerung bei der Verarbeitung einiger Ereignisse, z. B. <code>click</code> , <code>input</code> , <code>submit</code> , <code>scroll</code> usw. <br><br>  Um die Verz√∂gerung zu messen, h√§ngen Sie einfach den Ereignishandler mit <code>capture = true</code> an das <code>window</code> und verwenden Sie <code>requestAnimationFrame</code> um die Differenz <code>requestAnimationFrame</code> berechnen. Dies ist die Verz√∂gerung: <pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(eventType, ({target}) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = now(); requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latency = now() - start; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latency &gt;= minLatency) { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶. } }); }, true);</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e68/e3e/07d/e68e3e07d64825c3f07175625d477283.png" width="350"><br>  <i>Ein Beispiel f√ºr die Leistungserweiterung f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper, die</a> funktioniert, wenn eine Fibonacci-Zahl mit einem Klick berechnet wird.</i> <br><br><br><h2>  FPS beim Scrollen und Animieren </h2>  Dies ist die interessanteste Metrik. Sie wird normalerweise √ºber <code>requestAnimationFrame</code> gemessen. Wenn Sie eine konstante FPS-Messung durchf√ºhren m√ºssen, reicht das klassische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FPSMeter aus</a> (obwohl dies zu optimistisch ist).  Es funktioniert jedoch √ºberhaupt nicht, wenn Sie die Laufruhe beim Scrollen von Seiten messen m√ºssen, weil  Er braucht ein Aufw√§rmen.  Und dann bin ich auf einen sehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interessanten Weg gesto√üen</a> . <br><br>  Genialerweise erstellen wir einfach ein transparentes Div (1x1px), f√ºgen einen <code>transition: left 300ms linear</code> und f√ºhren es von einer Ecke zur anderen aus. W√§hrend der Animation <code>requestAnimationFrame</code> √ºber <code>requestAnimationFrame</code> die tats√§chliche Linke. Wenn sich die neue L√§nge von der vorherigen unterscheidet, Erh√∂hen Sie dann die Anzahl der gerenderten Frames (andernfalls haben wir einen FPS-Drawdown). <br><br>  Und das ist noch nicht alles. Wenn Sie FF verwenden, gibt es einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mozPaintCount</a> , das f√ºr die Anzahl der gerenderten Frames verantwortlich ist, d. H.  Wir erinnern uns an ‚ÄûDO‚Äú und berechnen am <code>transitionend</code> die Differenz. <br><br>  Insgesamt wissen wir ohne Aufw√§rmen sicher, ob der Browser den Frame neu gezeichnet hat oder nicht. <br><br>  Sie versprechen bald eine normale API: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://wicg.github.io/frame-timing/</a> <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/5c9/17b/d15/5c917bd15c349dd2101e10ce687294c5.png" width="350"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/964/4cc/6bb/9644cc6bb9c21671b5c7c7e34b596ff8.png" width="350"></td></tr></tbody></table></div>  <i>Ein Beispiel f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fps-</a> Erweiterung f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Bildlaufoptimierung: <br><br><ul><li>  Am einfachsten ist es, nichts am <code>requestAnimationFrame</code> zu tun oder die Ausf√ºhrung durch <code>requestAnimationFrame</code> oder sogar <code>requestIdleCallback</code> . </li><li>  Verwenden Sie <code>pointer-events: none</code> sehr vorsichtig <code>pointer-events: none</code> , das Ein- und Ausschalten kann den gegenteiligen Effekt haben. Daher ist es besser, ein A / B-Experiment mit und ohne <code>pointer-events</code> durchzuf√ºhren. </li><li>  Vergessen Sie nicht die virtualisierten Listen, fast alle View-Engines verf√ºgen jetzt √ºber solche Komponenten. Seien Sie jedoch vorsichtig, die Elemente einer solchen Liste sollten so einfach wie m√∂glich sein, oder verwenden Sie "Dummies", die nach Abschluss des Bildlaufs durch echte Elemente ersetzt werden.  Wenn Sie selbst eine virtualisierte Liste schreiben, dann kein inneres HTML und vergessen Sie nicht das DOM-Recycling (in diesem Fall erstellen Sie nicht f√ºr jedes Niesen DOM-Elemente, sondern verwenden sie wieder). </li></ul><br><br><h2>  Anwendungsinitialisierung </h2>  Es gibt nur eine Regel: Details, damit Sie genau beantworten k√∂nnen, wie viel Zeit von der Initialisierung der Anwendung bis zum endg√ºltigen Start ben√∂tigt wurde.  Daher sollten Sie mindestens die folgenden Metriken erhalten: <br><br><ul><li>  wie viel Zeit es dauerte, um jede Sucht zu l√∂sen; </li><li>  Zeit, um Daten f√ºr den Antrag zu erhalten und vorzubereiten; </li><li>  Renderanwendung mit Detaillierung nach Bl√∂cken. </li></ul><br>  Das hei√üt,  Am Ausgang sollten Sie solche Metriken erhalten, anhand derer Sie genau verfolgen k√∂nnen, in welcher Phase Ihr Drawdown stattfindet. <br><br><div class="spoiler">  <b class="spoiler_title">Arbeitsbeispiel</b> <div class="spoiler_text">  <b>Konsole</b> <img src="https://habrastorage.org/getpro/habr/post_images/678/c35/91f/678c3591fc9c9d1b46481a67be2d4551.png"><br><br>  <b>Benutzer-Timing</b> <img src="https://habrastorage.org/getpro/habr/post_images/b1e/67e/8c4/b1e67e8c408d8ad929ee6e404889a593.png"></div></div><br><br><br><h2>  Wenn Sie √ºber ein SPA verf√ºgen, m√ºssen Sie die Routing-Zeit messen </h2>  Erstens sollte es eine allgemeine Metrik f√ºr die Bewertung der Leistung (Laufzeit auf der Route) als Ganzes geben, aber es ist auch erforderlich, eine Metrik f√ºr jede Route zu haben (zum Beispiel haben wir eine "Liste der Threads", "Lesen eines Threads", "Suchen" usw.). d.) sollte die Metrik selbst in Metriken unterteilt werden: <br><br><ul><li>  Daten empfangen (mit einer Aufschl√ºsselung der Daten) <ul><li>  Verarbeitung </li><li>  Update </li></ul></li><li>  Rendern <ul><li>  Gesamtanwendung </li><li>  Bl√∂cke (bei uns zum Beispiel: "Linke Spalte" (auch bekannt als "Liste der Ordner"), "Intelligente Suchleiste", "Liste der Buchstaben" und dergleichen) </li></ul></li></ul><br>  Ohne all dies ist es unm√∂glich zu verstehen, wo die Probleme beginnen, daher haben wir viele <code>startTime</code> <code>endTime</code> Module mit Timings (zum Beispiel hat dasselbe Modul f√ºr XHR <code>startTime</code> und <code>endTime</code> , die automatisch protokolliert werden). <br><br>  Diese Metriken reichen jedoch nicht aus, um das Geschehen angemessen zu bewerten.  Sie sind zu allgemein, weil  Wir sprechen √ºber SPA, dann haben Sie definitiv eine Art Laufzeit-Cache (um nicht wieder zum Server zu gehen, wenn Sie bereits dort waren), sodass unsere Metriken weiter in Routing mit und ohne Cache unterteilt sind.  Insbesondere in unserem Fall teilen wir die Metrik jedoch durch die Anzahl der darin enthaltenen Entit√§ten.  Mit anderen Worten, Sie k√∂nnen die "Thread" -Ansicht nicht mit 1, 5, 10 oder mehr als 100 Buchstaben in einer Metrik hinzuf√ºgen. Wenn also eine Liste angezeigt wird, m√ºssen Sie Haltepunkte ausw√§hlen und die Metrik weiter trennen. <br><br><br><h2>  Speicher- und Verkehrsverbrauch </h2>  <b>Beginnen wir mit der Erinnerung</b> .  Und hier warten wir auf eine gro√üe Entt√§uschung.  Im Moment gibt es nur nicht standardisierte (nur Chrome) Performance.memory, die l√§cherlich niedrige Zahlen liefert.  Dennoch m√ºssen sie gemessen werden und beobachten, wie die Anwendung im Laufe der Zeit "flie√üt": <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/985/6f9/3f0/9856f93f0823ac906bd1938f2cf1f11c.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/983/1bf/437/9831bf437924eb2ecf577f897d934e45.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/c08/e33/577/c08e335770d4fa05b70d8d653ae1b38f.png"></td></tr></tbody></table></div>  <i>Ein Beispiel f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speichererweiterung</a> f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a></i> <br><br>  <b>Verkehr</b>  Um den Datenverkehr zu z√§hlen, ben√∂tigen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Timing-Allow-Origin</a> (wenn sich die Ressourcen in einer separaten Dom√§ne befinden) und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Resource Timing API</a> . Dies hilft nicht nur, den Datenverkehr zu berechnen, sondern auch detailliert darzustellen: <br><br><ul><li>  Welches Protokoll wird verwendet (HTTP / 1, HTTP / 2 usw.)? </li><li>  Arten geladener Ressourcen; </li><li>  wie lange es gedauert hat, sie herunterzuladen; </li><li>  Gr√∂√üe k√∂nnen Sie au√üerdem verstehen, ob die Ressource in das Netzwerk geladen oder aus dem Cache entnommen wurde. </li></ul><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/c65/c03/c66/c65c03c660ea8d6bb70ee6597d643245.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/aa3/ba4/973/aa3ba4973933bebafe516ed63e779700.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/35a/a87/d0d/35aa87d0d53ca31ea88ad249bacd057a.png"></td></tr></tbody></table></div>  <i>Ein Beispiel f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ressourcenerweiterung</a> f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Was gibt Verkehr z√§hlen? <br><br><ul><li>  Das Wichtigste ist, dass Sie das reale Bild sehen k√∂nnen und nicht wie bei CSS + JS √ºblich und dar√ºber hinaus, wie sich dieses ‚ÄûBild‚Äú im Laufe der Zeit √§ndert. </li><li>  Anschlie√üend k√∂nnen Sie analysieren, was genau geladen ist, Ressourcen in Gruppen aufteilen usw. </li><li>  Wie gut das Caching f√ºr Sie funktioniert. </li><li>  Gibt es Anomalien, zum Beispiel nach 15 Minuten Betrieb, zum Beispiel, der Code wurde rekursiv und l√§dt einige Ressourcen endlos. Die √úberwachung des Datenverkehrs hilft dabei. </li></ul><br>  Nun, ein Nachholbericht meines Kollegen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Igor Druzhinin</a> zu diesem Thema: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bewertung der Qualit√§t der Anwendung - √úberwachung des Verkehrsverbrauchs</a> <br><br><br><h2>  Analytik </h2>  Wir richten die Metriken ein und was dann?  Und dann m√ºssen sie irgendwohin geschickt werden.  Und hier holen Sie entweder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Graphit von Ihnen ab</a> oder Sie k√∂nnen zun√§chst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Analytics</a> oder √§hnliches f√ºr die Datenaggregation verwenden, um pers√∂nliche Vorteile zu erzielen. <br><br>  Und vergessen Sie nicht, es reicht nicht aus, nur ein Diagramm zu erstellen. F√ºr alle wichtigen Metriken sollten Perzentile vorhanden sein, mit denen Sie beispielsweise verstehen k√∂nnen, wie viel Prozent der Zielgruppe das Projekt f√ºr &lt;1s, &lt;2s, &lt;3s, &lt;5s, 5s + usw. l√§dt. <br><br><br><h2>  Schreiben eines Hochleistungscodes </h2>  Zuerst wollte ich hier etwas Sinnvolles schreiben, sie sagen, benutze WebWorker, vergiss nicht <code>requestIdleCallback</code> oder etwas Exotisches, zum Beispiel durch Runtime Cache √ºber Browser-Registerkarten mit SharedWorker oder ServiceWorker (was nicht nur Caching betrifft, wenn das so ist).  Aber das ist alles sehr abstrakt und viele Themen sind unm√∂glich, also schreiben Sie einfach Folgendes: <br><br><ol><li>  Decken Sie Ihren Code zun√§chst mit Metriken ab, mit denen die Leistung gemessen wird. </li><li>  Glauben Sie den Benchmarks mit jsperf nicht.  Die √ºberwiegende Mehrheit von ihnen ist schlecht geschrieben und einfach aus dem Zusammenhang gerissen.  Der beste Benchmark ist die tats√§chliche Metrik f√ºr das Projekt, anhand derer Sie die Auswirkungen Ihrer Aktionen sehen k√∂nnen. </li><li>  Denken Sie an die Wahrnehmung von Produktivit√§t oder vielmehr an das Weber-Fechner-Gesetz.  Wenn Sie mit der Optimierung begonnen haben, rollen Sie die √Ñnderungen erst aus, wenn sie mindestens um 20% besser werden. Andernfalls werden Benutzer dies einfach nicht bemerken.  Das Gesetz wirkt auch in die entgegengesetzte Richtung. </li><li>  F√ºrchte Stammg√§ste, besonders die generierten.  Sie k√∂nnen nicht nur den Browser h√§ngen, sondern auch XSS erhalten, weshalb es in unserer Mail verboten ist, HTML mit ihnen nur √ºber einen DOM-Bypass zu analysieren. </li><li>  Sie m√ºssen keine Arrays verwenden, um einen Wert in die eine oder andere Gruppe <code>successSteps.includes(currentStep)</code> gibt es ein <code>object</code> oder einen <code>Set</code> (z. B. wird <code>successSteps.includes(currentStep)</code> <code>successSteps.hasOwnProperty(currentStep)</code> <code>successSteps.includes(currentStep)</code> ben√∂tigt). O (1) ist alles. </li><li>  Bei dem Ausdruck "Vorzeitige Optimierung ist die Wurzel aller √úbel" geht es nicht darum, zu schreiben, was immer Sie wollen.  Wenn Sie wissen, wie am besten, schreiben Sie optimal. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Ich werde ein paar Abs√§tze √ºber den Code und seine Optimierung schreiben</b> <div class="spoiler_text">  <b>DOM</b>  Sehr oft h√∂re ich "Das Problem im DOM" - das ist nat√ºrlich wahr, aber da fast jeder jetzt eine Abstraktion dar√ºber hat.  Sie ist es, die zum Engpass oder vielmehr zu Ihrem Code wird, der f√ºr die Bildung der Ansicht und der Gesch√§ftslogik verantwortlich ist. <br><br>  Wenn wir zum Beispiel √ºber das DOM sprechen, anstatt ein Fragment aus dem DOM zu l√∂schen, ist es besser, es auszublenden oder zu entfernen.  Wenn Sie noch l√∂schen m√ºssen, f√ºhren Sie diesen Vorgang in <code>requestIdleCallback</code> (falls m√∂glich), oder teilen Sie den Zerst√∂rungsprozess in zwei Phasen auf: synchron und asynchron. <br><br>  Ich werde sofort eine Reservierung vornehmen. Verwenden Sie diesen Ansatz mit Bedacht, da Sie sonst auf Ihr Knie schie√üen k√∂nnen. <br><br>  Wir verwenden auch eine andere interessante Technik f√ºr Listen, zum Beispiel die ‚ÄûListe der Themen‚Äú.  Das Wesentliche der Technik ist, dass anstelle einer globalen "Liste" und der Aktualisierung ihrer Daten f√ºr jeden "Ordner" eine "Liste der Threads" generiert wird.  Wenn der Benutzer zwischen den "Ordnern" navigiert, wird eine Liste aus dem DOM entfernt (nicht gel√∂scht) und die andere entweder teilweise oder gar nicht aktualisiert.  Und nicht alle, wie es bei der "Single List" der Fall ist. <br><br>  All dies gibt eine sofortige Reaktion auf Benutzeraktionen. <br><br>  <b>Mathe</b>  Wir entfernen problemlos alle Berechnungen in Worker oder WebAssembly. Dies funktioniert seit langer Zeit. <br><br>  <b>Transpiler</b> .  Oh, viele glauben nicht einmal, dass der Code, den sie schreiben, durch den Transpiler geht.  Ja, sie wissen von ihm, aber das ist alles.  Aber was macht er daraus, dass sie sich nicht mehr darum k√ºmmern.  In DevTools sehen sie tats√§chlich das Ergebnis der Quellkarte. <br><br>  Studieren Sie daher die Werkzeuge, die Sie verwenden, z. B. hat dasselbe Babel auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spielplatz</a> die M√∂glichkeit zu sehen, in welchem ‚Äã‚ÄãCode es abh√§ngig von den ausgew√§hlten Voreinstellungen generiert wird. Schauen Sie sich einfach dasselbe Jahr <code>yeild</code> , <code>await</code> oder <code>await</code> <code>for of</code> . <br><br>  <b>Die Feinheiten der Zunge</b> .  Noch weniger Leute wissen √ºber den Monomorphismus des Codes Bescheid oder wissen, warum das Binden langsam ist und ... Sie verwenden endlich <code>handleEvent</code> ! <br><br>  <b>Daten und Prekreshing</b> .  Weniger Anfragen, mehr Caching.  Au√üerdem verwenden wir sehr oft die Technik der "Voraussicht", wenn wir im Hintergrund Daten laden.  Nach dem Rendern der ‚ÄûThread-Liste‚Äú laden wir beispielsweise N-ungelesene Threads in den aktuellen ‚ÄûOrdner‚Äú, sodass der Benutzer beim Klicken sofort zu ‚ÄûLesen‚Äú und nicht zu einem anderen ‚ÄûLoader‚Äú wechselt.  Wir verwenden eine √§hnliche Technik nicht nur f√ºr Daten, sondern auch f√ºr JS.  Zum Beispiel ist ‚ÄûSchreiben eines Briefes‚Äú ein riesiges B√ºndel (wegen des Editors), und nicht alle Leute schreiben Briefe gleichzeitig. Deshalb laden wir es nach der Initialisierung der Anwendung im Hintergrund. <br><br>  <b>Lauter</b>  Ich wei√ü nicht warum, aber ich habe keine Artikel gesehen, in denen gelehrt wurde, wie man keinen Lader herstellt, sondern eine Pr√§sentation der "zuk√ºnftigen" Reaktion, in der viel Zeit f√ºr dieses Problem in Suspense aufgewendet wurde.  Immerhin ist die ideale Anwendung ohne Lader, wir haben lange in der Mail versucht, sie nur in Notsituationen anzuzeigen. <br><br>  Im Allgemeinen haben wir eine solche Richtlinie, es gibt keine Daten, es gibt keine Ansicht, es gibt nichts, um eine Semi-Schnittstelle zu zeichnen, zuerst laden wir die Daten und erst dann "zeichnen".  Aus diesem Grund verwenden wir die ‚ÄûVoraussicht‚Äú, wohin der Benutzer gehen und diese Daten laden wird, damit der Benutzer den Loader nicht sieht.  Dar√ºber hinaus hilft unsere Datenschicht, die dauerhaft ist, bei dieser Aufgabe sehr.  Wenn Sie irgendwo an einem Ort "Thread" angefordert haben, wird beim n√§chsten Anfordern von einem anderen oder demselben Ort keine Anfrage gestellt. Wir nehmen Daten aus dem Laufzeit-Cache (genauer gesagt, einen Link zu den Daten).  Und so sind Sammlungen von Threads in allem auch nur Links zu Daten. <br><br>  Wenn Sie sich dennoch f√ºr einen Lader entscheiden, vergessen Sie nicht die Grundregeln, die Ihren Lader weniger nerven: <ul><li>  Es ist nicht erforderlich, den Loader sofort zu zeigen. Zum Zeitpunkt des Sendens der Anfrage sollte eine Verz√∂gerung von mindestens 300-500 ms vor der Show auftreten. </li><li>  Nach dem Empfang der Daten m√ºssen Sie den Loader nicht scharf entfernen, auch hier sollte es zu einer Verz√∂gerung kommen. </li></ul><br>  Diese einfachen Regeln werden ben√∂tigt, damit der Loader nur bei starken Anforderungen angezeigt wird und nach Abschluss nicht ‚Äûblinkt‚Äú.  Am wichtigsten ist jedoch, dass der beste Lader ein Lader ist, der nicht angezeigt wurde. </div></div><br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit, das ist alles, messen, analysieren und verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PerfKeeper</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Live-Beispiel</a> ) sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinen Github</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter</a> bei Fragen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454920/">https://habr.com/ru/post/de454920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454900/index.html">So machen Sie Webformulare auf der Website bequem und sicher: Entwicklungstools und Konstruktoren</a></li>
<li><a href="../de454904/index.html">Samsung startet kostenlosen Online-Kurs f√ºr Computer Vision Neural Network</a></li>
<li><a href="../de454912/index.html">Die Zwergenfestung Tarn Adams spricht √ºber die Spieleentwicklung</a></li>
<li><a href="../de454916/index.html">Neuronale Netzwerkarchitektur zur Implementierung des RL-Algorithmus mit der F√§higkeit, gleichzeitig laufende Aktionen festzulegen</a></li>
<li><a href="../de454918/index.html">So kombinieren Sie den R√ºcken zweier Einzelh√§ndler in SAP in 12 Stunden</a></li>
<li><a href="../de454922/index.html">Geschichten √ºber ausl√§ndische Kunden und ihre Arbeitsmerkmale in Russland nach dem PD-Gesetz</a></li>
<li><a href="../de454924/index.html">Authentifizierungseinstellungen in Veeam Backup f√ºr Microsoft Office 365 v3</a></li>
<li><a href="../de454926/index.html">Alles, was Sie √ºber word2vec wussten, ist nicht wahr</a></li>
<li><a href="../de454928/index.html">M√∂glichkeit, den Windows-Sperrbildschirm in RDP-Sitzungen zu umgehen</a></li>
<li><a href="../de454932/index.html">Investitionen und Software: 5 Handelsterminals f√ºr den Handel an der B√∂rse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>