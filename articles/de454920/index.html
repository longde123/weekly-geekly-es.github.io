<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏼 🖱️ 🐊 Front-End-Leistung: Analysieren wichtiger Metriken 🛀🏼 🥕 🔷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter Leistung wird normalerweise die Anzahl der Vorgänge für ein bestimmtes Zeitintervall verstanden. Je mehr davon, desto besser. Eine solche Defini...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Front-End-Leistung: Analysieren wichtiger Metriken</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/454920/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ou/4k/ny/ou4knymbtseyhgwt9_zcalajm4s.png"></div>  Unter Leistung wird normalerweise die Anzahl der Vorgänge für ein bestimmtes Zeitintervall verstanden. Je mehr davon, desto besser.  Eine solche Definition und der gesamte Ansatz sind jedoch für das Front-End kaum anwendbar, da jeder Benutzer sein eigenes „Front-End“ hat.  Darüber möchte ich sprechen, was „dort“ passiert, mit dem Benutzer auf der anderen Seite, in der Realität und nicht auf Ihrem Top-MacBook. <br><br>  Darüber hinaus werde ich versuchen, kurz die allgemeinen Regeln für die Optimierung des Codes und einige Fehler zu betrachten, die es wert sind, beachtet zu werden.  Ich erzähle Ihnen auch von einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tool</a> , das nicht nur bei der Profilerstellung hilft, sondern auch sofort eine Reihe grundlegender Messdaten zur Leistung Ihrer Anwendung sammelt (und ich hoffe, Sie lesen diesen Beitrag bis zum Ende). <br><a name="habracut"></a><br>  Zuerst werden wir bestimmen, was Front-End-Leistung ist, und dann werden wir fortfahren, wie man sie misst.  Wie gesagt, wir werden einige Operationen / Sek. Nicht messen, wir brauchen echte Daten, die die Frage beantworten können, was genau mit unserem Projekt in jeder Phase seiner Arbeit passiert.  Dazu benötigen wir die folgenden Metriken: <br><br><ul><li>  Download-Geschwindigkeit; </li><li>  Zeitpunkt des ersten Renderns und der Interaktivität (Time To Interactive); </li><li>  Reaktionsgeschwindigkeit auf Benutzeraktionen; </li><li>  FPS zum Scrollen und Animieren; </li><li>  Anwendungsinitialisierung; </li><li>  Wenn Sie über ein SPA verfügen, müssen Sie die Zeit messen, die für den Wechsel zwischen Routen aufgewendet wurde. </li><li>  Speicher- und Verkehrsverbrauch; </li><li>  und ... genug für jetzt. </li></ul><br>  All dies sind grundlegende Metriken, ohne die es unmöglich ist zu verstehen, was genau im Front-End passiert.  Und das nicht nur am Frontend, sondern in Wirklichkeit beim Endbenutzer.  Um diese Metriken zu erfassen, müssen Sie zunächst lernen, wie sie gemessen werden. Erinnern wir uns also daran, welche Methoden für die Leistungsanalyse verfügbar sind. <br><br>  Das erste, was Sie anfangen müssen, ist natürlich die Leistungs-API.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Performance.timing</a> , mit dem Sie herausfinden können, wie lange ein Benutzer zum Öffnen Ihres Projekts gebraucht hat.  Die Leistungs-API deckt jedoch nur einen Teil der Metrik ab, der Rest muss von uns selbst gemessen werden, und dafür verfügen wir über die folgenden Tools: <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  <sub>Vorteile</sub> </th><th>  <sub>Nachteile</sub> </th></tr><tr><td>  <sub>console.time ('label')</sub> </td><td>  <sub>Funktioniert sofort.</sub> <sub><br><br></sub>  <sub>Es wird in der Konsole angezeigt.</sub> <sub><br><br></sub>  <sub>Erscheint in DevTools -&gt; Leistung -&gt; Benutzer-Timing.</sub> </td><td> Die Ausgabe erfolgt nur in DevTools. Es gibt keine Möglichkeit, sie an den Server zu senden (d. H. Es gibt keine Möglichkeit, einen Wert für weitere Analysen abzurufen). <br><br>  Benötigt <code>console.timeEnd</code> mit dem Originaletikett. <br><br>  Keine Farbcodierung. <br><br>  Keine Gruppierung (so etwas wie <code>console.group</code> / <code>groupEnd</code> ). </td></tr><tr><td>  performance.now () </td><td>  Volle Kontrolle über Anfang und Ende. <br><br>  Sie können an den Server senden. <br><br></td><td>  Es gibt keine Anzeige in der Konsole. <br><br>  In DevTools -&gt; Leistung -&gt; Benutzer-Timing wird keine Anzeige angezeigt. <br><br>  Sie müssen die Variable "start" ziehen. <br><br>  Keine Gruppierung. </td></tr><tr><td>  Leistung.Marke / Maßnahme </td><td>  Volle Kontrolle über Anfang und Ende. <br><br>  Sie können an den Server senden. <br><br>  Erscheint in DevTools -&gt; Leistung -&gt; Benutzer-Timing. </td><td>  Es gibt keine Anzeige in der Konsole. <br><br>  Um etwas zu messen, müssen Sie drei eindeutige Beschriftungen festlegen und zwei Methoden aufrufen. In guter Weise benötigen Sie jedoch auch <code>performance.clearMarks</code> und <code>performance.clearMeasures</code> , was die Verwendung äußerst unpraktisch macht. <br><br>  Keine Gruppierung. </td></tr></tbody></table></div>  In diesem Moment wurde mir klar, dass Sie ein Werkzeug sehen müssen, das die oben genannten Vorteile kombiniert und, wenn möglich, keine Minuspunkte aufweist.  Da war also <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PerfKeeper</a> . <br><br><br><h2>  Perfkeeper </h2><ul><li>  Volle Kontrolle über Anfang und Ende. </li><li>  Sie können an den Server senden. </li><li>  Es wird in der Konsole angezeigt. </li><li>  Unterstützt DevTools -&gt; Leistung -&gt; Benutzer-Timing. </li><li>  Es gibt eine Gruppierung. </li><li>  Es gibt eine Farbcodierung (sowie Maßeinheiten, d. H. Sie können nicht nur die Zeit messen). </li><li>  Unterstützt Erweiterungen. </li></ul><br>  Jetzt werde ich die API hier nicht malen, ich habe keine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> dafür geschrieben, und der Artikel handelt nicht davon, aber ich werde fortfahren, wie Metriken gesammelt werden. <br><br><br><h2>  Seiten-Download-Geschwindigkeit </h2>  Wie bereits erwähnt, können Sie die Download-Geschwindigkeit unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">performance.timing ermitteln</a> . Auf diese Weise können Sie den gesamten Zyklus vom Beginn des Seitenladens (Zeit zum Auflösen von DNS, Installieren von HTTP Handshake, Verarbeiten der Anforderung) bis zum vollständigen Laden der Seite (DomReady und OnLoad) ermitteln: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eaf/320/48c/eaf32048c515e0a77ebeaa63e862def4.png"><br><br>  Als Ergebnis sollten Sie die folgenden Metriken erhalten: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/051/23d/b6a/05123db6af6359cc9f364b939f22fbcf.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/0d7/297/cdb/0d7297cdbd0c28f16849706a72bc54b5.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/6c0/ddc/21b/6c0ddc21b01640151d9e48b0018f2190.png"></td></tr></tbody></table></div>  <i>Ein Beispiel für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Navigationserweiterung</a> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Das reicht aber nicht, wir haben nur die Grundwerte und wissen immer noch nicht, was genau so viel Zeit gekostet hat.  Um dies herauszufinden, müssen Sie auch HTML-Metriken eingeben. <br><br>  Wie ich bereits sagte, werde ich Beispiele mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PerfKeeper</a> zeigen. Das erste, was zu tun ist, ist Inline in <code>&lt;hed/&gt;</code> PerfKeeper selbst (2,5 KB) und weiter: <img src="https://habrastorage.org/getpro/habr/post_images/dc8/a62/0b1/dc8a620b1d143b6fd2d328fed332e6ee.png"><br><br>  Infolgedessen sehen Sie solche Schönheit in der Konsole: <br><img src="https://habrastorage.org/getpro/habr/post_images/463/655/c0c/463655c0c0b6d5c23f0edb0828a4040b.png" width="350"><br><br>  Dies ist eine klassische Großvater-Messmethode, die zu 100% funktioniert.  Die Welt steht jedoch nicht still, und für genauere Messungen verfügen wir jetzt über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Resource Timing API</a> (und wenn sich die Ressourcen in einer separaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Timing-Allow-Origin-</a> Domäne befinden, um Ihnen zu helfen). <br><br>  Und hier lohnt es sich, über klassische Fehler beim ersten Laden der Seite zu sprechen, nämlich: <br><br><ul><li>  Mangel an GZip und HTTP / 2 (ja, das ist immer noch üblich); </li><li>  unangemessene Verwendung von Schriftarten (manchmal wird eine Schrift nur wegen einer Kopfzeile oder sogar einer Telefonnummer in der Fußzeile 0_o verbunden); </li><li>  CSS / JS-Bundles zu allgemein. </li></ul><br>  Möglichkeiten zum Optimieren des Seitenladens: <br><br><ul><li>  Verwenden Sie Brotli (oder sogar SDCH) anstelle von GZip und aktivieren Sie HTTP / 2. </li><li>  Sammeln Sie nur das erforderliche CSS (kritisch) und vergessen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSSO nicht</a> . </li><li>  Minimieren Sie die Größe des JS-Bündels, indem Sie das minimale CORE-Bündel trennen, und laden Sie den Rest nach Bedarf, d. h.  asynchron; </li><li>  Laden Sie JS und CSS im nicht blockierenden Modus, indem Sie dynamisch <code>/&gt;  &lt;sript src="..."/&gt;</code> Laden Sie JS idealerweise nach dem Hauptinhalt. </li><li>  Verwenden Sie SVG anstelle von PNG. In Kombination mit JS werden redundante XML <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Dateien entfernt</a> (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">font-awesome</a> ). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden Sie das verzögerte Laden</a> sowohl für Bilder als auch für Iframes (außerdem wird in naher Zukunft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">native Unterstützung</a> angezeigt). </li></ul><br><br><h2>  Erste Renderzeit und Interaktivität (TTI) </h2>  Die nächste Phase nach dem Laden ist der Moment, in dem der Benutzer das Ergebnis sah und die Benutzeroberfläche in den interaktiven Modus überging.  Dafür benötigen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Performance Paint Timing</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PerformanceObserver</a> . <br><br>  Der erste ist einfach, wir rufen <code>performance.getEntriesByType('paint')</code> und erhalten zwei Metriken: <br><br><ul><li>  First-Paint - das erste Rendering; </li><li>  first-contentful-paint - und das vollständige erste Rendern. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/ef7/230/acb/ef7230acbfdcace32596ce157bb00706.png" width="350"><br>  <i>Ein Beispiel für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farberweiterung</a> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Aber mit der nächsten Metrik, Time To Interactive, ist es etwas interessanter.  Es gibt keine genaue Möglichkeit, festzustellen, wann Ihre Anwendung interaktiv wurde, d. H.  für den Benutzer zugänglich, dies kann jedoch indirekt durch das Fehlen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Langzeitaufgaben verstanden werden</a> : <br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// TTI let ttiLastEntry: PerformanceEntry | undefined; let ttiPerfObserver: PerformanceObserver; try { ttiPerfObserver = new PerformanceObserver((list) =&gt; { ttiLastEntry = list.getEntries().pop(); }); ttiPerfObserver.observe({ entryTypes: ['longtask'], }); } catch (_) {} domReady(() =&gt; { // TTI Check if (ttiPerfObserver) { let tti: number; const check = () =&gt; { if (ttiLastEntry) { tti = ttiLastEntry.startTime + ttiLastEntry.duration; if (now() - tti &gt;= options.ttiDelay) { //  logntask  ,  , //     ;] send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { setTimeout(check, options.ttiDelay); } } else if (tti) { send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { //   logntask,         , //  ,       DOMReady! tti = now(); setTimeout(check, 500); } } //   check(); } });</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/dcb/6e1/a03dcb6e138ee982ab4cd90a2c1b7f09.png" width="350"><br>  <i>Ein Beispiel für die Leistungserweiterung für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Zusätzlich zu diesen grundlegenden Metriken wird auch Ihre Metrik für die Anwendungsbereitschaft benötigt, d. H.  Irgendwo in Ihrem Code sollte es so sein: <pre> <code class="javascript hljs">Import { system } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@perf-tools/keeper'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationBoot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(el, data); <span class="hljs-comment"><span class="hljs-comment">//     app.ready(() =&gt; { system.add('application-ready', 0, system.perf.now()); // ️application-ready: 3074.000ms }); return app; }</span></span></code> </pre> <br><br><h2>  Antwortrate auf Benutzeraktionen </h2>  Es gibt ein riesiges Feld für Metriken, und sie sind sehr individuell. Daher werde ich auf zwei grundlegende Metriken eingehen, die für jedes Projekt geeignet sind, nämlich: <br><br>  <b>Erstes Ereignis</b> - Der Zeitpunkt des ersten Ereignisses, z. B. der erste Klick (Teilen, wo der Benutzer gestoßen hat). Diese Metrik ist besonders relevant für alle Arten von Suchergebnissen, eine Liste von Produkten, Newsfeeds usw.  Damit können Sie steuern, wie sich die Reaktionszeit und der Benutzerfluss aus Ihren Aktionen (Änderungen in: Design / neue Funktionen / Optimierungen usw.) ändern <img src="https://habrastorage.org/getpro/habr/post_images/31a/f2c/e7e/31af2ce7e1ed48f7bfc4cacc6a6ddb0e.png" width="350"><br>  <i>Ein Beispiel für die Leistungserweiterung für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  <b>Latenz</b> - Verzögerung bei der Verarbeitung einiger Ereignisse, z. B. <code>click</code> , <code>input</code> , <code>submit</code> , <code>scroll</code> usw. <br><br>  Um die Verzögerung zu messen, hängen Sie einfach den Ereignishandler mit <code>capture = true</code> an das <code>window</code> und verwenden Sie <code>requestAnimationFrame</code> um die Differenz <code>requestAnimationFrame</code> berechnen. Dies ist die Verzögerung: <pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(eventType, ({target}) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = now(); requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latency = now() - start; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latency &gt;= minLatency) { <span class="hljs-comment"><span class="hljs-comment">// …. } }); }, true);</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e68/e3e/07d/e68e3e07d64825c3f07175625d477283.png" width="350"><br>  <i>Ein Beispiel für die Leistungserweiterung für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper, die</a> funktioniert, wenn eine Fibonacci-Zahl mit einem Klick berechnet wird.</i> <br><br><br><h2>  FPS beim Scrollen und Animieren </h2>  Dies ist die interessanteste Metrik. Sie wird normalerweise über <code>requestAnimationFrame</code> gemessen. Wenn Sie eine konstante FPS-Messung durchführen müssen, reicht das klassische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FPSMeter aus</a> (obwohl dies zu optimistisch ist).  Es funktioniert jedoch überhaupt nicht, wenn Sie die Laufruhe beim Scrollen von Seiten messen müssen, weil  Er braucht ein Aufwärmen.  Und dann bin ich auf einen sehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interessanten Weg gestoßen</a> . <br><br>  Genialerweise erstellen wir einfach ein transparentes Div (1x1px), fügen einen <code>transition: left 300ms linear</code> und führen es von einer Ecke zur anderen aus. Während der Animation <code>requestAnimationFrame</code> über <code>requestAnimationFrame</code> die tatsächliche Linke. Wenn sich die neue Länge von der vorherigen unterscheidet, Erhöhen Sie dann die Anzahl der gerenderten Frames (andernfalls haben wir einen FPS-Drawdown). <br><br>  Und das ist noch nicht alles. Wenn Sie FF verwenden, gibt es einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mozPaintCount</a> , das für die Anzahl der gerenderten Frames verantwortlich ist, d. H.  Wir erinnern uns an „DO“ und berechnen am <code>transitionend</code> die Differenz. <br><br>  Insgesamt wissen wir ohne Aufwärmen sicher, ob der Browser den Frame neu gezeichnet hat oder nicht. <br><br>  Sie versprechen bald eine normale API: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://wicg.github.io/frame-timing/</a> <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/5c9/17b/d15/5c917bd15c349dd2101e10ce687294c5.png" width="350"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/964/4cc/6bb/9644cc6bb9c21671b5c7c7e34b596ff8.png" width="350"></td></tr></tbody></table></div>  <i>Ein Beispiel für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fps-</a> Erweiterung für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Bildlaufoptimierung: <br><br><ul><li>  Am einfachsten ist es, nichts am <code>requestAnimationFrame</code> zu tun oder die Ausführung durch <code>requestAnimationFrame</code> oder sogar <code>requestIdleCallback</code> . </li><li>  Verwenden Sie <code>pointer-events: none</code> sehr vorsichtig <code>pointer-events: none</code> , das Ein- und Ausschalten kann den gegenteiligen Effekt haben. Daher ist es besser, ein A / B-Experiment mit und ohne <code>pointer-events</code> durchzuführen. </li><li>  Vergessen Sie nicht die virtualisierten Listen, fast alle View-Engines verfügen jetzt über solche Komponenten. Seien Sie jedoch vorsichtig, die Elemente einer solchen Liste sollten so einfach wie möglich sein, oder verwenden Sie "Dummies", die nach Abschluss des Bildlaufs durch echte Elemente ersetzt werden.  Wenn Sie selbst eine virtualisierte Liste schreiben, dann kein inneres HTML und vergessen Sie nicht das DOM-Recycling (in diesem Fall erstellen Sie nicht für jedes Niesen DOM-Elemente, sondern verwenden sie wieder). </li></ul><br><br><h2>  Anwendungsinitialisierung </h2>  Es gibt nur eine Regel: Details, damit Sie genau beantworten können, wie viel Zeit von der Initialisierung der Anwendung bis zum endgültigen Start benötigt wurde.  Daher sollten Sie mindestens die folgenden Metriken erhalten: <br><br><ul><li>  wie viel Zeit es dauerte, um jede Sucht zu lösen; </li><li>  Zeit, um Daten für den Antrag zu erhalten und vorzubereiten; </li><li>  Renderanwendung mit Detaillierung nach Blöcken. </li></ul><br>  Das heißt,  Am Ausgang sollten Sie solche Metriken erhalten, anhand derer Sie genau verfolgen können, in welcher Phase Ihr Drawdown stattfindet. <br><br><div class="spoiler">  <b class="spoiler_title">Arbeitsbeispiel</b> <div class="spoiler_text">  <b>Konsole</b> <img src="https://habrastorage.org/getpro/habr/post_images/678/c35/91f/678c3591fc9c9d1b46481a67be2d4551.png"><br><br>  <b>Benutzer-Timing</b> <img src="https://habrastorage.org/getpro/habr/post_images/b1e/67e/8c4/b1e67e8c408d8ad929ee6e404889a593.png"></div></div><br><br><br><h2>  Wenn Sie über ein SPA verfügen, müssen Sie die Routing-Zeit messen </h2>  Erstens sollte es eine allgemeine Metrik für die Bewertung der Leistung (Laufzeit auf der Route) als Ganzes geben, aber es ist auch erforderlich, eine Metrik für jede Route zu haben (zum Beispiel haben wir eine "Liste der Threads", "Lesen eines Threads", "Suchen" usw.). d.) sollte die Metrik selbst in Metriken unterteilt werden: <br><br><ul><li>  Daten empfangen (mit einer Aufschlüsselung der Daten) <ul><li>  Verarbeitung </li><li>  Update </li></ul></li><li>  Rendern <ul><li>  Gesamtanwendung </li><li>  Blöcke (bei uns zum Beispiel: "Linke Spalte" (auch bekannt als "Liste der Ordner"), "Intelligente Suchleiste", "Liste der Buchstaben" und dergleichen) </li></ul></li></ul><br>  Ohne all dies ist es unmöglich zu verstehen, wo die Probleme beginnen, daher haben wir viele <code>startTime</code> <code>endTime</code> Module mit Timings (zum Beispiel hat dasselbe Modul für XHR <code>startTime</code> und <code>endTime</code> , die automatisch protokolliert werden). <br><br>  Diese Metriken reichen jedoch nicht aus, um das Geschehen angemessen zu bewerten.  Sie sind zu allgemein, weil  Wir sprechen über SPA, dann haben Sie definitiv eine Art Laufzeit-Cache (um nicht wieder zum Server zu gehen, wenn Sie bereits dort waren), sodass unsere Metriken weiter in Routing mit und ohne Cache unterteilt sind.  Insbesondere in unserem Fall teilen wir die Metrik jedoch durch die Anzahl der darin enthaltenen Entitäten.  Mit anderen Worten, Sie können die "Thread" -Ansicht nicht mit 1, 5, 10 oder mehr als 100 Buchstaben in einer Metrik hinzufügen. Wenn also eine Liste angezeigt wird, müssen Sie Haltepunkte auswählen und die Metrik weiter trennen. <br><br><br><h2>  Speicher- und Verkehrsverbrauch </h2>  <b>Beginnen wir mit der Erinnerung</b> .  Und hier warten wir auf eine große Enttäuschung.  Im Moment gibt es nur nicht standardisierte (nur Chrome) Performance.memory, die lächerlich niedrige Zahlen liefert.  Dennoch müssen sie gemessen werden und beobachten, wie die Anwendung im Laufe der Zeit "fließt": <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/985/6f9/3f0/9856f93f0823ac906bd1938f2cf1f11c.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/983/1bf/437/9831bf437924eb2ecf577f897d934e45.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/c08/e33/577/c08e335770d4fa05b70d8d653ae1b38f.png"></td></tr></tbody></table></div>  <i>Ein Beispiel für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speichererweiterung</a> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a></i> <br><br>  <b>Verkehr</b>  Um den Datenverkehr zu zählen, benötigen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Timing-Allow-Origin</a> (wenn sich die Ressourcen in einer separaten Domäne befinden) und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Resource Timing API</a> . Dies hilft nicht nur, den Datenverkehr zu berechnen, sondern auch detailliert darzustellen: <br><br><ul><li>  Welches Protokoll wird verwendet (HTTP / 1, HTTP / 2 usw.)? </li><li>  Arten geladener Ressourcen; </li><li>  wie lange es gedauert hat, sie herunterzuladen; </li><li>  Größe können Sie außerdem verstehen, ob die Ressource in das Netzwerk geladen oder aus dem Cache entnommen wurde. </li></ul><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/c65/c03/c66/c65c03c660ea8d6bb70ee6597d643245.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/aa3/ba4/973/aa3ba4973933bebafe516ed63e779700.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/35a/a87/d0d/35aa87d0d53ca31ea88ad249bacd057a.png"></td></tr></tbody></table></div>  <i>Ein Beispiel für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ressourcenerweiterung</a> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Was gibt Verkehr zählen? <br><br><ul><li>  Das Wichtigste ist, dass Sie das reale Bild sehen können und nicht wie bei CSS + JS üblich und darüber hinaus, wie sich dieses „Bild“ im Laufe der Zeit ändert. </li><li>  Anschließend können Sie analysieren, was genau geladen ist, Ressourcen in Gruppen aufteilen usw. </li><li>  Wie gut das Caching für Sie funktioniert. </li><li>  Gibt es Anomalien, zum Beispiel nach 15 Minuten Betrieb, zum Beispiel, der Code wurde rekursiv und lädt einige Ressourcen endlos. Die Überwachung des Datenverkehrs hilft dabei. </li></ul><br>  Nun, ein Nachholbericht meines Kollegen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Igor Druzhinin</a> zu diesem Thema: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bewertung der Qualität der Anwendung - Überwachung des Verkehrsverbrauchs</a> <br><br><br><h2>  Analytik </h2>  Wir richten die Metriken ein und was dann?  Und dann müssen sie irgendwohin geschickt werden.  Und hier holen Sie entweder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Graphit von Ihnen ab</a> oder Sie können zunächst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Analytics</a> oder ähnliches für die Datenaggregation verwenden, um persönliche Vorteile zu erzielen. <br><br>  Und vergessen Sie nicht, es reicht nicht aus, nur ein Diagramm zu erstellen. Für alle wichtigen Metriken sollten Perzentile vorhanden sein, mit denen Sie beispielsweise verstehen können, wie viel Prozent der Zielgruppe das Projekt für &lt;1s, &lt;2s, &lt;3s, &lt;5s, 5s + usw. lädt. <br><br><br><h2>  Schreiben eines Hochleistungscodes </h2>  Zuerst wollte ich hier etwas Sinnvolles schreiben, sie sagen, benutze WebWorker, vergiss nicht <code>requestIdleCallback</code> oder etwas Exotisches, zum Beispiel durch Runtime Cache über Browser-Registerkarten mit SharedWorker oder ServiceWorker (was nicht nur Caching betrifft, wenn das so ist).  Aber das ist alles sehr abstrakt und viele Themen sind unmöglich, also schreiben Sie einfach Folgendes: <br><br><ol><li>  Decken Sie Ihren Code zunächst mit Metriken ab, mit denen die Leistung gemessen wird. </li><li>  Glauben Sie den Benchmarks mit jsperf nicht.  Die überwiegende Mehrheit von ihnen ist schlecht geschrieben und einfach aus dem Zusammenhang gerissen.  Der beste Benchmark ist die tatsächliche Metrik für das Projekt, anhand derer Sie die Auswirkungen Ihrer Aktionen sehen können. </li><li>  Denken Sie an die Wahrnehmung von Produktivität oder vielmehr an das Weber-Fechner-Gesetz.  Wenn Sie mit der Optimierung begonnen haben, rollen Sie die Änderungen erst aus, wenn sie mindestens um 20% besser werden. Andernfalls werden Benutzer dies einfach nicht bemerken.  Das Gesetz wirkt auch in die entgegengesetzte Richtung. </li><li>  Fürchte Stammgäste, besonders die generierten.  Sie können nicht nur den Browser hängen, sondern auch XSS erhalten, weshalb es in unserer Mail verboten ist, HTML mit ihnen nur über einen DOM-Bypass zu analysieren. </li><li>  Sie müssen keine Arrays verwenden, um einen Wert in die eine oder andere Gruppe <code>successSteps.includes(currentStep)</code> gibt es ein <code>object</code> oder einen <code>Set</code> (z. B. wird <code>successSteps.includes(currentStep)</code> <code>successSteps.hasOwnProperty(currentStep)</code> <code>successSteps.includes(currentStep)</code> benötigt). O (1) ist alles. </li><li>  Bei dem Ausdruck "Vorzeitige Optimierung ist die Wurzel aller Übel" geht es nicht darum, zu schreiben, was immer Sie wollen.  Wenn Sie wissen, wie am besten, schreiben Sie optimal. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Ich werde ein paar Absätze über den Code und seine Optimierung schreiben</b> <div class="spoiler_text">  <b>DOM</b>  Sehr oft höre ich "Das Problem im DOM" - das ist natürlich wahr, aber da fast jeder jetzt eine Abstraktion darüber hat.  Sie ist es, die zum Engpass oder vielmehr zu Ihrem Code wird, der für die Bildung der Ansicht und der Geschäftslogik verantwortlich ist. <br><br>  Wenn wir zum Beispiel über das DOM sprechen, anstatt ein Fragment aus dem DOM zu löschen, ist es besser, es auszublenden oder zu entfernen.  Wenn Sie noch löschen müssen, führen Sie diesen Vorgang in <code>requestIdleCallback</code> (falls möglich), oder teilen Sie den Zerstörungsprozess in zwei Phasen auf: synchron und asynchron. <br><br>  Ich werde sofort eine Reservierung vornehmen. Verwenden Sie diesen Ansatz mit Bedacht, da Sie sonst auf Ihr Knie schießen können. <br><br>  Wir verwenden auch eine andere interessante Technik für Listen, zum Beispiel die „Liste der Themen“.  Das Wesentliche der Technik ist, dass anstelle einer globalen "Liste" und der Aktualisierung ihrer Daten für jeden "Ordner" eine "Liste der Threads" generiert wird.  Wenn der Benutzer zwischen den "Ordnern" navigiert, wird eine Liste aus dem DOM entfernt (nicht gelöscht) und die andere entweder teilweise oder gar nicht aktualisiert.  Und nicht alle, wie es bei der "Single List" der Fall ist. <br><br>  All dies gibt eine sofortige Reaktion auf Benutzeraktionen. <br><br>  <b>Mathe</b>  Wir entfernen problemlos alle Berechnungen in Worker oder WebAssembly. Dies funktioniert seit langer Zeit. <br><br>  <b>Transpiler</b> .  Oh, viele glauben nicht einmal, dass der Code, den sie schreiben, durch den Transpiler geht.  Ja, sie wissen von ihm, aber das ist alles.  Aber was macht er daraus, dass sie sich nicht mehr darum kümmern.  In DevTools sehen sie tatsächlich das Ergebnis der Quellkarte. <br><br>  Studieren Sie daher die Werkzeuge, die Sie verwenden, z. B. hat dasselbe Babel auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spielplatz</a> die Möglichkeit zu sehen, in welchem ​​Code es abhängig von den ausgewählten Voreinstellungen generiert wird. Schauen Sie sich einfach dasselbe Jahr <code>yeild</code> , <code>await</code> oder <code>await</code> <code>for of</code> . <br><br>  <b>Die Feinheiten der Zunge</b> .  Noch weniger Leute wissen über den Monomorphismus des Codes Bescheid oder wissen, warum das Binden langsam ist und ... Sie verwenden endlich <code>handleEvent</code> ! <br><br>  <b>Daten und Prekreshing</b> .  Weniger Anfragen, mehr Caching.  Außerdem verwenden wir sehr oft die Technik der "Voraussicht", wenn wir im Hintergrund Daten laden.  Nach dem Rendern der „Thread-Liste“ laden wir beispielsweise N-ungelesene Threads in den aktuellen „Ordner“, sodass der Benutzer beim Klicken sofort zu „Lesen“ und nicht zu einem anderen „Loader“ wechselt.  Wir verwenden eine ähnliche Technik nicht nur für Daten, sondern auch für JS.  Zum Beispiel ist „Schreiben eines Briefes“ ein riesiges Bündel (wegen des Editors), und nicht alle Leute schreiben Briefe gleichzeitig. Deshalb laden wir es nach der Initialisierung der Anwendung im Hintergrund. <br><br>  <b>Lauter</b>  Ich weiß nicht warum, aber ich habe keine Artikel gesehen, in denen gelehrt wurde, wie man keinen Lader herstellt, sondern eine Präsentation der "zukünftigen" Reaktion, in der viel Zeit für dieses Problem in Suspense aufgewendet wurde.  Immerhin ist die ideale Anwendung ohne Lader, wir haben lange in der Mail versucht, sie nur in Notsituationen anzuzeigen. <br><br>  Im Allgemeinen haben wir eine solche Richtlinie, es gibt keine Daten, es gibt keine Ansicht, es gibt nichts, um eine Semi-Schnittstelle zu zeichnen, zuerst laden wir die Daten und erst dann "zeichnen".  Aus diesem Grund verwenden wir die „Voraussicht“, wohin der Benutzer gehen und diese Daten laden wird, damit der Benutzer den Loader nicht sieht.  Darüber hinaus hilft unsere Datenschicht, die dauerhaft ist, bei dieser Aufgabe sehr.  Wenn Sie irgendwo an einem Ort "Thread" angefordert haben, wird beim nächsten Anfordern von einem anderen oder demselben Ort keine Anfrage gestellt. Wir nehmen Daten aus dem Laufzeit-Cache (genauer gesagt, einen Link zu den Daten).  Und so sind Sammlungen von Threads in allem auch nur Links zu Daten. <br><br>  Wenn Sie sich dennoch für einen Lader entscheiden, vergessen Sie nicht die Grundregeln, die Ihren Lader weniger nerven: <ul><li>  Es ist nicht erforderlich, den Loader sofort zu zeigen. Zum Zeitpunkt des Sendens der Anfrage sollte eine Verzögerung von mindestens 300-500 ms vor der Show auftreten. </li><li>  Nach dem Empfang der Daten müssen Sie den Loader nicht scharf entfernen, auch hier sollte es zu einer Verzögerung kommen. </li></ul><br>  Diese einfachen Regeln werden benötigt, damit der Loader nur bei starken Anforderungen angezeigt wird und nach Abschluss nicht „blinkt“.  Am wichtigsten ist jedoch, dass der beste Lader ein Lader ist, der nicht angezeigt wurde. </div></div><br><br>  Vielen Dank für Ihre Aufmerksamkeit, das ist alles, messen, analysieren und verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PerfKeeper</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Live-Beispiel</a> ) sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinen Github</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter</a> bei Fragen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454920/">https://habr.com/ru/post/de454920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454900/index.html">So machen Sie Webformulare auf der Website bequem und sicher: Entwicklungstools und Konstruktoren</a></li>
<li><a href="../de454904/index.html">Samsung startet kostenlosen Online-Kurs für Computer Vision Neural Network</a></li>
<li><a href="../de454912/index.html">Die Zwergenfestung Tarn Adams spricht über die Spieleentwicklung</a></li>
<li><a href="../de454916/index.html">Neuronale Netzwerkarchitektur zur Implementierung des RL-Algorithmus mit der Fähigkeit, gleichzeitig laufende Aktionen festzulegen</a></li>
<li><a href="../de454918/index.html">So kombinieren Sie den Rücken zweier Einzelhändler in SAP in 12 Stunden</a></li>
<li><a href="../de454922/index.html">Geschichten über ausländische Kunden und ihre Arbeitsmerkmale in Russland nach dem PD-Gesetz</a></li>
<li><a href="../de454924/index.html">Authentifizierungseinstellungen in Veeam Backup für Microsoft Office 365 v3</a></li>
<li><a href="../de454926/index.html">Alles, was Sie über word2vec wussten, ist nicht wahr</a></li>
<li><a href="../de454928/index.html">Möglichkeit, den Windows-Sperrbildschirm in RDP-Sitzungen zu umgehen</a></li>
<li><a href="../de454932/index.html">Investitionen und Software: 5 Handelsterminals für den Handel an der Börse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>