<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏿 🤜 ⚔️ AQUA RTOS Echtzeit-Betriebssystem für MK AVR in der BASCOM AVR-Umgebung 🛍️ 💆🏾 🧕🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim Schreiben für MK-Code, der komplizierter ist als das „Blinken eines Lichts“, ist der Entwickler mit den Einschränkungen konfrontiert, die der lin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AQUA RTOS Echtzeit-Betriebssystem für MK AVR in der BASCOM AVR-Umgebung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453708/"> Beim Schreiben für MK-Code, der komplizierter ist als das „Blinken eines Lichts“, ist der Entwickler mit den Einschränkungen konfrontiert, die der linearen Programmierung im Stil von „Supercycle plus Interrupts“ inhärent sind.  Die Verarbeitung von Interrupts erfordert Geschwindigkeit und Prägnanz, was dazu führt, dass dem Code Flags hinzugefügt werden und der Projektstil zum „Superzyklus mit Interrupts und Flags“ wird. <br><br>  Wenn die Komplexität des Systems zunimmt, wächst die Anzahl der voneinander abhängigen Flags exponentiell und das Projekt wird schnell zu einem schlecht lesbaren und verwaltbaren „Pasta-Code“. <br><br>  Die Verwendung von Echtzeitbetriebssystemen hilft, den "Pasta-Code" loszuwerden und Flexibilität und Verwaltbarkeit für ein komplexes MK-Projekt wiederherzustellen. <br>  Es wurden mehrere kooperative Echtzeitbetriebssysteme entwickelt, die für AVR-Mikrocontroller sehr beliebt sind.  Sie sind jedoch alle in C oder Assembler geschrieben und nicht für diejenigen geeignet, die MK in der BASCOM AVR-Umgebung programmieren, wodurch ihnen ein so nützliches Werkzeug zum Schreiben seriöser Anwendungen entzogen wird. <br><br>  Um dieses Manko zu beheben, habe ich ein einfaches RTOS für die BASCOM AVR-Programmierumgebung entwickelt, auf das ich die Leser aufmerksam mache. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd6/0be/c64/cd60bec64b2a0b96ed562770a9063355.jpg" alt="Bild"><br><a name="habracut"></a><br>  Für viele ist der bekannte MK-Programmierstil der sogenannte  <i>Superzyklus</i> .  In diesem Fall besteht der Code aus einer Reihe von Funktionen, Prozeduren und Deskriptoren (Konstanten, Variablen), möglicherweise Bibliotheksfunktionen, die allgemein als "Hintergrundcode" bezeichnet werden, sowie einer großen Endlosschleife, die in einem <b>Do-Loop-</b> Konstrukt eingeschlossen ist.  Beim Start wird zuerst die Ausrüstung des MK selbst und externer Geräte initialisiert, die Konstanten und Anfangswerte der Variablen werden gesetzt, und dann wird die Steuerung auf diesen unendlichen Superzyklus übertragen. <br>  Die Einfachheit des Superzyklus ist offensichtlich.  Die meisten Aufgaben werden von MK ausgeführt, weil auf die eine oder andere Weise zyklisch.  Die Nachteile sind auch offensichtlich: Wenn ein Gerät oder Signal eine sofortige Reaktion erfordert, wird MK es bereitstellen, sobald sich der Zyklus dreht.  Wenn die Signaldauer kürzer als die Zyklusdauer ist, wird ein solches Signal übersprungen. <br><br>  Im folgenden Beispiel möchten wir überprüfen, ob die Taste <b>gedrückt wird</b> : <br><br><pre><code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">' -  if button = 1 then '     '  -  loop</span></span></code> </pre> <br>  Wenn "irgendein Code" lange genug funktioniert, bemerkt MK möglicherweise keinen kurzen Knopfdruck. <br><br>  Glücklicherweise ist MK mit einem Interrupt-System ausgestattet, das dieses Problem lösen kann: Alle kritischen Signale können an Interrupts „aufgehängt“ werden, und für jeden kann ein Handler geschrieben werden.  So erscheint das nächste Level: ein <i>Superzyklus mit Unterbrechungen</i> . <br>  Das folgende Beispiel zeigt die Struktur des Programms mit einem Superzyklus und einem Interrupt, der einen Schaltflächenklick verarbeitet: <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">on</span></span> button button_isr <span class="hljs-comment"><span class="hljs-comment">'    enable interrupts ' ***  *** do ' -  loop end '   button_isr: '  -    return</span></span></code> </pre> <br>  Die Verwendung von Interrupts stellt jedoch ein neues Problem dar: Der Interrupt-Handler-Code sollte so schnell und kürz wie möglich sein.  Innerhalb von Unterbrechungen ist die MK-Funktionalität eingeschränkt.  Da AVR-MKs kein hierarchisches Interrupt-System haben, kann innerhalb eines Interrupts kein weiterer Interrupt auftreten - sie sind zu diesem Zeitpunkt durch die Hardware deaktiviert.  Daher sollte der Interrupt so schnell wie möglich ausgeführt werden, da sonst andere (und möglicherweise wichtigere) Interrupts übersprungen und nicht verarbeitet werden. <br><br><div class="spoiler">  <b class="spoiler_title">Speicher unterbrechen</b> <div class="spoiler_text">  Tatsächlich kann MK innerhalb des Interrupts die Tatsache eines anderen Interrupts in einem speziellen Register notieren, wodurch es später verarbeitet werden kann.  Dieser Interrupt kann jedoch nicht sofort verarbeitet werden. <br></div></div><br>  Daher können wir nichts Kompliziertes in den Interrupt-Handler schreiben, insbesondere wenn dieser Code Verzögerungen aufweisen sollte - denn bis die Verzögerung funktioniert, kehrt der MK nicht zum Hauptprogramm (Superzyklus) zurück und ist für andere Interrupts taub. <br><br>  Aus diesem Grund müssen Sie im Interrupt-Handler häufig nur die Tatsache des Ereignisses mit einem Flag kennzeichnen - Ihrem eigenen für jedes Ereignis - und dann die Flags innerhalb des Superzyklus überprüfen und verarbeiten.  Dies verlängert natürlich die Reaktionszeit auf das Ereignis, aber zumindest verpassen wir nichts Wichtiges. <br><br>  Somit entsteht die nächste Komplexitätsstufe - ein <i>Superzyklus mit Interrupts und Flags</i> . <br><br>  Der folgende Code wird angezeigt: <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">on</span></span> button button_isr <span class="hljs-comment"><span class="hljs-comment">'    enable interrupts ' ***  *** do ' -  if button_flag = 1 then '     button_flag = 0 '     end if '  -  loop end ' ***    *** button_isr: button_flag = 1 return</span></span></code> </pre> <br>  Eine beträchtliche Anzahl von Programmen für MK ist dadurch begrenzt.  Solche Programme sind jedoch meist noch mehr oder weniger einfach.  Wenn Sie etwas Komplizierteres schreiben, wächst die Anzahl der Flaggen wie ein Schneeball, und der Code wird immer verwirrender und unlesbarer.  Außerdem wurde im obigen Beispiel das Problem mit Verzögerungen nicht gelöst.  Natürlich können Sie einen separaten Interrupt an den Timer "hängen" und darin ... auch verschiedene Flags steuern.  Aber das macht das Programm völlig hässlich, die Anzahl der voneinander abhängigen Flags wächst exponentiell, und selbst der Entwickler selbst kann einen solchen „Pasta-Code“ kaum bald herausfinden.  Der Versuch, einen Fehler zu finden oder den Code zu ändern, wird bei der Entwicklung eines neuen Projekts häufig gleichgestellt. <br><br>  Wie kann man das Problem des "Pasta-Codes" lösen und es lesbarer und handlicher machen?  Das <i>Betriebssystem</i> (OS) hilft.  Darin ist die Funktionalität, die MK implementieren sollte, in Aufgaben unterteilt, deren Betrieb vom Betriebssystem gesteuert wird. <br><br><h2>  Arten von Betriebssystemen für MK </h2><br>  Betriebssysteme für MK können in zwei große Klassen unterteilt werden: Betriebssystem mit Verdrängung und kooperatives Betriebssystem.  In jedem dieser Betriebssysteme werden Aufgaben durch ein spezielles Verfahren gesteuert, das als <i>Dispatcher bezeichnet wird</i> .  In einem Betriebssystem mit <i>Verdrängung</i> schaltet <i>der</i> Dispatcher die Ausführung jederzeit unabhängig von einer Aufgabe zu einer anderen um und weist jedem eine bestimmte Anzahl von Taktzyklen zu (möglicherweise unterschiedlich, abhängig von der Priorität der Aufgabe).  Dieser Ansatz funktioniert insgesamt hervorragend, sodass Sie den Inhalt von Aufgaben überhaupt nicht betrachten können: Sie können mindestens den Aufgabencode schreiben <br><br><pre> <code class="vbscript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  - und trotzdem werden die restlichen Aufgaben (einschließlich dieser) ausgeführt.  Präemptive Betriebssysteme erfordern jedoch viele Ressourcen (Speicher- und Prozessorzyklen), da jeder Switch den Kontext der deaktivierten Aufgabe vollständig speichern und den Kontext der erneuerbaren Aufgabe laden sollte.  Der Kontext bezieht sich hier auf den Inhalt der Maschinenregister und des Stapels (BASCOM verwendet zwei Stapel - den Hardware-Stapel für die Rücksprungadressen von Unterprogrammen und den Software-Stapel für die Übergabe von Argumenten).  Ein solches Laden erfordert nicht nur viele Prozessorzyklen, sondern der Kontext jeder Aufgabe muss auch eine Weile irgendwo gespeichert werden, bis sie funktioniert.  In den "großen" Prozessoren, die ursprünglich auf Multitasking ausgerichtet waren, werden diese Funktionen häufig in der Hardware unterstützt und verfügen über viel mehr Ressourcen.  In AVR MK gibt es keine Hardwareunterstützung für Multitasking (alles muss „manuell“ erfolgen), und der verfügbare Speicher ist klein.  Daher sind das Verschieben von Betriebssystemen, obwohl sie existieren, für einfache MKs nicht allzu geeignet. <br><br>  Eine andere Sache ist <i>kooperatives Betriebssystem</i> .  Hier steuert die Aufgabe selbst, an welchem ​​Punkt die Kontrolle an den Dispatcher übertragen werden soll, sodass er andere Aufgaben starten kann.  Darüber hinaus sind hierfür die Aufgaben erforderlich, da sonst die Codeausführung ins Stocken gerät.  Einerseits scheint dieser Ansatz die allgemeine Zuverlässigkeit zu verringern: Wenn eine Aufgabe hängt, wird der Dispatcher niemals angerufen, und das gesamte System reagiert nicht mehr.  Andererseits ist ein linearer Code oder ein Superzyklus in dieser Hinsicht nicht besser - weil sie mit genau dem gleichen Risiko einfrieren können. <br><br>  Ein kooperatives Betriebssystem hat jedoch einen wichtigen Vorteil.  Da der Programmierer hier den Moment des Wechsels selbst festlegt, kann dies beispielsweise nicht plötzlich geschehen, während die Aufgabe mit einer Ressource arbeitet oder gerade einen arithmetischen Ausdruck berechnet.  Daher können Sie in einem kooperativen Betriebssystem in den meisten Fällen auf die Pflege des Kontexts verzichten.  Dies spart Prozessorzeit und Speicher erheblich und scheint daher für die Implementierung auf MK AVR viel besser geeignet zu sein. <br><br><h2>  Taskwechsel in BASCOM AVR </h2><br>  Um die Taskumschaltung in der BASCOM AVR-Umgebung zu implementieren, muss der Taskcode, der jeweils als normale Prozedur implementiert ist, an einer Stelle den Dispatcher aufrufen - ebenfalls als normale Prozedur implementiert. <br>  Stellen Sie sich vor, wir haben zwei Aufgaben, von denen jede an einer Stelle ihres Codes vom Dispatcher aufgerufen wird. <br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> task1() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">'  1 '  loop end sub ' ---------------------------------- sub task2() do '  2 '  loop end sub</span></span></code> </pre> <br>  Angenommen, Aufgabe 1 wurde ausgeführt. Mal sehen, was auf dem Stapel passiert, wenn ein "Dispatcher-Aufruf" ausgeführt wird: <br><br><blockquote>  Rücksprungadresse an den Hauptcode (2 Bytes) <br>  Stapelanfang -&gt; Adresse an Task 1 zurückgeben, die den Dispatcher aufgerufen hat (2 Bytes) </blockquote><br>  Die Oberseite des Stapels zeigt auf die Adresse der Anweisung in Aufgabe 1, die auf den Dispatcher-Aufruf folgt (die <b>Schleifenanweisung</b> in unserem Beispiel). <br><br>  Das Ziel des Dispatchers besteht im einfachsten Fall darin, die Kontrolle auf Aufgabe 2 zu übertragen. Die Frage ist, wie dies zu tun ist.  (Angenommen, der Dispatcher kennt die Adresse von Task 2 bereits). <br><br>  Zu diesem Zweck sollte der Dispatcher die Adresse der Rückkehr zu Task 1 vom Stapel abrufen (und an einen Ort, an den er sich erinnern sollte), die Adresse von Task 2 an dieser Stelle auf dem Stapel ablegen und dann den Befehl return eingeben.  Der Prozessor extrahiert die dort platzierte Adresse aus dem Stapel und fährt mit der Ausführung von Task 2 fort, anstatt zu Task 1 zurückzukehren. <br><br>  Wenn Task 2 den Dispatcher aufruft, ziehen wir auch den Stapel heraus und speichern die Adresse, an der zu Task 2 zurückkehren kann, und laden die zuvor gespeicherte Adresse von Task 1 auf den Stapel. Geben Sie den Befehl <b>return ein,</b> und wir befinden uns am Fortsetzungspunkt von Task 1 . <br><br>  Infolgedessen bekommen wir so ein Durcheinander: <br><br><blockquote>  Aufgabe 1 -&gt; Dispatcher -&gt; Aufgabe 2 -&gt; Dispatcher -&gt; Aufgabe 1 .... </blockquote><br>  Nicht schlecht!  Und es funktioniert.  Für ein praktisch verwendbares Betriebssystem reicht dies natürlich nicht aus.  Schließlich sollten nicht immer und nicht alle Aufgaben funktionieren - zum Beispiel können sie etwas <i>erwarten</i> (Ablauf der Verzögerungszeit, Auftreten eines Signals usw.).  Die Aufgaben sollten also einen <i>Status haben</i> (ARBEITEN, BEREIT, ERWARTET usw.).  Außerdem wäre es schön, wenn Aufgaben <i>Priorität</i> zugewiesen würden.  Wenn dann mehr als eine Aufgabe zur Ausführung bereit ist, setzt der Dispatcher die Aufgabe mit der höchsten Priorität fort. <br><br><h2>  AQUA RTOS </h2><br>  Um die beschriebene Idee umzusetzen, wurde das kooperative OS AQUA RTOS entwickelt, das die notwendigen Dienste für Aufgaben bereitstellt und die Implementierung von kooperativem Multitasking in der BASCOM AVR-Umgebung ermöglicht. <br><br><div class="spoiler">  <b class="spoiler_title">Wichtiger Hinweis zum Verfahrensmodus in BASCOM AVR</b> <div class="spoiler_text">  Bevor Sie mit der Beschreibung von AUQA RTOS beginnen, sollten Sie beachten, dass die BASCOM AVR-Umgebung zwei Arten von Adressierungsverfahren unterstützt.  Dies wird durch den config submode = new | geregelt  alt. <br>  Wenn Sie die alte Option angeben, kompiliert der Compiler zum einen den gesamten Code linear, unabhängig davon, ob er irgendwo verwendet wird oder nicht, und zum anderen werden Prozeduren ohne Argumente, die im Stil von Subname / End-Sub entworfen wurden, als Prozeduren wahrgenommen , im Stil des Namens gestaltet: / return.  Auf diese Weise können wir die Adresse der Prozedur als Label als Argument an eine andere Prozedur übergeben, indem wir den Modifikator bylabel verwenden.  Dies gilt auch für Prozeduren, die im Stil des Subnamens / End-Substils entworfen wurden (Sie müssen den Namen der Prozedur als Bezeichnung übergeben). <br>  Gleichzeitig unterwirft der Modus submode = old einige Einschränkungen: Taskprozeduren dürfen keine Argumente enthalten;  Der Code der über $ include verbundenen Dateien ist linear im allgemeinen Projekt enthalten. Daher sollte in den verbundenen Dateien eine Umgehung angegeben werden. Gehen Sie von Anfang bis Ende mit goto und einem Label. <br>  Daher muss der Benutzer in AQUA RTOS entweder nur die alte Prozedurnotation im Stil von task_name: / return für Aufgaben verwenden oder den allgemeineren Subnamen / end sub verwenden, indem er den Modifikator submode = old am Anfang seines Codes hinzufügt und die enthaltenen Dateien umgeht gehe zu label / include file code / label :. <br></div></div><br><h3>  AQUA RTOS-Taskstatus </h3><br>  Die folgenden Status sind für Aufgaben in AQUA RTOS definiert: <br><br><pre> <code class="vbscript hljs">OSTS_UNDEFINE OSTS_READY OSTS_RUN OSTS_DELAY OSTS_STOP OSTS_WAIT OSTS_PAUSE OSTS_RESTART</code> </pre> <br>  Wenn die Aufgabe noch nicht initialisiert wurde, erhält sie den Status <b>OSTS_UNDEFINE</b> . <br>  Nach der Initialisierung hat die Task den Status <b>OSTS_STOP</b> . <br>  Wenn die Aufgabe <i>zur Ausführung bereit ist</i> , wird ihr der Status <b>OSTS_READY</b> zugewiesen. <br>  Die aktuell ausgeführte Task hat den Status <b>OSTS_RUN</b> . <br>  Von dort aus kann sie zu den Status <b>OSTS_STOP, OSTS_READY, OSTS_DELAY, OSTS_WAIT, OSTS_PAUSE wechseln</b> . <br>  Der Status <b>OSTS_DELAY</b> hat eine Aufgabe, die eine <i>Verzögerung</i> erfüllt. <br>  Der Status <b>OSTS_WAIT wird</b> Aufgaben zugewiesen, die <i>auf ein Semaphor, ein Ereignis oder eine Nachricht warten</i> (mehr dazu weiter unten). <br><br>  Was ist der Unterschied zwischen den <b>Status</b> <b>OSTS_STOP</b> und <b>OSTS_PAUSED</b> ? <br>  Wenn die Aufgabe aus irgendeinem Grund den Status von <b>OSTS_STOP</b> erhält, wird die nachfolgende Wiederaufnahme der Aufgabe (nach Erhalt des Status von <b>OSTS_READY</b> ) von ihrem Einstiegspunkt aus ausgeführt, d. H.  von Anfang an.  Ab dem Status von <b>OSTS_PAUSE funktioniert die</b> Aufgabe an dem Ort weiter, an dem sie angehalten wurde. <br><br><h3>  Aufgabenstatusverwaltung </h3><br>  Sowohl das Betriebssystem selbst kann die Aufgaben als auch den Benutzer automatisch verwalten, indem die Betriebssystemdienste aufgerufen werden.  Es gibt mehrere Aufgabenverwaltungsdienste (die Namen aller Betriebssystemdienste beginnen mit dem Präfix <b>OS_</b> ): <br><br><pre> <code class="vbscript hljs">OS_InitTask(task_label, task_prio) OS_Stop() OS_StopTask(task_label) OS_Pause() OS_PauseTask(task_label) OS_Resume() OS_ResumeTask(task_label) OS_Restart()</code> </pre> <br>  Jeder von ihnen hat zwei Optionen: <b>OS_service</b> und <b>OS_serviceTask</b> (mit Ausnahme des <b>OS_InitTask-</b> Dienstes, der nur eine Option hat; der <b>OS_Init-</b> Dienst initialisiert das Betriebssystem selbst). <br><br>  Was ist der Unterschied zwischen <b>OS_service</b> und <b>OS_serviceTask</b> ?  Die erste Methode wirkt auf die Aufgabe selbst, die sie verursacht hat.  Mit der zweiten Option können Sie einen Zeiger auf eine andere Aufgabe als Argument festlegen und somit eine andere Aufgabe von einer Aufgabe aus verwalten. <br><br><div class="spoiler">  <b class="spoiler_title">Über OS_Resume</b> <div class="spoiler_text">  Alle Task-Management-Services außer OS_Resume und OS_ResumeTask rufen den Task-Manager nach der Verarbeitung automatisch auf.  Im Gegensatz dazu setzen OS_Resume * -Dienste den Taskstatus nur auf OSTS_READY.  Dieser Status wird nur verarbeitet, wenn der Dispatcher explizit aufgerufen wird. <br></div></div><br><h3>  Prioritäts- und Aufgabenwarteschlange </h3><br>  Wie oben erwähnt, können in einem realen System einige Aufgaben wichtiger sein, während andere sekundär sein können.  Daher ist eine nützliche Funktion des Betriebssystems die Möglichkeit, Aufgaben Priorität zuzuweisen.  In diesem Fall wählt das Betriebssystem zuerst die Aufgabe mit der höchsten Priorität <i>aus</i> , wenn mehrere <i>vorgefertigte</i> Aufgaben gleichzeitig vorhanden sind.  Wenn <b>alle</b> vorgefertigten Aufgaben die gleiche Priorität haben, werden sie vom Betriebssystem in einem Kreis in einer Reihenfolge ausgeführt, die als "Karussell" oder "Round-Robin" bezeichnet wird. <br><br>  In AQUA RTOS wird einer Aufgabe Priorität zugewiesen, wenn sie durch einen Aufruf des Dienstes <b>OS_InitTask</b> <i>initialisiert wird</i> , der <b>die</b> Adresse der Aufgabe als erstes Argument und eine Zahl von 1 bis 15 als zweites Argument <b>empfängt</b> . <i>Eine niedrigere Zahl bedeutet eine höhere Priorität</i> .  Während des Betriebs des Betriebssystems wird keine Änderung der der Aufgabe zugewiesenen Priorität bereitgestellt. <br><br><h3>  Verzögerungen </h3><br>  In jeder Aufgabe wird die Verzögerung unabhängig von anderen Aufgaben verarbeitet. <br>  Während das Betriebssystem die Verzögerung einer Aufgabe berechnet, können andere ausgeführt werden. <br>  Zur Organisation von Verzögerungen erbrachte Dienstleistungen <b>OS_Delay |</b>  <b>OS_DelayTask</b> .  Das Argument ist die Anzahl der Millisekunden, um die sich die Aufgabe <i>verzögert</i> .  Da die Dimension des Arguments <b>dword</b> ist, <b>beträgt</b> die maximale Verzögerung 4294967295 ms oder etwa 120 Stunden, was für die meisten Anwendungen ausreichend zu sein scheint.  Nach dem Aufruf des Verzögerungsdienstes wird automatisch der Dispatcher angerufen, der die Kontrolle für die Dauer der Verzögerung auf andere Aufgaben überträgt. <br><br><h3>  Semaphoren </h3><br>  Semaphoren in AQUA RTOS sind so etwas wie Flags und Variablen, die für Aufgaben verfügbar sind.  Es gibt zwei Arten - binär und zählbar.  Die ersten haben nur zwei Zustände: frei und geschlossen.  Der zweite ist ein Bytezähler (der Dienst zum Zählen von Semaphoren in der aktuellen Version von AQUA RTOS ist nicht implementiert (ich bin ein fauler Arsch), daher gilt alles, was unten gesagt wird, nur für binäre Semaphoren). <br><br>  Der Unterschied zwischen einem Semaphor und einem einfachen Flag besteht darin, dass die Aufgabe ausgeführt werden kann, <i>auf die Freigabe des</i> angegebenen Semaphors zu <i>warten</i> .  In gewisser Weise ähnelt die Verwendung von Semaphoren wirklich einer Eisenbahn: Beim Erreichen des Semaphors überprüft die Komposition (Aufgabe) das Semaphor, und wenn es nicht geöffnet ist, wartet es darauf, dass das Aktivierungssignal weiter erscheint.  Zu diesem Zeitpunkt können andere Züge (Aufgaben) weiterfahren (fahren). <br><br>  In diesem Fall wird die gesamte schwarze Arbeit dem Dispatcher zugewiesen.  Sobald die Aufgabe angewiesen wird, auf das Semaphor zu warten, wird die Steuerung automatisch an den Dispatcher übertragen und er kann andere Aufgaben starten - genau bis das angegebene Semaphor freigegeben ist.  Sobald sich der Status des Semaphors in " <i>Frei"</i> ändert, weist der Dispatcher allen Aufgaben, die auf dieses Semaphor gewartet haben, den Status " <i>Bereit"</i> ( <b>OSTS_READY</b> ) zu und sie werden in der Reihenfolge Priorität und Priorität ausgeführt. <br>  Insgesamt bietet AQUA RTOS 16 binäre Semaphoren (diese Anzahl kann im Prinzip durch Ändern der Dimension der Variablen in der Task-Steuereinheit erhöht werden, da sie im Inneren als Bit-Flags implementiert sind). <br>  Binäre Semaphore arbeiten mit den folgenden Diensten: <br><br><pre> <code class="vbscript hljs">hBSem OS_CreateBSemaphore() OS_WaitBSemaphore(hBSem) OS_WaitBSemaphoreTask(task_label, hBSem) OS_BusyBSemaphore(hBSem) OS_FreeBSemaphore(hBSem)</code> </pre> <br>  Vor der Verwendung muss ein Semaphor <i>erstellt werden</i> .  Dies erfolgt durch Aufrufen des <b>OS_CreateBSemaphore-</b> Dienstes, der die eindeutige <b>Bytekennung</b> (Handle) des erstellten <b>hBSem-</b> Semaphors <b>zurückgibt</b> , oder durch den benutzerdefinierten Handler, der einen <b>OSERR_BSEM_MAX_REACHED-</b> Fehler generiert, der angibt, dass die maximal mögliche Anzahl von binären Semaphoren erreicht wurde. <br><br>  Sie können mit der empfangenen Kennung arbeiten, indem Sie sie als Argument an andere Semaphor-Dienste übergeben. <br><br>  Dienst <b>OS_WaitBSemaphore |</b>  <b>OS_WaitBSemaphoreTask</b> versetzt die (aktuell | angegebene) Aufgabe in einen Zustand, in dem <i>auf die Freigabe des</i> <b>hBSem-</b> <i>Semaphors</i> <b>gewartet wird,</b> wenn dieses Semaphor ausgelastet ist, und überträgt dann die Steuerung an den Dispatcher, damit dieser andere Aufgaben starten kann.  Wenn das Semaphor frei ist, findet keine Steuerübertragung statt und die Aufgabe wird einfach fortgesetzt. <br><br>  Die <b>Dienste</b> <b>OS_BusyBSemaphore</b> und <b>OS_FreeBSemaphore</b> setzen das <b>hBSem-</b> Semaphor auf <i>beschäftigt</i> bzw. <i>frei</i> . <br><br>  Die Zerstörung von Semaphoren zur Vereinfachung des Betriebssystems und zur Reduzierung der Codemenge ist nicht vorgesehen.  Somit sind alle erstellten Semaphoren statisch. <br><br><h3>  Ereignisse </h3><br>  Zusätzlich zu Semaphoren können Aufgaben ereignisgesteuert sein.  Eine Aufgabe kann angewiesen werden, <i>ein bestimmtes Ereignis</i> zu <i>erwarten</i> , und eine andere Aufgabe (sowie der Hintergrundcode) kann dieses Ereignis <i>signalisieren</i> .  Gleichzeitig erhalten alle Aufgaben, die auf dieses Ereignis gewartet haben, den Status <i>zur Ausführung bereit</i> ( <b>OSTS_READY</b> ) und werden vom Dispatcher zur Ausführung in der Reihenfolge Priorität und Priorität festgelegt. <br><br>  Auf welche Ereignisse kann die Aufgabe reagieren?  Nun, zum Beispiel: <br><ul><li>  Unterbrechung; </li><li>  Auftreten eines Fehlers; </li><li>  Freigabe der Ressource (manchmal ist es bequemer, dafür ein Semaphor zu verwenden); </li><li>  Ändern des Status der E / A-Leitung oder Drücken einer Taste auf der Tastatur; </li><li>  Empfangen oder Senden eines Zeichens über RS-232; </li><li>  Informationsübertragung von einem Teil der Anwendung zu einem anderen (siehe auch Nachrichten). </li></ul><br>  Das Ereignissystem wird durch die folgenden Dienste implementiert: <br><br><pre> <code class="vbscript hljs">hEvent OS_CreateEvent() OS_WaitEvent(hEvent) OS_WaitEventTask(task_label, hEvent) OS_WaitEventTO(hEvent, dwTimeout) OS_SignalEvent(hEvent)</code> </pre> <br>  Bevor Sie ein Ereignis verwenden können, müssen Sie <i>es erstellen</i> .  Dies erfolgt durch Aufrufen der Funktion <b>OS_CreateEvent</b> , die eine eindeutige Byte- <b>ID</b> (Handle) für das Ereignis <b>hEvent zurückgibt</b> , oder durch den benutzerdefinierten Handler einen <b>OSERR_EVENT_MAX_REACHED-</b> Fehler <b>ausgibt</b> , der angibt, dass die maximale Anzahl von Ereignissen erreicht wurde, die im Betriebssystem generiert werden können (maximal 255 verschiedene Ereignisse). <br><br>  Um eine Aufgabe auf ein <b>hEvent-</b> Ereignis warten zu <b>lassen</b> , rufen Sie <b>OS_WaitEvent</b> in seinem Code auf und übergeben Sie das Ereignishandle als Argument.  Nach dem Aufrufen dieses Dienstes wird die Kontrolle automatisch an den Dispatcher übertragen. <br><br>  Im Gegensatz zum Semaphor-Dienst bietet der Ereignisdienst die Option, auf ein Ereignis mit einer <i>Zeitüberschreitung</i> zu warten.  Verwenden Sie dazu den Dienst <b>OS_WaitEventTO</b> .  Mit dem zweiten Argument können Sie die Anzahl der Millisekunden angeben, die die Task für das Ereignis erwarten kann.  Wenn die angegebene Zeit abgelaufen ist, erhält die Task den Status <i>zur Ausführung bereit,</i> als ob das Ereignis eingetreten wäre, und wird vom Dispatcher so eingestellt, dass die Ausführung in der Reihenfolge ihrer Priorität und Priorität fortgesetzt wird.  Die Aufgabe kann feststellen, dass es sich nicht um ein Ereignis, sondern um eine Zeitüberschreitung handelt, die von der Aufgabe überprüft werden kann, indem das globale Flag <b>OS_TIMEOUT</b> überprüft wird. <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font></i><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder Hintergrundcode kann das Auftreten eines bestimmten Ereignisses </font><b><font style="vertical-align: inherit;">signalisieren</font></b><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">indem der Dienst </font><b><font style="vertical-align: inherit;">OS_SignalEvent aufgerufen</font></b><font style="vertical-align: inherit;"> wird </font><font style="vertical-align: inherit;">, der </font><b><font style="vertical-align: inherit;">das</font></b><font style="vertical-align: inherit;"> Ereignishandle als Argument </font><b><font style="vertical-align: inherit;">empfängt</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In diesem Fall setzt das Betriebssystem bei allen auf dieses Ereignis wartenden Aufgaben den Status </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur Ausführung bereit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , damit sie in der Reihenfolge ihrer Priorität und Priorität weiter ausgeführt werden können.</font></font><br><br><h3>  Nachrichten </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Nachrichtensystem funktioniert im Allgemeinen ähnlich wie das Ereignissystem, bietet Aufgaben jedoch mehr Optionen und Flexibilität: Es bietet nicht nur die Erwartung einer Nachricht zu einem bestimmten Thema, sondern auch die Art und Weise, wie die Nachricht selbst von einer Aufgabe zu einer anderen übertragen wird - einer Zahl oder einer Zeichenfolge. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies wird durch die folgenden Dienste implementiert:</font></font><br><br><pre> <code class="vbscript hljs">hTopic OS_CreateMessage() OS_WaitMessage(hTopic) OS_WaitMessageTask(task_label, hTopic) OS_WaitMessageTO(hTopic, dwTimeout) OS_SendMessage(hTopic, wMessage) word_ptr OS_GetMessage(hTopic) word_ptr OS_PeekMessage(hTopic) <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> OS_GetMessageString(hTopic) <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> OS_PeekMessageString(hTopic)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Nachrichtendienst nutzen zu können, müssen Sie zuerst </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Nachrichtenthema</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellen </font><font style="vertical-align: inherit;">. Dies erfolgt über den Dienst </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_CreateMessage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der das Byte-Handle des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hTopic-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Themas </font><b><font style="vertical-align: inherit;">zurückgibt</font></b><font style="vertical-align: inherit;"> , oder über den benutzerdefinierten Handler, der einen Fehler </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSERR_TOPIC_MAX_REACHED auslöst</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der angibt, dass die maximal mögliche Anzahl von Nachrichtenthemen erreicht wurde und nicht mehr erstellt werden kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Aufgabe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anzuweisen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">auf eine Nachricht zum Thema </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hTopic</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu warten </font><font style="vertical-align: inherit;">, rufen Sie </font><b><font style="vertical-align: inherit;">OS_WaitMessage</font></b><font style="vertical-align: inherit;"> in ihrem Code auf </font><font style="vertical-align: inherit;">und übergeben Sie das Handle des Themas als Argument. Nach dem Aufrufen dieses Dienstes wird die Steuerung automatisch an den Task-Manager übertragen. Somit versetzt dieser Dienst die aktuelle Aufgabe in einen Zustand</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten Sie auf eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hTopic-Nachricht</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wartedienst</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem Timeout </font><b><font style="vertical-align: inherit;">OS_WaitMessageTO</font></b><font style="vertical-align: inherit;"> funktioniert ähnlich wie der Dienst </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_WaitEventTO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des </font><b><font style="vertical-align: inherit;">Ereignissystems</font></b><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Senden von Nachrichten wird der Dienst </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_SendMessage bereitgestellt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das erste Argument ist der Griff der Themen , </font><font style="vertical-align: inherit;">auf das die Nachricht übertragen werden, und die zweite - das Argument Dimension </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wort</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies kann entweder eine unabhängige Zahl oder ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeiger auf eine Zeichenfolge sein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die wiederum bereits eine Nachricht ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um einen Zeilenzeiger zu erhalten, verwenden Sie einfach die in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BASCOM integrierte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> varptr-Funktion </font><font style="vertical-align: inherit;">wie </font><font style="vertical-align: inherit;">folgt </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="vbscript hljs">strMessage = <span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span> OS_SendMessage hTopic, varptr (strMessage)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederaufnahme der Arbeit nach dem Aufruf von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_WaitMessage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><b><font style="vertical-align: inherit;">dh</font></b><font style="vertical-align: inherit;"> wenn die erwartete Nachricht empfangen wird, kann die Task die Nachricht entweder mit ihrer nachfolgenden automatischen Zerstörung empfangen oder nur die Nachricht anzeigen - in diesem Fall wird sie nicht zerstört. Verwenden Sie dazu die letzten vier Dienste in der Liste. Die ersten beiden Rück die Anzahl der Dimensionen des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wortes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die entweder eine separate Nachricht sein kann, oder dienen als Zeiger auf eine Zeichenkette, die die Nachricht enthält. In diesem Fall </font><font style="vertical-align: inherit;">löscht </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_GetMessage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Nachricht automatisch und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_PeekMessage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verlässt sie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Aufgabe sofort eine Zeichenfolge und keinen Zeiger benötigt, können Sie die Dienste </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_GetMessageString</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_PeekMessageString verwenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die ähnlich wie die beiden vorherigen funktionieren, aber einen String zurückgeben, keinen Zeiger darauf. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interner Timer-Service </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die </font><font style="vertical-align: inherit;">Arbeit mit den Verzögerungen und Timing AQUA RTOS verwendet einen eingebauten IC Hardware - </font><font style="vertical-align: inherit;">Timer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIMER0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Daher sollte externer Code (Hintergrund und Aufgaben) diesen Timer nicht verwenden. </font><font style="vertical-align: inherit;">Aber normalerweise ist dies nicht erforderlich, weil </font><font style="vertical-align: inherit;">Das Betriebssystem liefert Aufgaben mit allen notwendigen Werkzeugen, um mit Zeitintervallen zu arbeiten. </font><font style="vertical-align: inherit;">Die Timer-Auflösung beträgt 1 ms.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beispiele für die Arbeit mit AQUA RTOS </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grundeinstellungen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ganz am Anfang des Benutzercodes müssen Sie festlegen, ob der Code im integrierten Simulator oder auf realer Hardware ausgeführt wird. </font><font style="vertical-align: inherit;">Definieren Sie die Konstante </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_SIM = TRUE | </font><font style="vertical-align: inherit;">FALSE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das den Simulationsmodus einstellt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bearbeiten Sie außerdem im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betriebssystemcode die</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstante </font><b><font style="vertical-align: inherit;">OS_MAX_TASK</font></b><font style="vertical-align: inherit;"> , die die maximale Anzahl der vom Betriebssystem unterstützten Aufgaben bestimmt. </font><font style="vertical-align: inherit;">Je niedriger diese Zahl, desto schneller arbeitet das Betriebssystem (weniger Overhead) und desto weniger Speicher verbraucht es. </font><font style="vertical-align: inherit;">Daher sollten Sie dort nicht mehr Aufgaben angeben, als Sie benötigen. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergessen Sie nicht, diese Konstante zu ändern, wenn sich die Anzahl der Aufgaben geändert hat.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betriebssysteminitialisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor dem Start muss AQUA RTOS initialisiert werden. Rufen Sie dazu den Dienst </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_Init</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf </font><font style="vertical-align: inherit;">. Dieser Dienst konfiguriert die anfänglichen Betriebssystemeinstellungen. Noch wichtiger ist, dass es ein Argument gibt - die Adresse der benutzerdefinierten Fehlerbehandlungsroutine. Sie hat wiederum ein Argument - einen Fehlercode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Handler muss sich im Benutzercode befinden (zumindest in Form eines Stubs) - das Betriebssystem sendet Fehlercodes an ihn, und der Benutzer hat keine andere Möglichkeit, sie abzufangen und entsprechend zu verarbeiten. Ich empfehle dringend, zumindest in der Entwicklungsphase keinen Stub zu setzen, sondern die Ausgabe von Fehlerinformationen in dieses Verfahren einzubeziehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Schritt bei der Arbeit mit AQUA RTOS besteht darin, den Betriebssysteminitialisierungscode und die Fehlerbehandlungsprozedur zum Benutzerprogramm hinzuzufügen:</font></font><br><br><pre> <code class="vbscript hljs">OS_Init my_err_trap <span class="hljs-comment"><span class="hljs-comment">'... '... '... sub my_err_trap(err_code as byte) print err_code end sub</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgabeninitialisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der zweite Schritt besteht darin, die Aufgaben durch Angabe ihres Namens und ihrer Priorität zu initialisieren: </font></font><br><br><pre> <code class="vbscript hljs">OS_InitTask task_1, <span class="hljs-number"><span class="hljs-number">1</span></span> OS_InitTask task_2 , <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">'... OS_InitTask task_N , 1</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testaufgaben </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LED blinkt </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen wir also eine Testanwendung, die auf eine Standard-Arduino Nano V3-Karte heruntergeladen werden kann. </font><font style="vertical-align: inherit;">Erstellen Sie einen Ordner in dem Ordner mit der Betriebssystemdatei (z. B. Test) und erstellen Sie dort die folgende Basisdatei:</font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $regfile = "m328pdef.dat" $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 '   declare sub my_err_trap (byval err_code as byte) declare sub task_1() declare sub task_2() '       led_1 alias portd.4 led_2 alias portd.5 config portd.4 = output config portd.5 = output ' ***    *** '   OS_Init my_err_trap '   OS_InitTask task_1, 1 OS_InitTask task_2 , 1 '      «» (OSTS_STOP) '    ,     ' «  » (OSTS_READY)   OS_ResumeTask OS_ResumeTask task_1 OS_ResumeTask task_2 '      OS_Sheduler end ' ***  *** sub task_1 () do toogle led_1 '   1 OS_delay 1000 '   1000  loop end sub sub task_2 () do toogle led_2 '   2 OS_delay 333 '   333  loop end sub ' **************************************************** '   sub my_err_trap(err_code as byte) print "OS Error: "; err_code end sub</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbinden Sie die Anoden der LEDs mit den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D4-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D5-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pins </font><font style="vertical-align: inherit;">der Arduino-Karte (oder mit anderen Pins, indem Sie die entsprechenden Definitionszeilen im Code ändern). Verbinden Sie die Kathoden über 100 ... 500 Ohm Abschlusswiderstände mit dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GND-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bus </font><font style="vertical-align: inherit;">. Kompilieren Sie die Firmware und laden Sie sie auf das Board hoch. Die LEDs beginnen mit einer Zeitspanne von 2 und 0,66 s asynchron zu schalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns den Code an. Also initialisieren wir zuerst die Ausrüstung (wir setzen die Compileroptionen, den Portmodus und weisen Aliase zu), dann das Betriebssystem selbst und schließlich die Aufgaben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da sich die gerade erstellten Aufgaben im Status "Gestoppt" befinden, müssen Sie ihnen den Status "Bereit zur Ausführung" geben (möglicherweise nicht für alle Aufgaben in einer realen Anwendung - schließlich können einige von ihnen, wie vom Entwickler konzipiert, zunächst gestoppt und ausgeführt werden Ausführung nur von anderen Tasks und nicht sofort zu Beginn des Systems (in diesem Beispiel sollten jedoch beide Tasks sofort funktionieren). Daher rufen wir für jede Aufgabe den Dienst </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_ResumeTask</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sind die Aufgaben zur Ausführung bereit, aber noch nicht abgeschlossen. Wer wird sie starten? Natürlich der Dispatcher! Dazu müssen wir es beim ersten Start des Systems aufrufen. Wenn nun alles richtig geschrieben ist, führt der Dispatcher unsere Aufgaben einzeln aus, und wir können den Hauptteil des Programms mit der </font><b><font style="vertical-align: inherit;">end-</font></b><font style="vertical-align: inherit;"> Anweisung </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns die Aufgaben an. Es ist sofort ersichtlich, dass jeder von ihnen als endlose </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do-Loop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gerahmt ist </font><font style="vertical-align: inherit;">. Die zweite wichtige Eigenschaft - innerhalb eines solchen Zyklus muss mindestens ein Aufruf an den Dispatcher oder den Betriebssystemdienst erfolgen, der den Dispatcher automatisch nach sich selbst aufruft - andernfalls gibt eine solche Aufgabe niemals die Kontrolle auf und andere Aufgaben können nicht ausgeführt werden. In unserem Fall ist dies der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_Delay-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verzögerungsdienst </font><font style="vertical-align: inherit;">. Als Argument haben wir ihm die Anzahl der Millisekunden angegeben, für die jede Aufgabe angehalten werden soll. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie am Anfang des Codes die Konstante </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_SIM = TRUE setzen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und den Code nicht auf dem realen Chip, sondern im Simulator ausführen, können Sie die Funktionsweise des Betriebssystems verfolgen.</font></font><br><br> ,   , ,      «  »,       .   ,    «   »,         . <br><br>  ,    (, <b>task_1</b> ),       (     <b>end</b>   )     <b>task_1</b> ,       ,    <b>return</b> ,             –  ,    <b>task_1</b> ( <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code </font><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Task </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schaltet ihre LED um und ruft den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_delay-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dienst auf </font><font style="vertical-align: inherit;">, der nach Abschluss der erforderlichen Aktionen an den Dispatcher geht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Dispatcher speichert die auf dem Stapel befindliche Adresse in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasksteuereinheit task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (zeigt auf die Anweisung nach dem Aufruf von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><b><font style="vertical-align: inherit;">dh auf</font></b><font style="vertical-align: inherit;"> die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schleifenanweisung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), und stellt dann beim Drehen des Karussells fest, dass </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jetzt abgeschlossen sein muss </font><font style="vertical-align: inherit;">. Es drückt die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taskadresse task_2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (zeigt derzeit auf die Anweisung </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taskcode task_2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und führt den Befehl aus</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wodurch der MK die Rücksprungadresse vom Stapel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abruft</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und dorthin wechselt - </font><b><font style="vertical-align: inherit;">dh Task_2</font></b><font style="vertical-align: inherit;"> ausführt </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schaltet seine LED um und ruft den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_delay-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dienst auf </font><font style="vertical-align: inherit;">, der nach Ausführung der erforderlichen Aktionen zum Dispatcher geht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Dispatcher speichert die auf dem Stapel befindliche Adresse in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasksteuereinheit task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (zeigt auf die Anweisung nach dem Aufruf von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><b><font style="vertical-align: inherit;">dh auf</font></b><font style="vertical-align: inherit;"> die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schleifenanweisung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), und stellt dann beim Drehen des Karussells fest, dass </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jetzt abgeschlossen sein muss </font><font style="vertical-align: inherit;">. Der Unterschied zum Ausgangszustand besteht darin, dass er sich jetzt im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasksteuerblock task_1 befindet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird nicht die Startadresse der Aufgabe gespeichert, sondern die Adresse des Punktes, von dem aus der Übergang zum Dispatcher stattgefunden hat. </font><font style="vertical-align: inherit;">Dort (zur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schleifenanweisung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taskcode task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) wird die Steuerung übertragen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> führt die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schleifenanweisung aus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und dann wird der gesamte Zyklus "Task 1 - Dispatcher - Task 2 - Dispatcher" endlos wiederholt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachrichten senden </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versuchen wir nun, Nachrichten von einer Aufgabe an eine andere zu senden. </font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $regfile = "m328pdef.dat" $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 '   declare sub my_err_trap (byval err_code as byte) declare sub task_1() declare sub task_2() const OS_SIM = TURE '       '   dim hTopic as byte '     dim task_1_cnt as byte '    1 dim strMessage as string * 16 '  ' ***    *** OS_CreateMessage hTopic OS_Init my_err_trap OS_InitTask task_1 , 1 OS_InitTask task_2 , 1 OS_ResumeTask task_1 OS_ResumeTask task_2 OS_Sheduler end ' ***  *** sub task_1() do print "task 1" OS_Sheduler incr task_1_cnt '    1 if task_1_cnt &gt; 3 then print "task 1 is sending message to task 2" strMessage = "Hello, task 2!" '    2 OS_SendMessage hTopic , varptr(strMessage) task_1_cnt = 0 end if loop end sub sub task_2() do print "task 2 is waiting messages..." '      1 OS_WaitMessage hTopic print "message recieved: " ; OS_GetMessageString (hTopic) loop end sub ' **************************************************** '   sub my_err_trap(err_code as byte) print "OS Error: "; err_code end sub</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Ergebnis der Ausführung des Programms im Simulator ist die folgende Ausgabe im Terminalfenster: </font></font><br><br><blockquote> task 1 <br> task 2 is waiting messages… <br> task 1 <br> task 1 <br> task 1 <br> task 1 is sending message to task 2 <br> task 1 <br> message recieved: Hello, task 2! <br> task 2 is waiting messages… <br> task 1 <br> task 1 <br>  ... <br></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Achten Sie auf die Reihenfolge, in der die Arbeit und der Aufgabenwechsel stattfinden. Sobald Aufgabe 1 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgabe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 druckt </font><font style="vertical-align: inherit;">, wird die Kontrolle an den Dispatcher übertragen, damit dieser die zweite Aufgabe starten kann. Task 2 druckt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task 2 wartet auf Nachrichten ...</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ruft dann den Nachrichtenwartedienst für das Thema </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hTopic auf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die Steuerung wird automatisch an den Dispatcher übertragen, der erneut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 aufruft. Er druckt erneut </font><b><font style="vertical-align: inherit;">Task 1</font></b><font style="vertical-align: inherit;"> und gibt dem Dispatcher die Kontrolle. Da der Dispatcher jedoch feststellt, dass Task 2 jetzt auf Nachrichten wartet, gibt er in der Anweisung </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nach dem Dispatcher-Aufruf die </font><font style="vertical-align: inherit;">Kontrolle an Task 1 zurück </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Zähler </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task_1_cnt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Task 1 wird der angegebene Wert überschritten. Die Task sendet eine Nachricht, wird jedoch weiterhin ausgeführt. Führt die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schleifenanweisung aus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und druckt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task 1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erneut </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach ruft sie den Dispatcher an, der nun feststellt, dass eine Nachricht für Aufgabe 2 vorliegt, und überträgt die Kontrolle an sie. </font><font style="vertical-align: inherit;">Als nächstes wird der Prozess zyklisch ausgeführt.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignisbehandlung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der folgende Code fragt zwei Tasten ab und schaltet die LEDs um, wenn Sie die entsprechende Taste drücken: </font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $regfile = "m328pdef.dat" $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 '   declare sub my_err_trap (byval err_code as byte) declare sub task_scankeys() declare sub task_led_1() declare sub task_led_2() '        led_1 alias portd.4 led_2 alias portd.5 config portd.4 = output config portd.5 = output button_1 alias pind.6 button_2 alias pind.7 config portd.6 = input config portd.7 = input '   dim eventButton_1 as byte dim eventButton_2 as byte ' ***    *** eventButton_1 = OS_CreateEvent '       eventButton_2 = OS_CreateEvent OS_Init my_err_trap OS_InitTask task_scankeys , 1 OS_InitTask task_led_1 , 1 OS_InitTask task_led_2 , 1 OS_ResumeTask task_scankeys OS_ResumeTask task_led_1 OS_ResumeTask task_led_2 OS_Sheduler end ' ***  *** sub task_scankeys() do debounce button_1 , 0 , btn_1_click , sub debounce button_2 , 0 , btn_2_click , sub OS_Sheduler loop btn_1_click: OS_SignalEvent eventButton_1 return btn_2_click: OS_SignalEvent eventButton_2 return end sub sub task_led_1() do OS_WaitEvent eventButton_1 toggle led_1 loop end sub sub task_led_2() do OS_WaitEvent eventButton_2 toggle led_2 loop end sub ' **************************************************** '   sub my_err_trap(err_code as byte) print "OS Error: "; err_code end sub</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein echtes Anwendungsbeispiel unter AQUA RTOS </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen wir uns vorzustellen, wie ein Kaffeeautomatenprogramm aussehen könnte. </font><font style="vertical-align: inherit;">Das Gerät sollte das Vorhandensein von Kaffeeoptionen und die Auswahl der LEDs in den Tasten anzeigen. </font><font style="vertical-align: inherit;">Signale vom Münzempfänger empfangen, das bestellte Getränk zubereiten, Wechselgeld ausgeben. </font><font style="vertical-align: inherit;">Darüber hinaus muss die Maschine die internen Geräte steuern: Halten Sie beispielsweise die Temperatur des Warmwasserbereiters bei 95 ... 97 ° C; </font><font style="vertical-align: inherit;">Übertragen Sie Daten zu Gerätestörungen und Bestandteilen von Zutaten und empfangen Sie Befehle über Fernzugriff (z. B. über ein GSM-Modem) sowie Signalvandalismus.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignisgesteuerter Ansatz </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst kann es für einen Entwickler schwierig sein, vom üblichen Schema „Supercycle + Flags + Interrupts“ zu einem auf Aufgaben und Ereignissen basierenden Ansatz zu wechseln. </font><font style="vertical-align: inherit;">Dazu müssen die grundlegenden Aufgaben hervorgehoben werden, die das Gerät ausführen soll. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen wir, solche Aufgaben für unsere Maschine zu skizzieren:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heizungssteuerung und -verwaltung - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ControlHeater ()</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angabe der Verfügbarkeit und Auswahl der Getränke - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShowGoods ()</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Annahme von Münzen / Scheinen und deren Summierung - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AcceptMoney ()</font></font></b> </li><li><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Abfragetasten</font></b><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScanKeys ()</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lieferung ändern - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MakeChange ()</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getränkeurlaub - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee ()</font></font></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vandalismusschutz - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alarm ()</font></font></b> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns den Grad der Wichtigkeit der Aufgaben und die Häufigkeit ihres Anrufs abschätzen. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ControlHeater () ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> offensichtlich wichtig, weil wir immer kochendes Wasser brauchen, um Kaffee zu machen. Es sollte jedoch nicht zu oft durchgeführt werden, da die Heizung eine hohe Trägheit aufweist und das Wasser langsam abkühlt. Es reicht aus, die Temperatur einmal pro Minute zu überprüfen. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geben Sie</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dieser Aufgabe Priorität 5. </font><b><font style="vertical-align: inherit;">ShowGoods () ist</font></b><font style="vertical-align: inherit;"> nicht zu wichtig. Das Angebot kann sich erst nach Freigabe der Ware ändern, wenn der Vorrat an Zutaten erschöpft ist. Daher geben wir dieser Aufgabe eine Priorität von 8 und lassen sie ausführen, wenn die Maschine startet und jedes Mal, wenn die Waren freigegeben werden. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScanKeys ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss eine ausreichend hohe Priorität haben, damit die Maschine schnell auf Tastendrücke reagieren kann. Geben Sie dieser Aufgabe Priorität 3, und wir werden sie alle 40 Millisekunden ausführen. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AcceptMoney () ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auch Teil der Benutzeroberfläche. Wir geben ihm die gleiche Priorität wie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScanKeys ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und führen ihn alle 20 Millisekunden aus. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MakeChange ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird erst ausgeführt, nachdem die Ware freigegeben wurde. Wir werden es mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee () verknüpfen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Priorität 10 geben. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee () wird</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nur benötigt, wenn der entsprechende Geldbetrag akzeptiert wurde und die Getränkeauswahltaste gedrückt wird. Für eine schnelle Reaktion geben wir ihm Priorität 2. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Vandalismusresistenz eine ziemlich wichtige Funktion der Maschine ist, ist die Aufgabe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alarm ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können die höchste Priorität auf 1 setzen und einmal pro Sekunde aktivieren, um die Neigungs- oder Manipulationssensoren zu überprüfen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir brauchen also sieben Aufgaben mit unterschiedlichen Prioritäten. </font><font style="vertical-align: inherit;">Wenn das Programm nach dem Start die Einstellungen aus dem EEPROM liest und das Gerät initialisiert, ist es Zeit, das Betriebssystem zu initialisieren und die Aufgaben zu starten.</font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    declare sub ControlHeater() declare sub ShowGoods() declare sub AcceptMoney() declare sub ScanKeys() declare sub MakeChange () declare sub ReleaseCoffee() declare sub Alarm()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um als Teil von RTOS zu arbeiten, muss jede Aufgabe eine bestimmte Struktur haben: Sie muss mindestens einen Aufruf an den Dispatcher haben (oder einen Betriebssystemdienst, der die Kontrolle automatisch an den Dispatcher überträgt) - dies ist die einzige Möglichkeit, kooperatives Multitasking sicherzustellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel </font><font style="vertical-align: inherit;">könnte </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee () ungefähr so</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aussehen:</font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> ReleaseCoffee() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> OS_WaitMessage bCoffeeSelection wItem = OS_GetMessage(bCoffeeSelection) Release wItem <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgabe </font><font style="vertical-align: inherit;">in einer Endlosschleife erwartet eine Nachricht zum Thema </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bCoffeeSelection</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und unternimmt nichts, bis sie eintrifft (die Steuerung wird automatisch an den Dispatcher zurückgegeben, damit er andere Aufgaben starten kann). Sobald die Nachricht gesendet wird, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird bereit zu laufen, und wenn das geschieht, wird die Aufgabe , </font><font style="vertical-align: inherit;">den Inhalt der Nachricht (der Code des ausgewählten Getränks) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wItem</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durch den Dienst </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_GetMessage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und gibt die Ware an den Kunden. Da </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das Nachrichtensubsystem verwendet, muss vor dem Starten von Multitasking eine Nachricht erstellt werden:</font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">dim</span></span> bCoffeeSelection as byte bCoffeeSelection = OS_CreateMessage()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie oben erwähnt, muss </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShowGoods ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einmal beim Start und jedes Mal ausgeführt werden, wenn Waren freigegeben werden. </font><font style="vertical-align: inherit;">Um es mit dem Release-Verfahren </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee () zu verknüpfen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , verwenden wir den Event-Service. </font><font style="vertical-align: inherit;">Erstellen Sie dazu ein Ereignis, bevor Sie mit dem Multitasking beginnen:</font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">dim</span></span> bGoodsReliased as byte bGoodsReliased = OS_CreateEvent()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReleaseCoffee ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Prozedur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fügen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><font style="vertical-align: inherit;">nach der Zeile </font><b><font style="vertical-align: inherit;">Release wItem</font></b><font style="vertical-align: inherit;"> einen Alarm über das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bGoodsReliased-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignis hinzu </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="vbscript hljs">OS_SignalEvent bGoodsReliased</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betriebssysteminitialisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Betriebssystem für die Arbeit vorzubereiten, müssen wir es initialisieren und die Adresse des Fehlerbehandlers angeben, die sich im Benutzercode befindet. </font><font style="vertical-align: inherit;">Wir tun dies mit dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_Init-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dienst </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="vbscript hljs">OS_Init Mailfuncion</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im Benutzercode müssen Sie einen Handler hinzufügen - eine Prozedur, deren Byteargument der Fehlercode ist: </font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> Mailfuncion (bCoffeeErr) print <span class="hljs-string"><span class="hljs-string">"Mailfunction! Error #: "</span></span>; bCoffeeErr <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isErrCritical (bCoffeeErr) = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CallService(bCoffeeErr) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bei diesem Verfahren wird ein Fehlercode gedruckt (oder auf andere Weise angezeigt: auf dem Bildschirm, über ein GSM-Modem usw.). Wenn der Fehler kritisch ist, wird die Serviceabteilung angerufen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aufgabenstart </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erinnern uns bereits daran, dass Ereignisse, Semaphoren usw. </font><font style="vertical-align: inherit;">muss vor der Verwendung initialisiert werden. </font><font style="vertical-align: inherit;">Darüber hinaus müssen die Aufgaben selbst </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vor dem Start</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem Dienst </font><b><font style="vertical-align: inherit;">OS_InitTask</font></b><font style="vertical-align: inherit;"> initialisiert werden </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="vbscript hljs">OS_InitTask ControlHeater , <span class="hljs-number"><span class="hljs-number">5</span></span> OS_InitTask ShowGoods , <span class="hljs-number"><span class="hljs-number">8</span></span> OS_InitTask AcceptMoney , <span class="hljs-number"><span class="hljs-number">3</span></span> OS_InitTask ScanKeys , <span class="hljs-number"><span class="hljs-number">3</span></span> OS_InitTask MakeChange, <span class="hljs-number"><span class="hljs-number">10</span></span> OS_InitTask ReleaseCoffee , <span class="hljs-number"><span class="hljs-number">2</span></span> OS_InitTask Alarm , <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Multitasking-Modus noch nicht begonnen hat, ist die Reihenfolge, in der die Aufgaben beginnen, unerheblich und hängt in keinem Fall von ihren Prioritäten ab. </font><font style="vertical-align: inherit;">Zu diesem Zeitpunkt befinden sich alle Aufgaben noch im gestoppten Zustand. </font><font style="vertical-align: inherit;">Um sie für die Ausführung vorzubereiten, müssen wir den Dienst </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_ResumeTask verwenden,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um ihnen den Status "Ausführungsbereit" zu setzen:</font></font><br><br><pre> <code class="vbscript hljs">OS_ResumeTask ControlHeater OS_ResumeTask ShowGoods OS_ResumeTask AcceptMoney OS_ResumeTask ScanKeys OS_ResumeTask MakeChange OS_ResumeTask ReleaseCoffee OS_ResumeTask Alarm</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bereits erwähnt, müssen nicht alle Aufgaben unbedingt gestartet werden, wenn Multitasking gestartet wird. </font><font style="vertical-align: inherit;">Einige von ihnen können jederzeit in einem „gestoppten“ Zustand bleiben und nur unter bestimmten Bedingungen bereit sein. </font><font style="vertical-align: inherit;">Der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_ResumeTask-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dienst </font><font style="vertical-align: inherit;">kann jederzeit von einer beliebigen Stelle im Code (Hintergrund oder Aufgabe) aufgerufen werden, wenn bereits Multitasking ausgeführt wird. </font><font style="vertical-align: inherit;">Die Hauptsache ist, dass die Aufgabe, auf die es sich bezieht, vorinitialisiert ist.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multitasking-Start </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist alles bereit, um Multitasking zu starten. </font><font style="vertical-align: inherit;">Dazu rufen wir den Dispatcher an:</font></font><br><br><pre> <code class="vbscript hljs">OS_Sheduler</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach können wir den Programmcode sicher </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beenden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - das Betriebssystem kümmert sich nun um die weitere Ausführung des Codes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns den gesamten Code an:</font></font><br><br><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">'    config submode = old $include "..\aquaRTOS_1.05.bas" $include "coffee_hardware.bas" '      '       Coffee_ $regfile = "m328pdef.dat" ' Arduino Nano v3 $crystal = 16000000 $hwstack = 48 $swstack = 48 $framesize = 64 Coffee_InitHardware '    '   declare sub Mailfuncion (byval bCoffeeErr as byte) '   declare sub ControlHeater () '   declare sub ShowGoods () '    declare sub AcceptMoney () '   declare sub ScanKeys () '   declare sub MakeChange () '      declare sub ReleaseCoffee () '   declare sub Alarm () '    '     Coffee_InitHardware () '   dim wMoney as long '    dim wGoods as long '   ' ***    *** '   OS_Init Mailfuncion '       dim bCoffeeSelection as byte bCoffeeSelection = OS_CreateMessage() '     dim bGoodsReliased as byte bGoodsReliased = OS_CreateEvent() '   OS_InitTask ControlHeater , 5 OS_InitTask ShowGoods , 8 OS_InitTask AcceptMoney , 3 OS_InitTask ScanKeys , 3 OS_InitTask MakeChange, 10 OS_InitTask ReleaseCoffee , 2 OS_InitTask Alarm , 1 '     OS_ResumeTask ControlHeater OS_ResumeTask ShowGoods OS_ResumeTask AcceptMoney OS_ResumeTask ScanKeys OS_ResumeTask MakeChange OS_ResumeTask ReleaseCoffee OS_ResumeTask Alarm '   OS_Sheduler end ' ***   *** ' ----------------------------------- sub ControlHeater() do select case GetWaterTemp() case is &gt; 97 Coffee_HeaterOff '   case is &lt; 95 Coffee_HeaterOn '   case is &lt; 5 CallServce (WARNING_WATER_FROZEN) '   end select OS_Delay 60000 '  1  loop end sub ' ----------------------------------- sub ShowGoods() do LEDS = Coffee_GetDrinkSupplies() '    D, '         '   LEDS OS_WaitEvent bGoodsReliased '   " " loop end sub ' ----------------------------------- sub AcceptMoney() do wMoney = wMoney + ReadMoneyAcceptor() OS_Delay 20 loop end sub ' ----------------------------------- sub ScanKeys() do wGoods = ButtonPressed() if wMoney &gt;= GostOf(wGoods) then OS_SendMessage bCoffeeSelection, wGoods '     bCoffeeSelection,  '     end if OS_Delay 40 loop end sub ' ----------------------------------- sub MakeChange() do OS_WaitEvent bGoodsReliased '   " " Refund wMoney loop end sub ' ----------------------------------- sub ReleaseCoffee() do OS_WaitMessage bCoffeeSelection '  bCoffeeSelection wItem = OS_GetMessage(bCoffeeSelection) '   Release wItem '    wMoney = wMoney – CostOf (wItem) '     OS_SignalEvent bGoodsReliased '     '  ,       : ' MakeChange  ShowGoods '  ,  ,     loop end sub ' ----------------------------------- sub Alarm() do OS_Delay 1000 if Hijack() = 1 then CallPolice() end if loop end sub ' ----------------------------------- ' ***    *** sub Mailfuncion (bCoffeeErr) print "Mailfunction! Error #: "; bCoffeeErr if isErrCritical (bCoffeeErr) = 1 then CallService() end if end sub</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich wäre ein Ansatz korrekter, nicht bei periodischen Abfragen von Tasten und Geldsensoren, sondern bei Verwendung von Interrupts. </font><font style="vertical-align: inherit;">In den Handlern dieser Interrupts könnten wir das Senden von Nachrichten mit dem Dienst </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OS_SendMessage () verwenden, deren</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhalt der Nummer der gedrückten Taste oder dem Wert der eingegebenen Münze / Rechnung entspricht. </font><font style="vertical-align: inherit;">Ich lade den Leser ein, das Programm selbst zu ändern. </font><font style="vertical-align: inherit;">Dank des aufgabenorientierten Ansatzes und des vom Betriebssystem bereitgestellten Dienstes sind hierfür nur minimale Codeänderungen erforderlich.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AQUA RTOS Quellcode </font></font></h2><br> <a href=""><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Quellcode der Version 1.05 steht hier zum Download bereit</font></font></b></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachtrag </font></font></h2><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F: Warum AQUA?</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A: Nun, ich habe den Aquarium-Controller gemacht, es ist wie ein "Smart Home", nicht nur für Menschen, sondern auch für Fische. Voll mit Sensoren aller Art, einer Echtzeituhr, Relais- und Analogausgängen, einem Bildschirmmenü, einem flexiblen "Ereignisprogramm" und sogar einem WiFi-Modul. Die Intervalle sollten gezählt werden, die Tasten sollten abgefragt werden, die Sensoren sollten verarbeitet werden, das Ereignisprogramm sollte aus dem EEPROM gelesen und ausgeführt werden, der Bildschirm sollte aktualisiert werden, das WLAN sollte reagieren. Darüber hinaus muss der Controller für Einstellungen und Programmierung in ein mehrstufiges Menü gehen. Bei Flags und Interrupts muss nur der „Pasta-Code“ abgerufen werden, der weder verstanden noch geändert wird. Deshalb habe ich beschlossen, dass ich ein Betriebssystem brauche. Hier ist sie AQUA. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F: Sicher ist der Code voller logischer Fehler und Pannen?</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A: Sicher. </font><font style="vertical-align: inherit;">Ich habe, so gut ich konnte, eine Reihe von Tests entwickelt und das Betriebssystem für eine Vielzahl von Aufgaben eingesetzt und sogar eine bemerkenswerte Anzahl von Fehlern zugeschlagen, aber dies bedeutet nicht, dass alles vollständig ist. </font><font style="vertical-align: inherit;">Ich bin mir mehr als sicher, dass es noch viele davon in den Seitenstraßen des Codes gibt. </font><font style="vertical-align: inherit;">Daher bin ich Ihnen sehr dankbar, wenn Sie, anstatt mich in die Käfer ins Gesicht zu stechen, höflich und taktvoll auf sie zeigen und mir besser sagen, wie Sie denken, dass es besser ist, sie zu beheben. </font><font style="vertical-align: inherit;">Es wird auch großartig sein, wenn das Projekt als Produkt kollektiver Kreativität weiterentwickelt wird. </font><font style="vertical-align: inherit;">Zum Beispiel wird jemand einen Dienst zum Zählen von Semaphoren hinzufügen (nicht vergessen? - Ich bin ein fauler Arsch) und andere Verbesserungen anbieten. </font><font style="vertical-align: inherit;">Auf jeden Fall werde ich für den konstruktiven Beitrag sehr dankbar sein.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453708/">https://habr.com/ru/post/de453708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453694/index.html">Stellen Sie wie unter Linux eine Verbindung zu Windows über SSH her</a></li>
<li><a href="../de453696/index.html">Winkel-Zwei-Wege-Bindung, etwas verständnisvoller</a></li>
<li><a href="../de453698/index.html">Quanteninformation im Quantenbewusstsein</a></li>
<li><a href="../de453700/index.html">Lektionen zu SDL 2: Lektion 1 - Hallo, SDL 2</a></li>
<li><a href="../de453706/index.html">Wie ich die Zertifizierungsprüfung für Google Cloud Professional Data Engineer bestanden habe</a></li>
<li><a href="../de453710/index.html">Entwicklungspraxis in großen Projekten: mitp SberPractice iOS # 1</a></li>
<li><a href="../de453712/index.html">Wie eBay einen Barcode-Scanner in WebAssembly erstellt hat</a></li>
<li><a href="../de453714/index.html">TON-Testclient (Telegram Open Network) und die neue Fift-Sprache für intelligente Verträge</a></li>
<li><a href="../de453716/index.html">Country Coworking für Familien-IT-Mitarbeiter - gibt es jemanden?</a></li>
<li><a href="../de453720/index.html">Feinheiten von Lambda-Ausdrücken in C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>