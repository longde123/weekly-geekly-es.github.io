<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ù üî• ü§∑üèº Creaci√≥n de una m√°quina arcade emulador. Parte 1 üë∏üèº üçÑ üßñüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Escribir un emulador de m√°quinas recreativas es un gran proyecto educativo, y en este tutorial analizaremos muy detalladamente todo el proceso de desa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creaci√≥n de una m√°quina arcade emulador. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418635/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="imagen"></div><br>  Escribir un emulador de m√°quinas recreativas es un gran proyecto educativo, y en este tutorial analizaremos muy detalladamente todo el proceso de desarrollo.  ¬øRealmente quieres poner tus manos en el procesador?  Entonces crear un emulador es la mejor manera de aprenderlo. <br><br>  Necesitar√° conocimiento de C, as√≠ como conocimiento de ensamblador.  Si no conoce el lenguaje ensamblador, escribir un emulador es la mejor manera de aprenderlo.  Tambi√©n necesitar√° dominar las matem√°ticas hexadecimales (tambi√©n conocido como base 16 o simplemente "hexadecimal").  Hablar√© sobre este tema. <br><br>  Decid√≠ elegir un emulador para la m√°quina Space Invaders, que usa el procesador 8080. Este juego y este procesador son muy populares, porque en Internet puedes encontrar mucha informaci√≥n sobre ellos.  Lo necesitar√° para completar el proyecto. <br><br>  Todo el c√≥digo fuente del tutorial se carga en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> .  Si no ha dominado el trabajo con git, en la p√°gina de github hay un bot√≥n "Descargar ZIP" que le permite descargar el archivo con todo el c√≥digo. <br><a name="habracut"></a><br><h1>  Introducci√≥n a los n√∫meros binarios y hexadecimales. </h1><br>  En matem√°ticas "ordinarias", se utiliza el sistema de n√∫meros decimales.  Cada d√≠gito del n√∫mero puede tener un valor de cero a nueve, y cuando superamos el 9, agregamos uno al n√∫mero en el siguiente d√≠gito y comenzamos nuevamente desde cero.  Todo esto es bastante simple y directo, y probablemente nunca lo pensaste. <br><br>  Es posible que haya sabido o escuchado que las computadoras funcionan con datos binarios.  Los geeks inform√°ticos llaman matem√°tica decimal base-10 y la llamada binaria base-2.  En notaci√≥n binaria, cada d√≠gito de un n√∫mero puede tener solo dos valores, cero o uno.  En el c√≥digo binario, el recuento es el siguiente: 0, 1, 10, 11, 100, 101, 110, 111, 1000. Estos no son n√∫meros decimales, por lo que no puede llamarlos "cero, uno, diez, once, cien, ciento uno".  Se pronuncian como "cero, uno, uno-cero, uno-uno, uno-cero-cero", etc.  Raramente leo n√∫meros binarios en voz alta, pero si es necesario, debe indicar claramente el sistema de n√∫meros utilizado.  Diez, once y cien no tienen significado en notaci√≥n binaria. <br><br>  En notaci√≥n decimal, un n√∫mero tiene los siguientes d√≠gitos: unidades, decenas, cientos, miles, decenas de miles, etc.  En el sistema binario, los siguientes d√≠gitos: unidades, deuces, fours, ochos, etc.  <strong>En inform√°tica, el valor de cada bit binario se llama bit.</strong>  <strong>8 bits forman un byte.</strong> <br><br>  En t√©rminos binarios, una cadena de n√∫meros r√°pidamente se vuelve muy larga.  Para representar el n√∫mero decimal 20,000 en t√©rminos binarios, se requieren 16 d√≠gitos: 0b100111000100000.  Para solucionar este problema, es conveniente usar un sistema de n√∫meros hexadecimales, tambi√©n conocido como base-16 (o hexadecimal).  En base-16, cada d√≠gito contiene 16 valores.  Para valores de cero a nueve, se usan los mismos caracteres que en la base 10, pero para los 6 valores restantes, las sustituciones se usan en forma de las primeras 6 letras del alfabeto, de A a F. <br><br>  La cuenta en el sistema hexadecimal se realiza de la siguiente manera: 0 1 2 3 4 5 6 7 8 9 ABCDEF 10 11 12, etc.  En hexadecimal, decenas, cientos, etc. no tienen el mismo significado que en decimal, por lo que las personas pronuncian los n√∫meros por separado.  Por ejemplo, $ A57 se pronuncia en voz alta como "A-cinco-siete".  Para mayor claridad, tambi√©n puede agregar hex√°gono, por ejemplo, "A-cinco-siete-hex".  En el sistema de n√∫meros hexadecimales, el equivalente del n√∫mero decimal 20,000 es $ 4E20, una forma mucho m√°s compacta en comparaci√≥n con los 16 bits del sistema binario. <br><br>  Creo que el sistema hexadecimal fue elegido debido a una conversi√≥n muy natural de binario a hexadecimal y viceversa.  Cada d√≠gito hexadecimal corresponde a 4 bits (4 bits) de un n√∫mero binario similar.  <strong>2 d√≠gitos hexadecimales forman un byte (8 bits).</strong>  Un solo d√≠gito hexadecimal puede llamarse nibble, y algunas personas incluso lo escriben a trav√©s de y como "nybble". <br><br><table><tbody><tr><th colspan="4">  Cada d√≠gito hexadecimal tiene 4 d√≠gitos binarios. </th></tr><tr><td>  Maleficio </td><td>  Un </td><td>  5 5 </td><td>  7 7 </td></tr><tr><td>  Binario </td><td>  1010 </td><td>  0101 </td><td>  0111 </td></tr></tbody></table><br>  Al escribir el c√≥digo C, se cree que el n√∫mero es decimal (base-10), a menos que se marque lo contrario.  Para decirle al compilador de C que el n√∫mero es binario, agregamos el n√∫mero cero y la letra b en min√∫scula, de esta manera: <code>0b1101101</code> .  El n√∫mero hexadecimal se puede escribir en c√≥digo C agregando al principio de cero yx en min√∫sculas: <code>0xA57</code> .  Algunos lenguajes de ensamblaje usan el signo de d√≥lar $: <code>$A57</code> para indicar un n√∫mero hexadecimal. <br><br>  Si lo piensa, la conexi√≥n entre n√∫meros binarios, hexadecimales y decimales es bastante obvia, pero para el primer ingeniero, que hab√≠a pensado en esto antes de la invenci√≥n de la computadora, esto deber√≠a haberse convertido en un momento de comprensi√≥n. <br><br>  Entendido todo esto?  Genial <br><br><h1>  Una breve introducci√≥n al procesador. </h1><br>  <em>Si ya lo sabe, puede saltarse la secci√≥n de forma segura.</em> <br><br>  Una unidad central de procesamiento (CPU) es una m√°quina dise√±ada para ejecutar programas.  Los bloques fundamentales de la CPU son registros e instrucciones.  Como desarrollador de software, puede tratar estos registros como variables.  En nuestro procesador 8080, entre otros registros, hay registros de 8 bits llamados A, B, C, D y E. Estos registros se pueden interpretar como el siguiente c√≥digo C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A, B, C, D, E;</code> </pre> <br>  Todos los procesadores tambi√©n tienen un contador de programas (Contador de programas, PC).  Puedes tomarlo como un puntero. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pc;</code> </pre> <br>  Para una CPU, un programa es una secuencia de n√∫meros hexadecimales.  Cada instrucci√≥n de lenguaje ensamblador en 8080 corresponde a 1-3 bytes en el programa.  Para saber qu√© comando corresponde a qu√© n√∫mero, es √∫til el manual del procesador (o cualquier otra informaci√≥n sobre el procesador 8080 de Internet). <br><br>  Los nombres de los comandos (instrucciones) a menudo son mnemot√©cnicos de las operaciones realizadas por estos comandos.  El mnem√≥nico para cargar en 8080 es MOV (mover), y ADD se usa para realizar la adici√≥n. <br><br><h4>  Ejemplos </h4><br>  El valor de memoria actual indicado por el contador de instrucciones es 0x79.  Esto cumple con la instrucci√≥n <code>MOV A,C</code> procesador 8080. Este c√≥digo de ensamblaje en c√≥digo C se parece a <code>A=C;</code>  . <br><br>  Si, en cambio, el valor en la PC ser√≠a 0x80, entonces el procesador ejecutar√≠a <code>ADD B</code>  En C, esto corresponde a la cadena <code>A = A + B;</code>  . <br><br>  Puede encontrar una lista completa de las instrucciones del procesador 8080 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Para implementar nuestro emulador, utilizaremos esta informaci√≥n. <br><br><h4>  Tiempos </h4><br>  En la CPU, la ejecuci√≥n de cada instrucci√≥n requiere una cierta cantidad de tiempo (sincronizaci√≥n), medida en ciclos.  En los procesadores modernos, esta informaci√≥n puede ser dif√≠cil de obtener, porque los tiempos dependen de muchos aspectos diferentes.  Pero en procesadores m√°s antiguos como el 8080, los tiempos son constantes y el fabricante del procesador suele proporcionar esta informaci√≥n.  Por ejemplo, una instrucci√≥n de transferencia de registro a registro MOV toma 1 ciclo. <br><br>  La informaci√≥n de tiempo es √∫til para escribir c√≥digo eficiente en el procesador.  Un programador puede tratar de evitar las instrucciones que tardan muchos ciclos en completarse. <br><br>  M√°s importante para nosotros es que usaremos informaci√≥n de tiempo para emular el procesador.  Para que el juego funcione de la misma manera que en el original, las instrucciones deben ejecutarse a la velocidad correcta.  Algunos emuladores ponen mucho esfuerzo en esto, pero cuando lleguemos a esto, tendremos que decidir qu√© precisi√≥n queremos obtener. <br><br><h1>  Operaciones l√≥gicas </h1><br>  Antes de cerrar el tema de los n√∫meros binarios y hexadecimales, deber√≠amos hablar sobre operaciones l√≥gicas.  Probablemente ya est√© acostumbrado a usar la l√≥gica en su c√≥digo, por ejemplo, en construcciones como <code>if ((conditionA) and (conditionB))</code> .  En los programas que funcionan directamente con hardware, a menudo tiene que manipular bits individuales de n√∫meros. <br><br><h3>  Y operaci√≥n </h3><br>  Aqu√≠ est√°n todos los resultados posibles de la operaci√≥n AND (AND) (tabla de verdad) entre dos n√∫meros de un solo bit. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Resultado </td></tr><tr><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  0 0 </td><td>  1 </td><td>  0 0 </td></tr><tr><td>  1 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br>  El resultado de AND es igual a la unidad solo cuando ambos valores son iguales a la unidad.  Cuando combinamos dos n√∫meros con la operaci√≥n AND, AND para cada bit de un n√∫mero es AND con el bit correspondiente del otro n√∫mero.  El resultado se almacena en este bit del n√∫mero de destino.  Probablemente sea mejor solo mirar un ejemplo: <br><br><table><tbody><tr><td></td><td colspan="8">  binario </td><td>  maleficio </td></tr><tr><td>  fuente x </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  $ 6B </td></tr><tr><td>  fuente y </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  $ D2 </td></tr><tr><td>  x e y </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  $ 42 </td></tr></tbody></table><br>  En C, la operaci√≥n AND l√≥gica es un simple signo "&amp;". <br><br><h3>  Operaci√≥n OR (OR) </h3><br>  La operaci√≥n OR funciona de manera similar.  La √∫nica diferencia es que el resultado ser√° igual a uno si al menos uno de los valores de x o y es igual a uno. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Resultado </td></tr><tr><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  0 0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br><table><tbody><tr><td></td><td colspan="8">  binario </td><td>  maleficio </td></tr><tr><td>  fuente x </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  $ 6B </td></tr><tr><td>  fuente y </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  $ D2 </td></tr><tr><td>  x O y </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  $ Fb </td></tr></tbody></table><br>  En C, una operaci√≥n OR l√≥gica se indica mediante una barra vertical "|". <br><br><h3>  ¬øPor qu√© es esto importante? </h3><br>  En muchos procesadores m√°s antiguos, y especialmente en m√°quinas recreativas, el juego a menudo requiere trabajar con solo una parte del n√∫mero.  A menudo hay un c√≥digo similar: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*  1:     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buttons_ptr = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0x2043</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buttons = *buttons_ptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buttons &amp; <span class="hljs-number"><span class="hljs-number">0x4</span></span>) HandleLeftButton(); <span class="hljs-comment"><span class="hljs-comment">/*  2:  LED-    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * LED_pointer = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) <span class="hljs-number"><span class="hljs-number">0x2089</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> led = *LED_pointer; led = led | <span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,  LED   6 *LED_pointer = led; /*  3:   LED- */ char * LED_pointer = (char *) 0x2089; char led = *LED_pointer; led = led &amp; 0xBF; //  6 *LED_pointer = led;</span></span></code> </pre> <br>  En el ejemplo 1, la direcci√≥n $ 2043 asignada en la memoria es la direcci√≥n de los botones en el panel de control.  Este c√≥digo lee y responde al bot√≥n presionado.  (¬°Por supuesto, en Space Invaders este c√≥digo estar√° en lenguaje ensamblador!) <br><br>  En el ejemplo 2, el juego quiere encender un indicador LED, que se encuentra en el bit 6 de la direcci√≥n de $ 2089 asignada en la memoria.  El c√≥digo debe leer el valor existente, cambiar solo un bit y volver a escribirlo. <br><br>  En el ejemplo 3, debe apagar el indicador del ejemplo 2, por lo que el c√≥digo debe restablecer el bit 6 de la direcci√≥n $ 2089.  Esto se puede hacer realizando la operaci√≥n AND para el byte de control del indicador con un valor para el que solo el bit 6 es cero. Por lo tanto, afectaremos solo 6, dejando los bits restantes sin cambios. <br><br>  Esto generalmente se llama una "m√°scara".  En C, una m√°scara generalmente se escribe usando el operador NOT, denotado por una tilde ("~").  Por lo tanto, en lugar de escribir <code>0xBF</code> , simplemente escribo <code>~0x40</code> y obtengo el mismo n√∫mero, pero sin poner mucho esfuerzo. <br><br><h1>  Introducci√≥n al lenguaje ensamblador </h1><br>  Si lee este tutorial, probablemente est√© familiarizado con la programaci√≥n de computadoras, por ejemplo, en Java o Python.  Estos lenguajes le permiten hacer mucho trabajo en solo unas pocas l√≠neas de c√≥digo.  El c√≥digo se considera h√°bilmente escrito si hace el mayor trabajo posible en la menor cantidad de l√≠neas posible, posiblemente incluso utilizando la funcionalidad de las bibliotecas integradas.  Tales lenguajes se llaman "lenguajes de alto nivel". <br><br>  En lenguaje ensamblador, por el contrario, no hay funciones integradas para salvar vidas, y se pueden requerir muchas l√≠neas de c√≥digo simples para completar tareas simples.  El lenguaje ensamblador se considera un lenguaje de bajo nivel.  En √©l, debe acostumbrarse a pensar al estilo de "¬øqu√© secuencia espec√≠fica de pasos se deben tomar para completar esta tarea?" <br><br>  Lo m√°s importante que necesita saber sobre el lenguaje ensamblador es que cada l√≠nea se traduce en un comando de procesador. <br><br>  Considere tal construcci√≥n del lenguaje C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = b + <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  En lenguaje ensamblador, esta tarea deber√° realizarse en la siguiente secuencia: <br><br><ol><li>  Cargue la direcci√≥n de la variable B en el registro 1 </li><li>  Cargue el contenido de esta direcci√≥n de memoria en el registro 2 </li><li>  Agregue valor directo 0x64 para registrar 2 </li><li>  Cargue la direcci√≥n de la variable A en el registro 1 </li><li>  Escriba el contenido del registro 2 en la direcci√≥n almacenada en el registro 1 </li></ol><br>  En c√≥digo, se ver√° m√°s o menos as√≠: <br><br><pre> <code class="hljs pgsql"> lea a1, #<span class="hljs-meta"><span class="hljs-meta">$1000</span></span> ;   a lea a2, #<span class="hljs-meta"><span class="hljs-meta">$1008</span></span> ;   b <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>.l d0,(a2) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>.l d0, #<span class="hljs-meta"><span class="hljs-meta">$64</span></span> mov (a1),d0</code> </pre> <br>  Vale la pena se√±alar lo siguiente: <br><br><ul><li>  En un lenguaje de alto nivel, el compilador decide d√≥nde colocar las variables en la memoria.  Al escribir c√≥digo en ensamblador, usted mismo es responsable de cada direcci√≥n de memoria que utilizar√°. </li><li>  En la mayor√≠a de los lenguajes ensambladores, los corchetes significan "memoria en esta direcci√≥n". </li><li>  En la mayor√≠a de los lenguajes ensambladores, # denota un n√∫mero algebraico, tambi√©n llamado valor inmediato.  Por ejemplo, en la l√≠nea 1 del ejemplo anterior, el c√≥digo realmente escribe el valor # 0x1000 para registrar a1.  Si el c√≥digo se parece a <code>move.l a1, ($1000)</code> , entonces a1 recibir√≠a el contenido de la memoria en la direcci√≥n 0x1000. </li><li>  Cada procesador tiene su propio lenguaje ensamblador, y la transferencia de c√≥digo de un procesador a otro puede ser dif√≠cil. </li><li>  Este no es un lenguaje ensamblador de procesador real, se me ocurri√≥ como ejemplo. </li></ul><br>  Sin embargo, hay una cosa en com√∫n entre los programadores inteligentes de alto nivel y los asistentes de ensamblador.  Los programadores de ensambladores consideran un honor completar la tarea de la manera m√°s eficiente posible y minimizar la cantidad de instrucciones utilizadas.  El c√≥digo para las m√°quinas recreativas generalmente est√° altamente optimizado y todos los jugos se exprimen de cada byte y ciclo extra. <br><br><h1>  Pilas </h1><br>  Hablemos un poco m√°s sobre el lenguaje ensamblador.  En cualquier programa de computadora bastante complejo en el ensamblador se utilizan subrutinas.  La mayor√≠a de las CPU tienen una estructura llamada pila. <br><br>  Imagina una pila en forma de pila.  Si necesitamos guardar un n√∫mero, lo colocamos en la parte superior de la pila.  Cuando necesitamos traerlo de vuelta, lo tomamos de la parte superior de la pila.  Los programadores de ensambladores llaman "empujar" al n√∫mero emergente en la pila, y al llamarlo emergente se llama "pop". <br><br>  Digamos que mi programa necesita llamar a una subrutina.  Puedo escribir un c√≥digo similar: <br><br><pre> <code class="hljs css"> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1004</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;     0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1008</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1010</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;  .. 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1014</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1018</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x101C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1020</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1024</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-id"><span class="hljs-selector-id">#0x1030</span></span> ;   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1028</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x102C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#0x2040</span></span> ;   <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x2040</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1030</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1034</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1038</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x103c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span>  ..</code> </pre> <br>  El c√≥digo que se muestra arriba empuja los valores d0, d1, a0 y a1 a la pila.  La mayor√≠a de los procesadores usan un puntero de pila.  Este puede ser un registro regular, por convenci√≥n utilizado como un puntero de pila, o un registro especial con funciones para ciertas instrucciones. <br><br>  En los procesadores de la serie 68K, el puntero de la pila solo se determina por convenci√≥n; de lo contrario, es un registro regular.  En nuestro procesador 8080, el registro SP es un registro especial.  Tiene comandos PUSH y POP que escriben y salen de la pila en un solo comando. <br><br>  En nuestro proyecto de emulador, no escribiremos c√≥digo desde cero.  Pero si necesita analizar programas en lenguaje ensamblador, entonces es bueno aprender a reconocer tales construcciones. <br><br><h4>  Idiomas de alto nivel </h4><br>  Al escribir un programa en un lenguaje de alto nivel, todas las operaciones de guardar y restaurar registros se realizan con cada llamada de funci√≥n.  No pensamos en ellos, porque el compilador los trata.  Las llamadas a funciones en un lenguaje de alto nivel pueden ocupar mucha memoria y tiempo de procesador. <br><br>  ¬øAlguna vez ha experimentado un bloqueo de un programa al llamar a una subrutina en un bucle infinito?  Esto puede suceder porque cada llamada a la funci√≥n introdujo valores de registro en la pila, y en alg√∫n momento la memoria se agot√≥.  (Si la pila crece demasiado, esto se llama desbordamiento de pila o desbordamiento de pila). <br><br>  Es posible que haya o√≠do hablar de las funciones en l√≠nea.  Evitan guardar y restaurar registros al incluir el c√≥digo de rutina en la funci√≥n de llamada.  El c√≥digo se hace m√°s grande, pero gracias a esto, se guardan varios comandos y operaciones de lectura / escritura en la memoria. <br><br><h4>  Convenciones de llamadas </h4><br>  Al escribir un programa ensamblador que solo llame a su c√≥digo, puede decidir por s√≠ mismo c√≥mo se comunicar√°n las rutinas entre s√≠.  Por ejemplo, ¬øc√≥mo vuelvo a la funci√≥n de llamada una vez que se completa la rutina?  Una forma es escribir la direcci√≥n del remitente en un registro espec√≠fico.  El otro es colocar la direcci√≥n de retorno en la parte superior de la pila.  Muy a menudo, la decisi√≥n depende de lo que admita el procesador.  El 8080 tiene un comando CALL que empuja la direcci√≥n de retorno de una funci√≥n a la pila.  Quiz√°s utilizar√° este comando 8080 para implementar llamadas de subrutina. <br><br>  Se debe tomar una decisi√≥n m√°s.  ¬øLa preservaci√≥n del registro es responsabilidad de la funci√≥n o subrutina que llama?  En el ejemplo anterior, la funci√≥n de llamada almacena los registros.  Pero, ¬øy si tenemos 32 registros?  Guardar y restaurar 32 registros cuando una rutina usa solo una peque√±a fracci√≥n de ellos ser√° una p√©rdida de tiempo. <br><br>  La compensaci√≥n puede ser un enfoque mixto.  Supongamos que elegimos una pol√≠tica en la que una rutina puede usar los registros r10-r32 sin guardar su contenido, pero no puede destruir r1-r9.  En una situaci√≥n similar, la funci√≥n de llamada sabe lo siguiente: <br><br><ul><li>  Al regresar de una funci√≥n, el contenido de r1-r9 permanecer√° sin cambios. </li><li>  No puedo depender del contenido de r10-r32 </li><li>  Si necesito un valor en r10-r32 despu√©s de llamar a una subrutina, entonces antes de llamarlo necesito guardarlo en alg√∫n lugar </li></ul><br>  Del mismo modo, cada rutina sabe lo siguiente: <br><br><ul><li>  Puedo destruir r10-r32 </li><li>  Si quiero usar r1-r9, entonces necesito guardar el contenido y restaurarlo antes de volver a la funci√≥n que me llam√≥ </li></ul><br><h4>  Abi </h4><br>  En la mayor√≠a de las plataformas modernas, dichas pol√≠ticas son creadas por ingenieros y publicadas en documentos llamados ABI (Application Binary Interface).  Gracias a este documento, los creadores del compilador saben c√≥mo compilar c√≥digo que puede llamar al c√≥digo compilado por otros compiladores.  Si desea escribir c√≥digo de ensamblador que pueda funcionar en dicho entorno, entonces necesita conocer ABI y escribir c√≥digo de acuerdo con √©l. <br><br>  Conocer ABI tambi√©n ayuda a depurar c√≥digo cuando no tiene acceso a la fuente.  El ABI define la ubicaci√≥n de los par√°metros para las funciones, por lo que al considerar cualquier subprograma, puede examinar estas direcciones para comprender qu√© se pasa a las funciones. <br><br><h4>  De vuelta al emulador </h4><br>  La mayor√≠a del c√≥digo de ensamblaje escrito a mano, especialmente para los procesadores y juegos arcade m√°s antiguos, no sigue ABI.  Los programas est√°n ensamblados y pueden no tener muchas rutinas.  Cada rutina guarda y restaura registros solo en caso de emergencia. <br><br>  Si desea comprender lo que hace el programa, ser√≠a bueno comenzar marcando las direcciones que est√°n destinadas a los comandos CALL. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418635/">https://habr.com/ru/post/es418635/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418625/index.html">Llamada secreta a Andy Grove que ayud√≥ a Apple a comprar el NeXT</a></li>
<li><a href="../es418627/index.html">M√°s informaci√≥n sobre m√©todos para resolver sistemas de ecuaciones algebraicas lineales</a></li>
<li><a href="../es418629/index.html">C√≥mo verificar independientemente si puede patentar su producto y realizar una b√∫squeda de patente</a></li>
<li><a href="../es418631/index.html">7 pautas de c√≥digo javascript</a></li>
<li><a href="../es418633/index.html">Reactividad de JavaScript: un ejemplo simple e intuitivo</a></li>
<li><a href="../es418637/index.html">Kubernetes a las masas: Slurm comienza el 3 de agosto</a></li>
<li><a href="../es418639/index.html">Akka Streams para simples mortales</a></li>
<li><a href="../es418641/index.html">Un error que impide que un dise√±ador crezca</a></li>
<li><a href="../es418643/index.html">Sentarse frente a pie: ¬øc√≥mo trabajar mejor?</a></li>
<li><a href="../es418645/index.html">Art√≠culos de la conferencia de primavera C ++ Rusia 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>