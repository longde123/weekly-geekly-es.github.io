<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游뱋 游댠 游뱡游낖 Creaci칩n de una m치quina arcade emulador. Parte 1 游놎游낖 游꼓 游븼游낕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Escribir un emulador de m치quinas recreativas es un gran proyecto educativo, y en este tutorial analizaremos muy detalladamente todo el proceso de desa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creaci칩n de una m치quina arcade emulador. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418635/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="imagen"></div><br>  Escribir un emulador de m치quinas recreativas es un gran proyecto educativo, y en este tutorial analizaremos muy detalladamente todo el proceso de desarrollo.  Realmente quieres poner tus manos en el procesador?  Entonces crear un emulador es la mejor manera de aprenderlo. <br><br>  Necesitar치 conocimiento de C, as칤 como conocimiento de ensamblador.  Si no conoce el lenguaje ensamblador, escribir un emulador es la mejor manera de aprenderlo.  Tambi칠n necesitar치 dominar las matem치ticas hexadecimales (tambi칠n conocido como base 16 o simplemente "hexadecimal").  Hablar칠 sobre este tema. <br><br>  Decid칤 elegir un emulador para la m치quina Space Invaders, que usa el procesador 8080. Este juego y este procesador son muy populares, porque en Internet puedes encontrar mucha informaci칩n sobre ellos.  Lo necesitar치 para completar el proyecto. <br><br>  Todo el c칩digo fuente del tutorial se carga en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> .  Si no ha dominado el trabajo con git, en la p치gina de github hay un bot칩n "Descargar ZIP" que le permite descargar el archivo con todo el c칩digo. <br><a name="habracut"></a><br><h1>  Introducci칩n a los n칰meros binarios y hexadecimales. </h1><br>  En matem치ticas "ordinarias", se utiliza el sistema de n칰meros decimales.  Cada d칤gito del n칰mero puede tener un valor de cero a nueve, y cuando superamos el 9, agregamos uno al n칰mero en el siguiente d칤gito y comenzamos nuevamente desde cero.  Todo esto es bastante simple y directo, y probablemente nunca lo pensaste. <br><br>  Es posible que haya sabido o escuchado que las computadoras funcionan con datos binarios.  Los geeks inform치ticos llaman matem치tica decimal base-10 y la llamada binaria base-2.  En notaci칩n binaria, cada d칤gito de un n칰mero puede tener solo dos valores, cero o uno.  En el c칩digo binario, el recuento es el siguiente: 0, 1, 10, 11, 100, 101, 110, 111, 1000. Estos no son n칰meros decimales, por lo que no puede llamarlos "cero, uno, diez, once, cien, ciento uno".  Se pronuncian como "cero, uno, uno-cero, uno-uno, uno-cero-cero", etc.  Raramente leo n칰meros binarios en voz alta, pero si es necesario, debe indicar claramente el sistema de n칰meros utilizado.  Diez, once y cien no tienen significado en notaci칩n binaria. <br><br>  En notaci칩n decimal, un n칰mero tiene los siguientes d칤gitos: unidades, decenas, cientos, miles, decenas de miles, etc.  En el sistema binario, los siguientes d칤gitos: unidades, deuces, fours, ochos, etc.  <strong>En inform치tica, el valor de cada bit binario se llama bit.</strong>  <strong>8 bits forman un byte.</strong> <br><br>  En t칠rminos binarios, una cadena de n칰meros r치pidamente se vuelve muy larga.  Para representar el n칰mero decimal 20,000 en t칠rminos binarios, se requieren 16 d칤gitos: 0b100111000100000.  Para solucionar este problema, es conveniente usar un sistema de n칰meros hexadecimales, tambi칠n conocido como base-16 (o hexadecimal).  En base-16, cada d칤gito contiene 16 valores.  Para valores de cero a nueve, se usan los mismos caracteres que en la base 10, pero para los 6 valores restantes, las sustituciones se usan en forma de las primeras 6 letras del alfabeto, de A a F. <br><br>  La cuenta en el sistema hexadecimal se realiza de la siguiente manera: 0 1 2 3 4 5 6 7 8 9 ABCDEF 10 11 12, etc.  En hexadecimal, decenas, cientos, etc. no tienen el mismo significado que en decimal, por lo que las personas pronuncian los n칰meros por separado.  Por ejemplo, $ A57 se pronuncia en voz alta como "A-cinco-siete".  Para mayor claridad, tambi칠n puede agregar hex치gono, por ejemplo, "A-cinco-siete-hex".  En el sistema de n칰meros hexadecimales, el equivalente del n칰mero decimal 20,000 es $ 4E20, una forma mucho m치s compacta en comparaci칩n con los 16 bits del sistema binario. <br><br>  Creo que el sistema hexadecimal fue elegido debido a una conversi칩n muy natural de binario a hexadecimal y viceversa.  Cada d칤gito hexadecimal corresponde a 4 bits (4 bits) de un n칰mero binario similar.  <strong>2 d칤gitos hexadecimales forman un byte (8 bits).</strong>  Un solo d칤gito hexadecimal puede llamarse nibble, y algunas personas incluso lo escriben a trav칠s de y como "nybble". <br><br><table><tbody><tr><th colspan="4">  Cada d칤gito hexadecimal tiene 4 d칤gitos binarios. </th></tr><tr><td>  Maleficio </td><td>  Un </td><td>  5 5 </td><td>  7 7 </td></tr><tr><td>  Binario </td><td>  1010 </td><td>  0101 </td><td>  0111 </td></tr></tbody></table><br>  Al escribir el c칩digo C, se cree que el n칰mero es decimal (base-10), a menos que se marque lo contrario.  Para decirle al compilador de C que el n칰mero es binario, agregamos el n칰mero cero y la letra b en min칰scula, de esta manera: <code>0b1101101</code> .  El n칰mero hexadecimal se puede escribir en c칩digo C agregando al principio de cero yx en min칰sculas: <code>0xA57</code> .  Algunos lenguajes de ensamblaje usan el signo de d칩lar $: <code>$A57</code> para indicar un n칰mero hexadecimal. <br><br>  Si lo piensa, la conexi칩n entre n칰meros binarios, hexadecimales y decimales es bastante obvia, pero para el primer ingeniero, que hab칤a pensado en esto antes de la invenci칩n de la computadora, esto deber칤a haberse convertido en un momento de comprensi칩n. <br><br>  Entendido todo esto?  Genial <br><br><h1>  Una breve introducci칩n al procesador. </h1><br>  <em>Si ya lo sabe, puede saltarse la secci칩n de forma segura.</em> <br><br>  Una unidad central de procesamiento (CPU) es una m치quina dise침ada para ejecutar programas.  Los bloques fundamentales de la CPU son registros e instrucciones.  Como desarrollador de software, puede tratar estos registros como variables.  En nuestro procesador 8080, entre otros registros, hay registros de 8 bits llamados A, B, C, D y E. Estos registros se pueden interpretar como el siguiente c칩digo C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A, B, C, D, E;</code> </pre> <br>  Todos los procesadores tambi칠n tienen un contador de programas (Contador de programas, PC).  Puedes tomarlo como un puntero. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pc;</code> </pre> <br>  Para una CPU, un programa es una secuencia de n칰meros hexadecimales.  Cada instrucci칩n de lenguaje ensamblador en 8080 corresponde a 1-3 bytes en el programa.  Para saber qu칠 comando corresponde a qu칠 n칰mero, es 칰til el manual del procesador (o cualquier otra informaci칩n sobre el procesador 8080 de Internet). <br><br>  Los nombres de los comandos (instrucciones) a menudo son mnemot칠cnicos de las operaciones realizadas por estos comandos.  El mnem칩nico para cargar en 8080 es MOV (mover), y ADD se usa para realizar la adici칩n. <br><br><h4>  Ejemplos </h4><br>  El valor de memoria actual indicado por el contador de instrucciones es 0x79.  Esto cumple con la instrucci칩n <code>MOV A,C</code> procesador 8080. Este c칩digo de ensamblaje en c칩digo C se parece a <code>A=C;</code>  . <br><br>  Si, en cambio, el valor en la PC ser칤a 0x80, entonces el procesador ejecutar칤a <code>ADD B</code>  En C, esto corresponde a la cadena <code>A = A + B;</code>  . <br><br>  Puede encontrar una lista completa de las instrucciones del procesador 8080 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> .  Para implementar nuestro emulador, utilizaremos esta informaci칩n. <br><br><h4>  Tiempos </h4><br>  En la CPU, la ejecuci칩n de cada instrucci칩n requiere una cierta cantidad de tiempo (sincronizaci칩n), medida en ciclos.  En los procesadores modernos, esta informaci칩n puede ser dif칤cil de obtener, porque los tiempos dependen de muchos aspectos diferentes.  Pero en procesadores m치s antiguos como el 8080, los tiempos son constantes y el fabricante del procesador suele proporcionar esta informaci칩n.  Por ejemplo, una instrucci칩n de transferencia de registro a registro MOV toma 1 ciclo. <br><br>  La informaci칩n de tiempo es 칰til para escribir c칩digo eficiente en el procesador.  Un programador puede tratar de evitar las instrucciones que tardan muchos ciclos en completarse. <br><br>  M치s importante para nosotros es que usaremos informaci칩n de tiempo para emular el procesador.  Para que el juego funcione de la misma manera que en el original, las instrucciones deben ejecutarse a la velocidad correcta.  Algunos emuladores ponen mucho esfuerzo en esto, pero cuando lleguemos a esto, tendremos que decidir qu칠 precisi칩n queremos obtener. <br><br><h1>  Operaciones l칩gicas </h1><br>  Antes de cerrar el tema de los n칰meros binarios y hexadecimales, deber칤amos hablar sobre operaciones l칩gicas.  Probablemente ya est칠 acostumbrado a usar la l칩gica en su c칩digo, por ejemplo, en construcciones como <code>if ((conditionA) and (conditionB))</code> .  En los programas que funcionan directamente con hardware, a menudo tiene que manipular bits individuales de n칰meros. <br><br><h3>  Y operaci칩n </h3><br>  Aqu칤 est치n todos los resultados posibles de la operaci칩n AND (AND) (tabla de verdad) entre dos n칰meros de un solo bit. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Resultado </td></tr><tr><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  0 0 </td><td>  1 </td><td>  0 0 </td></tr><tr><td>  1 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br>  El resultado de AND es igual a la unidad solo cuando ambos valores son iguales a la unidad.  Cuando combinamos dos n칰meros con la operaci칩n AND, AND para cada bit de un n칰mero es AND con el bit correspondiente del otro n칰mero.  El resultado se almacena en este bit del n칰mero de destino.  Probablemente sea mejor solo mirar un ejemplo: <br><br><table><tbody><tr><td></td><td colspan="8">  binario </td><td>  maleficio </td></tr><tr><td>  fuente x </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  $ 6B </td></tr><tr><td>  fuente y </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  $ D2 </td></tr><tr><td>  x e y </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  $ 42 </td></tr></tbody></table><br>  En C, la operaci칩n AND l칩gica es un simple signo "&amp;". <br><br><h3>  Operaci칩n OR (OR) </h3><br>  La operaci칩n OR funciona de manera similar.  La 칰nica diferencia es que el resultado ser치 igual a uno si al menos uno de los valores de x o y es igual a uno. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Resultado </td></tr><tr><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  0 0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br><table><tbody><tr><td></td><td colspan="8">  binario </td><td>  maleficio </td></tr><tr><td>  fuente x </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  $ 6B </td></tr><tr><td>  fuente y </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  0 0 </td><td>  1 </td><td>  0 0 </td><td>  $ D2 </td></tr><tr><td>  x O y </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0 0 </td><td>  1 </td><td>  1 </td><td>  $ Fb </td></tr></tbody></table><br>  En C, una operaci칩n OR l칩gica se indica mediante una barra vertical "|". <br><br><h3>  쯇or qu칠 es esto importante? </h3><br>  En muchos procesadores m치s antiguos, y especialmente en m치quinas recreativas, el juego a menudo requiere trabajar con solo una parte del n칰mero.  A menudo hay un c칩digo similar: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*  1:     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buttons_ptr = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0x2043</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buttons = *buttons_ptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buttons &amp; <span class="hljs-number"><span class="hljs-number">0x4</span></span>) HandleLeftButton(); <span class="hljs-comment"><span class="hljs-comment">/*  2:  LED-    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * LED_pointer = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) <span class="hljs-number"><span class="hljs-number">0x2089</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> led = *LED_pointer; led = led | <span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,  LED   6 *LED_pointer = led; /*  3:   LED- */ char * LED_pointer = (char *) 0x2089; char led = *LED_pointer; led = led &amp; 0xBF; //  6 *LED_pointer = led;</span></span></code> </pre> <br>  En el ejemplo 1, la direcci칩n $ 2043 asignada en la memoria es la direcci칩n de los botones en el panel de control.  Este c칩digo lee y responde al bot칩n presionado.  (춰Por supuesto, en Space Invaders este c칩digo estar치 en lenguaje ensamblador!) <br><br>  En el ejemplo 2, el juego quiere encender un indicador LED, que se encuentra en el bit 6 de la direcci칩n de $ 2089 asignada en la memoria.  El c칩digo debe leer el valor existente, cambiar solo un bit y volver a escribirlo. <br><br>  En el ejemplo 3, debe apagar el indicador del ejemplo 2, por lo que el c칩digo debe restablecer el bit 6 de la direcci칩n $ 2089.  Esto se puede hacer realizando la operaci칩n AND para el byte de control del indicador con un valor para el que solo el bit 6 es cero. Por lo tanto, afectaremos solo 6, dejando los bits restantes sin cambios. <br><br>  Esto generalmente se llama una "m치scara".  En C, una m치scara generalmente se escribe usando el operador NOT, denotado por una tilde ("~").  Por lo tanto, en lugar de escribir <code>0xBF</code> , simplemente escribo <code>~0x40</code> y obtengo el mismo n칰mero, pero sin poner mucho esfuerzo. <br><br><h1>  Introducci칩n al lenguaje ensamblador </h1><br>  Si lee este tutorial, probablemente est칠 familiarizado con la programaci칩n de computadoras, por ejemplo, en Java o Python.  Estos lenguajes le permiten hacer mucho trabajo en solo unas pocas l칤neas de c칩digo.  El c칩digo se considera h치bilmente escrito si hace el mayor trabajo posible en la menor cantidad de l칤neas posible, posiblemente incluso utilizando la funcionalidad de las bibliotecas integradas.  Tales lenguajes se llaman "lenguajes de alto nivel". <br><br>  En lenguaje ensamblador, por el contrario, no hay funciones integradas para salvar vidas, y se pueden requerir muchas l칤neas de c칩digo simples para completar tareas simples.  El lenguaje ensamblador se considera un lenguaje de bajo nivel.  En 칠l, debe acostumbrarse a pensar al estilo de "쯤u칠 secuencia espec칤fica de pasos se deben tomar para completar esta tarea?" <br><br>  Lo m치s importante que necesita saber sobre el lenguaje ensamblador es que cada l칤nea se traduce en un comando de procesador. <br><br>  Considere tal construcci칩n del lenguaje C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = b + <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  En lenguaje ensamblador, esta tarea deber치 realizarse en la siguiente secuencia: <br><br><ol><li>  Cargue la direcci칩n de la variable B en el registro 1 </li><li>  Cargue el contenido de esta direcci칩n de memoria en el registro 2 </li><li>  Agregue valor directo 0x64 para registrar 2 </li><li>  Cargue la direcci칩n de la variable A en el registro 1 </li><li>  Escriba el contenido del registro 2 en la direcci칩n almacenada en el registro 1 </li></ol><br>  En c칩digo, se ver치 m치s o menos as칤: <br><br><pre> <code class="hljs pgsql"> lea a1, #<span class="hljs-meta"><span class="hljs-meta">$1000</span></span> ;   a lea a2, #<span class="hljs-meta"><span class="hljs-meta">$1008</span></span> ;   b <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>.l d0,(a2) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>.l d0, #<span class="hljs-meta"><span class="hljs-meta">$64</span></span> mov (a1),d0</code> </pre> <br>  Vale la pena se침alar lo siguiente: <br><br><ul><li>  En un lenguaje de alto nivel, el compilador decide d칩nde colocar las variables en la memoria.  Al escribir c칩digo en ensamblador, usted mismo es responsable de cada direcci칩n de memoria que utilizar치. </li><li>  En la mayor칤a de los lenguajes ensambladores, los corchetes significan "memoria en esta direcci칩n". </li><li>  En la mayor칤a de los lenguajes ensambladores, # denota un n칰mero algebraico, tambi칠n llamado valor inmediato.  Por ejemplo, en la l칤nea 1 del ejemplo anterior, el c칩digo realmente escribe el valor # 0x1000 para registrar a1.  Si el c칩digo se parece a <code>move.l a1, ($1000)</code> , entonces a1 recibir칤a el contenido de la memoria en la direcci칩n 0x1000. </li><li>  Cada procesador tiene su propio lenguaje ensamblador, y la transferencia de c칩digo de un procesador a otro puede ser dif칤cil. </li><li>  Este no es un lenguaje ensamblador de procesador real, se me ocurri칩 como ejemplo. </li></ul><br>  Sin embargo, hay una cosa en com칰n entre los programadores inteligentes de alto nivel y los asistentes de ensamblador.  Los programadores de ensambladores consideran un honor completar la tarea de la manera m치s eficiente posible y minimizar la cantidad de instrucciones utilizadas.  El c칩digo para las m치quinas recreativas generalmente est치 altamente optimizado y todos los jugos se exprimen de cada byte y ciclo extra. <br><br><h1>  Pilas </h1><br>  Hablemos un poco m치s sobre el lenguaje ensamblador.  En cualquier programa de computadora bastante complejo en el ensamblador se utilizan subrutinas.  La mayor칤a de las CPU tienen una estructura llamada pila. <br><br>  Imagina una pila en forma de pila.  Si necesitamos guardar un n칰mero, lo colocamos en la parte superior de la pila.  Cuando necesitamos traerlo de vuelta, lo tomamos de la parte superior de la pila.  Los programadores de ensambladores llaman "empujar" al n칰mero emergente en la pila, y al llamarlo emergente se llama "pop". <br><br>  Digamos que mi programa necesita llamar a una subrutina.  Puedo escribir un c칩digo similar: <br><br><pre> <code class="hljs css"> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1004</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;     0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1008</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1010</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;  .. 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1014</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1018</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x101C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1020</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1024</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-id"><span class="hljs-selector-id">#0x1030</span></span> ;   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1028</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x102C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#0x2040</span></span> ;   <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x2040</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1030</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1034</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1038</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x103c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span>  ..</code> </pre> <br>  El c칩digo que se muestra arriba empuja los valores d0, d1, a0 y a1 a la pila.  La mayor칤a de los procesadores usan un puntero de pila.  Este puede ser un registro regular, por convenci칩n utilizado como un puntero de pila, o un registro especial con funciones para ciertas instrucciones. <br><br>  En los procesadores de la serie 68K, el puntero de la pila solo se determina por convenci칩n; de lo contrario, es un registro regular.  En nuestro procesador 8080, el registro SP es un registro especial.  Tiene comandos PUSH y POP que escriben y salen de la pila en un solo comando. <br><br>  En nuestro proyecto de emulador, no escribiremos c칩digo desde cero.  Pero si necesita analizar programas en lenguaje ensamblador, entonces es bueno aprender a reconocer tales construcciones. <br><br><h4>  Idiomas de alto nivel </h4><br>  Al escribir un programa en un lenguaje de alto nivel, todas las operaciones de guardar y restaurar registros se realizan con cada llamada de funci칩n.  No pensamos en ellos, porque el compilador los trata.  Las llamadas a funciones en un lenguaje de alto nivel pueden ocupar mucha memoria y tiempo de procesador. <br><br>  쮸lguna vez ha experimentado un bloqueo de un programa al llamar a una subrutina en un bucle infinito?  Esto puede suceder porque cada llamada a la funci칩n introdujo valores de registro en la pila, y en alg칰n momento la memoria se agot칩.  (Si la pila crece demasiado, esto se llama desbordamiento de pila o desbordamiento de pila). <br><br>  Es posible que haya o칤do hablar de las funciones en l칤nea.  Evitan guardar y restaurar registros al incluir el c칩digo de rutina en la funci칩n de llamada.  El c칩digo se hace m치s grande, pero gracias a esto, se guardan varios comandos y operaciones de lectura / escritura en la memoria. <br><br><h4>  Convenciones de llamadas </h4><br>  Al escribir un programa ensamblador que solo llame a su c칩digo, puede decidir por s칤 mismo c칩mo se comunicar치n las rutinas entre s칤.  Por ejemplo, 쯖칩mo vuelvo a la funci칩n de llamada una vez que se completa la rutina?  Una forma es escribir la direcci칩n del remitente en un registro espec칤fico.  El otro es colocar la direcci칩n de retorno en la parte superior de la pila.  Muy a menudo, la decisi칩n depende de lo que admita el procesador.  El 8080 tiene un comando CALL que empuja la direcci칩n de retorno de una funci칩n a la pila.  Quiz치s utilizar치 este comando 8080 para implementar llamadas de subrutina. <br><br>  Se debe tomar una decisi칩n m치s.  쯃a preservaci칩n del registro es responsabilidad de la funci칩n o subrutina que llama?  En el ejemplo anterior, la funci칩n de llamada almacena los registros.  Pero, 쯫 si tenemos 32 registros?  Guardar y restaurar 32 registros cuando una rutina usa solo una peque침a fracci칩n de ellos ser치 una p칠rdida de tiempo. <br><br>  La compensaci칩n puede ser un enfoque mixto.  Supongamos que elegimos una pol칤tica en la que una rutina puede usar los registros r10-r32 sin guardar su contenido, pero no puede destruir r1-r9.  En una situaci칩n similar, la funci칩n de llamada sabe lo siguiente: <br><br><ul><li>  Al regresar de una funci칩n, el contenido de r1-r9 permanecer치 sin cambios. </li><li>  No puedo depender del contenido de r10-r32 </li><li>  Si necesito un valor en r10-r32 despu칠s de llamar a una subrutina, entonces antes de llamarlo necesito guardarlo en alg칰n lugar </li></ul><br>  Del mismo modo, cada rutina sabe lo siguiente: <br><br><ul><li>  Puedo destruir r10-r32 </li><li>  Si quiero usar r1-r9, entonces necesito guardar el contenido y restaurarlo antes de volver a la funci칩n que me llam칩 </li></ul><br><h4>  Abi </h4><br>  En la mayor칤a de las plataformas modernas, dichas pol칤ticas son creadas por ingenieros y publicadas en documentos llamados ABI (Application Binary Interface).  Gracias a este documento, los creadores del compilador saben c칩mo compilar c칩digo que puede llamar al c칩digo compilado por otros compiladores.  Si desea escribir c칩digo de ensamblador que pueda funcionar en dicho entorno, entonces necesita conocer ABI y escribir c칩digo de acuerdo con 칠l. <br><br>  Conocer ABI tambi칠n ayuda a depurar c칩digo cuando no tiene acceso a la fuente.  El ABI define la ubicaci칩n de los par치metros para las funciones, por lo que al considerar cualquier subprograma, puede examinar estas direcciones para comprender qu칠 se pasa a las funciones. <br><br><h4>  De vuelta al emulador </h4><br>  La mayor칤a del c칩digo de ensamblaje escrito a mano, especialmente para los procesadores y juegos arcade m치s antiguos, no sigue ABI.  Los programas est치n ensamblados y pueden no tener muchas rutinas.  Cada rutina guarda y restaura registros solo en caso de emergencia. <br><br>  Si desea comprender lo que hace el programa, ser칤a bueno comenzar marcando las direcciones que est치n destinadas a los comandos CALL. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418635/">https://habr.com/ru/post/es418635/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418625/index.html">Llamada secreta a Andy Grove que ayud칩 a Apple a comprar el NeXT</a></li>
<li><a href="../es418627/index.html">M치s informaci칩n sobre m칠todos para resolver sistemas de ecuaciones algebraicas lineales</a></li>
<li><a href="../es418629/index.html">C칩mo verificar independientemente si puede patentar su producto y realizar una b칰squeda de patente</a></li>
<li><a href="../es418631/index.html">7 pautas de c칩digo javascript</a></li>
<li><a href="../es418633/index.html">Reactividad de JavaScript: un ejemplo simple e intuitivo</a></li>
<li><a href="../es418637/index.html">Kubernetes a las masas: Slurm comienza el 3 de agosto</a></li>
<li><a href="../es418639/index.html">Akka Streams para simples mortales</a></li>
<li><a href="../es418641/index.html">Un error que impide que un dise침ador crezca</a></li>
<li><a href="../es418643/index.html">Sentarse frente a pie: 쯖칩mo trabajar mejor?</a></li>
<li><a href="../es418645/index.html">Art칤culos de la conferencia de primavera C ++ Rusia 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>