<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÑ ü§öüèø üõ£Ô∏è Comment se prot√©ger contre le d√©bordement de pile (sur Cortex M)? üíì üé™ ü§∂üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si vous programmez sur un "gros" ordinateur, alors vous n'avez probablement pas une telle question. Il y a beaucoup de pile pour le d√©border, vous dev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment se prot√©ger contre le d√©bordement de pile (sur Cortex M)?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425071/">  Si vous programmez sur un "gros" ordinateur, alors vous n'avez probablement pas une telle question.  Il y a beaucoup de pile pour le d√©border, vous devez essayer.  Dans le pire des cas, vous cliquez sur OK dans une fen√™tre comme celle-ci et allez le d√©couvrir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/c2c/358/b12c2c358fa3a040589578b71521957b.png" alt="image"></div><br>  Mais si vous programmez des microcontr√¥leurs, le probl√®me semble un peu diff√©rent.  Vous devez d'abord <i>remarquer</i> que la pile est pleine. <br><br>  Dans cet article, je parlerai de mes propres recherches sur ce sujet.  Depuis que je programme principalement sous STM32 et sous Milander 1986 - je me suis concentr√© sur eux. <br><a name="habracut"></a><br><h2>  Pr√©sentation </h2><br>  Imaginons le cas le plus simple - nous √©crivons du code simple √† un seul thread sans aucun syst√®me d'exploitation, c'est-√†-dire  nous n'avons qu'une seule pile.  Et si vous, comme moi, programmez dans uVision Keil, alors la m√©moire est distribu√©e en quelque sorte comme ceci: <br><br><img src="https://habrastorage.org/webt/er/tb/to/ertbtohh-xf2meqxvzekrxlmwoe.png"><br><br>  Et si vous, comme moi, consid√©rez la m√©moire dynamique sur les microcontr√¥leurs comme mauvaise, alors comme ceci: <br><br><img src="https://habrastorage.org/webt/op/bu/el/opbuelnjpcvre-9jjpm_qnrlqcw.png"><br><br><div class="spoiler">  <b class="spoiler_title">Au fait</b> <div class="spoiler_text">  Si vous souhaitez interdire l'utilisation du tas, vous pouvez le faire comme ceci: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> import(__use_no_heap_region)</span></span></code> </pre> <br>  D√©tails <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> <br></div></div><br>  OK, quel est le probl√®me?  Le probl√®me est que Keil place la pile <b>imm√©diatement</b> derri√®re la zone de donn√©es statiques.  Et la pile dans Cortex-M cro√Æt dans le sens de la diminution des adresses.  Et quand il d√©borde, il sort simplement de la m√©moire allou√©e.  Et remplace toutes les variables statiques ou globales. <br><br>  Particuli√®rement bien si la pile ne d√©borde qu'en entrant dans l'interruption.  Ou, mieux encore, dans une interruption imbriqu√©e!  Et g√¢te discr√®tement une variable utilis√©e dans une section de code compl√®tement diff√©rente.  Et le programme se bloque √† l'assertion.  Si vous avez de la chance.  Heisenbag sph√©rique, on peut chercher une telle semaine enti√®re avec une lampe de poche. <br><br>  Faites imm√©diatement une r√©servation: si vous utilisez un tas, le probl√®me ne va nulle part, juste au lieu des variables globales, le tas se g√¢te.  Pas beaucoup mieux. <br><br>  D'accord, le probl√®me est clair.  Que faire <br><br><h2>  MPU </h2><br>  Le plus simple et le plus √©vident consiste √† utiliser MPU (en d'autres termes, Memory Protection Unit).  Vous permet d'attribuer diff√©rents attributs √† diff√©rents morceaux de m√©moire;  en particulier, vous pouvez entourer la pile de r√©gions en lecture seule et intercepter MemFault lorsque vous y √©crivez. <br><br>  Par exemple, dans stm32f407 MPU est.  Malheureusement, dans beaucoup d'autres stm "juniors", ce n'est pas le cas.  Et dans le Milandrovsky 1986VE1, il n'est pas l√† non plus. <br><br>  C'est-√†-dire  La solution est bonne, mais pas toujours abordable. <br><br><h2>  Commande manuelle </h2><br>  Lors de la compilation, Keil peut g√©n√©rer (et le fait par d√©faut) un rapport html avec un graphique d'appel (option de l'√©diteur de liens "--info = stack").  Et ce rapport donne √©galement des informations sur la pile utilis√©e.  Gcc peut aussi le faire (option -fstack-usage).  En cons√©quence, vous pouvez parfois consulter ce rapport (ou √©crire un script qui le fait pour vous et l'appeler avant chaque g√©n√©ration). <br><br>  De plus, au tout d√©but du rapport, un chemin est √©crit qui conduit √† l'utilisation maximale de la pile: <br><br><img src="https://habrastorage.org/webt/eb/mh/ao/ebmhaouyrjjvnmziubxybt3zyg0.png"><br><br>  Le probl√®me est que si votre code a des appels de fonction par des pointeurs ou des m√©thodes virtuelles (et je les ai), ce rapport peut grandement sous-estimer la profondeur maximale de la pile.  Eh bien, les interruptions, bien s√ªr, ne sont pas prises en compte.  Pas un moyen tr√®s fiable. <br><br><h2>  Placement de pile d√©licat </h2><br>  J'ai d√©couvert cette m√©thode dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> .  L'article porte sur la rouille, mais l'id√©e principale est la suivante: <br><br><img src="https://habrastorage.org/webt/i3/pz/yb/i3pzyb-ewbtxaei_oaz5mrhthda.png"><br><br>  Lorsque vous utilisez gcc, cela peut √™tre fait en utilisant le " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">double lien</a> ". <br><br>  Et dans Keil, l'emplacement des zones peut √™tre modifi√© en utilisant votre propre script pour l'√©diteur de liens (fichier scatter dans la terminologie de Keil).  Pour ce faire, ouvrez les options du projet et d√©cochez ¬´Utiliser la disposition de la m√©moire √† partir de la bo√Æte de dialogue cible¬ª.  Ensuite, le fichier par d√©faut appara√Ætra dans le champ ¬´Fichier Scatter¬ª.  Cela ressemble √† ceci: <br><br><pre> <code class="cpp hljs">; ************************************************************* ; *** Scatter-Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 <span class="hljs-number"><span class="hljs-number">0x08000000</span></span> <span class="hljs-number"><span class="hljs-number">0x00020000</span></span> { ; load region size_region ER_IROM1 <span class="hljs-number"><span class="hljs-number">0x08000000</span></span> <span class="hljs-number"><span class="hljs-number">0x00020000</span></span> { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } RW_IRAM1 <span class="hljs-number"><span class="hljs-number">0x20000000</span></span> <span class="hljs-number"><span class="hljs-number">0x00005000</span></span> { ; RW data .ANY (+RW +ZI) } }</code> </pre> <br>  Que faire ensuite?  Options possibles.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La documentation officielle</a> sugg√®re de d√©finir des sections avec des noms r√©serv√©s - ARM_LIB_HEAP et ARM_LIB_STACK.  Mais cela entra√Æne des cons√©quences d√©sagr√©ables, du moins pour moi - la taille de la pile et du tas devra √™tre d√©finie dans le fichier scatter. <br><br>  Dans tous les projets que j'utilise, les tailles de pile et de tas sont d√©finies dans le fichier de d√©marrage de l'assembleur (que Keil g√©n√®re lors de la cr√©ation du projet).  Je ne veux pas vraiment le changer.  Je veux juste inclure un nouveau fichier scatter dans le projet, et tout ira bien.  Je suis donc all√© un peu diff√©remment: <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#! armcc -E ; with that we can use C preprocessor <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RAM_BEGIN 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RAM_SIZE_BYTES (4*1024) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_BEGIN 0x8000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLASH_SIZE_BYTES (32*1024) ; This scatter file places stack before .bss region, so on stack overflow ; we get HardFault exception immediately LR_IROM1 FLASH_BEGIN FLASH_SIZE_BYTES { ; load region size_region ER_IROM1 FLASH_BEGIN FLASH_SIZE_BYTES { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } ; Stack region growing down REGION_STACK RAM_BEGIN { *(STACK) } ; We have to </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> heap region, even </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> we don</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'t actually use heap REGION_HEAP ImageLimit(REGION_STACK) { *(HEAP) } ; this will place .bss region above the stack and heap and allocate RAM that is left for it RW_IRAM1 ImageLimit(REGION_HEAP) (RAM_SIZE_BYTES - ImageLength(REGION_STACK) - ImageLength(REGION_HEAP)) { *(+RW +ZI) } }</span></span></span></span></code> </pre> <br></div></div><br>  Ensuite, j'ai dit que tous les objets nomm√©s STACK devraient √™tre situ√©s dans la r√©gion REGION_STACK, et tous les objets HEAP devraient √™tre situ√©s dans la r√©gion REGION_HEAP.  Et tout le reste se trouve dans la r√©gion RW_IRAM1.  Et il a arrang√© les r√©gions dans cet ordre - le d√©but de l'op√©rateur, la pile, le tas, tout le reste.  Le calcul est que dans le fichier de d√©marrage de l'assembleur, la pile et le tas sont d√©finis √† l'aide de ce code (c'est-√†-dire sous forme de tableaux avec les noms STACK et HEAP): <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Stack_Size EQU 0x00000400 AREA STACK, NOINIT, READWRITE, ALIGN=3 Stack_Mem SPACE Stack_Size __initial_sp Heap_Size EQU 0x00000200 AREA HEAP, NOINIT, READWRITE, ALIGN=3 __heap_base Heap_Mem SPACE Heap_Size __heap_limit PRESERVE8 THUMB</code> </pre> <br></div></div><br>  D'accord, vous pourriez demander, mais qu'est-ce que cela nous donne?  Et voici quoi.  D√©sormais, en sortant de la pile, le processeur essaie d'√©crire (ou de lire) de la m√©moire qui n'existe pas.  Et sur STM32, une interruption se produit en raison d'une exception - HardFault. <br><br>  Ce n'est pas aussi pratique que MemFault en raison de la MPU, car HardFault peut se produire pour de nombreuses raisons, mais au moins l'erreur est forte et non silencieuse.  C'est-√†-dire  cela se produit imm√©diatement, et non apr√®s une p√©riode de temps inconnue, comme c'√©tait le cas auparavant. <br><br>  Mieux encore, nous n'avons rien pay√© pour cela, pas de temps d'ex√©cution!  Ouah.  Mais il y a un probl√®me. <br><br>  <i>Cela ne fonctionne pas sur Milander.</i> <br><br>  Oui  Bien s√ªr, sur la Milandra (je suis principalement int√©ress√© par 1986BE1 et BE91), la carte m√©moire est diff√©rente.  Dans STM32, avant le d√©but de l'intervention, il n'y a rien, et sur la Milandra, avant l'intervention, se trouve la zone du bus externe. <br><br>  Mais m√™me si vous n'utilisez pas de bus externe, vous ne recevrez aucun HardFault.  Ou peut-√™tre l'obtenir.  Ou peut-√™tre l'obtenir, mais pas tout de suite.  Je n'ai pu trouver aucune information √† ce sujet (ce qui n'est pas surprenant pour Milander), et les exp√©riences n'ont donn√© aucun r√©sultat intelligible.  HardFault <i>se</i> produisait <i>parfois</i> si la taille de la pile √©tait un multiple de 256. Parfois, HardFault se produisait si la pile allait trop loin dans la m√©moire inexistante. <br><br>  Mais cela n'a m√™me pas d'importance.  Si HardFault ne se produit pas √† chaque fois, le simple fait de d√©placer la pile au d√©but de la RAM ne nous sauve plus.  Et pour √™tre tout √† fait honn√™te, STM n'est pas non plus oblig√© de lever une exception en m√™me temps, la sp√©cification de base Cortex-M ne semble rien dire de concret √† ce sujet. <br><br>  Donc, m√™me sur STM, cela ressemble plus √† un hack, mais pas tr√®s sale. <br><br>  Donc, vous devez chercher une autre fa√ßon. <br><br><h2>  Acc√©der au point d'arr√™t enregistr√© </h2><br>  Si nous d√©pla√ßons la pile au d√©but de la RAM, la valeur limite de la pile sera toujours la m√™me - 0x20000000.  Et nous pouvons simplement mettre un point d'arr√™t sur le dossier dans cette cellule.  Cela peut √™tre fait avec la commande et m√™me enregistr√© en autorun en utilisant le fichier .ini: <br><br><pre> <code class="plaintext hljs">// breakpoint on stackoverflow BS Write 0x20000000, 1</code> </pre> <br>  Mais ce n'est pas un moyen tr√®s fiable.  Ce point d'arr√™t se d√©clenchera √† chaque initialisation de la pile.  Il est facile de le battre accidentellement en cliquant sur "Tuer tous les points d'arr√™t".  Et il ne vous prot√©gera qu'en pr√©sence d'un d√©bogueur.  Pas bon. <br><br><h2>  Protection dynamique contre les d√©bordements </h2><br>  Une recherche rapide sur ce sujet m'a conduit aux options de Keil --protect_stack et --protect_stack_all.  Des options utiles, malheureusement, elles prot√®gent non pas du d√©bordement de la pile enti√®re, mais de l'insertion d'une autre fonction dans le cadre de la pile.  Par exemple, si votre code d√©passe les limites d'un tableau ou √©choue avec un nombre variable de param√®tres.  Gcc, bien s√ªr, peut le faire aussi (-fstack-protector). <br><br>  L'essence de cette option est la suivante: une ¬´variable de garde¬ª est ajout√©e √† chaque cadre de pile, c'est-√†-dire un num√©ro de garde.  Si ce nombre a chang√© apr√®s avoir quitt√© la fonction, la fonction de gestion des erreurs est appel√©e.  D√©tails <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Une chose utile, mais pas tout √† fait ce dont j'ai besoin.  J'ai besoin d'une v√©rification beaucoup plus simple - de sorte que lors de la saisie de chaque fonction, la valeur du registre SP (Stack Pointer) soit v√©rifi√©e par rapport √† une valeur minimale pr√©c√©demment connue.  Mais n'√©crivez pas ce test avec vos mains √† l'entr√©e de chaque fonction? <br><br><h2>  Contr√¥le SP dynamique </h2><br>  Heureusement, gcc a la merveilleuse option "-finstrument-functions", qui vous permet d'appeler une fonction d√©finie par l'utilisateur lorsque vous entrez dans chaque fonction et lorsque vous quittez chaque fonction.  Ceci est g√©n√©ralement utilis√© pour g√©n√©rer des informations de d√©bogage, mais quelle est la diff√©rence? <br><br>  Encore plus heureusement, Keil copie d√©lib√©r√©ment la fonctionnalit√© gcc, et l√† la m√™me option est disponible sous le nom "--gnu_instrument" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©tails</a> ). <br><br>  Apr√®s cela, il vous suffit d'√©crire ce code: <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    //   ,         scatter- extern unsigned int Image$$REGION_STACK$$RW$$Base; //    ,   static const uint32_t stack_lower_address = (uint32_t) &amp;( Image$$REGION_STACK$$RW$$Base ); //         extern "C" __attribute__((no_instrument_function)) void __cyg_profile_func_enter( void * current_func, void * callsite ) { (void)current_func; (void)callsite; ASSERT( __current_sp() &gt;= stack_lower_address ); } //   -   extern "C" __attribute__((no_instrument_function)) void __cyg_profile_func_exit( void * current_func, void * callsite ) { (void)current_func; (void)callsite; }</span></span></code> </pre> <br></div></div><br>  Et le tour est jou√©!  Maintenant, lors de la saisie de chaque fonction (y compris les gestionnaires d'interruption), une v√©rification sera effectu√©e pour le d√©passement de pile.  Et si la pile d√©borde, il y aura une assertion. <br><br><div class="spoiler">  <b class="spoiler_title">Une petite explication:</b> <div class="spoiler_text"><ul><li>  Oui, bien s√ªr, vous devez v√©rifier le d√©bordement avec une certaine marge, sinon il y a un risque de "sauter" par-dessus la pile. </li><li>  Image $$ REGION_STACK $$ RW $$ Base est une magie sp√©ciale pour obtenir des informations sur les zones de m√©moire en utilisant les constantes g√©n√©r√©es par l'√©diteur de liens.  D√©tails (bien que peu intelligibles par endroits) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </li></ul><br></div></div><br>  La solution est-elle parfaite?  Bien s√ªr que non. <br><br>  Premi√®rement, cette v√©rification est loin d'√™tre gratuite, le code en gonfle de 10% .Eh bien, le code fonctionnera plus lentement (m√™me si je ne l'ai pas mesur√©).  Que ce soit critique ou non d√©pend de vous;  √† mon avis, c'est un prix raisonnable pour la s√©curit√©. <br><br>  Deuxi√®mement, cela ne fonctionnera probablement pas lors de l'utilisation de biblioth√®ques pr√©compil√©es (mais comme je ne les utilise pas du tout, je n'ai pas v√©rifi√©). <br><br>  Mais cette solution est potentiellement adapt√©e aux programmes multithreads, puisque nous faisons nous-m√™mes la v√©rification.  Mais je n'ai pas vraiment pens√© √† cette id√©e, donc je vais la retenir pour l'instant. <br><br><h2>  Pour r√©sumer </h2><br>  Il s'est av√©r√© trouver des solutions de travail pour stm32 et pour Milander, bien que pour ce dernier, j'ai d√ª payer des frais g√©n√©raux. <br><br>  Pour moi, la chose la plus importante √©tait un petit changement dans le paradigme de la pens√©e.  Avant l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article susmentionn√©,</a> je ne pensais pas du tout que vous pourriez vous prot√©ger en quelque sorte contre le d√©bordement de la pile.  Je n'ai pas per√ßu cela comme un probl√®me √† r√©soudre, mais plut√¥t comme un certain ph√©nom√®ne naturel - parfois il pleut et parfois la pile d√©borde, eh bien, il n'y a rien √† faire, il faut mordre la balle et tol√©rer. <br><br>  Et je remarque g√©n√©ralement assez souvent pour moi-m√™me (et pour d'autres personnes) ceci - au lieu de passer 5 minutes sur Google et de trouver une solution triviale - je vis avec mes probl√®mes depuis des ann√©es. <br><br>  C‚Äôest tout pour moi.  Je comprends que je n'ai rien d√©couvert de fondamentalement nouveau, mais je n'ai trouv√© aucun article pr√™t √† l'emploi avec une telle d√©cision (au moins, Joseph Yu lui-m√™me ne le propose pas directement dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> sur ce sujet).  J'esp√®re que dans les commentaires, ils me diront si j'ai raison ou non, et quels sont les pi√®ges de cette approche. <br><br>  <b>UPD:</b> Si, lors de l'ajout d'un fichier scatter, Keil commence √† √©mettre un avertissement incompr√©hensible ala "AppData \ Local \ Temp \ p17af8-2 (33): avertissement: # 1-D: la derni√®re ligne de fichier se termine sans nouvelle ligne" - mais ce fichier lui-m√™me n'est pas s'ouvre, car il est temporaire, puis ajoutez simplement le saut de ligne avec le dernier caract√®re du fichier scatter. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425071/">https://habr.com/ru/post/fr425071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425057/index.html">Pr√™t pr√©f√©rentiel pour l'√©ducation pour tous les programmes GeekUniversity de GeekBrains et Alfa Bank</a></li>
<li><a href="../fr425059/index.html">Hackathon n ¬∞ 1 sur Tinkoff.ru</a></li>
<li><a href="../fr425061/index.html">CodeRainbow: apprentissage interactif du code et documentation</a></li>
<li><a href="../fr425063/index.html">Migration d'un sch√©ma de base de donn√©es sans interruption pour postgresql en utilisant django comme exemple</a></li>
<li><a href="../fr425069/index.html">Test d'un pr√©sentateur √† l'aide de PromiseKit</a></li>
<li><a href="../fr425073/index.html">Cr√©ation facile de r√©f√©rentiel git sur OneDrive</a></li>
<li><a href="../fr425075/index.html">Vision industrielle: installation, configuration et utilisation de Google Cloud Vision en PHP</a></li>
<li><a href="../fr425077/index.html">Kotlin sous le capot - voir bytecode d√©compil√©</a></li>
<li><a href="../fr425079/index.html">IPSec difficile avec Linux</a></li>
<li><a href="../fr425081/index.html">L'√âtat ne sait pas combien il d√©pense en informatique. Nous prouvons sur les chiffres</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>