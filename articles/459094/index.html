<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍟 🤱🏻 🙏🏼 C # o Java? ¿TypeScript o JavaScript? Clasificación basada en aprendizaje automático de lenguajes de programación 🛄 😢 🤹🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GitHub aloja más de 300 lenguajes de programación, desde lenguajes de uso común como Python, Java y Javascript hasta lenguajes esotéricos como Befunge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # o Java? ¿TypeScript o JavaScript? Clasificación basada en aprendizaje automático de lenguajes de programación</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/459094/">  GitHub aloja más de 300 lenguajes de programación, desde lenguajes de uso común como Python, Java y Javascript hasta lenguajes esotéricos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Befunge</a> , solo conocidos por comunidades muy pequeñas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3fa/593/e73/3fa593e735a40717b6d099826b3eefc9.png"><br>  <i>Figura 1: Los 10 principales lenguajes de programación alojados por GitHub por recuento de repositorio</i> <br><br>  Uno de los desafíos necesarios que enfrenta GitHub es poder reconocer estos diferentes idiomas.  Cuando se envía un código a un repositorio, es importante reconocer el tipo de código que se agregó para fines de búsqueda, alerta de vulnerabilidad de seguridad y resaltado de sintaxis, y mostrar la distribución de contenido del repositorio a los usuarios. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Linguist</a> es la herramienta que actualmente utilizamos para detectar lenguajes de codificación en GitHub.  Linguist, una aplicación basada en Ruby que utiliza diversas estrategias para la detección del lenguaje, aprovechando las convenciones de nomenclatura y las extensiones de archivo y también teniendo en cuenta las modelos de Vim o Emacs, así como el contenido en la parte superior del archivo (shebang).  Linguist maneja la desambiguación del lenguaje a través de la heurística y, en su defecto, a través de un clasificador Naive Bayes capacitado en una pequeña muestra de datos. <br><br>  Aunque Linguist hace un buen trabajo al hacer predicciones de lenguaje a nivel de archivo (84% de precisión), su rendimiento disminuye significativamente cuando los archivos usan convenciones de nomenclatura inesperadas y, crucialmente, cuando no se proporciona una extensión de archivo.  Esto hace que Linguist no sea adecuado para contenido como GitHub Gists o fragmentos de código dentro de README, problemas y solicitudes de extracción. <br><br>  Con el fin de hacer que la detección del lenguaje sea más robusta y mantenible a largo plazo, desarrollamos un clasificador de aprendizaje automático llamado Octo Lingua basado en una arquitectura de red neuronal artificial (ANN) que puede manejar predicciones del lenguaje en escenarios difíciles.  La versión actual del modelo puede hacer predicciones para los 50 idiomas principales alojados por GitHub y supera a Linguist en precisión y rendimiento. <a name="habracut"></a><br><br><h2>  Las tuercas y tornillos detrás de OctoLingua </h2><br>  OctoLingua se creó desde cero utilizando Python, Keras con el backend TensorFlow, y está diseñado para ser preciso, robusto y fácil de mantener.  En esta sección, describimos nuestras fuentes de datos, arquitectura de modelo y referencia de rendimiento para OctoLingua.  También describimos lo que se necesita para agregar soporte para un nuevo idioma. <br><br><h3>  Fuentes de datos </h3><br>  La versión actual de OctoLingua se capacitó en los archivos recuperados del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Código Rosetta</a> y de un conjunto de repositorios de calidad de colaboración interna.  Limitamos nuestro conjunto de idiomas a los 50 idiomas principales alojados en GitHub. <br><br>  Rosetta Code fue un excelente conjunto de datos de inicio, ya que contenía código fuente para la misma tarea expresada en diferentes lenguajes de programación.  Por ejemplo, la tarea de generar una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secuencia de Fibonacci</a> se expresa en C, C ++, CoffeeScript, D, Java, Julia y más.  Sin embargo, la cobertura en todos los idiomas no fue uniforme donde algunos idiomas solo tienen un puñado de archivos y algunos archivos estaban escasamente poblados.  Por lo tanto, era necesario aumentar nuestro conjunto de capacitación con algunas fuentes adicionales y mejorar sustancialmente la cobertura y el rendimiento del idioma. <br><br>  Nuestro proceso para agregar un nuevo idioma ahora está completamente automatizado.  Recopilamos programáticamente el código fuente de repositorios públicos en GitHub.  Elegimos repositorios que cumplen con un criterio mínimo de calificación, como tener un número mínimo de horquillas, cubrir el idioma de destino y cubrir extensiones de archivo específicas.  Para esta etapa de recopilación de datos, determinamos el idioma principal de un repositorio utilizando la clasificación de Linguist. <br><br><h3>  Características: aprovechando el conocimiento previo </h3><br>  Tradicionalmente, para problemas de clasificación de texto con redes neuronales, a menudo se emplean arquitecturas basadas en memoria como las redes neuronales recurrentes (RNN) y las redes de memoria a largo plazo (LSTM).  Sin embargo, dado que los lenguajes de programación tienen diferencias en vocabulario, estilo de comentario, extensiones de archivo, estructura, estilo de importación de bibliotecas y otras diferencias menores, optamos por un enfoque más simple que aprovecha toda esta información mediante la extracción de algunas características relevantes en forma de tabla para alimentarlas. nuestro clasificador  Las características extraídas actualmente son las siguientes: <br><br><ol><li>  Los cinco caracteres especiales principales por archivo </li><li>  Top 20 tokens por archivo </li><li>  Extensión de archivo </li><li>  Presencia de ciertos caracteres especiales comúnmente utilizados en archivos de código fuente, como dos puntos, llaves y puntos y comas </li></ol><br><h3>  El modelo de red neuronal artificial (ANN) </h3><br>  Utilizamos las características anteriores como entrada a una red neuronal artificial de dos capas construida usando Keras con el backend Tensorflow. <br><br>  El siguiente diagrama muestra que el paso de extracción de características produce una entrada tabular n-dimensional para nuestro clasificador.  A medida que la información se mueve a lo largo de las capas de nuestra red, se regulariza por abandono y finalmente produce una salida de 51 dimensiones que representa la probabilidad predicha de que el código dado se escriba en cada uno de los 50 idiomas principales de GitHub más la probabilidad de que no sea escrito en cualquiera de esos. <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/21c/3d4/1d0/21c3d41d0f7c82c8f0751bde7036bd55.png"></div><br>  <i>Figura 2: La Estructura ANN de nuestro modelo inicial (50 idiomas + 1 para "otro")</i> <br><br>  Utilizamos el 90% de nuestro conjunto de datos para el entrenamiento en aproximadamente ocho épocas.  Además, eliminamos un porcentaje de extensiones de archivo de nuestros datos de entrenamiento en el paso de entrenamiento, para alentar al modelo a aprender del vocabulario de los archivos y no sobreajustar en la función de extensión de archivo, que es altamente predictiva. <br><br><h3>  Punto de referencia de rendimiento </h3><br>  <b>OctoLingua vs.</b>  <b>Lingüista</b> <br><br>  En la Figura 3, mostramos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Puntuación F1</a> (media armónica entre precisión y recuperación) de OctoLingua y Linguist calculada en el mismo conjunto de prueba (10% de nuestra fuente de datos inicial). <br><br>  Aquí mostramos tres pruebas.  La primera prueba es con el conjunto de prueba sin tocar de ninguna manera.  La segunda prueba usa el mismo conjunto de archivos de prueba con la información de extensión de archivo eliminada y la tercera prueba también usa el mismo conjunto de archivos, pero esta vez con extensiones de archivo codificadas para confundir a los clasificadores (por ejemplo, un archivo Java puede tener un ". La extensión txt "y un archivo Python pueden tener una extensión" .java "). <br><br>  La intuición detrás de codificar o eliminar las extensiones de archivo en nuestro conjunto de pruebas es evaluar la solidez de OctoLingua en la clasificación de archivos cuando se elimina una característica clave o es engañosa.  Un clasificador que no dependa en gran medida de la extensión sería extremadamente útil para clasificar lo esencial y los fragmentos, ya que en esos casos es común que las personas no proporcionen información de extensión precisa (por ejemplo, muchas claves relacionadas con el código tienen una extensión .txt). <br><br>  La tabla a continuación muestra cómo OctoLingua mantiene un buen rendimiento en diversas condiciones, lo que sugiere que el modelo aprende principalmente del vocabulario del código, en lugar de la metainformación (es decir, la extensión de archivo), mientras que Linguist falla tan pronto como la información sobre las extensiones de archivo es alterado <br><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/4d9/a60/93d/4d9a6093ded8dbeb762c34dacd9d279f.png"></div>  <i>Figura 3: Rendimiento de OctoLingua vs.</i>  <i>Lingüista en el mismo conjunto de prueba</i> <br><br>  <b>Efecto de eliminar la extensión del archivo durante el tiempo de entrenamiento</b> <br><br>  Como se mencionó anteriormente, durante el tiempo de entrenamiento eliminamos un porcentaje de extensiones de archivo de nuestros datos de entrenamiento para alentar al modelo a aprender del vocabulario de los archivos.  La siguiente tabla muestra el rendimiento de nuestro modelo con diferentes fracciones de extensiones de archivo eliminadas durante el tiempo de entrenamiento. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ace/a5e/7d3/acea5e7d33553fe499f7d386d97b7caf.png"><br>  <i>Figura 4: Rendimiento de OctoLingua con diferentes porcentajes de extensiones de archivo eliminados en nuestras tres variaciones de prueba</i> <br><br>  Tenga en cuenta que sin la eliminación de la extensión de archivo durante el tiempo de entrenamiento, el rendimiento de OctoLingua en archivos de prueba sin extensiones y extensiones aleatorias disminuye significativamente de eso en los datos de prueba regulares.  Por otro lado, cuando el modelo se entrena en un conjunto de datos donde se eliminan algunas extensiones de archivo, el rendimiento del modelo no disminuye mucho en el conjunto de prueba modificado.  Esto confirma que eliminar la extensión de archivo de una fracción de archivos en el momento del entrenamiento induce a nuestro clasificador a aprender más del vocabulario.  También muestra que la función de extensión de archivo, aunque altamente predictiva, tenía una tendencia a dominar y evitaba que se asignaran más pesos a las funciones de contenido. <br><br><h3>  Apoyando un nuevo idioma </h3><br>  Agregar un nuevo idioma en OctoLingua es bastante sencillo.  Comienza con la obtención de una gran cantidad de archivos en el nuevo idioma (podemos hacer esto mediante programación como se describe en las fuentes de datos).  Estos archivos se dividen en un conjunto de entrenamiento y prueba y luego se ejecutan a través de nuestro preprocesador y extractor de funciones.  Este nuevo conjunto de trenes y pruebas se agrega a nuestro grupo existente de datos de capacitación y pruebas.  El nuevo conjunto de pruebas nos permite verificar que la precisión de nuestro modelo sigue siendo aceptable. <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/dcd/9fa/d5c/dcd9fad5ceed5cb24cefdf6e78c3e99f.png"></div>  <i>Figura 5: Agregar un nuevo idioma con OctoLingua</i> <br><br><h2>  Nuestros planes </h2><br>  A partir de ahora, OctoLingua se encuentra en la "etapa avanzada de creación de prototipos".  Nuestro motor de clasificación de idiomas ya es robusto y confiable, pero aún no admite todos los idiomas de codificación en nuestra plataforma.  Además de ampliar el soporte de idiomas, lo que sería bastante sencillo, nuestro objetivo es permitir la detección de idiomas en varios niveles de granularidad.  Nuestra implementación actual ya nos permite, con una pequeña modificación en nuestro motor de aprendizaje automático, clasificar fragmentos de código.  No sería demasiado descabellado llevar el modelo al escenario donde pueda detectar y clasificar de manera confiable los lenguajes incrustados. <br><br>  También estamos contemplando la posibilidad de un código abierto de nuestro modelo y nos encantaría saber de la comunidad si está interesado. <br><br><h2>  Resumen </h2><br>  Con OctoLingua, nuestro objetivo es proporcionar un servicio que permita la detección robusta y confiable del lenguaje de código fuente en múltiples niveles de granularidad, desde el nivel de archivo o nivel de fragmento hasta la detección y clasificación de lenguaje de nivel de línea potencial.  Eventualmente, este servicio puede admitir, entre otros, la búsqueda de código, el intercambio de código, el resaltado de idioma y la representación diferencial, todo esto destinado a apoyar a los desarrolladores en su trabajo de desarrollo diario, además de ayudarlos a escribir código de calidad.  Si está interesado en aprovechar o contribuir a nuestro trabajo, ¡no dude en ponerse en contacto en Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@github</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459094/">https://habr.com/ru/post/459094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459084/index.html">Un poco sobre Google Home Hub, o cómo compré un marco de fotos por 130 euros</a></li>
<li><a href="../459086/index.html">Distribución estática de objetos FreeRTOS</a></li>
<li><a href="../459088/index.html">Métodos de segmentación de puntos en nubes de puntos</a></li>
<li><a href="../459090/index.html">Lleve su experiencia de desarrollo de Linux en Windows al siguiente nivel con WSL y Visual Studio Code Remote</a></li>
<li><a href="../459092/index.html">X.Spectator - monitoreo de estado en .NET</a></li>
<li><a href="../459098/index.html">GitHub Package Registry admitirá paquetes Swift</a></li>
<li><a href="../459100/index.html">GitHub Package Registry admitirá paquetes Swift</a></li>
<li><a href="../459102/index.html">Plato de regalo o música gratis para los amantes de la cola y desayunos preparados.</a></li>
<li><a href="../459104/index.html">C # o Java? ¿TypeScript o JavaScript? La clasificación de los lenguajes de programación basados ​​en el aprendizaje automático.</a></li>
<li><a href="../459108/index.html">Tesla presentará varias sorpresas a la vez en la segunda mitad de este año</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>