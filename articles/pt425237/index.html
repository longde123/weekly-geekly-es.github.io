<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèª üí® ‚öïÔ∏è Medi√ß√£o de tempo com precis√£o de nanossegundos ü§∂üèø üõÄüèº üëéüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alguns meses atr√°s, um momento hist√≥rico veio para mim. As ferramentas padr√£o do sistema operacional para medir o tempo deixaram de ser suficientes pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Medi√ß√£o de tempo com precis√£o de nanossegundos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425237/"><img src="https://habrastorage.org/webt/zx/xf/se/zxxfse_sd5ma4wwfy0u6rilcai8.jpeg" alt="imagem"><br><br>  Alguns meses atr√°s, um momento hist√≥rico veio para mim.  As ferramentas padr√£o do sistema operacional para medir o tempo deixaram de ser suficientes para mim.  Demorou um tempo para medir com precis√£o de nanossegundos e sobrecarga de nanossegundos. <br><br>  Decidi escrever uma biblioteca que resolveria esse problema.  √Ä primeira vista, parecia que n√£o havia nada de especial para fazer.  Mas, ap√≥s uma an√°lise mais detalhada, como sempre, verificou-se que havia muitos problemas interessantes a serem resolvidos.  Neste artigo, falarei sobre os problemas e como eles foram resolvidos. <br><br>  Como voc√™ pode medir muitos tipos diferentes de tempo em um computador, vou esclarecer imediatamente que aqui falaremos sobre "tempo por cron√¥metro".  Ou hora do rel√≥gio de parede.  √â tempo real, tempo decorrido etc.  Ou seja, um tempo "humano" simples, que detectamos no in√≠cio da tarefa e paramos no final. <br><a name="habracut"></a><br><h3>  Microssegundo - quase para sempre </h3><br>  Os desenvolvedores de sistemas de alto desempenho nos √∫ltimos anos se acostumaram √† escala de tempo de microssegundos.  Em microssegundos, voc√™ pode ler dados de uma unidade NVMe.  Em microssegundos, os dados podem ser enviados pela rede.  N√£o para todos, √© claro, mas para a rede InifiniBand - facilmente. <br><br>  Ao mesmo tempo, o microssegundo tamb√©m tinha uma estrutura.  Uma pilha de E / S completa consiste em v√°rios componentes de software e hardware.  Os atrasos introduzidos por alguns deles est√£o no n√≠vel de microssegundos. <br><br>  Para medir atrasos dessa magnitude, a precis√£o do microssegundo n√£o √© mais suficiente.  No entanto, n√£o apenas a precis√£o √© importante, mas tamb√©m a sobrecarga do tempo de medi√ß√£o.  A chamada do sistema clock_gettime () do Linux retorna a hora com precis√£o de nanossegundos.  Em uma m√°quina que est√° ao meu alcance (CPU Intel¬Æ Xeon¬Æ E5-2630 v2 a 2.60GHz), essa chamada √© conclu√≠da em cerca de 120 ns.  Muito boa figura.  Al√©m disso, clock_gettime () funciona de maneira bastante previs√≠vel.  Isso permite que voc√™ leve em considera√ß√£o a sobrecarga da chamada e efetue medi√ß√µes com precis√£o da ordem de dezenas de nanossegundos.  No entanto, vamos agora prestar aten√ß√£o a isso.  Para medir o intervalo de tempo, voc√™ precisa fazer duas chamadas: no in√≠cio e no final.  I.e.  gaste 240 ns.  Se forem medidos intervalos de tempo densamente espa√ßados da ordem de 1 a 10 Œºs, em alguns casos, o pr√≥prio processo de medi√ß√£o distorcer√° significativamente o processo observado. <br><br>  Comecei esta se√ß√£o com a acelera√ß√£o da pilha de E / S nos √∫ltimos anos.  Isso √© novo, mas est√° longe de ser o √∫nico motivo para querer medir o tempo com rapidez e precis√£o.  Essa necessidade sempre foi.  Por exemplo, sempre havia um c√≥digo que eu queria acelerar pelo menos 1 ciclo de clock do microprocessador.  Ou outro exemplo, do artigo original sobre a sensacional vulnerabilidade Spectre: <br><br><img src="https://habrastorage.org/webt/db/5a/7o/db5a7oldvzrcqfi_ymamg4qzscu.jpeg" alt="imagem"><br><br>  Aqui, as linhas 72-74 medem o tempo de execu√ß√£o de uma √∫nica opera√ß√£o de acesso √† mem√≥ria.  √â verdade que o Spectre n√£o est√° interessado em nanossegundos.  O tempo pode ser medido em "papagaios".  Voltaremos aos papagaios e segundos. <br><br><h3>  Contador de carimbo de data / hora </h3><br>  A chave para a medi√ß√£o r√°pida e precisa do tempo √© um contador especial de microprocessador.  O valor desse contador geralmente √© armazenado em um registro separado e geralmente √© - mas nem sempre - acess√≠vel no espa√ßo do usu√°rio.  Em arquiteturas diferentes, o contador √© chamado de maneira diferente: <br><br><ol><li>  contador de carimbo de hora x86 </li><li>  registro de base de tempo no PowerPC </li><li>  contador de tempo de intervalo no Itanium </li><li>  etc. </li></ol><br>  Abaixo, sempre usarei o nome "contador de carimbo de data / hora" ou TSC, embora na verdade eu tenha em mente esse contador, independentemente da arquitetura. <br><br>  A leitura do valor TSC normalmente - mas nem sempre - √© poss√≠vel com uma √∫nica instru√ß√£o.  Aqui est√° um exemplo para x86.  Estritamente falando, esta n√£o √© uma instru√ß√£o pura do assembler, mas o assembler GNU inline: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eax, edx; __asm__ __volatile__( <span class="hljs-string"><span class="hljs-string">"rdtsc"</span></span> : <span class="hljs-string"><span class="hljs-string">"=a"</span></span> (eax), <span class="hljs-string"><span class="hljs-string">"=d"</span></span> (edx));</code> </pre> <br>  A instru√ß√£o rdtsc coloca duas metades de 32 bits do registrador TSC nos registradores eax e edx.  Destas, voc√™ pode "colar" um √∫nico valor de 64 bits. <br><br>  Mais uma vez, observo: essas instru√ß√µes (e similares) na maioria dos casos podem ser chamadas diretamente do espa√ßo do usu√°rio.  Nenhuma chamada do sistema.  Sobrecarga m√≠nima. <br><br>  O que agora precisa ser feito para medir o tempo? <br><br><ol><li>  Execute uma dessas instru√ß√µes no in√≠cio do intervalo de tempo de seu interesse.  Lembre-se do valor do contador </li><li>  Execute uma dessas instru√ß√µes no final.  Acreditamos que o valor do contador da primeira instru√ß√£o para a segunda aumentar√°.  Caso contr√°rio, por que √© necess√°rio?  Lembre-se do segundo valor </li><li>  Consideramos a diferen√ßa entre os dois valores armazenados.  Este √© o nosso tempo </li></ol><br>  Parece simples, mas ... <br><br>  O tempo medido pelo procedimento descrito √© expresso em "papagaios".  N√£o √© em segundos.  Mas √†s vezes os papagaios s√£o exatamente o que voc√™ precisa.  H√° situa√ß√µes em que os valores absolutos dos intervalos de tempo n√£o s√£o importantes, mas como os diferentes intervalos se relacionam.  O exemplo Spectre acima demonstra exatamente essa situa√ß√£o.  A dura√ß√£o de cada acesso individual √† mem√≥ria n√£o importa.  √â importante que chamadas para alguns endere√ßos sejam executadas muito mais rapidamente do que para outras (dependendo se os dados est√£o armazenados no cache ou na mem√≥ria principal). <br><br>  Mas e se n√£o forem necess√°rios papagaios, mas segundos / microssegundos / nanossegundos, etc.?  Dois casos fundamentalmente diferentes podem ser distinguidos aqui: <br><br><ol><li>  Nanossegundos s√£o necess√°rios, mas ent√£o.  Ou seja, √© permitido primeiro fazer todas as medidas necess√°rias em papagaios e armazen√°-las em algum lugar para processamento adicional (por exemplo, na mem√≥ria).  E somente ap√≥s as medi√ß√µes serem conclu√≠das, convertendo lentamente os papagaios coletados em segundos </li><li>  Nanossegundos s√£o necess√°rios "on the fly".  Por exemplo, seu processo de medi√ß√£o possui algum tipo de "consumidor" que voc√™ n√£o controla e que espera tempo no formato "humano" </li></ol><br>  O primeiro caso √© simples, o segundo - requer desenvoltura.  A convers√£o deve ser o mais eficaz poss√≠vel.  Se consumir muitos recursos, pode distorcer bastante o processo de medi√ß√£o.  Falaremos sobre a convers√£o efetiva abaixo.  At√© aqui, identificamos esse problema e passamos para outro. <br><br>  Os contadores de data e hora n√£o s√£o t√£o simples quanto gostar√≠amos.  Em algumas arquiteturas: <br><br><ol><li>  n√£o √© garantido que o TSC seja atualizado em alta frequ√™ncia.  Se o TSC for atualizado, digamos, uma vez a cada microssegundo, n√£o ser√° poss√≠vel corrigir nanossegundos com ele. </li><li>  a frequ√™ncia com a qual o TSC √© atualizado pode variar ao longo do tempo </li><li>  em diferentes CPUs presentes no sistema, os TSCs podem ser atualizados em diferentes frequ√™ncias </li><li>  pode haver uma mudan√ßa entre os TSCs em diferentes CPUs </li></ol><br>  Aqui est√° um exemplo que ilustra o √∫ltimo problema.  Suponha que tenhamos um sistema com duas CPUs: CPU1 e CPU2.  Suponha que o TSC na primeira CPU esteja atr√°s da segunda pelo n√∫mero de ticks, o que equivale a 5 segundos.  Suponha ainda que um fluxo seja lan√ßado no sistema que mede o tempo dos c√°lculos, o que ele pr√≥prio faz.  Para fazer isso, o fluxo primeiro l√™ o valor TSC, depois faz o c√°lculo e, em seguida, l√™ o segundo valor TSC.  Se durante toda a sua vida √∫til um thread permanecer em apenas uma CPU - em qualquer -, n√£o haver√° problemas.  Mas e se o encadeamento iniciado na CPU1, medisse o primeiro valor TSC l√° e, no meio dos c√°lculos, fosse movido pelo sistema operacional para a CPU2, onde leria o segundo valor TSC?  Nesse caso, os c√°lculos parecer√£o 5 segundos mais longos do que realmente s√£o. <br><br>  Devido aos problemas listados acima, o TSC n√£o pode servir como uma fonte confi√°vel de tempo em alguns sistemas.  No entanto, em outros sistemas "sofrendo" dos mesmos problemas, o TSC ainda pode ser usado.  Isso √© poss√≠vel gra√ßas a recursos arquitet√¥nicos especiais: <br><br><ol><li>  o equipamento pode gerar uma interrup√ß√£o especial sempre que a frequ√™ncia com a qual o TSC √© atualizado for alterada.  Ao mesmo tempo, o equipamento tamb√©m oferece a oportunidade de descobrir a frequ√™ncia atual.  Como alternativa, a taxa de atualiza√ß√£o do TSC pode ser colocada sob o controle do sistema operacional (consulte ‚ÄúPower ISA Vers√£o 2.06 Revis√£o B, Livro II, Cap√≠tulo 5‚Äù) </li><li>  juntamente com o valor TSC, o equipamento tamb√©m pode fornecer o ID da CPU na qual esse valor √© lido (consulte as instru√ß√µes Intel RDTSCP, ‚ÄúManual do desenvolvedor de software das arquiteturas Intel 64 e IA-32‚Äù, volume 2) </li><li>  em alguns sistemas, voc√™ pode ajustar programaticamente o valor TSC para cada CPU (consulte a instru√ß√£o Intel WRMSR e registre IA32_TIME_STAMP_COUNTER, ‚ÄúManual do desenvolvedor de software das arquiteturas Intel 64 e IA-32‚Äù, volume 3) </li></ol><br>  Em geral, o tema de como os medidores de tempo s√£o implementados em diferentes arquiteturas √© fascinante e extenso.  Se voc√™ tiver tempo e interesse, recomendo mergulhar.  Entre outras coisas, voc√™ aprender√°, por exemplo, que alguns sistemas permitem determinar programaticamente se o TSC pode servir como uma fonte confi√°vel de tempo. <br><br>  Portanto, existem muitas implementa√ß√µes arquitet√¥nicas do TSC, cada uma com suas pr√≥prias caracter√≠sticas.  Mas √© interessante que uma tend√™ncia geral tenha sido estabelecida em todo esse zool√≥gico.  <b>Os sistemas operacionais e hardware modernos se esfor√ßam para garantir que</b> : <br><br><ol><li>  O TSC marca na mesma frequ√™ncia em cada CPU do sistema </li><li>  essa frequ√™ncia n√£o muda no tempo </li><li>  n√£o h√° mudan√ßa entre TSCs marcando em diferentes CPUs </li></ol><br>  Ao projetar minha biblioteca, decidi seguir essa premissa, e n√£o o vinagrete das implementa√ß√µes de hardware. <br><br><h3>  A biblioteca </h3><br>  N√£o comecei a colocar chips de hardware de v√°rias arquiteturas diferentes.  Em vez disso, decidi que minha biblioteca seria orientada a tend√™ncias.  Ela tem um foco puramente emp√≠rico: <br><br><ol><li>  permite verificar experimentalmente a confiabilidade do TSC como fonte de tempo </li><li>  tamb√©m permite calcular experimentalmente os par√¢metros necess√°rios para converter rapidamente ticks em nanossegundos </li><li>  naturalmente, a biblioteca fornece interfaces convenientes para ler TSC e converter ticks em nanossegundos "on the fly" </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O c√≥digo da biblioteca est√° dispon√≠vel aqui.</a>  Ser√° compilado e executado apenas no Linux. <br><br>  No c√≥digo, voc√™ pode ver os detalhes da implementa√ß√£o de todos os m√©todos, que ser√£o discutidos posteriormente. <br><br><h3>  Avalia√ß√£o de Confiabilidade TSC </h3><br>  A biblioteca fornece uma interface que retorna duas classifica√ß√µes: <br><br><ol><li>  deslocamento m√°ximo entre contadores pertencentes a diferentes CPUs.  Somente CPUs dispon√≠veis para o processo s√£o consideradas.  Por exemplo, se um processo tiver tr√™s CPUs dispon√≠veis e, ao mesmo tempo, o TSC nessas CPUs for 50, 150, 20, o deslocamento m√°ximo ser√° 150-20 = 130.  Naturalmente, a biblioteca n√£o poder√° obter um turno m√°ximo real experimentalmente, mas fornecer√° uma estimativa na qual esse turno se ajustar√°.  O que fazer em seguida com a avalia√ß√£o?  Como usar?  Isso j√° resolve o c√≥digo do cliente.  Mas o significado √© aproximadamente o seguinte.  O deslocamento m√°ximo √© o valor m√°ximo pelo qual a dimens√£o que o c√≥digo do cliente faz pode ser distorcida.  Suponha que, em nosso exemplo com tr√™s CPUs, o c√≥digo do cliente comece a medir o tempo na CPU3 (onde TSC tinha 20 anos) e termine na CPU2 (onde TSC tenha 150).  Acontece que 130 carrapatos extras entrar√£o no intervalo medido.  E nunca mais.  A diferen√ßa entre CPU1 e CPU2 seria de apenas 100 ticks.  Tendo uma estimativa de 130 ticks (na verdade, ser√° muito mais conservador), o cliente pode decidir se esse valor de distor√ß√£o combina com ele ou n√£o </li><li>  Os valores TSC medidos sequencialmente na mesma ou em diferentes CPUs aumentam.  Aqui est√° a ideia.  Digamos que temos v√°rias CPUs.  Suponha que o rel√≥gio esteja sincronizado e marcando na mesma frequ√™ncia.  Ent√£o, se voc√™ medir primeiro o tempo em uma CPU e depois medir novamente - j√° em qualquer uma das CPUs dispon√≠veis -, o segundo d√≠gito dever√° ser maior que o primeiro. <br><br>  Vou chamar essa estimativa abaixo da estimativa de monotonicidade do TSC <br></li></ol><br>  Agora vamos ver como podemos obter a primeira estimativa: <br><br><ol><li>  um dos processadores dispon√≠veis para o processo √© declarado "b√°sico" </li><li>  todas as outras CPUs s√£o classificadas e para cada uma delas o deslocamento √© calculado: <code>TSC___CPU ‚Äì TSC___CPU</code> .  Isso √© feito da seguinte maneira: <br><ul><li>  a) tr√™s valores medidos s√£o obtidos seq√ºencialmente (um ap√≥s o outro!): <code>TSC_base_1, TSC_current, TSC_base_2</code> .  Aqui, current indica que o valor foi medido na CPU atual e base na base </li><li>  b) o turno <code>TSC___CPU ‚Äì TSC___CPU</code> deve estar no intervalo <code>[TSC_current ‚Äì TSC_base_2, TSC_current ‚Äì TSC_base_1]</code> .  Isso est√° sob a suposi√ß√£o de que os TSCs est√£o marcando na mesma frequ√™ncia em ambas as CPUs. </li><li>  c) os passos a) -b) s√£o repetidos v√°rias vezes.  A interse√ß√£o de todos os intervalos obtidos na etapa b) √© calculada.  O intervalo resultante √© obtido como a estimativa do turno <code>TSC___CPU ‚Äì TSC___CPU</code> </li></ul><br></li><li>  depois que uma estimativa de turno √© obtida para cada CPU em rela√ß√£o √† base, √© f√°cil obter uma estimativa do turno m√°ximo entre todas as CPUs dispon√≠veis: <br><ul><li>  a) o intervalo m√≠nimo √© calculado, incluindo todos os intervalos resultantes obtidos na etapa 2 </li><li>  b) a largura desse intervalo √© tomada como estimativa do deslocamento m√°ximo entre os TSCs em diferentes CPUs </li></ul><br></li></ol><br>  Para avaliar a monotonia na biblioteca, o seguinte algoritmo √© implementado: <br><br><ol><li>  Digamos que um processo tenha N CPU dispon√≠vel </li><li>  Medindo TSC na CPU1 </li><li>  Medindo TSC na CPU2 </li><li>  ... </li><li>  Medindo TSC no CPUN </li><li>  Me√ßa o TSC novamente na CPU1 </li><li>  Verificamos que os valores medidos aumentam monotonicamente do primeiro ao √∫ltimo </li></ol><br>  √â importante aqui que o primeiro e o √∫ltimo valor sejam medidos na mesma CPU.  E aqui est√° o porqu√™.  Digamos que temos 3 CPUs.  Suponha que o TSC na CPU2 seja deslocado em +100 ticks em rela√ß√£o ao TSC na CPU1.  Suponha tamb√©m que o TSC na CPU3 seja deslocado em +100 ticks em rela√ß√£o ao TSC na CPU2.  Considere a seguinte cadeia de eventos: <br><br><ul><li>  Leia o TSC na CPU1.  Seja obtido um valor de 10 </li><li>  2 carrapatos passaram </li><li>  Leia TSC na CPU2.  Deve ser 112 </li><li>  2 carrapatos passaram </li><li>  Leia TSC na CPU3.  Deve ser 214 </li></ul><br>  At√© agora, o rel√≥gio parece sincronizado.  Mas vamos medir o TSC na CPU1 novamente: <br><br><ul><li>  2 carrapatos passaram </li><li>  Leia o TSC na CPU1.  Deve ter 16 anos </li></ul><br>  Opa!  A monotonia est√° quebrada.  Acontece que medir o primeiro e o √∫ltimo valor na mesma CPU permite detectar mudan√ßas mais ou menos grandes entre os rel√≥gios.  A pr√≥xima pergunta, √© claro: "Qual o tamanho das mudan√ßas?"  A quantidade de turno que pode ser detectada depende do tempo decorrido entre as sucessivas medi√ß√µes de TSC.  No exemplo dado, estes s√£o apenas 2 ticks.  Ser√£o detectados turnos entre as horas que excederem 2 ticks.  De um modo geral, mudan√ßas que s√£o menores que o tempo decorrido entre medi√ß√µes sucessivas n√£o ser√£o detectadas.  Portanto, quanto mais densas as medi√ß√µes estiverem localizadas no tempo, melhor.  A precis√£o de ambas as estimativas depende disso.  Quanto mais densas forem as medidas: <br><br><ul><li>  quanto menor a estimativa de turno m√°ximo </li><li>  quanto mais confian√ßa na avalia√ß√£o da monotonia </li></ul><br>  Na pr√≥xima se√ß√£o, falaremos sobre como fazer medi√ß√µes rigorosas.  Acrescentarei aqui que, ao calcular as estimativas de confiabilidade do TSC, a biblioteca faz muito mais verifica√ß√µes simples de "piolhos", por exemplo: <br><br><ul><li>  verifica√ß√£o limitada de que TSCs em diferentes CPUs est√£o correndo na mesma velocidade </li><li>  verificando se os contadores realmente mudam com o tempo e n√£o apenas mostram o mesmo valor </li></ul><br><h3>  Dois m√©todos para coletar valores de contador </h3><br>  Na biblioteca, implementei dois m√©todos para coletar valores de TSC: <br><br><ol><li>  <b>Alterne entre CPU</b> .  Nesse m√©todo, todos os dados necess√°rios para avaliar a confiabilidade do TSC s√£o coletados por um √∫nico encadeamento que ‚Äúsalta‚Äù de uma CPU para outra.  Ambos os algoritmos descritos na se√ß√£o anterior s√£o adequados para este m√©todo e n√£o s√£o adequados para o outro. <br>  "Alternar entre a CPU" n√£o tem uso pr√°tico.  O m√©todo foi implementado apenas para "brincar".  O problema com o m√©todo √© que o tempo necess√°rio para "arrastar" um fluxo de uma CPU para outra √© muito grande.  Consequentemente, passa muito tempo entre medi√ß√µes sucessivas de TSC e a precis√£o das estimativas √© muito baixa.  Por exemplo, uma estimativa t√≠pica para o deslocamento m√°ximo entre o TSC √© obtida na regi√£o de 23.000 carrapatos. <br><br>  No entanto, o m√©todo tem algumas vantagens: <br><ul><li>  √© absolutamente determin√≠stico.  Se voc√™ precisar medir o TSC sequencialmente na CPU1, CPU2, CPU3, basta faz√™-lo: alterne para CPU1, leia TSC, alterne para CPU2, leia TSC e, finalmente, alterne para CPU3, leia TSC </li><li>  presumivelmente, se o n√∫mero de CPUs no sistema crescer muito r√°pido, o tempo de altern√¢ncia entre elas dever√° aumentar muito mais lentamente.  Portanto, em teoria, aparentemente, um sistema pode existir - um sistema muito grande!  - em que o uso do m√©todo ser√° justificado.  Mas ainda assim isso √© improv√°vel </li></ul><br></li><li>  <b>Medi√ß√µes solicitadas usando o CAS</b> .  Nesse m√©todo, os dados s√£o coletados em paralelo por v√°rios threads.  Cada CPU dispon√≠vel inicia um thread.  As medi√ß√µes realizadas por diferentes threads s√£o organizadas em uma √∫nica sequ√™ncia usando a opera√ß√£o "comparar e trocar".  Abaixo est√° um peda√ßo de c√≥digo que mostra como isso √© feito. <br>  A id√©ia do m√©todo √© emprestada do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fio</a> , uma ferramenta popular para gerar cargas de E / S. <br><br>  As estimativas de confiabilidade obtidas com o poder desse m√©todo j√° parecem muito boas.  Por exemplo, uma estimativa do turno m√°ximo j√° √© obtida no n√≠vel de v√°rias centenas de ticks.  Uma verifica√ß√£o de monotonia permite que voc√™ pegue o rel√≥gio fora de sincronia dentro de centenas de ticks. <br><br>  No entanto, os algoritmos dados na se√ß√£o anterior n√£o s√£o adequados para esse m√©todo.  √â importante para eles que os valores de TSC sejam medidos em uma ordem predeterminada.  O m√©todo de "medi√ß√µes ordenadas pelo CAS" n√£o permite isso.  Em vez disso, primeiro uma longa sequ√™ncia de medi√ß√µes aleat√≥rias √© coletada e, em seguida, algoritmos (j√° diferentes) tentam encontrar valores lidos em CPUs "adequadas" nessa sequ√™ncia. <br><br>  N√£o darei esses algoritmos aqui, para n√£o abusar de sua aten√ß√£o.  Voc√™ pode v√™-los no c√≥digo.  Existem muitos coment√°rios.  Em teoria, esses algoritmos s√£o os mesmos.  Um ponto fundamentalmente novo √© a verifica√ß√£o de como as seq√º√™ncias TSC de tipo aleat√≥rio s√£o estatisticamente "qualitativas".  Tamb√©m √© poss√≠vel definir um n√≠vel m√≠nimo aceit√°vel de signific√¢ncia estat√≠stica para as estimativas de confiabilidade do TSC. <br><br>  Teoricamente, em sistemas MUITO grandes, o m√©todo "ordenado por CAS" pode fornecer resultados ruins.  O m√©todo requer que os processadores concorram pelo acesso a um local de mem√≥ria comum.  Se houver muitos processadores, a concorr√™ncia poder√° se tornar muito intensa.  Como resultado, ser√° dif√≠cil criar uma sequ√™ncia de medidas com boas propriedades estat√≠sticas.  No entanto, no momento, essa situa√ß√£o parece improv√°vel. <br></li></ol><br>  Eu prometi algum c√≥digo.  Veja como √© criar medi√ß√µes em uma √∫nica cadeia usando o CAS. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg-&gt;probes_count; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> seq_num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> tsc_val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { __atomic_load( seq_counter, &amp;seq_num, __ATOMIC_ACQUIRE); __sync_synchronize(); tsc_val = WTMLIB_GET_TSC(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !__atomic_compare_exchange_n( seq_counter, &amp;seq_num, seq_num + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, __ATOMIC_ACQ_REL, __ATOMIC_RELAXED)); arg-&gt;tsc_probes[i].seq_num = seq_num; arg-&gt;tsc_probes[i].tsc_val = tsc_val; }</code> </pre><br>  Este c√≥digo √© executado em todas as CPUs dispon√≠veis.  Todos os encadeamentos t√™m acesso √† vari√°vel compartilhada <code>seq_counter</code> .  Antes de ler o TSC, o fluxo l√™ o valor dessa vari√°vel e o armazena na vari√°vel <code>seq_num</code> .  Ent√£o l√™ TSC.  Em seguida, ele tenta aumentar atomicamente seq_counter em um, mas apenas se o valor da vari√°vel n√£o tiver sido alterado desde que foi lido.  Se a opera√ß√£o for bem-sucedida, isso significa que o encadeamento conseguiu "piquetar" o n√∫mero de sequ√™ncia armazenado em <code>seq_num</code> atr√°s do valor TSC medido.  O pr√≥ximo n√∫mero de s√©rie, que poder√° apostar (possivelmente j√° em outro encadeamento) ser√° mais um.  Esse n√∫mero √© obtido da vari√°vel <code>seq_counter</code> e cada chamada bem-sucedida de <code>__atomic_compare_exchange_n()</code> aumenta essa vari√°vel em um. <br><br><div class="spoiler">  <b class="spoiler_title">__atomic com __sync ???</b> <div class="spoiler_text">  Por uma quest√£o de <code>__atomic</code> , deve-se notar que o uso das fun√ß√µes <code>__atomic</code> fam√≠lia <code>__atomic</code> junto com uma fun√ß√£o da fam√≠lia <code>__sync</code> obsoleta parece feio.  <code>__sync_synchronize()</code> usado no c√≥digo para evitar reordenar a opera√ß√£o de leitura do TSC com a opera√ß√£o upstream.  Isso requer uma barreira de mem√≥ria completa.  A fam√≠lia <code>__atomic</code> formalmente n√£o possui uma fun√ß√£o com as propriedades correspondentes.  Embora de fato exista: <code>__atomic_signal_fence()</code> .  Essa fun√ß√£o organiza c√°lculos de fluxo com manipuladores de sinal que s√£o executados no mesmo fluxo.  De fato, essa √© uma barreira completa.  No entanto, isso n√£o √© explicitamente declarado.  E eu prefiro c√≥digo que n√£o possui sem√¢ntica oculta.  Portanto, <code>__sync_synchronize()</code> √© uma barreira de mem√≥ria de ponto cheio. <br></div></div><br>  Outro ponto que vale a pena mencionar aqui √© o cuidado de que todos os fluxos envolvidos nas medi√ß√µes iniciem mais ou menos simultaneamente.  Estamos interessados ‚Äã‚Äãno fato de que os valores TSC lidos em diferentes CPUs s√£o t√£o mistos quanto poss√≠vel.  N√£o estamos satisfeitos com a situa√ß√£o em que, por exemplo, um thread inicia primeiro, termina seu trabalho e somente ent√£o todos os outros come√ßam.  A sequ√™ncia TSC resultante ter√° propriedades in√∫teis.  Nenhuma estimativa pode ser extra√≠da dele.  O in√≠cio simult√¢neo de todos os threads √© importante - e, para isso, foram tomadas medidas na biblioteca. <br><br><h3>  Converta carrapatos em nanossegundos em tempo real </h3><br>  Ap√≥s verificar a confiabilidade do TSC, o segundo objetivo principal da biblioteca √© converter ticks em nanossegundos em tempo real.  Peguei emprestada a ideia dessa convers√£o do fio j√° mencionado.  No entanto, eu tive que fazer algumas melhorias significativas, porque, como mostrou minha an√°lise, o processo de convers√£o n√£o funciona bem o suficiente.  L√° voc√™ obt√©m baixa precis√£o. <br><br>  Vou come√ßar com um exemplo. <br><br>  Idealmente, gostaria de converter ticks em nanossegundos como este: <br> <code>ns_time = tsc_ticks / tsc_per_ns</code> <br>  Queremos que o tempo gasto na convers√£o seja m√≠nimo.  Portanto, pretendemos usar aritm√©tica exclusivamente inteira.  Vamos ver como isso pode nos amea√ßar. <br><br>  Se <code>tsc_per_ns = 3</code> , uma divis√£o inteira simples, do ponto de vista da precis√£o, funciona bem: <code>ns_time = tsc_ticks / 3</code> . <br><br>  Mas e se <code>tsc_per_ns = 3.333</code> ?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se esse n√∫mero for arredondado para 3, a precis√£o da convers√£o ser√° muito baixa. Para ultrapassar este problema da seguinte forma: </font></font><br> <code>ns_time = (tsc_ticks * factor) / (3.333 * factor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o fator </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for grande o suficiente, a precis√£o ser√° boa. Mas algo continuar√° ruim. Ou seja, sobrecarga de convers√£o. A divis√£o inteira √© uma opera√ß√£o muito cara. Por exemplo, no x86, s√£o necess√°rios mais de 10 ciclos de clock. Al√©m disso, as opera√ß√µes de divis√£o inteira nem sempre s√£o canalizadas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s reescrever nossa f√≥rmula na forma equivalente </font></font><br> <code>ns_time = (tsc_ticks * factor / 3.333) / factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira divis√£o n√£o √© um problema. Podemos pr√© </font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">calcular </font><font style="vertical-align: inherit;">antecipadamente. Mas a segunda divis√£o ainda √© dor. Para se livrar dela, vamos escolher</font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">igual ao poder de dois. Depois disso, a segunda divis√£o pode ser substitu√≠da por uma mudan√ßa de bits - uma opera√ß√£o simples e r√°pida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu√£o grande voc√™ pode escolher </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Infelizmente, </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o pode ser arbitrariamente grande. √â limitado pela condi√ß√£o de que a multiplica√ß√£o no numerador n√£o deve levar ao estouro do tipo de 64 bits. Sim, queremos usar apenas tipos "nativos". Novamente, para manter as despesas gerais de convers√£o no m√≠nimo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos ver o qu√£o grande pode ser </font></font><code>factor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em nosso exemplo espec√≠fico. Suponha que desejemos trabalhar com intervalos de tempo de at√© um ano. Durante o ano, TSC tiknet nos seguintes hor√°rios: </font></font><code>3.333 * 1000000000 * 60 * 60 * 24 * 365 = 105109488000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dividir um valor m√°ximo do n√∫mero do tipo de 64 bits √©: </font></font><code>18446744073709551615 / 105109488000000000 ~ 175.5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ent√£o a express√£o</font></font><code>(factor / 3.333)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o deve exceder esse valor. Ent√£o n√≥s temos </font></font><code>factor &lt;= 175.5 * 3.333 ~ 584.9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A maior pot√™ncia de duas que n√£o excede esse n√∫mero √© 512. Portanto, nossa f√≥rmula de convers√£o assume a forma: </font></font><br><br> <code>ns_time = (tsc_ticks * 512 / 3.333) / 512</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou: </font></font><br><br> <code>ns_time = tsc_ticks * 153 / 512</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ìtimo. Vamos agora ver o que essa f√≥rmula tem com precis√£o. Um ano cont√©m </font></font><code>1000000000 * 60 * 60 * 24 * 365 = 31536000000000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nanossegundos. Nossa f√≥rmula d√°: </font></font><code>105109488000000000 * 153 / 512 = 31409671218750000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A diferen√ßa com o valor presente √© 126328781250000 nanossegundos ou </font></font><code>126328781250000 / 1000000000 / 60 / 60 ~ 35</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este √© um grande erro. Queremos uma melhor precis√£o. E se medirmos intervalos de tempo n√£o superiores a uma hora? Eu vou omitir os c√°lculos. Eles s√£o completamente id√™nticos aos que acabamos de fazer. A f√≥rmula final ser√°: </font></font><br><br> <code>ns_time = tsc_ticks * 1258417 / 4194304</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O erro de convers√£o ser√° de apenas 119.305 nanossegundos por 1 hora (menos de 0,2 milissegundos). Muito, muito bom Se o valor m√°ximo convers√≠vel for menor que uma hora, a precis√£o ser√° ainda melhor. Mas como usamos isso? N√£o limite as medi√ß√µes de tempo a uma hora? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preste aten√ß√£o para o seguinte ponto: </font></font><br><br> <code>tsc_ticks = (tsc_ticks_per_1_hour * number_of_hours) + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se precalculation </font></font><code>tsc_ticks_per_1_hour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podemos extrair </font></font><code>number_of_hours</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a partir </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em seguida, sabemos quantos nanossegundos est√£o contidos em uma hora. Portanto, n√£o ser√° dif√≠cil traduzir em nanossegundos a parte </font></font><code>tsc_ticks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que corresponde a um n√∫mero inteiro de horas. Para concluir a convers√£o, precisaremos traduzir em nanossegundos</font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No entanto, sabemos que esse n√∫mero de ticks ocorreu em menos de uma hora. Portanto, para convert√™-lo em nanossegundos, podemos usar a f√≥rmula (1). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feito. Esse mecanismo de convers√£o nos conv√©m. Vamos resumir e otimizar agora. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de tudo, queremos ter um controle flex√≠vel sobre os erros de convers√£o. N√£o queremos vincular os par√¢metros de convers√£o a um intervalo de tempo de 1 hora. Que seja um intervalo de tempo arbitr√°rio: </font></font><br><br> <code>tsc_ticks = modulus * number_of_moduli_periods + tsc_ticks_remainder</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais uma vez, lembre-se de como converter o restante em nanossegundos: </font></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * factor / tsc_per_nsec) / factor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculamos os par√¢metros de convers√£o (sabemos disso </font></font><code>tsc_ticks_remainder &lt; modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br><br> <code>modulus * (factor / tsc_per_nsec) &lt;= UINT64_MAX <br> factor &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br> 2 ^ shift &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por uma quest√£o de t√©dio, deve-se notar que a √∫ltima desigualdade n√£o √© equivalente √† primeira na estrutura da aritm√©tica inteira. Mas n√£o vou insistir nisso por muito tempo. S√≥ posso dizer que a √∫ltima desigualdade √© mais grave que a primeira e, portanto, segura de usar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de obtermos a √∫ltima desigualdade </font></font><code>shift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, calculamos: </font><font style="vertical-align: inherit;">E ent√£o esses par√¢metros s√£o usados ‚Äã‚Äãpara converter o restante em nanossegundos: </font><font style="vertical-align: inherit;">Ent√£o, </font><font style="vertical-align: inherit;">calculamos </font><font style="vertical-align: inherit;">a convers√£o restante. O pr√≥ximo problema a ser resolvido - √© a remo√ß√£o de </font><font style="vertical-align: inherit;">e </font><font style="vertical-align: inherit;">partir </font><font style="vertical-align: inherit;">. Como sempre, queremos fazer isso r√°pido. Como sempre, n√£o queremos usar a divis√£o. Portanto, simplesmente escolhemos </font><font style="vertical-align: inherit;">igual ao poder de dois: </font><font style="vertical-align: inherit;">Ent√£o: </font><font style="vertical-align: inherit;">Excelente. Agora sabemos como extrair de</font></font><br><br> <code>factor = 2 ^ shift <br> mult = factor / tsc_per_nsec <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br> <code>ns_per_remainder = (tsc_ticks_remainder * mult) &gt;&gt; shift <br></code> <br><br><font style="vertical-align: inherit;"></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"></font><code>number_of_moduli_periods</code><font style="vertical-align: inherit;"></font><code>tsc_ticks</code><font style="vertical-align: inherit;"></font><code>modulus</code><font style="vertical-align: inherit;"></font><br><br> <code>modulus = 2 ^ remainder_bit_length</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length <br> tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> <br> <br><font style="vertical-align: inherit;"></font><code>tsc_ticks</code> <code>number_of_moduli_periods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">E sabemos como converter </font></font><code>tsc_ticks_remainder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em nanossegundos. </font><font style="vertical-align: inherit;">Resta entender como converter essa parte dos ticks, que √© um m√∫ltiplo, em nanossegundos </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas tudo √© simples: </font></font><br><br> <code>ns_per_moduli = ns_per_modulus * number_of_moduli_periods</code> <br> <br> <code>ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voc√™ pode calcular antecipadamente. </font><font style="vertical-align: inherit;">Al√©m disso, de acordo com a mesma f√≥rmula pela qual convertemos o restante. </font><font style="vertical-align: inherit;">Essa f√≥rmula pode ser usada por per√≠odos que n√£o excedam </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ele mesmo </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √© claro, n√£o mais do que isso </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <code>ns_per_modulus = (modulus * mult) &gt;&gt; shift</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso √© tudo! </font><font style="vertical-align: inherit;">Conseguimos calcular todos os par√¢metros necess√°rios para converter ticks em nanossegundos em tempo real. </font><font style="vertical-align: inherit;">Agora, resuma brevemente o procedimento de convers√£o:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√≥s temos </font></font><code>tsc_ticks</code> </li><li> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length</code> </li> <li> <code>tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> </li> <li> <code>ns = ns_per_modulus * number_of_moduli_periods + (tsc_ticks_remainder * mult) &gt;&gt; shift</code> </li> </ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste procedimento, par√¢metros </font></font><code>remainder_bit_length</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>modulus, ns_per_modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>shift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avan√ßo precalculation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ ainda est√° lendo este post, voc√™ √© √≥timo ou √≥timo. </font><font style="vertical-align: inherit;">√â at√© poss√≠vel que voc√™ seja um analista de desempenho ou desenvolvedor de software de alto desempenho.</font></font><br><br>  Ent√£o aqui.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acontece que ainda n√£o terminamos :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembra como calculamos o par√¢metro </font></font><code>mult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Foi assim: </font></font><br><br> <code>mult = factor / tsc_per_nsec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pergunta: de onde vem </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√∫mero de ticks em um nanossegundo √© um valor muito pequeno. </font><font style="vertical-align: inherit;">De fato, minha biblioteca √© </font></font><code>tsc_per_nsec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usada em seu </font><font style="vertical-align: inherit;">lugar </font></font><code>(tsc_per_sec / 1000000000)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ou seja: </font></font><br><br> <code>mult = factor * 1000000000 / tsc_per_sec</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E h√° duas perguntas interessantes:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e n√£o </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por exemplo?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Onde conseguir isso </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar com o primeiro. O Fio atualmente usa o n√∫mero de ticks por milissegundo. E h√° problemas com isso. Na m√°quina, os par√¢metros dos quais eu nomeei acima </font></font><code>tsc_per_msec = 2599998</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Enquanto </font></font><code>tsc_per_sec = 2599998971</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se colocarmos esses n√∫meros em uma escala, a propor√ß√£o deles estar√° muito pr√≥xima da unidade: 0,999999626. Mas se usarmos o primeiro, e n√£o o segundo, a cada segundo, teremos um erro de 374 nanossegundos. Portanto - </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso ... Como contar </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso √© feito com base na medi√ß√£o direta: </font><font style="vertical-align: inherit;">‚Äúalgum tempo‚Äù √© um par√¢metro configur√°vel. Pode ser maior, menor ou igual a um segundo. Digamos que seja meio segundo. Suponha ainda que a diferen√ßa real entre </font><font style="vertical-align: inherit;">e </font><font style="vertical-align: inherit;">resultou em 0,6 segundos. Ent√£o </font><font style="vertical-align: inherit;">.</font></font><br><br> <code>start_sytem_time = clock_gettime() <br> start_tsc = WTMLIB_GET_TSC() <br>  -  <br> end_system_time = clock_gettime() <br> end_tsc = WTMLIB_GET_TSC() <br></code> <br><br><font style="vertical-align: inherit;"></font><code>end_system_time</code><font style="vertical-align: inherit;"></font><code>start_system_time</code><font style="vertical-align: inherit;"></font><code>tsc_per_sec = (end_tsc ‚Äì start_tsc) / 0,6</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A biblioteca considera v√°rios valores dessa maneira </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. E ent√£o, usando m√©todos padr√£o, "os limpa" de ru√≠do estat√≠stico e recebe um valor √∫nico </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que pode ser confi√°vel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No diagrama de medi√ß√£o de tempo acima, a ordem das chamadas </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e √© </font><font style="vertical-align: inherit;">importante </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. √â importante </font></font><code>WTMLIB_GET_TSC()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que o mesmo tempo transcorra entre duas chamadas e entre duas chamadas </font></font><code>clock_gettime()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ent√£o ser√° poss√≠vel correlacionar facilmente a hora do sistema com os ticks do TSC. E ent√£o a dispers√£o de valores </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode realmente ser considerada aleat√≥ria. Com esse esquema de medi√ß√£o, os valores </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se desviar√£o do valor m√©dio em qualquer dire√ß√£o com a mesma probabilidade. E ser√° poss√≠vel aplicar m√©todos de filtragem padr√£o a eles.</font></font><br><br><h3>  Conclus√£o </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Talvez seja s√≥ isso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas o t√≥pico da medi√ß√£o efetiva do tempo n√£o se limita a isso. </font><font style="vertical-align: inherit;">Existem muitas nuances. </font><font style="vertical-align: inherit;">Para os interessados, proponho trabalhar de forma independente nos seguintes assuntos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> armazenamento de par√¢metros de convers√£o em cache ou - melhor ainda - em registros </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at√© que limites podem ser reduzidos </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(aumentando assim a precis√£o da convers√£o)?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como vimos, a precis√£o da convers√£o √© afetada n√£o apenas </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas tamb√©m pelo tamanho do intervalo de tempo, que se correlaciona com os ticks ( </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Como equilibrar a influ√™ncia de ambos os fatores?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TSC na m√°quina virtual. </font><font style="vertical-align: inherit;">Posso usar?</font></font></li><li>        . , fio        timespec.    : <br><br> <code>tp-&gt;tv_sec = nsecs / 1000000000ULL;</code> <br> <br> ,   TSC          .         ,  ,      <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os m√©todos discutidos neste artigo permitem medir a escala de tempo de um segundo com uma precis√£o da ordem de v√°rias dezenas de nanossegundos. </font><font style="vertical-align: inherit;">Essa √© a precis√£o que eu realmente observo ao usar minha biblioteca. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curiosamente, o fio, do qual emprestei alguns m√©todos, perde exatamente 700-900 nanossegundos em uma segunda escala (e h√° tr√™s raz√µes para isso). </font><font style="vertical-align: inherit;">Al√©m disso, perde na velocidade de convers√£o devido ao armazenamento de tempo em um formato Linux padr√£o. </font><font style="vertical-align: inherit;">No entanto, apresso-me a tranquilizar os f√£s do fio. </font><font style="vertical-align: inherit;">Enviei aos desenvolvedores uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descri√ß√£o de todos os problemas de convers√£o que descobri</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">As pessoas j√° est√£o trabalhando, elas ir√£o corrigi-lo em breve. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desejo-lhe muitos agrad√°veis ‚Äã‚Äãnanossegundos!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425237/">https://habr.com/ru/post/pt425237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425227/index.html">Os pesquisadores descobriram uma maneira de detectar e ignorar as chaves Honeytoken em v√°rios servi√ßos da Amazon.</a></li>
<li><a href="../pt425229/index.html">Como ajudamos a CDN MegaFon.TV a n√£o chegar √† Copa do Mundo de 2018</a></li>
<li><a href="../pt425231/index.html">Perguntas frequentes sobre o trabalho de uma aeromo√ßa</a></li>
<li><a href="../pt425233/index.html">Python 3 no Facebook</a></li>
<li><a href="../pt425235/index.html">Um pouco mais sobre gr√°ficos ou sobre como detectar depend√™ncias entre seus aplicativos</a></li>
<li><a href="../pt425241/index.html">Desenvolvedor 20 anos depois: Vasily Lebedev sobre ICRE, educa√ß√£o, seu livro e programa√ß√£o</a></li>
<li><a href="../pt425243/index.html">O manual de john willis</a></li>
<li><a href="../pt425245/index.html">An√∫ncio do RamblerFront & # 6</a></li>
<li><a href="../pt425247/index.html">Crowdsourcing em testes</a></li>
<li><a href="../pt425249/index.html">Como √© o conhecimento do LLP na ITMO University: o curso "Programa√ß√£o de baixo n√≠vel"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>