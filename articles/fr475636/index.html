<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèø ‚õ≤Ô∏è üëÇüèæ Incr√©menter les √©l√©ments vectoriels üôÖüèª üëºüèº üçÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans quel cas l'incr√©ment des √©l√©ments std :: vector sera-t-il plus rapide - s'ils sont de type uint8_t ou uint32_t ? 

 Afin de ne pas raisonner abst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Incr√©menter les √©l√©ments vectoriels</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/475636/">  Dans quel cas l'incr√©ment des √©l√©ments <i>std :: vector</i> sera-t-il plus rapide - s'ils sont de type <i>uint8_t</i> ou <i>uint32_t</i> ? <br><br>  Afin de ne pas raisonner abstraitement, nous consid√©rons deux impl√©mentations sp√©cifiques: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector8_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector32_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } }</code> </pre> <a name="habracut"></a><br><h2>  Essayons de deviner </h2><br>  Il est facile de r√©pondre √† cette question en utilisant le benchmark, et un peu plus tard nous le ferons, mais d'abord nous essaierons de deviner (cela s'appelle "un raisonnement bas√© sur des principes de base" - cela semble plus scientifique). <br><br>  Tout d‚Äôabord, il vaut la peine de se poser une question: <i>quelle est la taille de ces vecteurs</i> ? <br><br>  Eh bien, choisissons un certain nombre.  Soit 20 000 √©l√©ments dans chacun. <br><br>  De plus, il est connu que nous testerons le processeur Intel Skylake - nous verrons les caract√©ristiques des commandes d'addition pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les</a> op√©randes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8 bits</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">32 bits</a> avec adressage direct.  Il s'av√®re que leurs principaux indicateurs sont les m√™mes: 1 op√©ration par cycle et un retard de 4 cycles par acc√®s m√©moire (1).  Dans ce cas, le retard n'a pas d'importance, car chaque op√©ration d'addition est effectu√©e ind√©pendamment, de sorte que la vitesse calcul√©e est de 1 √©l√©ment par cycle, √† condition que tout le reste du travail sur la boucle soit effectu√© en parall√®le. <br><br>  Vous pouvez √©galement remarquer que 20 000 √©l√©ments correspondent √† un ensemble de donn√©es de 20 Ko pour la version avec <i>uint8_t</i> et jusqu'√† 80 Ko pour la version avec <i>uint32_t</i> .  Dans le premier cas, ils s'int√®grent id√©alement dans le cache de niveau L1 des ordinateurs modernes bas√©s sur x86, et dans le second - pas.  Il s'av√®re que la version 8 bits aura une longueur d'avance gr√¢ce √† une mise en cache efficace? <br><br>  Enfin, nous constatons que notre t√¢che est tr√®s similaire au cas classique de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la vectorisation automatique</a> : dans une boucle avec un nombre connu d'it√©rations, une op√©ration arithm√©tique est effectu√©e sur des √©l√©ments situ√©s s√©quentiellement en m√©moire.  Dans ce cas, la version 8 bits devrait avoir un √©norme avantage sur la version 32 bits, car une op√©ration vectorielle traitera quatre fois plus d'√©l√©ments et, en g√©n√©ral, les processeurs Intel effectuent des op√©rations vectorielles sur des √©l√©ments √† un octet √† la m√™me vitesse que sur 32. √©l√©ments de bits. <br><br>  D'accord, arr√™tez de pester.  Il est temps de passer au test. <br><br><h2>  Benchmark </h2><br>  J'ai obtenu les timings suivants pour des vecteurs de 20 000 √©l√©ments sur des <i>compilateurs</i> <i>gcc 8</i> et <i>clang 8</i> avec diff√©rents niveaux d'optimisation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l_/6r/k7/l_6rk7tnbeguzjnreatqtggsopg.png"></div><br>  Il s'av√®re que, √† l'exception du niveau <i>-O1</i> , la version avec <i>uint32_t est</i> plus rapide que la version avec <i>uint8_t</i> , et dans certains cas, elle est significative: 5,4 fois sur gcc au niveau <i>-O3</i> et exactement 8 fois sur clang aux deux niveaux, <i>-O2</i> et <i>- O3</i> .  Oui, l'incr√©ment des entiers 32 bits dans <i>std :: vector</i> est jusqu'√† huit fois plus rapide que l'incr√©ment des entiers 8 bits sur le compilateur populaire avec des param√®tres d'optimisation standard. <br><br>  Comme d'habitude, tournons-nous vers la liste des assembleurs dans l'espoir qu'elle √©clairera ce qui se passe. <br><br>  Voici une liste pour gcc 8 au niveau <i>-O2</i> , o√π la version 8 bits est "seulement" 1,5 fois plus lente que la version 32 bits (2): <br><br>  <b>8 bits:</b> <br><br><pre> <code class="cpp hljs">.L3: inc BYTE PTR [rdx+rax] mov rdx, QWORD PTR [rdi] inc rax mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] sub rcx, rdx cmp rax, rcx jb .L3</code> </pre> <br>  <b>32 bits:</b> <br><pre> <code class="cpp hljs">.L9: inc DWORD PTR [rax] add rax, <span class="hljs-number"><span class="hljs-number">4</span></span> cmp rax, rdx jne .L9</code> </pre> <br>  La version 32 bits ressemble exactement √† ce que nous attendions d'une boucle non d√©velopp√©e (3): un incr√©ment (4) avec une adresse, puis trois commandes de contr√¥le de boucle: <i>ajouter rax</i> , <i>4 - un</i> incr√©ment de la variable inductive (5) et quelques commandes <i>cmp</i> et <i>jne</i> pour v√©rifier les conditions de sortie de la boucle et de saut conditionnel dessus  Tout a l'air g√©nial - le d√©ploiement compenserait le co√ªt de l'incr√©mentation du compteur et de la v√©rification de la condition, et notre code atteindrait presque la vitesse maximale possible de 1 √©l√©ment par cycle d'horloge (6), mais pour une application open source, cela suffira.  Et qu'en est-il de la version 8 bits?  En plus de la commande <i>inc</i> avec l'adresse, deux commandes suppl√©mentaires pour lire dans la m√©moire sont ex√©cut√©es, ainsi que la <i>sous-</i> commande, qui est prise de nulle part. <br><br>  Voici une liste avec des commentaires: <br><br>  <b>8 bits:</b> <br><br><pre> <code class="cpp hljs">.L3: inc BYTE PTR [rdx+rax] ;    v[i] mov rdx, QWORD PTR [rdi] ;  v.begin inc rax ; i++ mov rcx, QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>] ;  v.end sub rcx, rdx ; end - start (.. <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>.size()) cmp rax, rcx ; i &lt; size() jb .L3 ; .   i &lt; size()</code> </pre> <br>  Ici <i>vector :: begin</i> et <i>vector :: end</i> sont les pointeurs internes de <i>std :: vector</i> , qu'il utilise pour indiquer le d√©but et la fin de la s√©quence d'√©l√©ments contenus dans la zone s√©lectionn√©e pour lui (7), ce sont essentiellement les m√™mes valeurs qui sont utilis√©s pour impl√©menter <i>vector :: begin ()</i> et <i>vector :: end ()</i> (bien qu'ils soient d'un type diff√©rent).  Il s'av√®re que toutes les commandes suppl√©mentaires ne sont qu'une cons√©quence du calcul de <i>vector.size ()</i> .  Cela ne semble pas inhabituel?  Mais apr√®s tout, dans la version 32 bits, bien s√ªr, <i>size () est</i> √©galement calcul√©, cependant, ces commandes n'√©taient pas dans cette liste.  Le calcul de <i>size ()</i> ne s'est produit qu'une seule fois - en dehors de la boucle. <br><br>  Alors, quel est le probl√®me?  La r√©ponse courte est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">alias de pointeur</a> .  Je donnerai une r√©ponse d√©taill√©e ci-dessous. <br><br><h2>  R√©ponse d√©taill√©e </h2><br>  Le vecteur <i>v est</i> transmis √† la fonction par r√©f√©rence, qui est en fait un pointeur masqu√©.  Le compilateur doit aller aux membres <i>v :: begin</i> et <i>v :: end du</i> vecteur pour calculer sa taille <i>size ()</i> , et dans notre exemple, <i>size () est</i> calcul√© <i>√†</i> chaque it√©ration.  Mais le compilateur n'est pas oblig√© d'ob√©ir aveugl√©ment au code source: il peut tr√®s bien porter le r√©sultat de l'appel de la fonction <i>size () en</i> dehors de la boucle, mais seulement s'il sait avec certitude que la s√©mantique du programme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne changera pas</a> .  De ce point de vue, le seul endroit probl√©matique dans la boucle est l'incr√©ment <i>v [i] ++</i> .  L'enregistrement a lieu √† une adresse inconnue.  Une telle op√©ration peut-elle changer la valeur de size ()? <br><br>  Si l'enregistrement se produit dans <i>std :: vector &lt;uint32_t&gt;</i> (c'est-√†-dire par le pointeur <i>uint32_t *</i> ), alors non, il ne peut pas modifier la valeur <i>size ()</i> .  L'√©criture dans des objets de type <i>uint32_t</i> ne peut modifier que des objets de type <i>uint32_t</i> , et les pointeurs impliqu√©s dans le calcul de <i>size ()</i> ont un type diff√©rent (8). <br><br>  Cependant, dans le cas de <i>uint8_t</i> , au moins sur les compilateurs populaires (9), la r√©ponse sera la suivante: oui, th√©oriquement, la valeur de <b><i>size ()</i></b> <b>peut changer</b> , car <i>uint8_t</i> est un alias pour le caract√®re <i>non sign√©</i> , et les tableaux du type <i>char non sign√©</i> (et <i>char</i> ) peuvent <i>Alias ‚Äã‚Äãavec tout autre type</i> .  Cela signifie que, selon le compilateur, l'√©criture sur des <i>pointeurs uint8_t</i> peut modifier le contenu de la m√©moire d'origine inconnue √† n'importe quelle adresse (10).  Par cons√©quent, il suppose que chaque op√©ration d'incr√©mentation <i>v [i] ++</i> peut modifier la valeur <i>size ()</i> et est donc oblig√© de la recalculer √† chaque it√©ration de la boucle. <br><br>  Nous savons tous que l'√©criture dans la m√©moire point√©e par <i>std :: vector</i> ne changera jamais sa propre <i>taille ()</i> , car cela signifierait que le vecteur lui-m√™me a √©t√© en quelque sorte allou√© dans son propre tas, et c'est pratiquement impossible et s'apparente au probl√®me du poulet et des ≈ìufs (11).  Mais malheureusement, cela n'est pas connu du compilateur! <br><br><h2>  Qu'en est-il du reste des r√©sultats? </h2><br>  Eh bien, nous avons d√©couvert pourquoi la version avec <i>uint8_ est</i> l√©g√®rement plus lente que la version de <i>uint32_t</i> sur gcc au niveau <i>-O2</i> .  Mais pourquoi expliquer l'√©norme diff√©rence - jusqu'√† 8 fois - sur clang ou le m√™me gcc sur <i>-O3</i> ? <br><br>  Tout est simple ici: dans le cas de <i>uint32_t,</i> clang peut effectuer une auto-vectorisation de boucle: <br><br><pre> <code class="cpp hljs">.LBB1_6: ; =&gt;This Inner Loop Header: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi] vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">32</span></span>] vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">64</span></span>] vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">96</span></span>] vpsubd ymm1, ymm1, ymm0 vpsubd ymm2, ymm2, ymm0 vpsubd ymm3, ymm3, ymm0 vpsubd ymm4, ymm4, ymm0 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi], ymm1 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">32</span></span>], ymm2 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">64</span></span>], ymm3 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">96</span></span>], ymm4 vmovdqu ymm1, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">128</span></span>] vmovdqu ymm2, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">160</span></span>] vmovdqu ymm3, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">192</span></span>] vmovdqu ymm4, ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">224</span></span>] vpsubd ymm1, ymm1, ymm0 vpsubd ymm2, ymm2, ymm0 vpsubd ymm3, ymm3, ymm0 vpsubd ymm4, ymm4, ymm0 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">128</span></span>], ymm1 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">160</span></span>], ymm2 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">192</span></span>], ymm3 vmovdqu ymmword ptr [rax + <span class="hljs-number"><span class="hljs-number">4</span></span>*rdi + <span class="hljs-number"><span class="hljs-number">224</span></span>], ymm4 add rdi, <span class="hljs-number"><span class="hljs-number">64</span></span> add rsi, <span class="hljs-number"><span class="hljs-number">2</span></span> jne .LBB1_6</code> </pre> <br>  Le cycle a √©t√© d√©ploy√© 8 fois, et c'est en g√©n√©ral la performance maximale que vous pouvez obtenir: un vecteur (8 √©l√©ments) par cycle d'horloge pour le cache L1 (cela ne fonctionnera plus en raison de la limitation d'une op√©ration d'√©criture par cycle d'horloge (12)). <br><br>  <i>La vectorisation n'est</i> pas effectu√©e pour <i>uint8_t</i> , car elle est g√™n√©e par la n√©cessit√© de calculer <i>size ()</i> pour v√©rifier l'√©tat de la boucle √† chaque it√©ration.  La raison du d√©calage est toujours la m√™me, mais le d√©calage lui-m√™me est beaucoup plus important. <br><br>  Les timings les plus bas sont expliqu√©s par la vectorisation automatique: gcc ne l'applique qu'au niveau <i>-O3</i> , et clang s'applique aux niveaux <i>-O2</i> et <i>-O3</i> par d√©faut.  Le compilateur gcc de niveau -cc g√©n√®re un code l√©g√®rement plus lent que clang car il ne d√©veloppe pas la boucle autovectoris√©e. <br><br><h2>  Corriger la situation </h2><br>  Nous avons d√©couvert quel est le probl√®me - comment pouvons-nous le r√©soudre? <br><br>  Tout d'abord, essayons une fa√ßon qui ne fonctionnera pas, √† savoir, nous allons √©crire un cycle plus idiomatique bas√© sur un it√©rateur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(); i != v.end(); ++i) { (*i)++; }</code> </pre> <br>  Le code que <i>gcc</i> g√©n√®re au niveau <i>-O2</i> sera l√©g√®rement meilleur que l'option avec <i>size ()</i> : <br><br><pre> <code class="cpp hljs">.L17: add BYTE PTR [rax], <span class="hljs-number"><span class="hljs-number">1</span></span> add rax, <span class="hljs-number"><span class="hljs-number">1</span></span> cmp QWORD PTR [rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>], rax jne .L17</code> </pre> <br>  Deux op√©rations de lecture suppl√©mentaires sont devenues une, car nous comparons maintenant avec le pointeur de <i>fin</i> du vecteur, plut√¥t que de recalculer <i>size ()</i> , en soustrayant le pointeur de d√©but du vecteur du pointeur de fin.  Par le nombre d'instructions, ce code rattrape <i>uint32_t</i> , car l'op√©ration de lecture suppl√©mentaire a fusionn√© avec l'op√©ration de comparaison.  Cependant, le probl√®me n'a pas disparu et la vectorisation automatique n'est toujours pas disponible, donc <i>uint8_t</i> est toujours nettement derri√®re <i>uint32_t</i> - plus de 5 fois sur gcc et clang aux niveaux o√π la vectorisation automatique est fournie. <br><br>  Essayons autre chose.  Nous ne r√©ussirons pas √† nouveau, ou plut√¥t, nous trouverons <i>une autre</i> m√©thode inop√©rante. <br><br>  Dans cette version, nous calculons <i>size ()</i> une seule fois avant la boucle et mettons le r√©sultat dans une variable locale: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, s = v.size(); i &lt; s; i++) { v[i]++; }</code> </pre> <br>  Cela semble fonctionner?  Le probl√®me √©tait <i>size ()</i> , et maintenant nous avons ordonn√© au compilateur de valider le r√©sultat de <i>size ()</i> dans la variable locale <i>s</i> au d√©but de la boucle, et les variables locales, comme vous le savez, ne se croisent pas avec d'autres donn√©es.  Nous avons fait ce que le compilateur ne pouvait pas faire.  Et le code qu'il va g√©n√©rer sera en fait meilleur (par rapport √† l'original): <br><br><pre> <code class="cpp hljs">.L9: mov rdx, QWORD PTR [rdi] add BYTE PTR [rdx+rax], <span class="hljs-number"><span class="hljs-number">1</span></span> add rax, <span class="hljs-number"><span class="hljs-number">1</span></span> cmp rax, rcx jne .L9</code> </pre> <br>  Il n'y a qu'une seule op√©ration de lecture suppl√©mentaire et aucune <i>sous-</i> commande.  Mais que fait cette commande suppl√©mentaire ( <i>rdx, QWORD PTR [rdi]</i> ) si elle n'est pas impliqu√©e dans le calcul de la taille?  Il lit le pointeur <i>data ()</i> de <i>v</i> ! <br><br>  L'expression <i>v [i]</i> est impl√©ment√©e en tant que <i>* (v.data () + i)</i> , et le membre renvoy√© par <i>data ()</i> (et, en fait, un pointeur de <i>d√©but</i> r√©gulier) pose le m√™me probl√®me que <i>size ()</i> .  Certes, je n'ai pas remarqu√© cette op√©ration dans la version originale, car l√†, elle √©tait "gratuite", car elle devait encore √™tre effectu√©e pour calculer la taille. <br><br>  Ours avec un peu plus, nous avons presque trouv√© une solution.  Il vous suffit de supprimer de notre boucle <i>toutes les</i> d√©pendances sur le contenu de <i>std :: vector</i> .  La fa√ßon la plus simple de le faire est de modifier un peu notre idiome avec un it√©rateur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = v.begin(), e = v.end(); i != e; ++i) { (*i)++; }</code> </pre> <br>  Maintenant, tout a radicalement chang√© (ici, nous comparons uniquement les versions avec <i>uint8_t</i> - dans l'une, nous enregistrons l'it√©rateur <i>final</i> dans une variable locale <i>avant la</i> boucle, dans l'autre - non): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lp/pe/xj/lppexj0vgqumpzvblxctc7xkkoa.png"></div><br>  Ce petit changement nous a donn√© une augmentation de 20 fois la vitesse √† des niveaux avec auto-vectorisation.  De plus, le code avec <i>uint8_t</i> n'a pas seulement rattrap√© le code avec <i>uint32_t</i> - il l'a d√©pass√© presque exactement 4 fois par gcc <i>-O3</i> et clang <i>-O2</i> et <i>-O3</i> , comme nous nous y attendions au tout d√©but, en s'appuyant sur la vectorisation: au final, exactement quatre fois plus les √©l√©ments peuvent √™tre trait√©s par une op√©ration vectorielle et nous avons besoin de quatre fois moins de bande passante - quel que soit le niveau de cache (13). <br><br>  Si vous avez lu √† cet endroit, alors vous devez vous √™tre exclam√© tout ce temps: <br><br>  <i>Mais qu'en est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>-il de la boucle for avec travers√©e de bande</i></a> introduite en C ++ 11?</i> <br><br>  Je m'empresse de vous faire plaisir: √ßa marche!  En fait, c'est du sucre syntaxique, derri√®re lequel notre version avec un it√©rateur se cache presque sous la m√™me forme, o√π nous avons fix√© le pointeur de <i>fin</i> dans une variable locale avant le d√©but de la boucle.  Sa vitesse est donc la m√™me. <br><br>  Si nous d√©cidions soudainement de revenir aux temps anciens des grottes et d'√©crire une fonction de type C, un tel code fonctionnerait tout aussi bien: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { a[i]++; } }</code> </pre> <br>  Ici, le pointeur vers le tableau <i>a</i> et la <i>taille de</i> la variable sont pass√©s √† la fonction par valeur, ils ne peuvent donc pas √™tre modifi√©s suite √† l'√©criture dans le pointeur <i>a</i> (14) - tout comme les variables locales.  Les performances de ce code sont les m√™mes que celles des options pr√©c√©dentes. <br><br>  Enfin, sur les compilateurs o√π cette option est disponible, vous pouvez d√©clarer un vecteur avec <i>__restrict</i> (15): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector8_inc_restrict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; __restrict v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.size(); i++) { v[i]++; } }</code> </pre> <br>  Le <i>mot cl√© __restrict</i> ne <i>fait</i> pas partie de la norme C ++, mais fait partie de la norme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C depuis C99</a> (en tant que <i>restriction</i> ).  S'il est impl√©ment√© en tant qu'extension C ++ dans le compilateur, il est tr√®s probable qu'il ob√©ira √† la s√©mantique de C. Bien s√ªr, il n'y a pas de liens en C, vous pouvez donc remplacer mentalement le lien vers le vecteur par un pointeur vers le vecteur. <br><br>  Notez que restrict n'a pas de <i>propri√©t√©</i> transitive: l'action du sp√©cificateur <i>__restrict</i> , avec laquelle un lien vers <i>std :: vector est</i> d√©clar√©, s'applique uniquement aux membres du vecteur lui-m√™me, et non √† la r√©gion de tas r√©f√©renc√©e par <i>v.data ()</i> .  Dans notre cas, il n'en faut pas plus, car (comme dans le cas des variables locales) il suffit de convaincre le compilateur que les termes eux-m√™mes, pointant vers le d√©but et la fin du vecteur, ne se croisent avec rien.  La clause sur <i>restrict</i> , cependant, est toujours pertinente, car l'√©criture via <i>v.data ()</i> peut toujours entra√Æner la modification d'autres objets dans votre fonction en raison d'un alias. <br><br><h2>  D√©ception </h2><br>  Nous arrivons ici √† la derni√®re - et tr√®s d√©cevante - conclusion.  Le fait est que toutes les solutions pr√©sent√©es ci-dessus ne s'appliquent qu'√† ce cas sp√©cifique, lorsque le vecteur peut th√©oriquement interf√©rer avec lui-m√™me.  La solution √©tait de sortir de la boucle ou d'isoler le r√©sultat de l'appel de la <i>taille ()</i> ou de la <i>fin () du</i> vecteur, et de <i>ne</i> pas dire au compilateur que l'√©criture dans les donn√©es du vecteur n'affecte pas les autres donn√©es.  Ce code sera difficile √† mettre √† l'√©chelle √† mesure que la fonction se d√©veloppera. <br><br>  Le probl√®me d'aliasing n'a pas disparu, et les commandes d'√©criture peuvent toujours obtenir "n'importe o√π" - il n'y a tout simplement pas d'autres donn√©es dans cette fonction qui peuvent √™tre affect√©es ... pour l'instant.  D√®s qu'un nouveau code y appara√Ætra, tout sera r√©p√©t√©.  Voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple au pied lev√©</a> .  Si vous √©crivez dans des tableaux d'√©l√©ments de type <i>uint8_t</i> en petites boucles, vous devez vous battre avec le compilateur jusqu'√† la fin (16). <br><br><h2>  Commentaires </h2><br>  Je serai heureux de toute r√©troaction.  Je n'ai pas encore de syst√®me de commentaires (17), donc, comme d'habitude, nous allons discuter dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce fil sur HackerNews</a> . <br><br><ol><li>  En acc√©dant √† la m√©moire ici, il est entendu que la cha√Æne de d√©pendances passe par la m√©moire: les commandes d'√©criture √† la m√™me adresse doivent lire la derni√®re valeur qui y est √©crite, donc ces op√©rations sont d√©pendantes (en pratique, la redirection pour le chargement (STLF) sera utilis√©e si l'enregistrement est suffisant souvent).  Les d√©pendances de la commande <i>add</i> lors de l'acc√®s √† la m√©moire peuvent se produire par d'autres moyens, par exemple en calculant l'adresse, mais dans notre cas, cela n'est pas pertinent. </li><li>  Seul un petit cycle est illustr√© ici;  Le code d'installation est simple et fonctionne rapidement.  Pour voir la liste compl√®te, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t√©l√©chargez le code sur godbolt</a> . </li><li>  Peut-√™tre devrait-on l'appeler simplement ¬´minimis√©¬ª?  Quoi qu'il en soit, le compilateur gcc ne fait g√©n√©ralement pas de boucle, m√™me aux niveaux <i>-O2</i> et <i>-O3</i> , sauf dans des cas sp√©ciaux o√π le nombre d'it√©rations est petit et <i>connu au stade de la compilation</i> .  Pour cette raison, gcc affiche des r√©sultats de test inf√©rieurs √† ceux de clang, mais il √©conomise beaucoup sur la taille du code.  Vous pouvez <i>forcer gcc √† d√©rouler des boucles en</i> appliquant une optimisation de profil ou en <i>activant</i> l' <i>indicateur -funroll-loops</i> . </li><li>  En fait, la commande <i>inc DWORD PTR [rax]</i> dans gcc est une optimisation manqu√©e: il est presque toujours pr√©f√©rable d'utiliser la commande <i>add [rax], 1</i> , car elle ne comprend que 2 micro-op√©rations combin√©es contre 3 pour <i>inc</i> .  Dans ce cas, la diff√©rence n'est que d'environ 6%, mais si le cycle √©tait l√©g√®rement √©largi pour que seule l'op√©ration d'enregistrement soit r√©p√©t√©e, la diff√©rence serait plus importante (une nouvelle expansion ne jouerait plus de r√¥le, puisque nous atteindrions la limite de 1 op√©ration d'enregistrement par cycle, qui ne d√©pend pas du nombre total de micro-op√©rations). </li><li>  J'appelle cette variable <i>inductive</i> , et pas seulement <i>i</i> , comme dans le code source, car le compilateur a converti les op√©rations unitaires de l'incr√©ment <i>i en</i> incr√©ments de 4 octets du pointeur stock√© dans le registre <i>rax</i> , et corrig√© en cons√©quence la condition de boucle.  Dans sa forme originale, notre boucle adresse les √©l√©ments du vecteur, et apr√®s cette conversion, elle incr√©mente le pointeur / it√©rateur, ce qui est un moyen de <i>r√©duire le co√ªt des op√©rations</i> . </li><li>  En fait, si vous activez <i>-funroll-loops</i> , sur gcc, la vitesse sera de 1,08 mesure par √©l√©ment avec un <i>d√©ploiement 8x</i> .  Mais m√™me avec ce drapeau, il <i>ne</i> prolongera <i>pas</i> la boucle pour la version avec des √©l√©ments 8 bits, donc le d√©calage de vitesse sera encore plus perceptible! </li><li>  Ces membres ont un modificateur <i>priv√©</i> , et leurs noms d√©pendent de l'impl√©mentation, mais dans stdlibc ++, ils ne sont pas vraiment appel√©s <i>d√©but</i> et <i>fin</i> , comme dans gcc.  Ils sont appel√©s <i>_Vector_base :: _ Vector_impl :: _ M_start</i> et <i>_Vector_base :: _ Vector_impl :: _ M_finish respectivement</i> , c'est-√†-dire  entrez la structure <i>_Vector_impl</i> , qui est membre de <i>_M_impl</i> (et la seule) de la classe <i>_Vector_base</i> , et qui, √† son tour, est la classe de base pour <i>std :: vector</i> .  Eh bien!  Heureusement, le compilateur g√®re facilement cette pile d'abstractions. </li><li>  La norme ne prescrit pas quels devraient √™tre les types internes de membres <i>std :: vector</i> , mais dans la biblioth√®que libstdc ++, ils sont simplement d√©finis comme <i>Alloc :: pointer</i> (o√π <i>Alloc</i> est l'allocateur du vecteur), et pour l' <i>objet std :: allocation</i> par d√©faut, ils seront simplement pointeurs de type <i>T *</i> , c'est-√†-dire  pointeurs r√©guliers vers un objet - dans ce cas <i>uint32_t *</i> . </li><li>  Je fais cette r√©servation pour une raison.  On soup√ßonne que <i>uint8_t</i> peut √™tre consid√©r√© comme un type autre que <i>char</i> , <i>char sign√©</i> et <i>char non sign√©</i> .  √âtant donn√© que l'aliasing fonctionne avec les <i>types de caract√®res</i> , cela ne s'applique pas en principe √† <i>uint8_t</i> et devrait se comporter comme tout autre type sans caract√®re.  Cependant, aucun des compilateurs que je connais ne le pense: dans tous, <i>typedef</i> <i>uint8_t</i> est un alias de caract√®re <i>non sign√©</i> , de sorte que les compilateurs ne voient pas la diff√©rence entre eux, m√™me s'ils souhaitent l'utiliser. </li><li>  Par "origine inconnue", je veux dire ici seulement que le compilateur ne sait pas o√π le contenu de la m√©moire pointe ni comment il est apparu.  Cela inclut des pointeurs arbitraires transmis √† la fonction, ainsi que des variables globales et statiques.  , ,            ,  ,   ,     (    -     ). ,     <i>malloc</i>  <i>new</i> ,   <i></i>    ,      ,   ,        :  ,      ,       . ,       <i>malloc</i>  <i>new</i> . </li><li>  ,   <i>std::vector</i>  - <i></i> ? ,    <i>std::vector&lt;uint8_t&gt; a</i>     <i></i>  <i>a.data()</i>    <i>placement new</i>       <i>b</i> .   <i>std::swap(a, b)</i> ,       ‚Äì ,  <i>b</i>      ?       ,     <i>b</i> .       :          -  (,       ),      ,       . </li><li>        8 , ..  32 .     ,   <i>std::vector</i>      . </li><li> -        4 :     ,        ,   ‚Äì .       : 8-      L1,  32-        ‚Äì   L2    ,      . </li><li>        ,  ‚Äì  :        .      ,      ,    ¬´¬ª. </li><li>        <i>v[i]</i> ,           . </li><li>     . ,   ¬´¬ª ,          <i>uint8_t</i> .      , ,       ,  <i>uint8_t</i> ,          . ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   clang,      gcc</a> ,     ,    <i>uint8_t</i> . -     <i>gcc</i>          ,   .     ,     , -     <i>__restrict</i> . </li><li>  -  ,       ,      (   Disqus),           (        ),    . </li></ol><br> <i>     .  : Travis Downs. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Incrementing vectors</a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr475636/">https://habr.com/ru/post/fr475636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr475618/index.html">Comment √©crire un contrat Python intelligent sur le r√©seau Ontology. Partie 2: API de stockage</a></li>
<li><a href="../fr475622/index.html">Extension d'UObject dans Unreal Engine 4</a></li>
<li><a href="../fr475624/index.html">PHP-Watcher: un outil qui simplifie le d√©veloppement d'applications √† longue dur√©e de vie</a></li>
<li><a href="../fr475626/index.html">Les autotests peuvent-ils remplacer une personne √† la recherche de vuln√©rabilit√©s: entretien avec Alexandra Svatikova</a></li>
<li><a href="../fr475630/index.html">Knative - une plate-forme bas√©e sur k8s en tant que service avec prise en charge sans serveur</a></li>
<li><a href="../fr475640/index.html">Si vous cr√©ez quelque chose, √©vitez le calendrier du responsable.</a></li>
<li><a href="../fr475642/index.html">M√©canisme de tas uniquement de tuples dans PostgreSQL</a></li>
<li><a href="../fr475646/index.html">Yuri Ryabtsev: ¬´La premi√®re interception d'un missile balistique est un √©v√©nement √† peu pr√®s √©gal au vol de Gagarine¬ª</a></li>
<li><a href="../fr475652/index.html">Comment nous avons d√©velopp√© une application mobile sur l'OS Aurora (Sailfish Mobile OS RUS)</a></li>
<li><a href="../fr475654/index.html">¬´Le premier mois, trois hommes en bonne sant√© avaient peur d'allumer la turbine¬ª - comment Alexei Statsenko construit un jetpack √† partir de z√©ro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>