<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏾 🛍️ 👍🏻 Flightradar24 - comment ça marche? Partie 2, protocole ADS-B 👨🏾‍🏭 👪 👨‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je vais deviner et dire que tous ceux dont les amis ou la famille ont déjà pris l'avion ont utilisé Flightradar24 - un service gratuit et pratique pou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Flightradar24 - comment ça marche? Partie 2, protocole ADS-B</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447078/">  Je vais deviner et dire que tous ceux dont les amis ou la famille ont déjà pris l'avion ont utilisé Flightradar24 - un service gratuit et pratique pour suivre les vols en temps réel. <br><br><img src="https://habrastorage.org/webt/xg/eo/t-/xgeot-h18b94ucc-fiuc46iotvm.jpeg" alt="image"><br><br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première partie,</a> les idées de fonctionnement de base ont été décrites.  Allons maintenant plus loin et découvrons quelles données transmettent et reçoivent exactement entre l'avion et une station au sol.  Nous allons également décoder ces données en utilisant Python. <br><a name="habracut"></a><br><h2>  L'histoire </h2><br>  Il devrait être évident que les données des avions ne sont pas destinées uniquement aux utilisateurs, qui souhaitent les voir sur leurs smartphones.  Ce système est appelé ADS-B (surveillance dépendante automatique - diffusion) et a été conçu pour la transmission automatique des données d'informations de l'avion au centre de contrôle - différents paramètres, tels que les coordonnées, la vitesse, le cap, l'altitude et d'autres, sont envoyés.  Auparavant, le répartiteur ne pouvait voir qu'un point sur l'écran radar.  Et cela est devenu définitivement insuffisant lorsque le nombre d'avions a considérablement augmenté. <br><br>  Techniquement, l'ADS-B se compose d'un émetteur à l'intérieur de l'avion, qui envoie périodiquement des trames de données d'information à une fréquence relativement élevée de 1090 MHz (il existe d'autres modes, mais ils ne nous intéressent pas tellement, car les coordonnées ne sont transmises qu'ici) )  Bien sûr, il y a aussi un récepteur quelque part à l'aéroport, mais pour nous, comme pour les utilisateurs, notre propre récepteur est plus intéressant. <br><br>  À titre de comparaison, le premier système de ce type conçu pour les utilisateurs ordinaires, l'Airnav Radarbox, est apparu en 2007 et coûte environ 900 $, et environ 250 $ par an coûte un abonnement à leurs services réseau (l'idée principale de ce système est de collecter et partager les données de <i>nombreux récepteurs</i> , un récepteur autonome est relativement inutile). <br><br><img src="https://habrastorage.org/webt/74/dt/np/74dtnpj6jdit1zlt_cr37rq4mju.png"><br><br>  Maintenant, lorsque les récepteurs RTL-SDR sont devenus beaucoup plus disponibles, un appareil similaire peut être fabriqué pour 30 $.  Il se trouve dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première partie de l'article</a> , et nous irons plus loin et décrirons le protocole lui-même - voyons comment cela fonctionne. <br><br><h2>  Recevoir un signal </h2><br>  Tout d'abord, nous devons enregistrer un échantillon de signal.  L'ensemble du signal n'a qu'une longueur de 120 microsecondes, et pour voir ses détails dans une bonne "résolution", il est préférable d'avoir une radio SDR avec une fréquence d'échantillonnage d'au moins 5 MHz. <br><br><img src="https://habrastorage.org/webt/mu/ig/uj/muigujxudctclwalfdxl5tzzdam.png" alt="image"><br><br>  Après l'enregistrement, nous obtenons un fichier WAV avec un taux d'échantillonnage de 5 000 000 d'échantillons / s, 30 secondes d'un tel enregistrement ont une taille d'environ 500 Mo.  Bien sûr, il est inutile de l'écouter avec votre lecteur multimédia préféré - le fichier ne contient pas de son, mais un signal radio directement numérisé lui-même - c'est exactement ainsi que fonctionne la radio définie par logiciel. <br><br>  Nous pouvons ouvrir et traiter ce fichier avec Python.  Ceux qui souhaitent faire l'expérience par eux-mêmes peuvent télécharger un échantillon à partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce lien</a> . <br><br>  Permet d'ouvrir un fichier et de voir ce qu'il contient. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np fs, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"adsb_20190311_191728Z_1090000kHz_RF.wav"</span></span>) data = data.astype(float) I, Q = data[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], data[:, <span class="hljs-number"><span class="hljs-number">1</span></span>] A = np.sqrt(I*I + Q*Q) plt.plot(A) plt.show()</code> </pre> <br>  Résultat: on voit des «impulsions» sur le bruit. <br><br><img src="https://habrastorage.org/webt/ko/v5/ra/kov5rakmt1sysd7yncso6372l70.png"><br><br>  Chaque "impulsion" est un signal, dont la structure est clairement visible si l'on augmente la résolution sur le graphique. <br><br><img src="https://habrastorage.org/webt/7l/oa/y-/7loay-b4xf16kyy--ik_j4rhh4q.png"><br><br>  Comme nous pouvons le voir, l'image est entièrement cohérente avec sa description ci-dessus.  Nous pouvons maintenant traiter ces données. <br><br><h2>  Décodage </h2><br>  Tout d'abord, nous devons avoir un flux de bits.  Le signal lui-même est codé avec un codage manchester: <br><br><img src="https://habrastorage.org/webt/rh/k3/is/rhk3iskt0btt5s9okaekkaox3w8.png"><br><br>  Grâce aux différences de demi-bouchée, nous pouvons facilement obtenir de vrais «0» et «1». <br><br><pre> <code class="python hljs"> bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>): pos = start_data + bit_len*p p1, p2 = A[pos: pos + bit_len/<span class="hljs-number"><span class="hljs-number">2</span></span>], A[pos + bit_len/<span class="hljs-number"><span class="hljs-number">2</span></span>: pos + bit_len] avg1, avg2 = np.average(p1), np.average(p2) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg1 &lt; avg2: bits_str += <span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> avg1 &gt; avg2: bits_str += <span class="hljs-string"><span class="hljs-string">"1"</span></span></code> </pre><br>  La structure du signal lui-même ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/cl/_7/ng/cl_7ngs5clpg97zrplnolcajpcq.png"><br><br>  Permet de voir les champs plus en détail. <br><br>  <b>DF</b> (Downlink Format, 5 bits) - définit le type de message.  Il en existe plusieurs types: <br><br><img src="https://habrastorage.org/webt/li/no/dt/linodtcxx6jtskav1aqar14odew.png"><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source de la page</a> ) <br><br>  Nous ne sommes intéressés que par le type DF17, car seul celui-ci contient les coordonnées de l'avion. <br><br>  <b>OACI</b> (24 bits) - est un code d'avion international unique.  Nous pouvons vérifier l'avion par son code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur ce site</a> (malheureusement, l'auteur a cessé de mettre à jour la base de données, mais elle est toujours pertinente).  Par exemple, pour le code 3c5ee2, nous pouvons avoir les informations suivantes: <br><br><img src="https://habrastorage.org/webt/i6/gt/8s/i6gt8sgm9n7zv1u7nspnzsitpk4.png"><br><br>  <b>DONNÉES</b> (56 ou 112 bits) - sont les données elles-mêmes, que nous allons décoder.  Les 5 premiers bits de données sont le champ <b>Code de type</b> , qui contient le sous-type des données stockées (à ne pas mélanger avec le champ <i>DF</i> ).  Il existe de nombreux types de ce type: <br><br><img src="https://habrastorage.org/webt/5v/h1/3h/5vh13htes6_pyungnbzkucvqlji.png"><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source du tableau</a> ) <br><br>  Regardons quelques exemples. <br><br>  <b>Identification de l'aéronef</b> <br><br>  Un exemple sous forme binaire: <br><br>  00100 011 000101 010111 000111 110111 110001 111000 <br><br>  Champs de données: <br><br><pre> <code class="python hljs">+------+------+------+------+------+------+------+------+------+------+ | TC,<span class="hljs-number"><span class="hljs-number">5</span></span> | EC,<span class="hljs-number"><span class="hljs-number">3</span></span> | C1,<span class="hljs-number"><span class="hljs-number">6</span></span> | C2,<span class="hljs-number"><span class="hljs-number">6</span></span> | C3,<span class="hljs-number"><span class="hljs-number">6</span></span> | C4,<span class="hljs-number"><span class="hljs-number">6</span></span> | C5,<span class="hljs-number"><span class="hljs-number">6</span></span> | C6,<span class="hljs-number"><span class="hljs-number">6</span></span> | C7,<span class="hljs-number"><span class="hljs-number">6</span></span> | C8,<span class="hljs-number"><span class="hljs-number">6</span></span> | +------+------+------+------+------+------+------+------+------+------+</code> </pre><br>  TC = 00100b = 4, et chaque symbole C1-C8 contient des codes, qui doivent correspondre aux index de cette chaîne: <br>  #ABCDEFGHIJKLMNOPQRSTUVWXYZ ##### _ ################# 0123456789 ###### <br><br>  Après avoir décodé, il est facile d'obtenir le nom de l'avion: EWG7184 <br><br><pre> <code class="python hljs">symbols = <span class="hljs-string"><span class="hljs-string">"#ABCDEFGHIJKLMNOPQRSTUVWXYZ#####_###############0123456789######"</span></span> code_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>): c = int(bits_str[<span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">6</span></span>*p:<span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">6</span></span>*(p + <span class="hljs-number"><span class="hljs-number">1</span></span>)], <span class="hljs-number"><span class="hljs-number">2</span></span>) code_str += symbols[c] print(<span class="hljs-string"><span class="hljs-string">"Aircraft Identification:"</span></span>, code_str.replace(<span class="hljs-string"><span class="hljs-string">'#'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>))</code> </pre><br>  <b>Position aéroportée</b> <br><br>  Le décodage du nom était simple, mais les coordonnées sont plus compliquées.  Ils sont transmis sous forme de 2 trames, paires et impaires.  Le code de champ TC = 01011b = 11. <br><br><img src="https://habrastorage.org/webt/3i/8h/oj/3i8hojmkecmc0xlnfhkwvf7svk8.png"><br><br>  Exemple de trames de données paires et impaires: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">01011</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span> <span class="hljs-number"><span class="hljs-number">000101110110</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10111000111001000</span></span> <span class="hljs-number"><span class="hljs-number">10000110101111001</span></span> <span class="hljs-number"><span class="hljs-number">01011</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span> <span class="hljs-number"><span class="hljs-number">000110010000</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">10010011110000110</span></span> <span class="hljs-number"><span class="hljs-number">10000011110001000</span></span></code> </pre><br>  Le calcul des coordonnées lui-même utilise une formule un peu délicate: <br><br><img src="https://habrastorage.org/webt/3i/uf/m0/3iufm0e0758rzbjmxmkazgifsqq.png"><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source</a> ) <br><br>  Je ne suis pas un expert en SIG, donc je ne sais pas d'où il vient.  Qui le sait mieux, veuillez écrire dans les commentaires. <br><br>  Le calcul de l'altitude est plus simple - en fonction d'un bit spécifique, il peut être représenté comme un multiple de 25 ou 100 pieds. <br><br>  <b>Vitesse aéroportée</b> <br><br>  Dataframe avec TC = 19. Ce qui est intéressant ici, c'est que la vitesse peut être relative au sol (plus précise, appelée Ground Speed) et à la vitesse, mesurée par le capteur d'air de l'avion (peut être moins précise à cause du vent).  De nombreux autres domaines différents sont également transmis: <br><br><img src="https://habrastorage.org/webt/hh/yr/bn/hhyrbnk8nh7qauorxuohetys5fi.png"><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source</a> ) <br><br><h2>  Conclusion </h2><br>  Comme nous pouvons le voir, la technologie ADS-B est devenue une symbiose intéressante, lorsqu'un standard est largement utilisable non seulement pour les professionnels, mais aussi pour les utilisateurs ordinaires.  Mais définitivement, le rôle clé dans cela a été fait par la réduction du coût de la technologie des récepteurs SDR numériques, qui permet de recevoir des signaux avec une fréquence supérieure à gigahertz sur un appareil très bon marché. <br><br>  La norme elle-même, bien sûr, contient beaucoup plus de données.  Les personnes intéressées peuvent consulter le PDF sur la page <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OACI</a> ou visiter le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site Web mode-s.org</a> déjà mentionné ci-dessus.  Il est peu probable que cet article soit réellement utilisé par la plupart des lecteurs, mais j'espère qu'au moins l'idée générale de son fonctionnement est désormais plus claire. <br><br>  Par ailleurs, le décodeur ADS-B Python existe déjà, il peut être étudié <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le github</a> .  Les propriétaires de récepteurs SDR peuvent également créer et exécuter un décodeur ADS-B prêt à l'emploi à <a href="">partir de cette page</a> , et (je le répète) quelques détails que nous avons également dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la première partie</a> de cet article. <br><br>  Le code source de l'analyseur, décrit ci-dessus, est donné sous le spoiler.  Ce n'est qu'un exemple de test qui ne prétend pas à la qualité de la production, mais en général cela fonctionne, et il peut analyser le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichier WAV</a> , enregistré ci-dessus. <br><br><div class="spoiler">  <b class="spoiler_title">Code source (Python)</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> signal <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, start, bit_len)</span></span></span><span class="hljs-function">:</span></span> max_len = bit_len*<span class="hljs-number"><span class="hljs-number">128</span></span> A = data[start:start + max_len] A = signal.resample(A, <span class="hljs-number"><span class="hljs-number">10</span></span>*max_len) bits = np.zeros(<span class="hljs-number"><span class="hljs-number">10</span></span>*max_len) bit_len *= <span class="hljs-number"><span class="hljs-number">10</span></span> start_data = bit_len*<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment"># Parse first 8 bits bits_str = "" for p in range(8): pos = start_data + bit_len*p p1, p2 = A[pos: pos + bit_len/2], A[pos + bit_len/2: pos + bit_len] avg1, avg2 = np.average(p1), np.average(p2) if avg1 &lt; avg2: bits_str += "0" elif avg1 &gt; avg2: bits_str += "1" df = int(bits_str[0:5], 2) # Aircraft address (db - https://junzis.com/adb/?q=3b1c5c ) bits_str = "" for p in range(8, 32): pos = start_data + bit_len * p p1, p2 = A[pos: pos + bit_len / 2], A[pos + bit_len / 2: pos + bit_len] avg1, avg2 = np.average(p1), np.average(p2) if avg1 &lt; avg2: bits_str += "0" elif avg1 &gt; avg2: bits_str += "1" # print "Aircraft address:", bits_str, hex(int(bits_str, 2)) address = hex(int(bits_str, 2)) # Filter specific aircraft (optional) # if address != "0x3c5ee2": # return if df == 16 or df == 17 or df == 18 or df == 19 or df == 20 or df == 21: # print "Pos:", start, "DF:", msg_type # Data (56bit) bits_str = "" for p in range(32, 88): pos = start_data + bit_len*p p1, p2 = A[pos: pos + bit_len/2], A[pos + bit_len/2: pos + bit_len] avg1, avg2 = np.average(p1), np.average(p2) if avg1 &lt; avg2: bits_str += "0" # bits[pos + bit_len / 2] = 50 elif avg1 &gt; avg2: bits_str += "1" # http://www.lll.lu/~edward/edward/adsb/DecodingADSBposition.html # print "Data:" # print bits_str[:8], bits_str[8:20], bits_str[20:22], bits_str[22:22+17], bits_str[39:39+17] # Type Code: tc, ec = int(bits_str[:5], 2), int(bits_str[5:8], 2) # print("DF:", df, "TC:", tc) # 1 - 4 Aircraft identification # 5 - 8 Surface position # 9 - 18 Airborne position (w/ Baro Altitude) # 19 Airborne velocities if tc &gt;= 1 and tc &lt;= 4: # and (df == 17 or df == 18): print("Aircraft address:", address) print("Data:") print(bits_str[:8], bits_str[8:14], bits_str[14:20], bits_str[20:26], bits_str[26:32], bits_str[32:38], bits_str[38:44]) symbols = "#ABCDEFGHIJKLMNOPQRSTUVWXYZ#####_###############0123456789######" code_str = "" for p in range(8): c = int(bits_str[8 + 6*p:8 + 6*(p + 1)], 2) code_str += symbols[c] print("Aircraft Identification:", code_str.replace('#', '')) print() if tc == 11: print("Aircraft address:", address) print("Data: (11)") print(bits_str[:8], bits_str[8:20], bits_str[20:22], bits_str[22:22+17], bits_str[39:39+17]) # Bit 22 contains the F flag which indicates which CPR format is used (odd or even) # First frame has F flag = 0 so is even and the second frame has F flag = 1 so odd # f = bits_str[21:22] # print("F:", int(f, 2)) # Altitude alt1b = bits_str[8:20] if alt1b[-5] == '1': bits = alt1b[:-5] + alt1b[-4:] n = int(bits, 2) alt_ft = n*25 - 1000 print("Alt (ft)", alt_ft) # lat_dec = int(bits_str[22:22+17], 2) # lon_dec = int(bits_str[39:39+17], 2) # print("Lat/Lon:", lat_dec, lon_dec) # http://airmetar.main.jp/radio/ADS-B%20Decoding%20Guide.pdf print() if tc == 19: print("Aircraft address:", address) print("Data:") # print(bits_str) print(bits_str[:5], bits_str[5:8], bits_str[8:10], bits_str[10:13], bits_str[13] ,bits_str[14:24], bits_str[24], bits_str[25:35], bits_str[35:36], bits_str[36:65]) subtype = int(bits_str[5:8], 2) # https://mode-s.org/decode/adsb/airborne-velocity.html spd, hdg, rocd = -1, -1, -1 if subtype == 1 or subtype == 2: print("Velocity Subtype 1: Ground speed") v_ew_sign = int(bits_str[13], 2) v_ew = int(bits_str[14:24], 2) - 1 # east-west velocity v_ns_sign = int(bits_str[24], 2) v_ns = int(bits_str[25:35], 2) - 1 # north-south velocity v_we = -1*v_ew if v_ew_sign else v_ew v_sn = -1*v_ns if v_ns_sign else v_ns spd = math.sqrt(v_sn*v_sn + v_we*v_we) # unit in kts hdg = math.atan2(v_we, v_sn) hdg = math.degrees(hdg) # convert to degrees hdg = hdg if hdg &gt;= 0 else hdg + 360 # no negative val if subtype == 3: print("Subtype Subtype 3: Airspeed") hdg = int(bits_str[14:24], 2)/1024.0*360.0 spd = int(bits_str[25:35], 2) vr_sign = int(bits_str[36], 2) vr = int(bits_str[36:45], 2) rocd = -1*vr if vr_sign else vr # rate of climb/descend print("Speed (kts):", spd, "Rate:", rocd, "Heading:", hdg) print() # print() def calc_coordinates(): def _cprN(lat, is_odd): nl = _cprNL(lat) - is_odd return nl if nl &gt; 1 else 1 def _cprNL(lat): try: nz = 15 a = 1 - math.cos(math.pi / (2 * nz)) b = math.cos(math.pi / 180.0 * abs(lat)) ** 2 nl = 2 * math.pi / (math.acos(1 - a/b)) return int(math.floor(nl)) except: # happens when latitude is +/-90 degree return 1 def floor_(x): return int(math.floor(x)) lat1b, lon1b, alt1b = "10111000111010011", "10000110111111000", "000101111001" lat2b, lon2b, alt2b = "10010011101011100", "10000011000011011", "000101110111" lat1, lon1, alt1 = int(lat1b, 2), int(lon1b, 2), int(alt1b, 2) lat2, lon2, alt2 = int(lat2b, 2), int(lon2b, 2), int(alt2b, 2) # 131072 is 2^17, since CPR lat and lon are 17 bits each cprlat_even, cprlon_even = lat1/131072.0, lon1/131072.0 cprlat_odd, cprlon_odd = lat2/131072.0, lon2/131072.0 print(cprlat_even, cprlon_even) j = floor_(59*cprlat_even - 60*cprlat_odd) print(j) air_d_lat_even = 360.0 / 60 air_d_lat_odd = 360.0 / 59 # Lat lat_even = float(air_d_lat_even * (j % 60 + cprlat_even)) lat_odd = float(air_d_lat_odd * (j % 59 + cprlat_odd)) if lat_even &gt;= 270: lat_even = lat_even - 360 if lat_odd &gt;= 270: lat_odd = lat_odd - 360 # Lon ni = _cprN(lat_even, 0) m = floor_(cprlon_even * (_cprNL(lat_even)-1) - cprlon_odd * _cprNL(lat_even) + 0.5) lon = (360.0 / ni) * (m % ni + cprlon_even) print("Lat", lat_even, "Lon", lon) # Altitude # Q-bit (bit 48) indicates whether the altitude is encoded in multiples of 25 or 100 ft (0: 100 ft, 1: 25 ft) # The value can represent altitudes from -1000 to +50175 ft. if alt1b[-5] == '1': bits = alt1b[:-5] + alt1b[-4:] n = int(bits, 2) alt_ft = n*25 - 1000 print("Alt (ft)", alt_ft) fs, data = wavfile.read("adsb_20190311_191728Z_1090000kHz_RF.wav") T = 1/fs print("Sample rate %f MS/s" % (fs / 1e6)) print("Cnt samples %d" % len(data)) print("Duration: %fs" % (T * len(data))) data = data.astype(float) cnt = data.shape[0] # Processing only part on file (faster): # cnt = 10000000 # data = data[:cnt] print("Processing I/Q...") I, Q = data[:, 0], data[:, 1] A = np.sqrt(I*I + Q*Q) bits = np.zeros(cnt) # To see scope without any processing, uncomment # plt.plot(A) # plt.show() # sys.exit(0) print("Extracting signals...") pos = 0 avg = 200 msg_start = 0 # Find beginning of each signal while pos &lt; cnt - 16*1024: # P1 - message start while pos &lt; cnt - 16*1024: if A[pos] &lt; avg and A[pos+1] &gt; avg and pos - msg_start &gt; 1000: msg_start = pos bits[pos] = 100 pos += 4 break pos += 1 start1, start2, start3, start4 = msg_start, 0, 0, 0 # P2 while pos &lt; cnt - 16*1024: if A[pos] &lt; avg and A[pos+1] &gt; avg: start2 = pos bits[pos] = 90 pos += 1 break pos += 1 # P3 while pos &lt; cnt - 16*1024: if A[pos] &lt; avg and A[pos+1] &gt; avg: start3 = pos bits[pos] = 80 pos += 1 break pos += 1 # P4 while pos &lt; cnt - 16*1024: if A[pos] &lt; avg and A[pos+1] &gt; avg: start4 = pos bits[pos] = 70 pos += 1 break pos += 1 sig_diff = start4 - start1 if 20 &lt; sig_diff &lt; 25: bits[msg_start] = 500 bit_len = int((start4 - start1) / 4.5) # print(pos, start1, start4, ' - ', bit_len) # start = start1 + 8*bit_len parse_message(A, msg_start, bit_len) pos += 450 # For debugging: check signal start # plt.plot(A) # plt.plot(bits) # plt.show()</span></span></code> </pre><br></div></div><br>  J'espère que cela a été utile, merci d'avoir lu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447078/">https://habr.com/ru/post/fr447078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447068/index.html">Comparer des chaînes similaires</a></li>
<li><a href="../fr447070/index.html">AERODISK ENGINE N2 Tests de crash de stockage, test de résistance</a></li>
<li><a href="../fr447072/index.html">«J'ai tout fait - c'était une histoire drôle»: un podcast sur le marketing de contenu et une carrière dans les médias informatiques</a></li>
<li><a href="../fr447074/index.html">Nous écrivons le premier microservice sur Node.js avec communication via RabbitMQ</a></li>
<li><a href="../fr447076/index.html">Meetup OWASP Russie - Enregistrement des performances</a></li>
<li><a href="../fr447080/index.html">Des réseaux pour les plus petits. Oh partie c'est tout</a></li>
<li><a href="../fr447088/index.html">Planche à pain "Cell"</a></li>
<li><a href="../fr447090/index.html">Contexte: fonctionnement du processus d'intégration continue</a></li>
<li><a href="../fr447092/index.html">Quelle est la portée de cette antenne? Mesurer les performances de l'antenne avec l'OSA103 Mini</a></li>
<li><a href="../fr447094/index.html">Apprentissage automatique pour les gestionnaires: le sacrement de la séparation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>