<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏻 😀 🎠 Cuatro reglas mejoradas para el diseño de software 💢 👨🏿‍🚀 👯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les presento el artículo "Cuatro mejores reglas para el diseño de software" de David Bryant Copeland. David Bryant Copeland es arquitecto d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cuatro reglas mejoradas para el diseño de software</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461823/"><p>  Hola Habr!  Les presento el artículo "Cuatro mejores reglas para el diseño de software" de David Bryant Copeland.  David Bryant Copeland es arquitecto de software y CTO de Stitch Fix.  Mantiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un blog</a> y es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">autor de varios libros</a> . </p><br><p>  Martin Fowler tuiteó recientemente con un enlace a su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicación de blog</a> sobre cuatro reglas de diseño simples de Kent Beck, que creo que pueden mejorarse aún más (y que a veces pueden enviar al programador por el camino equivocado): </p><br><p>  Las reglas de Kent de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programación extrema explicadas</a> : </p><br><ul><li>  Kent dice: "Ejecute todas las pruebas". </li><li>  No duplicar la lógica.  Intente evitar duplicados ocultos, como las jerarquías de clases paralelas. </li><li>  Todas las intenciones importantes para el programador deben ser claramente visibles. </li><li>  El código debe tener el menor número posible de clases y métodos. </li></ul><br><p>  Según mi experiencia, estas reglas no satisfacen las necesidades del diseño de software. <a name="habracut"></a>  Mis cuatro reglas para un sistema bien diseñado pueden ser: </p><br><ul><li>  está bien cubierto por las pruebas y las supera con éxito. </li><li>  no tiene abstracciones que el programa no necesita directamente. </li><li>  ella tiene un comportamiento inequívoco. </li><li>  requiere la menor cantidad de conceptos. </li></ul><br><p>  Para mí, estas reglas se derivan de lo que hacemos con nuestro software. </p><br><h1 id="tak-chto-zhe-my-delaem-s-nashim-po">  Entonces, ¿qué <em>hacemos</em> con nuestro software? </h1><br><p>  No podemos hablar sobre diseño de software sin antes hablar sobre lo que pretendemos hacer con él. </p><br><p>  El software está escrito para resolver el problema.  El programa se ejecuta y tiene un comportamiento.  Este comportamiento se estudia para garantizar un funcionamiento correcto o para detectar errores.  El software también a menudo cambia para darle un comportamiento nuevo o modificado. </p><br><p>  Por lo tanto, cualquier enfoque para el diseño de software debe centrarse en predecir, estudiar y comprender su comportamiento para hacer que cambiar este comportamiento sea lo más simple posible. </p><br><p>  Verificamos la corrección del comportamiento mediante pruebas y, por lo tanto, estoy de acuerdo con Kent en que lo primero y más importante es que un software bien diseñado debe pasar las pruebas.  Incluso iré más allá e insistiré en que el software debe tener pruebas (es decir, estar bien cubierto por las pruebas). </p><br><p>  Después de que se haya verificado el comportamiento, los siguientes tres puntos en ambas listas se relacionan con la comprensión de nuestro software (y, por lo tanto, su comportamiento).  Su lista comienza con la duplicación de código, que realmente está en su lugar.  Sin embargo, en mi experiencia personal, centrarme demasiado en reducir la duplicación de código es costoso.  Para eliminarlo, es necesario crear abstracciones que lo oculten, y son estas abstracciones las que hacen que el software sea difícil de entender y cambiar. </p><br><h1 id="ustranenie-dublirovaniya-koda-trebuet-abstrakciy-a-abstrakcii-privodyat-k-slozhnosti">  Eliminar la duplicación de código requiere abstracciones, y las abstracciones conducen a la complejidad. </h1><br><p>  Don't Repeat Yourself o DRY se usa para justificar decisiones de diseño controvertidas.  ¿Alguna vez has visto un código similar? </p><br><pre><code class="ruby hljs">ZERO = BigDecimal.new(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  Además, probablemente viste algo como esto: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map payload, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> async, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> errorStrategy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Si ve métodos o funciones con banderas, booleanos, etc., esto generalmente significa que alguien usó el principio DRY al refactorizar, pero el código no era <em>exactamente</em> el mismo en ambos lugares, por lo que el código resultante debería tener ser lo suficientemente flexible como para acomodar ambos comportamientos. </p><br><p>  Tales abstracciones generalizadas son difíciles de probar y comprender, ya que deberían manejar muchos más casos que el código original (posiblemente duplicado).  En otras palabras, las abstracciones soportan muchos más comportamientos de los necesarios para el funcionamiento normal del sistema.  Por lo tanto, eliminar la duplicación de código puede crear un nuevo comportamiento que el sistema no requiere. </p><br><p>  Por lo tanto, es <em>realmente importante</em> combinar algunos tipos de comportamiento, pero puede ser difícil entender qué tipo de comportamiento se duplica realmente.  A menudo, las piezas de código se ven similares, pero esto sucede solo por accidente. </p><br><p>  Considere cuánto más fácil es eliminar la duplicación de código que devolverla nuevamente (por ejemplo, después de crear una abstracción mal pensada).  Por lo tanto, debemos pensar en dejar código duplicado, a menos que estemos absolutamente seguros de que tenemos una mejor manera de deshacernos de él. </p><br><p>  Crear abstracciones debería hacernos pensar.  Si en el proceso de eliminar el código duplicado crea una abstracción generalizada muy flexible, es posible que haya tomado el camino equivocado. </p><br><p>  Esto nos lleva al siguiente punto: intención versus comportamiento. </p><br><h1 id="namerenie-programmista-bessmyslenno---povedenie-znachit-vse">  La intención del programador no tiene sentido: el comportamiento lo es todo </h1><br><p>  A menudo elogiamos los lenguajes de programación, construcciones o fragmentos de código por "revelar las intenciones del programador".  Pero, ¿qué sentido tiene conocer las intenciones si no puede predecir el comportamiento?  Y si conoces el comportamiento, ¿cuánto significa la intención?  Resulta que <em>necesita</em> saber cómo <em>debe</em> comportarse el software, pero esto no es lo mismo que las "intenciones del programador". </p><br><p>  Veamos este ejemplo, que refleja muy bien las intenciones del programador, pero no se comporta según lo previsto: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LastModified</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Last modified on { props.date.toLocaleDateString() } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br><p>  Obviamente, el programador planeó que este componente React mostrara una fecha con el mensaje "Última modificación el".  ¿Funciona esto según lo previsto?  En realidad no  ¿Qué pasa si this.prop.date no importa?  Todo simplemente se rompe.  No sabemos si fue tan concebido, o si alguien simplemente lo olvidó, y eso ni siquiera importa.  Lo que importa es el comportamiento. </p><br><p>  Y esto es exactamente lo que debemos saber si queremos cambiar esta parte del código.  Imagina que necesitamos cambiar la línea a "Última modificación".  Aunque podemos hacer esto, no está claro qué debería suceder si falta la fecha.  Sería mejor si en su lugar escribiéramos el componente de tal manera que su comportamiento sea más comprensible. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LastModified</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!props.date) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"LastModified requires a date to be passed"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Last modified on { props.date.toLocaleDateString() } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br><p>  O incluso así: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LastModified</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (props.date) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Last modified on { props.date.toLocaleDateString() } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Never modified</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br><p>  En ambos casos, el comportamiento es más comprensible y las intenciones del programador no importan.  Supongamos que elegimos la segunda alternativa (que maneja el valor de la fecha que falta).  Cuando se nos pide que cambiemos el mensaje, podemos ver el comportamiento y verificar si el mensaje "Nunca modificado" es correcto o si también necesita ser cambiado. </p><br><p>  Por lo tanto, cuanto más inequívoco sea el <em>comportamiento</em> , más posibilidades tenemos de cambiarlo con éxito.  Y esto significa que es posible que necesitemos escribir más código o hacerlo más preciso, o incluso escribir código duplicado a veces. </p><br><p>  También significa que necesitaremos más clases, funciones, métodos, etc. Por supuesto, <em>nos gustaría</em> mantener su número mínimo, pero no debemos usar este número como nuestra métrica.  La creación de una gran cantidad de clases o métodos crea <em>una sobrecarga conceptual</em> , y aparecen más conceptos en el software que unidades de modularidad.  Por lo tanto, necesitamos reducir el número de conceptos, lo que, a su vez, puede conducir a una disminución en el número de clases. </p><br><h1 id="konceptualnye-rashody-sposobstvuyut-zaputannosti-i-uslozhneniyu">  Los costos conceptuales contribuyen a la confusión y la complejidad. </h1><br><p>  Para comprender qué hará realmente el código, debe conocer no solo el área temática, sino también todos los conceptos utilizados en este código (por ejemplo, al buscar la desviación estándar, debe conocer la asignación, la suma, la multiplicación, los bucles y las longitudes de la matriz).  Esto explica por qué a medida que aumenta el número de conceptos en un diseño, aumenta su complejidad para la comprensión. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solía</a> escribir sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gastos conceptuales</a> , y un buen efecto secundario de reducir la cantidad de conceptos en un sistema es que más personas pueden entender este sistema.  Esto a su vez aumenta el número de personas que pueden realizar cambios en este sistema.  Definitivamente, un diseño de software que muchas personas pueden cambiar de forma segura es mejor que uno que solo un pequeño puñado pueda cambiar.  (Por lo tanto, creo que la programación funcional hardcore nunca será popular, ya que requiere una comprensión profunda de muchos conceptos muy abstractos). </p><br><p>  Reducir los costos conceptuales naturalmente reducirá la cantidad de abstracciones <em>y</em> hará que el comportamiento sea más fácil de entender.  No digo "nunca introducir un nuevo concepto", digo que tiene su propio precio, y si este precio supera el beneficio, la introducción de un nuevo concepto debe considerarse cuidadosamente. </p><br><p>  Cuando escribimos código o diseñamos software, debemos dejar de pensar en la <em>elegancia</em> , <em>belleza</em> u otra medida subjetiva de nuestro código.  En cambio, siempre debemos recordar lo que vamos a hacer con el software. </p><br><h1 id="vy-ne-veshaete-kod-na-stenu---vy-menyaete-ego">  No cuelgas el código en la pared, lo cambias </h1><br><p>  Un código no es una obra de arte que puede imprimir y colgar en un museo.  El código se está ejecutando.  Es estudiado y depurado.  Y, lo más importante, está <em>cambiando</em> .  Y a menudo  Cualquier diseño con el que sea difícil trabajar debe ser cuestionado y revisado.  Cualquier diseño que reduzca el número de personas que pueden trabajar con él <em>también</em> debe ser cuestionado. </p><br><p>  El código debería funcionar, por lo que debería ser probado.  El código tiene errores y requerirá la adición de nuevas características, por lo que debemos comprender su comportamiento.  El código dura más que la capacidad de un programador en particular para admitirlo, por lo que debemos luchar por un código que sea comprensible para una amplia gama de personas. </p><br><p>  Cuando escribe su código o diseña su sistema, ¿simplifica la explicación del comportamiento del sistema?  ¿Se vuelve más fácil entender cómo se comportará?  ¿Estás enfocado en resolver el problema justo en frente tuyo o en uno más abstracto? </p><br><p>  Siempre trate de mantener el comportamiento simple para la demostración, predicción y comprensión, y mantenga el número de conceptos al mínimo absoluto. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461823/">https://habr.com/ru/post/461823/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461813/index.html">Noticias del mundo de OpenStreetMap No. 470 (16.07.2019 - 22.07.2019)</a></li>
<li><a href="../461815/index.html">Una revolución en el diseño de las fuentes de alimentación para computadoras hace medio siglo</a></li>
<li><a href="../461817/index.html">CMake y C ++: hermanos para siempre</a></li>
<li><a href="../461819/index.html">¿Por qué el diseño simple de un sitio web es mejor científicamente?</a></li>
<li><a href="../461821/index.html">La nueva inmunoterapia eliminó todos los tumores en una mujer con cáncer de seno metastásico</a></li>
<li><a href="../461827/index.html">Desarrollo de aplicaciones híbridas PHP / Go con RoadRunner</a></li>
<li><a href="../461829/index.html">TCP vs UDP o el futuro de los protocolos de red</a></li>
<li><a href="../461831/index.html">StealthWatch: implementación y personalización. Parte 2</a></li>
<li><a href="../461833/index.html">No te pierdas en tres pinos: una representación egocéntrica del entorno.</a></li>
<li><a href="../461835/index.html">Cómo los gráficos de Gantt simplifican y potencian la gestión de proyectos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>