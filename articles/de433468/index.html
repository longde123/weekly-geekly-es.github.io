<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚂 🚇 👩🏾‍🚀 Fehlerinjektion: Ihr System ist unzuverlässig, wenn Sie nicht versucht haben, es zu beschädigen 👗 💮 🌂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich heiße Pavel Lipsky. Ich bin Ingenieur und arbeite für Sberbank-Technology. Meine Spezialisierung ist das Testen der Fehlertoleranz und...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fehlerinjektion: Ihr System ist unzuverlässig, wenn Sie nicht versucht haben, es zu beschädigen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/433468/">  Hallo Habr!  Ich heiße Pavel Lipsky.  Ich bin Ingenieur und arbeite für Sberbank-Technology.  Meine Spezialisierung ist das Testen der Fehlertoleranz und Leistung der Backends großer verteilter Systeme.  Einfach gesagt, ich breche die Programme anderer Leute.  In diesem Beitrag werde ich über die Fehlerinjektion sprechen - eine Testmethode, mit der Sie Probleme im System finden können, indem Sie künstliche Fehler verursachen.  Ich beginne damit, wie ich zu dieser Methode gekommen bin, dann werden wir über die Methode selbst sprechen und wie wir sie verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/593/a93/c50593a934415805dac00c5de3a07390.png"></div><a name="habracut"></a><br>  Der Artikel enthält Java-Beispiele.  Wenn Sie nicht in Java programmieren - es ist in Ordnung, verstehen Sie einfach den Ansatz selbst und die Grundprinzipien.  Apache Ignite wird als Datenbank verwendet, aber die gleichen Ansätze gelten für jedes andere DBMS.  Alle Beispiele können von meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> heruntergeladen werden. <br><br><h2>  Warum brauchen wir das alles? </h2><br>  Ich werde mit der Geschichte beginnen.  2005 habe ich für Rambler gearbeitet.  Zu diesem Zeitpunkt wuchs die Anzahl der Rambler-Benutzer rapide und unsere zweistufige Architektur "Server - Datenbank - Server - Anwendungen" wurde nicht mehr bewältigt.  Wir haben darüber nachgedacht, wie Leistungsprobleme gelöst werden können, und auf die zwischengespeicherte Technologie aufmerksam gemacht. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e4e/907/91e/e4e90791ef24ecaba4ec24a941f6e5ce.png" width="600" height="278"><br><br>  Was ist zwischengespeichert?  Memcached - Eine Hash-Tabelle im Direktzugriffsspeicher mit Zugriff auf gespeicherte Objekte per Schlüssel.  Zum Beispiel müssen Sie ein Benutzerprofil erhalten.  Die Anwendung greift auf memcached (2) zu.  Befindet sich ein Objekt darin, wird es sofort an den Benutzer zurückgegeben.  Wenn es kein Objekt gibt, wird ein Rechtsbehelf bei der Datenbank eingelegt (3), das Objekt wird gebildet und in den Speicher gestellt (4).  Dann müssen wir beim nächsten Aufruf keinen ressourcenintensiven Aufruf mehr an die Datenbank vornehmen - wir erhalten das fertige Objekt aus dem Hauptspeicher - zwischengespeichert. <br><br>  Aufgrund von Memcached haben wir die Datenbank merklich entladen und unsere Anwendungen begannen viel schneller zu arbeiten.  Aber wie sich herausstellte, war es zu früh, um sich zu freuen.  Zusammen mit der Steigerung der Produktivität haben wir neue Herausforderungen erhalten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42c/4f9/c03/42c4f9c03bf3a365e19b4cda2dc6562b.png" width="600" height="277"><br><br>  Wenn Sie die Daten ändern müssen, korrigiert die Anwendung zuerst die Datenbank (2), erstellt ein neues Objekt und versucht dann, es in memcached (3) abzulegen.  Das heißt, das alte Objekt muss durch ein neues ersetzt werden.  Stellen Sie sich vor, dass in diesem Moment etwas Schreckliches passiert - die Verbindung zwischen der Anwendung und memcached ist unterbrochen, der memcached Server oder sogar die Anwendung selbst stürzt ab.  Daher konnte die Anwendung die Daten in memcached nicht aktualisieren.  Infolgedessen geht der Benutzer zur Seite der Site (z. B. seinem Profil), zeigt die alten Daten an und versteht nicht, warum dies passiert ist. <br><br>  Könnte dieser Fehler beim Funktionstest oder Leistungstest erkannt werden?  Ich denke, dass wir ihn höchstwahrscheinlich nicht finden würden.  Um nach solchen Fehlern zu suchen, gibt es eine spezielle Art der Prüfung - die Fehlerinjektion. <br><br>  Normalerweise gibt es beim Testen der Fehlerinjektion Fehler, die im Volksmund als <i>schwebend bezeichnet werden</i> .  Sie treten unter Last auf, wenn mehr als ein Benutzer im System arbeitet, wenn abnormale Situationen auftreten - Gerätestörungen, Stromausfall, Netzwerkstörung usw. <br><br><h2>  Neues Sberbank IT-System </h2><br>  Vor einigen Jahren begann die Sberbank mit dem Aufbau eines neuen IT-Systems.  Warum?  Hier sind die Statistiken von der Website der Zentralbank: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/32c/1ab/05232c1ab18a23996d9172fcdc05d970.png" width="600" height="229"><br><br>  Der grüne Teil der Spalte gibt die Anzahl der Bargeldabhebungen an Geldautomaten an, der blaue Teil die Anzahl der Vorgänge, bei denen Waren und Dienstleistungen bezahlt werden müssen.  Wir sehen, dass die Zahl der bargeldlosen Transaktionen von Jahr zu Jahr zunimmt.  In einigen Jahren müssen wir in der Lage sein, die wachsende Arbeitsbelastung zu bewältigen und unseren Kunden weiterhin neue Dienstleistungen anzubieten.  Dies ist einer der Gründe für die Schaffung eines neuen Sberbank-IT-Systems.  Darüber hinaus möchten wir unsere Abhängigkeit von westlichen Technologien und teuren Mainframes, die Millionen von Dollar kosten, verringern und auf Open Source-Technologien und Low-End-Server umsteigen. <br><br>  Zunächst haben wir den Grundstein für die Apache Ignite-Technologie im Zentrum der neuen Sberbank-Architektur gelegt.  Genauer gesagt verwenden wir das kostenpflichtige Gridgain-Plugin.  Die Technologie verfügt über eine ziemlich umfangreiche Funktionalität: Sie kombiniert die Eigenschaften einer relationalen Datenbank (SQL-Abfragen werden unterstützt), NoSQL, verteilte Verarbeitung und Speicherung von Daten im RAM.  Darüber hinaus gehen beim Neustart keine Daten verloren, die sich im RAM befanden.  Ab Version 2.1 hat Apache Ignite den persistenten Datenspeicher von Apache Ignite mit SQL-Unterstützung verteilt. <br><br>  Ich werde einige Funktionen dieser Technologie auflisten: <br><br><ul><li>  Speicherung und Datenverarbeitung im RAM <br></li><li>  Festplattenspeicher <br></li><li>  SQL-Unterstützung <br></li><li>  Verteilte Aufgabenausführung <br></li><li>  Horizontale Skalierung <br></li></ul><br>  Die Technologie ist relativ neu und erfordert daher besondere Aufmerksamkeit. <br><br>  Das neue IT-System der Sberbank besteht physisch aus vielen relativ kleinen Servern, die in einem einzigen Cloud-Cluster zusammengefasst sind.  Alle Knoten sind in ihrer Struktur identisch, Peer-to-Peer, und erfüllen die Funktion zum Speichern und Verarbeiten von Daten. <br><br>  Innerhalb des Clusters ist in die sogenannten Zellen unterteilt.  Eine Zelle besteht aus 8 Knoten.  Jedes Rechenzentrum hat 4 Knoten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a6/e18/2da/7a6e182daba502a73800093e18e1b4f7.png" width="600" height="343"><br>  Da wir das speicherinterne Datenraster Apache Ignite verwenden, wird dies alles dementsprechend in serververteilten Caches gespeichert.  Darüber hinaus sind Caches wiederum in identische Teile unterteilt - Partitionen.  Auf Servern werden sie als Dateien dargestellt.  Partitionen desselben Caches können auf verschiedenen Servern gespeichert werden.  Für jede Partition im Cluster gibt es Primärknoten und Sicherungsknoten. <br><br>  Die Hauptknoten speichern die Hauptpartitionen und verarbeiten Anforderungen für sie. Replizieren Sie die Daten auf die Sicherungsknoten (Sicherungsknoten), auf denen die Sicherungspartitionen gespeichert sind. <br><br>  Beim Entwurf der neuen Architektur der Sberbank kamen wir zu dem Schluss, dass Systemkomponenten ausfallen können und werden.  Angenommen, Sie haben einen Cluster von 1000 Eisen-Low-End-Servern, dann treten von Zeit zu Zeit Hardwarefehler auf.  RAM-Strips, Netzwerkkarten und Festplatten usw. fallen aus.  Wir werden dieses Verhalten als völlig normales Systemverhalten betrachten.  Solche Situationen sollten korrekt gehandhabt werden und unsere Kunden sollten sie nicht bemerken. <br><br>  Es reicht jedoch nicht aus, die Fehlerresistenz des Systems zu bestimmen. Es ist unbedingt erforderlich, die Systeme während dieser Fehler zu testen.  Caitie McCaffrey von Microsoft Research, eine bekannte Forscherin für verteilte Systeme, sagt: „Sie werden nie wissen, wie sich das System während eines Notfallfehlers verhält, bis Sie den Fehler reproduzieren.“ <br><br><h2>  Verlorene Updates </h2><br>  Nehmen wir ein einfaches Beispiel, eine Bankanwendung, die Geldtransfers simuliert.  Die Anwendung besteht aus zwei Teilen: Apache Ignite-Server und Apache Ignite-Client.  Die Serverseite ist ein Data Warehouse. <br><br>  Die Clientanwendung stellt eine Verbindung zum Apache Ignite-Server her.  Erstellt einen Cache, in dem der Schlüssel die Konto-ID und der Wert das Kontoobjekt ist.  Insgesamt werden zehn solcher Objekte im Cache gespeichert.  In diesem Fall werden wir zunächst 100 USD auf jedes Konto einzahlen (damit etwas überwiesen werden kann).  Dementsprechend beträgt der Gesamtbetrag auf allen Konten 1.000 USD. <br><br><pre><code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.ATOMIC); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IgniteCache&lt;Integer, Account&gt; cache = ignite.getOrCreateCache(cfg)) {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= ENTRIES_COUNT; i++)       cache.put(i, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Account(i, <span class="hljs-number"><span class="hljs-number">100</span></span>));   System.out.println(<span class="hljs-string"><span class="hljs-string">"Accounts before transfers"</span></span>);   printAccounts(cache);   printTotalBalance(cache);   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pairOfAccounts[] = getPairOfRandomAccounts();       transferMoney(cache, pairOfAccounts[<span class="hljs-number"><span class="hljs-number">0</span></span>], pairOfAccounts[<span class="hljs-number"><span class="hljs-number">1</span></span>]);   } } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IgniteCache&lt;Integer, Account&gt; cache, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{   Account fromAccount = cache.get(fromAccountId);   Account toAccount = cache.get(toAccountId);   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance);   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;   }   fromAccount.withdraw(amount);   toAccount.deposit(amount);   cache.put(fromAccountId, fromAccount);   cache.put(toAccountId, toAccount); }</code> </pre> <br><br>  Dann machen wir 100 zufällige Geldtransfers zwischen diesen 10 Konten.  Beispielsweise werden 50 USD von Konto A auf ein anderes Konto B überwiesen.  Schematisch kann dieser Prozess wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/526/dc8/626/526dc86262d11f823d0aabce90c2c429.png"><br><br>  Das System ist geschlossen, Übertragungen erfolgen nur intern, d.h.  Der Gesamtbetrag sollte 1000 US-Dollar betragen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6d/afe/366/f6dafe3664e4f55c07515fde18d0e92e.png" width="600" height="268"><br><br>  Starten Sie die Anwendung. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/S8_UMhMwhb0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Wir haben den erwarteten Wert des Gesamtbetrags erhalten - 1000 USD.  Lassen Sie uns nun unsere Anwendung etwas komplizieren - machen wir sie multitasking.  In der Realität können mehrere Clientanwendungen gleichzeitig mit demselben Konto arbeiten.  Führen Sie zwei Aufgaben aus, mit denen gleichzeitig Geldtransfers zwischen zehn Konten durchgeführt werden. <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.ATOMIC); cfg.setCacheMode(CacheMode.PARTITIONED); cfg.setIndexedTypes(Integer.class, Account.class); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IgniteCache&lt;Integer, Account&gt; cache = ignite.getOrCreateCache(cfg)) {  <span class="hljs-comment"><span class="hljs-comment">// Initializing the cache.  for (int i = 1; i &lt;= ENTRIES_COUNT; i++)    cache.put(i, new Account(i, 100));  System.out.println("Accounts before transfers");  System.out.println();  printAccounts(cache);  printTotalBalance(cache);  IgniteRunnable run1 = new MyIgniteRunnable(cache, ignite,1);  IgniteRunnable run2 = new MyIgniteRunnable(cache, ignite,2);  List&lt;IgniteRunnable&gt; arr = Arrays.asList(run1, run2);  ignite.compute().run(arr); } ... private void transferMoney(int fromAccountId, int toAccountId) {  Account fromAccount = cache.get(fromAccountId);  Account toAccount = cache.get(toAccountId);  int amount = getRandomAmount(fromAccount.balance);  if (amount &lt; 1) {      return;  }  int fromAccountBalanceBeforeTransfer = fromAccount.balance;  int toAccountBalanceBeforeTransfer = toAccount.balance;  fromAccount.withdraw(amount);  toAccount.deposit(amount);  cache.put(fromAccountId, fromAccount);  cache.put(toAccountId, toAccount); }</span></span></code> </pre><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3RPeJlYNDFg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Der Gesamtbetrag beträgt 1296 USD.  Kunden freuen sich, die Bank erleidet Verluste.  Warum ist das passiert? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed1/636/2fd/ed16362fd78ed83f0ecb703941eb2596.png"><br><br>  Hier sehen wir, wie zwei Aufgaben gleichzeitig den Status von Konto A ändern. Die zweite Aufgabe kann jedoch ihre Änderungen früher als die erste aufzeichnen.  Dann zeichnet die erste Aufgabe ihre Änderungen auf, und alle von der zweiten Aufgabe vorgenommenen Änderungen verschwinden sofort.  Diese Anomalie wird als Problem verlorener Updates bezeichnet. <br><br>  Damit die Anwendung ordnungsgemäß funktioniert, muss unsere Datenbank ACID-Transaktionen unterstützen, und unser Code sollte dies berücksichtigen. <br><br>  Schauen wir uns die ACID-Eigenschaften für unsere Anwendung an, um zu verstehen, warum dies so wichtig ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/210/b47/f2f210b470dc23068ac49e0b68b54de3.png" width="315" height="315"><br><br><ul><li>  <i>A - Atomizität, Atomizität.</i>  Entweder werden alle vorgeschlagenen Änderungen an der Datenbank vorgenommen, oder es wird nichts vorgenommen.  Das heißt, wenn zwischen den Schritten 3 und 6 ein Fehler aufgetreten ist, sollten sich die Änderungen nicht in der Datenbank befinden <br></li><li>  <i>C - Konsistenz, Integrität.</i>  Nach Abschluss der Transaktion muss die Datenbank in einem konsistenten Zustand bleiben.  In unserem Beispiel bedeutet dies, dass die Summe von A und B immer gleich sein sollte, der Gesamtbetrag beträgt 1000 USD. <br></li><li>  <i>I - Isolation, Isolation.</i>  Transaktionen sollten sich nicht gegenseitig beeinflussen.  Wenn eine Transaktion eine Überweisung vornimmt und die andere nach Schritt 3 und bis zu Schritt 6 den Wert von Konto A und B erhält, glaubt sie, dass das System weniger Geld als nötig hat.  Hier gibt es Nuancen, auf die ich mich später konzentrieren werde. <br></li><li>  <i>D - Haltbarkeit</i>  Nachdem die Transaktion Änderungen an der Datenbank festgeschrieben hat, sollten diese Änderungen nicht aufgrund von Fehlern verloren gehen. <br></li></ul><br>  Bei der transferMoney-Methode führen wir also eine Geldüberweisung innerhalb der Transaktion durch. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart()) {      Account fromAccount = cache.get(fromAccountId);      Account toAccount = cache.get(toAccountId);      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;      }      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fromAccountBalanceBeforeTransfer = fromAccount.balance;      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> toAccountBalanceBeforeTransfer = toAccount.balance;          fromAccount.withdraw(amount);      toAccount.deposit(amount);          cache.put(fromAccountId, fromAccount);      cache.put(toAccountId, toAccount);          tx.commit();  } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){      e.printStackTrace();  } }</code> </pre><br>  Starten Sie die Anwendung. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pEgyqAUAvM8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hm.  Transaktionen haben nicht geholfen.  Der Gesamtbetrag beträgt 6951 $!  Was ist das Problem mit diesem Anwendungsverhalten? <br><br>  Zuerst wählten sie den ATOMIC-Cache-Typ, d.h.  ohne ACID-Transaktionsunterstützung: <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.TOMIC);</code> </pre> <br>  Zweitens verfügt die txStart-Methode über zwei wichtige Parameter des Aufzählungstyps, die angegeben werden sollten: die Sperrmethode (Parallelitätsmodus in Apache Ignite) und die Isolationsstufe.  Abhängig von den Werten dieser Parameter kann eine Transaktion Daten auf unterschiedliche Weise lesen und schreiben.  In Apache Ignite werden diese Parameter wie folgt festgelegt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart( ,  )) { Account fromAccount = cache.get(fromAccountId); Account toAccount = cache.get(toAccountId); ...  tx.commit(); }</code> </pre><br>  Sie können PESSIMISTIC (pessimistische Sperre) oder OPTIMISTIC (optimistische Sperre) als Wert des Parameters LOCK METHOD verwenden.  Sie unterscheiden sich im Moment der Blockierung.  Bei Verwendung von PESSIMISTIC wird die Sperre beim ersten Lesen / Schreiben auferlegt und gehalten, bis die Transaktion festgeschrieben wird.  Wenn beispielsweise eine Transaktion mit einer pessimistischen Sperre eine Übertragung von Konto A auf Konto B durchführt, können andere Transaktionen die Werte dieser Konten erst lesen oder schreiben, wenn die Transaktion, die die Übertragung vornimmt, festgeschrieben wurde.  Es ist klar, dass andere Transaktionen, die auf die Konten A und B zugreifen möchten, gezwungen sind, auf den Abschluss der Transaktion zu warten, was sich negativ auf die Gesamtleistung der Anwendung auswirkt.  Das optimistische Sperren schränkt den Zugriff auf Daten für andere Transaktionen nicht ein. Während der Vorbereitungsphase der Transaktion für das Festschreiben (Vorbereitungsphase, Apache Ignite verwendet das 2PC-Protokoll) wird jedoch eine Überprüfung durchgeführt. Haben sich die Daten bei anderen Transaktionen geändert?  Und wenn Änderungen vorgenommen wurden, wird die Transaktion abgebrochen.  In Bezug auf die Leistung läuft OPTIMISTIC schneller, eignet sich jedoch besser für Anwendungen, bei denen keine Konkurrenz zu Daten besteht. <br><br>  Der Parameter INSULATION LEVEL bestimmt den Grad der Isolation von Transaktionen voneinander.  Der SQL ANSI / ISO-Standard definiert vier Arten der Isolation. Für jede Isolationsstufe kann dasselbe Transaktionsszenario zu unterschiedlichen Ergebnissen führen. <br><br><ul><li>  READ_UNCOMMITED ist die niedrigste Isolationsstufe.  Transaktionen können "schmutzige" nicht festgeschriebene Daten anzeigen. <br></li><li>  READ_COMMITTED - Wenn eine Transaktion nur sensible Daten in sich sieht <br></li><li>  REPEATABLE_READ - bedeutet, dass dieser Lesevorgang wiederholbar sein muss, wenn innerhalb der Transaktion ein Lesevorgang durchgeführt wird. <br></li><li>  SERIALIZABLE - Diese Ebene setzt den maximalen Grad der Transaktionsisolation voraus - als ob sich keine anderen Benutzer im System befinden.  Das Ergebnis paralleler Transaktionen ist so, als ob sie in der richtigen Reihenfolge ausgeführt würden.  Zusammen mit einem hohen Maß an Isolation erhalten wir jedoch eine Leistungsminderung.  Daher müssen Sie die Wahl dieser Isolationsstufe sorgfältig treffen. <br></li></ul><br>  Für viele moderne DBMS (Microsoft SQL Server, PostgreSQL und Oracle) lautet die Standardisolationsstufe READ_COMMITTED.  In unserem Beispiel wäre dies fatal, da es uns nicht vor verlorenen Updates schützt.  Das Ergebnis ist das gleiche, als hätten wir überhaupt keine Transaktionen verwendet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/32a/a26/0a6/32aa260a65aa3ad758dbecc220eef231.png"><br><br>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Ignite-Transaktionsdokumentation können</a> wir eine Kombination aus Sperrmethode und Isolationsstufe verwenden: <br><br><ul><li>  <b>PESSIMISTIC REPEATABLE_READ</b> - Die Sperre wird beim ersten Lesen oder Schreiben von Daten auferlegt und bis zu ihrem <b>Abschluss beibehalten</b> . <br></li><li>  <b>PESSIMISTIC SERIALIZABLE</b> - funktioniert ähnlich wie PESSIMISTIC REPEATABLE_READ <br></li><li>  <b>OPTIMISTIC SERIALIZABLE</b> - Die Version der Daten, die nach dem ersten Lesen erhalten wurden, wird gespeichert. Wenn sich diese Version während der Vorbereitungsphase für das Commit unterscheidet (die Daten wurden durch eine andere Transaktion geändert), wird die Transaktion abgebrochen.  Versuchen wir diese Option. <br></li></ul><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart(OPTIMISTIC, SERIALIZABLE)) { Account fromAccount = cache.get(fromAccountId); Account toAccount = cache.get(toAccountId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fromAccountBalanceBeforeTransfer = fromAccount.balance; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> toAccountBalanceBeforeTransfer = toAccount.balance; fromAccount.withdraw(amount); toAccount.deposit(amount); cache.put(fromAccountId, fromAccount); cache.put(toAccountId, toAccount); tx.commit(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ e.printStackTrace(); } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/vPZcW7qbvvs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hurra, bekam wie erwartet 1.000 Dollar.  Beim dritten Versuch. <br><br><h2>  Testen unter Last </h2><br>  Jetzt werden wir unseren Test realistischer machen - wir werden unter Last testen.  Und fügen Sie einen zusätzlichen Serverknoten hinzu.  Es gibt viele Tools für die Durchführung von Stresstests. Bei Sberbank verwenden wir das HP Performance Center.  Dies ist ein ziemlich leistungsfähiges Tool, das mehr als 50 Protokolle unterstützt, für große Teams entwickelt wurde und viel Geld kostet.  Ich habe mein Beispiel auf JMeter geschrieben - es ist kostenlos und löst unser Problem zu 100%.  Ich möchte den Code nicht in Java umschreiben, daher werde ich den JSR223-Sampler verwenden. <br><br>  Wir erstellen ein JAR-Archiv aus den Klassen unserer Anwendung und laden es in den Testplan.  Führen Sie die CreateCache-Klasse aus, um den Cache zu erstellen und zu füllen.  Nach dem Initialisieren des Caches können Sie das JMeter-Skript ausführen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/i7jUnyfz_88" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Alles ist cool, hat 1.000 Dollar. <br><br><h2>  Notfall-Herunterfahren des Clusterknotens </h2><br>  Jetzt werden wir destruktiver: Während des Clusterbetriebs stürzen wir einen der beiden Serverknoten ab.  Über das Visor-Dienstprogramm, das im Gridgain-Paket enthalten ist, können wir den Apache Ignite-Cluster überwachen und verschiedene Datenbeispiele erstellen.  Führen Sie auf der Registerkarte SQL Viewer eine SQL-Abfrage aus, um den Gesamtsaldo für alle Konten abzurufen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/phUdYiMrPLg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Was ist das  553 Dollar.  Kunden haben Angst, die Bank erleidet Reputationsverluste.  Was haben wir diesmal falsch gemacht? <br><br>  Es stellt sich heraus, dass es in Apache Ignite Cache-Typen gibt: <br><br><ul><li>  partitioniert - Eine oder mehrere Sicherungskopien werden im Cluster gespeichert <br></li><li>  Replizierte Caches - Alle Partitionen (alle Teile des Caches) werden auf einem Server gespeichert.  Solche Caches eignen sich hauptsächlich für Nachschlagewerke - etwas, das sich selten ändert und oft gelesen wird. <br></li><li>  lokal - alles auf einem Knoten <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/032/23e/360/03223e3607e052fe4f0e3f24aca15837.png" width="600" height="344"><br><br>  Wir werden unsere Daten häufig ändern, daher wählen wir einen partitionierten Cache aus und fügen ihm eine zusätzliche Sicherung hinzu.  Das heißt, wir haben zwei Kopien der Daten - die primäre und die Sicherung. <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL); cfg.setCacheMode(CacheMode.PARTITIONED); cfg.setBackups(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Wir starten die Anwendung.  Ich erinnere Sie daran, dass wir vor Überweisungen 1000 Dollar haben.  Wir starten und „löschen“ während des Betriebs einen der Knoten <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1Y0C9eaTXFk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Im Visor-Dienstprogramm führen wir eine SQL-Abfrage durch, um einen Gesamtbetrag von 1000 US-Dollar zu erhalten.  Alles hat super geklappt! <br><br><h2>  Zuverlässigkeitsfälle </h2><br>  Vor zwei Jahren haben wir gerade damit begonnen, das neue Sberbank-IT-System zu testen.  Irgendwie gingen wir zu unseren Escort-Ingenieuren und fragten: Was könnte überhaupt kaputt gehen?  Sie antworteten uns: Alles kann kaputt gehen, alles testen!  Diese Antwort passte natürlich nicht zu uns.  Wir setzten uns zusammen, analysierten die Fehlerstatistik und stellten fest, dass der wahrscheinlichste Fall ein Knotenfehler ist. <br><br>  Darüber hinaus kann dies aus ganz anderen Gründen geschehen.  Beispielsweise kann eine Anwendung abstürzen, ein JVM-Absturz, ein Betriebssystemabsturz oder ein Hardwarefehler. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68c/ea2/035/68cea2035db5f01d47e48943a2c8797a.png" width="600" height="197"><br><br>  Wir haben alle möglichen Fehlerfälle in 4 Gruppen unterteilt: <br><br><ol><li>  Ausrüstung <br></li><li>  Netzwerk <br></li><li>  Software <br></li><li>  Andere <br></li></ol><br>  Sie entwickelten Tests für sie und nannten sie Fälle von Zuverlässigkeit.  Ein typischer Zuverlässigkeitsfall besteht aus einer Beschreibung des Systemzustands vor den Tests, Schritten zur Reproduktion des Fehlers und einer Beschreibung des erwarteten Verhaltens während des Fehlers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/201/bc5/484/201bc5484c7811d1a70bb8da502e3ad9.png" width="600" height="313"><br><br><h4>  Zuverlässigkeitsfälle: Ausrüstung </h4><br>  Diese Gruppe umfasst Fälle wie: <br><br><ul><li>  Stromausfall <br></li><li>  Vollständiger Verlust des Zugriffs auf die Festplatte <br></li><li>  Ausfall eines Festplattenzugriffspfads <br></li><li>  CPU, RAM, Festplatte, Netzwerklast <br></li></ul><br>  Der Cluster speichert 4 identische Kopien jeder Partition: eine primäre Partition und drei Sicherungspartitionen.  Angenommen, ein Knoten verlässt einen Cluster aufgrund eines Geräteausfalls.  In diesem Fall sollten die Hauptpartitionen zu anderen überlebenden Knoten verschoben werden. <br><br>  Was könnte sonst noch passieren?  Verlust des Gestells in der Zelle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44d/2b8/132/44d2b81324d9a0d91ee63a5508652456.png" width="600" height="251"><br><br>  Alle Knoten der Zelle befinden sich in unterschiedlichen Racks.  Das heißt,  Die Rack-Ausgabe führt nicht zu Clusterfehlern oder Datenverlust.  Wir werden drei Exemplare von vier haben.  Aber selbst wenn wir das gesamte Rechenzentrum verlieren, wird es für uns kein großes Problem sein, denn  Wir haben noch zwei weitere Kopien der Daten von vier. <br><br>  Einige Fälle werden mit Unterstützung von Support-Ingenieuren direkt im Rechenzentrum ausgeführt.  Schalten Sie beispielsweise die Festplatte aus und den Server oder das Rack aus. <br><br><h4>  Zuverlässigkeitsfälle: Netzwerk </h4><br>  Um Fälle im Zusammenhang mit der Netzwerkfragmentierung zu testen, verwenden wir iptables.  Und mit dem NetEm-Dienstprogramm emulieren wir: <br><br><ul><li>  Netzwerkverzögerungen mit unterschiedlicher Verteilungsfunktion <br></li><li>  Paketverlust <br></li><li>  Paketwiederholung <br></li><li>  Pakete neu anordnen <br></li><li>  Paketverzerrung <br></li></ul><br>  Ein weiterer interessanter Netzwerkfall, den wir testen, ist Split-Brain.  In diesem Fall sind alle Knoten des Clusters aktiv, können jedoch aufgrund der Netzwerksegmentierung nicht miteinander kommunizieren.  Der Begriff stammt aus der Medizin und bedeutet, dass das Gehirn in zwei Hemisphären unterteilt ist, von denen jede sich als einzigartig betrachtet.  Das gleiche kann mit einem Cluster passieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/778/cc0/58e/778cc058e68e7d552b612f9389af7499.png"><br>  Es kommt vor, dass zwischen Rechenzentren die Verbindung verschwindet.  Beispielsweise führte ein Kunde der Banken der Banken Tochka, Otkrytie und Rocketbank im vergangenen Jahr aufgrund einer Beschädigung des Glasfaserkabels durch einen Bagger mehrere Stunden lang keine Transaktionen über das Internet durch, die Terminals akzeptierten keine Karten und Geldautomaten funktionierten nicht.  Über diesen Unfall wurde auf Twitter viel geschrieben. <br><br>  In unserem Fall sollte die Split-Brain-Situation korrekt behandelt werden.  Ein Gitter identifiziert ein geteiltes Gehirn, das einen Cluster in zwei Teile teilt.  Eine Hälfte geht in den Lesemodus.  Dies ist die Hälfte, in der sich mehr lebende Knoten befinden oder der Koordinator sich befindet (der älteste Knoten im Cluster). <br><br><h4>  Zuverlässigkeitsfälle: Software </h4><br>  Dies sind Fälle im Zusammenhang mit dem Ausfall verschiedener Subsysteme: <br><br><ul><li>  DPL ORM - Datenzugriffsmodul, z. B. Hibernate ORM <br></li><li>  Intermodularer Transport - Messaging zwischen Modulen (Microservices) <br></li><li>  Protokollierungssystem <br></li><li>  Zugangssystem <br></li><li>  Apache Ignite Cluster <br></li><li>  ... <br></li></ul><br>  Da die meiste Software in Java geschrieben ist, sind wir anfällig für alle Probleme, die mit Java-Anwendungen verbunden sind.  Testet verschiedene Garbage Collector-Einstellungen.  Ausführen von Tests mit einem Absturz der Java Virtual Machine. <br><br>  Für den Apache Ignite-Cluster gibt es Sonderfälle für Off-Heap - dies ist der Speicherbereich, den Apache Ignite steuert.  Es ist viel größer als Java-Heap und dient zum Speichern von Daten und Indizes.  Hier können Sie beispielsweise den Überlauf testen.  Wir laufen außerhalb des Heaps über und sehen, wie der Cluster funktioniert, wenn einige der Daten nicht in den RAM passen, d. H.  von der Festplatte lesen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d97/cb0/29a/d97cb029adf7075f155c3f68332b3a80.png" width="600" height="374"><br><br><h4>  Andere Fälle </h4><br>  Dies sind Fälle, die nicht in den ersten drei Gruppen enthalten sind.  Dazu gehören Dienstprogramme, die die Datenwiederherstellung im Falle eines schweren Unfalls oder bei der Migration von Daten in einen anderen Cluster ermöglichen. <br><br><ul><li>  Das Dienstprogramm zum Erstellen von Snapshots (Backup) von Daten - Testen von vollständigen und inkrementellen Snapshots. <br></li><li>  Wiederherstellung zu einem bestimmten Zeitpunkt - PITR-Mechanismus (Point-in-Time Recovery). <br></li></ul><br><h2>  Dienstprogramme zur Fehlerinjektion </h2><br>  Ich erinnere mich an den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> zu Beispielen aus meinem Bericht.  Sie können die Apache Ignite-Distribution von der offiziellen Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterladen</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Ignite Downloads</a> .  Und jetzt werde ich die Dienstprogramme, die wir bei Sberbank verwenden, teilen, wenn Sie sich plötzlich für das Thema interessieren. <br><br>  Frameworks <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jepsen</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chaosaffe</a> <br></li></ul><br>  Konfigurationsmanagement: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ansible</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Marionette</a> <br></li></ul><br>  Linux-Dienstprogramme: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetEm (tc)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stress-ng</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iperf</a> <br></li><li>  töte -9 <br></li><li>  iptables <br></li></ul><br>  Lasttest-Tools: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jmeter</a> <br></li></ul><br>  Sowohl in der modernen Welt als auch in der Sberbank sind alle Veränderungen dynamisch und es ist schwierig vorherzusagen, welche Technologien in den nächsten Jahren eingesetzt werden.  Aber ich weiß mit Sicherheit, dass wir die Fehlerinjektionsmethode verwenden werden.  Die Methode ist universell - sie eignet sich zum Testen jeder Technologie, funktioniert wirklich, hilft, viele Fehler zu erkennen und die von uns entwickelten Produkte besser zu machen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433468/">https://habr.com/ru/post/de433468/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433448/index.html">Vergleichende Analyse der Gebrauchtmärkte Deutsche und französische Autos im B- und C-Segment</a></li>
<li><a href="../de433450/index.html">Wachsen und lehren. Wie wir uns mit PEGA angefreundet haben</a></li>
<li><a href="../de433456/index.html">So überzeugen Sie einen Kunden oder ein Unternehmen von Flutter</a></li>
<li><a href="../de433464/index.html">Subkosmische Rasse</a></li>
<li><a href="../de433466/index.html">Seiten vergleichen. Einfaches Plugin für Atlassian Confluence</a></li>
<li><a href="../de433472/index.html">Unity 2018.3 veröffentlicht</a></li>
<li><a href="../de433474/index.html">Pylint von innen nach außen. Wie macht er das?</a></li>
<li><a href="../de433476/index.html">50 Sellerietöne</a></li>
<li><a href="../de433478/index.html">Warum Django im Tinkoff Magazine ausgewählt wird</a></li>
<li><a href="../de433480/index.html">Holivarny Geschichte über Linter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>