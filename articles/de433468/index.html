<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÇ üöá üë©üèæ‚ÄçüöÄ Fehlerinjektion: Ihr System ist unzuverl√§ssig, wenn Sie nicht versucht haben, es zu besch√§digen üëó üíÆ üåÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich hei√üe Pavel Lipsky. Ich bin Ingenieur und arbeite f√ºr Sberbank-Technology. Meine Spezialisierung ist das Testen der Fehlertoleranz und...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fehlerinjektion: Ihr System ist unzuverl√§ssig, wenn Sie nicht versucht haben, es zu besch√§digen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/433468/">  Hallo Habr!  Ich hei√üe Pavel Lipsky.  Ich bin Ingenieur und arbeite f√ºr Sberbank-Technology.  Meine Spezialisierung ist das Testen der Fehlertoleranz und Leistung der Backends gro√üer verteilter Systeme.  Einfach gesagt, ich breche die Programme anderer Leute.  In diesem Beitrag werde ich √ºber die Fehlerinjektion sprechen - eine Testmethode, mit der Sie Probleme im System finden k√∂nnen, indem Sie k√ºnstliche Fehler verursachen.  Ich beginne damit, wie ich zu dieser Methode gekommen bin, dann werden wir √ºber die Methode selbst sprechen und wie wir sie verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/593/a93/c50593a934415805dac00c5de3a07390.png"></div><a name="habracut"></a><br>  Der Artikel enth√§lt Java-Beispiele.  Wenn Sie nicht in Java programmieren - es ist in Ordnung, verstehen Sie einfach den Ansatz selbst und die Grundprinzipien.  Apache Ignite wird als Datenbank verwendet, aber die gleichen Ans√§tze gelten f√ºr jedes andere DBMS.  Alle Beispiele k√∂nnen von meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> heruntergeladen werden. <br><br><h2>  Warum brauchen wir das alles? </h2><br>  Ich werde mit der Geschichte beginnen.  2005 habe ich f√ºr Rambler gearbeitet.  Zu diesem Zeitpunkt wuchs die Anzahl der Rambler-Benutzer rapide und unsere zweistufige Architektur "Server - Datenbank - Server - Anwendungen" wurde nicht mehr bew√§ltigt.  Wir haben dar√ºber nachgedacht, wie Leistungsprobleme gel√∂st werden k√∂nnen, und auf die zwischengespeicherte Technologie aufmerksam gemacht. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e4e/907/91e/e4e90791ef24ecaba4ec24a941f6e5ce.png" width="600" height="278"><br><br>  Was ist zwischengespeichert?  Memcached - Eine Hash-Tabelle im Direktzugriffsspeicher mit Zugriff auf gespeicherte Objekte per Schl√ºssel.  Zum Beispiel m√ºssen Sie ein Benutzerprofil erhalten.  Die Anwendung greift auf memcached (2) zu.  Befindet sich ein Objekt darin, wird es sofort an den Benutzer zur√ºckgegeben.  Wenn es kein Objekt gibt, wird ein Rechtsbehelf bei der Datenbank eingelegt (3), das Objekt wird gebildet und in den Speicher gestellt (4).  Dann m√ºssen wir beim n√§chsten Aufruf keinen ressourcenintensiven Aufruf mehr an die Datenbank vornehmen - wir erhalten das fertige Objekt aus dem Hauptspeicher - zwischengespeichert. <br><br>  Aufgrund von Memcached haben wir die Datenbank merklich entladen und unsere Anwendungen begannen viel schneller zu arbeiten.  Aber wie sich herausstellte, war es zu fr√ºh, um sich zu freuen.  Zusammen mit der Steigerung der Produktivit√§t haben wir neue Herausforderungen erhalten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42c/4f9/c03/42c4f9c03bf3a365e19b4cda2dc6562b.png" width="600" height="277"><br><br>  Wenn Sie die Daten √§ndern m√ºssen, korrigiert die Anwendung zuerst die Datenbank (2), erstellt ein neues Objekt und versucht dann, es in memcached (3) abzulegen.  Das hei√üt, das alte Objekt muss durch ein neues ersetzt werden.  Stellen Sie sich vor, dass in diesem Moment etwas Schreckliches passiert - die Verbindung zwischen der Anwendung und memcached ist unterbrochen, der memcached Server oder sogar die Anwendung selbst st√ºrzt ab.  Daher konnte die Anwendung die Daten in memcached nicht aktualisieren.  Infolgedessen geht der Benutzer zur Seite der Site (z. B. seinem Profil), zeigt die alten Daten an und versteht nicht, warum dies passiert ist. <br><br>  K√∂nnte dieser Fehler beim Funktionstest oder Leistungstest erkannt werden?  Ich denke, dass wir ihn h√∂chstwahrscheinlich nicht finden w√ºrden.  Um nach solchen Fehlern zu suchen, gibt es eine spezielle Art der Pr√ºfung - die Fehlerinjektion. <br><br>  Normalerweise gibt es beim Testen der Fehlerinjektion Fehler, die im Volksmund als <i>schwebend bezeichnet werden</i> .  Sie treten unter Last auf, wenn mehr als ein Benutzer im System arbeitet, wenn abnormale Situationen auftreten - Ger√§test√∂rungen, Stromausfall, Netzwerkst√∂rung usw. <br><br><h2>  Neues Sberbank IT-System </h2><br>  Vor einigen Jahren begann die Sberbank mit dem Aufbau eines neuen IT-Systems.  Warum?  Hier sind die Statistiken von der Website der Zentralbank: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/32c/1ab/05232c1ab18a23996d9172fcdc05d970.png" width="600" height="229"><br><br>  Der gr√ºne Teil der Spalte gibt die Anzahl der Bargeldabhebungen an Geldautomaten an, der blaue Teil die Anzahl der Vorg√§nge, bei denen Waren und Dienstleistungen bezahlt werden m√ºssen.  Wir sehen, dass die Zahl der bargeldlosen Transaktionen von Jahr zu Jahr zunimmt.  In einigen Jahren m√ºssen wir in der Lage sein, die wachsende Arbeitsbelastung zu bew√§ltigen und unseren Kunden weiterhin neue Dienstleistungen anzubieten.  Dies ist einer der Gr√ºnde f√ºr die Schaffung eines neuen Sberbank-IT-Systems.  Dar√ºber hinaus m√∂chten wir unsere Abh√§ngigkeit von westlichen Technologien und teuren Mainframes, die Millionen von Dollar kosten, verringern und auf Open Source-Technologien und Low-End-Server umsteigen. <br><br>  Zun√§chst haben wir den Grundstein f√ºr die Apache Ignite-Technologie im Zentrum der neuen Sberbank-Architektur gelegt.  Genauer gesagt verwenden wir das kostenpflichtige Gridgain-Plugin.  Die Technologie verf√ºgt √ºber eine ziemlich umfangreiche Funktionalit√§t: Sie kombiniert die Eigenschaften einer relationalen Datenbank (SQL-Abfragen werden unterst√ºtzt), NoSQL, verteilte Verarbeitung und Speicherung von Daten im RAM.  Dar√ºber hinaus gehen beim Neustart keine Daten verloren, die sich im RAM befanden.  Ab Version 2.1 hat Apache Ignite den persistenten Datenspeicher von Apache Ignite mit SQL-Unterst√ºtzung verteilt. <br><br>  Ich werde einige Funktionen dieser Technologie auflisten: <br><br><ul><li>  Speicherung und Datenverarbeitung im RAM <br></li><li>  Festplattenspeicher <br></li><li>  SQL-Unterst√ºtzung <br></li><li>  Verteilte Aufgabenausf√ºhrung <br></li><li>  Horizontale Skalierung <br></li></ul><br>  Die Technologie ist relativ neu und erfordert daher besondere Aufmerksamkeit. <br><br>  Das neue IT-System der Sberbank besteht physisch aus vielen relativ kleinen Servern, die in einem einzigen Cloud-Cluster zusammengefasst sind.  Alle Knoten sind in ihrer Struktur identisch, Peer-to-Peer, und erf√ºllen die Funktion zum Speichern und Verarbeiten von Daten. <br><br>  Innerhalb des Clusters ist in die sogenannten Zellen unterteilt.  Eine Zelle besteht aus 8 Knoten.  Jedes Rechenzentrum hat 4 Knoten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a6/e18/2da/7a6e182daba502a73800093e18e1b4f7.png" width="600" height="343"><br>  Da wir das speicherinterne Datenraster Apache Ignite verwenden, wird dies alles dementsprechend in serververteilten Caches gespeichert.  Dar√ºber hinaus sind Caches wiederum in identische Teile unterteilt - Partitionen.  Auf Servern werden sie als Dateien dargestellt.  Partitionen desselben Caches k√∂nnen auf verschiedenen Servern gespeichert werden.  F√ºr jede Partition im Cluster gibt es Prim√§rknoten und Sicherungsknoten. <br><br>  Die Hauptknoten speichern die Hauptpartitionen und verarbeiten Anforderungen f√ºr sie. Replizieren Sie die Daten auf die Sicherungsknoten (Sicherungsknoten), auf denen die Sicherungspartitionen gespeichert sind. <br><br>  Beim Entwurf der neuen Architektur der Sberbank kamen wir zu dem Schluss, dass Systemkomponenten ausfallen k√∂nnen und werden.  Angenommen, Sie haben einen Cluster von 1000 Eisen-Low-End-Servern, dann treten von Zeit zu Zeit Hardwarefehler auf.  RAM-Strips, Netzwerkkarten und Festplatten usw. fallen aus.  Wir werden dieses Verhalten als v√∂llig normales Systemverhalten betrachten.  Solche Situationen sollten korrekt gehandhabt werden und unsere Kunden sollten sie nicht bemerken. <br><br>  Es reicht jedoch nicht aus, die Fehlerresistenz des Systems zu bestimmen. Es ist unbedingt erforderlich, die Systeme w√§hrend dieser Fehler zu testen.  Caitie McCaffrey von Microsoft Research, eine bekannte Forscherin f√ºr verteilte Systeme, sagt: ‚ÄûSie werden nie wissen, wie sich das System w√§hrend eines Notfallfehlers verh√§lt, bis Sie den Fehler reproduzieren.‚Äú <br><br><h2>  Verlorene Updates </h2><br>  Nehmen wir ein einfaches Beispiel, eine Bankanwendung, die Geldtransfers simuliert.  Die Anwendung besteht aus zwei Teilen: Apache Ignite-Server und Apache Ignite-Client.  Die Serverseite ist ein Data Warehouse. <br><br>  Die Clientanwendung stellt eine Verbindung zum Apache Ignite-Server her.  Erstellt einen Cache, in dem der Schl√ºssel die Konto-ID und der Wert das Kontoobjekt ist.  Insgesamt werden zehn solcher Objekte im Cache gespeichert.  In diesem Fall werden wir zun√§chst 100 USD auf jedes Konto einzahlen (damit etwas √ºberwiesen werden kann).  Dementsprechend betr√§gt der Gesamtbetrag auf allen Konten 1.000 USD. <br><br><pre><code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.ATOMIC); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IgniteCache&lt;Integer, Account&gt; cache = ignite.getOrCreateCache(cfg)) {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= ENTRIES_COUNT; i++)       cache.put(i, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Account(i, <span class="hljs-number"><span class="hljs-number">100</span></span>));   System.out.println(<span class="hljs-string"><span class="hljs-string">"Accounts before transfers"</span></span>);   printAccounts(cache);   printTotalBalance(cache);   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pairOfAccounts[] = getPairOfRandomAccounts();       transferMoney(cache, pairOfAccounts[<span class="hljs-number"><span class="hljs-number">0</span></span>], pairOfAccounts[<span class="hljs-number"><span class="hljs-number">1</span></span>]);   } } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IgniteCache&lt;Integer, Account&gt; cache, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{   Account fromAccount = cache.get(fromAccountId);   Account toAccount = cache.get(toAccountId);   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance);   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;   }   fromAccount.withdraw(amount);   toAccount.deposit(amount);   cache.put(fromAccountId, fromAccount);   cache.put(toAccountId, toAccount); }</code> </pre> <br><br>  Dann machen wir 100 zuf√§llige Geldtransfers zwischen diesen 10 Konten.  Beispielsweise werden 50 USD von Konto A auf ein anderes Konto B √ºberwiesen.  Schematisch kann dieser Prozess wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/526/dc8/626/526dc86262d11f823d0aabce90c2c429.png"><br><br>  Das System ist geschlossen, √úbertragungen erfolgen nur intern, d.h.  Der Gesamtbetrag sollte 1000 US-Dollar betragen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6d/afe/366/f6dafe3664e4f55c07515fde18d0e92e.png" width="600" height="268"><br><br>  Starten Sie die Anwendung. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/S8_UMhMwhb0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Wir haben den erwarteten Wert des Gesamtbetrags erhalten - 1000 USD.  Lassen Sie uns nun unsere Anwendung etwas komplizieren - machen wir sie multitasking.  In der Realit√§t k√∂nnen mehrere Clientanwendungen gleichzeitig mit demselben Konto arbeiten.  F√ºhren Sie zwei Aufgaben aus, mit denen gleichzeitig Geldtransfers zwischen zehn Konten durchgef√ºhrt werden. <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.ATOMIC); cfg.setCacheMode(CacheMode.PARTITIONED); cfg.setIndexedTypes(Integer.class, Account.class); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IgniteCache&lt;Integer, Account&gt; cache = ignite.getOrCreateCache(cfg)) {  <span class="hljs-comment"><span class="hljs-comment">// Initializing the cache.  for (int i = 1; i &lt;= ENTRIES_COUNT; i++)    cache.put(i, new Account(i, 100));  System.out.println("Accounts before transfers");  System.out.println();  printAccounts(cache);  printTotalBalance(cache);  IgniteRunnable run1 = new MyIgniteRunnable(cache, ignite,1);  IgniteRunnable run2 = new MyIgniteRunnable(cache, ignite,2);  List&lt;IgniteRunnable&gt; arr = Arrays.asList(run1, run2);  ignite.compute().run(arr); } ... private void transferMoney(int fromAccountId, int toAccountId) {  Account fromAccount = cache.get(fromAccountId);  Account toAccount = cache.get(toAccountId);  int amount = getRandomAmount(fromAccount.balance);  if (amount &lt; 1) {      return;  }  int fromAccountBalanceBeforeTransfer = fromAccount.balance;  int toAccountBalanceBeforeTransfer = toAccount.balance;  fromAccount.withdraw(amount);  toAccount.deposit(amount);  cache.put(fromAccountId, fromAccount);  cache.put(toAccountId, toAccount); }</span></span></code> </pre><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3RPeJlYNDFg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Der Gesamtbetrag betr√§gt 1296 USD.  Kunden freuen sich, die Bank erleidet Verluste.  Warum ist das passiert? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed1/636/2fd/ed16362fd78ed83f0ecb703941eb2596.png"><br><br>  Hier sehen wir, wie zwei Aufgaben gleichzeitig den Status von Konto A √§ndern. Die zweite Aufgabe kann jedoch ihre √Ñnderungen fr√ºher als die erste aufzeichnen.  Dann zeichnet die erste Aufgabe ihre √Ñnderungen auf, und alle von der zweiten Aufgabe vorgenommenen √Ñnderungen verschwinden sofort.  Diese Anomalie wird als Problem verlorener Updates bezeichnet. <br><br>  Damit die Anwendung ordnungsgem√§√ü funktioniert, muss unsere Datenbank ACID-Transaktionen unterst√ºtzen, und unser Code sollte dies ber√ºcksichtigen. <br><br>  Schauen wir uns die ACID-Eigenschaften f√ºr unsere Anwendung an, um zu verstehen, warum dies so wichtig ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/210/b47/f2f210b470dc23068ac49e0b68b54de3.png" width="315" height="315"><br><br><ul><li>  <i>A - Atomizit√§t, Atomizit√§t.</i>  Entweder werden alle vorgeschlagenen √Ñnderungen an der Datenbank vorgenommen, oder es wird nichts vorgenommen.  Das hei√üt, wenn zwischen den Schritten 3 und 6 ein Fehler aufgetreten ist, sollten sich die √Ñnderungen nicht in der Datenbank befinden <br></li><li>  <i>C - Konsistenz, Integrit√§t.</i>  Nach Abschluss der Transaktion muss die Datenbank in einem konsistenten Zustand bleiben.  In unserem Beispiel bedeutet dies, dass die Summe von A und B immer gleich sein sollte, der Gesamtbetrag betr√§gt 1000 USD. <br></li><li>  <i>I - Isolation, Isolation.</i>  Transaktionen sollten sich nicht gegenseitig beeinflussen.  Wenn eine Transaktion eine √úberweisung vornimmt und die andere nach Schritt 3 und bis zu Schritt 6 den Wert von Konto A und B erh√§lt, glaubt sie, dass das System weniger Geld als n√∂tig hat.  Hier gibt es Nuancen, auf die ich mich sp√§ter konzentrieren werde. <br></li><li>  <i>D - Haltbarkeit</i>  Nachdem die Transaktion √Ñnderungen an der Datenbank festgeschrieben hat, sollten diese √Ñnderungen nicht aufgrund von Fehlern verloren gehen. <br></li></ul><br>  Bei der transferMoney-Methode f√ºhren wir also eine Geld√ºberweisung innerhalb der Transaktion durch. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart()) {      Account fromAccount = cache.get(fromAccountId);      Account toAccount = cache.get(toAccountId);      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;      }      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fromAccountBalanceBeforeTransfer = fromAccount.balance;      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> toAccountBalanceBeforeTransfer = toAccount.balance;          fromAccount.withdraw(amount);      toAccount.deposit(amount);          cache.put(fromAccountId, fromAccount);      cache.put(toAccountId, toAccount);          tx.commit();  } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){      e.printStackTrace();  } }</code> </pre><br>  Starten Sie die Anwendung. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pEgyqAUAvM8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hm.  Transaktionen haben nicht geholfen.  Der Gesamtbetrag betr√§gt 6951 $!  Was ist das Problem mit diesem Anwendungsverhalten? <br><br>  Zuerst w√§hlten sie den ATOMIC-Cache-Typ, d.h.  ohne ACID-Transaktionsunterst√ºtzung: <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.TOMIC);</code> </pre> <br>  Zweitens verf√ºgt die txStart-Methode √ºber zwei wichtige Parameter des Aufz√§hlungstyps, die angegeben werden sollten: die Sperrmethode (Parallelit√§tsmodus in Apache Ignite) und die Isolationsstufe.  Abh√§ngig von den Werten dieser Parameter kann eine Transaktion Daten auf unterschiedliche Weise lesen und schreiben.  In Apache Ignite werden diese Parameter wie folgt festgelegt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart( ,  )) { Account fromAccount = cache.get(fromAccountId); Account toAccount = cache.get(toAccountId); ...  tx.commit(); }</code> </pre><br>  Sie k√∂nnen PESSIMISTIC (pessimistische Sperre) oder OPTIMISTIC (optimistische Sperre) als Wert des Parameters LOCK METHOD verwenden.  Sie unterscheiden sich im Moment der Blockierung.  Bei Verwendung von PESSIMISTIC wird die Sperre beim ersten Lesen / Schreiben auferlegt und gehalten, bis die Transaktion festgeschrieben wird.  Wenn beispielsweise eine Transaktion mit einer pessimistischen Sperre eine √úbertragung von Konto A auf Konto B durchf√ºhrt, k√∂nnen andere Transaktionen die Werte dieser Konten erst lesen oder schreiben, wenn die Transaktion, die die √úbertragung vornimmt, festgeschrieben wurde.  Es ist klar, dass andere Transaktionen, die auf die Konten A und B zugreifen m√∂chten, gezwungen sind, auf den Abschluss der Transaktion zu warten, was sich negativ auf die Gesamtleistung der Anwendung auswirkt.  Das optimistische Sperren schr√§nkt den Zugriff auf Daten f√ºr andere Transaktionen nicht ein. W√§hrend der Vorbereitungsphase der Transaktion f√ºr das Festschreiben (Vorbereitungsphase, Apache Ignite verwendet das 2PC-Protokoll) wird jedoch eine √úberpr√ºfung durchgef√ºhrt. Haben sich die Daten bei anderen Transaktionen ge√§ndert?  Und wenn √Ñnderungen vorgenommen wurden, wird die Transaktion abgebrochen.  In Bezug auf die Leistung l√§uft OPTIMISTIC schneller, eignet sich jedoch besser f√ºr Anwendungen, bei denen keine Konkurrenz zu Daten besteht. <br><br>  Der Parameter INSULATION LEVEL bestimmt den Grad der Isolation von Transaktionen voneinander.  Der SQL ANSI / ISO-Standard definiert vier Arten der Isolation. F√ºr jede Isolationsstufe kann dasselbe Transaktionsszenario zu unterschiedlichen Ergebnissen f√ºhren. <br><br><ul><li>  READ_UNCOMMITED ist die niedrigste Isolationsstufe.  Transaktionen k√∂nnen "schmutzige" nicht festgeschriebene Daten anzeigen. <br></li><li>  READ_COMMITTED - Wenn eine Transaktion nur sensible Daten in sich sieht <br></li><li>  REPEATABLE_READ - bedeutet, dass dieser Lesevorgang wiederholbar sein muss, wenn innerhalb der Transaktion ein Lesevorgang durchgef√ºhrt wird. <br></li><li>  SERIALIZABLE - Diese Ebene setzt den maximalen Grad der Transaktionsisolation voraus - als ob sich keine anderen Benutzer im System befinden.  Das Ergebnis paralleler Transaktionen ist so, als ob sie in der richtigen Reihenfolge ausgef√ºhrt w√ºrden.  Zusammen mit einem hohen Ma√ü an Isolation erhalten wir jedoch eine Leistungsminderung.  Daher m√ºssen Sie die Wahl dieser Isolationsstufe sorgf√§ltig treffen. <br></li></ul><br>  F√ºr viele moderne DBMS (Microsoft SQL Server, PostgreSQL und Oracle) lautet die Standardisolationsstufe READ_COMMITTED.  In unserem Beispiel w√§re dies fatal, da es uns nicht vor verlorenen Updates sch√ºtzt.  Das Ergebnis ist das gleiche, als h√§tten wir √ºberhaupt keine Transaktionen verwendet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/32a/a26/0a6/32aa260a65aa3ad758dbecc220eef231.png"><br><br>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Ignite-Transaktionsdokumentation k√∂nnen</a> wir eine Kombination aus Sperrmethode und Isolationsstufe verwenden: <br><br><ul><li>  <b>PESSIMISTIC REPEATABLE_READ</b> - Die Sperre wird beim ersten Lesen oder Schreiben von Daten auferlegt und bis zu ihrem <b>Abschluss beibehalten</b> . <br></li><li>  <b>PESSIMISTIC SERIALIZABLE</b> - funktioniert √§hnlich wie PESSIMISTIC REPEATABLE_READ <br></li><li>  <b>OPTIMISTIC SERIALIZABLE</b> - Die Version der Daten, die nach dem ersten Lesen erhalten wurden, wird gespeichert. Wenn sich diese Version w√§hrend der Vorbereitungsphase f√ºr das Commit unterscheidet (die Daten wurden durch eine andere Transaktion ge√§ndert), wird die Transaktion abgebrochen.  Versuchen wir diese Option. <br></li></ul><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart(OPTIMISTIC, SERIALIZABLE)) { Account fromAccount = cache.get(fromAccountId); Account toAccount = cache.get(toAccountId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fromAccountBalanceBeforeTransfer = fromAccount.balance; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> toAccountBalanceBeforeTransfer = toAccount.balance; fromAccount.withdraw(amount); toAccount.deposit(amount); cache.put(fromAccountId, fromAccount); cache.put(toAccountId, toAccount); tx.commit(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ e.printStackTrace(); } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/vPZcW7qbvvs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hurra, bekam wie erwartet 1.000 Dollar.  Beim dritten Versuch. <br><br><h2>  Testen unter Last </h2><br>  Jetzt werden wir unseren Test realistischer machen - wir werden unter Last testen.  Und f√ºgen Sie einen zus√§tzlichen Serverknoten hinzu.  Es gibt viele Tools f√ºr die Durchf√ºhrung von Stresstests. Bei Sberbank verwenden wir das HP Performance Center.  Dies ist ein ziemlich leistungsf√§higes Tool, das mehr als 50 Protokolle unterst√ºtzt, f√ºr gro√üe Teams entwickelt wurde und viel Geld kostet.  Ich habe mein Beispiel auf JMeter geschrieben - es ist kostenlos und l√∂st unser Problem zu 100%.  Ich m√∂chte den Code nicht in Java umschreiben, daher werde ich den JSR223-Sampler verwenden. <br><br>  Wir erstellen ein JAR-Archiv aus den Klassen unserer Anwendung und laden es in den Testplan.  F√ºhren Sie die CreateCache-Klasse aus, um den Cache zu erstellen und zu f√ºllen.  Nach dem Initialisieren des Caches k√∂nnen Sie das JMeter-Skript ausf√ºhren. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/i7jUnyfz_88" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Alles ist cool, hat 1.000 Dollar. <br><br><h2>  Notfall-Herunterfahren des Clusterknotens </h2><br>  Jetzt werden wir destruktiver: W√§hrend des Clusterbetriebs st√ºrzen wir einen der beiden Serverknoten ab.  √úber das Visor-Dienstprogramm, das im Gridgain-Paket enthalten ist, k√∂nnen wir den Apache Ignite-Cluster √ºberwachen und verschiedene Datenbeispiele erstellen.  F√ºhren Sie auf der Registerkarte SQL Viewer eine SQL-Abfrage aus, um den Gesamtsaldo f√ºr alle Konten abzurufen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/phUdYiMrPLg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Was ist das  553 Dollar.  Kunden haben Angst, die Bank erleidet Reputationsverluste.  Was haben wir diesmal falsch gemacht? <br><br>  Es stellt sich heraus, dass es in Apache Ignite Cache-Typen gibt: <br><br><ul><li>  partitioniert - Eine oder mehrere Sicherungskopien werden im Cluster gespeichert <br></li><li>  Replizierte Caches - Alle Partitionen (alle Teile des Caches) werden auf einem Server gespeichert.  Solche Caches eignen sich haupts√§chlich f√ºr Nachschlagewerke - etwas, das sich selten √§ndert und oft gelesen wird. <br></li><li>  lokal - alles auf einem Knoten <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/032/23e/360/03223e3607e052fe4f0e3f24aca15837.png" width="600" height="344"><br><br>  Wir werden unsere Daten h√§ufig √§ndern, daher w√§hlen wir einen partitionierten Cache aus und f√ºgen ihm eine zus√§tzliche Sicherung hinzu.  Das hei√üt, wir haben zwei Kopien der Daten - die prim√§re und die Sicherung. <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL); cfg.setCacheMode(CacheMode.PARTITIONED); cfg.setBackups(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Wir starten die Anwendung.  Ich erinnere Sie daran, dass wir vor √úberweisungen 1000 Dollar haben.  Wir starten und ‚Äûl√∂schen‚Äú w√§hrend des Betriebs einen der Knoten <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1Y0C9eaTXFk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Im Visor-Dienstprogramm f√ºhren wir eine SQL-Abfrage durch, um einen Gesamtbetrag von 1000 US-Dollar zu erhalten.  Alles hat super geklappt! <br><br><h2>  Zuverl√§ssigkeitsf√§lle </h2><br>  Vor zwei Jahren haben wir gerade damit begonnen, das neue Sberbank-IT-System zu testen.  Irgendwie gingen wir zu unseren Escort-Ingenieuren und fragten: Was k√∂nnte √ºberhaupt kaputt gehen?  Sie antworteten uns: Alles kann kaputt gehen, alles testen!  Diese Antwort passte nat√ºrlich nicht zu uns.  Wir setzten uns zusammen, analysierten die Fehlerstatistik und stellten fest, dass der wahrscheinlichste Fall ein Knotenfehler ist. <br><br>  Dar√ºber hinaus kann dies aus ganz anderen Gr√ºnden geschehen.  Beispielsweise kann eine Anwendung abst√ºrzen, ein JVM-Absturz, ein Betriebssystemabsturz oder ein Hardwarefehler. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68c/ea2/035/68cea2035db5f01d47e48943a2c8797a.png" width="600" height="197"><br><br>  Wir haben alle m√∂glichen Fehlerf√§lle in 4 Gruppen unterteilt: <br><br><ol><li>  Ausr√ºstung <br></li><li>  Netzwerk <br></li><li>  Software <br></li><li>  Andere <br></li></ol><br>  Sie entwickelten Tests f√ºr sie und nannten sie F√§lle von Zuverl√§ssigkeit.  Ein typischer Zuverl√§ssigkeitsfall besteht aus einer Beschreibung des Systemzustands vor den Tests, Schritten zur Reproduktion des Fehlers und einer Beschreibung des erwarteten Verhaltens w√§hrend des Fehlers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/201/bc5/484/201bc5484c7811d1a70bb8da502e3ad9.png" width="600" height="313"><br><br><h4>  Zuverl√§ssigkeitsf√§lle: Ausr√ºstung </h4><br>  Diese Gruppe umfasst F√§lle wie: <br><br><ul><li>  Stromausfall <br></li><li>  Vollst√§ndiger Verlust des Zugriffs auf die Festplatte <br></li><li>  Ausfall eines Festplattenzugriffspfads <br></li><li>  CPU, RAM, Festplatte, Netzwerklast <br></li></ul><br>  Der Cluster speichert 4 identische Kopien jeder Partition: eine prim√§re Partition und drei Sicherungspartitionen.  Angenommen, ein Knoten verl√§sst einen Cluster aufgrund eines Ger√§teausfalls.  In diesem Fall sollten die Hauptpartitionen zu anderen √ºberlebenden Knoten verschoben werden. <br><br>  Was k√∂nnte sonst noch passieren?  Verlust des Gestells in der Zelle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44d/2b8/132/44d2b81324d9a0d91ee63a5508652456.png" width="600" height="251"><br><br>  Alle Knoten der Zelle befinden sich in unterschiedlichen Racks.  Das hei√üt,  Die Rack-Ausgabe f√ºhrt nicht zu Clusterfehlern oder Datenverlust.  Wir werden drei Exemplare von vier haben.  Aber selbst wenn wir das gesamte Rechenzentrum verlieren, wird es f√ºr uns kein gro√ües Problem sein, denn  Wir haben noch zwei weitere Kopien der Daten von vier. <br><br>  Einige F√§lle werden mit Unterst√ºtzung von Support-Ingenieuren direkt im Rechenzentrum ausgef√ºhrt.  Schalten Sie beispielsweise die Festplatte aus und den Server oder das Rack aus. <br><br><h4>  Zuverl√§ssigkeitsf√§lle: Netzwerk </h4><br>  Um F√§lle im Zusammenhang mit der Netzwerkfragmentierung zu testen, verwenden wir iptables.  Und mit dem NetEm-Dienstprogramm emulieren wir: <br><br><ul><li>  Netzwerkverz√∂gerungen mit unterschiedlicher Verteilungsfunktion <br></li><li>  Paketverlust <br></li><li>  Paketwiederholung <br></li><li>  Pakete neu anordnen <br></li><li>  Paketverzerrung <br></li></ul><br>  Ein weiterer interessanter Netzwerkfall, den wir testen, ist Split-Brain.  In diesem Fall sind alle Knoten des Clusters aktiv, k√∂nnen jedoch aufgrund der Netzwerksegmentierung nicht miteinander kommunizieren.  Der Begriff stammt aus der Medizin und bedeutet, dass das Gehirn in zwei Hemisph√§ren unterteilt ist, von denen jede sich als einzigartig betrachtet.  Das gleiche kann mit einem Cluster passieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/778/cc0/58e/778cc058e68e7d552b612f9389af7499.png"><br>  Es kommt vor, dass zwischen Rechenzentren die Verbindung verschwindet.  Beispielsweise f√ºhrte ein Kunde der Banken der Banken Tochka, Otkrytie und Rocketbank im vergangenen Jahr aufgrund einer Besch√§digung des Glasfaserkabels durch einen Bagger mehrere Stunden lang keine Transaktionen √ºber das Internet durch, die Terminals akzeptierten keine Karten und Geldautomaten funktionierten nicht.  √úber diesen Unfall wurde auf Twitter viel geschrieben. <br><br>  In unserem Fall sollte die Split-Brain-Situation korrekt behandelt werden.  Ein Gitter identifiziert ein geteiltes Gehirn, das einen Cluster in zwei Teile teilt.  Eine H√§lfte geht in den Lesemodus.  Dies ist die H√§lfte, in der sich mehr lebende Knoten befinden oder der Koordinator sich befindet (der √§lteste Knoten im Cluster). <br><br><h4>  Zuverl√§ssigkeitsf√§lle: Software </h4><br>  Dies sind F√§lle im Zusammenhang mit dem Ausfall verschiedener Subsysteme: <br><br><ul><li>  DPL ORM - Datenzugriffsmodul, z. B. Hibernate ORM <br></li><li>  Intermodularer Transport - Messaging zwischen Modulen (Microservices) <br></li><li>  Protokollierungssystem <br></li><li>  Zugangssystem <br></li><li>  Apache Ignite Cluster <br></li><li>  ... <br></li></ul><br>  Da die meiste Software in Java geschrieben ist, sind wir anf√§llig f√ºr alle Probleme, die mit Java-Anwendungen verbunden sind.  Testet verschiedene Garbage Collector-Einstellungen.  Ausf√ºhren von Tests mit einem Absturz der Java Virtual Machine. <br><br>  F√ºr den Apache Ignite-Cluster gibt es Sonderf√§lle f√ºr Off-Heap - dies ist der Speicherbereich, den Apache Ignite steuert.  Es ist viel gr√∂√üer als Java-Heap und dient zum Speichern von Daten und Indizes.  Hier k√∂nnen Sie beispielsweise den √úberlauf testen.  Wir laufen au√üerhalb des Heaps √ºber und sehen, wie der Cluster funktioniert, wenn einige der Daten nicht in den RAM passen, d. H.  von der Festplatte lesen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d97/cb0/29a/d97cb029adf7075f155c3f68332b3a80.png" width="600" height="374"><br><br><h4>  Andere F√§lle </h4><br>  Dies sind F√§lle, die nicht in den ersten drei Gruppen enthalten sind.  Dazu geh√∂ren Dienstprogramme, die die Datenwiederherstellung im Falle eines schweren Unfalls oder bei der Migration von Daten in einen anderen Cluster erm√∂glichen. <br><br><ul><li>  Das Dienstprogramm zum Erstellen von Snapshots (Backup) von Daten - Testen von vollst√§ndigen und inkrementellen Snapshots. <br></li><li>  Wiederherstellung zu einem bestimmten Zeitpunkt - PITR-Mechanismus (Point-in-Time Recovery). <br></li></ul><br><h2>  Dienstprogramme zur Fehlerinjektion </h2><br>  Ich erinnere mich an den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> zu Beispielen aus meinem Bericht.  Sie k√∂nnen die Apache Ignite-Distribution von der offiziellen Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herunterladen</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Ignite Downloads</a> .  Und jetzt werde ich die Dienstprogramme, die wir bei Sberbank verwenden, teilen, wenn Sie sich pl√∂tzlich f√ºr das Thema interessieren. <br><br>  Frameworks <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jepsen</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chaosaffe</a> <br></li></ul><br>  Konfigurationsmanagement: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ansible</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Marionette</a> <br></li></ul><br>  Linux-Dienstprogramme: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetEm (tc)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stress-ng</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iperf</a> <br></li><li>  t√∂te -9 <br></li><li>  iptables <br></li></ul><br>  Lasttest-Tools: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jmeter</a> <br></li></ul><br>  Sowohl in der modernen Welt als auch in der Sberbank sind alle Ver√§nderungen dynamisch und es ist schwierig vorherzusagen, welche Technologien in den n√§chsten Jahren eingesetzt werden.  Aber ich wei√ü mit Sicherheit, dass wir die Fehlerinjektionsmethode verwenden werden.  Die Methode ist universell - sie eignet sich zum Testen jeder Technologie, funktioniert wirklich, hilft, viele Fehler zu erkennen und die von uns entwickelten Produkte besser zu machen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433468/">https://habr.com/ru/post/de433468/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433448/index.html">Vergleichende Analyse der Gebrauchtm√§rkte Deutsche und franz√∂sische Autos im B- und C-Segment</a></li>
<li><a href="../de433450/index.html">Wachsen und lehren. Wie wir uns mit PEGA angefreundet haben</a></li>
<li><a href="../de433456/index.html">So √ºberzeugen Sie einen Kunden oder ein Unternehmen von Flutter</a></li>
<li><a href="../de433464/index.html">Subkosmische Rasse</a></li>
<li><a href="../de433466/index.html">Seiten vergleichen. Einfaches Plugin f√ºr Atlassian Confluence</a></li>
<li><a href="../de433472/index.html">Unity 2018.3 ver√∂ffentlicht</a></li>
<li><a href="../de433474/index.html">Pylint von innen nach au√üen. Wie macht er das?</a></li>
<li><a href="../de433476/index.html">50 Selleriet√∂ne</a></li>
<li><a href="../de433478/index.html">Warum Django im Tinkoff Magazine ausgew√§hlt wird</a></li>
<li><a href="../de433480/index.html">Holivarny Geschichte √ºber Linter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>