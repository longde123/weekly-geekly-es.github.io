<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🏭 📛 🚊 Kualitas kode 👧🏽 👦 ⛹🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kualitas kode adalah tema yang lahir dengan pemrograman. ISO 9000 digunakan untuk menilai dan mengontrol kualitas manajemen perusahaan, GOST dan ISO y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kualitas kode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433326/">  Kualitas kode adalah tema yang lahir dengan pemrograman.  ISO 9000 digunakan untuk menilai dan mengontrol kualitas manajemen perusahaan, GOST dan ISO yang sama digunakan untuk produk, tetapi tidak ada kode GOST untuk penilaian kualitas.  Tidak ada definisi dan standar yang pasti untuk kualitas kode. <br><br><img src="https://habrastorage.org/webt/g7/lf/vf/g7lfvflqvaed3arisqbaikdvrhi.jpeg"><br><br>  Setiap pengembang memahami kualitas dengan caranya sendiri, berdasarkan pengalaman.  Pandangan para joon dan lead berbeda, dan ini mengarah pada ketidaksepakatan.  Setiap tim untuk masing-masing proyek mengevaluasi kode dengan caranya sendiri.  Tim sedang diperbarui, pengembang pergi, pemimpin tim berubah - definisi kualitas berubah.  <strong>Ivan Botanov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">StressoID</a> ) dari Tinkoff.ru, Frontend-developer, tutor online tentang Angular, pembicara di rapat dan konferensi, tutor di YouTube dan kadang-kadang pelatih tim di perusahaan, akan mencoba membantu menyelesaikan masalah ini. <br><br>  Dalam menguraikan laporan Ivan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf, kami</a> akan berbicara tentang keterbacaan, penamaan, deklaratifitas, gaya kode, dan secara tidak langsung menyentuh hubungan joon dan lead: kesalahan, garu, dan “pembakaran” timlids. <br><br>  <em>Penafian:</em> Persiapkan diri Anda secara mental, <em>akan ada banyak kode buruk</em> dalam teks <em>, yang diambil dari situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"khusus"</a> .</em> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dpkKf-Nkwcw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Sedikit sejarah <br></h2><br>  Kita semua menulis dengan cara yang berbeda.  Anda mungkin telah memperhatikan ini ketika Anda mengubah tempat kerja, proyek, atau tim Anda - hal-hal yang tidak biasa langsung terlihat jelas.  Ini juga terjadi pada saya berkali-kali, karena itulah laporan ini lahir.  Saya fokus pada pengembang pemula, tetapi artikel ini akan bermanfaat bagi mereka yang sudah lebih banyak mengelola daripada menulis, atau menyesuaikan proses pengembangan.  Apa yang akan kita bicarakan: <br><br><ul><li>  Tentang masalah kode yang tidak dapat dibaca. </li><li>  Mari kita bahas penamaan. </li><li>  Mari kita lihat apa perbedaan antara gaya deklaratif dan imperatif, dan apa masalahnya. </li><li>  Tentang modularisasi dan pengetikan kode. </li><li>  Tentang gaya kode dan hutang teknis, tentang komitmen dan alur git. </li><li>  Tentang alat yang dapat Anda gunakan, dan memperbaiki kesalahan pada prod. </li></ul><br>  Sebelum kita mulai, saya akan mengajukan pertanyaan: <strong>"Berapa banyak programmer yang harus bus lepas landas agar proyek berhenti berkembang?"</strong>  .  Jawaban yang benar: semuanya. <br><br><h2>  Apa itu Faktor Bus? <br></h2><br>  Secara kondisional, Petya atau Vasya bekerja dalam sebuah tim, yang tahu segalanya tentang proyek: mereka mendatanginya, bertanya tentang ini dan itu, bagaimana cara kerjanya di sini, dan bagaimana cara kerjanya di sana.  Semua orang tergantung pada Petya, nomor bus dari proyek itu satu.  Semakin kecil angkanya, semakin sulit untuk mengembangkan proyek, karena semua orang mengganggu Petya, dan dia keren, dan harus melakukan tugas, dan tidak menjawab pertanyaan. <br><br>  Anda akan mengatakan <em>betapa kerennya menjadi Pete!</em>  <em>Semua orang mencintainya, menghargainya, membutuhkannya.</em> <br><br>  Ini tidak benar.  Biasanya, Petya adalah pemimpin tim, dan ia harus berurusan dengan tugas-tugas lain: membahas pengembangan proyek, membangun arsitektur, mengelola tim, tetapi jangan pergi ke bukit pasir dan menjelaskan mengapa itu ditulis di sini dan bukan sebaliknya. <br><br>  Jika kodenya bersih dan bagus, maka itu bagus untuk membacanya dan ada lebih sedikit pertanyaan dari jones.  <strong>Kode bersih meningkatkan kelayakan proyek dan menurunkan ambang untuk masuk</strong> .  Ketika orang baru muncul di tim, mereka akan mengajukan lebih sedikit pertanyaan.  Dalam proyek semacam <strong>itu</strong> , <strong>lebih mudah untuk menarik pengembang</strong> karena ambang masuk yang rendah. <br><br><blockquote>  Kode kualitas meningkatkan jumlah bus. <br></blockquote><br><h2>  Keterbacaan <br></h2><br>  Keterbacaan dipengaruhi oleh lekukan, penamaan yang bengkok, dan bersarang yang kuat - banyak proyek menderita karenanya.  Selain lekukan, operator ternary multi-line, kurangnya gaya Kode tunggal, kombinasi pendekatan pengembangan dan redefinisi variabel yang tidak jelas mengurangi keterbacaan.  Semua ini adalah penyebab paling umum dari keterbacaan kode yang buruk. <br><br>  Bagi saya sendiri, saya telah mengidentifikasi istilah <strong>kode linier</strong> - ini adalah kode yang dapat dibaca seperti buku. <br><br><blockquote>  Kode linear dibaca dari kiri ke kanan, dari atas ke bawah, tanpa harus kembali ke kode yang ditulis sebelumnya. <br></blockquote><br>  Contoh kode seperti itu: <br><br><pre><code class="javascript hljs">list.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element1</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element1.parent_id == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { output.push(element1); list.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element2</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element2.parent_id == element1.id) { output.push(element2); list.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element3</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element3.parent_id == element2.id) { output.push(element3); list.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element4</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element4.parent_id == element3.id) { output.push(element4); } }) } }) } }) } })</code> </pre> <br>  Kode ini linear, tetapi memiliki masalah lain - sangat bersarang.  Karena itu, kita juga harus memantau persarangan. <br><br>  Contoh kode <strong>nonlinear</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!brk &amp;&amp; html.childNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>].value &amp;&amp; html.childNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>].max) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(clear) html.childNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>].value = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(html.childNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>].value &lt;= html.childNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>].max) { ++ html.childNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>].value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(brk) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(id = <span class="hljs-number"><span class="hljs-number">1</span></span>; id &lt; html.childNodes.length; ++ id) findActive(html.childNodes[id], <span class="hljs-literal"><span class="hljs-literal">true</span></span>); html.parentNode.className = <span class="hljs-string"><span class="hljs-string">""</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { html.parentNode.className = <span class="hljs-string"><span class="hljs-string">"Ready"</span></span>; html.className = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html; } }</code> </pre><br>  Jika kita membuang semua yang berlebihan dan mencari tahu apa yang merusak linearitas, maka kita akan melihat sesuatu seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br>  Ketika ada yang lain, pertama-tama Anda harus melihat apa yang tertulis di satu tempat, kemudian di tempat lain.  Jika itu besar atau sangat bersarang jika, maka perhatian tersebar, dan kodenya sulit dibaca. <br><br><h3>  Bagaimana cara mengurangi nesting dan mencapai kode linier? <br></h3><br>  <strong>Kombinasikan kondisi</strong> .  Ini adalah hal paling sederhana yang bisa kita lakukan - bersarang jika saya dapat menggabungkan dalam kondisi dan sedikit mengurangi bersarang. <br><br>  Itu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUser()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAdmin()) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'admin'</span></span>); } }</code> </pre><br>  Itu menjadi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isUser() &amp;&amp; isAdmin()) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'admin'</span></span>); }</code> </pre><br>  Terapkan <strong>pola pengembalian awal</strong> .  Ini memungkinkan Anda untuk sepenuhnya menyingkirkan yang lain.  Saya bisa mengganti metode atau sepotong kode dengan if-else dengan pengembalian awal, dan kemudian salah satu blok kode atau yang lain akan dieksekusi.  Ini sangat mudah - Anda tidak perlu menggulir dan kembali ke beberapa bagian kode. <br><br>  Itu: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAdmin()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> admin; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user; }</code> </pre><br>  Itu menjadi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAdmin()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> admin; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user;</code> </pre><br><br>  <strong>Terapkan rantai janji</strong> .  Ini adalah kode busur derajat yang khas.  Saya menulis tes E2E belum lama ini, dan kode tersebut menyakiti mata saya: <br><br><pre> <code class="javascript hljs">ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q01_D'</span></span>)).click().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q02_C'</span></span>)).click().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q03_D'</span></span>)).click().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); }); }); })</code> </pre><br>  Dengan rantai janji, kode berubah: <br><br><pre> <code class="javascript hljs">ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q01_D'</span></span>)).click() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q02_C'</span></span>)).click(); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q03_D'</span></span>)).click(); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); });</code> </pre><br><br>  Jika kita menggunakan pengetahuan fungsi panah, kita bisa melakukan ini: <br><br><pre> <code class="javascript hljs">ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q01_D'</span></span>)).click() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q02_C'</span></span>)).click()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q03_D'</span></span>)).click()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>));</code> </pre><br>  Itu mudah dibaca, deklaratif, indah - semuanya terlihat jelas. <br><br>  <strong>Tatanan yang lebih tinggi diamati.</strong>  Karena saya seorang angular dan menggunakan RxJS, saya dihadapkan dengan masalah kuat bersarangnya kode spaghetti - nested <strong>Observable</strong> , yaitu, langganan bersarang.  Ada aliran, dan di dalam aliran Anda perlu mendapatkan nilai dan kemudian ada hubungannya dengan aliran lain.  Beberapa menulis seperti ini: <br><br><pre> <code class="javascript hljs">Observable.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> { item += <span class="hljs-number"><span class="hljs-number">2</span></span>; Observable.of(item) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function"> =&gt;</span></span> { element += <span class="hljs-number"><span class="hljs-number">1</span></span>; }) })</code> </pre><br>  Dan ini sangat mempengaruhi proyek orang dewasa.  Anda bisa melakukan ini: <br><br><pre> <code class="javascript hljs">Observable.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) .mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable.of(item + <span class="hljs-number"><span class="hljs-number">2</span></span>)) .mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable.of(element + <span class="hljs-number"><span class="hljs-number">1</span></span>)) .subscribe()</code> </pre><br>  Menerapkan pengetahuan tentang API RxJS, kami beralih dari sarang yang kuat, berkat <strong>tatanan yang lebih tinggi yang dapat diamati</strong> , dan sampai pada <strong>deklaratif</strong> .  Hal ini, yang melemparkan nilai aliran internal ke eksternal, itu saja.  Tapi ini bersih, linier, indah dan tidak diinvestasikan. <br><br><h3>  Operator ternary bersarang <br></h3><br>  Menurut pendapat saya, yang terburuk yang dapat ditemukan dalam kode adalah <strong>operator ternary bersarang</strong> .  Tulis ulang mereka pada pernyataan bersyarat blok, cobalah untuk tidak menggunakannya sama sekali.  Kami tidak akan berbicara tentang kondisi implisit sama sekali - ini adalah kegagalan. <br><br>  Contoh operator terner bersarang dan kondisi tersirat: <br><br><pre> <code class="javascript hljs">arr.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? arr[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">1</span></span> ? arr[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span> : arr[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'empty arr'</span></span>); !a &amp;&amp; b &amp;&amp; func()</code> </pre><br>  Saya menulis terner sederhana ini dalam 5 menit.  Ini memiliki panjang array dan beberapa operasi, tetapi sulit dibaca, karena di suatu tempat satu pertanyaan, di tempat lain - semuanya tidak jelas.  Kode ini dapat ditulis ulang menggunakan operator ternary multi-line: <br><br><pre> <code class="javascript hljs">arr.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? arr[<span class="hljs-number"><span class="hljs-number">1</span></span>] === <span class="hljs-number"><span class="hljs-number">1</span></span> ? arr[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span> : arr[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'empty arr'</span></span>);</code> </pre><br>  Anda akan mengatakan: <br><br>  - <em>Baik, baik!</em> <br>  - <em>Terlihat?</em> <br>  - <em>Itu terlihat!</em> <br><br>  Dan apa yang Anda katakan tentang ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> query <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span> ? (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ fn.each(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id.match(query)) { seatSet.push(id, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seatSet; })() : (query.length == <span class="hljs-number"><span class="hljs-number">1</span></span> ? (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">character</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//user searches just for a particual character fn.each(function () { if (this.char() == character) { seatSet.push(this.settings.id, this); } }); return seatSet; })(query) : (function () { //user runs a more sophisticated query, so let's see if there's a dot return query.indexOf('.') &gt; -1 ? (function () { //there's a dot which separates character and the status var parts = query.split('.'); fn.each(function (seatId) { if (this.char() == parts[0] &amp;&amp; this.status() == parts[1]) { seatSet.push(this.settings.id, this); } }); return seatSet; })() : (function () { fn.each(function () { if (this.status() == query) { seatSet.push(this.settings.id, this); } }); return seatSet; })(); })() );</span></span></code> </pre><br>  Seseorang menulis dan mendukung ternarnik ini.  Dengan mengakses bagian kode semacam itu, akan sulit untuk mengetahui di mana tanda tanya dimulai dan di mana itu berakhir.  Jika Anda menggunakan terner, jangan berinvestasi satu sama lain - ini buruk. <br><br><h2>  Penamaan <br></h2><br>  Kode buruk lain: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0x30119c = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0x3af68e = { <span class="hljs-string"><span class="hljs-string">'data'</span></span>: { <span class="hljs-string"><span class="hljs-string">'key'</span></span>: <span class="hljs-string"><span class="hljs-string">'cookie'</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>: <span class="hljs-string"><span class="hljs-string">'timeout'</span></span> }, <span class="hljs-string"><span class="hljs-string">'setCookie'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_0x3543f3, _0x13e5c1, _0x586dac, _0x1c9d63</span></span></span><span class="hljs-function">) </span></span>{ _0x1c9d63 = _0x1c9d63 || {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0x47b83f = _0x13e5c1 + <span class="hljs-string"><span class="hljs-string">'='</span></span> + _0x586dac; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0xae3be = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0xae3be = <span class="hljs-number"><span class="hljs-number">0x0</span></span>, _0x5d2845 = _0x3543f3[<span class="hljs-string"><span class="hljs-string">'length'</span></span>]; _0xae3be &lt; _0x5d2845; _0xae3be++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0x440369 = _0x3543f3[_0xae3be]; _0x47b83f += <span class="hljs-string"><span class="hljs-string">';\x20'</span></span> + _0x440369; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0x411875 = _0x3543f3[_0x440369]; _0x3543f3[<span class="hljs-string"><span class="hljs-string">'push'</span></span>](_0x411875); _0x5d2845 = _0x3543f3[<span class="hljs-string"><span class="hljs-string">'length'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_0x411875 !== !![]) { _0x47b83f += <span class="hljs-string"><span class="hljs-string">'='</span></span> + _0x411875; } } _0x1c9d63[<span class="hljs-string"><span class="hljs-string">'cookie'</span></span>] = _0x47b83f; } };</code> </pre><br><br>  Kita dapat mengatakan bahwa kode ini <strong>dikaburkan</strong> , tetapi meskipun demikian: kita melihat bahwa ada fungsi yang dapat dimengerti, 'data' yang jelas, setCookie melakukan sesuatu, dan kemudian hanya selimut dan tidak ada yang jelas - sesuatu <strong>disatukan</strong> , di suatu tempat spasi.  Semuanya sangat buruk. <br><br><h3>  Apa yang perlu Anda pertimbangkan dalam penamaan <br></h3><br>  Gunakan <strong>notasi</strong> <code>camelCaseNotation</code> : <code>camelCaseNotation</code> .  <strong>Tidak ada transliterasi, semua nama metode hanya dalam bahasa Inggris</strong> : <code>ssylka, vikup, tovar, yslyga</code> atau <code>checkTovaraNaNalichieTseni</code> adalah sebuah kegagalan.  Yang terakhir, omong-omong, saya menulis ketika saya baru saja memulai program. <br><br>  <strong>Tidak ada item, data, el, html, arr</strong> , terutama ketika iterasi melalui array.  Misalnya, untuk berbagai produk atau penawaran, pilih nama yang ramah: <code>product, offer, etc</code>  Perbedaan antara barang dan produk tidak begitu besar, tetapi keterbacaan lebih tinggi.  Bahkan jika Anda memiliki fungsi satu baris yang menambah sesuatu, nama yang ramah bisnis akan meningkatkan keterbacaan. <br><br>  <code>private_property</code> <strong>untuk properti pribadi</strong> : <code>private_property</code> .  Saya menambahkan aturan ini karena saya telah menulis TypeScript untuk tahun kedua, tetapi tidak ada pengubah akses di JS, dan dalam konvensi penamaan kami sepakat bahwa garis bawah mendefinisikan properti pribadi untuk pengembang lain. <br><br>  <strong>Konstanta dalam huruf kapital</strong> : <code>const BLOCK_WIDTH = 300;</code>  , dan <strong>nama kelas dalam huruf kapital:</strong> <code>class SomeClass</code> .  Saya menulis dalam TypeScript dan semuanya jelas di sana, semuanya jelas di <strong>ES6</strong> , tetapi ada juga proyek warisan di mana semua kelas fungsi dengan operator <code>new</code> menulis dalam huruf kapital. <br><br>  <strong>Tidak ada variabel satu huruf</strong> : <code>u = user</code> .  Ini adalah referensi untuk <strong>i</strong> - jangan.  Tulis dengan jelas, yaitu, bisnis secara fungsional.  Tidak perlu membuat metode Periksa, yang memeriksa sesuatu, tetapi apa yang tidak jelas.  Tulis <strong>nama</strong> <code>addProductToCard(); sendFeedback()</code> <strong>metode</strong> : <code>addProductToCard(); sendFeedback()</code>  <code>addProductToCard(); sendFeedback()</code> . <br><br><h2>  Ketidaksabaran <br></h2><br>  Penyimpangan kecil.  Ketidaksabaran muncul bersamaan dengan pemrograman.  Pada saat itu, mereka mengkodekan dalam Assembler, dan menulis secara imperatif: setiap perintah, setiap langkah dijelaskan secara rinci, dan sel memori ditugaskan ke nilai.  Kami tinggal di 2019 dan jadi tidak lagi menulis di JS. <br><br><img src="https://habrastorage.org/webt/zl/ra/s4/zlras4uvhmk2psu5vnew5pgxqya.jpeg"><br><br>  Ini adalah kode sederhana namun imperatif yang memiliki for, loop variabel.  Tidak jelas mengapa mereka ditambahkan di sini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> someItem = conferences[i]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prefixString = <span class="hljs-string"><span class="hljs-string">'Hello '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (someItem === <span class="hljs-string"><span class="hljs-string">'Frontend Conf'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(prefixString + someItem); } }</code> </pre><br>  Masalah kode imperatif <strong>:</strong> banyak variabel, banyak konstruksi servis dari variabel-variabel ini dan banyak komentar, karena variabel-variabel ini perlu dijelaskan entah bagaimana - Anda tidak dapat membuat variabel dan melupakannya.  Semua ini mempengaruhi keterbacaan kode. <br><br><h2>  Deklaratifitas <br></h2><br>  Gaya deklaratif telah diganti.  Kami menulis dalam JavaScript dan tersedia untuk kami.  Gaya deklaratif terlihat seperti ini: <br><br><pre> <code class="javascript hljs">conferences .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">someItem</span></span></span><span class="hljs-function"> =&gt;</span></span> someItem === <span class="hljs-string"><span class="hljs-string">'Frontend Conf'</span></span>) .forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">someItem</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello'</span></span> + someItem));</code> </pre><br>  Ini sama seperti dalam imperatif, tetapi jauh lebih mudah dan lebih dimengerti. <br><br><h3>  Manfaat kode deklaratif <br></h3><br>  Kode tersebut lebih mudah dibaca, dipelihara, dan diuji, dan konstruksi kode yang rumit dapat disembunyikan di balik metode dan abstraksi.  Anda dapat memahami perbedaan antara gaya imperatif dan gaya deklaratif dengan contoh menggoreng telur.  Untuk menggoreng telur goreng dengan gaya imperatif, kita mengambil wajan, menaruhnya di atas api, menuangkan minyak, mengambil telur, memecahkannya, menuangkannya.  Dalam gaya deklaratif, kita mengatakan: "Telur goreng", dan prosesnya akan disembunyikan di balik abstraksi.  Kami ingin menggoreng telur orak-arik, bukan untuk mencari tahu cara kerjanya. <br><br>  Masalah dimulai ketika pengembang yang tidak terlalu berpengalaman datang dari universitas tempat mereka mempelajari Pascal dan menulis seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prefix = <span class="hljs-string"><span class="hljs-string">'Hello '</span></span>; conferences .forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">someItem</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (someItem === <span class="hljs-string"><span class="hljs-string">'Frontend Conf'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = prefix + someItem; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) } });</code> </pre><br><br>  Ini adalah <strong>kombinasi dari</strong> gaya deklaratif dan imperatif.  Tidak ada keterbacaan, tidak ada keharusan penuh, beberapa variabel dan <code>if</code> .  Ini <code>if</code> orang menambahkan karena dia tidak tahu tentang filter.  Jika Anda seorang pemimpin dan melihat kode seperti itu, muncul, colokkan tautan <s>dengan tongkat</s> dan bawa kode ke deklaratif. <br><br><h3>  Membuat Variabel <br></h3><br>  Jangan membuat variabel demi variabel - ini adalah ide yang buruk.  Ketika saya mengetahui dari pengembang mengapa mereka melakukan ini, saya mendengar: <br><br>  - Yah, itu meningkatkan keterbacaan! <br><br>  Apa yang meningkatkan keterbacaan di sini - <code>const username = user.name</code> ?  Jika Anda ingin membuat variabel, beri nama signifikansi.  Misalnya, kami memiliki ekspresi reguler: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> somePattern = <span class="hljs-regexp"><span class="hljs-regexp">/[0-9]+/</span></span>; str.split(somePattern); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> someResult = a + b - c;</code> </pre><br>  Di sini saya akan membuat variabel sehingga seseorang tidak membuang waktu untuk melanjutkan, tetapi membaca bahwa ini secara teratur memeriksa telepon, dan melangkah lebih jauh.  Jika Anda memiliki operasi matematika, juga menulis ke variabel, karena, pasti, operasi matematika memiliki entitas bisnis, tengara bisnis tertentu, misalnya, untuk menghitung keranjang atau membuat diskon.  Dalam hal ini, Anda bisa membuat variabel. <br><br><blockquote>  Membuat variabel untuk membuat variabel tidak sepadan. </blockquote><br><h3>  Override variabel yang tidak jelas <br></h3><br>  Misalkan kita membuat variabel <code>element</code> , dari namanya tidak jelas apa itu.  Kami menulis <code>element</code> DOM, menulis pengesampingannya dalam array karena beberapa alasan, dan pergi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'someId'</span></span>); arr.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... //      // ... element = document.getElementById('someItem') if (typeof item === 'string') { let element = document.getElementById('some' + item); element.appendChild(); } });</span></span></code> </pre><br>  Semuanya baik-baik saja, hilang, dilupakan.  Mengikuti Petya, yang bekerja di tim kami, masuk dan menambahkan blok <code>if</code> .  Apa itu  Cukup mendefinisikan ulang variabel lagi, dan pergi.  Dan cakupannya sudah berbeda.  Ketika pengembang berikutnya mencoba memahami kode ini, terutama jika metodenya besar, ia akan menunggu <code>someId</code> atau <code>someItem</code> , dan tidak ada sama sekali.  Ini adalah tempat di mana Anda dapat kehilangan banyak waktu untuk mencari apa masalahnya.  Kami akan menulis <code>debugger</code> , meletakkan <code>brake point</code> , melihat apa yang ada - secara umum, jangan menulis seperti itu. <br><br><h3>  Pembagian menjadi metode <br></h3><br>  Kami secara singkat mempertimbangkan pembagian ke dalam metode dan dengan lancar beralih ke abstraksi. <br><br>  Metode harus membawa <strong>fungsi atom</strong> : <strong>satu metode - satu tindakan</strong> .  Jika Anda memiliki tindakan satu baris, jangan campur dulu, hanya karena metodenya sangat kecil.  Metode harus <strong>tidak lebih dari 10 baris.</strong>  Pernyataan ini memprovokasi holivar dan sekarang juga "menembak", jadi tuliskan kepada saya atau di komentar, dan saya akan menjelaskan mengapa saya menulis aturan ini. <br><br><h3>  Modularitas kode <br></h3><br>  Modularitas <strong>meningkatkan pembacaan kode</strong> dengan memisahkan menjadi abstraksi, <strong>membantu "menyembunyikan" kode yang sulit dibaca,</strong> <strong>lebih mudah untuk menguji,</strong> dan lebih mudah untuk <strong>memperbaiki kesalahan</strong> .  Saya akan jelaskan lebih detail. <br><br><h3>  Bersembunyi di balik abstraksi <br></h3><br>  Misalnya, ada kode yang membuat tombol, menetapkan id untuknya, kelas dan mengkliknya - semuanya sederhana. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'button'</span></span>); element.id = <span class="hljs-string"><span class="hljs-string">'id_button'</span></span>; element.classList = <span class="hljs-string"><span class="hljs-string">'red'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(element); element.click();</code> </pre><br>  Anda dapat menambahkan fungsi ke kode tombol, membungkusnya, dan menggunakan fungsi <code>createButton</code> saat membuat tombol: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span>.button = createButton(<span class="hljs-string"><span class="hljs-string">'id_button'</span></span>); button.click(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">') { element = document.createElement('</span></span></span></span><span class="hljs-function"><span class="hljs-params">button</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'); element.id = id; element.classList = '</span></span></span></span><span class="hljs-function"><span class="hljs-params">red</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'; document.body.appendChild(element); return element; }</span></span></span></span></span></span></code> </pre><br>  Dengan nama "berbicara", jelas fungsi apa yang dilakukan dan id dilewatkan.  Jika kita ingin membuat tombol dan tidak mengerti bagaimana itu dibuat dan mengapa, kita menulis kode menggunakan fungsi ini. <br><br><pre> <code class="javascript hljs">button.component.js <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> button = createButton(<span class="hljs-string"><span class="hljs-string">'id_button'</span></span>); button.click();</code> </pre><br>  Selanjutnya kita menulis <strong>helper</strong> , yang kemudian digunakan oleh pengembang lain.  Jika mereka ingin memahami bagaimana telur orak-arik digoreng atau ingin mengubah resep - menambah atau menghilangkan garam, mereka akan mampir dan menghormati. <br><br><pre> <code class="javascript hljs">button.helpers.js <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> button = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'button'</span></span>); button.id = id; button.classList = <span class="hljs-string"><span class="hljs-string">'red'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> button; }</code> </pre><br><h3>  Mengetik <br></h3><br>  Saya tidak akan berbicara tentang mengetik untuk waktu yang lama - ada banyak laporan.  Saya menulis dalam TypeScript, saya suka, tetapi masih ada aliran dan alat lainnya.  Jika Anda tidak mengetik di proyek Anda, maka sudah saatnya untuk mengimplementasikannya.  Ini membantu untuk men-debug banyak kesalahan. <br><br><h3>  Kode berbau <br></h3><br>  Bau kode sangat terkait dengan tema saya, karena menulis kode berkualitas buruk menghasilkan bau yang sangat.  Lihatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan keren dari Alexei Okhrimenko</a> , ia menyentuh topik ini secara rinci. <br><br><h2>  Gaya kode <br></h2><br>  Ini adalah seperangkat aturan tim, proyek, atau perusahaan yang dipatuhi pengembang.  <strong>Gaya kode yang</strong> baik berisi contoh kode yang baik dan buruk.  Itu dapat ditulis dalam alat dan tempat yang nyaman.  Kami memiliki Wiki ini, dan untuk perusahaan kecil, file di Word sudah cukup.  Anda juga dapat mengambil gaya kode yang sudah jadi, yang sudah digunakan oleh perusahaan lain: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JQuery</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Airbnb</a> - gaya kode yang paling populer. <br><br>  Jika Anda menggunakan teknologi atau kerangka kerja tertentu, mereka biasanya juga memiliki gaya kode mereka sendiri, yang patut dilihat.  Misalnya, di Angular, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Gaya Sudut</a> , atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Gaya</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bereaksi / JSX</a> dari Airbnb. <br><br>  Ini adalah contoh gaya kode kami. <br><br><img src="https://habrastorage.org/webt/3q/2v/h0/3q2vh0awwujjwunmpkg3e7iqtfe.png"><br><br>  Ini adalah bagian untuk membuat variabel, dan menjelaskan bagaimana tidak melakukan dan bagaimana melakukannya. <br><br><h2>  Utang teknis <br></h2><br>  Ini semacam pembayaran untuk fakta bahwa di suatu tempat kami pernah memotong rumput.  Seringkali hutang teknis lahir ketika kita tidak punya waktu untuk menyelesaikan tugas dan menulis pengingat untuk kembali nanti.  Dari kasus-kasus yang tidak terkait dengan fungsi bisnis, ini, misalnya, memperbarui kerangka kerja. <br><br><blockquote>  Hutang teknologi memunculkan kruk dan kode berkualitas rendah. <br></blockquote><br>  Karena hutang teknis, saya menulis kode yang buruk dan kruk.  Pengembang selanjutnya akan melihat ini, itu saja, melihat kusen dan menambahkan kruk lain: "Jika masih ada dukungan, tidak ada yang salah."  Hutang teknologi menumbuhkan kruk, kualitas hilang, yang lagi-lagi memunculkan kruk, dan mereka menumbuhkan utang teknologi lebih banyak lagi. <br><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teori "broken windows</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a>  Jika jendela pecah muncul di gedung dan itu tidak berubah, maka setelah beberapa saat jendela pecah kedua akan muncul, yang ketiga, grafiti.  Orang-orang melihat bahwa tidak ada yang mengikuti bangunan dan hukuman untuk jendela yang rusak seharusnya tidak.  Begitu juga kodenya.  Seringkali dalam proyek-proyek warisan, kode dikelilingi oleh kruk, karena Petit dan Vasya bersyarat melihat kruk dan berpikir: "Tidak apa-apa, aku akan menjadi yang pertama."  Oleh karena itu, di perusahaan normal, utang teknis diberikan waktu yang cukup - mereka mengambil kuota atau sprint teknis yang akan menyelesaikan masalah.  Jika Anda seorang pemimpin, atau entah bagaimana memengaruhi proses pembuatan sprint dan daftar tugas yang harus dikerjakan, perhatikan utang teknis - ini penting. <br><br><h2>  Repositori <br></h2><br>  Mari kita bahas pesan komit.  Gambar tersebut menunjukkan contoh pesan nyata yang saya lihat di berbagai proyek.  Menurut Anda yang mana yang informatif? <br><br><img src="https://habrastorage.org/webt/q8/72/mj/q872mjvfvpr0ykuknmkekksni6m.png"><br><br><div class="spoiler">  <b class="spoiler_title">Jawaban yang benar</b> <div class="spoiler_text">  Pesan informatif ada di blok, tetapi "menambahkan fitur", "memperbaiki bug" - tidak informatif. <br></div></div><br><h3>  Pesan komit <br></h3><br>  Saya menulis di <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebStorm</a></strong> dan menyukainya.  Di dalamnya, Anda dapat mengkonfigurasi penyorotan nomor tugas, transisi ketika Anda mengklik di Task Tracker keren.  Jika seseorang tidak menggunakan WebStorm, maka sudah saatnya, karena dengan dia, pesan komit diperoleh dalam kualitas tinggi.  Apakah pesan komit berkualitas?  Ini adalah komit, di mana ada <strong>nomor tugas</strong> dan pernyataan singkat tapi ringkas dari <strong>esensi perubahan</strong> <strong>:</strong> "membuat modul baru", "menambahkan tombol", "menambahkan fitur di mana komponen dibuat", dan bukan "fitur tambahan" tanpa wajah.  Saat melihat komit, akan jelas di mana komponen ditambahkan dan di mana bug diperbaiki.  Bahkan dalam pesan komit, perlu untuk menunjukkan <strong>jenis perubahan</strong> <strong>:</strong> fitur, perbaikan bug, sehingga jelas di mana perubahan terjadi. <br><br><h3>  Gitflow <br></h3><br>  Saya akan berbicara tentang Gitflow secara singkat.  Penjelasan terperinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan artikel Vincent Driessen</a> .  Gitflow adalah salah satu model manajemen repositori paling populer dan sangat sukses, yang memiliki <strong>cabang utama</strong> - mengembangkan, menguasai, preprod, prod, dan <strong>cabang sementara</strong> : fitur, bug, rilis.  Saat kami memulai tugas, kami mengalihkan cabang fitur dari cabang pengembangan.  Setelah melewati tinjauan kode pada cabang fitur, kami menuangkannya kembali ke pengembangan.  Pada akhirnya, kami mengumpulkan rilis dari pengembangan dan rilis master. <br><br><img src="https://habrastorage.org/webt/e4/kk/3g/e4kk3g7gg9-wfqfl38ecmdfstvg.png"><br><br><h3>  Alat-alatnya <br></h3><br>  Yang pertama adalah <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Commitizen</a></strong> .  Ini adalah utilitas perangkat lunak yang saya pelajari belum lama ini - saya melihat, merasakan, menyukainya.  Hal ini memungkinkan Anda untuk membakukan komit pesan, memiliki antarmuka konsol yang bagus di mana Anda dapat memilih fitur.  Jika Anda memiliki komitmen dalam semangat "mengoreksi fitur" atau "memperbaiki bug", maka inilah saatnya untuk menunjukkan Commitizen kepada teman-teman Anda sehingga mereka dapat menggunakannya setidaknya sebagai permulaan, dan kemudian Anda dapat menulisnya dari kepala. <br><br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Linter</a></strong> adalah alat yang harus dimiliki di setiap proyek.  Ada banyak konfigurasi yang sudah jadi dalam linter, tetapi Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis aturan Anda sendiri</a> .  Jika Anda memiliki aturan sendiri, maka linter harus membaca aturan-aturan ini - Anda harus menulis aturan untuk gaya Kode Anda. <br>  Tautan bermanfaat pada linter: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/dustinspecker/awesome-eslint</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eslint.org</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/reid/node-jslint</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">palantir.github.io/tslint/</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> </li></ul><br>  Paragraf terpisah mengalokasikan <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sonarJS</a> .</strong>  Ini adalah alat yang memungkinkan Anda untuk mengintegrasikan validasi kode ke dalam CI.  Sebagai contoh, kami membuat permintaan tarik, dan kemudian sonarJS menulis untuk menarik permintaan tentang sekolah kami, dan entah apruvit atau tidak.  Ini keren - saya menyukainya.  Bahkan jika Vasya bersyarat berpikir bahwa kusennya tidak akan diperhatikan, sonarJS akan memperhatikan. <br><br>  Alat ini terintegrasi dengan mudah ke Jenkins.  Orang-orang kita membangun dengan cukup cepat.  Kemungkinan besar, itu terintegrasi ke dalam sistem lain, tetapi kami belum mencobanya.  SonarJS masih memeriksa kode untuk bau kode.  Sejujurnya, saya tidak tahu apakah orang biasa melakukan ini. <br><br>  <strong>Pemformat atau stylist</strong> adalah alat yang memformat kode sesuai dengan konfigurasi, misalnya, Lebih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cantik</a> .  Anda bisa mengonfigurasinya untuk <strong>pre-push hook</strong> , dan mendapatkan gaya kode seragam di repositori.  Petya dari tim kami dapat menempatkan 500 spasi, atau tidak menulis titik koma sama sekali - semuanya akan bersih dan indah di repositori. <br><br><blockquote>  Formatter memungkinkan Anda menyimpan kode dalam satu gaya. <br></blockquote><br>  Saya ingin menceritakan sebuah kisah yang terjadi pada kami.  Kami menerapkan Prettier dalam proyek yang menulis banyak tugas, dan memutuskan untuk tidak menjalankan keseluruhan proyek melaluinya, tetapi hanya potongan kode dengan fitur.  Tampaknya bagi kita bahwa secara bertahap kita akan keluar dan tidak merusak sejarah komitmen: dalam anotasi akan terlihat siapa yang berkuasa.  Itu adalah keputusan yang buruk.  Ketika kami melakukan tugas dan menarik permintaan, dan mengubah beberapa baris, kemudian Prettier memformat seluruh file, dan ketika kami menonton permintaan tarik - hanya dua baris!  Ini memakan waktu satu ton ulasan kode.  Karena itu, <strong>jika Anda ingin menerapkan Prettier, jalankan seluruh proyek</strong> . <br><br>    — <strong>error tracking</strong>  runtime. ,     ,    .  -       —    . Error tracking     DOM-,  ,        .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sentry</a> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TrackJS</a>   ,    . <br><br>      Sentry,  .  Mengapa   ,   Sentry.   . <br><br><img src="https://habrastorage.org/webt/zi/wx/ua/ziwxuafsfcoonphdjgxesammrxu.jpeg"><br>   . <br><br><img src="https://habrastorage.org/webt/hh/7q/cc/hh7qccwp1liaxrjlvblcyktusry.jpeg"><br>     , ,    : «,    iOS,  ,     ,   Android  — ,    iOS». <br><br>  Sentry  <strong>StackTrace</strong> —   ,  . <br><br><img src="https://habrastorage.org/webt/qy/um/vc/qyumvcgz6gerwfs9u0bwrnaudeu.jpeg"><br>    Sentry.      ,    —  :   .     ,  ,   : «   ,     ?».  —  .       ,    .   ,      —  «»       . <br><br><h2> - <br></h2><br> -   ,    . <br><br><ul><li>       . </li><li>    —  . </li><li>     . </li><li>   .   ,     frontend-developer  Tinkoff.ru. </li><li>   Code style,    .   —  . </li><li>    —   .   ,   ,     . </li><li>  Git Flow —   ,   .         —  . </li><li>   — , .     ,     . </li></ul><br>       <strong> </strong> .   « » ,          —      ,      .      .       ,   ,      ,   .   ,    ,    . <br><br>    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Facebook</a> . <br><br><blockquote>   —     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf</a> . ?   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf ++</a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> :  , ,       . <br><br>        —    FrontendConf ++.      — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,       . ,    27  </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433326/">https://habr.com/ru/post/id433326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433316/index.html">Intisari desain: orientasi, umpan balik, cari ide dan pengambilan keputusan</a></li>
<li><a href="../id433318/index.html">garbage.collect ()</a></li>
<li><a href="../id433320/index.html">Layout Grid sebagai dasar dari layout modern</a></li>
<li><a href="../id433322/index.html">API JSON - kami bekerja sesuai dengan spesifikasi</a></li>
<li><a href="../id433324/index.html">Mengumpulkan bundel impian dengan Webpack</a></li>
<li><a href="../id433328/index.html">Lebih baik kehilangan sehari</a></li>
<li><a href="../id433330/index.html">Pecahkan teka-teki silang Jepang dengan SAT Solver</a></li>
<li><a href="../id433332/index.html">Dukungan Python di Fungsi Azure</a></li>
<li><a href="../id433334/index.html">Perilaku XAML untuk WPF sekarang adalah Open Source</a></li>
<li><a href="../id433336/index.html">Implementasi perpustakaan Babel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>