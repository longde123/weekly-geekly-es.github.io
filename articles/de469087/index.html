<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§õüèº üèè ü§ô MVCC in PostgreSQL-2. Gabeln, Dateien, Seiten ‚ùóÔ∏è üöµüèª üòÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das letzte Mal haben wir √ºber Datenkonsistenz gesprochen, den Unterschied zwischen den Ebenen der Transaktionsisolation aus Sicht des Benutzers unters...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC in PostgreSQL-2. Gabeln, Dateien, Seiten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/469087/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das letzte Mal haben</a> wir √ºber Datenkonsistenz gesprochen, den Unterschied zwischen den Ebenen der Transaktionsisolation aus Sicht des Benutzers untersucht und herausgefunden, warum dies wichtig ist.  Jetzt beginnen wir zu untersuchen, wie PostgreSQL die Snapshot-Isolation und die Multiversion-Parallelit√§t implementiert. <br><br>  In diesem Artikel werden wir uns ansehen, wie Daten physisch in Dateien und Seiten angeordnet sind.  Dies f√ºhrt uns von der Diskussion √ºber Isolation ab, aber ein solcher Exkurs ist notwendig, um das Folgende zu verstehen.  Wir m√ºssen herausfinden, wie der Datenspeicher auf niedriger Ebene organisiert ist. <br><br><h1>  Beziehungen </h1><br>  Wenn Sie sich Tabellen und Indizes ansehen, stellt sich heraus, dass sie √§hnlich organisiert sind.  Beide sind Datenbankobjekte, die einige Daten enthalten, die aus Zeilen bestehen. <br><br>  Es besteht kein Zweifel, dass eine Tabelle aus Zeilen besteht, dies ist jedoch f√ºr einen Index weniger offensichtlich.  Stellen Sie sich jedoch einen B-Baum vor: Er besteht aus Knoten, die indizierte Werte und Verweise auf andere Knoten oder Tabellenzeilen enthalten.  Es sind diese Knoten, die als Indexzeilen betrachtet werden k√∂nnen, und tats√§chlich sind sie es. <br><br>  Tats√§chlich sind einige weitere Objekte auf √§hnliche Weise organisiert: Sequenzen (im Wesentlichen einzeilige Tabellen) und materialisierte Ansichten (im Wesentlichen Tabellen, die sich an die Abfrage erinnern).  Und es gibt auch regul√§re Ansichten, die keine Daten selbst speichern, sondern in allen anderen Sinnen Tabellen √§hneln. <br><br>  Alle diese Objekte in PostgreSQL werden als allgemeine Wortbeziehung <em>bezeichnet</em> .  Dieses Wort ist √§u√üerst unpassend, weil es ein Begriff aus der relationalen Theorie ist.  Sie k√∂nnen eine Parallele zwischen einer Relation und einer Tabelle (Ansicht) ziehen, aber sicherlich nicht zwischen einer Relation und einem Index.  Aber es ist einfach so passiert: Der akademische Ursprung von PostgreSQL manifestiert sich.  Es scheint mir, dass es Tabellen und Ansichten sind, die zuerst so genannt wurden, und der Rest schwoll mit der Zeit an. <br><a name="habracut"></a><br>  Zur Vereinfachung werden wir weiter auf Tabellen und Indizes eingehen, aber die anderen <em>Beziehungen</em> sind genauso organisiert. <br><br><h1>  Gabeln und Feilen </h1><br>  Normalerweise entsprechen mehrere <em>Gabeln</em> jeder Beziehung.  Gabeln k√∂nnen verschiedene Typen haben, und jeder von ihnen enth√§lt eine bestimmte Art von Daten. <br><br>  Wenn es eine Gabel gibt, wird diese zuerst durch die einzige <em>Datei dargestellt</em> .  Der Dateiname ist eine numerische Kennung, an die eine Endung angeh√§ngt werden kann, die dem Gabelnamen entspricht. <br><br>  Die Datei w√§chst allm√§hlich und wenn ihre Gr√∂√üe 1 GB erreicht, wird eine neue Datei mit demselben Fork erstellt (Dateien wie diese werden manchmal als <em>Segmente bezeichnet</em> ).  Die Ordnungszahl des Segments wird am Ende des Dateinamens angeh√§ngt. <br><br>  Die 1-GB-Beschr√§nkung der Dateigr√∂√üe trat in der Vergangenheit auf, um verschiedene Dateisysteme zu unterst√ºtzen, von denen einige nicht mit Dateien gr√∂√üerer Gr√∂√üe umgehen k√∂nnen.  Sie k√∂nnen diese Einschr√§nkung beim <code>./configure --with-segsize</code> PostgreSQL <code>./configure --with-segsize</code> ( <code>./configure --with-segsize</code> ). <br><br>  So k√∂nnen mehrere Dateien auf der Festplatte einer Beziehung entsprechen.  F√ºr einen kleinen Tisch gibt es beispielsweise drei davon. <br><br>  Alle Dateien von Objekten, die zu einem Tabellenbereich und einer Datenbank geh√∂ren, werden in einem Verzeichnis gespeichert.  Sie m√ºssen dies ber√ºcksichtigen, da Dateisysteme normalerweise mit einer gro√üen Anzahl von Dateien in einem Verzeichnis nicht einwandfrei funktionieren. <br><br>  Beachten Sie hier, dass Dateien wiederum in <em>Seiten</em> (oder <em>Bl√∂cke</em> ) unterteilt sind, normalerweise um 8 KB.  Wir werden die interne Struktur der Seiten etwas weiter diskutieren. <br><br><img src="https://habrastorage.org/webt/10/ze/w6/10zew6_pruaxe8amjtx7_6x70tk.png"><br><br>  Schauen wir uns nun die Gabeltypen an. <br><br>  Die <strong>Hauptgabel</strong> sind die Daten selbst: die Tabellen- und Indexzeilen.  Die Hauptgabel ist f√ºr alle Beziehungen verf√ºgbar (au√üer f√ºr Ansichten, die keine Daten enthalten). <br><br>  Die Namen der Dateien der Hauptgabel bestehen aus der einzigen numerischen Kennung.  Dies ist beispielsweise der Pfad zu der Tabelle, die wir zuletzt erstellt haben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  Woher kommen diese Kennungen?  Das Verzeichnis "base" entspricht dem Tabellenbereich "pg_default".  Im n√§chsten Unterverzeichnis, das der Datenbank entspricht, befindet sich die interessierende Datei: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  Der Pfad ist relativ und wird ab dem Datenverzeichnis (PGDATA) angegeben.  Dar√ºber hinaus werden praktisch alle Pfade in PostgreSQL ab PGDATA angegeben.  Dank dessen k√∂nnen Sie PGDATA sicher an einen anderen Speicherort verschieben - nichts schr√§nkt es ein (au√üer es kann erforderlich sein, den Pfad zu Bibliotheken in LD_LIBRARY_PATH festzulegen). <br><br>  Weiter in das Dateisystem schauen: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  Der <strong>Initialisierungsgabel</strong> ist nur f√ºr nicht protokollierte Tabellen (erstellt mit UNLOGGED angegeben) und deren Indizes verf√ºgbar.  Objekte wie diese unterscheiden sich nicht von normalen Objekten, au√üer dass Operationen mit ihnen nicht im Write-Ahead-Protokoll (WAL) protokolliert werden.  Aus diesem Grund ist es schneller, mit ihnen zu arbeiten, aber es ist unm√∂glich, die Daten im Falle eines Fehlers im konsistenten Zustand wiederherzustellen.  Daher entfernt PostgreSQL w√§hrend einer Wiederherstellung einfach alle Gabeln solcher Objekte und schreibt die Initialisierungsgabel anstelle der Hauptgabel.  Dies f√ºhrt zu einem leeren Objekt.  Wir werden die Protokollierung im Detail besprechen, aber in einer anderen Serie. <br><br>  Die Tabelle "Konten" wird protokolliert und verf√ºgt daher nicht √ºber eine Initialisierungsgabel.  Aber um zu experimentieren, k√∂nnen wir die Abmeldung deaktivieren: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  Das Beispiel verdeutlicht, dass mit dem Umschreiben der Daten in Dateien mit unterschiedlichen Namen eine M√∂glichkeit verbunden ist, die Protokollierung im laufenden Betrieb ein- und auszuschalten. <br><br>  Eine Initialisierungsgabel hat denselben Namen wie die Hauptgabel, jedoch das Suffix "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  Die <strong>Freiraumkarte</strong> ist eine Abzweigung, die die Verf√ºgbarkeit von Freiraum innerhalb von Seiten verfolgt.  Dieser Raum √§ndert sich st√§ndig: Er nimmt ab, wenn neue Versionen von Zeilen hinzugef√ºgt werden, und nimmt beim Staubsaugen zu.  Die Freiraumkarte wird beim Einf√ºgen neuer Zeilenversionen verwendet, um schnell eine geeignete Seite zu finden, auf die die hinzuzuf√ºgenden Daten passen. <br><br>  Der Name der Freiraumkarte hat das Suffix "_fsm".  Diese Datei wird jedoch nicht sofort angezeigt, sondern nur bei Bedarf.  Der einfachste Weg, dies zu erreichen, ist das Staubsaugen eines Tisches (wir werden erkl√§ren, warum, wenn es soweit ist): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  Die <strong>Sichtbarkeitskarte</strong> ist eine Abzweigung, bei der Seiten, die nur aktuelle Zeilenversionen enthalten, mit einem Bit markiert sind.  In etwa bedeutet dies, dass beim Versuch einer Transaktion, eine Zeile von einer solchen Seite zu lesen, die Zeile angezeigt werden kann, ohne ihre Sichtbarkeit zu √ºberpr√ºfen.  In den n√§chsten Artikeln werden wir detailliert diskutieren, wie dies geschieht. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  Seiten </h1><br>  Wie bereits erw√§hnt, werden Dateien logisch in Seiten unterteilt. <br><br>  Eine Seite hat normalerweise die Gr√∂√üe von 8 KB.  Die Gr√∂√üe kann innerhalb bestimmter Grenzen (16 KB oder 32 KB) ge√§ndert werden, jedoch nur w√§hrend des <code>./configure --with-blocksize</code> ( <code>./configure --with-blocksize</code> ).  Eine erstellte und ausgef√ºhrte Instanz kann nur mit Seiten derselben Gr√∂√üe arbeiten. <br><br>  Unabh√§ngig davon, wo sich Dateien befinden, verwendet der Server sie auf √§hnliche Weise.  Seiten werden zuerst in den Puffercache eingelesen, wo die Prozesse sie lesen und √§ndern k√∂nnen.  Bei Bedarf werden sie dann wieder auf die Festplatte √ºbertragen. <br><br>  Jede Seite verf√ºgt √ºber eine interne Partitionierung und enth√§lt im Allgemeinen die folgenden Partitionen: <br><br><pre>        0 + ----------------------------------- +
           |  Header |
       24 + ----------------------------------- +
           |  Array von Zeigern auf Zeilenversionen |
    niedriger + ----------------------------------- +
           |  freier Speicherplatz |
    obere + ----------------------------------- +
           |  Zeilenversionen |
  spezielle + ----------------------------------- +
           |  besonderer Raum |
 Seitengr√∂√üe + ----------------------------------- +
</pre><br>  Sie k√∂nnen die Gr√∂√üe dieser Partitionen leicht mit der Erweiterungsseite "Forschung" kennenlernen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Hier sehen wir uns die <strong>Kopfzeile</strong> der allerersten (Null-) Seite der Tabelle an.  Zus√§tzlich zu den Gr√∂√üen anderer Bereiche enth√§lt die Kopfzeile andere Informationen √ºber die Seite, an denen wir noch nicht interessiert sind. <br><br>  Am Ende der Seite befindet sich der <strong>spezielle Bereich</strong> , der in diesem Fall leer ist.  Es wird nur f√ºr Indizes verwendet und auch nicht f√ºr alle.  "Unten" spiegelt hier wider, was auf dem Bild zu sehen ist.  es kann genauer sein, "in hohen Adressen" zu sagen. <br><br>  Nach dem speziellen Bereich befinden sich <strong>Zeilenversionen</strong> , <strong>dh genau</strong> die Daten, die wir in der Tabelle speichern, sowie einige interne Informationen. <br><br>  Am oberen Rand einer Seite, direkt nach der Kopfzeile, befindet sich das Inhaltsverzeichnis: das <strong>Array von Zeigern</strong> auf Zeilenversionen, die auf der Seite verf√ºgbar sind. <br><br>  Zwischen Zeilenversionen und Zeigern kann freier Speicherplatz verbleiben (dieser freie Speicherplatz wird in der Freiraumkarte nachverfolgt).  Beachten Sie, dass es innerhalb einer Seite keine Speicherfragmentierung gibt - der gesamte freie Speicherplatz wird durch einen zusammenh√§ngenden Bereich dargestellt. <br><br><h2>  Zeiger </h2><br>  Warum werden die Zeiger auf Zeilenversionen ben√∂tigt?  Die Sache ist, dass Indexzeilen irgendwie auf Zeilenversionen in der Tabelle verweisen m√ºssen.  Es ist klar, dass die Referenz die Dateinummer, die Nummer der Seite in der Datei und einige Angaben zur Zeilenversion enthalten muss.  Wir k√∂nnten den Versatz vom Anfang der Seite als Indikator verwenden, aber es ist unpraktisch.  Wir k√∂nnten eine Zeilenversion nicht innerhalb der Seite verschieben, da dadurch verf√ºgbare Referenzen besch√§digt w√ºrden.  Dies w√ºrde zu einer Fragmentierung des Platzes innerhalb der Seiten und anderen problematischen Konsequenzen f√ºhren.  Daher verweist der Index auf die Zeigernummer und der Zeiger auf die aktuelle Position der Zeilenversion auf der Seite.  Und das ist indirekte Adressierung. <br><br>  Jeder Zeiger belegt genau vier Bytes und enth√§lt: <br><br><ul><li>  ein Verweis auf die Zeilenversion </li><li>  die Gr√∂√üe dieser Zeilenversion </li><li>  mehrere Bytes, um den Status der Zeilenversion zu bestimmen </li></ul><br><h2>  Datenformat </h2><br>  Das Datenformat auf der Festplatte entspricht genau der Datendarstellung im RAM.  Die Seite wird "wie sie ist" ohne Konvertierungen in den Puffercache eingelesen.  Daher sind Datendateien von einer Plattform nicht mit anderen Plattformen kompatibel. <br><br>  In der X86-Architektur ist die Bytereihenfolge beispielsweise von niedrigstwertigen zu h√∂chstwertigen Bytes (Little-Endian), z / Architecture verwendet die umgekehrte Reihenfolge (Big-Endian), und in ARM kann die Reihenfolge vertauscht werden. <br><br>  Viele Architekturen sehen eine Datenausrichtung an den Grenzen von Maschinenw√∂rtern vor.  Auf einem 32-Bit-x86-System werden beispielsweise Ganzzahlen (Typ "Ganzzahl", die 4 Byte belegt) an einer Grenze von 4-Byte-W√∂rtern ausgerichtet, genau wie Zahlen mit doppelter Genauigkeit (Typ "doppelte Genauigkeit"). , die 8 Bytes belegt).  Bei einem 64-Bit-System werden Zahlen mit doppelter Genauigkeit an einer Grenze von 8-Byte-W√∂rtern ausgerichtet.  Dies ist ein weiterer Inkompatibilit√§tsgrund. <br><br>  Aufgrund der Ausrichtung h√§ngt die Gr√∂√üe der Tabellenzeile von der Feldreihenfolge ab.  Normalerweise ist dieser Effekt nicht sehr auff√§llig, aber manchmal kann er zu einem signifikanten Wachstum der Gr√∂√üe f√ºhren.  Wenn beispielsweise Felder vom Typ "char (1)" und "integer" verschachtelt sind, werden normalerweise 3 Bytes zwischen ihnen verschwendet.  Weitere Einzelheiten hierzu finden Sie in Nikolay Shaplovs Pr√§sentation " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tuple internals</a> ". <br><br><h1>  Zeilenversionen und TOAST </h1><br>  Wir werden das n√§chste Mal Details der internen Struktur von Zeilenversionen diskutieren.  An dieser Stelle ist es nur wichtig zu wissen, dass jede Version vollst√§ndig auf eine Seite passen muss: PostgreSQL hat keine M√∂glichkeit, die Zeile auf die n√§chste Seite zu "erweitern".  Stattdessen wird die OASTized Attributes Storage-Technik (TOAST) verwendet.  Der Name selbst deutet darauf hin, dass eine Reihe in Toast geschnitten werden kann. <br><br>  Im Scherz impliziert TOAST mehrere Strategien.  Wir k√∂nnen lange Attributwerte an eine separate interne Tabelle √ºbertragen, nachdem wir sie in kleine Toastst√ºcke aufgeteilt haben.  Eine andere M√∂glichkeit besteht darin, einen Wert so zu komprimieren, dass die Zeilenversion auf eine regul√§re Seite passt.  Und wir k√∂nnen beides tun: zuerst komprimieren und dann aufl√∂sen und √ºbertragen. <br><br>  F√ºr jede Prim√§rtabelle kann bei Bedarf eine separate TOAST-Tabelle erstellt werden, eine f√ºr alle Attribute (zusammen mit einem Index darauf).  Die Verf√ºgbarkeit potenziell langer Attribute bestimmt diesen Bedarf.  Wenn eine Tabelle beispielsweise eine Spalte vom Typ "numerisch" oder "Text" enth√§lt, wird die TOAST-Tabelle sofort erstellt, auch wenn keine langen Werte verwendet werden. <br><br>  Da eine TOAST-Tabelle im Wesentlichen eine regul√§re Tabelle ist, verf√ºgt sie √ºber denselben Satz Gabeln.  Dies verdoppelt die Anzahl der Dateien, die einer Tabelle entsprechen. <br><br>  Die anf√§nglichen Strategien werden durch die Spaltendatentypen definiert.  Sie k√∂nnen sie mit dem Befehl <code>\d+</code> in psql anzeigen. Da jedoch zus√§tzlich viele andere Informationen ausgegeben werden, werden wir den Systemkatalog abfragen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Die Namen der Strategien bedeuten: <br><br><ul><li>  plain - TOAST wird nicht verwendet (wird f√ºr Datentypen verwendet, von denen bekannt ist, dass sie kurz sind, z. B. "Ganzzahl"). </li><li>  erweitert - sowohl Komprimierung als auch Speicherung in einer separaten TOAST-Tabelle sind zul√§ssig </li><li>  extern - lange Werte werden ohne Komprimierung in der TOAST-Tabelle gespeichert. </li><li>  main - long - Werte werden zuerst komprimiert und gelangen nur dann in die TOAST - Tabelle, wenn die Komprimierung nicht geholfen hat. </li></ul><br>  Im Allgemeinen ist der Algorithmus wie folgt.  PostgreSQL zielt darauf ab, dass mindestens vier Zeilen auf eine Seite passen.  Wenn die Zeilengr√∂√üe einen Viertel der Seite √ºberschreitet, muss TOAST auf einen Teil der Werte angewendet werden, wobei der Header ber√ºcksichtigt wird (2040 Byte f√ºr eine regul√§re 8-KB-Seite).  Wir folgen der unten beschriebenen Reihenfolge und halten an, sobald die Zeile den Schwellenwert nicht mehr √ºberschreitet: <br><br><ol><li>  Zuerst gehen wir die Attribute mit den Strategien "extern" und "erweitert" vom l√§ngsten Attribut zum k√ºrzesten durch.  "Erweiterte" Attribute werden komprimiert (sofern dies wirksam ist). Wenn der Wert selbst einen Viertel der Seite √ºberschreitet, wird er sofort in die TOAST-Tabelle aufgenommen.  "Externe" Attribute werden auf die gleiche Weise verarbeitet, jedoch nicht komprimiert. </li><li>  Wenn die Zeilenversion nach dem ersten Durchgang noch nicht auf die Seite passt, √ºbertragen wir die verbleibenden Attribute mit den Strategien "extern" und "erweitert" an die Tabelle TOAST. </li><li>  Wenn dies auch nicht geholfen hat, versuchen wir, die Attribute mit der "Haupt" -Strategie zu komprimieren, lassen sie jedoch auf der Tabellenseite. </li><li>  Und nur wenn danach die Zeile nicht kurz genug ist, werden "Haupt" -Attribute in die TOAST-Tabelle aufgenommen. </li></ol><br>  Manchmal kann es n√ºtzlich sein, die Strategie f√ºr bestimmte Spalten zu √§ndern.  Wenn beispielsweise im Voraus bekannt ist, dass die Daten in einer Spalte nicht komprimiert werden k√∂nnen, k√∂nnen wir die "externe" Strategie festlegen, mit der wir Zeit sparen k√∂nnen, indem wir unn√∂tige Komprimierungsversuche vermeiden.  Dies geschieht wie folgt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  Wenn Sie die Abfrage erneut ausf√ºhren, erhalten Sie: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  TOAST-Tabellen und -Indizes befinden sich im separaten Schema pg_toast und sind daher normalerweise nicht sichtbar.  F√ºr tempor√§re Tabellen wird das Schema "pg_toast_temp_N" √§hnlich wie das √ºbliche Schema "pg_temp_N" verwendet. <br><br>  Wenn Sie m√∂chten, wird Sie nat√ºrlich niemand daran hindern, die internen Mechanismen des Prozesses auszuspionieren.  Angenommen, in der Tabelle "Konten" gibt es drei potenziell lange Attribute, und daher muss eine TOAST-Tabelle vorhanden sein.  Hier ist es: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  Es ist vern√ºnftig, dass die "einfache" Strategie auf die Toasts angewendet wird, in die die Reihe geschnitten wird: Es gibt keinen TOAST der zweiten Ebene. <br><br>  PostgreSQL versteckt den Index besser, aber es ist auch nicht schwer zu finden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  Die Spalte "Client" verwendet die Strategie "Erweitert": Ihre Werte werden komprimiert.  Lassen Sie uns √ºberpr√ºfen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  Die TOAST-Tabelle enth√§lt nichts: Wiederholte Zeichen werden gut komprimiert, und nach der Komprimierung passt der Wert auf eine normale Tabellenseite. <br><br>  Und jetzt soll der Client-Name aus zuf√§lligen Zeichen bestehen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Eine solche Sequenz kann nicht komprimiert werden und wird in die TOAST-Tabelle aufgenommen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Wir k√∂nnen sehen, dass die Daten in 2000-Byte-Bl√∂cke aufgeteilt sind. <br><br>  Wenn auf einen langen Wert zugegriffen wird, stellt PostgreSQL f√ºr die Anwendung automatisch und transparent den urspr√ºnglichen Wert wieder her und gibt ihn an den Client zur√ºck. <br><br>  Sicherlich ist es ziemlich ressourcenintensiv, zu komprimieren, aufzubrechen und dann wiederherzustellen.  Das Speichern massiver Daten in PostgreSQL ist daher nicht die beste Idee, insbesondere wenn sie h√§ufig verwendet werden und f√ºr die Verwendung keine Transaktionslogik erforderlich ist (z. B. Scans von Original-Buchhaltungsdokumenten).  Eine vorteilhaftere Alternative besteht darin, solche Daten in einem Dateisystem mit den im DBMS gespeicherten Dateinamen zu speichern. <br><br>  Die TOAST-Tabelle wird nur verwendet, um auf einen langen Wert zuzugreifen.  Au√üerdem wird f√ºr eine TOAST-Tabelle eine eigene Mutiversions-Parallelit√§t unterst√ºtzt: Wenn eine Datenaktualisierung keinen langen Wert ber√ºhrt, verweist eine neue Zeilenversion auf denselben Wert in der TOAST-Tabelle, was Platz spart. <br><br>  Beachten Sie, dass TOAST nur f√ºr Tabellen funktioniert, nicht jedoch f√ºr Indizes.  Dies begrenzt die Gr√∂√üe der zu indizierenden Schl√ºssel. <br><blockquote>  Weitere Einzelheiten zur internen Datenstruktur finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . <br></blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469087/">https://habr.com/ru/post/de469087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469073/index.html">Diskrete Ableitung oder Zusammenfassung der Summenreihen</a></li>
<li><a href="../de469075/index.html">Grokay DLR</a></li>
<li><a href="../de469077/index.html">Microsofts neuer Python-Kurs [auf Englisch]</a></li>
<li><a href="../de469079/index.html">Python in Visual Studio Code: September-Erweiterungsupdate</a></li>
<li><a href="../de469085/index.html">Wir nehmen die Software aus dem passwortgesch√ºtzten Mikrocontroller Renesas M16C heraus</a></li>
<li><a href="../de469093/index.html">Vergleich weniger popul√§rer und nicht sehr CLI-Bibliotheken: Cliff, Plac, Plumbum und andere (Teil 2)</a></li>
<li><a href="../de469095/index.html">ML.NET- und Model Builder-Updates ver√∂ffentlicht: Was ist neu?</a></li>
<li><a href="../de469097/index.html">CentOS 8 Webserver mit PHP7, Node.js und Redis</a></li>
<li><a href="../de469099/index.html">Testaufgaben beim Interview des Entwicklers - macht das Sinn?</a></li>
<li><a href="../de469101/index.html">Englisch lernen: wie man lernt, als Muttersprachler zu sprechen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>