<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏾 📘 🧕🏼 Implementasi kamus dengan Python 😇 ⚰️ 👨‍👨‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya, pada 30 April, kursus Algoritma untuk Pengembang dimulai di OTUS, dan publikasi materi hari ini didedikasikan untuk ini. Mari kita mula...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi kamus dengan Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/448350/">  Halo semuanya, pada 30 April, kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritma untuk Pengembang</a> dimulai di OTUS, dan publikasi materi hari ini didedikasikan untuk ini.  Mari kita mulai. <br><br><img src="https://habrastorage.org/webt/hq/5t/r4/hq5tr4-0h1wb2kxrkaggtq_fatm.png"><br><br>  Pada artikel ini, Anda akan belajar bagaimana kamus diimplementasikan dengan Python. <br>  Kamus diindeks menggunakan kunci, dan mereka dapat dianggap sebagai array terkait.  Mari kita tambahkan 3 pasangan kunci / nilai ke kamus: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d = {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>} &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'c'</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; d {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}</code> </pre> <a name="habracut"></a><br>  Nilai dapat diakses sebagai berikut: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>d[<span class="hljs-string"><span class="hljs-string">'a'</span></span>] <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'b'</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'c'</span></span>] <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; d[<span class="hljs-string"><span class="hljs-string">'d'</span></span>] Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; KeyError: <span class="hljs-string"><span class="hljs-string">'d'</span></span></code> </pre> <br>  Kunci <code>“d”</code> tidak ada, sehingga kesalahan KeyError akan terjadi. <br><br>  <b>Tabel hash</b> <br><br>  Kamus dengan Python diimplementasikan menggunakan tabel hash.  Mereka adalah array yang indeksnya dihitung menggunakan fungsi hash.  Tujuan dari fungsi hash adalah untuk mendistribusikan kunci secara merata dalam array.  Fungsi hash yang baik meminimalkan jumlah tabrakan, mis.  kemungkinan bahwa kunci yang berbeda akan memiliki hash yang sama.  Tidak ada fungsi hash seperti itu di Python.  Fungsi hash yang paling penting (untuk nilai string dan integer) menghasilkan nilai yang serupa dalam kasus umum: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>map(hash, (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; map(hash, (<span class="hljs-string"><span class="hljs-string">"namea"</span></span>, <span class="hljs-string"><span class="hljs-string">"nameb"</span></span>, <span class="hljs-string"><span class="hljs-string">"namec"</span></span>, <span class="hljs-string"><span class="hljs-string">"named"</span></span>)) [<span class="hljs-number"><span class="hljs-number">-1658398457</span></span>, <span class="hljs-number"><span class="hljs-number">-1658398460</span></span>, <span class="hljs-number"><span class="hljs-number">-1658398459</span></span>, <span class="hljs-number"><span class="hljs-number">-1658398462</span></span>]</code> </pre> <br>  Kami akan menganggap bahwa sampai akhir artikel ini kami akan menggunakan string sebagai kunci.  Fungsi hash dalam Python untuk string didefinisikan sebagai berikut: <br><br><pre> <code class="python hljs">arguments: string object returns: hash function string_hash: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash cached: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it set len to string<span class="hljs-string"><span class="hljs-string">'s length initialize var p pointing to 1st char of string object set x to value pointed by p left shifted by 7 bits while len &gt;= 0: set var x to (1000003 * x) xor value pointed by p increment pointer p set x to x xor length of string object cache x as the hash so we don'</span></span>t need to calculate it again <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> the hash</code> </pre> <br>  Jika Anda menjalankan <code>hash('a')</code> dengan Python, ia akan <code>12416037344</code> <code>string_hash()</code> dan mengembalikan <code>12416037344</code> .  Di sini kita menggunakan mesin 64-bit secara default. <br><br>  Jika array ukuran <code></code> digunakan untuk menyimpan pasangan nilai / kunci, maka mask akan digunakan untuk menghitung indeks sel sel dalam array, yang dihitung sebagai <code>-1</code> .  Pendekatan ini membuat penghitungan indeks sel dengan cepat.  Probabilitas menemukan sel kosong cukup tinggi karena mekanisme pengubahan ukuran, yang dijelaskan di bawah ini.  Ini berarti bahwa perhitungan sederhana masuk akal dalam banyak kasus.  Ukuran array adalah 8, indeks untuk <code>'a'</code> akan menjadi: <code>hash('a') &amp; 7 = 0</code> .  Indeks untuk <code>'b'</code> adalah 2, indeks untuk <code>'c'</code> adalah 3, indeks untuk <code>'z'</code> adalah 3, sama seperti untuk <code>'b'</code> , dan di sinilah kita mendapatkan tabrakan. <br><br><img src="https://habrastorage.org/webt/m0/uu/ie/m0uuieays-qf4xbaurxripjwdi8.png"><br><br>  Seperti yang bisa kita lihat, fungsi hash di Python melakukan tugasnya dengan cara yang berkualitas ketika kunci berurutan, yang bagus, karena Anda sering harus bekerja dengan data tersebut.  Namun, segera setelah kami menambahkan kunci <code>'z'</code> , tabrakan terjadi karena tidak konsisten dengan yang sebelumnya. <br><br>  Kita dapat menggunakan daftar tertaut untuk menyimpan pasangan, sementara memiliki hash yang sama, tetapi ini akan meningkatkan waktu pencarian, dan itu tidak akan sama dengan rata-rata O (1).  Bagian berikut ini menjelaskan metode resolusi tabrakan yang digunakan untuk kamus dengan Python. <br><br>  <b>Buka pengalamatan</b> <br><br>  Open Addressing adalah teknik resolusi tabrakan yang menggunakan probing.  Dalam kasus <code>'z'</code> , indeks sel 3 sudah digunakan dalam array, jadi kita perlu mencari indeks lain yang belum digunakan.  Operasi menambahkan pasangan kunci / nilai mengambil rata-rata O (1), serta operasi pencarian. <br><br>  Untuk mencari sel bebas, digunakan urutan pencarian kuadratik.  Diimplementasikan sebagai berikut: <br><br><pre> <code class="python hljs">j = (<span class="hljs-number"><span class="hljs-number">5</span></span>*j) + <span class="hljs-number"><span class="hljs-number">1</span></span> + perturb; perturb &gt;&gt;= PERTURB_SHIFT; use j % <span class="hljs-number"><span class="hljs-number">2</span></span>**i <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> the next table index;</code> </pre> <br>  Rekursi pada (5 * j) +1 dengan cepat meningkatkan perbedaan besar dalam bit yang tidak mempengaruhi indeks asli.  Variabel <code>"perturb"</code> dalam kasus ini mengambil bit lain dari kode hash. <br><br>  Mari kita lihat dari keingintahuan apa yang terjadi jika kita memiliki urutan sampel dengan ukuran tabel 32 dan j = 3. <br><br>  3 -&gt; 11 -&gt; 19 -&gt; 29 -&gt; 5 -&gt; 6 -&gt; 16 -&gt; 31 -&gt; 28 -&gt; 13 -&gt; 2 ... <br><br>  Anda dapat mempelajari lebih lanjut tentang urutan <a href="">penyelidikan</a> ini dengan merujuk ke kode sumber <a href="">dictobject.c</a> .  Penjelasan terperinci tentang mekanisme menyelidik dapat ditemukan di bagian atas file. <br><br><img src="https://habrastorage.org/webt/jq/vo/l3/jqvol3q4ekq8yullsftv4ylm-p4.png"><br><br>  Mari kita lihat kode sumber Python dengan contoh ini. <br><br>  <b>Struktur kamus C</b> <br><br>  Struktur C berikut digunakan untuk menyimpan entri dalam kamus: pasangan kunci / nilai.  Hash, kunci, dan nilai disimpan.  <code>PyObject</code> adalah kelas dasar untuk objek dalam Python. <br><br><pre> <code class="python hljs">typedef struct { Py_ssize_t me_hash; PyObject *me_key; PyObject *me_value; } PyDictEntry;</code> </pre> <br>  Struktur berikut adalah kamus.  <code>ma_fill</code> adalah jumlah total sel yang digunakan dan tidak aktif.  Sel dianggap tidak aktif ketika pasangan kunci dihapus.  <code>ma_used</code> adalah jumlah sel yang digunakan (aktif).  <code>ma_mask</code> sama dengan ukuran array -1 dan digunakan untuk menghitung indeks sel.  <code>ma_table</code> adalah array, dan <code>ma_smalltable</code> adalah array asli ukuran 8. <br><br><pre> <code class="python hljs">typedef struct _dictobject PyDictObject; struct _dictobject { PyObject_HEAD Py_ssize_t ma_fill; Py_ssize_t ma_used; Py_ssize_t ma_mask; PyDictEntry *ma_table; PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash); PyDictEntry ma_smalltable[PyDict_MINSIZE]; };</code> </pre> <br>  <b>Inisialisasi kosakata</b> <br><br>  Saat Anda baru saja membuat kamus, fungsi <code>PyDict_New()</code> .  Saya menghapus beberapa baris dan mengonversi kode C ke kode semu untuk fokus pada konsep-konsep kunci. <br><br>  <code>PyDict_New()</code> : <br><br><ul><li>  Mengembalikan objek kamus; </li><li>  Mengalokasikan objek kamus baru; </li><li>  Menghapus tabel kamus; </li><li>  Setel jumlah sel kamus yang digunakan dan sel yang tidak digunakan ( <code>ma_fill</code> ) menjadi 0; </li><li>  Setel jumlah sel aktif ( <code>ma_used</code> ) ke 0; </li><li>  Menetapkan topeng kamus ( <code>ma_value</code> ) ke nilai yang sama dengan ukuran kamus - 1 = 7; </li><li>  Mengatur fungsi pencarian kamus <code>lookdict_string</code> ; </li><li>  Mengembalikan objek kamus yang dialokasikan. </li></ul><br>  <b>Tambahkan item</b> <br><br>  Ketika pasangan kunci / nilai baru ditambahkan, <code>PyDict_SetItem()</code> dipanggil.  Fungsi ini menerima pointer ke objek kamus dan pasangan kunci / nilai sebagai input.  Ia memeriksa apakah kuncinya adalah string dan mengevaluasi hash atau menggunakan kembali cache jika ada.  <code>insertdict()</code> dipanggil untuk menambahkan pasangan kunci / nilai baru dan ukuran kamus berubah jika jumlah sel yang digunakan dan yang tidak digunakan lebih dari 2/3 dari ukuran array. <br><br>  Kenapa tepatnya 2/3?  Ini diperlukan untuk memastikan bahwa urutan penyelidikan dapat menemukan sel bebas dengan cukup cepat.  Nanti kita akan mempertimbangkan fungsi untuk mengubah ukuran. <br><br><pre> <code class="python hljs">arguments: dictionary, key, value returns: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> OK <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> function PyDict_SetItem: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key<span class="hljs-string"><span class="hljs-string">'s hash cached: use hash else: calculate hash call insertdict with dictionary object, key, hash and value if key/value pair added successfully and capacity over 2/3: call dictresize to resize dictionary'</span></span>s table</code> </pre> <br>  <code>inserdict()</code> menggunakan fungsi pencarian <code>lookdict_string()</code> untuk menemukan sel gratis.  Fungsi yang sama digunakan untuk mencari kunci. <br><br>  <code>lookdict_string()</code> menghitung indeks sel menggunakan nilai hash dan mask.  Jika dia tidak dapat menemukan kunci dengan nilai indeks sel = hash &amp; mask (indeks slot = hash &amp; mask), dia mulai memeriksa menggunakan siklus yang dijelaskan di atas sampai dia menemukan sel bebas.  Pada upaya pertama untuk menyelidiki, jika kuncinya adalah <code>null</code> , itu mengembalikan sel yang tidak digunakan jika ditemukan selama pencarian pertama.  Ini memastikan prioritas untuk menggunakan kembali sel yang sebelumnya dihapus. <br>  Kami ingin menambahkan pasangan kunci / nilai berikut: <code>{'a': 1, 'b': 2′, 'z': 26, 'y': 25, 'c': 5, 'x': 24}</code> .  Inilah yang akan terjadi: <br><br>  Struktur kamus dialokasikan dengan ukuran tabel 8. <br><br><ul><li>  PyDict_SetItem: key = 'a', value = 1 <br><ul><li>  hash = hash ('a') = 12416037344 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  indeks slot = hash &amp; mask = 12416037344 &amp; 7 = 0 </li><li>  slot 0 tidak digunakan, kembalikan sel ini </li></ul></li><li>  inisialisasi entri pada indeks 0 dengan kunci, nilai dan hash </li><li>  ma_used = 1, ma_fill = 1 </li></ul></li></ul></li><li>  PyDict_SetItem: key = 'b', value = 2 <br><ul><li>  hash = hash ('b') = 12544037731 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  indeks slot = hash &amp; mask = 12544037731 &amp; 7 = 3 </li><li>  slot 3 tidak digunakan, kembalikan sel ini </li></ul></li><li>  inisialisasi entri pada indeks 3 dengan kunci, nilai dan hash </li><li>  ma_used = 2, ma_fill = 2 <br></li></ul></li></ul></li><li>  PyDict_SetItem: key = 'z', value = 26 <br><ul><li>  hash = hash ('z') = 15616046971 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  indeks slot = hash &amp; mask = 15616046971 &amp; 7 = 3 </li><li>  slot 3 digunakan, coba sel lain: 5 gratis <br></li></ul><br>  inisialisasi entri pada indeks 5 dengan kunci, nilai dan hash <br>  ma_used = 3, ma_fill = 3 <br></li></ul></li></ul></li><li>  PyDict_SetItem: key = 'y', value = 25 <br><ul><li>  hash = hash ('y') = 15488046584 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  indeks slot = hash &amp; mask = 15488046584 &amp; 7 = 0 </li><li>  slot 0 digunakan, coba sel lain: 1 gratis </li></ul></li><li>  inisialisasi entri pada indeks 1 dengan kunci, nilai dan hash </li><li>  ma_used = 4, ma_fill = 4 </li></ul></li></ul></li></ul><br>  PyDict_SetItem: key = 'c', value = 3 <br><ul><li>  hash = hash ('c') = 12672038114 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  indeks slot = hash &amp; mask = 12672038114 &amp; 7 = 2 </li><li>  slot 2 tidak digunakan, kembalikan sel ini </li></ul></li><li>  inisialisasi entri pada indeks 2 dengan kunci, nilai dan hash </li><li>  ma_used = 5, ma_fill = 5 </li></ul></li></ul><br>  PyDict_SetItem: key = 'x', value = 24 <br><ul><li>  hash = hash ('x') = 15360046201 </li><li>  insertdict <br><ul><li>  lookdict_string <br><ul><li>  indeks slot = hash &amp; mask = 15360046201 &amp; 7 = 1 </li><li>  slot 1 digunakan, coba sel lain: 7 gratis </li></ul></li><li>  inisialisasi entri pada indeks 7 dengan kunci, nilai dan hash </li><li>  ma_used = 6, ma_fill = 6 </li></ul></li></ul><br>  Inilah yang kami dapatkan: <br><br><img src="https://habrastorage.org/webt/f9/wa/hf/f9wahfryuhllv1zykzjmwjcqllk.png"><br><br>  Sekarang 6 dari 8 sel digunakan, lebih dari 2/3 dari kapasitas array ditempati.  <code>dictresize()</code> dipanggil untuk mengalokasikan array yang lebih besar.  Fungsi ini juga menyalin catatan dari tabel lama ke yang baru. <br><br>  <code>dictresize ()</code> dipanggil dengan <code>minused</code> = 24 dalam kasus kami, di mana 4 * <code>ma_used</code> .  2 * <code>ma_used</code> digunakan ketika jumlah sel yang digunakan sangat besar (lebih dari 50.000).  Mengapa sel 4 kali lebih banyak?  Ini mengurangi jumlah langkah untuk menerapkan pengubahan ukuran dan meningkatkan sparseness. <br><br>  Ukuran baru tabel harus lebih besar dari 24, itu dihitung dengan menggeser ukuran saat ini dengan 1 bit ke kiri sampai ukuran tabel menjadi lebih dari 24. Akibatnya, akan menjadi 32, misalnya, 8 -&gt; 16 -&gt; 32. <br><br>  Inilah yang terjadi pada tabel kami selama mengubah ukuran: tabel baru ukuran 32 disorot. Entri tabel lama dimasukkan ke dalam tabel baru menggunakan nilai mask baru 31. Hasilnya adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/qy/ue/ke/qyueke3baeooxaxzskg8dphcpli.png"><br><br>  <b>Hapus item</b> <br><br>  <code>PyDict_DelItem()</code> dipanggil untuk menghapus catatan.  Hash dihitung untuk kunci rekaman, lalu fungsi pencarian dipanggil untuk mengembalikan catatan.  Sekarang selnya kosong. <br><br>  Kami ingin menghapus kunci c dari kamus kami.  Hasilnya, kami mendapatkan array berikut: <br><br><img src="https://habrastorage.org/webt/sw/x1/l1/swx1l1efqzzelggasprbesixdqw.png"><br><br>  Perhatikan bahwa operasi menghapus elemen tidak mengubah ukuran array jika jumlah sel yang digunakan jauh lebih sedikit dari jumlah totalnya.  Namun, ketika pasangan kunci / nilai ditambahkan, kebutuhan untuk mengubah ukuran tergantung pada jumlah sel yang digunakan dan tidak aktif, sehingga operasi penambahan juga dapat mengurangi array. <br><br>  Publikasi ini telah berakhir, dan kami secara tradisional menunggu komentar Anda dan mengundang semua orang untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelajaran terbuka</a> , yang akan diadakan pada tanggal 18 April. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448350/">https://habr.com/ru/post/id448350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448336/index.html">Seminar "Awan hibrid - pro dan kontra: apa yang harus dipersiapkan untuk bisnis dan TI" - 25 April, Moskow</a></li>
<li><a href="../id448338/index.html">Memecah dasar-dasar C #: mengalokasikan memori untuk tipe referensi pada stack</a></li>
<li><a href="../id448340/index.html">Pembuatan game 35MM. Post Apocalypse di Rusia</a></li>
<li><a href="../id448342/index.html">MyDrops - TWS murah dengan suara yang bagus dan Bluetooth yang andal</a></li>
<li><a href="../id448346/index.html">Dari GNU ke Doom: TechTrain 2019 Diumumkan</a></li>
<li><a href="../id448352/index.html">Boring Company akan menggali terowongan di Las Vegas</a></li>
<li><a href="../id448354/index.html">GraphQL Voyager sebagai alat untuk menemukan kerentanan</a></li>
<li><a href="../id448358/index.html">Kami mendengarkan musik dan ceramah dari Youtube dengan layar ponsel cerdas yang terkunci dan tanpa iklan menggunakan Telegram</a></li>
<li><a href="../id448360/index.html">Backdoor kecil di Flask atau cara mengontrol komputer di jaringan lokal</a></li>
<li><a href="../id448362/index.html">Saya pikir saya perlu mengirim desainer ke ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>