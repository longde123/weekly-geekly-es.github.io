<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¢ ü¶Å üë©üèΩ‚Äçü§ù‚Äçüë®üèø Como tornar os cont√™ineres ainda mais isolados: uma revis√£o das tecnologias de sandbox de cont√™ineres ü¶É üßïüèΩ ‚öíÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apesar de a maior parte do setor de TI implementar solu√ß√µes de infraestrutura baseadas em cont√™ineres e solu√ß√µes em nuvem, √© necess√°rio entender as li...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como tornar os cont√™ineres ainda mais isolados: uma revis√£o das tecnologias de sandbox de cont√™ineres</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/457760/">  Apesar de a maior parte do setor de TI implementar solu√ß√µes de infraestrutura baseadas em cont√™ineres e solu√ß√µes em nuvem, √© necess√°rio entender as limita√ß√µes dessas tecnologias.  Tradicionalmente, Docker, Linux Containers (LXC) e Rocket (rkt) n√£o s√£o realmente isolados porque compartilham o n√∫cleo do sistema operacional pai em seu trabalho.  Sim, eles s√£o eficazes em termos de recursos, mas o n√∫mero total de vetores de ataque estimados e perdas potenciais de hackers ainda s√£o grandes, especialmente no caso de um ambiente de nuvem com v√°rios inquilinos no qual os cont√™ineres est√£o localizados. <br><br><img src="https://habrastorage.org/webt/ls/er/x_/lserx_gyy2iflakk5liv6en4yty.png"><br><br>  A raiz do nosso problema est√° na fraca delimita√ß√£o de cont√™ineres no momento em que o sistema operacional host cria uma √°rea de usu√°rio virtual para cada um deles.  Sim, pesquisa e desenvolvimento foram conduzidos com o objetivo de criar "cont√™ineres" reais com uma caixa de areia de pleno direito.  E a maioria das solu√ß√µes resultantes leva a uma reestrutura√ß√£o dos limites entre os cont√™ineres para aumentar seu isolamento.  Neste artigo, examinaremos quatro projetos exclusivos da IBM, Google, Amazon e OpenStack, respectivamente, que usam m√©todos diferentes para atingir o mesmo objetivo: criar isolamento confi√°vel.  Portanto, o IBM Nabla implementa cont√™ineres sobre o Unikernel, o Google gVisor cria um kernel convidado especializado, o Amazon Firecracker usa um hipervisor extremamente leve para aplicativos sandbox e o OpenStack coloca os cont√™ineres em uma m√°quina virtual especializada otimizada para ferramentas de orquestra√ß√£o. <br><a name="habracut"></a><br><h3>  Vis√£o geral da moderna tecnologia de cont√™ineres </h3><br>  Os cont√™ineres s√£o uma maneira moderna de empacotar, compartilhar e implantar um aplicativo.  Ao contr√°rio de um aplicativo monol√≠tico, no qual todas as fun√ß√µes s√£o empacotadas em um programa, os aplicativos de cont√™iner ou microsservi√ßos destinam-se ao uso restrito direcionado e s√£o especializados em apenas uma tarefa. <br><br>  Um cont√™iner inclui todas as depend√™ncias (por exemplo, pacotes, bibliotecas e bin√°rios) que um aplicativo precisa para concluir sua tarefa espec√≠fica.  Como resultado, os aplicativos em cont√™ineres s√£o independentes da plataforma e podem ser executados em qualquer sistema operacional, independentemente da vers√£o ou dos pacotes instalados.  Essa conveni√™ncia poupa os desenvolvedores de uma grande parte do trabalho de adapta√ß√£o de diferentes vers√µes de software para diferentes plataformas ou clientes.  Embora conceitualmente n√£o seja totalmente preciso, muitas pessoas gostam de pensar em cont√™ineres como "m√°quinas virtuais leves". <br><br>  Quando um cont√™iner √© implantado em um host, os recursos de cada cont√™iner, como sistema de arquivos, processo e pilha de rede, s√£o colocados em um ambiente praticamente isolado que outros cont√™ineres n√£o podem acessar.  Essa arquitetura permite que centenas e milhares de cont√™ineres sejam executados simultaneamente em um √∫nico cluster, e cada aplicativo (ou microsservi√ßo) pode ser facilmente dimensionado replicando um grande n√∫mero de inst√¢ncias. <br><br>  Nesse caso, o layout do cont√™iner √© baseado em dois ‚Äúblocos de constru√ß√£o‚Äù principais: o espa√ßo para nome do Linux e os grupos de controle do Linux (cgroups). <br><br>  O espa√ßo para nome cria um espa√ßo de usu√°rio praticamente isolado e fornece ao aplicativo recursos dedicados do sistema, como sistema de arquivos, pilha de rede, ID do processo e ID do usu√°rio.  Nesse espa√ßo isolado do usu√°rio, o aplicativo controla o diret√≥rio raiz do sistema de arquivos e pode ser executado como raiz.  Esse espa√ßo abstrato permite que cada aplicativo funcione independentemente, sem interferir com outros aplicativos que residem no mesmo host.  No momento, seis namespaces est√£o dispon√≠veis: montagem, comunica√ß√£o entre processos (ipc), sistema de compartilhamento de tempo UNIX (uts), identifica√ß√£o do processo (pid), rede e usu√°rio.  √â proposto que esta lista seja complementada com dois namespaces adicionais: time e syslog, mas a comunidade Linux ainda n√£o decidiu as especifica√ß√µes finais. <br><br>  Os Cgroups fornecem limita√ß√£o, prioriza√ß√£o, monitoramento e controle de recursos de hardware.  Um exemplo dos recursos de hardware que eles podem controlar √© o processador, a mem√≥ria, o dispositivo e a rede.  Ao combinar o namespace e o cgroups, podemos executar com seguran√ßa v√°rios aplicativos no mesmo host, com cada aplicativo em seu pr√≥prio ambiente isolado - que √© a propriedade fundamental do cont√™iner. <br><br>  A principal diferen√ßa entre uma m√°quina virtual (VM) e um cont√™iner √© que a m√°quina virtual √© virtualiza√ß√£o no n√≠vel do hardware e o cont√™iner √© virtualiza√ß√£o no n√≠vel do sistema operacional.  O hipervisor da VM emula o ambiente de hardware de cada m√°quina, onde o tempo de execu√ß√£o do cont√™iner j√° emula o sistema operacional de cada objeto.  M√°quinas virtuais compartilham o hardware f√≠sico do host e os cont√™ineres compartilham o hardware e o n√∫cleo do SO.  Como os cont√™ineres geralmente compartilham mais recursos com o host, seu trabalho com os ciclos de armazenamento, mem√≥ria e CPU √© muito mais eficiente do que com uma m√°quina virtual.  No entanto, a desvantagem desse acesso compartilhado s√£o os problemas no plano de seguran√ßa da informa√ß√£o, pois √© estabelecida muita confian√ßa entre os cont√™ineres e o host.  A Figura 1 ilustra a diferen√ßa arquitet√¥nica entre um cont√™iner e uma m√°quina virtual. <br><br><img src="https://habrastorage.org/webt/_7/qr/bk/_7qrbkpwq4ee_ep709hxsqzyl8o.png"><br><br>  Em geral, o isolamento de equipamentos virtualizados cria um per√≠metro de seguran√ßa muito mais forte do que apenas o isolamento de um espa√ßo para nome.  O risco de um invasor sair com √™xito de um processo isolado √© muito maior do que a chance de sair com √™xito da m√°quina virtual.  A raz√£o do maior risco de ir al√©m do ambiente de cont√™iner limitado √© o fraco isolamento criado pelo namespace e cgroups.  O Linux os implementa associando novos campos de propriedades a cada processo.  Esses campos no sistema de arquivos <code>/proc</code> indicam ao sistema operacional host se um processo pode ver outro ou quanto recursos de processador / mem√≥ria um determinado processo pode usar.  Ao visualizar processos e threads em execu√ß√£o no sistema operacional pai (por exemplo, o comando top ou ps), o processo do cont√™iner se parece com qualquer outro.  Normalmente, solu√ß√µes tradicionais, como LXC ou Docker, n√£o s√£o consideradas totalmente isoladas porque usam o mesmo n√∫cleo no mesmo host.  Portanto, n√£o √© de surpreender que os cont√™ineres tenham um n√∫mero suficiente de vulnerabilidades.  Por exemplo, CVE-2014-3519, CVE-2016-5195, CVE-2016-9962, CVE-2017-5123 e CVE-2019-5736 podem resultar em um invasor obtendo acesso a dados fora do cont√™iner. <br><br>  A maioria das explora√ß√µes de kernel cria um vetor para um ataque bem-sucedido, porque geralmente resulta em escalonamento de privil√©gios e permite que um processo comprometido obtenha controle fora do espa√ßo de nome pretendido.  Al√©m dos vetores de ataque no contexto de vulnerabilidades de software, a configura√ß√£o inadequada tamb√©m pode desempenhar um papel.  Por exemplo, implantar imagens com privil√©gios excessivos (CAP_SYS_ADMIN, acesso privilegiado) ou pontos cr√≠ticos de montagem ( <code>/var/run/docker.sock</code> ) pode resultar em um vazamento.  Dadas essas conseq√º√™ncias potencialmente catastr√≥ficas, voc√™ deve entender o risco que corre ao implantar o sistema em um espa√ßo de v√°rios locat√°rios ou ao usar cont√™ineres para armazenar dados confidenciais. <br><br>  Esses problemas motivam os pesquisadores a criar per√≠metros de seguran√ßa mais fortes.  A id√©ia √© criar um cont√™iner sandbox real o mais isolado poss√≠vel do sistema operacional principal.  A maioria dessas solu√ß√µes inclui o desenvolvimento de uma arquitetura h√≠brida que utiliza uma distin√ß√£o estrita entre o aplicativo e a m√°quina virtual e se concentra em melhorar a efici√™ncia das solu√ß√µes de cont√™iner. <br><br>  No momento da reda√ß√£o deste artigo, n√£o havia um √∫nico projeto que pudesse ser considerado maduro o suficiente para ser aceito como padr√£o, mas, no futuro, os desenvolvedores, sem d√∫vida, aceitar√£o alguns desses conceitos como principais. <br><br>  Come√ßamos nossa an√°lise com o Unikernel, o sistema altamente especializado mais antigo que compacta um aplicativo em uma imagem usando um conjunto m√≠nimo de bibliotecas de SO.  O conceito do Unikernel em si provou ser fundamental para muitos projetos cujo objetivo era criar imagens seguras, compactas e otimizadas.  Depois disso, passaremos a considerar o IBM Nabla, um projeto para iniciar aplicativos Unikernel, incluindo cont√™ineres.  Al√©m disso, temos o Google gVisor, um projeto para iniciar cont√™ineres no espa√ßo do kernel do usu√°rio.  Em seguida, mudaremos para solu√ß√µes de cont√™ineres baseadas em m√°quinas virtuais - Amazon Firecracker e OpenStack Kata.  Para resumir este post, comparando todas as solu√ß√µes acima. <br><br><h3>  Unikernel </h3><br>  O desenvolvimento de tecnologias de virtualiza√ß√£o nos permitiu mudar para a computa√ß√£o em nuvem.  Hipervisores como Xen e KVM lan√ßaram as bases para o que hoje conhecemos como Amazon Web Services (AWS) e Google Cloud Platform (GCP).  E embora os hipervisores modernos sejam capazes de trabalhar com centenas de m√°quinas virtuais combinadas em um √∫nico cluster, os sistemas operacionais tradicionais de uso geral n√£o s√£o muito adaptados e otimizados para funcionar em um ambiente como esse.  O objetivo geral do sistema operacional √©, em primeiro lugar, oferecer suporte e trabalhar com o maior n√∫mero poss√≠vel de aplicativos, portanto, seus kernels incluem todos os tipos de drivers, bibliotecas, protocolos, agendadores e assim por diante.  No entanto, a maioria das m√°quinas virtuais agora implantadas em algum lugar da nuvem √© usada para executar um √∫nico aplicativo, por exemplo, para fornecer DNS, um proxy ou algum tipo de banco de dados.  Como um aplicativo √∫nico depende apenas de uma parte espec√≠fica e pequena do kernel do sistema operacional, todas as outras "saias" simplesmente desperdi√ßam recursos do sistema e, pelo fato de existir, aumentam o n√∫mero de vetores para um poss√≠vel ataque.  De fato, quanto maior a base de c√≥digo, mais dif√≠cil √© eliminar todas as defici√™ncias e mais vulnerabilidades, erros e outras fraquezas em potencial.  Esse problema incentiva os especialistas a desenvolver sistemas operacionais altamente especializados com um conjunto m√≠nimo de funcionalidades do kernel, ou seja, a criar ferramentas para suportar um aplicativo espec√≠fico. <br><br>  Pela primeira vez, a ideia do Unikernel nasceu nos anos 90.  Ent√£o, ele tomou forma como uma imagem especializada de uma m√°quina com um √∫nico espa√ßo de endere√ßo que pode funcionar diretamente em hipervisores.  Ele compacta os aplicativos e fun√ß√µes principais e dependentes do kernel em uma √∫nica imagem.  Nemesis e Exokernel s√£o as duas primeiras vers√µes de pesquisa do projeto Unikernel.  O processo de empacotamento e implanta√ß√£o √© mostrado na Figura 2. <br><br><img src="https://habrastorage.org/webt/lv/pl/2q/lvpl2q9eel5loxodhibvhzjc93m.png"><br>  <i>Figura 2. Sistemas operacionais multiuso projetados para oferecer suporte a todos os tipos de aplicativos; muitas bibliotecas e drivers s√£o carregados com anteced√™ncia.</i>  <i>Unikernels s√£o sistemas operacionais altamente especializados, projetados para suportar um aplicativo espec√≠fico.</i> <i><br></i> <br>  O unikernel divide o kernel em v√°rias bibliotecas e coloca apenas os componentes necess√°rios na imagem.  Como m√°quinas virtuais regulares, o unikernel √© implementado e executado no hipervisor da VM.  Devido ao seu tamanho pequeno, ele pode carregar rapidamente e tamb√©m escalar rapidamente.  Os recursos mais importantes do Unikernel s√£o seguran√ßa aumentada, tamanho reduzido, alto grau de otimiza√ß√£o e carregamento r√°pido.  Como essas imagens cont√™m apenas bibliotecas dependentes de aplicativos e o shell do SO n√£o √© acess√≠vel se n√£o estiver conectado propositadamente, o n√∫mero de vetores de ataque que os invasores podem usar neles √© m√≠nimo. <br><br>  Ou seja, n√£o √© apenas dif√≠cil para os invasores ganhar uma posi√ß√£o nesses n√∫cleos √∫nicos, mas sua influ√™ncia tamb√©m √© limitada a uma inst√¢ncia principal.  Como o tamanho das imagens do Unikernel √© de apenas alguns megabytes, elas s√£o baixadas em dezenas de milissegundos e literalmente centenas de inst√¢ncias podem ser executadas em um √∫nico host.  Usando a aloca√ß√£o de mem√≥ria no mesmo espa√ßo de endere√ßo em vez de uma tabela de p√°ginas multin√≠vel, como √© o caso da maioria dos sistemas operacionais modernos, os aplicativos unikernel t√™m um atraso menor no acesso √† mem√≥ria em compara√ß√£o com o mesmo aplicativo em execu√ß√£o em uma m√°quina virtual comum.  Como os aplicativos se re√∫nem com o kernel ao criar a imagem, os compiladores podem simplesmente executar a verifica√ß√£o de tipo est√°tico para otimizar arquivos bin√°rios. <br><br>  O Unikernel.org mant√©m uma lista de projetos do unikernel.  Mas com todas as suas caracter√≠sticas e propriedades distintas, o unikernel n√£o √© amplamente utilizado.  Quando a Docker adquiriu a Unikernel Systems em 2016, a comunidade decidiu que a empresa agora embalaria cont√™ineres neles.  Mas tr√™s anos se passaram e ainda n√£o h√° sinais de integra√ß√£o.  Uma das principais raz√µes para essa lenta implementa√ß√£o √© que ainda n√£o existe uma ferramenta madura para criar aplicativos Unikernel, e a maioria desses aplicativos pode funcionar apenas em determinados hipervisores.  Al√©m disso, a portabilidade de um aplicativo para o unikernel pode exigir a reescrita manual do c√≥digo em outros idiomas, incluindo a reescrita das bibliotecas dependentes do kernel.  Tamb√©m √© importante que o monitoramento ou depura√ß√£o em unikernels seja imposs√≠vel ou tenha um impacto significativo no desempenho. <br><br>  Todas essas restri√ß√µes impedem os desenvolvedores de mudar para essa tecnologia.  Deve-se notar que o unikernel e os cont√™ineres t√™m muitas propriedades semelhantes.  Tanto a primeira como a segunda s√£o imagens imut√°veis ‚Äã‚Äãaltamente focadas, o que significa que os componentes dentro deles n√£o podem ser atualizados ou corrigidos, ou seja, voc√™ sempre precisa criar uma nova imagem para o patch do aplicativo.  Hoje, o Unikernel √© semelhante ao ancestral do Docker: ent√£o o tempo de execu√ß√£o do cont√™iner n√£o estava dispon√≠vel e os desenvolvedores precisavam usar as ferramentas b√°sicas para criar um ambiente de aplicativo isolado (chroot, descompartilhamento e cgroups). <br><br><h3>  Ibm nabla </h3><br>  Uma vez, pesquisadores da IBM propuseram o conceito de "Unikernel como um processo" - ou seja, o aplicativo unikernel que seria executado como um processo em um hipervisor especializado.  O projeto IBM ‚ÄúNabla containers‚Äù fortaleceu o per√≠metro de seguran√ßa do unikernel, substituindo o hypervisor universal (por exemplo, QEMU) por seu pr√≥prio desenvolvimento chamado Nabla Tender.  A l√≥gica por tr√°s dessa abordagem √© que as chamadas entre o unikernel e o hipervisor ainda fornecem o maior n√∫mero de vetores de ataque.  √â por isso que o uso de um hypervisor dedicado ao unikernel com menos chamadas de sistema permitidas pode fortalecer significativamente o per√≠metro de seguran√ßa.  O Nabla Tender intercepta chamadas que o unikernel roteia para o hipervisor e j√° as converte em solicita√ß√µes do sistema.  Ao mesmo tempo, a pol√≠tica seccomp do Linux bloqueia todas as outras chamadas do sistema que n√£o s√£o necess√°rias para o Tender funcionar.  Assim, o Unikernel em conjunto com o Nabla Tender √© executado como um processo no espa√ßo do usu√°rio do host.  Abaixo, na figura 3, √© mostrado como o Nabla cria uma interface fina entre o unikernel e o host. <br><br><img src="https://habrastorage.org/webt/wy/je/p6/wyjep6mcxwfd8n-ogesrx1rnjyi.png"><br>  <i>Figura 3. Para vincular o Nabla √†s plataformas de cont√™iner existentes, o Nabla usa um ambiente compat√≠vel com OCI, que por sua vez pode ser conectado ao Docker ou ao Kubernetes.</i> <br><br>  Os desenvolvedores afirmam que o Nabla Tender usa menos de sete chamadas do sistema em seu trabalho para interagir com o host.  Como as chamadas do sistema servem como uma esp√©cie de ponte entre os processos no espa√ßo do usu√°rio e o kernel do sistema operacional, quanto menos chamadas do sistema estiverem dispon√≠veis, menor ser√° o n√∫mero de vetores dispon√≠veis para atacar o kernel.  Outra vantagem de executar o unikernel como um processo √© que voc√™ pode depurar esses aplicativos usando um grande n√∫mero de ferramentas, por exemplo, usando o gdb. <br><br>  Para trabalhar com plataformas de orquestra√ß√£o de cont√™iner, a Nabla fornece um <code>runnc</code> dedicado, implementado usando o padr√£o Open Container Initiative (OCI).  O √∫ltimo define uma API entre clientes (por exemplo, Docker, Kubectl) e o ambiente de tempo de execu√ß√£o (por exemplo, runc).  O Nabla tamb√©m vem com um construtor de imagens que o <code>runnc</code> poder√° executar mais tarde.  No entanto, devido a diferen√ßas no sistema de arquivos entre unikernels e cont√™ineres tradicionais, as imagens Nabla n√£o atendem √†s especifica√ß√µes de imagem OCI e, portanto, as imagens do Docker n√£o s√£o compat√≠veis com o <code>runnc</code> .  No momento da reda√ß√£o deste artigo, o projeto ainda est√° nos est√°gios iniciais de desenvolvimento.  Existem outras restri√ß√µes, por exemplo, a falta de suporte para montar / acessar sistemas de arquivos host, adicionar v√°rias interfaces de rede (necess√°rias para o Kubernetes) ou usar imagens de outras imagens de unikernel (por exemplo, MirageOS). <br><br><h3>  Google gVisor </h3><br>  O Google gVisor √© uma tecnologia sandbox usando o Google Cloud Platform Application Engine (GCP), recursos de nuvem e CloudML.  Em algum momento, o Google percebeu o risco de executar aplicativos n√£o confi√°veis ‚Äã‚Äãna infraestrutura de nuvem p√∫blica e a inefici√™ncia de aplicativos sandbox usando m√°quinas virtuais.  Como resultado, um kernel do espa√ßo do usu√°rio foi desenvolvido para um ambiente isolado de aplicativos n√£o confi√°veis.  O gVisor coloca esses aplicativos na sandbox, interceptando todas as chamadas do sistema para o kernel do host e processando-as no ambiente do usu√°rio usando o kernel do gVisor Sentry.  Em ess√™ncia, ele funciona como uma combina√ß√£o de um n√∫cleo convidado e um hipervisor.  A Figura 4 mostra a arquitetura do gVisor. <br><br><img src="https://habrastorage.org/webt/rk/xe/eq/rkxeeqqm9qs73q5enqp6zy99rfk.png"><br>  <i>Figura 4. Implementa√ß√£o do kernel do gVisor // Os sistemas de arquivos Sentry e gVisor Gofer usam um pequeno n√∫mero de chamadas do sistema para interagir com o host</i> <br><br>  O gVisor cria um forte per√≠metro de seguran√ßa entre o aplicativo e seu host.  Limita as chamadas do sistema que os aplicativos podem usar no espa√ßo do usu√°rio.  Sem depender da virtualiza√ß√£o, o gVisor funciona como um processo host que interage entre um aplicativo independente e um host.  O Sentry suporta a maioria das chamadas de sistema Linux e os principais recursos do kernel, como entrega de sinal, gerenciamento de mem√≥ria, pilha de rede e modelo de fluxo.  O Sentry implementa mais de 70% das 319 chamadas do sistema Linux para dar suporte a aplicativos em √°rea restrita.  No entanto, o Sentry usa menos de 20 chamadas do sistema Linux para interagir com o kernel host.  Vale ressaltar que o gVisor e o Nabla t√™m uma estrat√©gia muito semelhante: proteger o sistema operacional host e essas duas solu√ß√µes usam menos de 10% das chamadas do sistema Linux para interagir com o kernel.  Mas voc√™ precisa entender que o gVisor cria um kernel multiuso e, por exemplo, o Nabla conta com kernels exclusivos.  Ao mesmo tempo, ambas as solu√ß√µes iniciam um kernel convidado especializado no espa√ßo do usu√°rio para dar suporte a aplicativos isolados confi√°veis ‚Äã‚Äãpor eles. <br><br>  Algu√©m pode se perguntar por que o gVisor precisa de seu pr√≥prio kernel, quando o kernel Linux j√° √© de c√≥digo aberto e facilmente acess√≠vel.  ,  gVisor,   Golang,  ,   ‚Äã‚ÄãLinux,   C.           Golang.      gVisor ‚Äî    Docker, Kubernetes   OCI.   Docker        gVisor,     gVisor runsc.   Kubernetes  ¬´¬ª       gVisor    ¬´¬ª-. <br><br>  gVisor      ,     .  gVisor     ,    ,   ,       . ( ,   Nabla   ,   unikernel    . Nabla        hypercall).  gVisor     (passthrough),  ,   , ,  GPU,     . ,  gVisor   70%   Linux, ,       ,     gVisor. <br><br><h3> Amazon Firecracker </h3><br> Amazon Firecracker ‚Äî  ,     AWS Lambda  AWS Fargate.  ,   ¬´  ¬ª (MicroVM)   multi-tenant     .   Firecracker  Lambda  Fargate         EC2  ,    .            ,      ,                . Firecracker    ,   ,      .  Firecracker                ,   .       Linux     ext4      . Amazon   Firecracker  2017 ,   2018      . <br><br>   unikernel, Firecracker          .       micro-VM      ,        .  ,  micro-VM  Firecracker   5      ~125        2 CPU + 256  RAM.   5   Firecracker    . <br><br><img src="https://habrastorage.org/webt/_i/rd/qu/_irdqutnwf2v659vbsxz47igzo0.png"><br> <i> 5.  Firecracker         </i> <br><br> Firecracker   KVM,         .   Firecracker   seccomp, cgroups  namespaces,   ,  ,         .    Firecracker   . ,  API         microVM.        virtIO (  ). Firecracker        microVM: virtio-block, virtio-net, serial console  1-button  ,     microVM.               .   ,   ,   microVM  File Block Devices,       .       ,      cgroups.         ,           . <br><br>      Firecracker         Docker  Kubernetes. Firecracker      ,  ,          ,   .               .   ,     ,        OCI     . <br><br><h3> OpenStack Kata </h3><br>     ,  2015   Intel         Clear Containers. Clear Containers      Intel VT     QEMU-KVM <code>qemu-lite</code> .   2017   Clear Containers   Hyper RunV,     OCI,     Kata.    Clear Containers, Kata        . <br><br> Kata    OCI,    (CRI)    (CNI).       (, passthrough, MacVTap, bridge, tc mirroring)    ,        ,       .   6 ,      Kata     . <br><br><img src="https://habrastorage.org/webt/f0/7k/yy/f07kyyzusufaygo32ysb8hjjb-i.png"><br> <i> 6.    Kata  Docker  Kubernetes</i> <br><br>   Kata     .       Kata     Kata Shim,    API   (, docker  kubectl)         VSock.  Kata   . NEMU ‚Äî    QEMU    ~80%   . VM-Templating     Kata VM         .          ,          ,  ,  CVE-2015-2877.   ¬´ ¬ª        (, , ,  virtio),      . <br><br>  Kata  Firecracker ‚Äî   ¬´¬ª    ,    .    ,   . Firecracker ‚Äî   ,        ,      Kata ‚Äî    ,      .      Kata  Firecracker.         ,        . <br><br><h3>  Conclus√£o </h3><br>    ,   ‚Äî        . <br><br> IBM Nabla ‚Äî     unikernel,       . <br><br> Google gVisor ‚Äî        ,         . <br><br> Amazon Firecracker ‚Äî   ,           . <br><br> OpenStack Kata ‚Äî        ,      . <br><br>  ,       ,         .             . Nabla   ,     ,   unikernel-,   MirageOS  IncludeOS. gVisor      Docker  Kubernetes,  -         . Firecracker         ,         .  Kata    OCI      KVM,     Xen.        . <br><br><img src="https://habrastorage.org/webt/50/d1/gr/50d1grnpu0ushkd6pkjl74vbeju.png"><br><br>  ,      ,   ,      ,           . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457760/">https://habr.com/ru/post/pt457760/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457750/index.html">Trabalhar com JSON RPC no Symfony 4</a></li>
<li><a href="../pt457752/index.html">Nem vagabundos da lua nem piadistas. O que sabemos sobre rob√¥s em Fukushima</a></li>
<li><a href="../pt457754/index.html">Estado e T-killers</a></li>
<li><a href="../pt457756/index.html">O livro Kafka Streams em a√ß√£o. Aplicativos e microsservi√ßos em tempo real ¬ª</a></li>
<li><a href="../pt457758/index.html">Engenheiros salvam pessoas perdidas na floresta, mas a floresta ainda n√£o se rendeu</a></li>
<li><a href="../pt457762/index.html">R√©gua do CCD: o que √© comido</a></li>
<li><a href="../pt457764/index.html">10 erros do jovem PO (parte II)</a></li>
<li><a href="../pt457766/index.html">Geramos n√≠veis de ladrilhos e ocultamos quadrados do jogador</a></li>
<li><a href="../pt457768/index.html">Como fiquei vulner√°vel: digitalizando a infraestrutura de TI com a Qualys</a></li>
<li><a href="../pt457770/index.html">Escrevemos o transformador personalizado AST no TypeScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>