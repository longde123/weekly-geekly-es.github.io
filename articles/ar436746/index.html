<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏻 🏒 🔻 كيفية تدهور الأداء من خلال تحسينه 🙅🏻 ⌨️ 📝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="أردنا الأفضل ، لكن اتضح كما هو الحال دائمًا. 
 فيكتور تشيرنوميردين ، 
 رجل دولة روسي 


 هناك أوقات في الحياة يبدو أنك تفعل فيها كل شيء بشكل صحيح ، ول...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>كيفية تدهور الأداء من خلال تحسينه</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436746/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"> <em>أردنا الأفضل ، لكن اتضح كما هو الحال دائمًا.</em> <br>  فيكتور تشيرنوميردين ، <br>  رجل دولة روسي </p><br><p style=";text-align:right;direction:rtl">  هناك أوقات في الحياة يبدو أنك تفعل فيها كل شيء بشكل صحيح ، ولكن هناك خطأ ما. <br>  هذه القصة عن حالة واحدة من هذا القبيل. </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl">  بمجرد أن نظرت إلى هذا الرمز وفكرت في تسريع الأمر: </p><br><pre style=";text-align:right;direction:rtl"><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(data.str, beginIndex, endIndex) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  أولاً ، أردت حساب الطول الإجمالي للسلسلة باستخدام المتغيرات <code>beginIndex</code> و <code>endIndex</code> (بالإضافة إلى حقيقة أنه بالإضافة إلى السلسلة المقتطعة ، ستتم إضافة حرفين آخرين إلى <code>StringBuilder</code> ) وتمرير هذه القيمة إلى مُنشئ <code>StringBuilder</code> لتحديد صفيف الحجم المطلوب على الفور .  بدا هذا الفكر واضحًا جدًا بالنسبة لي ، لذلك قررت تجربة شيء آخر.  دفعتني حقيقة أن هذا الرمز لم يتم تسليط الضوء عليه بواسطة "الفكرة" إلى التفكير الصحيح ، على الرغم من أن هذه الفتاة الذكية تقترح عادةً استبدال السلسلة القصيرة من <code>StringBuilder::append</code> بإضافة سلاسل ، وهي أقصر وأسهل في القراءة. </p><br><p style=";text-align:right;direction:rtl">  عقبة أمام هذا التبسيط هي استخدام أسلوب <code>StringBuilder.append(CharSequence, int, int)</code> .  نظرًا لأن حقل <code>data.str</code> عبارة عن سلسلة ، باستخدام <code>String.substring(beginIndex, endIndex)</code> يمكنك تحديد سلسلة فرعية منه وتمريرها إلى <code>StringBuilder.append(String)</code> . </p><br><p style=";text-align:right;direction:rtl">  الرمز بعد التحويل: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String subString = data.str.substring(beginIndex, endIndex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(subString) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  والآن تقدم Idea تبسيطًا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'L'</span></span> + data.str.substring(beginIndex, endIndex) + <span class="hljs-string"><span class="hljs-string">';'</span></span>; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  ومع ذلك ، فإن هدفنا في هذه الحالة ليس قابلية القراءة بقدر ما الإنتاجية.  قارن بين الطريقتين: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@Fork</span></span>(jvmArgsAppend = {<span class="hljs-string"><span class="hljs-string">"-Xms2g"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xmx2g"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilderAppendBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendSubString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ String latinStr = data.latinStr; String nonLatinStr = data.nonLatinStr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String substring = data.nonLatin ? nonLatinStr.substring(beginIndex, endIndex) : latinStr.substring(beginIndex, endIndex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(substring) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ String latinStr = data.latinStr; String nonLatinStr = data.nonLatinStr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String appended = data.nonLatin ? nonLatinStr : latinStr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(appended, beginIndex, endIndex) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); } <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ String latinStr; String nonLatinStr; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"false"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> nonLatin; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-string"><span class="hljs-string">"50"</span></span>, <span class="hljs-string"><span class="hljs-string">"100"</span></span>, <span class="hljs-string"><span class="hljs-string">"500"</span></span>, <span class="hljs-string"><span class="hljs-string">"1000"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ThreadLocalRandom random = ThreadLocalRandom.current(); <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ latinStr = randomString(<span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span></span>); nonLatinStr = randomString(<span class="hljs-string"><span class="hljs-string">""</span></span>); beginIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; endIndex = length + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String alphabet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] chars = alphabet.toCharArray(); StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(length + <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length + <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = chars[random.nextInt(chars.length)]; sb.append(c); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.toString(); } } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  المعيار بسيط مثل بنسات اثنين: يتم إضافة سلسلة عشوائية إلى <code>StringBuilder</code> ، يتم تحديد حجمها حسب حقل <code>length</code> ، وبما أن الفناء هو 2019 ، تحتاج إلى التحقق من ذلك كسلسلة تحتوي فقط على أحرف الأبجدية اللاتينية الرئيسية (ما يسمى الخط المضغوط ، والذي يُسمى فيه كل حرف يتوافق مع 1 بايت) ، وسلسلة مع الأحرف غير اللاتينية (يتم تمثيل كل حرف بواسطة 2 بايت). </p><br><p style=";text-align:right;direction:rtl">  في الفحص السريع ، <code>appendSubString</code> أن طريقة <code>appendSubString</code> لدينا أبطأ ، لأن كمية البيانات التي يجب لصقها تتوافق مع طريقة <code>appendBounds</code> ، ومع ذلك ، في طريقة <code>appendSubString</code> أيضًا إنشاء واضح <code>appendSubString</code> فرعية ، أي تخصيص الذاكرة لكائن جديد ونسخ المحتويات من <code>data.latinStr</code> / <code>data.nonLatinStr</code> . </p><br><p style=";text-align:right;direction:rtl">  يبدو أن نتائج القياس التي أجريتها باستخدام JDK11 على جهاز منزلي (Intel Core i5-4690، 3.50 GHz) تبدو أكثر إثارة للدهشة (ولكن للوهلة الأولى). </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">Benchmark nonLatin length Score Error Units appendBounds true 5 44,6 ± 0,4 ns/op appendBounds true 10 45,7 ± 0,7 ns/op appendBounds true 50 129,0 ± 0,5 ns/op appendBounds true 100 218,7 ± 0,8 ns/op appendBounds true 500 907,1 ± 5,5 ns/op appendBounds true 1000 1626,4 ± 13,0 ns/op appendSubString true 5 28,6 ± 0,2 ns/op appendSubString true 10 30,8 ± 0,2 ns/op appendSubString true 50 65,6 ± 0,4 ns/op appendSubString true 100 106,6 ± 0,6 ns/op appendSubString true 500 430,1 ± 2,4 ns/op appendSubString true 1000 839,1 ± 8,6 ns/op appendBounds:·gc.alloc.rate.norm true 5 184,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 10 200,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 50 688,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 100 1192,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 500 5192,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 1000 10200,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 5 136,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 10 160,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 50 360,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 100 608,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 500 2608,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 1000 5104,0 ± 0,0 B/op appendBounds false 5 20,8 ± 0,1 ns/op appendBounds false 10 24,0 ± 0,2 ns/op appendBounds false 50 66,4 ± 0,4 ns/op appendBounds false 100 111,0 ± 0,8 ns/op appendBounds false 500 419,2 ± 2,7 ns/op appendBounds false 1000 840,4 ± 7,8 ns/op appendSubString false 5 25,3 ± 0,3 ns/op appendSubString false 10 25,7 ± 0,2 ns/op appendSubString false 50 36,0 ± 0,1 ns/op appendSubString false 100 52,8 ± 0,4 ns/op appendSubString false 500 206,1 ± 6,1 ns/op appendSubString false 1000 388,1 ± 1,6 ns/op appendBounds:·gc.alloc.rate.norm false 5 80,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 10 88,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 50 320,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 100 544,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 500 2144,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 1000 4152,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 5 96,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 10 112,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 50 192,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 100 288,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 500 1088,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 1000 2088,0 ± 0,0 B/op</code> </pre> <br><p style=";text-align:right;direction:rtl">  <code>appendSubString</code> افتراضنا ، <code>appendSubString</code> طريقة <code>appendSubString</code> في الغالبية العظمى من الحالات (بما في ذلك دائمًا السلاسل غير اللاتينية) كانت أسرع وأقل شرهًا (على الرغم من أن <code>String::substring</code> تُرجع كائنًا جديدًا).  كيف حدث ذلك؟ </p><br><h2 id="smotryu-v-knigu-vizhu-figu" style=";text-align:right;direction:rtl">  أنظر إلى الكتاب ، أرى التين </h2><br><p style=";text-align:right;direction:rtl">  دراسة الكود المصدري لـ <code>StringBuilder</code> ستساعد على <code>StringBuilder</code> حجاب السرية.  تمرير كل الأساليب المستخدمة الاستدعاء إلى نفس الأساليب من <code>AbstractStringBuilder</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractStringBuilder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharSequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(s, start, end); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  انتقل إلى <code>AbstractStringBuilder.append(String)</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AbstractStringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> appendNull(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = str.length(); ensureCapacityInternal(count + len); putStringAt(count, str); count += len; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putStringAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getCoder() != str.coder()) { inflate(); } str.getBytes(value, index, coder); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  ما هو مثير للاهتمام هنا؟  تقوم <code>AbstractStringBuilder::inflate</code> ، كما يوحي الاسم ، بتوسيع صفيف <code>AbstractStringBuilder.value</code> عند الجمع بين السلاسل المختلفة.  يتم <code>String::getBytes</code> البيانات في <code>String::getBytes</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dstBegin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> coder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (coder() == coder) { System.arraycopy(value, <span class="hljs-number"><span class="hljs-number">0</span></span>, dst, dstBegin &lt;&lt; coder, value.length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// this.coder == LATIN &amp;&amp; coder == UTF16 StringLatin1.inflate(value, 0, dst, dstBegin, value.length); } }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  ما هو المهم؟  إذا كانت السلاسل متجانسة ، فسيتم استخدام <code>System::arraycopy</code> لنقل البيانات ، وإلا <code>StringLatin1::inflate</code> ، والذي يقودنا من خلال التفويض إلى <code>StringUTF16::inflate</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inflatedCopy byte[] -&gt; byte[] @HotSpotIntrinsicCandidate public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len) { // We need a range check here because 'putChar' has no checks checkBoundsOffCount(dstOff, len, dst); for (int i = 0; i &lt; len; i++) { putChar(dst, dstOff++, src[srcOff++] &amp; 0xff); } } @HotSpotIntrinsicCandidate static void putChar(byte[] val, int index, int c) { assert index &gt;= 0 &amp;&amp; index &lt; length(val) : "Trusted caller missed bounds check"; index &lt;&lt;= 1; val[index++] = (byte)(c &gt;&gt; HI_BYTE_SHIFT); val[index] = (byte)(c &gt;&gt; LO_BYTE_SHIFT); }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  وبالتالي ، إذا كانت الصفوف متجانسة ، فسيتم استخدام الطريقة التي تعتمد على <code>System::arraycopy</code> لنقل البيانات ، وإلا يتم استخدام حلقة ( <code>System::arraycopy</code> أيضًا).  هذا يعني أنه عند الإلتصاق بسطرين ، حيث تكون جميع الأحرف في مجموعة الأبجدية اللاتينية الرئيسية (بمعنى آخر ، تناسب البايت الواحد) ، يجب أن يكون الأداء أفضل بكثير من عند الإلتصاق بالخطوط غير المتجانسة.  يؤكد هذا المعيار (انظر الإخراج لغير <code>nonLatin = false</code> ). </p><br><p style=";text-align:right;direction:rtl">  الآن طريقة <code>AbstractStringBuilder.append(CharSequence, int, int)</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AbstractStringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { s = <span class="hljs-string"><span class="hljs-string">"null"</span></span>; } checkRange(start, end, s.length()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = end - start; ensureCapacityInternal(count + len); appendChars(s, start, end); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendChars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> off, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLatin1()) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] val = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = off, j = count; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = s.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StringLatin1.canEncode(c)) { val[j++] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)c; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { count = j; inflate(); StringUTF16.putCharsSB(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value, j, s, i, end); count += end - i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { StringUTF16.putCharsSB(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value, count, s, off, end); } count += end - off; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  هنا ، يشبه النهج المتبع في المثال السابق: بالنسبة للسلاسل المتجانسة ، يتم استخدام آلية أكثر بساطة (هنا ، نسخ النسخ في حلقة) ، للسلاسل غير المتجانسة التي نستخدمها <code>StringUTF16</code> ، ومع ذلك ، لاحظ أن <code>StringUTF16::putCharsSB</code> مضمّن. </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putCharsSB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> off, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ checkBoundsBeginEnd(index, index + end - off, val); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = off; i &lt; end; i++) { putChar(val, index++, s.charAt(i)); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  لذلك ، فإن البنية الداخلية لكلتا الطريقتين والسبب وراء أدائهما المختلف أكثر وضوحًا بالنسبة لنا.  السؤال الذي يطرح نفسه بطبيعة الحال - ماذا تفعل مع المعرفة المكتسبة بعد ذلك؟  هناك العديد من الخيارات في وقت واحد: </p><br><p style=";text-align:right;direction:rtl">  1) ضع ذلك في الاعتبار وعندما يكتشف رمزًا مشبوهًا ، قم بتغييره بيديك <br>  2) اذهب إلى Tagir واطلب منه تقديم الشيك الذي سيقوم بالعمل بدلاً منا <br>  3) قم بإجراء تغييرات على JDK بحيث لا يتغير الرمز على الإطلاق. </p><br><p style=";text-align:right;direction:rtl">  بالطبع ، نبدأ مع الثالث.  على استعداد لاتخاذ فرصة؟ </p><br><h2 id="pogruzhenie-v-puchinu" style=";text-align:right;direction:rtl">  الهاوية </h2><br><p style=";text-align:right;direction:rtl">  سوف ندرب <del>  على القطط </del>  على الكود المصدري لـ Java الحادي عشر ، يمكنك تنزيله من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> . </p><br><p style=";text-align:right;direction:rtl">  تتمثل أبسط الطرق وأكثرها وضوحًا في تحسينها في تحديد سلسلة فرعية موجودة بالفعل داخل طريقة <code>AbstractStringBuilder.append(CharSequence, int, int)</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  public AbstractStringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); int len = end - start; ensureCapacityInternal(count + len); appendChars(s, start, end); return this; } //  public AbstractStringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); return append(s.subSequence(start, end).toString()); }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  أنت الآن بحاجة إلى إنشاء JDK ، وإجراء الاختبارات ، وتشغيل معيار <code>StringBuilderAppendBenchmark::appendBounds</code> ، والذي يجب مقارنة نتائجه بنتائج نفس المؤشر على JDK الأصلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">#   before      JDK, # after -   Benchmark nonLatin length before after Units avgt true 5 44,6 64,4 ns/op avgt true 10 45,7 66,3 ns/op avgt true 50 129,0 168,9 ns/op avgt true 100 218,7 281,9 ns/op avgt true 500 907,1 1116,2 ns/op avgt true 1000 1626,4 2002,5 ns/op gc.alloc.rate.norm true 5 184,0 264,0 B/op gc.alloc.rate.norm true 10 200,0 296,0 B/op gc.alloc.rate.norm true 50 688,0 904,0 B/op gc.alloc.rate.norm true 100 1192,0 1552,0 B/op gc.alloc.rate.norm true 500 5192,0 6752,0 B/op gc.alloc.rate.norm true 1000 10200,0 13256,0 B/op avgt false 5 20,8 38,0 ns/op avgt false 10 24,0 37,8 ns/op avgt false 50 66,4 82,9 ns/op avgt false 100 111,0 138,8 ns/op avgt false 500 419,2 531,9 ns/op avgt false 1000 840,4 1002,7 ns/op gc.alloc.rate.norm false 5 80,0 152,0 B/op gc.alloc.rate.norm false 10 88,0 168,0 B/op gc.alloc.rate.norm false 50 320,0 440,0 B/op gc.alloc.rate.norm false 100 544,0 688,0 B/op gc.alloc.rate.norm false 500 2144,0 2688,0 B/op gc.alloc.rate.norm false 1000 4152,0 5192,0 B/op</code> </pre> <br><p style=";text-align:right;direction:rtl">  ما يسمى ، فجأة!  لم تحدث التحسينات فحسب ، بل حدث تدهور.  اللعنة ، ولكن كيف؟ </p><br><p style=";text-align:right;direction:rtl">  الحقيقة هي أنه في البداية ، في وصف أسلوب <code>StringBuilder::append</code> قمت بإهمال واحد صغير ولكنه مهم.  تم وصف الطريقة مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  وهنا وجهة نظرها كاملة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  لا يُعد رمز Java الذي درسناه أعلاه ، والذي يتم تسخينه وتجميعه على مستوى C2 ، أمرًا مهمًا ، لأنه لا يتم تنفيذه ، ولكنه جوهري.  من السهل إثبات ذلك عن طريق إزالة ملف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">التعريف</a> باستخدام ملف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">التعريف غير المتزامن</a> .  فيما يلي ، تتم إزالة ملف التعريف <code>length = 1000</code> و <code>nonLatin = true</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">#   `appendSubString`, JDK    ns percent samples top ---------- ------- ------- --- 19096340914 43.57% 1897673 jbyte_disjoint_arraycopy &lt;--------- 13500185356 30.80% 1343343 jshort_disjoint_arraycopy &lt;--------- 4124818581 9.41% 409533 java.lang.String.&lt;init&gt; #   2177311938 4.97% 216375 java.lang.StringUTF16.compress #   1557269661 3.55% 154253 java.util.Arrays.copyOfRange #   349344451 0.80% 34823 appendSubString_avgt_jmhStub 279803769 0.64% 27862 java.lang.StringUTF16.newString 274388920 0.63% 27312 org.openjdk.jmh.infra.Blackhole.consume 160962540 0.37% 15946 SpinPause 122418222 0.28% 11795 __memset_avx2</code> </pre> <br><p style=";text-align:right;direction:rtl">  كود <code>StringBuilder</code> (و <code>AbstractStringBuilder</code> ) لا يشم حتى هنا ، ما يقرب من 3/4 من الملف الشخصي يشغلها مضمن.  أرغب في ملاحظة نفس الصورة في ملف تعريف <code>StringBuilder.append(CharSequence, int, int)</code> "المحسن" الخاص بنا <code>StringBuilder.append(CharSequence, int, int)</code> . </p><br><p style=";text-align:right;direction:rtl">  في الواقع ، لدينا هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ns percent samples top ---------- ------- ------- --- 19071221451 43.78% 1897827 jbyte_disjoint_arraycopy 6409223440 14.71% 638348 jlong_disjoint_arraycopy 3933622128 9.03% 387403 java.lang.StringUTF16.newBytesFor 2067248311 4.75% 204193 java.lang.AbstractStringBuilder.ensureCapacityInternal 1929218737 4.43% 194751 java.lang.StringUTF16.compress 1678321343 3.85% 166458 java.util.Arrays.copyOfRange 1621470408 3.72% 160849 java.lang.String.checkIndex 969180099 2.22% 96018 java.util.Arrays.copyOf 581600786 1.34% 57818 java.lang.AbstractStringBuilder.&lt;init&gt; 417818533 0.96% 41611 appendBounds_jmhTest 406565329 0.93% 40479 java.lang.String.&lt;init&gt; 340972882 0.78% 33727 java.lang.AbstractStringBuilder.append 299895915 0.69% 29982 java.lang.StringBuilder.toString 183885595 0.42% 18136 SpinPause 168666033 0.39% 16755 org.openjdk.jmh.infra.Blackhole.consume</code> </pre> <br><p style=";text-align:right;direction:rtl">  ستقول: "ها هم ، في جوهرهم ، في القمة!"  في الواقع ، هذه فقط ليست هي نفسها في جوهرها (بما في ذلك مقارنة اسم الثانية من أعلاه).  أذكر: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  هنا يحل محل جوهري الدعوة إلى <code>StringBuilder.append(String)</code> ، ولكن في التصحيح لدينا هذه الدعوة ليست كذلك!  دعا <code>AbstractStringBuilder.append(String)</code> .  استدعاء <code>jbyte_disjoint_arraycopy</code> التي <code>jbyte_disjoint_arraycopy</code> هي جوهرية ل <code>StringLatin1::inflate</code> ، ودعا من <code>AbstractStringBuider::putStringAt</code> عبر <code>String::getBytes</code> .  أي أنه ، على عكس <code>StringBuilder::append</code> لا يعالج فقط النظام الأساسي بل وأيضًا كود جافا ، </p><br><p style=";text-align:right;direction:rtl">  فهم سبب الفشل ، حاول أن تنجح بطريقة أخرى.  من السهل تخمين أننا بحاجة إلى الرجوع بطريقة ما إلى <code>StringBuilder::append</code> .  يمكنك القيام بذلك عن طريق تمزيق التصحيح السابق وإجراء تغييرات على <code>StringBuilder</code> نفسه: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  @Override public StringBuilder append(CharSequence s, int start, int end) { super.append(s, start, end); return this; } //  @Override public StringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); return this.append(s.subSequence(start, end).toString()); } }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن كل شيء يتم بحكمة: يسمى StringBuilder :: إلحاقي. <br>  إعادة بناء ، تشغيل ، مقارنة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">#   before      JDK, # after -   Benchmark nonLatin length before after Units avgt true 5 44,6 60,2 ns/op avgt true 10 45,7 59,1 ns/op avgt true 50 129,0 164,6 ns/op avgt true 100 218,7 276,2 ns/op avgt true 500 907,1 1088,8 ns/op avgt true 1000 1626,4 1959,4 ns/op gc.alloc.rate.norm true 5 184,0 264,0 B/op gc.alloc.rate.norm true 10 200,0 296,0 B/op gc.alloc.rate.norm true 50 688,0 904,0 B/op gc.alloc.rate.norm true 100 1192,0 1552,0 B/op gc.alloc.rate.norm true 500 5192,0 6752,0 B/op gc.alloc.rate.norm true 1000 10200,0 13256,0 B/op avgt false 5 20,8 37,9 ns/op avgt false 10 24,0 37,9 ns/op avgt false 50 66,4 80,9 ns/op avgt false 100 111,0 125,6 ns/op avgt false 500 419,2 483,6 ns/op avgt false 1000 840,4 893,8 ns/op gc.alloc.rate.norm false 5 80,0 152,0 B/op gc.alloc.rate.norm false 10 88,0 168,0 B/op gc.alloc.rate.norm false 50 320,0 440,0 B/op gc.alloc.rate.norm false 100 544,0 688,0 B/op gc.alloc.rate.norm false 500 2144,0 2688,0 B/op gc.alloc.rate.norm false 1000 4152,0 5187,2 B/op</code> </pre><br><p style=";text-align:right;direction:rtl">  أشعر بحزن شديد حقًا ، لكنها لم تتحسن.  الآن ملف تعريف جديد: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ns percent samples top ---------- ------- ------- --- 19614374885 44.12% 1953620 jbyte_disjoint_arraycopy 6645299702 14.95% 662146 jlong_disjoint_arraycopy 4065789919 9.15% 400167 java.lang.StringUTF16.newBytesFor 2374627822 5.34% 234746 java.lang.AbstractStringBuilder.ensureCapacityInternal 1837858014 4.13% 183822 java.lang.StringUTF16.compress 1472039604 3.31% 145956 java.util.Arrays.copyOfRange 1316397864 2.96% 130747 appendBounds_jmhTest 956823151 2.15% 94959 java.util.Arrays.copyOf 573091712 1.29% 56933 java.lang.AbstractStringBuilder.&lt;init&gt; 434454076 0.98% 43202 java.lang.String.&lt;init&gt; 368480388 0.83% 36439 java.lang.AbstractStringBuilder.append 304409057 0.68% 30442 java.lang.StringBuilder.toString 272437989 0.61% 26833 SpinPause 201051696 0.45% 19985 java.lang.StringBuilder.&lt;init&gt; 198934052 0.45% 19810 appendBounds_avgt_jmhStub</code> </pre> <br><p style=";text-align:right;direction:rtl">  لقد تغير القليل.  بالنسبة لي ، يبقى من غير الواضح سبب عدم عمل الجوهر عند الوصول إلى <code>StringBuilder.append(String)</code> من داخل <code>StringBuilder</code> .  هناك شك في أن لصق (مضمّن) نص أسلوب <code>StringBuilder.append(String)</code> في نص <code>StringBuilder.append(CharSequence, int, int)</code> يغير شيئًا ما في معالجة استدعاءات أسلوب VM. </p><br><p style=";text-align:right;direction:rtl">  على أي حال ، هذا هو الفشل ، وإخوانه.  لم يكن من الممكن تصحيح JDK ، لكن لا يزال بإمكاننا القيام بالبدائل يدويًا حيث يكون ذلك منطقيًا. </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">فشل التراجع الأدبي</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><blockquote style=";text-align:right;direction:rtl">  جاء تشفير الاستجابة خلال يومين.  لا يرغب المستكشف في الانفصال عن Oto Velara ، مع شركة تبني سفن حربية سريعة وقوية بشكل مدهش.  لا يريد المستكشف قراءة التشفير لي.  إنه ببساطة يكرر الرد من مركز القيادة: "لا".  التشفير لا يفسر لماذا "لا".  "لا" في أي حال يعني أنه شخص معروف لجهاز كمبيوتر كبير.  إذا لم يكن هناك شيء معروف عنه ، فكان الجواب نعم: جربه.  سيء للغاية  إنه لأمر مؤسف أن تفقد مثل هذا الشخص المثير للاهتمام.  والقائد يجب أن يكون آسف بالنسبة لي.  ربما المرة الأولى أمر مؤسف.  رآني يمزق الفايكنج.  وهو لا يريد أن يدفعني إلى الكلاب السلوقية مرة أخرى. <br>  إنه صامت.  لكنني أعلم أنه في توفير نقص حاد في العمال: <br>  - أنا ، الرفيق العام ، أعمل في الغد.  دعني اذهب <br>  - استمر.  - وفجأة تبتسم.  "أنت تعرف ، كل سحابة لها بطانة فضية." <br>  "أنا ، الرفيق العام ، أعاني دائمًا من مرض جيد." <br>  "ومن هنا"  منعت من مقابلته ، هذا أمر سيء.  <strong>لكن إلى كنوز تجربتنا ، أضفنا حبة أخرى.</strong> </blockquote></div></div><br><p style=";text-align:right;direction:rtl">  الاستنتاجات: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لا يرتبط رمز أساليب JDK في بعض الحالات بالتنفيذ الفعلي ، لأنه بدلاً من نص الطريقة ، يمكن تنفيذ جوهري ، والذي يكون مخفيًا في أحشاء جهاز VM. </li><li style=";text-align:right;direction:rtl">  يمكن التعرف على مثل هذه الأساليب ، على وجه الخصوص ، <code>@HotSpotIntrinsicCandidate</code> علامات <code>@HotSpotIntrinsicCandidate</code> إليها ، على الرغم من أن بعض الطرق مضمّنة دون أي تلميح ، على سبيل المثال <code>String::equals</code> ( <a href="">والعديد غيرها</a> ). </li><li style=";text-align:right;direction:rtl">  الاستنتاج الذي يأتي من الأولين هو أن مناقشتنا لكيفية عمل كود JDK قد تتعارض مع الواقع.  C'est la vie </li></ul><br><p style=";text-align:right;direction:rtl">  PS <br>  بديل محتمل آخر: </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(str, <span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex); <span class="hljs-comment"><span class="hljs-comment">// --&gt; StringBuilder sb = new StringBuilder(str.substring(o, endIndex));</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  PPS <br>  يشير مطورو أوراكل بحق إلى ذلك </p><br><blockquote style=";text-align:right;direction:rtl">  يبدو لي غريبًا إلى حد ما ومن المستغرب إدخال مسار رمز إلى <br>  sb.append (cs، int، int) الذي يخصص الذاكرة من أجل الحصول على ذلك <br>  فقط في بعض الأحيان يجعل الأمور تعمل بشكل أسرع.  كما لاحظت ، والأداء <br>  المفاضلات ليست واضحة. <br><br>  بدلاً من ذلك ، إذا كنا نريد تحسين sb.append (cs ، int ، int) ربما يجب أن نذهب <br>  إلى الأمام والقيام بذلك ، ربما عن طريق إضافة أو إعادة ترتيب العناصر الداخلية. </blockquote><p style=";text-align:right;direction:rtl">  الحل المقترح هو <code>StringBuilder.append(CharSequence, int, int)</code> . </p><br><p style=";text-align:right;direction:rtl">  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المهمة</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مناقشة</a> </p><br><p style=";text-align:right;direction:rtl">  <strong>PPS</strong> <br>  ومن المثير للاهتمام ، في هذه اللحظة ، عند كتابة شيء من هذا القبيل </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(str.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex));</code> </pre> <br><p style=";text-align:right;direction:rtl">  "الفكرة" تقترح تبسيط الرمز إلى </p><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(s, <span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex);</code> </pre> <br><p style=";text-align:right;direction:rtl">  إذا لم يكن الأداء في هذا المكان مهمًا للغاية بالنسبة لك ، فمن المحتمل أن يكون استخدام الإصدار الثاني المبسط أكثر صحة.  ومع ذلك ، فإن معظم الشفرة التي نكتبها مخصصة لرفاقنا ، وليس للآلات. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar436746/">https://habr.com/ru/post/ar436746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar436726/index.html">يبلغ المستخدمون عن فقد عملات البيتكوين كنتيجة للقرصنة الذكية لمحافظ الإلكتروم</a></li>
<li><a href="../ar436732/index.html">ML.NET البرنامج التعليمي - البدء في 10 دقيقة</a></li>
<li><a href="../ar436740/index.html">البحوث الخاصة ، ماذا يمكن أن المصادر المفتوحة تخبرنا؟</a></li>
<li><a href="../ar436742/index.html">Android Robotics حتى 2019: القصة الحقيقية ؛ في 5 أجزاء ؛ الجزء 1</a></li>
<li><a href="../ar436744/index.html">قم بتشغيل كاشف الشبكة العصبية الخاص بك على Raspberry Pi باستخدام Neural Compute Stick و OpenVINO</a></li>
<li><a href="../ar436748/index.html">تطوير hexapod من الصفر (الجزء 3) - الحركية</a></li>
<li><a href="../ar436750/index.html">اتجاهات تحليل يوتيوب الروسي لعام 2018</a></li>
<li><a href="../ar436752/index.html">الكعكة كذبة</a></li>
<li><a href="../ar436754/index.html">Q2VKPT: Quake II بالكامل مع إضاءة واقعية</a></li>
<li><a href="../ar436756/index.html">يسرع التماثل إلى الإنقاذ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>