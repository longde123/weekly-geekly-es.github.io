<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ» â­•ï¸ âœŒğŸ¼ Metode rata-rata vektor untuk mengukur arah angin ğŸš£ğŸ¾ ğŸ– ğŸš¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setahun yang lalu, saya menggambarkan stasiun cuaca dengan alat ukur untuk arah dan kecepatan angin. Berdasarkan pengalaman dua musim operasi, beberap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metode rata-rata vektor untuk mengukur arah angin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423243/"> Setahun yang lalu, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggambarkan</a> stasiun cuaca dengan alat ukur untuk arah dan kecepatan angin.  Berdasarkan pengalaman dua musim operasi, beberapa perubahan dan perbaikan dilakukan untuk itu, yang sebagian dijelaskan di sana sebagai tambahan pada teks utama. <br><br>  Salah satu perubahan ini menyangkut perhitungan arah angin rata-rata.  Yang mengherankan saya, saya tidak menemukan sesuatu yang masuk akal pada topik ini di Web, hanya di salah satu forum orang sendiri hampir memikirkan metode rata-rata vektor (tetapi hanya hampir, mereka tidak memecahkan masalah secara umum).  Oleh karena itu, saya merasa berguna untuk meletakkan topik ini dalam publikasi terpisah - tiba-tiba orang lain akan berguna.  Metode ini dapat digunakan untuk rata-rata jumlah vektor, tidak hanya angin atau arus. <br><a name="habracut"></a><br>  Perhatikan bahwa metode kanonik untuk melakukan pengukuran meteorologi angin adalah sebagai berikut: rata-rata vektor (baik kecepatan dan arah) selama 10 menit (di Rusia dan sebagian besar negara di dunia diterima dengan cara itu, kata mereka, di AS dan beberapa negara lain berbeda).  Dalam hal ini, pengukuran dilakukan pada ketinggian 10 m dari permukaan Bumi.  Untuk memastikan semua ini di bawah kondisi lutut cukup sulit: seseorang tidak dapat mencapai ketinggian 10 m di ruang terbuka (jangan membangun menara khusus, jauh dari rumah dan pohon yang mengganggu aliran angin), dan suhu dengan kelembaban harus, sebaliknya, diukur di tempat teduh dan dekat dari permukaan.  Sensor portabel diubah dari perangkat yang ringkas menjadi sistem pengukuran keseluruhan (lihat foto wilayah stasiun cuaca di kota Kirov). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/704/b2b/b03704b2bd492c4455aae265a659d489.jpg" alt="Stasiun cuaca di Kirov"><br><br>  Dan hasilnya - rata-rata 10 menit - akan sedikit informatif.  Di dekat permukaan, angin jauh lebih kencang daripada di ketinggian, dalam 10 menit dapat mengubah kecepatan dan arah dua puluh kali, dan informasi tentang hembusan ini jauh lebih informatif bagi orang rata-rata daripada nilai rata-rata.  Biarkan saya mengingatkan Anda bahwa sensor kecepatan di sini menunjukkan nilai maksimum empat pengukuran per siklus 8 detik, dan ini ternyata menjadi pilihan yang tepat (pada kenyataannya, kami mendapatkan sensor riak daripada sensor kecepatan rata-rata). <br><br>  Tapi baling-baling cuaca ternyata lebih murung daripada sensor kecepatan.  Menurut algoritma awal stasiun cuaca saya (yang dipilih berdasarkan penghematan energi maksimum yang mungkin), arah diukur sekali siklus, yaitu, bahkan denyut nadi tidak berhasil: ada sampel acak dari proses terus-menerus menggantung baling-baling cuaca bolak-balik dengan frekuensi jauh lebih besar daripada sekali setiap 8 dan lebih dari 16 detik. <br><br>  Oleh karena itu, diputuskan untuk rata-rata arah vektor kecepatan per siklus, mengambil pengukuran setiap dua detik dan menghitung rata-rata.  Dan masalahnya tidak sehingga bisa diselesaikan dengan setengah tendangan - nilai arah tidak membentuk array angka yang dapat ditambahkan dan dibagi secara langsung (satu kata adalah vektor, bukan skalar omong kosong).  Biasanya sebuah contoh diberikan dengan nilai 1 derajat dan 359 derajat: mudah untuk mengetahui bahwa secara rata-rata 360 (atau 0, tidak ada perbedaan), tetapi aritmatika biasa akan memberikan angka 180 derajat. <br><br>  Tidak perlu menemukan apa pun - semuanya telah ditemukan sebelum Anda.  Masalahnya diselesaikan dengan metode rata-rata vektor, yang diketahui oleh mereka yang berurusan dengan pengukuran angin atau arus.  Metode ini pada dasarnya sangat sederhana: karena kita tidak dapat secara langsung meratakan sudut, maka mari rata-rata proyeksi vektor pada sumbu koordinat, yang, menurut definisi, adalah nilai skalar, yaitu, dapat dikenakan aritmatika biasa tanpa pertanyaan. <br><br>  Proyeksi vektor angin saat ini W '(apostrof memainkan peran superskrip) pada sumbu X dan Y adalah wx = Wa â€¢ cos (Î±) dan wy = Wa â€¢ sin (Î±), di mana Wa adalah modulus vektor (nilai kecepatan), dan Î± - nilai sudut antara vektor dan sumbu koordinat nol.  Jika kita meratakan nilai-nilai proyeksi ini, dan kemudian mengkonversi rata-rata kembali ke vektor, maka kita mendapatkan nilai sebenarnya dari kecepatan rata-rata dan arah angin. <br><br><div class="spoiler">  <b class="spoiler_title">Catatan untuk sangat korosif</b> <div class="spoiler_text">  Untuk rata-rata yang benar-benar benar dengan cara ini, perlu bahwa nilai Wa (nilai kecepatan) diukur secara ketat bersamaan dengan nilai sudut.  Dalam praktiknya, ini harus dipantau hanya jika periode fluktuasi yang signifikan dalam amplitudo aliran kurang dari atau sebanding dengan waktu pengukuran.  Untuk angin (dan untuk hampir semua kasus aliran air alami), biasanya tidak perlu dipantau, karena waktu pengukuran untuk kita adalah maksimum sepersekian detik, dan denyut angin yang signifikan, tentu saja, bertahan lebih lama.  Kita dapat mengabaikan frekuensi aliran yang tidak homogen, karena mereka tidak mempengaruhi apa pun: kelembaman benda fisik nyata (termasuk sensor) jauh lebih besar daripada inhomogenitas ini, dan kita tidak akan merasakannya - secarik kertas akan bergetar, tetapi tidak lebih.  Dalam kasus ekstrim, mereka akan keluar sebagai noise acak kecil yang tidak secara signifikan mempengaruhi kualitas pengukuran. <br></div></div><br>  Metode yang luar biasa ini (sebut saja full vector averaging) memiliki satu kelemahan utama dari sudut pandang praktis: dengan tidak adanya subjek pengukuran (yaitu, ketika benar-benar tenang, yang merupakan kasus umum), ini memberikan hasil yang secara matematis salah: karena kecepatan angin nol, maka dan kedua proyeksi sama dengan nol, yang tidak mungkin (karena dosa dan cos adalah fungsi yang saling melengkapi).  Lebih tepatnya, mungkin, tetapi pada dasarnya mustahil untuk mengekstraksi informasi dari situasi seperti itu.  Apa yang ingin Anda tampilkan di layar?  Sejujurnya, saya masih tidak tahu cara yang benar untuk mengatasi situasi ini (dalam flow meter yang pernah saya rancang, siklus rata-rata adalah berjam-jam, dan diyakini bahwa setidaknya beberapa pengadukan akan terjadi). <br><br>  Tetapi dalam kasus kami, tugasnya, untungnya, lebih mudah - kita tidak perlu rata-rata kecepatannya, dan kita dapat melakukannya dengan satu proyeksi vektor, tanpa memperhitungkan besarnya modulnya.  Dengan kata lain, seseorang dapat beroperasi dengan sinus murni dan cosinus, yang tidak pernah mengambil nol keduanya sekaligus: bahkan ketika tidak ada angin, baling-baling cuaca yang membeku di real estat menunjukkan beberapa arah.  Kami menyebut metode semacam itu sebagai vektor yang disederhanakan dengan rata-rata arah (mungkin memiliki beberapa nama resmi, tapi saya tidak sadar). <br><br>  Hanya ada satu kesulitan sekarang: mengubah nilai proyeksi rata-rata yang dihitung kembali ke nilai sudut.  Untuk ini, fungsi Î± = arctan (sin (Î±) / cos (Î±)) biasanya digunakan, tetapi jika kita menghitung melalui fungsi trigonometri terbalik, maka lebih mudah untuk mengambil arcos (cos (Î±)) (atau arcsin (sin (Î±)), tetap), dan untuk melengkapi hasil ini untuk mendapatkan lingkaran penuh (mis., dari 0 hingga 359 derajat), menganalisis tanda-tanda proyeksi, Anda masih harus dalam hal apa pun: semua fungsi terbalik memberikan hasil dalam setengah lingkaran (dari 0 hingga 180 atau dari -90 hingga +90).  (Lihat UPD tentang ini di akhir artikel.) <br><br>  Kami meresmikan semua di atas menjadi algoritma nyata (dengan mengacu pada Arduino).  Untuk memulainya, kita akan membaca petunjuk arah tidak setiap siklus, tetapi setiap pengukuran (setelah nilai frekuensi anemometer).  Kami akan mengonversi hasilnya dalam kode Gray (di negara kami ini ditunjuk sebagai wind_Gray dari tipe byte, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi itu</a> ) menjadi kode biner biasa, dan, seperti frekuensi anemometer, kami akan menempatkannya dalam array global, yang akan kami nyatakan sebagai wDirAvr [4], di mana 4 adalah jumlah pengukuran dalam siklus.  Kami tidak akan mengecat konversi kode Grey empat digit menjadi kode biner - ini dapat dilakukan dengan beberapa cara sesuai kehendak programmer dan dijelaskan dalam referensi apa pun. <br><br>  Kode biner ini akan mengambil nilai dari 0 hingga 15, dan kami setuju bahwa kami akan menghitung sudutnya, bukan sebagai geografer / topografi / navigator yang bergeser, tetapi sebagai orang normal yang mempelajari trigonometri di sekolah - berlawanan arah jarum jam.  Yaitu, jika utara sesuai dengan nilai nol, maka 90 derajat bukan timur, seperti pada yang "bergeser", tetapi barat.  Karena kita memiliki 16 gradasi arah, kita perlu mengalikan nilai kode dengan 22,5 (360/16) untuk mendapatkan arah dalam derajat busur biasa. <br><br>  Sekarang algoritma aktual vektor disederhanakan rata-rata arah dari 4 nilai kode: <br><br><pre><code class="plaintext hljs">. . . . . float wSin=0; // sin float wCos=0; // cos float wind_Rad; //   for (byte i=0; i&lt;4; i++){ wind_Rad= ((float(wDirAvr[i])*22.5)*M_PI/180); //   wSin=wSin+sin(wind_Rad);//    sin wCos=wCos+cos(wind_Rad);//    cos } // wSin=wSin/4;// sin â€“    ,   wCos=wCos/4; // cos wind_Rad = acos(wCos); //     arccos if (wSin&lt;0) wind_Rad=2*M_PI-wind_Rad; //   sin int wind_G = round ((wind_Rad*180/M_PI)/22.5); //    0-15 . . . . .</code> </pre> <br>  Baris terakhir yang kita konversi rata-rata, yang dinyatakan dalam radian, ke rata-rata, yang dinyatakan dalam kode kita dari 0 menjadi 15. Anda kemudian dapat mengubahnya kembali menjadi kode Gray, maka Anda bahkan tidak perlu mengubah program dalam modul utama untuk menampilkan arah. <br><br>  Di sini, sebenarnya, adalah keseluruhan algoritma.  Saya takut perhitungan cosinus-arcsin akan memperlambat controller Arduino yang lemah (hingga saat ini 32-bit), tetapi tidak ada yang terjadi: ia menelan kode tanpa berkedip ... LED, mungkin. <br><br>  <b>UPD</b> : Untuk penulis, algoritme berfungsi dalam bentuk ini selama beberapa bulan tanpa kegagalan.  Namun, para komentator menuntun saya pada kesalahan yang mungkin, walaupun sangat mustahil dalam praktiknya: jika data berisi dua kelompok pengukuran yang jaraknya kira-kira 180 derajat dari satu sama lain di dekat nilai nol kosinus (mis., Sekitar 90 dan 270 derajat), maka algoritma akan menghasilkan kesalahan nilai.  Untuk menghindarinya, alih-alih acos (), gunakan fungsi atan2 (wSin, wCos), yang segera menghasilkan hasil yang benar dengan mempertimbangkan tanda sinus dan kosinus (terima kasih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asterster</a> atas bantuannya).  Garis di mana nilai rata-rata wSin dihitung harus dihapus, dan garis disesuaikan untuk tanda wSin tidak diperlukan.  Sebagai gantinya, Anda perlu memasukkan gips ke nilai positif sudut (karena atan2 memberikan nilai dari pi ke -pi): <br><pre> <code class="plaintext hljs">if (wind_Rad&lt;0) wind_Rad=2*M_PI+wind_Rad;</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423243/">https://habr.com/ru/post/id423243/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423233/index.html">Kecerdasan Buatan di Dunia Nyata</a></li>
<li><a href="../id423235/index.html">Dari Dribbble ke Android Motion</a></li>
<li><a href="../id423237/index.html">Lengan robot yang sederhana namun canggih</a></li>
<li><a href="../id423239/index.html">Buat paket untuk Kubernetes dengan Helm: struktur bagan dan templating</a></li>
<li><a href="../id423241/index.html">Gambaran Umum Ponsel SIP Digip A20 dan A25</a></li>
<li><a href="../id423247/index.html">Apa itu kecerdasan?</a></li>
<li><a href="../id423249/index.html">Rust 1.29 Rilis</a></li>
<li><a href="../id423251/index.html">Akun saya dari Megafail</a></li>
<li><a href="../id423253/index.html">Domestik CAD-platform nanoCAD Plus 10: kompleks universal bagi mereka yang mendesain</a></li>
<li><a href="../id423257/index.html">Argumen Fungsi sebagai Konstanta Bit dalam PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>