<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùÑÔ∏è üëñ üï∏Ô∏è Comment automatiser la cr√©ation de machines virtuelles? Nous racontons en d√©tail üëê ‚ûó üñïüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La cr√©ation d'une nouvelle machine virtuelle prend du temps. Et plus il y a d'infrastructure et d'organisation, plus il y a de proc√©dures associ√©es √† ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment automatiser la cr√©ation de machines virtuelles? Nous racontons en d√©tail</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/icl_services/blog/425129/"> La cr√©ation d'une nouvelle machine virtuelle prend du temps.  Et plus il y a d'infrastructure et d'organisation, plus il y a de proc√©dures associ√©es √† ce processus.  Nous avons automatis√© ce processus √† l'aide de PowerShell. <br><br>  Bienvenue √† kat si vous √™tes int√©ress√©. <br><br><img src="https://habrastorage.org/webt/fv/fr/cc/fvfrccl_crsi5nfvcnstarorits.jpeg"><br><br><a name="habracut"></a><br>  Les programmeurs n'aiment pas faire un double travail, les administrateurs syst√®me aussi. <br><br>  Ci-dessous, un exemple d'automatisation d'un de nos clients. <br><br>  Nous voulions nous assurer que tout ing√©nieur ou chef de projet pouvait cr√©er une nouvelle machine virtuelle avec un minimum d'effort et pour une p√©riode minimale.  Notre client dispose d'un syst√®me ITSM, dans cet exemple c'est ServiceNow, nous avons cr√©√© le formulaire web correspondant dans le catalogue de service.  Pour ¬´commander¬ª une nouvelle machine, le gestionnaire doit remplir les champs et confirmer la ¬´commande¬ª, apr√®s que la cha√Æne de processus est lanc√©e, et √† la sortie, nous pr√©parons la machine pour l'utilisation. <br><br>  Examinons donc ce qu'un gestionnaire doit d√©finir pour cr√©er une nouvelle machine virtuelle: <br><br><img src="https://habrastorage.org/webt/3l/8d/yo/3l8dyowobrfvbgpznotayqjywvu.png"><br><br>  <b>Description de la machine virtuelle: description de la machine virtuelle</b> <b><br></b>  Quelques clarifications sont n√©cessaires ici.  Dans notre solution, PowerShell 5.1 est activement utilis√©, donc bien que sous Windows uniquement, nous essaierons √† l'avenir d'ajouter la prise en charge des machines Unix et de passer √† PowerShell Core. <br><br>  <b>OS</b> , syst√®me d'exploitation.  Il n'y a pas d'obstacles particuliers √† l'utilisation de Windows 2008 (R2), mais nous utilisons 2012R2 ou 2016. <br><br>  <b>Taille de</b> la machine virtuelle, taille de la machine virtuelle.  Pour chacun, cela peut √™tre d√©termin√© √† sa mani√®re, dans cet exemple Petit Ram 1CPU-4Gb, Moyen 2CPU-8Gb, Grand 4-16. <br><br>  <b>VM Storage</b> , Disk 0 (C: \) a une taille fixe que vous ne pouvez pas modifier, seul le s√©lecteur de stockage rapide / lent est disponible.  ¬´Fast¬ª peut √™tre un niveau de stockage avec SSD, et ¬´Slow¬ª peut √™tre un stockage sur des disques durs ¬´ordinaires¬ª (bien s√ªr, SAN).  Disk1 (Disk2 en avant) a √©galement un s√©lecteur pour s√©lectionner le stockage, ainsi que des champs pour entrer la taille souhait√©e en gigaoctets, Lettre pour la partition et la taille du cluster (ce qui est important pour SQL Server). <br><br>  <b>Confiance</b> , nous d√©terminons que la machine doit √™tre jointe au domaine ou non, avec acc√®s depuis le r√©seau public ou non. <br><br>  <b>Type</b> , type de machine.  Presque chaque machine peut √™tre d√©finie comme une application frontale ou principale ou autre dans tous les autres cas.  En fonction du type s√©lectionn√©, nous pouvons en outre d√©terminer le sous-r√©seau le plus appropri√© pour la machine. <br><br>  <b>Environnement</b> , dans l'infrastructure du client, il existe deux centres de donn√©es: primaire (production) et secondaire (d√©veloppement / test), les CC sont connect√©s par un canal de communication rapide et offrent une tol√©rance aux pannes.  Par accord, toutes les machines virtuelles dans Primary DC ont une adresse IP commen√ßant √† 10.230 et dans Secondary DC √† 10.231. <br><br>  <b>(SLA) Service Level Agreement</b> , ce param√®tre affecte la qualit√© de service de cette machine. <br><br>  <b>Les applications</b>  Nous avons ajout√© la possibilit√© d'installer et de configurer SQL Server.  Vous devez s√©lectionner l'√©dition, le nom de l'instance et le classement.  Il est √©galement possible de configurer √† la fois le r√¥le de serveur Web et bien plus encore. <br><br>  Nous devons maintenant d√©terminer comment stocker les valeurs s√©lectionn√©es.  Nous avons d√©cid√© que le format le plus pratique √©tait un fichier JSON.  Comme je l'ai dit plus t√¥t, l'environnement du client utilise ITSM ServiceNow;  le gestionnaire, apr√®s avoir s√©lectionn√© toutes les valeurs n√©cessaires, clique sur le bouton ¬´commander¬ª et apr√®s cela, ServiceNow passe tous les param√®tres √† notre script PowerShell (au back-end ServiceNow), qui cr√©era le fichier JSON.  Cela ressemble √† ceci: <br><br><pre><code class="plaintext hljs">.\CreateConfiguration.ps1 -SecurityZone trusted -VMDescription "VM for CRM System" -Requestor "evgeniy.vpro" -OSVersion 2k16 -OSEdition Standard -BuildNewVM -VMEnvironment Prod -VMServiceLevel GOLD -VMSize Medium -Disk0Tier Fast -Disk1Size 50 -Disk1Tier Eco -Disk1Letter D -MSSQLServer -MSSQLInstanceName "Instance1" -SQLCollation Latin1_General_CI_AS -SQLEdition Standard -Disk2Size 35 -Disk3Size 65</code> </pre> <br><br>  Dans le corps du script CreateConfiguration .ps1: <br><br><pre> <code class="plaintext hljs"># PowerShell- $config = [ordered]@{} #    . $config.SecurityZone=$SecurityZone</code> </pre><br><br>  √Ä la fin, exportez notre objet dans un fichier JSON: <br><br><pre> <code class="plaintext hljs">$ServerConfig = New-Object ‚ÄìTypeName PSObject $config ConvertTo-Json -InputObject $ServerConfig -Depth 100 | Out-File "C:\Configs\TargetNodes\Build\$($Hostname.ToLower()).json" -Force</code> </pre><br><br>  Exemple de configuration: <br><br><pre> <code class="plaintext hljs">{ "Hostname": "dsctest552", "SecurityZone": "trusted", "Domain": "testdomain", "Requestor": "evgeniy.vpro", "VM": { "Size": "Medium", "Environment": "Prod", "SLA": "GOLD", "DbEngine": "MSSQL", "RAM": 8, "Storage": [ { "Id": 0, "Tier": "Fast", "Size": "100", "Allocation": 4, "Letter": "C" }, { "Id": 1, "Tier": "Eco", "Size": 50, "Label": "Data", "Allocation": 64, "Letter": "D" }, { "Id": 2, "Tier": "Fast", "Size": 35, "Label": "Data", "Allocation": 64, "Letter": "E" }, { "Id": 3, "Tier": "Fast", "Size": 65, "Label": "Data", "Allocation": 64, "Letter": "F" } ] }, "Network": { "MAC": "", "IP": "10.230.168.50", "Gateway": "10.230.168.1", "VLAN": ‚ÄúVLAN168‚Äù }, "OS": { "Version": "2k16", "Edition": "Standard", "Administrators": [ "LocaAdmin", "testdomain\\ Security-LocalAdmins" ] }, "OU": "OU=Servers,OU=Staging,DC=testdomain", "Applications": [ { "Application": "Microsoft SQL Server 2016", "InstanceName": "vd", "Collation": "Latin1_General_CI_AS", "Edition": "Standard", "Features": "SQLENGINE", "Folders": { "DataRoot": "E:\\MSSQL", "UserDB": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Data", "UserLog": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Log", "TempDB": "D:\\MSSQL\\MSSQL11.vd\\MSSQL\\TempDB", "TempDBLog": "D:\\MSSQL\\MSSQL11.vd\\MSSQL\\TempDB", "Backup": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Backup" }, "MaxMemory": 2147483647 } ], "Description": "VM for CRM", "Certificate": { "File": null, "Thumbprint": null }, "Version": 0 }</code> </pre><br><br>  Vous avez peut-√™tre remarqu√© que le formulaire Web n'avait pas de nom de machine virtuelle ni d'adresse IP.  Nous obtenons ces valeurs automatiquement comme suit: <br><br>  <b>Le nom de la machine</b> , ITSM ServiceNow a une section sp√©ciale: CMDB (Configuration Management Data Base), cette base de donn√©es stocke tous les enregistrements sur les machines virtuelles existantes, leur √©tat, l'√©quipe d'assistance, etc.  Nous avons cr√©√© environ 200 enregistrements de sauvegarde avec le statut Allou√©.  Pour obtenir un nom pour la machine virtuelle, nous faisons une demande REST √† CMDB et obtenons le premier enregistrement ¬´gratuit¬ª et passons son statut d'Allou√© √† l'installation en attente. <br><br>  <b>Adresse IP et VLAN</b> , nous avons d√©ploy√© IPAM sur notre r√©seau - il s'agit d'une fonctionnalit√© int√©gr√©e √† Windows Server 2016 qui vous permet de g√©rer les adresses IP sur votre r√©seau.  Il n'est pas du tout n√©cessaire d'utiliser toutes les fonctionnalit√©s d'IPAM (DHCP, DNS, AD), mais de ne l'utiliser que comme base de donn√©es d'adresses IP avec une extension potentielle des fonctionnalit√©s.  Le script qui cr√©e le fichier JSON fait une demande √† IPAM pour la premi√®re adresse IP libre sur le sous-r√©seau.  Et le sous-r√©seau VLAN (sous-r√©seau x / 24) est d√©termin√© en fonction des valeurs SLA, Environment, Trust et Type s√©lectionn√©es. <br>  Le fichier de configuration est pr√™t, tous les champs sont en place, vous pouvez cr√©er une machine.  La question est: ¬´comment stocker les informations d'identification pour tous nos scripts?¬ª.  Nous utilisons le package <a href="">CredentialManager</a> .  Ce package fonctionne avec l'API Windows Credential Manager int√©gr√©e pour stocker les mots de passe.  Exemple de cr√©ation d'un mot de passe: <br><br><pre> <code class="plaintext hljs">New-StoredCredential -Target "ESXi" -UserName "testdomain.eu\vmwareadm" -Password "veryultraP@ssw00rd." -Type Generic -Persist LocalMachine</code> </pre><br><br>  Le mot de passe sera disponible pour lecture sur cette machine et ce compte. <br><br><pre> <code class="plaintext hljs">$ESXiAdmin = Get-StoredCredential -Type Generic -Target ESXi</code> </pre> <br><br>  Nous avons un serveur sur lequel toutes les configurations avec GIT sont stock√©es, nous pouvons maintenant suivre de mani√®re fiable tous les changements de configurations: qui, quoi, o√π et quand. <br><br>  La t√¢che planifi√©e est configur√©e sur ce serveur: v√©rifiez le dossier avec les configurations et √©crivez dans le journal des √©v√©nements Windows toutes les modifications. <br><br>  Apr√®s 15 minutes, la t√¢che planifi√©e √©crira dans Windows EventLog qu'un nouveau fichier de configuration a √©t√© d√©tect√©. <br><br>  Il est temps de v√©rifier cette configuration.  Tout d'abord, nous devons nous assurer que le fichier a la bonne mise en forme: <br><br><pre> <code class="plaintext hljs">$Configuration=(Get-Content -Raw $File | Out-String | ConvertFrom-Json)</code> </pre> <br><br>  Si tout va bien, il est temps de commencer √† cr√©er la machine et d'ex√©cuter le script BuildVM.ps1. <br><br>  Dans BuildVM.ps1, nous v√©rifions que le fichier de configuration a une description de toutes les caract√©ristiques de la machine virtuelle: taille, env, sla, type, stockage, ram, r√©seau. <br><br>  Assurez-vous de v√©rifier s'il existe une machine du m√™me nom dans l'infrastructure (CheckVM.ps1). <br>  Nous nous connectons via la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CLI VMWare PowerShell</a> √† notre vSphere: <br><br><pre> <code class="plaintext hljs">$VmWareAdmin = Get-StoredCredential -Type Generic -Target ESXi Connect-VIServer -Server "vSphereSrv" -Credential $VmWareAdmin | Out-Null</code> </pre><br><br>  V√©rifier s'il existe une machine du m√™me nom dans l'infrastructure <br><br><pre> <code class="plaintext hljs">$VM=Get-VM $server -ErrorAction SilentlyContinue</code> </pre> <br><br>  Et d√©sactivez: <br><br><pre> <code class="plaintext hljs">Disconnect-VIServer * -Force -Confirm:$false</code> </pre> <br><br>  Assurez-vous que la machine n'est pas non plus disponible sur WinRM <br><br><pre> <code class="plaintext hljs">$ping=Test-NetConnection -ComputerName $Configuration.Hostname -CommonTCPPort WINRM -InformationLevel Quiet -ErrorAction SilentlyContinue</code> </pre> <br><br>  Si $ VM et $ ping sont vides, vous pouvez cr√©er une nouvelle machine.  (Nous traitons les situations o√π une machine est d√©j√† cr√©√©e manuellement dans ESXi ou cette machine se trouve dans un autre centre de donn√©es.) <br><br><blockquote>  Quelques mots sur la voiture.  Il s'agit d'une image de machine virtuelle pr√©par√©e qui a √©t√© finalis√©e par sysprep et convertie en mod√®le dans notre vSphere.  L'administrateur local avec le mot de passe connu est enregistr√© dans l'image, ce compte ne plante pas apr√®s sysprep, ce qui nous permettra d'acc√©der √† chaque machine √† partir de ce mod√®le, et plus tard nous pourrons remplacer ce mot de passe pour des raisons de s√©curit√©. </blockquote><br><br><h3>  Cr√©ation d'une machine virtuelle <br></h3><br>  Trouvez le cluster SLR correspondant: <br><br><pre> <code class="plaintext hljs">$Cluster=Get-Cluster -Name $Configuration.VM.SLA</code> </pre> <br><br>  V√©rifiez que nous avons suffisamment d'espace sur le magasin de donn√©es: <br><br><pre> <code class="plaintext hljs">$DatastoreCluster = Get-DatastoreCluster |Where-Object {$_.Name -like $Datastore1Name} $Datastore1 = Get-Datastore -Location $DatastoreCluster |sort -Property "FreeSpaceGB" |select -Last 1 IF ($Datastore1.FreeSpaceGB -le "200"){ Write-Host -foreground red "STOP: Not enough datastore capacity for DISK" $vdisk.Id Break }</code> </pre><br><br>  Et assez de m√©moire: <br><br><pre> <code class="plaintext hljs">$VMHost = Get-VMHost -Location $Cluster |sort -Property "MemoryUsageGB" |select -First 1 IF ($VMHost.MemoryUsageGB -le "20"){ Write-Host -foreground red "STOP: No enough ESXi host capacity" Break }</code> </pre><br><br>  Nous prenons notre mod√®le <br><br><pre> <code class="plaintext hljs">$VMTemplate = Get-Template -Name 'Win2016_Std_x64_Template'</code> </pre> <br><br>  Et cr√©ez une nouvelle machine virtuelle <br><br><pre> <code class="plaintext hljs">New-VM -Name $Configuration.Hostname.ToUpper() -VMHost $VMHost -ResourcePool $ResourcePool -Datastore $Datastore -Template $VMTemplate -Location "AutoDeployed VMs"</code> </pre> <br><br>  Il est important de connecter l'interface r√©seau √† un sous-r√©seau avec DHCP activ√©. <br><br>  Nous d√©marrons la machine virtuelle <br><br><pre> <code class="plaintext hljs">Start-VM $VM</code> </pre> <br><br>  Et enregistrez la description de la machine, afin de pouvoir ult√©rieurement d√©terminer la machine au niveau VMWare. <br><br><pre> <code class="plaintext hljs">Set-Annotation -Entity $VM -CustomAttribute "Change request" -Value $Configuration.Request -Confirm:$false Set-VM $VM -Notes $Configuration.Description -Confirm:$false</code> </pre><br><br>  La machine a d√©marr√© et maintenant nous pouvons trouver l'adresse MAC re√ßue: <br><br><pre> <code class="plaintext hljs">$vMAC = (($VM | Get-NetworkAdapter | Select-Object -Property "MacAddress").MacAddress).Replace(':','')</code> </pre> <br><br>  Enregistrez cette valeur dans notre fichier JSON. <br><br><pre> <code class="plaintext hljs">$Configuration.Network.MAC=$VMAC ConvertTo-Json -InputObject $Configuration -Depth 100 | Out-File "C:\Configs\TargetNodes\Build\$Hostname.json" -Force</code> </pre><br><br>  Voici le temps de vous engager dans notre Git que la machine est cr√©√©e et poss√®de son propre MAC unique. <br><br>  La machine commence l'initialisation (apr√®s sysprep), l'installation de l'√©quipement et la configuration initiale. <br><br>  Attendons que notre machine WinRM soit disponible avec le script EstablishConnection.ps1. <br><br>  Nous d√©couvrons d'abord quelle IP la machine a re√ßue de DHCP: <br><br><pre> <code class="plaintext hljs"># $MAC = $vMAC while($isOnline -ne $true){ if((Get-DhcpServerv4Lease -ClientId $MAC -ScopeId $StagingDHCPScope -ComputerName $DHCPServer -ErrorAction Ignore).IPAddress.IPAddressToString){ $tempIP=(Get-DhcpServerv4Lease -ClientId $MAC -ScopeId $StagingDHCPScope -ComputerName $DHCPServer).IPAddress.IPAddressToString break } else{ if($isOnline -ne $true){ Write-Host "`r$i`t" -NoNewline $i++ } } }</code> </pre><br><br>  Et maintenant, nous attendrons, lorsque la machine sera disponible sur WinRM: <br><br><pre> <code class="plaintext hljs">$LocalAdmin = Get-StoredCredential -Type Generic -Target LocalAdmin $i=0 $isOnline=$false while($isOnline -ne $true){ if(Invoke-Command -ComputerName $tempIP -ScriptBlock{ Get-ItemProperty -Path "Registry::\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing" } -Credential $LocalAdmin -ErrorAction SilentlyContinue){ $isOnline=$true break } else{ if($isOnline -ne $true){ Write-Host "`r$i" -NoNewline $i++ Start-Sleep -Seconds 1 } } }</code> </pre><br><br>  La machine est pr√™te √† rouler. <br><br><h3>  Configuration de l'√©tat souhait√© <br></h3><br>  Pour configurer la configuration souhait√©e, nous utilisons la partie PowerShell - DSC (Desired State Configuration).  Il existe un serveur Pull DSC configur√© sur le r√©seau: dscpull.testdomain.eu. <br>  Vous trouverez ci-dessous la configuration de notre serveur DSC Pull.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bon article sur la configuration de DSC Pull.</a> <br><br><pre> <code class="plaintext hljs">Node $NodeName { WindowsFeature DSCServiceFeature { Ensure = "Present" Name = "DSC-Service" } xDscWebService PSDSCPullServer { Ensure = "Present" EndpointName = "PSDSCPullServer" Port = 8080 PhysicalPath = "$env:SystemDrive\inetpub\PSDSCPullServer" CertificateThumbPrint = $certificateThumbPrint ModulePath = "$env:PROGRAMFILES\WindowsPowerShell\DscService\Modules" ConfigurationPath = "$env:PROGRAMFILES\WindowsPowerShell\DscService\Configuration" State = "Started" DependsOn = "[WindowsFeature]DSCServiceFeature" RegistrationKeyPath = "$env:PROGRAMFILES\WindowsPowerShell\DscService" AcceptSelfSignedCertificates = $true UseSecurityBestPractices = $true } File RegistrationKeyFile { Ensure = 'Present' Type = 'File' DestinationPath = "$env:ProgramFiles\WindowsPowerShell\DscService\RegistrationKeys.txt" Contents = $RegistrationKey } }</code> </pre><br><br>  Il est disponible sur: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://dscpull.testdomain.eu:8080</a> <br><br>  Son point de terminaison: <a href="">https://dscpull.testdomain.eu:8080/PSDSCPullserver.svc</a> <br><br>  Tous les clients de serveur pull doivent avoir PowerShell 5.1 install√© <br>  Si PowerShell 5.1 n'est pas install√©: <br><br><pre> <code class="plaintext hljs">$PSVersionTable.PSVersion.Major ‚Äìlt 5</code> </pre> <br><br>  installer PowerShell 5.1: <br><br><pre> <code class="plaintext hljs">Write-Host "Download PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock { [System.Net.ServicePointManager]::SecurityProtocol=[System.Net.SecurityProtocolType]::Tls12;Invoke-WebRequest -Uri "https://dscpull.testdomain.eu:8080/Files/Updates/WMF.msu" -OutFile C:\TEMP\WMF.MSU } Write-Host "Extract PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock {Start-Process -FilePath 'wusa.exe' -ArgumentList "C:\temp\WMF.msu /extract:C:\temp\" -Wait -PassThru } Write-Host "Apply PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock {Start-Process -FilePath 'dism.exe' -ArgumentList "/online /add-package /PackagePath:C:\temp\WindowsBlue-KB3191564-x64.cab /Quiet" -Wait -PassThru } Write-Host "PowerShell 5.1 has been installed"</code> </pre><br><br>  Un serveur PKI est √©galement d√©ploy√© sur notre r√©seau.  Il s'agit d'une condition pour le cryptage s√©curis√© des informations d'identification stock√©es dans les fichiers mof DSC (les fichiers mof sont la ¬´langue¬ª dans laquelle Pull Server et ses clients communiquent).  Lorsqu'un client essaie de s'enregistrer sur le serveur Pull, il est n√©cessaire de sp√©cifier un certificat d'empreinte num√©rique et plus tard, le serveur Pull utilisera ce certificat pour crypter les mots de passe.  Ci-dessous, nous verrons comment cela fonctionne. <br><br>  Importez Root CA sur notre nouvelle machine: <br><br><pre> <code class="plaintext hljs"> Invoke-Command -ComputerName $server -ScriptBlock{ $PKI="-----BEGIN CERTIFICATE----- MIIF2TCCA8GgAwIBAgIQSPIjcff9rotNdxbg3+ygqDANBgkqhkiG9w0BAQUFADAe **************************************************************** znafMvVx0B4tGEz2PFss/FviGdC3RohBHG0rF5jO50J4nS/3cGGm+HGdn1w/tZd0 a0FWpn9VCOSmXM2It+tSW1f4nZVt6T2kr1ZlTxkDhT7HMSGsrX/XJswzCkDGe3dE qrVVjNUkhVTaeeBWdujB5J6mcx7YkNsAUhODiS9Cf7FnYnxLFA72M0pijI48P5F0 ShM9HWAAUIrLkv13ug== -----END CERTIFICATE-----" $PKI | Out-File RootCA.cer Import-Certificate RootCA.cer -CertStoreLocation Cert:\LocalMachine\Root | select Thumbprint | Out-Null } -Credential $LocalAdmin | Out-Null</code> </pre><br><br>  Pour poursuivre les travaux, nous avons besoin d'une paire de cl√©s RSA.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous allons g√©n√©rer un certificat auto-sign√©</a> et travailler temporairement avec lui. <br><br>  Maintenant, nous pouvons nous inscrire sur le Pull Server: <br><br><pre> <code class="plaintext hljs">$DscHostFQDN = [System.Net.Dns]::GetHostEntry([string]$env:computername).HostName $DscPullServerURL = "https://$($DscHostFQDN):8080/PSDSCPullserver.svc" $DscWebConfigChildPath = '\inetpub\psdscpullserver\web.config' $DscWebConfigPath = Join-Path -Path $env:SystemDrive -ChildPath $DscWebConfigChildPath $DscWebConfigXML = [xml](Get-Content $DscWebConfigPath) $DscRegKeyName = 'RegistrationKeys.txt' $DscRegKeyXMLNode = "//appSettings/add[@key = 'RegistrationKeyPath']" $DscRegKeyParentPath = ($DscWebConfigXML.SelectNodes($DscRegKeyXMLNode)).value $DscRegKeyPath = Join-Path -Path $DscRegKeyParentPath -ChildPath $DscRegKeyName $DscRegKey = Get-Content $DscRegKeyPath [DSCLocalConfigurationManager()] configuration RegisterOnPull { Node $Node { Settings { ConfigurationModeFrequencyMins = 1440 CertificateID = $Thumbprint RefreshMode ='Pull' RefreshFrequencyMins = 1440 RebootNodeIfNeeded = $true ConfigurationMode ='ApplyAndAutoCorrect' AllowModuleOverwrite = $true DebugMode = 'None' StatusRetentionTimeInDays = 1 } ConfigurationRepositoryWeb $([string]$env:computername) { ServerURL = $DscPullServerURL RegistrationKey = $DscRegKey CertificateID = $Thumbprint ConfigurationNames = @("$hostx") } } } RegisterOnPull -OutputPath $MetaConfigsStorage Set-DscLocalConfigurationManager -ComputerName $Node -Path $MetaConfigsStorage -Verbose -Force -Credential $LocalAdmin</code> </pre><br><br>  Envoyez la premi√®re configuration √† notre machine <br><br><pre> <code class="plaintext hljs">Configuration Rename { param ( [Parameter()] [System.String[]] $Node, $hostname ) Import-DscResource -ModuleName xComputerManagement Import-DscResource ‚ÄìModuleName PSDesiredStateConfiguration Node $Node { xComputer JoinDomain { Name = $hostname } } } Rename -Node $Node -OutputPath $DscConfigPath -hostname $hostname New-DscChecksum $DscConfigPath -Force Invoke-Command -ComputerName $Node -ScriptBlock{Update-DscConfiguration -Verbose -Wait } -Credential $LocalAdmin -Verbose</code> </pre><br><br>  Le serveur renommera et red√©marrera automatiquement.  Nous pouvons maintenant ex√©cuter Join Domain. <br><br><pre> <code class="plaintext hljs">Configuration JoinAD { param ( [Parameter()] [System.String[]] $Node, [Parameter(Mandatory = $true)] [ValidateNotNullorEmpty()] [System.Management.Automation.PSCredential] $DomainAdmin, $hostname, $domain ) Import-DscResource -ModuleName xComputerManagement Import-DscResource ‚ÄìModuleName PSDesiredStateConfiguration Node $Node { xComputer JoinDomain { Name = $hostname DomainName = $domain Credential = $DomainAdmin JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu" } GroupSet LocalAdmins { GroupName = @( 'Administrators') Ensure = 'Present' MembersToInclude = @( 'testdomain-eu\dscstaging' ) } } } $cd = @{ AllNodes = @( @{ NodeName = $Node PSDscAllowPlainTextPassword = $false PSDscAllowDomainUser=$true Certificatefile = $CertFile Thumbprint = $Certificate.ToString() } ) } JoinAD -Node $Node -OutputPath $DscConfigPath -DomainAdmin $DomainAdmin -hostname $hostname -ConfigurationData $cd -domain $domain New-DscChecksum $DscConfigPath -Force Invoke-Command -ComputerName $Node -ScriptBlock{Update-DscConfiguration -Verbose -Wait } -Credential $LocalAdmin -Verbose</code> </pre><br><br>  Voici √† quoi ressemble notre fichier mof: <br><br><pre> <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> de <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H \ nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO + BEyD2cr6vKHdn \ nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT + GX4IkPezR \ nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp + VQCx2ljlwif6ac4X / PQG \ n ----- ----- FIN CMS"; <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> </pre><br><br>  Informations d'identification chiffr√©es DSC √† partir d'un compte de service avec des droits d'administrateur de domaine: testdomain.eu \\ service_DomainJoin_001 avec un certificat auto-sign√©.  Le client DSC avec sa cl√© priv√©e d√©chiffre les informations d'identification et applique tous les modules de configuration avec les informations d'identification de domaine sp√©cifi√©es.  Dans ce cas, il effectue la jointure de domaine dans l'unit√© d'organisation sp√©cifi√©e. <br><br><pre> <code class="plaintext hljs">GroupSet LocalAdmins { GroupName = @( 'Administrators') Ensure = 'Present' MembersToInclude = @( testdomain-eu\dscstaging' ) }</code> </pre><br><br>  Ce module ajoute dscstaging aux administrateurs locaux pour une configuration suppl√©mentaire. <br><br>  Apr√®s le red√©marrage, nous pourrons entrer dans la machine avec les informations d'identification du domaine. <br><br>  Nous attendons que le serveur re√ßoive un certificat de notre PKI (nous avons configur√© l'inscription automatique) et √† l'avenir, nous travaillerons avec le certificat √©mis par notre PKI. <br><br><pre> <code class="plaintext hljs">$vmcert=Invoke-Command -ComputerName $server -ScriptBlock{ return Get-ChildItem -Path cert:\LocalMachine\My | where {$_.EnhancedKeyUsageList.FriendlyName -eq "Document Encryption"-and $_.Issuer -eq "CN=TestDomain Issuing CA, DC=testdomain, DC=eu"} } -ErrorAction Ignore</code> </pre> <br><br>  Inscrivez-vous √† nouveau √† Pull Server avec l'empreinte num√©rique mise √† jour. <br><br>  Voil√†, la machine jointe au domaine, et nous pouvons l'utiliser de la mani√®re qui nous convient. <br><br><h3>  Installer SQL Server <br></h3><br>  Le fichier JSON d√©crit les exigences pour MS SQL Server, nous utilisons √©galement DSC pour installer et configurer SQL Server.  Voici √† quoi ressemble la configuration: <br><br><pre> <code class="plaintext hljs">Configuration $Node{ WindowsFeature "NetFramework35"{ Name = "NET-Framework-Core" Ensure = "Present" Source = "\\$DscHostFQDN\Files\Updates" } WindowsFeature "NetFramework45"{ Name = "NET-Framework-45-Core" Ensure= "Present" } SqlSetup "MSSQL2012NamedInstance"{ InstanceName = $MSSQL.InstanceName Features = $MSSQL.Features ProductKey = $ProductKey SQLCollation = $MSSQL.Collation SQLSysAdminAccounts = @('testdomain-EU\SQLAdmins',' testdomain-EU\Backup') InstallSharedDir = "C:\Program Files\Microsoft SQL Server" InstallSharedWOWDir = "C:\Program Files (x86)\Microsoft SQL Server" InstallSQLDataDir = $MSSQL.DataRoot SQLUserDBDir = $MSSQL.UserDBDir SQLUserDBLogDir = $MSSQL.UserLogDir SQLTempDBDir = $MSSQL.TempDBDir SQLTempDBLogDir = $MSSQL.TempDBLogDir SQLBackupDir = $MSSQL.BackupDir SourcePath = $SQLSource SAPwd = $SA SecurityMode = 'SQL' UpdateSource = ".\Updates" Action = "Install" ForceReboot = $True SQLSvcAccount = $SqlServiceCredential AgtSvcAccount = $SqlServiceCredential ISSvcAccount = $SqlServiceCredential BrowserSvcStartupType = "Automatic" DependsOn = '[WindowsFeature]NetFramework35', '[WindowsFeature]NetFramework45' }</code> </pre><br>  O√π $ MSSQL est d√©fini: <br><pre> <code class="plaintext hljs">$MSSQL=$Configuration.Applications | where {$_.Application -eq "Microsoft SQL Server 2012"}</code> </pre> <br><br>  $ MSSQL.InstanceName - tout cela est indiqu√© dans notre fichier Json.  L'application de cette configuration installera MS SQL Server avec toutes les mises √† jour du dossier Updates et red√©marrera le serveur si n√©cessaire. <br><br>  La voiture est pr√™te. <br><br><h2>  Service maintenant </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Plusieurs API sont disponibles</a> dans Service-Now.  Nous utilisons l'API Rest. <br>  Pour obtenir une liste des machines avec le statut Allou√©, une requ√™te du formulaire est utilis√©e: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instance.service-now.com/cmdb_ci_server_list.do?sysparm_query=install_status=16</a> ^ u_subtype = ^ ORDERBYname <br>  Dans PowerShell, cela ressemble √† ceci: <br><pre> <code class="plaintext hljs">$url="https://instance.service-now.com/api/now/table/cmdb_ci_server?sysparm_query=install_status=16^u_subtype=^ORDERBYname" $uri= new-object System.Uri("https://instance.service-now.com/") #       $credentials = (Get-StoredCredential -Type Generic -Target DSC).GetNetworkCredential() $credentials = new-object System.Net.NetworkCredential $credentials.UserName, $credentials.SecurePassword Add-Type -AssemblyName System.Net.Http $handler = New-Object System.Net.Http.HttpClientHandler $handler.CookieContainer = New-Object System.Net.CookieContainer $handler.UseCookies=$true $handler.Credentials=$credentials $HttpClient = New-Object System.Net.Http.HttpClient($handler) $HttpClient.BaseAddress= $uri $Header = New-Object System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json") $HttpClient.DefaultRequestHeaders.Accept.Clear() $HttpClient.DefaultRequestHeaders.Accept.Add($Header); $response=$HttpClient.GetAsync($url) $respStream=$response.Result.Content.ReadAsStringAsync() $Servers = $respStream.Result | ConvertFrom-Json #   Configuration Items  $ServersCI=$Servers.result</code> </pre> <br>  Le premier objet tableau est le nom d'h√¥te dont nous avons besoin. <br>  Si la machine est pr√™te, vous pouvez modifier l'√©tat de la machine dans Service-Now, pour cela le script UpdateCI.ps1: <br><pre> <code class="plaintext hljs">param( $CI, [ValidateSet("Allocated","In use","Pending install")] $NewStatus='In use' ) $url="https://instance.service-now.com/api/now/table/cmdb_ci_server?sysparm_query=name=$CI" $uri= new-object System.Uri("https://instance.service-now.com/") $credentials = (Get-StoredCredential -Type Generic -Target DSC).GetNetworkCredential() $credentials = new-object System.Net.NetworkCredential $credentials.UserName, $credentials.SecurePassword Add-Type -AssemblyName System.Net.Http $handler = New-Object System.Net.Http.HttpClientHandler $handler.CookieContainer = New-Object System.Net.CookieContainer $handler.UseCookies=$true $handler.Credentials=$credentials $HttpClient = New-Object System.Net.Http.HttpClient($handler) $HttpClient.BaseAddress= $uri $Header = New-Object System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json") $HttpClient.DefaultRequestHeaders.Accept.Clear() $HttpClient.DefaultRequestHeaders.Accept.Add($Header); $response=$HttpClient.GetAsync($url) $respStream=$response.Result.Content.ReadAsStringAsync() $Servers = $respStream.Result | ConvertFrom-Json $ServerCI=$Servers.result[0] $update=@{} if($NewStatus -eq "In use"){ $update.install_status=1 } if($NewStatus -eq "Pending install"){ $update.install_status=4 } $stringcontent = New-Object System.Net.Http.StringContent((ConvertTo-Json -InputObject $update -Depth 100),[System.Text.Encoding]::UTF8, "application/json"); $result=$HttpClient.PutAsync("https://instance.service-now.com/api/now/table/cmdb_ci_server/$($ServerCI.sys_id)", $stringcontent)</code> </pre> <br>  Pour obtenir la table et les enregistrements, les requ√™tes REST API GET sont utilis√©es, pour modifier les requ√™tes d'enregistrement PUT / POST, dans le corps desquelles les champs que vous devez modifier. <br><br>  <i>Nous avons cr√©√© un outil pratique avec un outil graphique comme Azure Portal, qui nous permet de g√©rer une infrastructure sur site aussi pratique que possible pour nous et nos clients.</i> <br>  PS 12.24.2018.  Tout semble-t-il obsol√®te?  Il est temps d'utiliser Azure DevOps.  Dans le prochain article, je vais vous montrer comment faire tout cela avec le pipeline Azure DevOps. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425129/">https://habr.com/ru/post/fr425129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425113/index.html">¬´Typographie num√©rique¬ª ou mon exp√©rience dans la num√©risation mobile de livres</a></li>
<li><a href="../fr425115/index.html">DevOps √† part enti√®re: trag√©die grecque en trois actes</a></li>
<li><a href="../fr425117/index.html">Deux bits par transistor: ROM haute densit√© dans une puce √† virgule flottante Intel 8087</a></li>
<li><a href="../fr425123/index.html">Le c≈ìur myst√©rieux de la bo√Æte √† rythmes Roland TR-808</a></li>
<li><a href="../fr425125/index.html">@Pythonetc septembre 2018</a></li>
<li><a href="../fr425131/index.html">√Ä lire sur la technologie de la blockchain: guides, livres et articles</a></li>
<li><a href="../fr425133/index.html">Probl√®mes de paiement transfrontaliers - pourquoi et comment la blockchain est-elle utilis√©e ici</a></li>
<li><a href="../fr425135/index.html">Pourquoi la VoIP est reconnue comme un service d'information aux √âtats-Unis, et qu'est-ce que cela signifie pour l'industrie des t√©l√©communications et les utilisateurs</a></li>
<li><a href="../fr425137/index.html">Nous travaillons dans la console rapidement et efficacement</a></li>
<li><a href="../fr425139/index.html">Des stars de la pop sous l'objectif de l'intelligence artificielle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>