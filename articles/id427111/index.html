<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš¿ ğŸ‘¸ ğŸ‘­ Transformasi proses pengembangan dan pengiriman untuk aplikasi lawas â™ ï¸ ğŸ‘¶ğŸ» ğŸš¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tim kami bertanggung jawab untuk pengoperasian dan pengembangan produk perusahaan besar. 
 Pada awal 2017, mengambil istirahat dari implementasi besar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transformasi proses pengembangan dan pengiriman untuk aplikasi lawas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427111/"><p>  Tim kami bertanggung jawab untuk pengoperasian dan pengembangan produk perusahaan besar. <br>  Pada awal 2017, mengambil istirahat dari implementasi besar dan membaca kembali "pelajaran yang dipetik", kami dengan tegas memutuskan untuk meninjau pengembangan dan pengiriman aplikasi kami.  Kami khawatir tentang kecepatan rendah dan kualitas pengiriman, tidak memungkinkan kami untuk memberikan tingkat layanan yang diharapkan pelanggan dari kami. </p><br><p>  Sudah waktunya untuk beralih dari kata-kata ke perbuatan - untuk mengubah proses. </p><br><p>  Artikel ini akan membahas secara singkat di mana kita mulai, apa yang kita lakukan, apa situasinya sekarang, kesulitan apa yang kita hadapi, apa yang harus kita tinggalkan, apa lagi yang kita rencanakan untuk dilakukan. </p><a name="habracut"></a><br><h1 id="nachalo">  Mulai </h1><br><h3 id="nemnogo-o-sisteme">  Sedikit tentang sistem </h3><br><p>  Aplikasi ini adalah contoh klasik dari aplikasi perusahaan monolitik dari "tumpahan arsitektur tahun 2000-an": </p><br><ul><li>  Dioperasikan dan dikembangkan lebih dari 15 tahun. </li><li>  Ini adalah satu set satu setengah lusin WinForms, layanan windows dan ASP. Aplikasi Net diikat ke database MS SQL tunggal. </li><li>  Ukuran basis kode: ~ 1MLOC untuk C #, ~ 9000 objek basis data.  Sebagian besar logika bisnis berjalan di sisi basis data. </li><li>  Aplikasi ini terdiri dari ~ 250+ solusi untuk membuat win / web client (satu solusi per kelompok formulir terkait).  Ini adalah warisan dari proses pengembangan sebelumnya dan arsitektur klien. </li><li>  Aplikasi ini mendukung beberapa jenis proses (klien) dengan mengubah konfigurasi internal: proses pengaturan, izin, bidang fleksibel, dll., Dalam tabel konfigurasi basis data sistem.  Pada saat yang sama, basis kode aplikasi adalah sama untuk semua klien. </li><li>  Aplikasi ini digunakan dan didukung di 25+ situs (setiap situs adalah turunan independen dari sistem) dan melayani total beberapa ribu pengguna akhir di zona waktu yang berbeda. </li></ul><br><h3 id="process-dostavki-do-transformacii">  Proses pengiriman sebelum transformasi </h3><br><ol><li>  Pengembangan dan perakitan aplikasi yang sudah selesai dan komponennya dilakukan oleh kontraktor. </li><li>  kode itu disimpan di sisi kontraktor (versi lokal MS TFS).  Kode ditransmisikan ke pelanggan setiap bulan dalam bentuk arsip dari versi saat ini dari cabang repositori utama. </li><li>  pengiriman dilakukan dengan pengiriman "pembaruan delta": untuk aplikasi (set dll, exe, dll.) dan komponen database (set skrip sql buat / ubah).  Aplikasi dibangun dan paket delta disiapkan oleh kontraktor. </li><li>  proses penyebaran didukung oleh sistem transportasi, perubahan diterapkan secara otomatis. </li></ol><br><p>  Pengiriman dilakukan sebagai bagian dari rilis bulanan (seperti yang telah saya atur, saya katakan sebelumnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). </p><br><h3 id="suschestvovavshie-problemy">  Masalah yang ada </h3><br><p>  <em>Kurangnya kontrol</em> </p><br><ul><li>  Meskipun kepemilikan formal kode, perakitan aplikasi yang sebenarnya oleh pelanggan tidak mungkin. </li><li>  akibatnya, tidak mungkin untuk memverifikasi operabilitas kode yang dikirimkan ke pelanggan. </li><li>  perubahan kode - tidak transparan kepada pelanggan.  Tidak mungkin untuk mencocokkan perubahan yang diminta dan aktual dalam produk. </li><li>  analisis kode sulit untuk SQL, dan tidak mungkin untuk komponen C # </li></ul><br><p>  <em>Masukan dan kesalahan tenaga kerja</em> </p><br><ul><li>  persiapan "paket delta" adalah prosedur yang memakan waktu untuk pengembangan, sumber kesalahan dan biaya proyek tertentu. </li><li>  Menyebarkan aplikasi Delta Packet membutuhkan pelacakan urutan paket.  Kesalahan out-of-order paket adalah masalah penyebaran utama dan sumber insiden yang signifikan. </li><li>  Regresi secara teratur terjadi: kesalahan yang tampaknya telah diperbaiki dan diluncurkan koreksi ke produk muncul lagi. </li></ul><br><p>  <em>Keterbatasan</em> </p><br><ul><li>  kemampuan untuk memulihkan keadaan sistem pada satu waktu di masa lalu (memutar kembali perubahan) hampir tidak ada. </li><li>  kemampuan untuk secara efektif mengukur pengembangan dan menguji sumber daya awal dengan menarik karyawan pelanggan praktis tidak ada. </li></ul><br><h3 id="ozhidaemye-rezultaty">  Hasil yang Diharapkan </h3><br><p>  Pada awal proyek, kami menetapkan tujuan yang jelas bagi kami untuk menyelesaikan masalah yang diidentifikasi di atas. </p><br><ul><li>  Transfer repositori kode ke kontrol pelanggan </li><li>  Pindahkan proses pembuatan aplikasi ke sisi pelanggan </li><li>  Memodifikasi proses distribusi perubahan, meninggalkan "delta perubahan" demi pembaruan lengkap </li></ul><br><p>  Selain itu, dengan menggunakan solusi yang diperoleh ketika dua tujuan pertama tercapai, kami menghitung: </p><br><ul><li>  Meningkatkan kualitas teknis dari solusi yang dihasilkan melalui kontrol kode </li><li>  Tingkatkan keterlibatan pengujian dan kegunaan dengan menyediakan penyebaran swalayan. </li></ul><br><h1 id="etapy-bolshogo-puti">  Tahapan yang Jauh </h1><br><h3 id="analiz-tekuschego-sostoyaniya-processov-razrabotki">  Analisis kondisi proses pembangunan saat ini </h3><br><p>  Langkah pertama: menganalisis proses pengembangan kontraktor yang ada.  Ini membantu merencanakan perubahan sehingga, jika mungkin, tidak mengganggu pekerjaan. </p><br><p>  Sayangnya, kenalan dengan proses pengembangan menunjukkan bahwa dalam pemahaman industri TI saat ini, proses itu tidak ada. </p><br><ol><li>  Kode database dan logika bisnis untuk itu tidak dipertahankan dalam repositori yang terbaru.  Alasan utama: kurangnya alat yang mengimplementasikan perakitan dari kode di repositori dan penyebaran hasilnya.  Jadi, kode dalam repositori hanyalah dokumentasi. </li><li>  Versi "nyata" dari kode basis data ada dalam "basis data pengembangan" yang sama, tempat puluhan pengembang bekerja. </li><li>  Kode aplikasi klien (C #, ASP.NET) dipertahankan dalam repositori, tetapi kualitas dan ketepatan waktu dari komitmen tidak dijamin. </li><li>  Perakitan komponen (bukan seluruh aplikasi) dilakukan di stasiun pengembang.  Tidak sepenuhnya jelas bagaimana kode diperbarui sebelum perakitan.  Komponen yang dirakit diletakkan di folder bersama bersama.  Dari sana, "paket delta" dibentuk untuk pelanggan. </li><li>  Kurangnya praktik mempertahankan cabang pembangunan.  Dengan tanda-tanda tidak langsung, kami menduga ini untuk waktu yang lama - tetapi setelah menyelam ke dalam proses, semuanya menjadi jelas. </li></ol><br><h3 id="perehod-na-novyy-repozitoriy-i-sistemu-kontrolya-versiy">  Beralih ke repositori dan sistem kontrol versi yang baru </h3><br><p>  Ketergantungan pada platform MS dan standar perusahaan menentukan pilihan lingkungan pengembangan - Team Foundation Server. <br>  Namun, saat kami memulai proyek secara langsung (April 2017), versi Visual Studio Team Services baru saja dirilis.  Produk ini tampak sangat menarik, ia ditunjuk sebagai arahan strategis untuk MS, ia menawarkan repositori git, perakitan dan penyebaran untuk on-prem dan cloud. </p><br><p>  Corporate on-prem TFS tertinggal dari versi dan fungsionalitas VSTS, migrasi ke versi baru hanya dalam proses diskusi.  Kami tidak mau menunggu.  Kami memutuskan untuk segera beralih ke VSTS, karena ini mengurangi biaya overhead kami untuk mendukung platform dan memberi kami kontrol penuh atas bagaimana dan apa yang kami lakukan. </p><br><p>  Pada saat awal perubahan, tim pengembangan memiliki pengalaman dengan TFSVC, kode aplikasi disimpan dalam repositori.  Di sisi lain, GIT telah lama menjadi standar bagi komunitas TI - pelanggan dan konsultan pihak ketiga merekomendasikan untuk beralih ke sistem ini. <br>  Kami ingin tim pengembangan terlibat dalam memutuskan sistem kontrol versi baru, dan membuat pilihan yang tepat. </p><br><p>  Kami menggunakan dua proyek dalam VSTS dengan repositori yang berbeda - TFSVC dan GIT.  Seperangkat skenario didefinisikan, yang diusulkan untuk menguji dan mengevaluasi kegunaan di masing-masing sistem. </p><br><p>  Di antara skenario yang dievaluasi adalah: </p><br><ul><li>  Buat dan gabungkan cabang </li><li>  Organisasi kerja bersama (pada satu atau cabang berbeda) </li><li>  Ubah operasi rantai (komit, batalkan) </li><li>  Integrasi pihak ketiga </li><li>  Kemampuan untuk terus bekerja ketika server tidak tersedia. </li></ul><br><p>  Akibatnya, seperti yang diharapkan, GIT dipilih, dan sejauh ini tidak ada yang menyesal. </p><br><p>  Sebagai proses, kami mulai menggunakan GitFlow.  Proses ini memberikan kontrol yang cukup atas perubahan dan memungkinkan pengiriman rilis, seperti yang biasa kita lakukan. </p><br><ol><li>  Kami membela cabang pengembangan dengan kebijakan yang menuntut agar semua perubahan melalui permintaan tarik. </li><li>  Kami mencoba untuk mematuhi praktik "satu tiket - permintaan satu tarik".  Perubahan dari tiket yang berbeda tidak pernah digabungkan dalam satu perubahan.  Kami mencoba melakukan yang terbaik untuk menguji pada cabang fitur untuk menghindari situasi dengan koreksi di tarik tarik berikutnya. </li><li>  Saat menggabungkan ke dalam pengembangan, semua perubahan digabung menjadi satu komit (squash). </li><li>  Cabang rilis dibuat dari pengembangan. </li><li>  Jika perlu, di cabang rilis, Anda dapat menambahkan perubahan terbaru secara selektif (cherry-pick) atau semua (rebase).  Kami tidak melakukan koreksi langsung di cabang rilis. </li><li>  Setelah menyebarkan rilis terbaru pada produk, ia akan dikuasai melalui push force (hanya beberapa orang yang memiliki hak ini) </li></ol><br><h3 id="avtomatizaciya-sborki-produkta">  Otomatisasi perakitan produk </h3><br><p>  Aplikasi itu sejumlah besar majelis, ratusan solusi.  Ternyata selama proses audit, semua ini dikumpulkan secara terpisah dan "secara manual". <br>  Pada tahap pertama, kami memutuskan untuk tidak mengulang semuanya dari awal (agar tidak menghentikan pengiriman yang ada), tetapi untuk "membungkus" perakitan dalam satu set skrip msbuild - satu skrip per komponen. <br>  Dengan demikian, kami dengan cepat mendapatkan skrip yang melakukan semua artefak perantara yang diperlukan, dan pada akhirnya - produk jadi. </p><br><p>  Cerita terpisah adalah desain basis data.  Sayangnya, sistem mengandung beberapa komponen CLR yang tidak terstruktur dengan baik.  Dependensi tidak memungkinkan basis penyebaran sederhana dengan konten.  Saat ini, ini sedang diselesaikan oleh skrip pra-penempatan. <br>  Selain itu, karena lanskap sistem yang tidak merata (SQL Server versi 2008 dan 2014 diinstal pada titik yang berbeda), maka perlu untuk mengatur perakitan proyek dasar untuk .Net versi 2.0 dan 4.0. </p><br><p>  Setelah semua skrip siap dan diuji, mereka digunakan dalam skrip build VSTS. </p><br><p>  Segera sebelum dimulainya perakitan, versi semua produk diperbarui ke nomor standar umum, termasuk nomor build-through dari build.  Nomor yang sama disimpan dalam skrip pasca penempatan.  Dengan demikian, semua komponen - database dan semua aplikasi klien - keluar secara konsisten dan bernomor sama. </p><br><h3 id="razvertyvaniya-na-testovyy-stend">  Penempatan ke bangku tes </h3><br><p>  Setelah versi awal proses pembuatan selesai, kami melanjutkan persiapan skrip penempatan. </p><br><p>  Diharapkan bahwa database adalah yang paling merepotkan. </p><br><p>  Menyebarkan "top" salinan database nyata mengungkapkan banyak konflik antara majelis dan keadaan sistem nyata: </p><br><ul><li>  Versi tidak konsisten dalam GIT dan dalam sistem nyata </li><li>  Skema basis data yang dimiliki oleh pengguna yang rencananya akan dihapus. </li></ul><br><h3 id="stabilizaciya-processa-razrabotki">  Stabilisasi proses pengembangan </h3><br><p>  Tentu saja, aneh untuk membicarakan hal ini, dan terlebih lagi menulis di sini, tetapi perubahan yang paling serius bagi pengembang adalah pengenalan prinsip "jika ini tidak ada dalam git, ini tidak ada."  Sebelumnya, kode itu berkomitmen "untuk melaporkan kepada pelanggan."  Sekarang - tanpa ini, tidak mungkin untuk memberikan apa pun. </p><br><p>  Yang paling sulit adalah dengan kode database.  Setelah beralih ke menggunakan database dari repositori, melalui perakitan dan penyebaran menggunakan sqlpackage, pendekatan "delta" digantikan oleh pendekatan "state yang diinginkan".  Paket adalah sesuatu dari masa lalu, semuanya harus dikerahkan secara otomatis. </p><br><p>  Tapi!  Sampai transisi penuh ke proses penyebaran baru, perubahan masih perlu disampaikan.  Dan itu perlu untuk melakukan ini dengan cara lama - "pembaruan delta". </p><br><p>  Kami menghadapi tugas untuk memastikan konsistensi yang lengkap dan konstan dari kondisi sistem saat mengirimkan paket delta, dan isi repositori. </p><br><p>  Untuk melakukan ini, kami mengatur proses berikut: </p><br><ol><li>  Secara teratur, kode dari repositori dikumpulkan dan digunakan ke database "model" kosong. </li><li>  Atas dasar "model", autotest khusus sedang disiapkan.  Untuk setiap objek database "model", checksum dihitung.  Autotest berisi semua checksum ini dan pada saat startup ia menghitung checksum dari objek yang sesuai dari database "yang diperiksa".  Setiap perbedaan dalam komposisi benda atau checksumnya menyebabkan penurunan dalam tes. </li><li>  Tes "jatuh" secara otomatis melarang transfer paket dari lingkungan pengujian lebih jauh ke lanskap.  Integrasi semacam itu telah diterapkan dalam sistem transportasi sebelumnya. </li></ol><br><p>  Dengan demikian, menggunakan kontrol otomatis, dimungkinkan untuk relatif cepat membawa kode basis data produk dalam git terbaru dan memeliharanya tanpa upaya tambahan dari pihak tim proyek.  Pada saat yang sama, pengembang mulai terbiasa dengan kebutuhan untuk secara tepat dan tepat waktu mengkomit kode ke repositori. </p><br><h3 id="razvertyvanie-produkta-na-okruzheniya-integracionnyh-testov">  Penempatan Produk pada Lingkungan Uji Integrasi </h3><br><p>  Setelah menyelesaikan tahap sebelumnya, kami melanjutkan langsung ke penerapan aplikasi pada lingkungan pengujian.  Kami sepenuhnya berhenti menerapkan paket delta untuk menguji sistem dan beralih ke penerapan otomatis menggunakan VSTS. </p><br><p>  Sejak saat itu, seluruh tim mulai menerima buah pertama dari upaya yang dikeluarkan sebelumnya: penyebaran dilakukan tanpa upaya tambahan.  Kode khusus dikumpulkan, disebarkan, dan diuji secara otomatis. </p><br><p>  Sayangnya, seperti yang kita pahami nanti, "penyelarasan repositori" mengarah pada fakta bahwa kami memiliki versi versi "berkembang" yang didukung secara stabil, tetapi versi "produksi" masih belum tersedia.  Dan oleh karena itu, tidak ada yang melampaui lingkungan pengujian dengan QAS dan PRD. </p><br><p>  Kode aplikasi di sisi database dapat dibandingkan dengan yang produktif dan memahami perbedaannya.  Tidak ada yang bisa dibandingkan dengan aplikasi klien - hanya ada versi produktif terbaru dalam bentuk set file yang dapat dieksekusi, dan dari mana mereka dikompilasi, tidak mungkin untuk mengatakan dengan pasti. </p><br><h3 id="testirovanie-produkta-kak-rezultata-avtomaticheskoy-sborki">  Menguji produk sebagai hasil perakitan otomatis </h3><br><p>  Setelah mengubah pendekatan perakitan, produk harus menjalani pengujian regresi yang luas.  Itu perlu untuk memastikan bahwa aplikasi itu berfungsi dan tidak ada yang hilang. <br>  Saat pengujian, ternyata lebih mudah dengan fungsi yang terletak di sisi basis data.  Untungnya, kami telah mengembangkan serangkaian autotes yang signifikan yang mencakup area kritis. </p><br><p>  Tetapi tidak ada tes untuk C # - karena itu, semuanya diperiksa dengan tangan.  Ini adalah jumlah pekerjaan yang signifikan, dan verifikasi membutuhkan waktu. </p><br><h3 id="pryzhok-very---pilotnoe-razvertyvanie-na-produktiv">  Leap of Faith - Penerapan Pilot Produktif </h3><br><p>  Meskipun pengujian, penerapan pada produk untuk pertama kalinya menakutkan. </p><br><p>  Kami beruntung - kami baru saja merencanakan penyebaran sistem selanjutnya di situs baru.  Dan kami memutuskan untuk menggunakan kesempatan ini untuk penyebaran pilot. <br>  Pengguna tidak melihat, kemungkinan kesalahan perakitan baru mudah diperbaiki, pekerjaan produktif nyata belum dimulai. </p><br><p>  Kami menyebarkan sistem, dan selama beberapa minggu berada dalam mode penggunaan pra-produktif (beban rendah, pola penggunaan tertentu yang dapat dilewati dalam produk).  Selama waktu ini, beberapa cacat yang terlewatkan selama pengujian terungkap.  Mereka dikoreksi saat ditemukan, dan versi baru segera diluncurkan untuk verifikasi. </p><br><p>  Setelah peluncuran resmi dan satu minggu dukungan pasca peluncuran, kami mengumumkan bahwa ini adalah salinan pertama yang dikumpulkan dan dikirimkan "dengan cara yang baru." </p><br><p>  Versi majelis ini menjadi versi stabil pertama dari cabang master, digantung dengan tag fisrt_deployment (kami tidak memesan ikon dengan hash dari commit). </p><br><h3 id="masshtabirovanie-razvertyvaniya-na-ves-produktivnyy-landshaft">  Penempatan skala di seluruh lanskap produktif </h3><br><p>  Seperti yang dikatakan James Bond: "Kedua kalinya jauh lebih sederhana."  Setelah keberhasilan penyebaran pilot, kami dengan cepat menghubungkan contoh sistem yang tersisa dari jenis yang sama. </p><br><p>  Tetapi sistem memiliki beberapa jenis penggunaan - satu fungsi dapat digunakan untuk satu jenis, dan tidak digunakan dalam kasus lain.  Dengan demikian, fungsionalitas yang diuji pada implementasi tipe pertama tidak selalu menjamin kesuksesan untuk kasus lain. </p><br><p>  Untuk menguji fungsionalitas jenis penggunaan yang tersisa, kami mulai menggunakan proyek aktif yang sedang dikembangkan.  Idenya serupa dan penyebaran pertama - kami mulai menggunakan rakitan otomatis, "menyelipkan" mereka kepada pengguna bersama dengan fungsionalitas desain.  Dengan demikian, pengguna, yang bekerja dengan versi "proyek" produk, pada saat yang sama memeriksa fungsi lama. </p><br><p>  Scaling sendiri mengungkapkan masalah teknis yang tidak terduga: </p><br><p>  <em>Lansekap sistem tidak homogen</em> <br>  Selain menerapkan aplikasi secara langsung, pertama-tama kami harus berhati-hati bahwa semuanya sama di mana saja -. Versi bersih, Powershell, dan modul.  Itu semua membutuhkan waktu yang cukup lama. </p><br><p>  <em>Koneksi jaringan</em> <br>  Di beberapa situs, koneksi jaringan tidak memungkinkan memompa semua komponen perakitan.  Ada batas waktu, kerusakan selama transfer.  Kami memeriksa dan mencoba banyak hal - tidak terlalu berhasil. </p><br><p>  Saya harus memikirkan solusi berikut: skrip build diselesaikan sehingga semua hasilnya dikemas menjadi satu arsip besar, yang kemudian dipotong-potong kecil (masing-masing 2 mb).  Kami menyelesaikan skenario penyebaran untuk menghilangkan konkurensi saat mengunduh artefak, menerima semua fragmen 2 megabyte dan memulihkannya dari apa yang sudah dapat diperluas. </p><br><p>  <em>Konflik dengan antivirus</em> <br>  Masalah aneh lain yang kami temui adalah konflik antara perangkat lunak antivirus dan salah satu langkah penyebaran: ketika semua jenis file "mencurigakan", seperti .js, .dll, diekstrak dari arsip artefak, antivirus mulai memperhatikan mereka dengan seksama.  Dan yang paling aneh adalah bahwa antivirus mulai tergesa-gesa ke file sebelum akhir pembongkaran dan proses pembongkaran turun dengan pesan "file sedang sibuk oleh proses lain".  Meskipun kami berjuang dengan ini, mengecualikan folder lokal dengan artefak dari pemindaian, itu tidak terlalu baik, tetapi kami tidak menemukan yang lain. </p><br><h3 id="uluchshenie-processov">  Perbaikan proses </h3><br><p>      ,    "   " â€”   . </p><br><ul><li>        (service-now.com)  VSTS      Work Items.     develop â€”       . </li><li>  CI   feature .      â€”        </li><li>            "self-service"      </li><li>         â€”     .        ,            . </li><li>      :    , CI/CD        ,      </li><li>         (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ) </li><li>   -    (   )     .        â€”    ,      . </li><li>     VSTS     ,        ,     . </li></ul><br><h1 id="itogi">  Ringkasan </h1><br><h3 id="tekuschaya-situaciya">   </h3><br><ul><li>        MS VisualStudio Team Services (   â€” Azure Devops)  .    â€” GIT </li><li>          (/) </li><li>    git / GitFlow    . </li><li>   code review    . </li><li>     CI.       ,    feature ,     . </li><li>          . ,           . </li><li>          (  )    â€”     . -      . </li><li>  -      1 .      -  . </li><li>   ""     . </li></ul><br><h3 id="vremya-po-etapam">    </h3><br><table><thead><tr><th> â„– </th><th>   </th><th>  </th></tr></thead><tbody><tr><td>  1 </td><td>    â€”     ,        </td><td> 6  </td></tr><tr><td>  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dari penyebaran pertama ke lingkungan pengujian - hingga rilis pilot pertama menjadi produktif </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3 bulan </font></font></td></tr><tr><td>  3 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dari Penempatan Pilot ke Produktivitas hingga Rilis Pertama untuk Semua Mesin Virtual </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5 bulan </font></font></td></tr></tbody></table><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Total durasi - 14 bulan </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Itu berlangsung, terutama pada tahap akhir, dalam banyak hal ditentukan oleh koordinasi, dan kalender yang disepakati untuk pemeliharaan sistem. </font></font></p><br><h3 id="trudozatraty"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biaya tenaga kerja </font></font></h3><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Total biaya karyawan yang terlibat dari pelanggan dan organisasi kontraktor untuk semua pekerjaan yang terkait dengan perubahan adalah sekitar 250 orang * hari. </font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427111/">https://habr.com/ru/post/id427111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427097/index.html">Aplikasi seluler membantu mendeteksi depresi dan masalah psikologis lainnya pada tahap paling awal.</a></li>
<li><a href="../id427101/index.html">Google berencana untuk menagih produsen perangkat seluler hingga $ 40 untuk setiap perangkat yang terjual</a></li>
<li><a href="../id427105/index.html">Belajar belajar: melanjutkan pendidikan adalah kunci daya saing di era ekonomi digital</a></li>
<li><a href="../id427107/index.html">Parsim X12 "di lutut"</a></li>
<li><a href="../id427109/index.html">Pembajakan di Luar Angkasa - Delta-V yang Lezat dan Hidrogen Stealth Steamboats - Bagian 1</a></li>
<li><a href="../id427113/index.html">Array Gerbang yang Dapat Diprogram: Bagaimana Mereka Membantu Jaringan 5G</a></li>
<li><a href="../id427117/index.html">Ruang pertemuan berdasarkan Asterisk</a></li>
<li><a href="../id427123/index.html">Turing game</a></li>
<li><a href="../id427129/index.html">Ancaman Intelijen - pendekatan modern terhadap keamanan informasi</a></li>
<li><a href="../id427131/index.html">Berkenalan dengan Audiomania: 15 materi tematik tentang produksi, desain, kantor, dan bisnis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>