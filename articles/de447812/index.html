<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🔬 🖼️ 🌫️ Wie wir die kontinuierliche Bereitstellung von Updates für die Kundenplattform implementiert haben 👦🏻 💣 📪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei True Engineering haben wir den Prozess der kontinuierlichen Bereitstellung von Updates für die Server des Kunden eingerichtet und möchten diese Er...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir die kontinuierliche Bereitstellung von Updates für die Kundenplattform implementiert haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/447812/">  Bei True Engineering haben wir den Prozess der kontinuierlichen Bereitstellung von Updates für die Server des Kunden eingerichtet und möchten diese Erfahrung teilen. <br><br>  Zunächst haben wir ein Online-System für den Kunden entwickelt und in unserem eigenen Kubernetes-Cluster bereitgestellt.  Jetzt ist unsere hoch geladene Lösung auf die Plattform des Kunden umgestiegen, für die wir den vollautomatischen Continuous Deployment-Prozess eingerichtet haben.  Dank dessen haben wir die Markteinführungszeit verkürzt - die Bereitstellung von Änderungen an der Produktumgebung. <br><br>  In diesem Artikel werden alle Phasen des CD-Prozesses (Continuous Deployment) oder die Bereitstellung von Updates für die Kundenplattform beschrieben: <br><br><ol><li>  Wie beginnt dieser Prozess? </li><li>  Synchronisation mit dem Git-Repository des Kunden, </li><li>  Backend- und Frontend-Assembly </li><li>  automatische Bereitstellung der Anwendung in einer Testumgebung, </li><li>  automatische Bereitstellung auf Prod. </li></ol><br>  Dabei werden wir die Details der Einstellungen teilen. <br><br><img src="https://habrastorage.org/webt/ii/pa/gh/iipaghverrphnx-_scgemoqhgy0.jpeg"><br><a name="habracut"></a><br><h3>  1. Starten Sie die CD </h3><br>  Die kontinuierliche Bereitstellung beginnt mit der Tatsache, dass der Entwickler die Änderungen im Release-Zweig unseres Git-Repositorys veröffentlicht. <br><br>  Unsere Anwendung basiert auf einer Microservice-Architektur und alle ihre Komponenten werden in einem Repository gespeichert.  Dank dessen werden alle Microservices zusammengebaut und installiert, auch wenn sich einer von ihnen geändert hat. <br><br>  Wir haben die Arbeit in einem Repository aus mehreren Gründen organisiert: <br><br><ul><li>  Einfache Entwicklung - Die Anwendung wird aktiv entwickelt, sodass Sie sofort mit dem gesamten Code arbeiten können. </li><li>  Eine einzelne CI / CD-Pipeline, die sicherstellt, dass die Anwendung als einzelnes System alle Tests besteht und an die Produktumgebung des Kunden geliefert wird. </li><li>  Wir schließen Verwirrung in den Versionen aus - wir müssen keine Karte der Microservice-Versionen speichern und unsere Konfiguration für jeden Microservice in Helm-Skripten beschreiben. </li></ul><br><h3>  2. Synchronisation mit dem Git-Repository des Kundenquellcodes </h3><br>  Die vorgenommenen Änderungen werden automatisch mit dem Git-Repository des Kunden synchronisiert.  Dort wird die Assembly der Anwendung konfiguriert, die nach dem Aktualisieren des Zweigs und der Bereitstellung zu prod beginnt.  Beide Prozesse finden in ihrer Umgebung über das Git-Repository statt. <br><br>  Wir können nicht direkt mit dem Repository des Kunden arbeiten, da wir unsere eigenen Entwicklungs- und Testumgebungen benötigen.  Wir verwenden unser Git-Repository für diese Zwecke - es wird mit dem Git-Repository synchronisiert.  Sobald der Entwickler die Änderungen in der entsprechenden Zweigstelle unseres Repositorys veröffentlicht, sendet GitLab diese Änderungen sofort an den Kunden. <br><br><img src="https://habrastorage.org/webt/x4/de/zu/x4dezunuwwydsx3xq2uaxj1wbzo.png"><br><br>  Danach müssen Sie eine Baugruppe erstellen.  Es besteht aus mehreren Schritten: Zusammenbau des Backends und des Frontends, Testen und Lieferung an das Produkt. <br><br><h3>  3. Erstellen Sie das Backend und das Frontend </h3><br>  Backend- und Frontend-Assembly sind zwei parallele Aufgaben, die im GitLab Runner-System ausgeführt werden.  Ihre Konfiguration der ursprünglichen Baugruppe befindet sich im selben Repository. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial zum Schreiben eines YAML-Skripts zum Erstellen in GitLab</a> . <br><br>  GitLab Runner nimmt den Code aus dem gewünschten Repository auf, sammelt den Befehl zum Erstellen von Java-Anwendungen und sendet ihn an die Docker-Registrierung.  Hier sammeln wir das Backend und das Frontend, erhalten Docker-Images, die wir auf Kundenseite in das Repository stellen.  Verwenden Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gradle-Plugin,</a> um Doker-Bilder zu verwalten. <br><br>  Wir synchronisieren die Versionen unserer Bilder mit der Version der Version, die in Docker veröffentlicht wird.  Für einen reibungslosen Betrieb haben wir verschiedene Einstellungen vorgenommen: <br><br>  1. Zwischen Testumgebung und Lebensmittelbehältern werden keine wieder zusammengesetzt.  Wir haben die Parametrisierung durchgeführt, damit derselbe Container ohne Neuerstellung mit allen Einstellungen, Umgebungsvariablen und Diensten sowohl in der Testumgebung als auch im Produkt funktioniert. <br><br>  2. Um die Anwendung über Helm zu aktualisieren, müssen Sie ihre Version angeben.  Wir haben die Backend-Assembly, das Frontend und das Anwendungsupdate - dies sind drei verschiedene Aufgaben, daher ist es wichtig, überall dieselbe Version der Anwendung zu verwenden.  Für diese Aufgabe verwenden wir Daten aus dem Git-Verlauf, da wir eine K8S-Cluster-Konfiguration haben und sich Anwendungen im selben Git-Repository befinden. <br><br>  Wir erhalten die Anwendungsversion aus den Ergebnissen des Befehls <br>  <code>git describe --tags --abbrev=7</code> . <br><br><h3>  4. Automatische Bereitstellung aller Änderungen in einer Testumgebung (UAT) </h3><br>  Der nächste Schritt in diesem Build-Skript besteht darin, den K8S-Cluster automatisch zu aktualisieren.  Dies geschieht, sofern die gesamte Anwendung zusammengestellt und alle Artefakte in der Docker-Registrierung veröffentlicht werden.  Danach beginnt die Aktualisierung der Testumgebung. <br><br>  Das Cluster-Update wird mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm Update</a> gestartet.  Wenn infolgedessen ein Fehler aufgetreten ist, setzt Helm alle Änderungen automatisch und unabhängig zurück.  Seine Arbeit muss nicht kontrolliert werden. <br><br>  Zusammen mit der Baugruppe liefern wir die Konfiguration des K8S-Clusters.  Daher besteht der nächste Schritt darin, es zu aktualisieren: configMaps, Bereitstellungen, Dienste, Geheimnisse und alle anderen von uns geänderten K8S-Konfigurationen. <br><br>  Danach startet Helm das RollOut-Update der Anwendung selbst in einer Testumgebung.  Bevor die Anwendung auf dem Produkt bereitgestellt wird.  Dies geschieht, damit Benutzer die Geschäftsfunktionen, die wir in der Testumgebung veröffentlicht haben, manuell überprüfen können. <br><br><h3>  5. Stellen Sie alle Änderungen automatisch an Prod bereit </h3><br>  Um das Update in der Produktumgebung bereitzustellen, müssen Sie nur noch auf eine Schaltfläche in GitLab klicken - und die Container werden sofort an die Produktumgebung geliefert. <br><br>  Ein und dieselbe Anwendung kann ohne Neuerstellung in verschiedenen Umgebungen funktionieren - Test und Produktion.  Wir verwenden dieselben Artefakte, ohne etwas in der Anwendung zu ändern, und stellen die Parameter von außen ein. <br><br>  Die flexible Parametrisierung der Anwendungseinstellungen hängt von der Umgebung ab, in der diese Anwendung ausgeführt wird.  Wir haben alle Umgebungseinstellungen vorgenommen: Alles wird über die K8S-Konfiguration und die Helm-Parameter parametriert.  Wenn Helm eine Baugruppe in einer Testumgebung bereitstellt, gelten Testparameter und Produktparameter für die Produktumgebung. <br><br>  Am schwierigsten war es, alle verwendeten Dienste und Variablen, die von der Umgebung abhängen, zu parametrisieren und in Umgebungsvariablen und eine Beschreibungskonfiguration der Umgebungsparameter für Helm zu übersetzen. <br><br>  Die Anwendungsparameter verwenden Umgebungsvariablen.  Ihre Werte werden in Containern mithilfe der K8S-Konfigurationskarte festgelegt, die mithilfe von Go-Vorlagen erstellt wird.  Das Festlegen einer Umgebungsvariablen auf einen Domänennamen kann beispielsweise folgendermaßen erfolgen: <br><br><pre> <code class="plaintext hljs">APP_EXTERNAL_DOMAIN: {{ (pluck .Values.global.env .Values.app.properties.app_external_domain | first) }}</code> </pre> <br>  <b>.Values.global.env</b> - Der Name der Umgebung (Prod, Stage, UAT) wird in dieser Variablen gespeichert. <br>  <b>.Values.app.properties.app_external_domain</b> - In dieser Variablen legen wir in der Datei .Values.yaml die gewünschte Domäne fest <br><br>  Beim Aktualisieren der Anwendung erstellt Helm die Datei configmap.yaml aus den Vorlagen und füllt den Wert APP_EXTERNAL_DOMAIN mit dem erforderlichen Wert aus, abhängig von der Umgebung, in der die Anwendungsaktualisierung beginnt.  Diese Variable ist bereits im Container festgelegt.  Der Zugriff darauf erfolgt über die Anwendung. In jeder Umgebung der Anwendung gibt es einen anderen Wert für diese Variable. <br><br>  Vor relativ kurzer Zeit hat Spring Cloud die K8S-Unterstützung eingeführt, einschließlich der Arbeit mit configMaps: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring Cloud Kubernetes</a> .  Während sich das Projekt aktiv entwickelt und dramatisch verändert, können wir es nicht in der Produktion verwenden.  Wir überwachen jedoch aktiv den Zustand und verwenden ihn in DEV-Konfigurationen.  Sobald es sich stabilisiert hat, werden wir von der Verwendung von Umgebungsvariablen zu dieser wechseln. <br><br><h3>  Insgesamt </h3><br>  Continuous Deployment ist also betriebsbereit.  Alle Aktualisierungen erfolgen auf Knopfdruck.  Die Übermittlung von Änderungen an die Lebensmittelumgebung erfolgt automatisch.  Und vor allem stoppen Updates das System nicht. <br><br><img src="https://habrastorage.org/webt/3j/aq/bs/3jaqbs3llw95qie5ienc8efaymw.jpeg"><br><br><h3>  Zukunftspläne: automatische Basismigration </h3><br>  Wir haben darüber nachgedacht, die Datenbank zu aktualisieren und diese Änderungen rückgängig zu machen.  Immerhin funktionieren zwei verschiedene Versionen der Anwendung gleichzeitig: die alte funktioniert und die neue steigt.  Und wir werden die alte nur ausschalten, wenn wir davon überzeugt sind, dass die neue Version funktioniert.  Die Datenbankmigration sollte die Arbeit mit beiden Versionen der Anwendung ermöglichen. <br><br>  Daher können wir nicht einfach den Namen der Spalte oder anderer Daten ändern.  Wir können jedoch eine neue Spalte erstellen, die Daten aus der alten Spalte in diese Spalte kopieren und Trigger schreiben, die beim Aktualisieren der Daten gleichzeitig kopiert und in einer anderen Spalte aktualisiert werden.  Und nach der erfolgreichen Bereitstellung der neuen Version der Anwendung können wir nach der Unterstützung nach dem Start die alte Spalte und den nicht mehr benötigten Auslöser löschen. <br><br>  Wenn die neue Version der Anwendung nicht ordnungsgemäß funktioniert, können wir auf die vorherige Version zurücksetzen, einschließlich der vorherigen Version der Datenbank.  Mit einem Wort, unsere Änderungen ermöglichen die gleichzeitige Arbeit mit mehreren Versionen der Anwendung. <br><br>  Wir planen, die Datenbankmigration durch den K8S-Job zu automatisieren, indem wir ihn in den CD-Prozess einbetten.  Und diese Erfahrung werden wir sicherlich auf Habré teilen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447812/">https://habr.com/ru/post/de447812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447802/index.html">Isabella 2</a></li>
<li><a href="../de447804/index.html">Die Zwergenfestung verzichtet auf Textgrafiken, aber nicht auf deren Essenz</a></li>
<li><a href="../de447806/index.html">Beschleunigung der Leistung neuronaler Netze durch Hashing</a></li>
<li><a href="../de447808/index.html">Lernen, Waves Smart-Verträge auf RIDE und RIDE4DAPPS zu schreiben. Teil 2 (DAO - Dezentrale Autonome Organisation)</a></li>
<li><a href="../de447810/index.html">Analytics für Azure DevOps Services ist jetzt öffentlich verfügbar</a></li>
<li><a href="../de447814/index.html">Wo und wie kann ein Entwicklungszentrum eröffnet werden?</a></li>
<li><a href="../de447816/index.html">Ein bisschen C ++ - Vorlagenmagie und CRTP, um die Richtigkeit der Aktionen des Programmierers in der Kompilierungszeit zu kontrollieren</a></li>
<li><a href="../de447818/index.html">AgileDays 2019</a></li>
<li><a href="../de447820/index.html">Importieren Sie 3D-Modelle in Unity und Fallstricke</a></li>
<li><a href="../de447822/index.html">Fast gefeuert. Wie ich die Yandex Analytics-Abteilung aufgebaut habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>