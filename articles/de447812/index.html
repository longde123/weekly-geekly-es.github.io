<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüî¨ üñºÔ∏è üå´Ô∏è Wie wir die kontinuierliche Bereitstellung von Updates f√ºr die Kundenplattform implementiert haben üë¶üèª üí£ üì™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei True Engineering haben wir den Prozess der kontinuierlichen Bereitstellung von Updates f√ºr die Server des Kunden eingerichtet und m√∂chten diese Er...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir die kontinuierliche Bereitstellung von Updates f√ºr die Kundenplattform implementiert haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/447812/">  Bei True Engineering haben wir den Prozess der kontinuierlichen Bereitstellung von Updates f√ºr die Server des Kunden eingerichtet und m√∂chten diese Erfahrung teilen. <br><br>  Zun√§chst haben wir ein Online-System f√ºr den Kunden entwickelt und in unserem eigenen Kubernetes-Cluster bereitgestellt.  Jetzt ist unsere hoch geladene L√∂sung auf die Plattform des Kunden umgestiegen, f√ºr die wir den vollautomatischen Continuous Deployment-Prozess eingerichtet haben.  Dank dessen haben wir die Markteinf√ºhrungszeit verk√ºrzt - die Bereitstellung von √Ñnderungen an der Produktumgebung. <br><br>  In diesem Artikel werden alle Phasen des CD-Prozesses (Continuous Deployment) oder die Bereitstellung von Updates f√ºr die Kundenplattform beschrieben: <br><br><ol><li>  Wie beginnt dieser Prozess? </li><li>  Synchronisation mit dem Git-Repository des Kunden, </li><li>  Backend- und Frontend-Assembly </li><li>  automatische Bereitstellung der Anwendung in einer Testumgebung, </li><li>  automatische Bereitstellung auf Prod. </li></ol><br>  Dabei werden wir die Details der Einstellungen teilen. <br><br><img src="https://habrastorage.org/webt/ii/pa/gh/iipaghverrphnx-_scgemoqhgy0.jpeg"><br><a name="habracut"></a><br><h3>  1. Starten Sie die CD </h3><br>  Die kontinuierliche Bereitstellung beginnt mit der Tatsache, dass der Entwickler die √Ñnderungen im Release-Zweig unseres Git-Repositorys ver√∂ffentlicht. <br><br>  Unsere Anwendung basiert auf einer Microservice-Architektur und alle ihre Komponenten werden in einem Repository gespeichert.  Dank dessen werden alle Microservices zusammengebaut und installiert, auch wenn sich einer von ihnen ge√§ndert hat. <br><br>  Wir haben die Arbeit in einem Repository aus mehreren Gr√ºnden organisiert: <br><br><ul><li>  Einfache Entwicklung - Die Anwendung wird aktiv entwickelt, sodass Sie sofort mit dem gesamten Code arbeiten k√∂nnen. </li><li>  Eine einzelne CI / CD-Pipeline, die sicherstellt, dass die Anwendung als einzelnes System alle Tests besteht und an die Produktumgebung des Kunden geliefert wird. </li><li>  Wir schlie√üen Verwirrung in den Versionen aus - wir m√ºssen keine Karte der Microservice-Versionen speichern und unsere Konfiguration f√ºr jeden Microservice in Helm-Skripten beschreiben. </li></ul><br><h3>  2. Synchronisation mit dem Git-Repository des Kundenquellcodes </h3><br>  Die vorgenommenen √Ñnderungen werden automatisch mit dem Git-Repository des Kunden synchronisiert.  Dort wird die Assembly der Anwendung konfiguriert, die nach dem Aktualisieren des Zweigs und der Bereitstellung zu prod beginnt.  Beide Prozesse finden in ihrer Umgebung √ºber das Git-Repository statt. <br><br>  Wir k√∂nnen nicht direkt mit dem Repository des Kunden arbeiten, da wir unsere eigenen Entwicklungs- und Testumgebungen ben√∂tigen.  Wir verwenden unser Git-Repository f√ºr diese Zwecke - es wird mit dem Git-Repository synchronisiert.  Sobald der Entwickler die √Ñnderungen in der entsprechenden Zweigstelle unseres Repositorys ver√∂ffentlicht, sendet GitLab diese √Ñnderungen sofort an den Kunden. <br><br><img src="https://habrastorage.org/webt/x4/de/zu/x4dezunuwwydsx3xq2uaxj1wbzo.png"><br><br>  Danach m√ºssen Sie eine Baugruppe erstellen.  Es besteht aus mehreren Schritten: Zusammenbau des Backends und des Frontends, Testen und Lieferung an das Produkt. <br><br><h3>  3. Erstellen Sie das Backend und das Frontend </h3><br>  Backend- und Frontend-Assembly sind zwei parallele Aufgaben, die im GitLab Runner-System ausgef√ºhrt werden.  Ihre Konfiguration der urspr√ºnglichen Baugruppe befindet sich im selben Repository. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial zum Schreiben eines YAML-Skripts zum Erstellen in GitLab</a> . <br><br>  GitLab Runner nimmt den Code aus dem gew√ºnschten Repository auf, sammelt den Befehl zum Erstellen von Java-Anwendungen und sendet ihn an die Docker-Registrierung.  Hier sammeln wir das Backend und das Frontend, erhalten Docker-Images, die wir auf Kundenseite in das Repository stellen.  Verwenden Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gradle-Plugin,</a> um Doker-Bilder zu verwalten. <br><br>  Wir synchronisieren die Versionen unserer Bilder mit der Version der Version, die in Docker ver√∂ffentlicht wird.  F√ºr einen reibungslosen Betrieb haben wir verschiedene Einstellungen vorgenommen: <br><br>  1. Zwischen Testumgebung und Lebensmittelbeh√§ltern werden keine wieder zusammengesetzt.  Wir haben die Parametrisierung durchgef√ºhrt, damit derselbe Container ohne Neuerstellung mit allen Einstellungen, Umgebungsvariablen und Diensten sowohl in der Testumgebung als auch im Produkt funktioniert. <br><br>  2. Um die Anwendung √ºber Helm zu aktualisieren, m√ºssen Sie ihre Version angeben.  Wir haben die Backend-Assembly, das Frontend und das Anwendungsupdate - dies sind drei verschiedene Aufgaben, daher ist es wichtig, √ºberall dieselbe Version der Anwendung zu verwenden.  F√ºr diese Aufgabe verwenden wir Daten aus dem Git-Verlauf, da wir eine K8S-Cluster-Konfiguration haben und sich Anwendungen im selben Git-Repository befinden. <br><br>  Wir erhalten die Anwendungsversion aus den Ergebnissen des Befehls <br>  <code>git describe --tags --abbrev=7</code> . <br><br><h3>  4. Automatische Bereitstellung aller √Ñnderungen in einer Testumgebung (UAT) </h3><br>  Der n√§chste Schritt in diesem Build-Skript besteht darin, den K8S-Cluster automatisch zu aktualisieren.  Dies geschieht, sofern die gesamte Anwendung zusammengestellt und alle Artefakte in der Docker-Registrierung ver√∂ffentlicht werden.  Danach beginnt die Aktualisierung der Testumgebung. <br><br>  Das Cluster-Update wird mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm Update</a> gestartet.  Wenn infolgedessen ein Fehler aufgetreten ist, setzt Helm alle √Ñnderungen automatisch und unabh√§ngig zur√ºck.  Seine Arbeit muss nicht kontrolliert werden. <br><br>  Zusammen mit der Baugruppe liefern wir die Konfiguration des K8S-Clusters.  Daher besteht der n√§chste Schritt darin, es zu aktualisieren: configMaps, Bereitstellungen, Dienste, Geheimnisse und alle anderen von uns ge√§nderten K8S-Konfigurationen. <br><br>  Danach startet Helm das RollOut-Update der Anwendung selbst in einer Testumgebung.  Bevor die Anwendung auf dem Produkt bereitgestellt wird.  Dies geschieht, damit Benutzer die Gesch√§ftsfunktionen, die wir in der Testumgebung ver√∂ffentlicht haben, manuell √ºberpr√ºfen k√∂nnen. <br><br><h3>  5. Stellen Sie alle √Ñnderungen automatisch an Prod bereit </h3><br>  Um das Update in der Produktumgebung bereitzustellen, m√ºssen Sie nur noch auf eine Schaltfl√§che in GitLab klicken - und die Container werden sofort an die Produktumgebung geliefert. <br><br>  Ein und dieselbe Anwendung kann ohne Neuerstellung in verschiedenen Umgebungen funktionieren - Test und Produktion.  Wir verwenden dieselben Artefakte, ohne etwas in der Anwendung zu √§ndern, und stellen die Parameter von au√üen ein. <br><br>  Die flexible Parametrisierung der Anwendungseinstellungen h√§ngt von der Umgebung ab, in der diese Anwendung ausgef√ºhrt wird.  Wir haben alle Umgebungseinstellungen vorgenommen: Alles wird √ºber die K8S-Konfiguration und die Helm-Parameter parametriert.  Wenn Helm eine Baugruppe in einer Testumgebung bereitstellt, gelten Testparameter und Produktparameter f√ºr die Produktumgebung. <br><br>  Am schwierigsten war es, alle verwendeten Dienste und Variablen, die von der Umgebung abh√§ngen, zu parametrisieren und in Umgebungsvariablen und eine Beschreibungskonfiguration der Umgebungsparameter f√ºr Helm zu √ºbersetzen. <br><br>  Die Anwendungsparameter verwenden Umgebungsvariablen.  Ihre Werte werden in Containern mithilfe der K8S-Konfigurationskarte festgelegt, die mithilfe von Go-Vorlagen erstellt wird.  Das Festlegen einer Umgebungsvariablen auf einen Dom√§nennamen kann beispielsweise folgenderma√üen erfolgen: <br><br><pre> <code class="plaintext hljs">APP_EXTERNAL_DOMAIN: {{ (pluck .Values.global.env .Values.app.properties.app_external_domain | first) }}</code> </pre> <br>  <b>.Values.global.env</b> - Der Name der Umgebung (Prod, Stage, UAT) wird in dieser Variablen gespeichert. <br>  <b>.Values.app.properties.app_external_domain</b> - In dieser Variablen legen wir in der Datei .Values.yaml die gew√ºnschte Dom√§ne fest <br><br>  Beim Aktualisieren der Anwendung erstellt Helm die Datei configmap.yaml aus den Vorlagen und f√ºllt den Wert APP_EXTERNAL_DOMAIN mit dem erforderlichen Wert aus, abh√§ngig von der Umgebung, in der die Anwendungsaktualisierung beginnt.  Diese Variable ist bereits im Container festgelegt.  Der Zugriff darauf erfolgt √ºber die Anwendung. In jeder Umgebung der Anwendung gibt es einen anderen Wert f√ºr diese Variable. <br><br>  Vor relativ kurzer Zeit hat Spring Cloud die K8S-Unterst√ºtzung eingef√ºhrt, einschlie√ülich der Arbeit mit configMaps: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring Cloud Kubernetes</a> .  W√§hrend sich das Projekt aktiv entwickelt und dramatisch ver√§ndert, k√∂nnen wir es nicht in der Produktion verwenden.  Wir √ºberwachen jedoch aktiv den Zustand und verwenden ihn in DEV-Konfigurationen.  Sobald es sich stabilisiert hat, werden wir von der Verwendung von Umgebungsvariablen zu dieser wechseln. <br><br><h3>  Insgesamt </h3><br>  Continuous Deployment ist also betriebsbereit.  Alle Aktualisierungen erfolgen auf Knopfdruck.  Die √úbermittlung von √Ñnderungen an die Lebensmittelumgebung erfolgt automatisch.  Und vor allem stoppen Updates das System nicht. <br><br><img src="https://habrastorage.org/webt/3j/aq/bs/3jaqbs3llw95qie5ienc8efaymw.jpeg"><br><br><h3>  Zukunftspl√§ne: automatische Basismigration </h3><br>  Wir haben dar√ºber nachgedacht, die Datenbank zu aktualisieren und diese √Ñnderungen r√ºckg√§ngig zu machen.  Immerhin funktionieren zwei verschiedene Versionen der Anwendung gleichzeitig: die alte funktioniert und die neue steigt.  Und wir werden die alte nur ausschalten, wenn wir davon √ºberzeugt sind, dass die neue Version funktioniert.  Die Datenbankmigration sollte die Arbeit mit beiden Versionen der Anwendung erm√∂glichen. <br><br>  Daher k√∂nnen wir nicht einfach den Namen der Spalte oder anderer Daten √§ndern.  Wir k√∂nnen jedoch eine neue Spalte erstellen, die Daten aus der alten Spalte in diese Spalte kopieren und Trigger schreiben, die beim Aktualisieren der Daten gleichzeitig kopiert und in einer anderen Spalte aktualisiert werden.  Und nach der erfolgreichen Bereitstellung der neuen Version der Anwendung k√∂nnen wir nach der Unterst√ºtzung nach dem Start die alte Spalte und den nicht mehr ben√∂tigten Ausl√∂ser l√∂schen. <br><br>  Wenn die neue Version der Anwendung nicht ordnungsgem√§√ü funktioniert, k√∂nnen wir auf die vorherige Version zur√ºcksetzen, einschlie√ülich der vorherigen Version der Datenbank.  Mit einem Wort, unsere √Ñnderungen erm√∂glichen die gleichzeitige Arbeit mit mehreren Versionen der Anwendung. <br><br>  Wir planen, die Datenbankmigration durch den K8S-Job zu automatisieren, indem wir ihn in den CD-Prozess einbetten.  Und diese Erfahrung werden wir sicherlich auf Habr√© teilen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447812/">https://habr.com/ru/post/de447812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447802/index.html">Isabella 2</a></li>
<li><a href="../de447804/index.html">Die Zwergenfestung verzichtet auf Textgrafiken, aber nicht auf deren Essenz</a></li>
<li><a href="../de447806/index.html">Beschleunigung der Leistung neuronaler Netze durch Hashing</a></li>
<li><a href="../de447808/index.html">Lernen, Waves Smart-Vertr√§ge auf RIDE und RIDE4DAPPS zu schreiben. Teil 2 (DAO - Dezentrale Autonome Organisation)</a></li>
<li><a href="../de447810/index.html">Analytics f√ºr Azure DevOps Services ist jetzt √∂ffentlich verf√ºgbar</a></li>
<li><a href="../de447814/index.html">Wo und wie kann ein Entwicklungszentrum er√∂ffnet werden?</a></li>
<li><a href="../de447816/index.html">Ein bisschen C ++ - Vorlagenmagie und CRTP, um die Richtigkeit der Aktionen des Programmierers in der Kompilierungszeit zu kontrollieren</a></li>
<li><a href="../de447818/index.html">AgileDays 2019</a></li>
<li><a href="../de447820/index.html">Importieren Sie 3D-Modelle in Unity und Fallstricke</a></li>
<li><a href="../de447822/index.html">Fast gefeuert. Wie ich die Yandex Analytics-Abteilung aufgebaut habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>