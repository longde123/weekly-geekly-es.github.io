<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎨 ▶️ 😃 编写Linux内核模块：I2C ◼️ 💅🏻 🔩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈伯，你好！ 

 本文重点介绍I2C（集成电路间）Linux内核模块的开发。 下面描述了实现I2C驱动程序基本结构的过程，您可以在其中轻松添加必要功能的实现。 

 我们描述输入数据：运行在Linux 3.18.19版和外围设备（EEPROM AT24C64和BME280）上的“连接”到FPGA的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>编写Linux内核模块：I2C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413249/"> 哈伯，你好！ <br><br> 本文重点介绍I2C（集成电路间）Linux内核模块的开发。 下面描述了实现I2C驱动程序基本结构的过程，您可以在其中轻松添加必要功能的实现。 <br><br> 我们描述输入数据：运行在Linux 3.18.19版和外围设备（EEPROM AT24C64和BME280）上的“连接”到FPGA的新处理器的I2C模块。 <br><br>  I2C的操作原理很简单，但是如果您需要学习知识，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>阅读。 <br><br><img src="https://habrastorage.org/webt/jq/rh/yg/jqrhyg8bveyubub7hysu0gxrkms.png"><br>  <i>图1. I2C总线信号的时序图</i> <br><a name="habracut"></a><br> 在开始开发驱动程序之前，让我们看看用户空间应用程序如何与内核模块交互，为此： <br><br><ol><li> 我们实施了一个小型用户空间应用程序，目的是读取设备的唯一I2C寄存器ID。 此步骤将使您了解内核模块和用户应用程序之间进行交换的接口。 </li><li>让我们熟悉内核模块传输I2C消息的选项； </li><li> 将内核模块添加到程序集中，并在设备树中描述设备的硬件； </li><li> 我们通过一些解释来实现I2C驱动程序的一般结构（框架）。 </li></ol><br> 不幸的是，不可能附加已开发驱动程序的真实资源。 另外，我想指出，控制器的所有名称，名称和注册卡均已更改。 驱动程序的骨架中甚至没有包括一半已开发功能，但是，驱动程序结构是开发的良好起点。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>可以找到I2C驱动程序的示例。 <br><br><h3>  <b>第一步</b> </h3><br> 首先，让我们熟悉i2cdetect实用程序。  i2cdetect的结果如下： <br><pre><code class="cpp hljs">./i2cdetect -y <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> abcdef <span class="hljs-number"><span class="hljs-number">00</span></span>: — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">10</span></span>: — — — — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">20</span></span>: — — — — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">30</span></span>: — — — — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">40</span></span>: — — — — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">50</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span> — — — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">60</span></span>: — — — — — — — — — — — — — — — — <span class="hljs-number"><span class="hljs-number">70</span></span>: — — — — — — — —</code> </pre> <br> 该实用程序顺序地在I2C上公开设备地址总线，并在收到肯定响应（在这种情况下，肯定回答为ACK）后，在控制台中的总线上显示设备地址号。 <br><br> 我们将编写一个小程序，该程序读取温度传感器的唯一ID，并在控制台中显示其工作结果。 看起来很简单： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;linux/i2c.h&gt; #include &lt;linux/i2c-dev.h&gt; #define I2C_ADAPTER "/dev/i2c-0" int read_buffer(int fd) { struct i2c_rdwr_ioctl_data data; struct i2c_msg messages[2]; unsigned char write_buf[1] = {0xD0}, read_buf[1] = {0x00}; unsigned char write[200]; /* * .addr -   () * .flags -     (0 - w, 1 - r) * .len - - /  * .buf -      */ messages[0].addr = 0x50; messages[0].flags = 0; messages[0].len = 1; messages[0].buf = write_buf; messages[1].addr = 0x50; messages[1].flags = 1; messages[1].len = 1; messages[1].buf = read_buf; data.msgs = messages; data.nmsgs = 2; if (ioctl(fd, I2C_RDWR, &amp;data) &lt; 0) printf("Cant send data!\n"); else printf("ID = 0x%x\n", read_buf[0]); } int main(int argc, char **argv) { int fd; /* * Open I2C file descriptor. */ fd = open(I2C_ADAPTER, O_RDWR); if (fd &lt; 0) { printf("Unable to open i2c file\n"); return 0; } read_buffer(fd); return 0; }</span></span></span></span></code> </pre><br> 显然，内核模块以i2c_rdwr_ioctl_data消息字段的形式接收数据。 该结构包含诸如i2c_msg和nmsgs之类的字段，用于传输： <br><br><ul><li>  .addr-设备地址； </li><li>  .flags-操作类型（读或写）； </li><li>  .len-当前消息的长度； </li><li>  .buf-剪贴板。 </li></ul><br><h3>  <b>第二步</b> </h3><br> 现在，我不深入研究，不熟悉I2C驱动程序的一个版本。 <br> 如已经建立的，内核模块接收结构形式的消息。 例如，在执行写操作（与硬件有关的部分）时，请考虑驱动程序的算法： <br><br><ul><li> 首先填充TX FIFO：首先发送设备的地址，然后发送剩余的数据。 </li><li>  ISR中断状态寄存器被清除并且IER寄存器中的中断被允许（在这种情况下，当TX FIFO中没有数据时发生中断）。 </li><li> 允许数据传输，并且在总线上设置起始位。 </li></ul><br> 所有后续数据交换将在中断处理程序中进行。 <br> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到使用该算法的驱动程序。 同样，控制器可能没有FIFO，而只有一个传输寄存器，但这是FIFO大小等于1的特殊情况。 <br><br><h3>  <b>第三步</b> </h3><br> 将内核模块添加到程序集中，并在设备树中描述设备的硬件： <br><br>  1.在以下目录中创建源文件： <br><br><pre> <code class="cpp hljs">cd drivers/i2c/busses/ vim i2c-skel.c :wq</code> </pre><br> 结果，文件出现： <br><br><pre> <code class="cpp hljs">drivers/i2c/busses/i2c-skel.c</code> </pre><br><br>  2.将驱动程序配置添加到<i>驱动程序/ i2c /总线/ Kconfig中</i> ： <br><br><pre> <code class="cpp hljs">config I2C_SKEL tristate <span class="hljs-string"><span class="hljs-string">"I2C adapter"</span></span> help If you say yes to <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> option, support will be included <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the I2C interface.</code> </pre><br>  3.将<i>驱动程序/ i2c /总线/ Makefile</i>驱动程序添加到<i>程序集中</i> ： <br><br><pre> <code class="cpp hljs">obj-$(CONFIG_I2C_SKEL) += i2c-skel.o</code> </pre><br>  4.在设备树（* .dts）中添加I2C块的描述，并立即支持eeprom设备： <br><br><pre> <code class="cpp hljs"> i2c: i2c@f8f01d00 { compatible = <span class="hljs-string"><span class="hljs-string">"skel,skel-i2c"</span></span>; <span class="hljs-meta"><span class="hljs-meta">#address-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;1&gt;; #size-cells = &lt;0&gt;; reg = &lt;0x43c00000 0x100&gt;; interrupt-parent = &lt;&amp;ps7_scugic_0&gt;; interrupts = &lt;0 29 4&gt;; clock-names = "skel-i2c"; clocks = &lt;&amp;clkc 38&gt;; clock-frequency = &lt;100000&gt;; 24c64@50 { compatible = "at,24c64"; pagesize = &lt;32&gt;; reg = &lt;0x50&gt;; }; } ;</span></span></span></span></code> </pre><br> 上面的步骤将不会被详细考虑，但是好奇的读者可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>看看。 <br><br><h3>  <b>第四步</b> </h3><br> 在熟悉了驱动程序的原理之后，让我们继续执行。 <br> 首先，连接头文件，描述“虚拟”注册卡以及I2C驱动程序的介绍。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* i2c-skel.c: I2C bus driver. * * Name Surname &lt;name@surname.ru&gt; * * This file is licensed under the terms of the GNU General Public License * version 2. This program is licensed "as is" without any warranty of any * kind, whether express or implied. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/i2c.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/clk.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/time.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/device.h&gt; /* * Registers description. */ #define SKEL_I2C_ID 0x00 /* Core Identifier register */ #define SKEL_I2C_ISR 0x14 /* Interrupt Status Register */ #define SKEL_I2C_ISR_DNE BIT(0) /* One byte transaction done */ #define SKEL_I2C_ISR_ARB BIT(1) /* Arbitration lost */ #define SKEL_I2C_ISR_TXE BIT(2) /* RX FIFO nearly full */ #define SKEL_I2C_ISR_NACK BIT(3) /* No ACK */ #define SKEL_I2C_IER 0x18 /* Interrupt Enable Register */ #define SKEL_I2C_IER_DNE BIT(0) /* Enable DNE IRQ */ #define SKEL_I2C_IER_ARB BIT(1) /* Enable ARB LOSR IRQ */ #define SKEL_I2C_IER_TXE BIT(2) /* Enable TX FIFO EPMTY IRQ */ #define SKEL_I2C_IER_NACK BIT(3) /* Enable NACK IRQ */ #define SKEL_I2C_CTRL 0x1C /* Control Register */ #define SKEL_I2C_CTRL_EN BIT(0) /* Enable I2C controller */ #define SKEL_I2C_CTRL_START BIT(1) /* Send START condition */ #define SKEL_I2C_CTRL_R BIT(2) /* Read command */ #define SKEL_I2C_CTRL_W BIT(3) /* Write command */ #define SKEL_I2C_CTRL_STOP BIT(4) /* Send STOP cindition */ #define SKEL_I2C_TX 0x20 /* TX FIFO */ #define SKEL_I2C_RX 0x24 /* RX FIFO */ #define SKEL_I2C_CLK 0x28 /* Clock Prescale Register*/ #define SKEL_I2C_TIMEOUT 100000 #define SKEL_I2C_XFER_TIMEOUT (msecs_to_jiffies(500)) #define FIFO_SIZE_TX 1024 #define FIFO_SIZE_RX 1024 int presc = -1; module_param(presc, int, S_IRUGO | S_IWUSR); /* * skel_i2c - I2C device context * @base: pointer to register struct * @msg: pointer to current message * @mlen: number of bytes transferred in msg * @dev: device reference * @adap: i2c core abstraction * @msg_complete: xfer completion object * @clk: reference for i2c input clock * @err: error occured * @buf: ptr to msg buffer * @bus_clock: current i2c bus clock rate * @lock: spinlock for IRQ synchronization */ struct skel_i2c { void __iomem *base; struct i2c_msg *msg; size_t mlen; struct device *dev; struct i2c_adapter adap; struct completion msg_complete; struct clk *clk; u32 bus_clock; int err; u32 addr; u8 *buf; spinlock_t lock; };</span></span></span></span></code> </pre><br> 控制器的主要控制寄存器为： <br><br><ul><li> 控制寄存器（CTRL）-控制寄存器； </li><li> 中断状态寄存器（ISR）-中断状态寄存器； </li><li> 中断使能寄存器（IER）-中断屏蔽寄存器。 </li></ul><br> 驱动程序的核心是skel_i2c结构，其中包含以下字段： <br><br><ul><li>  .base-指向注册卡开头的指针； </li><li>  .msg-指向当前消息的指针； </li><li>  .adap-I2C抽象<a href="">（单击）</a> 。 </li></ul><br> 让我们继续进行更实际的部分，描述驱动程序支持的设备类型， <br>  I2C适配器功能和I2C消息传递接口： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of_device_id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c_match</span></span></span><span class="hljs-class">[] = {</span></span> { .compatible = <span class="hljs-string"><span class="hljs-string">"skel,skel-i2c"</span></span>, }, { .compatible = <span class="hljs-string"><span class="hljs-string">"at,24c64"</span></span>, }, {}, }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> u32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_i2c_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct i2c_adapter *adap)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i2c_algorithm</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c_algo</span></span></span><span class="hljs-class"> = {</span></span> .master_xfer = skel_i2c_xfer, .functionality = skel_i2c_func, }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c_driver</span></span></span><span class="hljs-class"> = {</span></span> .probe = skel_i2c_probe, .remove = skel_i2c_remove, .driver = { .name = <span class="hljs-string"><span class="hljs-string">"skel-i2c"</span></span>, .of_match_table = skel_i2c_match, }, }; module_platform_driver(skel_i2c_driver); MODULE_AUTHOR(<span class="hljs-string"><span class="hljs-string">"Name Surname"</span></span>); MODULE_DESCRIPTION(<span class="hljs-string"><span class="hljs-string">"I2C bus driver"</span></span>); MODULE_LICENSE(<span class="hljs-string"><span class="hljs-string">"GPL"</span></span>); MODULE_ALIAS(<span class="hljs-string"><span class="hljs-string">"platform:skel-i2c"</span></span>);</code> </pre><br> 从结构和功能的名称来看，它们的用途显而易见，我们仅从上面描述了主要结构： <br><br><ul><li>  skel_i2c_driver-描述驱动程序的名称，支持的设备和函数的表，这些函数在内核模块从系统中加载或删除时被调用。 </li></ul><br> 现在该在系统中注册驱动程序了，这意味着实现控制器初始化功能，并描述skel_i2c_probe（在将驱动程序加载到系统中时调用）和skel_i2c_remove（在从系统中删除驱动程序时调用）。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_i2c_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct skel_i2c *rdev)</span></span></span><span class="hljs-function"> </span></span>{ u32 bus_clk_khz = rdev-&gt;bus_clock / <span class="hljs-number"><span class="hljs-number">1000</span></span>; u32 clk_khz = clk_get_rate(rdev-&gt;clk) / <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prescale; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff; prescale = clk_khz / (<span class="hljs-number"><span class="hljs-number">5</span></span> * bus_clk_khz) - <span class="hljs-number"><span class="hljs-number">1</span></span>; prescale = clamp(prescale, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>); diff = clk_khz / (<span class="hljs-number"><span class="hljs-number">5</span></span> * (prescale <span class="hljs-number"><span class="hljs-number">1</span></span>)) - bus_clk_khz; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(diff) &gt; bus_clk_khz / <span class="hljs-number"><span class="hljs-number">10</span></span>) { dev_err(rdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Unsupported clock settings: clk: %d KHz, bus: %d KHz\n"</span></span>, clk_khz, bus_clk_khz); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (presc != <span class="hljs-number"><span class="hljs-number">-1</span></span>) i2c_write(presc, rdev-&gt;base, SKEL_I2C_CLK); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> i2c_write(prescale, rdev-&gt;base, SKEL_I2C_CLK); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_i2c_probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct platform_device *pdev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rdev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resource</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">res</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> irq, ret; u32 val; rdev = devm_kzalloc(&amp;pdev-&gt;dev, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*rdev), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rdev) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="hljs-number"><span class="hljs-number">0</span></span>); rdev-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(rdev-&gt;base)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(rdev-&gt;base); irq = platform_get_irq(pdev, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Missing interrupt resource\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> irq; } rdev-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(rdev-&gt;clk)) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Missing clock\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PTR_ERR(rdev-&gt;clk); } rdev-&gt;dev = &amp;pdev-&gt;dev; init_completion(&amp;rdev-&gt;msg_complete); spin_lock_init(&amp;rdev-&gt;lock); val = of_property_read_u32(pdev-&gt;dev.of_node, <span class="hljs-string"><span class="hljs-string">"clock-frequency"</span></span>, &amp;rdev-&gt;bus_clock); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Default to 100kHz\n"</span></span>); rdev-&gt;bus_clock = <span class="hljs-number"><span class="hljs-number">100000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* default clock rate */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rdev-&gt;bus_clock &gt; <span class="hljs-number"><span class="hljs-number">400000</span></span>) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Invalid clock-frequency %d\n"</span></span>, rdev-&gt;bus_clock); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; } ret = devm_request_irq(&amp;pdev-&gt;dev, irq, skel_i2c_isr, <span class="hljs-number"><span class="hljs-number">0</span></span>, pdev-&gt;name, rdev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Failed to claim IRQ %d\n"</span></span>, irq); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } ret = clk_prepare_enable(rdev-&gt;clk); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) { dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Failed to enable clock\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } skel_i2c_init(rdev); i2c_set_adapdata(&amp;rdev-&gt;adap, rdev); strlcpy(rdev-&gt;adap.name, pdev-&gt;name, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(rdev-&gt;adap.name)); rdev-&gt;adap.owner = THIS_MODULE; rdev-&gt;adap.algo = &amp;skel_i2c_algo; rdev-&gt;adap.dev.parent = &amp;pdev-&gt;dev; rdev-&gt;adap.dev.of_node = pdev-&gt;dev.of_node; platform_set_drvdata(pdev, rdev); ret = i2c_add_adapter(&amp;rdev-&gt;adap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) { clk_disable_unprepare(rdev-&gt;clk); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } dev_info(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"I2C probe complete\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skel_i2c_remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct platform_device *pdev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skel_i2c</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rdev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_get_drvdata</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdev</span></span></span><span class="hljs-class">);</span></span> clk_disable_unprepare(rdev-&gt;clk); i2c_del_adapter(&amp;rdev-&gt;adap); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br> 最简单的功能是skel_i2c_remove，它将关闭时钟源并释放已用的内存。  skel_i2c_init函数执行I2C控制器的初始化。 <br><br> 如前所述，skel_i2c_probe在系统中注册了驱动程序。 有条件的操作顺序可以分为两个阶段： <br><br><ul><li> 获取系统资源并注册中断处理程序skel_i2c_isr; </li><li> 填写结构字段并调用添加新I2C适配器的过程。 </li></ul><br> 在系统中注册驱动程序后，可以在接口上实现消息传输逻辑： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i2c_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr)</span></span></span><span class="hljs-function"> </span></span>{ writel(value, base addr); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined DEBUG dev_dbg(rdev-&gt;dev, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"iowrite32(0x%x, base 0x%x);\n"</span></span></span><span class="hljs-meta">, value, addr); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } static inline uint32_t i2c_read(void *base, uint32_t addr) { uint32_t reg = readl(base addr); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined DEBUG dev_dbg(rdev-&gt;dev, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/* ioread32(base 0x%x) == 0x%x */\n"</span></span></span><span class="hljs-meta">, addr, reg); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return reg; } static irqreturn_t skel_i2c_isr(int irq, void *dev) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (unlikely(int_stat &amp; skel_I2C_ISR_ARB)) { } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (unlikely(int_stat &amp; skel_I2C_ISR_NACK)) { } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (read) fill_rx_fifo(rdev); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> fill_tx_fifo(rdev); complete(&amp;rdev-&gt;msg_complete); return IRQ_HANDLED; } static int skel_i2c_xfer_msg(struct skel_i2c *rdev, struct i2c_msg *msg) { unsigned long time; rdev-&gt;msg = msg; rdev-&gt;mlen = msg-&gt;len; rdev-&gt;addr = msg-&gt;addr; rdev-&gt;buf = msg-&gt;buf; rdev-&gt;err = 0; reinit_completion(&amp;rdev-&gt;msg_complete); skel_i2c_start_trans(rdev, msg); time = wait_for_completion_timeout(&amp;rdev-&gt;msg_complete, skel_I2C_XFER_TIMEOUT); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (time == 0) rdev-&gt;err = -ETIMEDOUT; rdev-&gt;curr; return rdev-&gt;err; } static int skel_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num) { struct skel_i2c *rdev = i2c_get_adapdata(adap); int i, ret = 0; for (i = 0; (ret == 0) &amp;&amp; (i &lt; num); i) ret = skel_i2c_xfer_msg(rdev, msgs); skel_i2c_snd_stop(rdev); return ret ? : num; }</span></span></code> </pre><br> 第一步描述了用户空间应用程序与系统内核模块的交互。 在我们实现了驱动程序的内部结构之后，很容易看到进行交换的接口。 通常，消息传递如下： <br><br><ul><li>  skel_i2c_xfer-该函数直接接收要传输的消息，并将每个消息顺序传输到skel_i2c_xfer_msg。 如果在数据传输过程中发生错误，则数据传输将停止； </li><li>  skel_i2c_xfer_msg-该函数设置所有必要的驱动程序字段并启动消息传输的开始； </li><li>  skel_i2c_isr-中断处理程序。 在这里进行错误处理和总线通信。 如果所有数据都已发送/接收，则通过调用complete函数来设置完成标志，该标志表示消息传输已完成。 </li></ul><br> 本文没有描述这项工作的一些细微之处。 例如，发送消息的操作顺序，因为此算法的实现取决于硬件。 无论控制器的硬件功能如何，我们都专注于驱动程序常规部分的实现。 <br><br> 完整的驱动程序框架如下所示。 请，如果您发现错误/不正确，或者您有什么要补充的内容，请写在PM或注释中。 <br><br><div class="spoiler">  <b class="spoiler_title">驱动程序骨架</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* i2c-skel.c: I2C bus driver. * * Name Surname &lt;name@surname.ru&gt; * * This file is licensed under the terms of the GNU General Public License * version 2. This program is licensed "as is" without any warranty of any * kind, whether express or implied. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/platform_device.h&gt; #include &lt;linux/i2c.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/clk.h&gt; #include &lt;linux/interrupt.h&gt; #include &lt;linux/time.h&gt; #include &lt;linux/delay.h&gt; #include &lt;linux/device.h&gt; /* * Registers description. */ #define SKEL_I2C_ID 0x00 /* Core Identifier register */ #define SKEL_I2C_ISR 0x14 /* Interrupt Status Register */ #define SKEL_I2C_ISR_DNE BIT(0) /* One byte transaction done */ #define SKEL_I2C_ISR_ARB BIT(1) /* Arbitration lost */ #define SKEL_I2C_ISR_TXE BIT(2) /* RX FIFO nearly full */ #define SKEL_I2C_ISR_NACK BIT(3) /* No ACK */ #define SKEL_I2C_IER 0x18 /* Interrupt Enable Register */ #define SKEL_I2C_IER_DNE BIT(0) /* Enable DNE IRQ */ #define SKEL_I2C_IER_ARB BIT(1) /* Enable ARB LOSR IRQ */ #define SKEL_I2C_IER_TXE BIT(2) /* Enable TX FIFO EPMTY IRQ */ #define SKEL_I2C_IER_NACK BIT(3) /* Enable NACK IRQ */ #define SKEL_I2C_CTRL 0x1C /* Control Register */ #define SKEL_I2C_CTRL_EN BIT(0) /* Enable I2C controller */ #define SKEL_I2C_CTRL_START BIT(1) /* Send START condition */ #define SKEL_I2C_CTRL_R BIT(2) /* Read command */ #define SKEL_I2C_CTRL_W BIT(3) /* Write command */ #define SKEL_I2C_CTRL_STOP BIT(4) /* Send STOP cindition */ #define SKEL_I2C_TX 0x20 /* TX FIFO */ #define SKEL_I2C_RX 0x24 /* RX FIFO */ #define SKEL_I2C_CLK 0x28 /* Clock Prescale Register*/ #define SKEL_I2C_TIMEOUT 100000 #define SKEL_I2C_XFER_TIMEOUT (msecs_to_jiffies(500)) #define FIFO_SIZE_TX 1024 #define FIFO_SIZE_RX 1024 int presc = -1; module_param(presc, int, S_IRUGO | S_IWUSR); /* * skel_i2c - I2C device context * @base: pointer to register struct * @msg: pointer to current message * @mlen: number of bytes transferred in msg * @dev: device reference * @adap: i2c core abstraction * @msg_complete: xfer completion object * @clk: reference for i2c input clock * @err: error occured * @buf: ptr to msg buffer * @bus_clock: current i2c bus clock rate * @lock: spinlock for IRQ synchronization */ struct skel_i2c { void __iomem *base; struct i2c_msg *msg; size_t mlen; struct device *dev; struct i2c_adapter adap; struct completion msg_complete; struct clk *clk; u32 bus_clock; int err;; u32 addr; u8 *buf; spinlock_t lock; }; static const struct of_device_id skel_i2c_match[] = { { .compatible = "skel,skel-i2c", }, { .compatible = "at,24c64", }, {}, }; static inline void i2c_write(uint32_t value, void *base, uint32_t addr) { writel(value, base + addr); #if defined DEBUG dev_dbg(rdev-&gt;dev, "iowrite32(0x%x, base 0x%x);\n", value, addr); #endif } static inline uint32_t i2c_read(void *base, uint32_t addr) { uint32_t reg = readl(base + addr); #if defined DEBUG dev_dbg(rdev-&gt;dev, "/* ioread32(base 0x%x) == 0x%x */\n", addr, reg); #endif return reg; } static void skel_i2c_transfer(struct skel_i2c *rdev, u32 data) { i2c_write(data, rdev-&gt;base, SKEL_I2C_TX); } static void fill_tx_fifo(struct skel_i2c *rdev) { size_t tx_fifo_avail = FIFO_SIZE_TX; int bytes_to_transfer = min(tx_fifo_avail, rdev-&gt;mlen); while (bytes_to_transfer-- &gt; 0) { skel_i2c_transfer(rdev, *rdev-&gt;buf); rdev-&gt;mlen--; } } static void fill_rx_fifo(struct skel_i2c *rdev) { size_t rx_fifo_avail = FIFO_SIZE_RX; int receive = min(rx_fifo_avail, rdev-&gt;mlen); while (receive-- &gt; 0) { *rdev-&gt;buf = i2c_read(rdev-&gt;base, SKEL_I2C_RX); rdev-&gt;mlen--; } } void skel_i2c_snd_stop(struct skel_i2c *rdev) { u32 control = i2c_read(rdev-&gt;base, SKEL_I2C_CTRL); i2c_write(control | SKEL_I2C_CTRL_STOP, rdev-&gt;base, SKEL_I2C_CTRL); } static irqreturn_t skel_i2c_isr(int irq, void *dev) { struct skel_i2c *rdev = dev; u32 int_stat, read; int_stat = i2c_read(rdev-&gt;base, SKEL_I2C_ISR); read = rdev-&gt;msg-&gt;flags &amp; I2C_M_RD; if (unlikely(int_stat &amp; SKEL_I2C_ISR_ARB)) { } else if (unlikely(int_stat &amp; SKEL_I2C_ISR_NACK)) { } if (read) fill_rx_fifo(rdev); else fill_tx_fifo(rdev); complete(&amp;rdev-&gt;msg_complete); return IRQ_HANDLED; } static void skel_i2c_start_trans(struct skel_i2c *rdev, struct i2c_msg *msg) { } static int skel_i2c_xfer_msg(struct skel_i2c *rdev, struct i2c_msg *msg) { unsigned long time; rdev-&gt;msg = msg; rdev-&gt;mlen = msg-&gt;len; rdev-&gt;addr = msg-&gt;addr; rdev-&gt;buf = msg-&gt;buf; rdev-&gt;err = 0; reinit_completion(&amp;rdev-&gt;msg_complete); skel_i2c_start_trans(rdev, msg); time = wait_for_completion_timeout(&amp;rdev-&gt;msg_complete, SKEL_I2C_XFER_TIMEOUT); if (time == 0) rdev-&gt;err = -ETIMEDOUT; return rdev-&gt;err; } static int skel_i2c_init(struct skel_i2c *rdev) { u32 bus_clk_khz = rdev-&gt;bus_clock / 1000; u32 clk_khz = clk_get_rate(rdev-&gt;clk) / 1000; int prescale; int diff; prescale = clk_khz / (5 * bus_clk_khz) - 1; prescale = clamp(prescale, 0, 0xFFFF); diff = clk_khz / (5 * (prescale - 1)) - bus_clk_khz; if (abs(diff) &gt; bus_clk_khz / 10) { dev_err(rdev-&gt;dev, "Unsupported clock settings: clk: %d KHz, bus: %d KHz\n", clk_khz, bus_clk_khz); return -EINVAL; } if (presc != -1) i2c_write(presc, rdev-&gt;base, SKEL_I2C_CLK); else i2c_write(prescale, rdev-&gt;base, SKEL_I2C_CLK); return 0; } static int skel_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num) { struct skel_i2c *rdev = i2c_get_adapdata(adap); int i, ret = 0; for (i = 0; (ret == 0) &amp;&amp; (i &lt; num); i++) ret = skel_i2c_xfer_msg(rdev, msgs); skel_i2c_snd_stop(rdev); return ret ? : num; } static u32 skel_i2c_func(struct i2c_adapter *adap) { return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL; } static const struct i2c_algorithm skel_i2c_algo = { .master_xfer = skel_i2c_xfer, .functionality = skel_i2c_func, }; static int skel_i2c_probe(struct platform_device *pdev) { struct skel_i2c *rdev = NULL; struct resource *res; int irq, ret; u32 val; rdev = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*rdev), GFP_KERNEL); if (!rdev) return -ENOMEM; res = platform_get_resource(pdev, IORESOURCE_MEM, 0); rdev-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res); if (IS_ERR(rdev-&gt;base)) return PTR_ERR(rdev-&gt;base); irq = platform_get_irq(pdev, 0); if (irq &lt; 0) { dev_err(&amp;pdev-&gt;dev, "Missing interrupt resource\n"); return irq; } rdev-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, NULL); if (IS_ERR(rdev-&gt;clk)) { dev_err(&amp;pdev-&gt;dev, "Missing clock\n"); return PTR_ERR(rdev-&gt;clk); } rdev-&gt;dev = &amp;pdev-&gt;dev; init_completion(&amp;rdev-&gt;msg_complete); spin_lock_init(&amp;rdev-&gt;lock); val = of_property_read_u32(pdev-&gt;dev.of_node, "clock-frequency", &amp;rdev-&gt;bus_clock); if (val) { dev_err(&amp;pdev-&gt;dev, "Default to 100kHz\n"); rdev-&gt;bus_clock = 100000; /* default clock rate */ } if (rdev-&gt;bus_clock &gt; 400000) { dev_err(&amp;pdev-&gt;dev, "Invalid clock-frequency %d\n", rdev-&gt;bus_clock); return -EINVAL; } ret = devm_request_irq(&amp;pdev-&gt;dev, irq, skel_i2c_isr, 0, pdev-&gt;name, rdev); if (ret) { dev_err(&amp;pdev-&gt;dev, "Failed to claim IRQ %d\n", irq); return ret; } ret = clk_prepare_enable(rdev-&gt;clk); if (ret) { dev_err(&amp;pdev-&gt;dev, "Failed to enable clock\n"); return ret; } skel_i2c_init(rdev); i2c_set_adapdata(&amp;rdev-&gt;adap, rdev); strlcpy(rdev-&gt;adap.name, pdev-&gt;name, sizeof(rdev-&gt;adap.name)); rdev-&gt;adap.owner = THIS_MODULE; rdev-&gt;adap.algo = &amp;skel_i2c_algo; rdev-&gt;adap.dev.parent = &amp;pdev-&gt;dev; rdev-&gt;adap.dev.of_node = pdev-&gt;dev.of_node; platform_set_drvdata(pdev, rdev); ret = i2c_add_adapter(&amp;rdev-&gt;adap); if (ret) { clk_disable_unprepare(rdev-&gt;clk); return ret; } dev_info(&amp;pdev-&gt;dev, "I2C probe complete\n"); return 0; } static int skel_i2c_remove(struct platform_device *pdev) { struct skel_i2c *rdev = platform_get_drvdata(pdev); clk_disable_unprepare(rdev-&gt;clk); i2c_del_adapter(&amp;rdev-&gt;adap); return 0; } static struct platform_driver skel_i2c_driver = { .probe = skel_i2c_probe, .remove = skel_i2c_remove, .driver = { .name = "skel-i2c", .of_match_table = skel_i2c_match, }, }; module_platform_driver(skel_i2c_driver); MODULE_AUTHOR("Name Surname"); MODULE_DESCRIPTION("I2C bus driver"); MODULE_LICENSE("GPL"); MODULE_ALIAS("platform:skel-i2c");</span></span></span></span></code> </pre><br></div></div><br> 感谢您的关注！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413249/">https://habr.com/ru/post/zh-CN413249/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413239/index.html">如何使智能手机变得笨拙</a></li>
<li><a href="../zh-CN413241/index.html">使用ftrace拦截Linux内核中的函数</a></li>
<li><a href="../zh-CN413243/index.html">数据学院：如何将数学与商业结合</a></li>
<li><a href="../zh-CN413245/index.html">在杜比全景声（Dolby Atmos）设备上-仅“本机”声音。 杜比禁止非本地混音</a></li>
<li><a href="../zh-CN413247/index.html">为什么要监视存储系统？</a></li>
<li><a href="../zh-CN413251/index.html">聚合酶链反应和符拉迪沃斯托克（海参div）</a></li>
<li><a href="../zh-CN413253/index.html">理查德·汉明（Richard Hamming）：第21章。</a></li>
<li><a href="../zh-CN413255/index.html">理查德·汉明（Richard Hamming）：第27章。无效数据</a></li>
<li><a href="../zh-CN413261/index.html">搜索的工作方式</a></li>
<li><a href="../zh-CN413265/index.html">带IT去澡堂</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>