<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèº üôÅ üë©üèº‚ÄçüöÄ RANS de codificaci√≥n de entrop√≠a o c√≥mo escribir su propio archivador üé¥ üà∫ üë©üèø‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo puede ser de inter√©s para aquellos que se dedican a la compresi√≥n de datos o desean escribir su propio archivador. 

  

 El art√≠culo es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RANS de codificaci√≥n de entrop√≠a o c√≥mo escribir su propio archivador</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/441814/">  Este art√≠culo puede ser de inter√©s para aquellos que se dedican a la compresi√≥n de datos o desean escribir su propio archivador. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/jz/w8/xk/jzw8xkq1k6enudm8xozmna6m3ia.jpeg"></a> <br><br>  El art√≠culo est√° escrito principalmente sobre los materiales del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog</a> , que es mantenido por Fabian Giesen. <br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  El m√©todo de codificaci√≥n de entrop√≠a rANS ( <b>r</b> ange + ANS) es el hermano del algoritmo FSE, sobre el que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrib√≠ anteriormente</a> .  La abreviatura ANS significa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sistemas de n√∫meros asim√©tricos</a> , y el rango de palabras en el nombre sugiere la similitud de este m√©todo con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">codificaci√≥n por intervalos</a> .  El autor de rANS es <a href="">Yarek Duda</a> . <br><br>  El m√©todo rANS le permite lograr una compresi√≥n casi √≥ptima a una velocidad muy alta.  En este rANS no es peor que FSE, lo cual no es sorprendente: ambos algoritmos se basan en una base te√≥rica com√∫n.  Sin embargo, el algoritmo rANS es mucho m√°s simple de implementar que FSE. <br><br>  Primero, habr√° una larga parte "te√≥rica", y luego intentaremos escribir un archivador simple. <br><br><h2>  Descripci√≥n del m√©todo </h2><br>  El funcionamiento del algoritmo est√° determinado por las siguientes f√≥rmulas simples: <br><br>  <b>Codificaci√≥n:</b> <code>C(s,x): x := (x / Fs) * M + Bs + (x % Fs)</code> <br>  <b>Decodificaci√≥n:</b> <code>D(x): s = sym[x % M], x := Fs * (x / M) + (x % M) - Bs</code> <br><br>  Analicemos en detalle. <br><br>  La funci√≥n de codificaci√≥n <b>C (s, x)</b> recibe los caracteres <b>s</b> a codificar (que sea un n√∫mero entero) y el estado actual del codificador <b>x</b> (tambi√©n un n√∫mero entero). <br><br>  <b>F <sub>s</sub></b> - frecuencia de s√≠mbolo <b>s</b> .  La divisi√≥n por Fs anterior es entera. <br>  <b>M</b> es la suma de las frecuencias de todos los s√≠mbolos del alfabeto ( <b>M =</b> Œ£ <b>F <sub>s</sub></b> ). <br>  <b>En <sub>s</sub></b> , el comienzo del intervalo correspondiente al car√°cter codificado (en la figura siguiente). <br>  <b>x</b> % <b>Fs</b> es el resto de dividir <b>x</b> por <b>F <sub>s</sub></b> . <br><br>  El principio de operaci√≥n es el mismo que en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">codificaci√≥n aritm√©tica</a> : tomamos el segmento <b>[</b> 0, <b>M)</b> y lo dividimos en partes para que cada car√°cter <b>s</b> corresponda a un intervalo de tama√±o igual a la frecuencia del car√°cter <b>F <sub>s</sub></b> .  La aparici√≥n del valor <b>x% M</b> en cualquier intervalo denota la codificaci√≥n del s√≠mbolo correspondiente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6i/vl/ql/6ivlqldcqlkeuwsxu6fcypus39o.png"></div><br>  Al comienzo de la codificaci√≥n, inicialice <b>x con</b> un valor arbitrario adecuado y luego calcule la funci√≥n <b>C (s, x)</b> para todos los caracteres codificados en secuencia. <br><br>  Cada c√°lculo de la funci√≥n <b>C (s, x)</b> aumenta el valor de <b>x</b> .  Cuando se vuelve demasiado grande, debe volcar los datos en la salida: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt;= x_max) {   writeToStream(x % b); <span class="hljs-comment"><span class="hljs-comment">//     x /= b; //  x }</span></span></code> </pre> <br>  Este paso se llama <i>renormalizaci√≥n</i> .  Despu√©s de eso, puede continuar codificando. <br><br>  Arriba en el c√≥digo, aparecieron nuevas constantes: <b>x_max</b> y <b>b</b> .  En teor√≠a, los n√∫meros <b>M</b> , <b>b</b> y <b>x_max</b> est√°n relacionados por algunas relaciones, pero en la pr√°ctica es m√°s efectivo usar los siguientes valores si el estado uint32 se usa para el estado <code>x</code> : <br><br>  <b>M</b> = 2 ^ <b>k</b> , donde <b>k</b> &lt;= 16 <br>  <b>b</b> = 2 ^ 16 (la mitad del tama√±o de uint32) <br><br>  La elecci√≥n de <b>M</b> = 2 ^ <b>k</b> se debe al hecho de que hay una divisi√≥n por <b>M</b> en la funci√≥n de decodificaci√≥n, por lo que la divisi√≥n con el resto se puede reemplazar con operaciones bit a bit. <br><br>  El valor de <b>k</b> se selecciona de las siguientes consideraciones: cuanto mayor es, mayor es la precisi√≥n de <b>Fs</b> y m√°s eficiente es la compresi√≥n.  En este caso, se deben tener en cuenta algunos gastos generales para almacenar la tabla de frecuencias, por lo que no siempre vale la pena utilizar los valores m√°ximos de <b>k</b> . <br><br>  El valor de <b>x_max</b> debe ser tal que no se produzca un desbordamiento.  Seg√∫n la funci√≥n de codificaci√≥n, obtenemos que <b>x</b> &lt; <b>uint32_max</b> * <b>Fs</b> / <b>M</b> o de una manera ligeramente diferente: <b>x_max</b> &lt;= ( <b>b</b> * <b>L</b> ) * <b>Fs</b> / <b>M</b> , donde <b>L</b> &lt;= <b>uint32_max</b> / <b>b</b> .  En c√≥digo real, la condici√≥n toma la forma x / b&gt; = L / M * Fs para evitar el desbordamiento en los c√°lculos. <br><br>  El valor <b>b</b> = 2 ^ 16 (la mitad del tama√±o de uint32) se elige de tal manera que si <b>x</b> excede <b>x_max</b> , entonces una divisi√≥n por <b>b es</b> suficiente para continuar trabajando.  Como resultado, el <code>while</code> finalizar√° despu√©s de la primera iteraci√≥n, lo que significa que se puede reemplazar con un simple <code>if</code> . <br><br>  Como resultado, la funci√≥n de codificaci√≥n toma la siguiente forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RansState; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RANS_L = <span class="hljs-number"><span class="hljs-number">1u</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> k = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   constexpr uint32_t RANS_M = 1u &lt;&lt; k; // M = 2^k //   s void RansEnc(RansState&amp; x, uint32_t s, RansOutBuf&amp; out) {   assert(x &gt;= RANS_L); //        uint32 Fs = freq[s]; //   s   uint32 Bs = range_start[s]; //   s   assert(Fs &gt; 0 &amp;&amp; Fs &lt;= RANS_M);     // renormalize   if ((x &gt;&gt; 16) &gt;= (RANS_L &gt;&gt; k) * Fs) { // x / b &gt;=  L / M * Fs       out.put( x &amp; 0xffff );       x &gt;&gt;= 16;   }   x = ((x / Fs) &lt;&lt; k) + Bs + (x % Fs); // C(s,x)     assert(x &gt;= RANS_L); //      }</span></span></code> </pre> <br>  Al final de la codificaci√≥n, debe guardar el valor de <b>x</b> , ya que la decodificaci√≥n comenzar√° desde all√≠.  Y s√≠, decodificaremos desde el final hasta el principio, es decir, desde el √∫ltimo car√°cter codificado hasta el primero.  (El art√≠culo sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FSE</a> explica este punto con suficiente detalle). <br><br>  Quiero detenerme un poco m√°s sobre c√≥mo funciona la f√≥rmula de codificaci√≥n. <br><br><pre> <code class="cpp hljs">x := (x / Fs) * M + Bs + (x % Fs)</code> </pre> <br>  Despu√©s de calcular ( <code>x / Fs) * M</code> , la variable <b>x</b> contiene los <b>k</b> bits menos significativos (recuerde que <b>M</b> = 2 ^ <b>k</b> ).  Agregar <code>+ Bs + (x % Fs)</code> esencialmente escribe en estos bits un cierto valor del <i>intervalo del</i> car√°cter <b>s</b> , porque <b>Bs</b> es el comienzo del intervalo, y (x% Fs) es el n√∫mero dentro de este intervalo (el tama√±o del intervalo es Fs).  Por lo tanto, al decodificar, podemos determinar el car√°cter codificado por el intervalo en el que cae (x% M). <br><br>  <b>Decodificaci√≥n</b> <br><br>  Pasemos a la funci√≥n de decodificaci√≥n. <br><br><pre> <code class="cpp hljs">D(x): s = sym[x % M], x := Fs * (x / M) + (x % M) - Bs</code> </pre> <br>  Como ya entendimos anteriormente, el car√°cter deseado <b>s</b> est√° determinado por el resto de la divisi√≥n <b>x</b> % <b>M.</b>  En qu√© intervalo cay√≥ el valor (x% M), se codific√≥ dicho car√°cter. <br><br>  Anteriormente, definimos espec√≠ficamente M = 2 ^ k para simplificar la funci√≥n de decodificaci√≥n.  Termin√≥ as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> RansDecode(RansState&amp; x, RansInBuf&amp; in) {   assert(x &gt;= RANS_L); <span class="hljs-comment"><span class="hljs-comment">//       uint32_t x_mod = x &amp; (RANS_M - 1); // = x % M   //  ,    x_mod,     assert(x_mod &lt; dct.size());   uint32_t s = dct[x_mod]; //     uint32 Fs = freq[s]; //   s   uint32 Bs = range_start[s]; //    s   x = (x &gt;&gt; k) * Fs + x_mod - Bs;     // renormalize   if (x &lt; RANS_L) {       x = (x &lt;&lt; 16) | in.read16(); //  16    }     assert(x &gt;= RANS_L); //     return s; }</span></span></code> </pre> <br>  La decodificaci√≥n comienza con la misma <b>x</b> que se obtuvo al final de la codificaci√≥n.  Para hacer esto, debe guardarse junto con los datos codificados. <br><br>  Al final de la decodificaci√≥n, el estado del decodificador <b>x</b> debe ser exactamente el mismo que el de la codificaci√≥n.  En general, en cada paso <b>x</b> debe ser exactamente el mismo que en el paso de codificaci√≥n correspondiente.  Este hecho ayuda mucho al depurar. <br><br>  Como puede ver, la decodificaci√≥n funciona m√°s r√°pido que la codificaci√≥n, ya que no hay operaciones de divisi√≥n. <br><br>  El momento m√°s dif√≠cil en la funci√≥n de decodificaci√≥n es el m√©todo para determinar en qu√© intervalo cay√≥ el valor (x% M). <br><br>  El m√©todo m√°s f√°cil y r√°pido es usar la tabla <b>sym []</b> , tama√±o <b>M.</b>  En este caso, obtenemos una tabla del mismo tama√±o que en el algoritmo FSE, con la diferencia de que en rANS la tabla no est√° "mezclada", los caracteres est√°n en orden y esa tabla es mucho m√°s f√°cil de construir. <br><br>  El principal inconveniente de este enfoque es el tama√±o de la tabla de <b>s√≠mbolos</b> , que crece exponencialmente con el aumento de <b>k</b> . <br><br><h2>  M√©todo alias </h2><br>  Se invent√≥ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√©todo de alias</a> para determinar de manera m√°s eficiente el golpe en un intervalo.  Este m√©todo le permite determinar r√°pidamente el intervalo deseado utilizando tablas peque√±as, por la cantidad de caracteres en el alfabeto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kv/v0/gu/kvv0guji6nfuxxr6mcjorxxsv9a.png"></div><br>  Una explicaci√≥n larga y larga se puede encontrar aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dardos, dados y monedas</a> .  Describir√© brevemente la esencia del m√©todo: tomamos un fragmento del intervalo m√°s largo y lo adjuntamos al intervalo m√°s corto para que el tama√±o total sea exactamente <b>M</b> / <b>N</b> (donde <b>N</b> es el n√∫mero de caracteres en el alfabeto).  Resulta que si haces esto secuencialmente, siempre terminar√°s con <b>N</b> pares de tama√±o <b>M</b> / <b>N.</b> <br><br>  Naturalmente, <b>M</b> debe ser divisible por <b>N.</b>  Y si recordamos que tenemos <b>M</b> = 2 ^ <b>k</b> , entonces el tama√±o del alfabeto tambi√©n resulta ser una potencia de dos.  Esto no es un problema, ya que siempre puede complementar el alfabeto al tama√±o deseado con caracteres no utilizados con una frecuencia cero. <br><br>  El hecho de que el intervalo de caracteres se divida en varias partes complica un poco el procedimiento de codificaci√≥n, pero no mucho.  Si recuerda el FSE, entonces los intervalos generalmente se extendieron en todo el rango, como si un mezclador loco hubiera trabajado en ellos, y nada funcion√≥ =) <br><br>  Determinar el intervalo deseado no es dif√≠cil: dividir <b>x</b> entre <b>N</b> y caer en uno de los pares.  A continuaci√≥n, comparamos el resto de la divisi√≥n de <b>x% N</b> con el l√≠mite entre los segmentos en un par y cae en un intervalo o en otro. <br><br><h2>  Lo intentamos en la pr√°ctica </h2><br>  Usaremos el c√≥digo del <a href="">ejemplo terminado</a> . <br><br>  Tomamos los datos para la compresi√≥n del archivo: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> in_size; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* in_bytes = read_file(<span class="hljs-string"><span class="hljs-string">"book1"</span></span>, &amp;in_size);</code> </pre> <br>  <b>1.</b> Primero debe decidir sobre <b>la estructura de datos</b> . <br><br>  Usamos la opci√≥n m√°s simple: codificaremos un byte usando el alfabeto [0 ... 255]. <br><br>  <b>2.</b> El siguiente paso es determinar la <b>frecuencia de los caracteres del</b> alfabeto: <br><br>  (funci√≥n <code>stats.count_freqs</code> ) <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; in_size; i++) {   freqs[in_bytes[i]]++; }</code> </pre> <br>  <b>3.</b> Entonces, tenemos frecuencias de s√≠mbolos, pero ahora necesitamos <b>normalizarlas</b> , es decir, reducirlas (o aumentarlas) proporcionalmente para que en total obtengamos M = 2 ^ k.  Esta no es una tarea tan simple como podr√≠a parecer, por lo que utilizamos una funci√≥n preparada: <br><br><pre> <code class="plaintext hljs">stats.normalize_freqs(...);</code> </pre> <br>  Por cierto, debes determinar el valor de <b>k</b> .  Como nuestro alfabeto consta de 256 caracteres, no se deben tomar <b>k</b> menos de 8.  Primero, tome el m√°ximo - 16, y luego intente con otros valores. <br><br>  <b>4.</b> Construir <b>tabla de alias</b> : <br><br><pre> <code class="cpp hljs">stats.make_alias_table();</code> </pre> <br>  <b>5.</b> Codificamos <b>desde el final</b> , luego para decodificar en el orden normal. <br><br><pre> <code class="cpp hljs">RansState rans; <span class="hljs-comment"><span class="hljs-comment">//  rANS,    x RansEncInit(&amp;rans); //    uint8_t* ptr = out_buf + out_max_size; // *end* of output buffer for (size_t i = in_size; i &gt; 0; i--) { // NB: working in reverse!   int s = in_bytes[i - 1];   RansEncPutAlias(&amp;rans, &amp;ptr, &amp;stats, s, prob_bits); } //   .     . RansEncFlush(&amp;rans, &amp;ptr);</span></span></code> </pre> <br>  Adem√°s, el ejemplo por referencia decodifica datos comprimidos utilizando estad√≠sticas ya hechas.  En la vida real, para decodificar, debe guardar una tabla de frecuencias (estad√≠sticas) junto con datos comprimidos.  En el caso m√°s simple, tendr√° que gastar N * k bits en √©l. <br><br>  Como se prometi√≥ anteriormente, veamos los resultados de compresi√≥n para varios valores de k (en el c√≥digo es <code>prob_bits</code> ), teniendo en cuenta el aumento de tama√±o debido al registro de la tabla de frecuencias: <br><br>  ( <i>Tama√±o del</i> <i>archivo original del</i> <i>libro1</i> : 768771) <br>  k = 16: 435059 + 512 = 435571 bytes <br>  k = <b>15</b> : 435078 + 480 = <b>435558</b> bytes <br>  k = 14: 435113 + 448 = 435561 bytes <br>  k = 13: 435239 + 416 = 435655 bytes <br>  k = 12: 435603 + 384 = 435987 bytes <br>  k = 11: 436530 + 352 = 436882 bytes <br>  k = 10: 440895 + 320 = 441215 bytes <br>  k = 9: 453418 + 288 = 453706 bytes <br>  k = 8: 473126 + 256 = 473382 bytes <br><br>  Puede ver que cuanto mayor sea k, mejor ser√° la compresi√≥n.  Pero en cierto punto (en k = 16), la sobrecarga de la tabla de frecuencias comienza a superar los beneficios de aumentar la precisi√≥n.  Si comprime un archivo m√°s peque√±o, este efecto aparecer√° en k m√°s peque√±o. <br><br>  Tambi√©n debe decir algunas palabras sobre el truco llamado "rANS intercalados", que se implementa adicionalmente <a href="">en este ejemplo</a> .  La idea es que el uso alternativo de dos variables de estado independientes hace un mejor uso del paralelismo del procesador.  Como resultado, la decodificaci√≥n es a√∫n m√°s r√°pida. <br><br>  En conclusi√≥n, quiero se√±alar que el m√©todo de compresi√≥n de archivos seleccionado es demasiado simple.  No tiene en cuenta las caracter√≠sticas de los datos, por lo que la compresi√≥n dista mucho de ser √≥ptima.  Si observa de cerca la entrada, puede encontrar que algunas <i>combinaciones de letras</i> son m√°s comunes que otras, y algunas no ocurren en absoluto.  Usando este hecho, la compresi√≥n se puede mejorar significativamente.  Pero este es un tema para un art√≠culo separado. <br><br><h2>  Ep√≠logo </h2><br>  ¬øPor qu√© escribir su propio archivador cuando hay muchas utilidades probadas?  La respuesta es bastante simple: los archivadores adaptados a un formato espec√≠fico se comprimen mucho mejor. <br><br>  Cuando desarrollamos juegos en <b>Playrix</b> , a menudo confiamos en la necesidad de reducir el tama√±o de construcci√≥n.  Los juegos evolucionan constantemente, la cantidad de contenido est√° creciendo y el espacio es limitado. <br><br>  Una vez m√°s <s>,</s> mirando con <s>anhelo</s> los recursos, nos dimos cuenta de que algunos archivos se pueden comprimir mucho mejor que zip, dada su estructura.  Durante los experimentos, logramos reducir significativamente el tama√±o de nuestro propio formato de animaci√≥n, tambi√©n hay algunos cambios en la compresi√≥n de archivos gr√°ficos. <br><br>  Al desarrollar algoritmos de compresi√≥n, un codificador de entrop√≠a universal, como rANS o FSE, es una herramienta indispensable.  Asume completamente la tarea de escribir caracteres con el menor n√∫mero de bits, lo que permite al desarrollador centrarse en los detalles principales del algoritmo.  Y tambi√©n funciona muy r√°pido tanto en codificaci√≥n como en decodificaci√≥n. <br><br>  Espero que este art√≠culo te ayude a conocer RANS y comenzar a usarlo en tus proyectos. <br><br><h2>  Referencias </h2><br>  Aqu√≠ puede ver ejemplos de trabajo de implementaci√≥n de rANS (con diferentes opciones de optimizaci√≥n): <br><br>  Fabian Giesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/rygorous/ryg_rans</a> <br><br>  Puede leer detalles interesantes y detalles en el blog de Fabian (en ingl√©s): <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">notas RANS</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RANS con distribuciones de probabilidad est√°ticas</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RANS en la pr√°ctica</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441814/">https://habr.com/ru/post/441814/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441804/index.html">¬øD√≥nde ense√±ar programaci√≥n infantil?</a></li>
<li><a href="../441806/index.html">VPN sin VPN o una historia sobre el uso no convencional de SSH</a></li>
<li><a href="../441808/index.html">Te invitamos el 6 de marzo a ElixirLangMoscow Meetup # 9</a></li>
<li><a href="../441810/index.html">Eclipse para microcontroladores (STM32) + FreeRTOS Task Aware Debugger</a></li>
<li><a href="../441812/index.html">Ir a Meetup en vivo en Acronis</a></li>
<li><a href="../441816/index.html">Las autoridades francesas multaron al banco UBS con $ 4 mil millones por ayudar a los clientes a evitar impuestos</a></li>
<li><a href="../441818/index.html">Rendimiento equilibrado del sitio. Parte 2: optimizaci√≥n t√©cnica</a></li>
<li><a href="../441820/index.html">Devoci√≥n de horror eliminada de Steam: la causa nuevamente es Winnie the Pooh, Xi Jinping y la ira de China por connotaciones pol√≠ticas</a></li>
<li><a href="../441824/index.html">Manejo de incendios como parte del trabajo del l√≠der</a></li>
<li><a href="../441826/index.html">Lo que est√° sucediendo en el mercado de transmisi√≥n de audio: discutiendo el desarrollo de plataformas de transmisi√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>