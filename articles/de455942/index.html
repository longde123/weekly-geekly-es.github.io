<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗒️ 🌰 👨🏻‍🚀 Protokoll für die Kommunikation zwischen iframe und Hauptbrowserfenster ☄️ 🤱🏿 👩🏼‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Entwickler müssen regelmäßig die Kommunikation zwischen mehreren Browser-Registerkarten herstellen: die Möglichkeit, Nachrichten von einem zum a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protokoll für die Kommunikation zwischen iframe und Hauptbrowserfenster</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/455942/"><p>  Viele Entwickler müssen regelmäßig die Kommunikation zwischen mehreren Browser-Registerkarten herstellen: die Möglichkeit, Nachrichten von einem zum anderen zu senden und eine Antwort zu erhalten.  Eine solche Aufgabe stellte sich vor uns. </p><br><p>  Es gibt Standardlösungen wie BroadcastChannel, aber die Browserunterstützung lässt jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu wünschen übrig</a> . Deshalb haben wir uns entschlossen, unsere Bibliothek zu implementieren.  Als die Bibliothek fertig war, stellte sich heraus, dass diese Funktionalität nicht mehr benötigt wurde, aber eine andere Aufgabe erschien: Es war notwendig, zwischen dem Iframe und dem Hauptfenster zu kommunizieren. </p><br><p>  Bei näherer Betrachtung stellte sich heraus, dass zwei Drittel der Bibliothek nicht gleichzeitig geändert werden können. Sie müssen den Code nur ein wenig umgestalten.  Die Bibliothek ist eher ein Kommunikationsprotokoll, das mit Textdaten arbeiten kann.  Es kann in allen Fällen verwendet werden, wenn es möglich ist, Text zu übertragen (iframe, window.open, worker, Browser-Registerkarten, WebSocket). </p><br><h2 id="kak-eto-rabotaet">  Wie funktioniert es? </h2><br><p>  Derzeit hat das Protokoll zwei Funktionen: Senden einer Nachricht und Abonnieren von Ereignissen.  Jede Nachricht im Protokoll ist ein Objekt mit Daten.  Das Hauptfeld dieses Objekts ist das <strong>Typfeld</strong> , das uns sagt, um welche Art von Nachricht es sich handelt.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typfeld</a> ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufzählung</a> mit Werten: </p><a name="habracut"></a><br><ul><li>  0 - Nachricht senden </li><li>  1 - Anfrage senden </li><li>  2 - eine Antwort erhalten. </li></ul><br><h3 id="otpravka-soobscheniya">  Nachrichten senden </h3><br><p>  Das Senden einer Nachricht <strong>bedeutet keine</strong> Antwort.  Um ein Ereignis zu senden, erstellen wir ein Objekt mit Feldern: </p><br><ul><li>  <strong>Typ</strong> - Ereignistyp 0 </li><li>  <strong>name</strong> - Name des Benutzerereignisses </li><li>  <strong>Daten</strong> - Benutzerdaten (JSON-ähnlich). </li></ul><br><p>  Wenn wir auf der anderen Seite eine Nachricht mit dem Feld <strong>Typ</strong> = 0 erhalten, wissen wir, dass dies ein Ereignis ist und dass es einen Ereignisnamen und Daten gibt.  Alles, was bleibt, ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auslösen</a> des Ereignisses (ein fast reguläres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EventEmitter-</a> Muster). </p><br><p>  Schema der Arbeit mit Veranstaltungen: </p><br><p><img src="https://habrastorage.org/webt/rs/ca/py/rscapy4jhbddmpzbztk4crk9sd0.png"></p><br><h3 id="otpravka-zaprosa">  Einreichung anfordern </h3><br><p>  Das Senden einer Anforderung impliziert, dass eine Anforderungs-ID in der Bibliothek generiert wird. Die Bibliothek wartet auf eine Antwort mit dieser ID. Nach einem erfolgreichen Antwortdienst werden Felder daraus gelöscht und die Antwort an den Benutzer zurückgegeben.  Außerdem können Sie die maximale Antwortzeit festlegen. </p><br><p><img src="https://habrastorage.org/webt/cb/0a/sa/cb0asaefngtcodhbgz0uwacrakm.png"></p><br><p>  Mit der Anfrage ist alles etwas komplizierter.  Um auf eine Anfrage zu antworten, müssen Sie Methoden deklarieren, die in unserem Protokoll verfügbar sind.  Dies erfolgt mit der Methode <strong>registerRequestHandler</strong> .  Es akzeptiert den Namen der Anfrage, auf die es antworten wird, und die Funktion, die die Antwort zurückgibt.  Zum Erstellen einer Anforderung benötigen wir eine <strong>ID</strong> . Im Allgemeinen können Sie einen <strong>Zeitstempel verwenden</strong> . Das Debuggen ist jedoch sehr unpraktisch.  Daher ist dies die <strong>ID der</strong> Klasse, die die Anforderung + Seriennummer der Anforderung + Zeichenfolgenkonstante sendet.  Als nächstes konstruieren wir ein Objekt mit den Feldern <strong>id</strong> , <strong>type</strong> - mit dem Wert 1, <strong>name</strong> - dem Namen der Anfrage, <strong>data</strong> - user data (JSON-like). </p><br><p>  Nach Erhalt der Anfrage prüfen wir, ob wir eine API haben, um auf diese Anfrage zu antworten. Wenn keine API vorhanden ist, geben wir einen Fehler zurück.  Wenn es eine API gibt, geben wir das Ergebnis der Funktion von <strong>registerRequestHandler</strong> mit dem entsprechenden Anforderungsnamen zurück. </p><br><p>  Für die Antwort wird ein Objekt mit Typfeldern gebildet - mit dem Wert 2, <strong>ID</strong> - ID der Nachricht, auf die wir antworten, <strong>Status</strong> - ein Feld, das angibt, ob diese Antwort ein Fehler ist (wenn keine API vorhanden ist oder beim Benutzerexit ein Fehler aufgetreten ist oder der Benutzer das abgelehnte Versprechen zurückgegeben hat). andere Fehler (serialisieren)), <strong>Inhalt</strong> - Antwortdaten. </p><br><p>  Daher haben wir die Funktionsweise des Protokolls selbst beschrieben, das die <strong>Busklasse</strong> implementiert, aber nicht beschrieben, wie Nachrichten tatsächlich gesendet und empfangen werden.  Dafür benötigen wir Adapter - eine Klasse mit 3 Methoden: </p><br><ul><li>  <strong>send</strong> - eine Methode, die tatsächlich für das Senden einer Nachricht verantwortlich ist </li><li>  <strong>addListener</strong> - eine Methode zum Abonnieren von Ereignissen </li><li>  <strong>zerstören</strong> - um Abonnements zu zerstören, wenn Bus zerstört wird. </li></ul><br><h3 id="adaptery-realizaciya-protokola">  Adapter  Protokollimplementierung. </h3><br><p>  Zu Beginn ist derzeit nur der Adapter für die Arbeit mit iframe / window bereit.  Es funktioniert mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">postMessage</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">addEventListener</a> .  Hier ist alles ganz einfach: Sie müssen eine Nachricht mit dem richtigen <strong>Ursprung</strong> an <strong>postMessage</strong> senden und Nachrichten über <strong>addEventListener</strong> für das Ereignis "message" abhören. </p><br><p>  Kleine Feinheiten, auf die wir gestoßen sind: </p><br><ul><li>  Sie sollten immer auf die Antworten in IHREM Fenster hören und sie an eine andere Person senden (Iframe, Opener, Eltern, Arbeiter, ...). <br>  Tatsache ist, dass beim Versuch, eine Nachricht im Fenster einer anderen Person abzuhören, ein Fehler auftritt, wenn der Ursprung vom aktuellen abweicht. </li><li>  Wenn Sie eine Nachricht erhalten, stellen Sie sicher, dass sie an Sie gesendet wird (eine Reihe von Nachrichten aus der Analyse werden im Fenster ausgelöst). <br>  WebStrom (falls Sie es verwenden), fremde Iframes, daher sollten Sie sicherstellen, dass das Ereignis in unserem Protokoll und für uns enthalten ist. </li><li>  Sie können <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Promise nicht</a></strong> mit einer Instanz von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Window zurückgeben</a> , da <strong>Promise</strong> bei der Rückgabe des Ergebnisses versucht zu überprüfen, ob das Ergebnis eine <strong>then-</strong> Methode hat. Wenn Sie keinen Zugriff auf das Fenster haben (z. B. ein Fenster mit einem anderen Ursprung), tritt ein Fehler auf (obwohl dies nicht in allen Browsern der Fall ist) )  Um dieses Problem zu vermeiden, wickeln Sie das Fenster einfach in ein Objekt ein und fügen Sie das <strong>Promise-</strong> Objekt ein, in dem sich ein Link zum gewünschten Fenster befindet. </li></ul><br><h3 id="primery-ispolzovaniya">  Anwendungsbeispiele: </h3><br><p>  Die Bibliothek kann mit Ihrem bevorzugten Paketmanager installiert werden - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ wells / wave-browser-bus</a> </p><br><p>  Um eine bidirektionale Kommunikation mit einem Iframe herzustellen, schreiben Sie einfach den Code: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Bus, WindowAdapter } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-browser-bus'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://some-iframe-content-url.com'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iframe = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'iframe'</span></span>); WindowAdapter.createSimpleWindowAdapter(iframe).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">adapter</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bus(adapter); bus.once(<span class="hljs-string"><span class="hljs-string">'ready'</span></span>, () =&gt; { <span class="hljs-comment"><span class="hljs-comment">//    iframe }); }); iframe.src = url; //   url   WindowAdapter.createSimpleWindowAdapter document.body.appendChild(iframe);</span></span></code> </pre> <br><p>  Und im Iframe: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Bus, WindowAdapter } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-browser-bus'</span></span>; WindowAdapter.createSimpleWindowAdapter().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">adapter</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bus(adapter); bus.dispatchEvent(<span class="hljs-string"><span class="hljs-string">'ready'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      });</span></span></code> </pre> <br><h2 id="chto-dalshe">  Was weiter? </h2><br><p>  Es stellte sich ein flexibles und universelles Protokoll heraus, das in jeder Situation verwendet werden kann. <br>  Jetzt plane ich, die Adapter vom Protokoll zu trennen und sie in separate npm-Pakete zu packen. Fügen Sie Adapter für die Arbeit mit Worker- und Browser-Registerkarten hinzu.  Ich möchte Adapter schreiben, die das Protokoll für alle anderen Anforderungen implementieren, es war so einfach wie möglich. </p><br><p>  Wenn Sie sich der Entwicklung oder den Ideen zur Funktionalität der Bibliothek anschließen möchten, sind Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> willkommen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455942/">https://habr.com/ru/post/de455942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455932/index.html">Wie wir einen coolen Weg gefunden haben, um Business und DevOps zu verbinden</a></li>
<li><a href="../de455934/index.html">Übertragen Sie Sicherungsdaten einer neuen Version von MS SQL Server auf eine ältere Version</a></li>
<li><a href="../de455936/index.html">Der Vater von Free Software, Richard Stallman, kommt nach Russland. Wir suchen jemanden, der bereit ist, ihn für ein paar Tage zu beschützen</a></li>
<li><a href="../de455938/index.html">Ist hochwertige Software die Kosten ihrer Entwicklung wert?</a></li>
<li><a href="../de455940/index.html">QVD-Dateien - was ist drin, Teil 2</a></li>
<li><a href="../de455944/index.html">Arbeiten Sie mit Freiberuflern. Sich fortbewegen lernen</a></li>
<li><a href="../de455948/index.html">RAMBleed: Ruft in 34 Stunden einen RSA-Schlüssel ab</a></li>
<li><a href="../de455950/index.html">Die seltensten und teuersten Programmiersprachen. Teil II</a></li>
<li><a href="../de455952/index.html">Codegenerierung mit Roslyn</a></li>
<li><a href="../de455954/index.html">Nutzung und Schutz des Erbes in der modernen Welt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>