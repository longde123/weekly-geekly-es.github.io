<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóíÔ∏è üå∞ üë®üèª‚ÄçüöÄ Protokoll f√ºr die Kommunikation zwischen iframe und Hauptbrowserfenster ‚òÑÔ∏è ü§±üèø üë©üèº‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Entwickler m√ºssen regelm√§√üig die Kommunikation zwischen mehreren Browser-Registerkarten herstellen: die M√∂glichkeit, Nachrichten von einem zum a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protokoll f√ºr die Kommunikation zwischen iframe und Hauptbrowserfenster</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/455942/"><p>  Viele Entwickler m√ºssen regelm√§√üig die Kommunikation zwischen mehreren Browser-Registerkarten herstellen: die M√∂glichkeit, Nachrichten von einem zum anderen zu senden und eine Antwort zu erhalten.  Eine solche Aufgabe stellte sich vor uns. </p><br><p>  Es gibt Standardl√∂sungen wie BroadcastChannel, aber die Browserunterst√ºtzung l√§sst jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu w√ºnschen √ºbrig</a> . Deshalb haben wir uns entschlossen, unsere Bibliothek zu implementieren.  Als die Bibliothek fertig war, stellte sich heraus, dass diese Funktionalit√§t nicht mehr ben√∂tigt wurde, aber eine andere Aufgabe erschien: Es war notwendig, zwischen dem Iframe und dem Hauptfenster zu kommunizieren. </p><br><p>  Bei n√§herer Betrachtung stellte sich heraus, dass zwei Drittel der Bibliothek nicht gleichzeitig ge√§ndert werden k√∂nnen. Sie m√ºssen den Code nur ein wenig umgestalten.  Die Bibliothek ist eher ein Kommunikationsprotokoll, das mit Textdaten arbeiten kann.  Es kann in allen F√§llen verwendet werden, wenn es m√∂glich ist, Text zu √ºbertragen (iframe, window.open, worker, Browser-Registerkarten, WebSocket). </p><br><h2 id="kak-eto-rabotaet">  Wie funktioniert es? </h2><br><p>  Derzeit hat das Protokoll zwei Funktionen: Senden einer Nachricht und Abonnieren von Ereignissen.  Jede Nachricht im Protokoll ist ein Objekt mit Daten.  Das Hauptfeld dieses Objekts ist das <strong>Typfeld</strong> , das uns sagt, um welche Art von Nachricht es sich handelt.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typfeld</a> ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufz√§hlung</a> mit Werten: </p><a name="habracut"></a><br><ul><li>  0 - Nachricht senden </li><li>  1 - Anfrage senden </li><li>  2 - eine Antwort erhalten. </li></ul><br><h3 id="otpravka-soobscheniya">  Nachrichten senden </h3><br><p>  Das Senden einer Nachricht <strong>bedeutet keine</strong> Antwort.  Um ein Ereignis zu senden, erstellen wir ein Objekt mit Feldern: </p><br><ul><li>  <strong>Typ</strong> - Ereignistyp 0 </li><li>  <strong>name</strong> - Name des Benutzerereignisses </li><li>  <strong>Daten</strong> - Benutzerdaten (JSON-√§hnlich). </li></ul><br><p>  Wenn wir auf der anderen Seite eine Nachricht mit dem Feld <strong>Typ</strong> = 0 erhalten, wissen wir, dass dies ein Ereignis ist und dass es einen Ereignisnamen und Daten gibt.  Alles, was bleibt, ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausl√∂sen</a> des Ereignisses (ein fast regul√§res <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EventEmitter-</a> Muster). </p><br><p>  Schema der Arbeit mit Veranstaltungen: </p><br><p><img src="https://habrastorage.org/webt/rs/ca/py/rscapy4jhbddmpzbztk4crk9sd0.png"></p><br><h3 id="otpravka-zaprosa">  Einreichung anfordern </h3><br><p>  Das Senden einer Anforderung impliziert, dass eine Anforderungs-ID in der Bibliothek generiert wird. Die Bibliothek wartet auf eine Antwort mit dieser ID. Nach einem erfolgreichen Antwortdienst werden Felder daraus gel√∂scht und die Antwort an den Benutzer zur√ºckgegeben.  Au√üerdem k√∂nnen Sie die maximale Antwortzeit festlegen. </p><br><p><img src="https://habrastorage.org/webt/cb/0a/sa/cb0asaefngtcodhbgz0uwacrakm.png"></p><br><p>  Mit der Anfrage ist alles etwas komplizierter.  Um auf eine Anfrage zu antworten, m√ºssen Sie Methoden deklarieren, die in unserem Protokoll verf√ºgbar sind.  Dies erfolgt mit der Methode <strong>registerRequestHandler</strong> .  Es akzeptiert den Namen der Anfrage, auf die es antworten wird, und die Funktion, die die Antwort zur√ºckgibt.  Zum Erstellen einer Anforderung ben√∂tigen wir eine <strong>ID</strong> . Im Allgemeinen k√∂nnen Sie einen <strong>Zeitstempel verwenden</strong> . Das Debuggen ist jedoch sehr unpraktisch.  Daher ist dies die <strong>ID der</strong> Klasse, die die Anforderung + Seriennummer der Anforderung + Zeichenfolgenkonstante sendet.  Als n√§chstes konstruieren wir ein Objekt mit den Feldern <strong>id</strong> , <strong>type</strong> - mit dem Wert 1, <strong>name</strong> - dem Namen der Anfrage, <strong>data</strong> - user data (JSON-like). </p><br><p>  Nach Erhalt der Anfrage pr√ºfen wir, ob wir eine API haben, um auf diese Anfrage zu antworten. Wenn keine API vorhanden ist, geben wir einen Fehler zur√ºck.  Wenn es eine API gibt, geben wir das Ergebnis der Funktion von <strong>registerRequestHandler</strong> mit dem entsprechenden Anforderungsnamen zur√ºck. </p><br><p>  F√ºr die Antwort wird ein Objekt mit Typfeldern gebildet - mit dem Wert 2, <strong>ID</strong> - ID der Nachricht, auf die wir antworten, <strong>Status</strong> - ein Feld, das angibt, ob diese Antwort ein Fehler ist (wenn keine API vorhanden ist oder beim Benutzerexit ein Fehler aufgetreten ist oder der Benutzer das abgelehnte Versprechen zur√ºckgegeben hat). andere Fehler (serialisieren)), <strong>Inhalt</strong> - Antwortdaten. </p><br><p>  Daher haben wir die Funktionsweise des Protokolls selbst beschrieben, das die <strong>Busklasse</strong> implementiert, aber nicht beschrieben, wie Nachrichten tats√§chlich gesendet und empfangen werden.  Daf√ºr ben√∂tigen wir Adapter - eine Klasse mit 3 Methoden: </p><br><ul><li>  <strong>send</strong> - eine Methode, die tats√§chlich f√ºr das Senden einer Nachricht verantwortlich ist </li><li>  <strong>addListener</strong> - eine Methode zum Abonnieren von Ereignissen </li><li>  <strong>zerst√∂ren</strong> - um Abonnements zu zerst√∂ren, wenn Bus zerst√∂rt wird. </li></ul><br><h3 id="adaptery-realizaciya-protokola">  Adapter  Protokollimplementierung. </h3><br><p>  Zu Beginn ist derzeit nur der Adapter f√ºr die Arbeit mit iframe / window bereit.  Es funktioniert mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">postMessage</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">addEventListener</a> .  Hier ist alles ganz einfach: Sie m√ºssen eine Nachricht mit dem richtigen <strong>Ursprung</strong> an <strong>postMessage</strong> senden und Nachrichten √ºber <strong>addEventListener</strong> f√ºr das Ereignis "message" abh√∂ren. </p><br><p>  Kleine Feinheiten, auf die wir gesto√üen sind: </p><br><ul><li>  Sie sollten immer auf die Antworten in IHREM Fenster h√∂ren und sie an eine andere Person senden (Iframe, Opener, Eltern, Arbeiter, ...). <br>  Tatsache ist, dass beim Versuch, eine Nachricht im Fenster einer anderen Person abzuh√∂ren, ein Fehler auftritt, wenn der Ursprung vom aktuellen abweicht. </li><li>  Wenn Sie eine Nachricht erhalten, stellen Sie sicher, dass sie an Sie gesendet wird (eine Reihe von Nachrichten aus der Analyse werden im Fenster ausgel√∂st). <br>  WebStrom (falls Sie es verwenden), fremde Iframes, daher sollten Sie sicherstellen, dass das Ereignis in unserem Protokoll und f√ºr uns enthalten ist. </li><li>  Sie k√∂nnen <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Promise nicht</a></strong> mit einer Instanz von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Window zur√ºckgeben</a> , da <strong>Promise</strong> bei der R√ºckgabe des Ergebnisses versucht zu √ºberpr√ºfen, ob das Ergebnis eine <strong>then-</strong> Methode hat. Wenn Sie keinen Zugriff auf das Fenster haben (z. B. ein Fenster mit einem anderen Ursprung), tritt ein Fehler auf (obwohl dies nicht in allen Browsern der Fall ist) )  Um dieses Problem zu vermeiden, wickeln Sie das Fenster einfach in ein Objekt ein und f√ºgen Sie das <strong>Promise-</strong> Objekt ein, in dem sich ein Link zum gew√ºnschten Fenster befindet. </li></ul><br><h3 id="primery-ispolzovaniya">  Anwendungsbeispiele: </h3><br><p>  Die Bibliothek kann mit Ihrem bevorzugten Paketmanager installiert werden - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ wells / wave-browser-bus</a> </p><br><p>  Um eine bidirektionale Kommunikation mit einem Iframe herzustellen, schreiben Sie einfach den Code: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Bus, WindowAdapter } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-browser-bus'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://some-iframe-content-url.com'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iframe = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'iframe'</span></span>); WindowAdapter.createSimpleWindowAdapter(iframe).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">adapter</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bus(adapter); bus.once(<span class="hljs-string"><span class="hljs-string">'ready'</span></span>, () =&gt; { <span class="hljs-comment"><span class="hljs-comment">//    iframe }); }); iframe.src = url; //   url   WindowAdapter.createSimpleWindowAdapter document.body.appendChild(iframe);</span></span></code> </pre> <br><p>  Und im Iframe: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Bus, WindowAdapter } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-browser-bus'</span></span>; WindowAdapter.createSimpleWindowAdapter().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">adapter</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bus(adapter); bus.dispatchEvent(<span class="hljs-string"><span class="hljs-string">'ready'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      });</span></span></code> </pre> <br><h2 id="chto-dalshe">  Was weiter? </h2><br><p>  Es stellte sich ein flexibles und universelles Protokoll heraus, das in jeder Situation verwendet werden kann. <br>  Jetzt plane ich, die Adapter vom Protokoll zu trennen und sie in separate npm-Pakete zu packen. F√ºgen Sie Adapter f√ºr die Arbeit mit Worker- und Browser-Registerkarten hinzu.  Ich m√∂chte Adapter schreiben, die das Protokoll f√ºr alle anderen Anforderungen implementieren, es war so einfach wie m√∂glich. </p><br><p>  Wenn Sie sich der Entwicklung oder den Ideen zur Funktionalit√§t der Bibliothek anschlie√üen m√∂chten, sind Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> willkommen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455942/">https://habr.com/ru/post/de455942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455932/index.html">Wie wir einen coolen Weg gefunden haben, um Business und DevOps zu verbinden</a></li>
<li><a href="../de455934/index.html">√úbertragen Sie Sicherungsdaten einer neuen Version von MS SQL Server auf eine √§ltere Version</a></li>
<li><a href="../de455936/index.html">Der Vater von Free Software, Richard Stallman, kommt nach Russland. Wir suchen jemanden, der bereit ist, ihn f√ºr ein paar Tage zu besch√ºtzen</a></li>
<li><a href="../de455938/index.html">Ist hochwertige Software die Kosten ihrer Entwicklung wert?</a></li>
<li><a href="../de455940/index.html">QVD-Dateien - was ist drin, Teil 2</a></li>
<li><a href="../de455944/index.html">Arbeiten Sie mit Freiberuflern. Sich fortbewegen lernen</a></li>
<li><a href="../de455948/index.html">RAMBleed: Ruft in 34 Stunden einen RSA-Schl√ºssel ab</a></li>
<li><a href="../de455950/index.html">Die seltensten und teuersten Programmiersprachen. Teil II</a></li>
<li><a href="../de455952/index.html">Codegenerierung mit Roslyn</a></li>
<li><a href="../de455954/index.html">Nutzung und Schutz des Erbes in der modernen Welt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>