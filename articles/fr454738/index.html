<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÑÔ∏è ü§òüèæ üöª Prise en charge de Visual Studio 2019 dans PVS-Studio üòØ üèπ ‚öìÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La prise en charge de Visual Studio 2019 dans PVS-Studio a imm√©diatement affect√© plusieurs composants diff√©rents: le plug-in IDE lui-m√™me, l'applicati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prise en charge de Visual Studio 2019 dans PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/454738/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/aea/16e/de3aea16e3b6472a4d5034fd035d8827.png"></div><br>  La prise en charge de Visual Studio 2019 dans PVS-Studio a imm√©diatement affect√© plusieurs composants diff√©rents: le plug-in IDE lui-m√™me, l'application d'analyse de ligne de commande, les analyseurs C ++ et C #, ainsi que plusieurs utilitaires.  Je vais bri√®vement parler des probl√®mes que nous avons rencontr√©s lors de la prise en charge de la nouvelle version de l'IDE et comment les r√©soudre. <br><a name="habracut"></a><br>  Avant de commencer, je voudrais revenir un peu en arri√®re pour retracer l'historique de prise en charge des versions pr√©c√©dentes de Visual Studio, ce qui permettra de mieux comprendre notre vision de la t√¢che et les d√©cisions prises dans certaines situations. <br><br>  √Ä partir de la premi√®re version de l'analyseur PVS-Studio, dans laquelle un plug-in pour l'environnement Visual Studio est apparu (il s'agissait √©galement d'une version de Visual Studio 2005), la prise en charge de nouvelles versions de Visual Studio √©tait une t√¢che assez simple pour nous - cela se r√©sumait essentiellement √† la mise √† jour du fichier de projet de plug-in d√©pendances de diverses API d'extension Visual Studio.  Parfois, il √©tait n√©cessaire de prendre en charge en outre de nouvelles fonctionnalit√©s du langage C ++, que le compilateur Visual C ++ apprenait progressivement, mais cela ne causait g√©n√©ralement pas de probl√®mes imm√©diatement avant la sortie de la prochaine √©dition de Visual Studio.  Et il n'y avait alors qu'un seul analyseur dans PVS-Studio - pour les langages C et C ++. <br><br>  Tout a chang√© pour la sortie de Visual Studio 2017. En plus du fait que de nombreuses API d'extension pour cet IDE ont chang√© de mani√®re tr√®s significative dans cette version, apr√®s la mise √† jour, nous avons rencontr√© des probl√®mes pour assurer la compatibilit√© descendante du travail du nouvel analyseur C # qui √©tait apparu √† ce moment-l√† (ainsi que notre nouvelle couche C ++ analyseur pour les projets MSBuild) avec les anciennes versions de MSBuild \ Visual Studio. <br><br>  Par cons√©quent, avant de lire cet article, je vous recommande fortement de lire l'article connexe sur la prise en charge de Visual Studio 2017: "Prise en charge de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visual Studio 2017 et Roslyn 2.0 dans PVS-Studio: parfois, l'utilisation de solutions pr√™tes √† l'emploi n'est pas aussi simple qu'il y para√Æt √† premi√®re vue</a> ."  L'article mentionn√© ci-dessus d√©crit les probl√®mes que nous avons rencontr√©s la derni√®re fois, ainsi que les sch√©mas d'interaction de divers composants (par exemple, PVS-Studio, MSBuild, Roslyn).  Comprendre cette interaction sera utile lors de la lecture de cet article. <br><br>  En fin de compte, la solution √† ces probl√®mes a apport√© des changements importants √† notre analyseur et, comme nous l'esp√©rions, les nouvelles approches que nous avons ensuite appliqu√©es permettront de prendre en charge les versions mises √† jour de Visual Studio \ MSBuild beaucoup plus facilement et plus rapidement √† l'avenir.  En partie, cette hypoth√®se a d√©j√† √©t√© confirm√©e par la publication de nombreuses mises √† jour de Visual Studio 2017. Cette nouvelle approche a-t-elle aid√© √† prendre en charge Visual Studio 2019?  √Ä ce sujet ci-dessous. <br><br><h2>  Plugin PVS-Studio pour Visual Studio 2019 </h2><br>  Tout a commenc√©, semble-t-il, pas mal.  Il √©tait assez facile de porter le plug-in vers Visual Studio 2019, o√π il a d√©marr√© et a bien fonctionn√©.  Malgr√© cela, 2 probl√®mes ont √©t√© imm√©diatement r√©v√©l√©s, ce qui promettait de futurs probl√®mes. <br><br>  La premi√®re est l'interface <i>IVsSolutionWorkspaceService</i> , utilis√©e pour prendre en charge le mode Lightweight Solution Load, qui, soit dit en passant, a √©t√© d√©sactiv√© dans l'une des mises √† jour pr√©c√©dentes de Visual Studio 2017, a √©t√© d√©cor√© avec l'attribut <i>obsol√®te</i> , qui n'√©tait qu'un avertissement lors de l'assemblage, mais il a promis plus √† l'avenir probl√®mes.  Microsoft a rapidement introduit ce mode et l'a abandonn√© ... Nous avons trait√© ce probl√®me tout simplement - refus√© d'utiliser l'interface appropri√©e. <br><br>  La seconde - lors du chargement de Visual Studio avec le plug-in, le message suivant est apparu: <i>Visual Studio a d√©tect√© une ou plusieurs extensions √† risque ou ne fonctionnant pas dans une mise √† jour VS de fonctionnalit√©.</i> <br><br>  La visualisation des journaux de d√©marrage de Visual Studio (fichier ActivityLog) a finalement point√© le ¬´i¬ª: <br><br>  <i>Avertissement: l'extension ¬´PVS-Studio¬ª utilise la fonction ¬´chargement automatique synchrone¬ª de Visual Studio.</i>  <i>Cette fonctionnalit√© ne sera plus prise en charge dans une future mise √† jour de Visual Studio 2019, auquel cas cette extension ne fonctionnera pas.</i>  <i>Veuillez contacter le fournisseur d'extensions pour obtenir une mise √† jour.</i> <br><br>  Pour nous, cela signifiait une chose - changer la fa√ßon dont le plug-in est charg√© en mode asynchrone.  J'esp√®re que vous ne serez pas contrari√© si je ne vous surcharge pas de d√©tails sur l'interaction avec les interfaces COM de Visual Studio, et je passerai en revue les modifications assez bri√®vement. <br><br>  Microsoft a un article sur la cr√©ation de plugins charg√©s de mani√®re asynchrone: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment: utiliser AsyncPackage pour charger des VSPackages en arri√®re-plan</a> ".  Dans le m√™me temps, il √©tait √©vident pour tout le monde que la question ne se limiterait pas √† ces changements. <br><br>  L'un des principaux changements est la m√©thode de chargement, ou plut√¥t d'initialisation.  Auparavant, l'initialisation n√©cessaire avait lieu dans deux m√©thodes - la m√©thode <i>Initialize</i> substitu√©e de notre classe <i>Package</i> et la m√©thode <i>OnShellPropertyChange</i> .  La n√©cessit√© de transf√©rer une partie de la logique vers la m√©thode <i>OnShellPropertyChange</i> est due au fait que lorsque le plug-in est charg√© de mani√®re synchrone, Visual Studio peut ne pas encore √™tre enti√®rement charg√© et initialis√©, et par cons√©quent, toutes les actions n√©cessaires n'ont pas pu √™tre effectu√©es √† l'√©tape d'initialisation du plug-in.  Une option pour r√©soudre ce probl√®me consiste √† attendre que Visual Studio quitte l'√©tat ¬´zombie¬ª et √† retarder ces actions.  C'est la logique et a √©t√© rendue dans <i>OnShellPropertyChange</i> avec une v√©rification de l'√©tat ¬´zombie¬ª. <br><br>  Dans la classe abstraite <i>AsyncPackage</i> , dont les plug-ins charg√©s de mani√®re asynchrone sont h√©rit√©s, la m√©thode <i>Initialize</i> a un modificateur <i>scell√©</i> , donc l'initialisation doit √™tre effectu√©e dans la m√©thode <i>InitializeAsync</i> red√©finie, qui a √©t√© effectu√©e.  Nous avons √©galement d√ª changer la logique du suivi de l'√©tat ¬´zombie¬ª de Visual Studio, car nous avons cess√© de recevoir ces informations dans le plugin.  Cependant, un certain nombre d'actions qui devaient √™tre effectu√©es apr√®s l'initialisation du plugin n'ont pas disparu.  La <i>solution a</i> √©t√© d'utiliser la m√©thode <i>OnPackageLoaded</i> de l'interface <i>IVsPackageLoadEvents</i> , o√π les actions n√©cessitant une ex√©cution diff√©r√©e ont √©t√© effectu√©es. <br><br>  Un autre probl√®me qui d√©coule logiquement du fait du chargement asynchrone du plug-in est le manque de commandes de plug-in PVS-Studio au moment du d√©marrage de Visual Studio.  Lorsque vous ouvrez le journal de l'analyseur en double-cliquant dans le gestionnaire de fichiers (si vous devez l'ouvrir via Visual Studio), la version n√©cessaire de devenv.exe a √©t√© lanc√©e avec la commande pour ouvrir le rapport de l'analyseur.  La commande de lancement ressemblait √† ceci: <br><br><pre><code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\Common7\IDE\devenv.exe"</span></span> /command <span class="hljs-string"><span class="hljs-string">"PVSStudio.OpenAnalysisReport C:\Users\vasiliev\source\repos\ConsoleApp\ConsoleApp.plog"</span></span></code> </pre> <br>  L'indicateur "/ command" ici est utilis√© pour appeler une commande enregistr√©e dans Visual Studio.  Cette approche ne fonctionnait plus, car les commandes n'√©taient pas disponibles avant le t√©l√©chargement du plug-in.  En cons√©quence, j'ai d√ª m'arr√™ter sur la ¬´b√©quille¬ª avec l'analyse de la ligne de lancement de devenv.exe apr√®s le chargement du plugin, et s'il y a une repr√©sentation sous forme de cha√Æne de la commande pour ouvrir le journal - en fait, le chargement du journal.  Ainsi, dans ce cas, ayant refus√© d'utiliser l'interface ¬´correcte¬ª pour travailler avec des commandes, il a √©t√© possible de maintenir les fonctionnalit√©s n√©cessaires en retardant le chargement du journal jusqu'√† ce que le plug-in soit compl√®tement charg√©. <br><br>  Fuh, il semble √™tre r√©gl√© et tout fonctionne - tout se charge et s'ouvre correctement, il n'y a pas d'avertissement - enfin. <br><br>  Et puis l'inattendu se produit - Pavel (bonjour!) Installe un plug-in, apr√®s quoi il demande pourquoi nous n'avons pas fait de chargement asynchrone? <br><br>  Dire que nous avons √©t√© surpris - ne rien dire - comment cela?  Non, vraiment - voici la nouvelle version du plugin install√©, voici le message que le package est t√©l√©chargeable de fa√ßon synchrone.  Nous installons avec Alexander (et bonjour √† vous aussi) la m√™me version du plugin sur nos machines - tout va bien.  Rien n'est clair - nous avons d√©cid√© de voir quelles versions des biblioth√®ques PVS-Studio √©taient charg√©es dans Visual Studio.  Et soudain, il s'av√®re que les versions des biblioth√®ques PVS-Studio pour Visual Studio 2017 sont utilis√©es, malgr√© le fait que la version correcte des biblioth√®ques se trouve dans le package VSIX - pour Visual Studio 2019. <br><br>  Apr√®s avoir bricol√© avec VSIXInstaller, j'ai r√©ussi √† trouver la cause du probl√®me - le cache du package.  La th√©orie a √©galement √©t√© confirm√©e par le fait que lors de la restriction des droits d'acc√®s au package dans le cache (C: \ ProgramData \ Microsoft \ VisualStudio \ Packages) VSIXInstaller a √©crit des informations d'erreur dans le journal.  √âtonnamment, s'il n'y a pas d'erreur, aucune information sur le fait que le package est install√© √† partir du cache n'est √©crite dans le journal. <br><br>  <b>Remarque</b>  En √©tudiant le comportement de VSIXInstaller et des biblioth√®ques associ√©es, il s'est dit qu'il est tr√®s cool que Roslyn et MSBuild aient un code open source qui facilite la lecture, le d√©bogage et le suivi de la logique de travail. <br><br>  En cons√©quence, les √©v√©nements suivants se sont produits - lors de l'installation du plug-in, VSIXInstaller a vu que le package correspondant √©tait d√©j√† dans le cache (il y avait un package .vsix pour Visual Studio 2017) et l'a utilis√© √† la place du package install√© lors de l'installation.  Pourquoi cela ne prend pas en compte les restrictions / exigences d√©crites dans .vsixmanifest (par exemple, la version de Visual Studio pour laquelle vous pouvez installer l'extension) est une question ouverte.  Pour cette raison, il s'est av√©r√© que bien que .vsixmanifest contienne les restrictions n√©cessaires, le plug-in con√ßu pour Visual Studio 2017 a √©t√© install√© sur Visual Studio 2019. <br><br>  Le pire, c'est qu'une telle installation a bris√© le graphique des d√©pendances de Visual Studio, et m√™me si ext√©rieurement il peut m√™me sembler que l'environnement de d√©veloppement fonctionnait bien, en fait tout √©tait tr√®s mauvais.  Il √©tait impossible d'installer et de d√©sinstaller des extensions, d'effectuer des mises √† jour, etc.  Le processus de ¬´r√©cup√©ration¬ª a √©galement √©t√© assez d√©sagr√©able, car  il √©tait n√©cessaire de supprimer l'extension (les fichiers correspondants), ainsi que de modifier manuellement les fichiers de configuration qui stockent des informations sur le package install√©.  En g√©n√©ral, ce n'est pas assez agr√©able. <br><br>  Pour r√©soudre ce probl√®me et √©viter des situations similaires √† l'avenir, il a √©t√© d√©cid√© de cr√©er un GUID pour le nouveau package afin de s√©parer exactement les packages Visual Studio 2017 et Visual Studio 2019 (il n'y a pas un tel probl√®me avec les anciens packages, et ils ont toujours utilis√© un GUID commun). <br><br>  Et comme nous parlions de surprises d√©sagr√©ables, je mentionnerai encore une chose: apr√®s la mise √† jour vers l'aper√ßu 2, l'√©l√©ment de menu a √©t√© "d√©plac√©" sous l'onglet "Extensions".  Il semblerait que ce soit correct, mais l'acc√®s aux fonctions du plugin est devenu moins pratique.  Sur les versions ult√©rieures de Visual Studio 2019, y compris la version finale, ce comportement a √©t√© conserv√©.  Je n'ai trouv√© aucune mention de cette ¬´fonctionnalit√©¬ª au moment de sa sortie dans la documentation ou le blog. <br><br>  Maintenant, il semblerait que tout fonctionne et que la prise en charge du plug-in pour Visual Studio 2019 est termin√©e.  Le lendemain de la sortie de PVS-Studio 7.02 avec prise en charge de Visual Studio 2019, il s'est av√©r√© que ce n'√©tait pas le cas - un autre probl√®me avec le plug-in asynchrone a √©t√© trouv√©.  Pour l'utilisateur, cela pourrait ressembler √† ceci: lors de l'ouverture d'une fen√™tre avec les r√©sultats de l'analyse (ou du d√©marrage de l'analyse), notre fen√™tre √©tait parfois affich√©e ¬´vide¬ª - elle ne contenait aucun contenu: boutons, tableau avec avertissements de l'analyseur, etc. <br><br>  En fait, ce probl√®me s'est parfois r√©p√©t√© au cours du travail.  Cependant, il n'a √©t√© r√©p√©t√© que sur une seule machine et n'a commenc√© √† appara√Ætre qu'apr√®s la mise √† jour de Visual Studio dans l'une des premi√®res versions de 'Preview' - il y avait des soup√ßons que quelque chose s'√©tait cass√© pendant l'installation / la mise √† jour.  Au fil du temps, cependant, le probl√®me a cess√© de se r√©p√©ter m√™me sur cette machine, et nous avons d√©cid√© qu'elle "se r√©parait d'elle-m√™me".  Il s'est av√©r√© que non - juste si chanceux.  Plus pr√©cis√©ment, pas de chance. <br><br>  La question s'est av√©r√©e √™tre dans l'ordre d'initialisation de la fen√™tre d'environnement elle-m√™me (le descendant de la classe <i>ToolWindowPane</i> ) et de son contenu (en fait, notre contr√¥le avec la grille et les boutons).  Dans certaines conditions, l'initialisation du contr√¥le a eu lieu avant l'initialisation du volet et malgr√© le fait que tout fonctionnait sans erreur, la m√©thode <i>FindToolWindowAsync</i> (cr√©ation d'une fen√™tre lors du premier appel) a fonctionn√© correctement, mais le contr√¥le est rest√© invisible.  Nous avons corrig√© cela en ajoutant une initialisation paresseuse pour notre contr√¥le au code de remplissage du volet. <br><br><h2>  Prise en charge C # 8.0 </h2><br>  L'utilisation de Roslyn comme base pour l'analyseur pr√©sente un avantage significatif - il n'est pas n√©cessaire de maintenir manuellement de nouvelles constructions de langage.  Tout cela est pris en charge et impl√©ment√© dans le cadre des biblioth√®ques Microsoft.CodeAnalysis - nous utilisons des r√©sultats pr√™ts √† l'emploi.  Ainsi, la prise en charge de la nouvelle syntaxe est impl√©ment√©e en mettant √† jour les biblioth√®ques. <br><br>  Bien s√ªr, en ce qui concerne l'analyse statique, ici, vous devez d√©j√† tout faire vous-m√™me, en particulier, pour traiter de nouvelles constructions de langage.  Oui, nous obtenons le nouvel arbre de syntaxe automatiquement en utilisant la version la plus r√©cente de Roslyn, mais nous devons enseigner √† l'analyseur comment percevoir et traiter les n≈ìuds nouveaux / modifi√©s de l'arbre. <br><br>  Je pense que l'innovation la plus parl√©e en C # 8 est les types de r√©f√©rence nullables.  Je n'√©crirai pas √† leur sujet ici - c'est un sujet assez vaste qui m√©rite un article s√©par√© (qui est d√©j√† en cours d'√©criture).  En g√©n√©ral, nous avons jusqu'√† pr√©sent d√©cid√© d'ignorer les annotations annulables dans notre m√©canisme de flux de donn√©es (c'est-√†-dire que nous les comprenons, les analysons et les ignorons).  Le fait est que malgr√© le type de r√©f√©rence non nullable de la variable, vous pouvez toujours y √©crire <i>null</i> tout simplement (ou par erreur), ce qui peut conduire √† NRE lors du d√©r√©f√©rencement du lien correspondant.  Dans ce cas, notre analyseur peut voir une erreur similaire et donner un avertissement sur l'utilisation d'une r√©f√©rence potentiellement nulle (bien s√ªr, s'il voit une telle affectation dans le code) malgr√© le type de r√©f√©rence non nul de la variable. <br><br>  Je veux noter que l'utilisation de types de r√©f√©rence nullables et la syntaxe qui l'accompagne ouvre la possibilit√© d'√©crire du code tr√®s int√©ressant.  Pour nous, nous avons appel√© cela la ¬´syntaxe √©motionnelle¬ª.  Le code ci-dessous se compile assez bien: <br><br><pre> <code class="cpp hljs">obj.Calculate(); obj?.Calculate(); obj.Calculate(); obj!?.Calculate(); obj!!!.Calculate();</code> </pre> <br>  Soit dit en passant, au cours de mon travail, j'ai trouv√© quelques fa√ßons de `` remplir '' Visual Studio en utilisant la nouvelle syntaxe.  Le fait est que vous ne pouvez pas limiter le nombre de caract√®res √† un lorsque vous mettez "!".  Autrement dit, vous pouvez √©crire non seulement un code du formulaire: <br><br><pre> <code class="cpp hljs">object temp = null!</code> </pre> <br>  mais aussi: <br><br><pre> <code class="cpp hljs">object temp = null!!!;</code> </pre> <br>  Vous pouvez pervertir, continuer et √©crire comme ceci: <br><br><pre> <code class="cpp hljs">object temp = null!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;</code> </pre> <br>  Ce code se compile avec succ√®s.  Mais si vous demandez des informations sur l'arborescence de syntaxe √† l'aide du visualiseur de syntaxe √† partir du SDK de la plateforme du compilateur .NET, Visual Studio se bloque. <br><br>  Vous pouvez obtenir des informations sur le probl√®me √† partir de l'Observateur d'√©v√©nements: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.28803</span></span><span class="hljs-number"><span class="hljs-number">.352</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5cc37012</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: WindowsBase.ni.dll, version: <span class="hljs-number"><span class="hljs-number">4.8</span></span><span class="hljs-number"><span class="hljs-number">.3745</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5c5bab63</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xc00000fd</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x000c9af4</span></span> Faulting process id: <span class="hljs-number"><span class="hljs-number">0x3274</span></span> Faulting application start time: <span class="hljs-number"><span class="hljs-number">0x01d5095e7259362e</span></span> Faulting application path: C:\<span class="hljs-function"><span class="hljs-function">Program </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Files</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x86)</span></span></span><span class="hljs-function">\ Microsoft Visual Studio\2019\Community\Common7\IDE\devenv.exe Faulting </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> path: C:\WINDOWS\assembly\NativeImages_v4.0.30319_32\ WindowsBase\4480dfedf0d7b4329838f4bbf953027d\WindowsBase.ni.dll Report Id: 66d41eb2-c658-486d-b417-02961d9c3e4f Faulting package full name: Faulting package-relative application ID:</span></span></code> </pre> <br>  Si vous allez plus loin et augmentez le nombre de points d'exclamation plusieurs fois, Visual Studio tombera de lui-m√™me - l'aide de Syntax Visualizer n'est plus n√©cessaire.  Les biblioth√®ques Microsoft.CodeAnalysis et le compilateur csc.exe ne dig√®rent pas non plus ce code. <br><br>  Bien s√ªr, ce sont des exemples synth√©tiques, mais ce fait m'a quand m√™me sembl√© dr√¥le. <br><br><h2>  Jeu d'outils </h2><br>  <b>Remarque</b>  Une fois de plus, je suis confront√© au probl√®me de traduire le mot ¬´√©valuation¬ª dans le contexte d'une conversation sur les projets MSBuild.  La traduction, qui semblait la plus proche en termes de sens et qui semblait en m√™me temps normale, √©tait ¬´construire un mod√®le de projet¬ª.  Si vous avez d'autres options de traduction - vous pouvez m'√©crire, ce sera int√©ressant √† lire. <br><br>  Il √©tait √©vident que la mise √† jour de l'ensemble d'outils serait la t√¢che la plus longue.  Plus pr√©cis√©ment, cela semblait le cas d√®s le d√©but, mais maintenant je suis port√© √† croire que le plus probl√©matique √©tait le support du plugin.  En particulier, cela √©tait d√ª √† la panoplie d'outils d√©j√† existante et au m√©canisme de construction du mod√®le de projet MSBuild, qui a fonctionn√© avec succ√®s maintenant, bien qu'il ait d√ª √™tre √©tendu.  Pas besoin d'√©crire des algorithmes √† partir de z√©ro a consid√©rablement simplifi√© la t√¢che.  Notre pari sur ¬´notre¬ª jeu d'outils, r√©alis√© au stade de la prise en charge de Visual Studio 2017, √©tait une fois de plus justifi√©. <br><br>  Traditionnellement, tout commence par la mise √† jour des packages NuGet.  Sur l'onglet de gestion des packages NuGet pour les solutions, il y a un bouton ¬´Mettre √† jour¬ª ... qui ne fonctionne pas.  Lors de la mise √† jour de tous les packages, plusieurs conflits de versions sont survenus et leur r√©solution ne semblait pas tr√®s correcte.  Un moyen plus p√©nible, mais, semble-t-il, plus fiable, consiste √† mettre √† jour ¬´morceau par morceau¬ª les packages Microsoft.Build / Microsoft.CodeAnalysis cibles. <br><br>  L'une des diff√©rences a √©t√© imm√©diatement identifi√©e par des tests de r√®gles de diagnostic - la structure de l'arbre de syntaxe d'un n≈ìud d√©j√† existant a chang√©.  C'est bon, corrig√© rapidement. <br><br>  Permettez-moi de vous rappeler que pendant le travail, nous testons des analyseurs (C #, C ++, Java) sur des projets open source.  Cela vous permet de bien tester les r√®gles de diagnostic - trouver, par exemple, des faux positifs, ou avoir une id√©e des autres cas qui n'ont pas √©t√© pris en compte (r√©duire le nombre de faux n√©gatifs).  Ces tests permettent √©galement de suivre une √©ventuelle r√©gression au stade initial de la mise √† jour des biblioth√®ques / outils.  Et cette fois n'a pas fait exception, car un certain nombre de probl√®mes sont apparus. <br><br>  Un probl√®me √©tait la d√©t√©rioration du comportement dans les biblioth√®ques CodeAnalysis.  Plus pr√©cis√©ment, sur un certain nombre de projets dans le code de biblioth√®que, des exceptions se sont produites lors de diverses op√©rations - obtention d'informations s√©mantiques, ouverture de projets, etc. <br><br>  Les lecteurs attentifs de l'article sur la prise en charge de Visual Studio 2017 se souviennent que notre kit de distribution a un stub - le fichier MSBuild.exe a une taille de 0 octet. <br><br>  Cette fois, j'ai d√ª aller plus loin - maintenant le kit de distribution contient √©galement des talons de compilateur vides - csc.exe, vbc.exe, VBCSCompiler.exe.  Pourquoi?  La voie √† suivre a commenc√© avec l'analyse de l'un des projets de la base de test, sur lequel les ¬´diff√©rences¬ª de rapports sont apparues - un certain nombre d'avertissements √©taient absents lors de l'utilisation de la nouvelle version de l'analyseur. <br><br>  Le probl√®me s'est av√©r√© √™tre des symboles de compilation conditionnelle - lors de l'analyse d'un projet √† l'aide de la nouvelle version de l'analyseur, certains symboles ont √©t√© extraits incorrectement.  Pour mieux comprendre ce qui a caus√© ce probl√®me, j'ai d√ª plonger dans les biblioth√®ques Roslyn. <br><br>  Pour analyser les caract√®res de compilation conditionnelle, utilisez la m√©thode <i>GetDefineConstantsSwitch</i> de la classe <i>Csc</i> de la biblioth√®que <i>Microsoft.Build.Tasks.CodeAnalysis</i> .  L'analyse est effectu√©e √† l'aide de la m√©thode <i>String.Split</i> sur un certain nombre de d√©limiteurs: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] allIdentifiers = originalDefineConstants.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> });</code> </pre> <br>  Cette m√©thode d'analyse fonctionne correctement, tous les symboles de compilation conditionnelle n√©cessaires sont extraits avec succ√®s.  Creuser plus loin. <br><br>  Le point cl√© suivant est l'appel √† la m√©thode <i>ComputePathToTool</i> de la classe <i>ToolTask</i> .  Cette m√©thode cr√©e le chemin d'acc√®s au fichier ex√©cutable ( <i>csc.exe</i> ) et v√©rifie sa pr√©sence.  Si le fichier existe, son chemin d'acc√®s est renvoy√©, sinon <i>null est</i> renvoy√©. <br><br>  Code de l'appelant: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pathToTool = ComputePathToTool(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTool == null) { <span class="hljs-comment"><span class="hljs-comment">// An appropriate error should have been logged already. return false; } ....</span></span></code> </pre> <br>  Puisqu'il n'y a pas de fichier <i>csc.exe</i> (il semblerait - pourquoi en avons-nous besoin?), <i>PathToTool</i> √† ce stade est <i>nul</i> et la m√©thode actuelle ( <i>ToolTask.Execute</i> ) termine son ex√©cution avec le r√©sultat <i>faux</i> .  Par cons√©quent, les r√©sultats de la t√¢che, y compris les symboles de compilation conditionnelle r√©sultants, sont ignor√©s. <br><br>  <i>Voyons</i> ce qui se passe si vous placez le fichier <i>csc.exe</i> √† l'emplacement attendu. <br><br>  Dans ce cas, <i>pathToTool</i> indique l'emplacement r√©el du fichier existant et l'ex√©cution de la m√©thode <i>ToolTask.Execute</i> continue.  Le point cl√© suivant est l'appel √† la m√©thode <i>ManagedCompiler.ExecuteTool</i> .  Et cela commence comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteTool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathToTool, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> responseFileCommands, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandLineCommands)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ProvideCommandLineArgs) { CommandLineArgs = GetArguments(commandLineCommands, responseFileCommands) .Select(arg =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskItem(arg)).ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SkipCompilerExecution) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  La propri√©t√© <i>SkipCompilerExecution</i> est <i>vraie</i> (logiquement, nous ne <i>compilons</i> pas r√©ellement).  Par cons√©quent, la m√©thode appelante (d√©j√† mentionn√©e <i>ToolTask.Execute</i> ) v√©rifie que le code retour de la m√©thode <i>ExecuteTool</i> est 0 et, si tel est le cas, termine son ex√©cution avec la valeur <i>true</i> .  Ce que vous aviez derri√®re <i>csc.exe</i> √©tait l√† - le vrai compilateur ou ¬´Guerre et paix¬ª de Leo Tolsto√Ø sous forme textuelle n'a pas d'importance. <br><br>  Par cons√©quent, le probl√®me principal provient du fait que la s√©quence des √©tapes est d√©finie dans l'ordre suivant: <br><br><ul><li>  v√©rifier l'existence du compilateur; </li><li>  v√©rifier si le compilateur doit √™tre d√©marr√©; </li></ul><br>  pas l'inverse.  Les stubs du compilateur ont r√©ussi √† r√©soudre ce probl√®me. <br><br>  Eh bien, comment les caract√®res d'une compilation r√©ussie se sont-ils produits si le fichier csc.exe n'a pas √©t√© d√©tect√© (et le r√©sultat de la t√¢che a √©t√© ignor√©)? <br><br>  Il existe une m√©thode pour ce cas - <i>CSharpCommandLineParser.ParseConditionalCompilationSymbols √†</i> partir de la biblioth√®que <i>Microsoft.CodeAnalysis.CSharp</i> .  L'analyse est √©galement effectu√©e par la m√©thode <i>String.Split</i> avec un certain nombre de d√©limiteurs: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] values = value.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*, StringSplitOptions.RemoveEmptyEntries*/</span></span>);</code> </pre> <br>  Remarquez la diff√©rence avec l'ensemble des d√©limiteurs de la m√©thode <i>Csc.GetDefineConstantsSwitch</i> ?  Dans ce cas, l'espace blanc n'est pas un s√©parateur.  Ainsi, si des caract√®res de compilation conditionnelle ont √©t√© √©crits avec un espace, cette m√©thode ne les analysera pas correctement. <br><br>  Cette situation s'est produite sur des projets probl√©matiques - des caract√®res de compilation conditionnelle y ont √©t√© √©crits avec un espace et ont √©t√© analys√©s avec succ√®s √† l'aide de <i>GetDefineConstantsSwitch</i> , mais pas <i>ParseConditionalCompilationSymbols</i> . <br><br>  Un autre probl√®me qui s'est r√©v√©l√© apr√®s la mise √† jour des biblioth√®ques a √©t√© la d√©t√©rioration du comportement dans un certain nombre de cas, en particulier sur des projets qui n'ont pas √©t√© collect√©s.  Des probl√®mes sont survenus dans les biblioth√®ques Microsoft.CodeAnalysis et nous sont retourn√©s sous la forme de diverses exceptions - <i>ArgumentNullException</i> (certains enregistreurs internes n'ont pas √©t√© initialis√©s), <i>NullReferenceException</i> et d'autres. <br><br>  Je veux parler d'un de ces probl√®mes ci-dessous - il m'a sembl√© assez int√©ressant. <br><br>  Nous avons rencontr√© ce probl√®me lors de la v√©rification de la derni√®re version du projet Roslyn - une <i>exception NullReferenceException a √©t√©</i> lev√©e √† partir du code de l'une des biblioth√®ques.  En raison de suffisamment d'informations d√©taill√©es sur l'emplacement du probl√®me, nous avons rapidement trouv√© le code du probl√®me et, pour des raisons d'int√©r√™t, nous avons d√©cid√© d'essayer de voir si le probl√®me se reproduit lorsque vous travaillez √† partir de Visual Studio. <br><br>  Eh bien - il √©tait possible de le reproduire dans Visual Studio (l'exp√©rience a √©t√© men√©e sur Visual Studio 16.0.3).  Pour ce faire, nous avons besoin d'une d√©finition de classe de la forme suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  Nous aurons √©galement besoin du visualiseur de syntaxe (qui fait partie du SDK de la plateforme du compilateur .NET).  Il est n√©cessaire de demander <i>TypeSymbol</i> (√©l√©ment de menu ¬´Afficher TypeSymbol (le cas √©ch√©ant)¬ª) √† partir du n≈ìud de l'arborescence de syntaxe de type <i>ConstantPatternSyntax</i> ( <i>null</i> ).  Apr√®s cela, Visual Studio va red√©marrer et dans l'Observateur d'√©v√©nements, vous pouvez voir des informations sur le probl√®me, en particulier, trouver la trace de la pile: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.NullReferenceException at Microsoft.CodeAnalysis.CSharp.ConversionsBase. ClassifyImplicitBuiltInConversionSlow( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet<span class="hljs-string"><span class="hljs-string">'1 &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyBuiltInConversion( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet'</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode( Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode) at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo( Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) ....</code> </pre> <br>  Comme vous pouvez le voir, la cause du probl√®me est le d√©r√©f√©rencement de la r√©f√©rence nulle. <br><br>  Comme je l'ai mentionn√© pr√©c√©demment, nous avons rencontr√© le m√™me probl√®me lors des tests de l'analyseur.  Si vous utilisez les biblioth√®ques de d√©bogage Microsoft.CodeAnalysis pour cr√©er l'analyseur, vous pouvez arriver √† l'endroit exact en <i>d√©boguant en</i> demandant <i>TypeSymbol</i> au n≈ìud souhait√© dans l'arborescence de syntaxe. <br><br>  En cons√©quence, nous arrivons √† la m√©thode <i>ClassifyImplicitBuiltInConversionSlow</i> mentionn√©e dans la trace de pile <i>ci</i> - <i>dessus</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } Conversion conversion = ClassifyStandardImplicitConversion(source, destination, ref useSiteDiagnostics); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conversion.Exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversion; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; }</code> </pre> <br>  Le probl√®me est que le param√®tre de <i>destination</i> est <i>nul</i> dans ce cas.  Par cons√©quent, lors de l'appel de <i>destination.SpecialType, une</i> <i>exception NullReferenceException est lev√©e</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oui, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug.Assert est</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plus √©lev√© que le d√©r√©f√©rencement </font><font style="vertical-align: inherit;">, mais ce n'est pas suffisant, car en fait il ne prot√®ge pas contre quoi que ce soit - il aide seulement √† identifier le probl√®me dans les versions de d√©bogage des biblioth√®ques. </font><font style="vertical-align: inherit;">Ou n'aide pas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changements dans la construction d'un mod√®le de projets C ++ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rien de particuli√®rement int√©ressant ne s'est produit ici - les anciens algorithmes ne n√©cessitaient aucune modification importante, ce qui serait int√©ressant √† discuter. </font><font style="vertical-align: inherit;">Il y avait peut-√™tre deux points sur lesquels il est logique de s'attarder. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous avons d√ª modifier les algorithmes qui s'appuient sur la valeur de ToolsVersion pour √™tre √©crits au format num√©rique. </font><font style="vertical-align: inherit;">Sans entrer dans les d√©tails - il existe plusieurs cas o√π vous devez comparer des jeux d'outils et choisir, par exemple, une nouvelle version plus r√©cente. </font><font style="vertical-align: inherit;">Cette version, respectivement, avait une valeur num√©rique plus √©lev√©e. </font><font style="vertical-align: inherit;">Il y a eu un calcul que ToolsVersion, correspondant √† la nouvelle version de MSBuild / Visual Studio, sera √©gal √† 16.0. </font><font style="vertical-align: inherit;">Quel que soit le cas ... Par souci d'int√©r√™t, je cite un tableau sur la fa√ßon dont les valeurs des diff√©rentes propri√©t√©s ont chang√© dans diff√©rentes versions de Visual Studio:</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nom du produit Visual Studio </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Num√©ro de version de Visual Studio </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Version des outils </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Version PlatformToolset </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2010 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4,0 </font></font><br></td><td>  100 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2012 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4,0 </font></font><br></td><td>  110 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2013 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12,0 </font></font><br></td><td>  120 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2015 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14,0 </font></font><br></td><td>  140 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2017 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 141 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2019 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16,0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Courant </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 142 </font></font><br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La blague, bien s√ªr, est obsol√®te, mais vous ne pouvez pas vous emp√™cher de vous souvenir de changer les versions de Windows et Xbox afin de comprendre que la pr√©diction des valeurs futures (quels que soient le nom et la version), dans le cas de Microsoft, est une chose fragile. </font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La solution √©tait assez simple - introduisant la hi√©rarchisation des ensembles d'outils (attribution d'une entit√© prioritaire distincte). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le deuxi√®me point concerne les probl√®mes lors du travail dans Visual Studio 2017 ou dans un environnement adjacent (par exemple, la pr√©sence de la variable d'environnement </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VisualStudioVersion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Le fait est que le calcul des param√®tres n√©cessaires pour construire un mod√®le de projet C ++ est beaucoup plus compliqu√© que de construire un mod√®le de projet .NET. Dans le cas de .NET, nous utilisons notre propre ensemble d'outils et la valeur correspondante de ToolsVersion. Dans le cas de C ++, nous pouvons construire √† la fois sur nos propres outils et sur les ensembles d'outils existants dans le syst√®me. √Ä partir de Build Tools dans Visual Studio 2017, les jeux d'outils sont enregistr√©s dans le fichier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSBuild.exe.config</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pas dans le registre. Par cons√©quent, nous ne pouvons pas les obtenir √† partir de la liste g√©n√©rale des jeux d'outils (par exemple, via </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.Toolsets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), contrairement aux jeux d'outils qui sont enregistr√©s dans le Registre (correspondant √† &lt;= Visual Studio 2015) . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En cons√©quence de ce qui pr√©c√®de, il ne fonctionnera pas pour construire un mod√®le de projet √† l'aide de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToolsVersion 15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car le syst√®me ne verra pas le jeu d'outils n√©cessaire. Ensemble d'outils le plus r√©cent - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actuel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- il sera disponible en m√™me temps, car il s'agit de notre propre jeu d'outils, par cons√©quent, il n'y a pas un tel probl√®me pour Visual Studio 2019. </font><font style="vertical-align: inherit;">La solution s'est av√©r√©e simple et a permis de r√©soudre le probl√®me sans changer les algorithmes existants pour la construction du mod√®le de projet - en ajoutant </font><font style="vertical-align: inherit;">un autre </font><font style="vertical-align: inherit;">√† la liste de vos propres jeux d'outils, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changements dans la construction d'un mod√®le de projets C # .NET Core </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans le cadre de cette t√¢che, 2 probl√®mes ont √©t√© r√©solus √† la fois, car ils se sont av√©r√©s li√©s: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> apr√®s l'ajout du jeu d'outils 'Actuel', l'analyse des projets .NET Core pour Visual Studio 2017 a cess√© de fonctionner; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'analyse des projets .NET Core sur un syst√®me o√π au moins une version de Visual Studio n'√©tait pas install√©e n'a pas fonctionn√©. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le probl√®me dans les deux cas √©tait le m√™me - certains fichiers de base .targets / .props ont √©t√© recherch√©s de mani√®re incorrecte. </font><font style="vertical-align: inherit;">Cela a conduit au fait qu'il n'√©tait pas possible de construire un mod√®le de projet √† l'aide de notre ensemble d'outils. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En l'absence de Visual Studio, vous pouvez voir une telle erreur (avec la version pr√©c√©dente de toolset'a - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Windows\Microsoft.NET\Framework64\ 15.0\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found.</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la g√©n√©ration du mod√®le C # .NET Core du projet dans Visual Studio 2017, vous pouviez voir le probl√®me suivant (avec la version actuelle du jeu d'outils, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\MSBuild\Current\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found. ....</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme les probl√®mes sont similaires (mais √ßa ressemble √† √ßa), vous pouvez essayer de tuer deux oiseaux avec une pierre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ci-dessous, je d√©cris comment ce probl√®me a √©t√© r√©solu sans entrer dans les d√©tails techniques. Ces d√©tails (sur la construction de mod√®les de projets C # .NET Core, ainsi que sur la modification de la construction des mod√®les dans notre ensemble d'outils) attendent dans l'un de nos futurs articles. √Ä propos, si vous lisez attentivement le texte ci-dessus, vous remarquerez peut-√™tre qu'il s'agit de la deuxi√®me r√©f√©rence √† de futurs articles.</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alors, comment avons-nous r√©solu ce probl√®me? La solution consistait √† √©tendre notre propre ensemble d'outils au d√©triment des principaux fichiers .targets / .props du SDK .NET Core ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sdk.props</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sdk.targets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Cela nous a permis d'avoir plus de contr√¥le sur la situation, plus de flexibilit√© dans la gestion des importations, ainsi que dans la construction d'un mod√®le de projets .NET Core en g√©n√©ral. Oui, notre ensemble d'outils a un peu augment√©, et nous avons √©galement d√ª ajouter de la logique pour configurer les projets d'environnement n√©cessaires √† la construction du mod√®le .NET Core, mais il semble que cela en valait la peine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auparavant, le principe de travail lors de la construction d'un mod√®le de projets .NET Core √©tait le suivant: nous avons simplement demand√© cette construction, puis tout a fonctionn√© aux d√©pens de MSBuild. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lorsque nous avons pris plus de contr√¥le entre nos mains, cela semble un peu diff√©rent:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pr√©paration de l'environnement n√©cessaire √† la construction d'un mod√®le de projets .NET Core; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> construction de mod√®les: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©but de la construction en utilisant les fichiers .targets / .props de notre ensemble d'outils'a; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> poursuite de la construction √† l'aide de fichiers externes. </font></font></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ä partir des √©tapes d√©crites ci-dessus, il est √©vident que la mise en place de l'environnement n√©cessaire a deux objectifs principaux: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lancer la construction de mod√®les √† l'aide de fichiers .targets / .props √† partir de votre propre jeu d'outils; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rediriger d'autres op√©rations vers des fichiers externes .targets / .props. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour rechercher les fichiers .targets / .props n√©cessaires √† la construction d'un mod√®le de projets .NET Core, une biblioth√®que sp√©ciale est utilis√©e - Microsoft.DotNet.MSBuildSdkResolver. L'initiation de la construction √† l'aide de fichiers de notre ensemble d'outils a √©t√© r√©solue en utilisant une variable d'environnement sp√©ciale utilis√©e par cette biblioth√®que - nous sugg√©rons o√π importer les fichiers n√©cessaires (√† partir de notre ensemble d'outils). Puisque la biblioth√®que fait partie de notre distribution, il n'y a aucune crainte que la logique change soudainement et cesse de fonctionner.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, les fichiers Sdk sont d'abord import√©s de notre ensemble d'outils, et comme nous pouvons facilement les modifier, le contr√¥le de la logique suppl√©mentaire de construction du mod√®le passe entre nos mains. Par cons√©quent, nous pouvons d√©terminer nous-m√™mes quels fichiers doivent √™tre import√©s et d'o√π. Cela s'applique √©galement aux Microsoft.Common.props mentionn√©s ci-dessus. Nous importons ce fichier et d'autres fichiers de base de notre propre ensemble d'outils en toute confiance dans leur disponibilit√© et leur contenu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s cela, apr√®s avoir effectu√© les importations n√©cessaires et d√©fini un certain nombre de propri√©t√©s, nous transf√©rons le contr√¥le suppl√©mentaire de la cr√©ation de mod√®les vers le SDK .NET Core r√©el, o√π le reste des actions n√©cessaires ont lieu.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En g√©n√©ral, la prise en charge de Visual Studio 2019 est devenue plus facile que la prise en charge de Visual Studio 2017, ce qui, √† mon avis, est d√ª √† plusieurs facteurs. Tout d'abord, Microsoft n'a pas chang√© autant de choses qu'entre Visual Studio 2015 et Visual Studio 2017. Oui, nous avons chang√© le jeu d'outils principal, avons commenc√© √† orienter les plug-ins pour Visual Studio sur l'asynchronie, mais n√©anmoins. La seconde - nous avions d√©j√† une solution pr√™te avec nos propres outils et mod√®les de projet de construction - il n'√©tait pas n√©cessaire de tout inventer √† nouveau, il suffisait simplement d'√©tendre la solution existante. La prise en charge relativement simple de l'analyse des projets .NET Core pour de nouvelles conditions (ainsi que pour les cas d'analyse sur une machine o√π il n'y a pas d'instances Visual Studio install√©es) en raison de l'expansion de notre syst√®me de construction de mod√®le de projet donne √©galement l'espoir que nous avons fait le bon choix.Ayant d√©cid√© de prendre le contr√¥le de vous-m√™me.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais tout de m√™me, je voudrais r√©p√©ter une pens√©e qui figurait √† nouveau dans l'article pr√©c√©dent - parfois, utiliser des solutions toutes faites n'est pas aussi simple qu'il y para√Æt √† premi√®re vue. </font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Sergey Vasiliev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prise en charge de Visual Studio 2019 dans PVS-Studio</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454738/">https://habr.com/ru/post/fr454738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454728/index.html">Acc√®s Internet ouvert: la technologie LUWRAIN aide les utilisateurs aveugles</a></li>
<li><a href="../fr454730/index.html">Meetup Allure Server: enregistrements vid√©o de rapports</a></li>
<li><a href="../fr454732/index.html">5 techniques de priorisation robustes pour les √©quipes informatiques</a></li>
<li><a href="../fr454734/index.html">Sauvegarde, Partie 4: Pr√©sentation et test de zbackup, restic, borgbackup</a></li>
<li><a href="../fr454736/index.html">Prise en charge de Visual Studio 2019 dans PVS-Studio</a></li>
<li><a href="../fr454740/index.html">Mai 2019 Joomla Digest</a></li>
<li><a href="../fr454742/index.html">Au moins une astuce Vim que vous ne connaissiez pas</a></li>
<li><a href="../fr454744/index.html">Pr√©sentation des rapports de suivi Java de la conf√©rence RigaDevDays</a></li>
<li><a href="../fr454748/index.html">Guide de survie MongoDB</a></li>
<li><a href="../fr454750/index.html">Swift UI - galoper √† travers l'Europe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>