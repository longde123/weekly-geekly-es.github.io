<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏅 🙅 🐒 So funktioniert JS: Klassen und Vererbung, Transpilation in Babel und TypeScript 🔪 😾 👵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Klassen sind heutzutage eine der beliebtesten Möglichkeiten, Softwareprojekte zu strukturieren. Dieser Programmieransatz wird auch in JavaScript verwe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So funktioniert JS: Klassen und Vererbung, Transpilation in Babel und TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415377/">  Klassen sind heutzutage eine der beliebtesten Möglichkeiten, Softwareprojekte zu strukturieren.  Dieser Programmieransatz wird auch in JavaScript verwendet.  Heute veröffentlichen wir eine Übersetzung von Teil 15 der JS-Ökosystemreihe.  In diesem Artikel werden verschiedene Ansätze zum Implementieren von Klassen in JavaScript, Vererbungsmechanismen und Transpiration erläutert.  Zunächst erklären wir Ihnen, wie Prototypen funktionieren, und analysieren verschiedene Möglichkeiten, um die klassenbasierte Vererbung in gängigen Bibliotheken zu simulieren.  Als nächstes werden wir darüber sprechen, wie es dank der Transpilation möglich ist, JS-Programme zu schreiben, die Funktionen verwenden, die entweder nicht in der Sprache verfügbar sind oder, obwohl sie in Form neuer Standards oder Vorschläge existieren, die sich in verschiedenen Genehmigungsphasen befinden, noch nicht in JS implementiert sind. Motoren.  Insbesondere werden wir über Babel- und TypeScript- sowie ECMAScript 2015-Klassen sprechen. Anschließend werden einige Beispiele betrachtet, die die Funktionen der internen Implementierung von Klassen in der V8-JS-Engine demonstrieren. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/196/736/c87/196736c87449034c2354db7c52f1cd08.png" alt="Bild"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">[Lesen empfehlen] Die anderen 19 Teile des Zyklus</b> <div class="spoiler_text"> Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überblick über die Engine, Laufzeitmechanismen, Aufrufstapel</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu V8-Interna und Codeoptimierung</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten des Speichers, vier Arten von Speicherlecks und Umgang mit ihnen</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Async und fünf Möglichkeiten zur Verbesserung Ihres Codes mit Async / Warten</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebSocket und HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was soll ich wählen?</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen und Umfang von WebAssembly</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web Worker und fünf Nutzungsszenarien</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Servicemitarbeiter</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web-Push-Benachrichtigungen</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verfolgen Sie Änderungen im DOM mit MutationObserver</a> <br>  Teil 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering-Engines für Webseiten und Tipps zur Optimierung ihrer Leistung</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Animation mit CSS und JavaScript</a> <br>  Teil 14: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Abstrakte Syntaxbäume, Analyse und deren Optimierung</a> <br>  Teil 15: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Klassen und Vererbung, Transpilation in Babel und TypeScript</a> <br>  Teil 16: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Speicher</a> <br>  Teil 17: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Shadow DOM-Technologie und Webkomponenten</a> <br>  Teil 18: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: WebRTC- und P2P-Kommunikationsmechanismen</a> <br>  Teil 19: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Benutzerdefinierte Elemente</a> </div></div><br><h2>  <font color="#3AC1EF">Rückblick</font> </h2><br>  In JavaScript werden wir ständig mit Objekten konfrontiert, auch wenn es den Anschein hat, dass wir mit primitiven Datentypen arbeiten.  Erstellen Sie beispielsweise ein Zeichenfolgenliteral: <br><br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = <span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>;</code> </pre> <br>  Danach können wir uns sofort an <code>name</code> wenden, um verschiedene Methoden eines Objekts vom Typ <code>String</code> aufzurufen, in das das von uns erstellte String-Literal automatisch konvertiert wird. <br><br><pre> <code class="hljs pgsql">console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">2</span></span>)); // SessionStackSessionStack console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>.toLowerCase()); // sessionstack</code> </pre> <br>  Im Gegensatz zu anderen Sprachen können wir in JavaScript durch Erstellen einer Variablen, die beispielsweise eine Zeichenfolge oder eine Zahl enthält, ohne eine explizite Konvertierung mit dieser Variablen arbeiten, als ob sie ursprünglich mit dem <code>new</code> Schlüsselwort und dem entsprechenden Konstruktor erstellt worden wäre.  Aufgrund der automatischen Erstellung von Objekten, die primitive Werte einkapseln, können Sie daher mit solchen Werten arbeiten, als wären sie Objekte, insbesondere beziehen Sie sich auf deren Methoden und Eigenschaften. <br><br>  Eine weitere bemerkenswerte Tatsache in Bezug auf das JavaScript-Typsystem ist, dass beispielsweise Arrays auch Objekte sind.  Wenn Sie sich die Ausgabe des Befehls <code>typeof</code> ansehen, der für das Array <code>typeof</code> , können Sie feststellen, dass die untersuchte Entität den <code>object</code> .  Als Ergebnis stellt sich heraus, dass die Indizes der Elemente des Arrays nur Eigenschaften eines bestimmten Objekts sind.  Wenn wir also über einen Index auf ein Element eines Arrays zugreifen, müssen wir mit einer Eigenschaft eines Objekts vom Typ <code>Array</code> und den Wert dieser Eigenschaft abrufen.  Wenn wir darüber sprechen, wie Daten in gewöhnlichen Objekten und Arrays gespeichert werden, führen die folgenden zwei Konstruktionen zur Erstellung nahezu identischer Datenstrukturen: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = [<span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = { <span class="hljs-string"><span class="hljs-string">"0"</span></span>: <span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>, <span class="hljs-string"><span class="hljs-string">"length"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Infolgedessen wird der Zugriff auf die Elemente des Arrays und auf die Eigenschaften des Objekts mit derselben Geschwindigkeit ausgeführt.  Der Autor dieses Artikels sagt, er habe es bei der Lösung eines komplexen Problems herausgefunden.  Einmal musste er nämlich eine ernsthafte Optimierung eines sehr wichtigen Codeteils im Projekt durchführen.  Nachdem er viele einfache Ansätze ausprobiert hatte, beschloss er, alle in diesem Code verwendeten Objekte durch Arrays zu ersetzen.  Theoretisch ist der Zugriff auf Array-Elemente schneller als die Arbeit mit Hash-Tabellenschlüsseln.  Zu seiner Überraschung hatte diese Ersetzung keinerlei Auswirkungen auf die Leistung, da die Arbeit mit Arrays und die Arbeit mit Objekten in JavaScript auf die Interaktion mit Hash-Tabellenschlüsseln zurückzuführen ist, was in beiden Fällen dieselbe Zeit erfordert. <br><br><h2>  <font color="#3AC1EF">Klassen mit Prototypen simulieren</font> </h2><br>  Wenn wir an Objekte denken, fallen uns als erstes die Klassen ein.  Vielleicht hat jeder, der sich heute mit Programmierung beschäftigt, Anwendungen erstellt, deren Struktur auf Klassen und den Beziehungen zwischen ihnen basiert.  Obwohl Objekte in JavaScript buchstäblich überall zu finden sind, verwendet die Sprache kein traditionelles klassenbasiertes Vererbungssystem.  JavaScript verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prototypen</a> , um ähnliche Probleme zu lösen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/ba7/cab/633ba7cabdf251ed3747fb2a3764b344.png"></div><br>  <i><font color="#999999">Objekt und sein Prototyp</font></i> <br><br>  In JavaScript ist jedes Objekt einem anderen Objekt zugeordnet - mit einem eigenen Prototyp.  Wenn Sie versuchen, auf eine Eigenschaft oder Methode eines Objekts zuzugreifen, wird die Suche nach dem, was Sie benötigen, zuerst im Objekt selbst durchgeführt.  Wenn die Suche nicht erfolgreich ist, wird sie im Prototyp des Objekts fortgesetzt. <br><br>  Stellen Sie sich ein einfaches Beispiel vor, das eine Konstruktorfunktion für die <code>Component</code> Basisklasse beschreibt: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Component</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } Component.prototype.render = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content); }</code> </pre> <br>  Hier weisen wir der Prototypmethode die Funktion <code>render()</code> zu, da wir jede Instanz der <code>Component</code> Klasse benötigen, um diese Methode zu verwenden.  Wenn in einer Instanz von <code>Component</code> die <code>render</code> aufgerufen wird, beginnt ihre Suche in dem Objekt selbst, für das sie aufgerufen wird.  Anschließend wird die Suche im Prototyp fortgesetzt, wo das System diese Methode findet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/553/6d8/74d/5536d874d81cc44b164174953614f725.png"></div><br>  <i><font color="#999999">Prototyp und zwei Instanzen der Component-Klasse</font></i> <br><br>  Versuchen wir nun, die <code>Component</code> Klasse zu erweitern.  Erstellen wir einen Konstruktor für eine neue Klasse - <code>InputField</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   this.content = `&lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$</span></span></span><span class="hljs-string">{value}"</span></span> /&gt;`; }</code> </pre> <br>  Wenn wir die <code>InputField</code> Klasse benötigen <code>InputField</code> um die Funktionalität der <code>Component</code> Klasse zu erweitern und ihre <code>render</code> Methode aufrufen zu können, müssen wir ihren Prototyp ändern.  Wenn eine Methode für eine Instanz einer untergeordneten Klasse aufgerufen wird, ist es nicht sinnvoll, sie in einem leeren Prototyp zu suchen.  Bei der Suche nach dieser Methode müssen wir in der <code>Component</code> Klasse gefunden werden.  Daher müssen wir Folgendes tun: <br><br><pre> <code class="hljs pgsql">InputField.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Component());</code> </pre> <br>  Wenn Sie nun mit einer Instanz der <code>InputField</code> Klasse arbeiten und die Methode der <code>Component</code> Klasse aufrufen, befindet sich diese Methode im Prototyp der <code>Component</code> Klasse.  Um das Vererbungssystem zu implementieren, müssen Sie den <code>InputField</code> Prototyp mit einer Instanz der <code>Component</code> Klasse verbinden.  Viele Bibliotheken verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Object.setPrototypeOf ()</a> , um dieses Problem zu lösen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/c43/ba8/f5cc43ba8e7a66cf1bb5c8aecec04572.png"></div><br>  <i><font color="#999999">Erweitern der Komponentenklasse mit der InputField-Klasse</font></i> <br><br>  Die oben genannten Maßnahmen reichen jedoch nicht aus, um einen Mechanismus zu implementieren, der der herkömmlichen Vererbung ähnelt.  Jedes Mal, wenn wir die Klasse erweitern, müssen wir die folgenden Aktionen ausführen: <br><br><ul><li>  Machen Sie den Prototyp der untergeordneten Klasse zu einer Instanz der übergeordneten Klasse. </li><li>  Rufen Sie im Konstruktor der untergeordneten Klasse den Konstruktor der übergeordneten Klasse auf, um sicherzustellen, dass die übergeordnete Klasse korrekt initialisiert ist. </li><li>  Stellen Sie einen Mechanismus zum Aufrufen von Methoden der übergeordneten Klasse in Situationen bereit, in denen die untergeordnete Klasse die übergeordnete Methode überschreibt, die ursprüngliche Implementierung dieser Methode jedoch von der übergeordneten Klasse aufgerufen werden muss. </li></ul><br>  Wie Sie sehen können, muss ein JS-Entwickler die oben genannten Schritte ständig ausführen, wenn er die Funktionen der klassenbasierten Vererbung nutzen möchte.  Für den Fall, dass Sie viele Klassen erstellen müssen, kann dies alles in Form von Funktionen erkannt werden, die zur Wiederverwendung geeignet sind. <br><br>  Tatsächlich wurde die Aufgabe, die Vererbung anhand von Klassen zu organisieren, in der Praxis der JS-Entwicklung zunächst auf diese Weise gelöst.  Insbesondere unter Verwendung verschiedener Bibliotheken.  Solche Lösungen wurden sehr beliebt, was eindeutig darauf hinwies, dass in JavaScript eindeutig etwas fehlte.  Aus diesem Grund wurden in ECMAScript 2015 neue syntaktische Konstruktionen eingeführt, die die Arbeit mit Klassen unterstützen und die entsprechenden Vererbungsmechanismen implementieren sollen. <br><br><h2>  <font color="#3AC1EF">Klassentranspilation</font> </h2><br>  Nachdem die neuen Funktionen von ECMAScript 2015 (ES6) vorgeschlagen wurden, wollte die JS-Community sie so schnell wie möglich nutzen, ohne auf den Abschluss des langen Prozesses warten zu müssen, in dem diese Funktionen in JS-Engines und Browsern unterstützt werden.  Bei der Lösung solcher Probleme ist die Transpilation gut.  In diesem Fall reduziert sich die Kompilierung darauf, den nach den Regeln von ES6 geschriebenen JS-Code in eine Ansicht umzuwandeln, die für Browser verständlich ist, die bisher keine ES6-Funktionen unterstützen.  Auf diese Weise wird es beispielsweise möglich, Klassen zu deklarieren und klassenbasierte Vererbungsmechanismen gemäß ES6-Regeln zu implementieren und diese Konstrukte in Code zu konvertieren, der in jedem Browser funktioniert.  Schematisch kann dieser Prozess am Beispiel der Verarbeitung einer Pfeilfunktion durch einen Transpiler (eine weitere neue Sprachfunktion, deren Unterstützung Zeit benötigt) wie in der folgenden Abbildung dargestellt dargestellt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/37b/f2c/80237bf2c453fb8f9d7913c310a21384.png"></div><br>  <i><font color="#999999">Transpilation</font></i> <br><br>  Einer der beliebtesten JavaScript-Transpiler ist Babel.js.  Lassen Sie uns sehen, wie es funktioniert, indem Sie eine Kompilierung des <code>Component</code> Klassendeklarationscodes durchführen, über den wir oben gesprochen haben.  Hier ist also der ES6-Code: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } render() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Component(<span class="hljs-string"><span class="hljs-string">'SessionStack'</span></span>); component.render();</code> </pre> <br>  Und hier ist, was dieser Code nach der Transpilation wird: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Component = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Component</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{   _classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, Component);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } _createClass(Component, [{   <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">'render'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content);   } }]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Component; }();</code> </pre> <br>  Wie Sie sehen können, wird ECMAScript 5-Code am Ausgang des Transpilers abgerufen, der in jeder Umgebung ausgeführt werden kann.  Außerdem werden hier Aufrufe einiger Funktionen hinzugefügt, die Teil der Babel-Standardbibliothek sind. <br><br>  Wir sprechen über die Funktionen <code>_classCallCheck()</code> und <code>_createClass()</code> , die im transpilierten Code enthalten sind.  Die erste Funktion, <code>_classCallCheck()</code> , soll verhindern, dass die Konstruktorfunktion wie eine reguläre Funktion aufgerufen wird.  Dazu wird geprüft, ob der Kontext, in dem die Funktion aufgerufen wird, der Instanzkontext der <code>Component</code> Klasse ist.  Der Code prüft, ob das Schlüsselwort this auf eine ähnliche Instanz verweist.  Die zweite Funktion, <code>_createClass()</code> , erstellt Objekteigenschaften, die als Array von Objekten übergeben werden, die Schlüssel und ihre Werte enthalten. <br><br>  Um zu verstehen, wie Vererbung funktioniert, analysieren wir die <code>InputField</code> Klasse, die der Nachkomme der <code>Component</code> Klasse ist.  So kommen Klassenbeziehungen in ES6 zusammen: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   constructor(value) {       const content = `&lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"${value}"</span></span> /&gt;`;       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(content);   } }</code> </pre> <br>  Hier ist das Ergebnis der Transpilation dieses Codes mit Babel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputField = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_Component</span></span></span><span class="hljs-function">) </span></span>{ _inherits(InputField, _Component); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{   _classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, InputField);   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-string"><span class="hljs-string">'&lt;input type="text" value="'</span></span> + value + <span class="hljs-string"><span class="hljs-string">'" /&gt;'</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _possibleConstructorReturn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, (InputField.__proto__ || <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(InputField)).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, content)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InputField; }(Component);</code> </pre> <br>  In diesem Beispiel wird die Logik der Vererbungsmechanismen in einem Aufruf der Funktion <code>_inherits()</code> gekapselt.  Es führt dieselben Aktionen aus, die wir oben beschrieben haben, insbesondere mit dem Schreiben einer Instanz der übergeordneten Klasse in den Prototyp der untergeordneten Klasse. <br><br>  Um den Code zu transponieren, führt Babel mehrere seiner Transformationen durch.  Zunächst wird der ES6-Code analysiert und in eine Zwischendarstellung konvertiert, die als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abstrakter Syntaxbaum bezeichnet wird</a> .  Dann wird der resultierende abstrakte Syntaxbaum in einen anderen Baum konvertiert, von dem jeder Knoten in sein ES5-Äquivalent transformiert wird.  Infolgedessen wird dieser Baum in JS-Code konvertiert. <br><br><h2>  <font color="#3AC1EF">Abstrakter Syntaxbaum in Babel</font> </h2><br>  Ein abstrakter Syntaxbaum enthält Knoten, von denen jeder nur einen übergeordneten Knoten hat.  Babel hat einen Basistyp für Knoten.  Es enthält Informationen darüber, was der Knoten ist und wo er im Code zu finden ist.  Es gibt verschiedene Arten von Knoten, z. B. Knoten zur Darstellung von Literalen, z. B. Zeichenfolgen, Zahlen, <code>null</code> usw.  Darüber hinaus gibt es Knoten zur Darstellung von Ausdrücken, die zur Steuerung des Programmausführungsflusses verwendet werden ( <code>if</code> konstruiert), und Knoten für Schleifen ( <code>for</code> , <code>while</code> ).  Es gibt auch einen speziellen Knotentyp zur Darstellung von Klassen.  Es ist ein Nachkomme der <code>Node</code> Basisklasse.  Er erweitert diese Klasse, indem er Felder zum Speichern von Verweisen auf die Basisklasse und den Hauptteil der Klasse als separaten Knoten hinzufügt. <br>  Konvertieren Sie das folgende Codefragment in einen abstrakten Syntaxbaum: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } render() {   console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content) } }</code> </pre> <br>  So wird seine schematische Darstellung aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8b/4c5/c1d/a8b4c5c1d077388bac770d1b452e51ed.png"></div><br>  <i><font color="#999999">Abstrakter Syntaxbaum</font></i> <br><br>  Nach dem Erstellen eines Baums wird jeder seiner Knoten in den entsprechenden ES5-Knoten umgewandelt. Anschließend wird dieser neue Baum in Code konvertiert, der dem ECMAScript 5-Standard entspricht. Suchen Sie während des Konvertierungsprozesses zunächst den Knoten, der am weitesten vom Stammknoten entfernt ist, und konvertieren Sie diesen Knoten anschließend in Code Verwenden von für jeden Knoten generierten Snippets.  Danach wird der Vorgang wiederholt.  Diese Technik wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tiefensuche bezeichnet</a> . <br><br>  Im obigen Beispiel wird zuerst der Code für die beiden <code>MethodDefinition</code> Knoten generiert, danach der Code für den <code>ClassBody</code> Knoten und schließlich der Code für den <code>ClassDeclaration</code> Knoten. <br><br><h2>  <font color="#3AC1EF">TypeScript-Transpilation</font> </h2><br>  Ein weiteres beliebtes System, das Transpilation verwendet, ist TypeScript.  Dies ist eine Programmiersprache, deren Code in ECMAScript 5-Code umgewandelt wird, der für jede JS-Engine verständlich ist.  Es bietet eine neue Syntax zum Schreiben von JS-Anwendungen.  So implementieren Sie die <code>Component</code> Klasse in TypeScript: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   content: string;   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content: string) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content;   }   render() {       console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content)   } }</code> </pre> <br>  Hier ist der abstrakte Syntaxbaum für diesen Code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/806/ad0/332806ad0bd9882f32c58c0280a8ae40.png"></div><br>  <i><font color="#999999">Abstrakter Syntaxbaum</font></i> <br><br>  TypeScript unterstützt die Vererbung. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   constructor(value: string) {       const content = `&lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"${value}"</span></span> /&gt;`;       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(content);   } }</code> </pre> <br>  Hier ist das Ergebnis der Transpilation dieses Codes: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputField = <span class="hljs-comment"><span class="hljs-comment">/** @class */</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_super)</span></span></span><span class="hljs-function"> </span></span>{   __extends(InputField, _super);   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-string"><span class="hljs-string">"&lt;input type=\"text\" value=\""</span></span> + value + <span class="hljs-string"><span class="hljs-string">"\" /&gt;"</span></span>;       _this = _super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, content) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _this;   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InputField; }(Component));</code> </pre> <br>  Wie Sie sehen, handelt es sich wieder um einen ES5-Code, in dem zusätzlich zu Standardkonstruktionen einige Funktionen aus der TypeScript-Bibliothek aufgerufen werden.  Die Funktionen der Funktion <code>__extends()</code> ähneln denen, über die wir am Anfang dieses Materials gesprochen haben. <br><br>  Dank der weit verbreiteten Einführung von Babel und TypeScript sind Mechanismen zum Deklarieren von Klassen und zum Organisieren der klassenbasierten Vererbung zu Standardwerkzeugen für die Strukturierung von JS-Anwendungen geworden.  Dies trug dazu bei, diese Mechanismen in Browsern zu unterstützen. <br><br><h2>  <font color="#3AC1EF">Unterstützung für Browserklassen</font> </h2><br>  Die Klassenunterstützung wurde 2014 im Chrome-Browser angezeigt.  Auf diese Weise kann der Browser mit Klassendeklarationen ohne Verwendung von Transpilation oder Hilfsbibliotheken arbeiten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/860/a55/ad5860a550c7956d6bbf17cd1b0afbb6.png"></div><br>  <i><font color="#999999">Arbeiten mit Klassen in der Chrome JS-Konsole</font></i> <br><br>  Tatsächlich ist die Browserunterstützung für diese Mechanismen nichts anderes als syntaktischer Zucker.  Diese Konstrukte werden in dieselben Grundstrukturen konvertiert, die bereits von der Sprache unterstützt werden.  Selbst wenn Sie die neue Syntax auf einer niedrigeren Ebene verwenden, sieht alles so aus, als würden Konstruktoren erstellt und Prototypen von Objekten bearbeitet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b61/d1c/a5b/b61d1ca5b3d35b3b1f431ae8e82c48bd.png"></div><br>  <i><font color="#999999">Klassenunterstützung ist syntaktischer Zucker</font></i> <br><br><h2>  <font color="#3AC1EF">Klassenunterstützung in V8</font> </h2><br>  Lassen Sie uns darüber sprechen, wie die Unterstützung der ES6-Klasse in der V8-JS-Engine funktioniert.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Material</a> zu abstrakten Syntaxbäumen haben wir darüber gesprochen, dass das System JS-Code bei der Vorbereitung für die Ausführung analysiert und auf seiner Grundlage einen abstrakten Syntaxbaum bildet.  Beim Parsen von Konstruktionen von <a href="">Klassendeklarationen</a> fallen Knoten vom Typ <a href="">ClassLiteral</a> in den abstrakten Syntaxbaum. <br><br>  Diese Knoten speichern einige interessante Dinge.  Erstens ist es ein Konstruktor als separate Funktion, und zweitens ist es eine Liste von Klasseneigenschaften.  Dies können Methoden, Getter, Setter, öffentliche oder private Felder sein.  Ein solcher Knoten speichert außerdem einen Verweis auf die übergeordnete Klasse, der die Klasse erweitert, für die der Knoten gebildet wird, und der wiederum den Konstruktor, die Liste der Eigenschaften und eine Verknüpfung zu seiner eigenen übergeordneten Klasse speichert. <br><br>  Nachdem der neue <code>ClassLiteral</code> Knoten <a href="">in Code umgewandelt wurde</a> , wird er in Konstrukte konvertiert, die aus Funktionen und Prototypen bestehen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Der Autor dieses Materials sagt, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SessionStack</a> bestrebt ist, den Code seiner Bibliothek so vollständig wie möglich zu optimieren, da es schwierige Aufgaben beim Sammeln von Informationen über alles, was auf Webseiten passiert, lösen muss.  Bei der Lösung dieser Probleme sollte die Bibliothek die zu analysierende Seite nicht verlangsamen.  Für die Optimierung dieser Ebene müssen die kleinsten Details des JavaScript-Ökosystems berücksichtigt werden, die sich auf die Leistung auswirken, insbesondere die Merkmale der Anordnung von Klassen und Vererbungsmechanismen in ES6. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie ES6-Syntaxkonstrukte für die Arbeit mit Klassen in JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415377/">https://habr.com/ru/post/de415377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415367/index.html">Was ist, wenn sich Außerirdische als Maschinen mit künstlicher Intelligenz herausstellen?</a></li>
<li><a href="../de415369/index.html">Refactoring Preis</a></li>
<li><a href="../de415371/index.html">Kryptowährungs-Datenschutz</a></li>
<li><a href="../de415373/index.html">NumPy in Python. Teil 4</a></li>
<li><a href="../de415375/index.html">Versteckte Schafe und typografische Archäologie</a></li>
<li><a href="../de415381/index.html">Spielen Sie mit Kubernetes - Service für eine praktische Bekanntschaft mit K8s</a></li>
<li><a href="../de415383/index.html">Der unerfahrene Händler machte aufgrund eines Fehlers im System des britischen Maklers Geschäfte in Höhe von 5,5 Milliarden Euro</a></li>
<li><a href="../de415385/index.html">Die DCIM-Situation: Wie sich das Infrastrukturmanagement von Rechenzentren in den letzten Jahren verändert hat</a></li>
<li><a href="../de415387/index.html">Jeder Entwickler möchte wissen, wie man mit Phishing umgeht.</a></li>
<li><a href="../de415389/index.html">Heute ist das Zahlungssystem "VKontakte"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>