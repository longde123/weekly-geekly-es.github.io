<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÖ üôÖ üêí So funktioniert JS: Klassen und Vererbung, Transpilation in Babel und TypeScript üî™ üòæ üëµüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Klassen sind heutzutage eine der beliebtesten M√∂glichkeiten, Softwareprojekte zu strukturieren. Dieser Programmieransatz wird auch in JavaScript verwe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So funktioniert JS: Klassen und Vererbung, Transpilation in Babel und TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415377/">  Klassen sind heutzutage eine der beliebtesten M√∂glichkeiten, Softwareprojekte zu strukturieren.  Dieser Programmieransatz wird auch in JavaScript verwendet.  Heute ver√∂ffentlichen wir eine √úbersetzung von Teil 15 der JS-√ñkosystemreihe.  In diesem Artikel werden verschiedene Ans√§tze zum Implementieren von Klassen in JavaScript, Vererbungsmechanismen und Transpiration erl√§utert.  Zun√§chst erkl√§ren wir Ihnen, wie Prototypen funktionieren, und analysieren verschiedene M√∂glichkeiten, um die klassenbasierte Vererbung in g√§ngigen Bibliotheken zu simulieren.  Als n√§chstes werden wir dar√ºber sprechen, wie es dank der Transpilation m√∂glich ist, JS-Programme zu schreiben, die Funktionen verwenden, die entweder nicht in der Sprache verf√ºgbar sind oder, obwohl sie in Form neuer Standards oder Vorschl√§ge existieren, die sich in verschiedenen Genehmigungsphasen befinden, noch nicht in JS implementiert sind. Motoren.  Insbesondere werden wir √ºber Babel- und TypeScript- sowie ECMAScript 2015-Klassen sprechen. Anschlie√üend werden einige Beispiele betrachtet, die die Funktionen der internen Implementierung von Klassen in der V8-JS-Engine demonstrieren. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/196/736/c87/196736c87449034c2354db7c52f1cd08.png" alt="Bild"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">[Lesen empfehlen] Die anderen 19 Teile des Zyklus</b> <div class="spoiler_text"> Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberblick √ºber die Engine, Laufzeitmechanismen, Aufrufstapel</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu V8-Interna und Codeoptimierung</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten des Speichers, vier Arten von Speicherlecks und Umgang mit ihnen</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Async und f√ºnf M√∂glichkeiten zur Verbesserung Ihres Codes mit Async / Warten</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebSocket und HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was soll ich w√§hlen?</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen und Umfang von WebAssembly</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web Worker und f√ºnf Nutzungsszenarien</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Servicemitarbeiter</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web-Push-Benachrichtigungen</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verfolgen Sie √Ñnderungen im DOM mit MutationObserver</a> <br>  Teil 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering-Engines f√ºr Webseiten und Tipps zur Optimierung ihrer Leistung</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Animation mit CSS und JavaScript</a> <br>  Teil 14: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Abstrakte Syntaxb√§ume, Analyse und deren Optimierung</a> <br>  Teil 15: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Klassen und Vererbung, Transpilation in Babel und TypeScript</a> <br>  Teil 16: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Speicher</a> <br>  Teil 17: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Shadow DOM-Technologie und Webkomponenten</a> <br>  Teil 18: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: WebRTC- und P2P-Kommunikationsmechanismen</a> <br>  Teil 19: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Benutzerdefinierte Elemente</a> </div></div><br><h2>  <font color="#3AC1EF">R√ºckblick</font> </h2><br>  In JavaScript werden wir st√§ndig mit Objekten konfrontiert, auch wenn es den Anschein hat, dass wir mit primitiven Datentypen arbeiten.  Erstellen Sie beispielsweise ein Zeichenfolgenliteral: <br><br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = <span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>;</code> </pre> <br>  Danach k√∂nnen wir uns sofort an <code>name</code> wenden, um verschiedene Methoden eines Objekts vom Typ <code>String</code> aufzurufen, in das das von uns erstellte String-Literal automatisch konvertiert wird. <br><br><pre> <code class="hljs pgsql">console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">2</span></span>)); // SessionStackSessionStack console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>.toLowerCase()); // sessionstack</code> </pre> <br>  Im Gegensatz zu anderen Sprachen k√∂nnen wir in JavaScript durch Erstellen einer Variablen, die beispielsweise eine Zeichenfolge oder eine Zahl enth√§lt, ohne eine explizite Konvertierung mit dieser Variablen arbeiten, als ob sie urspr√ºnglich mit dem <code>new</code> Schl√ºsselwort und dem entsprechenden Konstruktor erstellt worden w√§re.  Aufgrund der automatischen Erstellung von Objekten, die primitive Werte einkapseln, k√∂nnen Sie daher mit solchen Werten arbeiten, als w√§ren sie Objekte, insbesondere beziehen Sie sich auf deren Methoden und Eigenschaften. <br><br>  Eine weitere bemerkenswerte Tatsache in Bezug auf das JavaScript-Typsystem ist, dass beispielsweise Arrays auch Objekte sind.  Wenn Sie sich die Ausgabe des Befehls <code>typeof</code> ansehen, der f√ºr das Array <code>typeof</code> , k√∂nnen Sie feststellen, dass die untersuchte Entit√§t den <code>object</code> .  Als Ergebnis stellt sich heraus, dass die Indizes der Elemente des Arrays nur Eigenschaften eines bestimmten Objekts sind.  Wenn wir also √ºber einen Index auf ein Element eines Arrays zugreifen, m√ºssen wir mit einer Eigenschaft eines Objekts vom Typ <code>Array</code> und den Wert dieser Eigenschaft abrufen.  Wenn wir dar√ºber sprechen, wie Daten in gew√∂hnlichen Objekten und Arrays gespeichert werden, f√ºhren die folgenden zwei Konstruktionen zur Erstellung nahezu identischer Datenstrukturen: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = [<span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = { <span class="hljs-string"><span class="hljs-string">"0"</span></span>: <span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>, <span class="hljs-string"><span class="hljs-string">"length"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Infolgedessen wird der Zugriff auf die Elemente des Arrays und auf die Eigenschaften des Objekts mit derselben Geschwindigkeit ausgef√ºhrt.  Der Autor dieses Artikels sagt, er habe es bei der L√∂sung eines komplexen Problems herausgefunden.  Einmal musste er n√§mlich eine ernsthafte Optimierung eines sehr wichtigen Codeteils im Projekt durchf√ºhren.  Nachdem er viele einfache Ans√§tze ausprobiert hatte, beschloss er, alle in diesem Code verwendeten Objekte durch Arrays zu ersetzen.  Theoretisch ist der Zugriff auf Array-Elemente schneller als die Arbeit mit Hash-Tabellenschl√ºsseln.  Zu seiner √úberraschung hatte diese Ersetzung keinerlei Auswirkungen auf die Leistung, da die Arbeit mit Arrays und die Arbeit mit Objekten in JavaScript auf die Interaktion mit Hash-Tabellenschl√ºsseln zur√ºckzuf√ºhren ist, was in beiden F√§llen dieselbe Zeit erfordert. <br><br><h2>  <font color="#3AC1EF">Klassen mit Prototypen simulieren</font> </h2><br>  Wenn wir an Objekte denken, fallen uns als erstes die Klassen ein.  Vielleicht hat jeder, der sich heute mit Programmierung besch√§ftigt, Anwendungen erstellt, deren Struktur auf Klassen und den Beziehungen zwischen ihnen basiert.  Obwohl Objekte in JavaScript buchst√§blich √ºberall zu finden sind, verwendet die Sprache kein traditionelles klassenbasiertes Vererbungssystem.  JavaScript verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prototypen</a> , um √§hnliche Probleme zu l√∂sen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/ba7/cab/633ba7cabdf251ed3747fb2a3764b344.png"></div><br>  <i><font color="#999999">Objekt und sein Prototyp</font></i> <br><br>  In JavaScript ist jedes Objekt einem anderen Objekt zugeordnet - mit einem eigenen Prototyp.  Wenn Sie versuchen, auf eine Eigenschaft oder Methode eines Objekts zuzugreifen, wird die Suche nach dem, was Sie ben√∂tigen, zuerst im Objekt selbst durchgef√ºhrt.  Wenn die Suche nicht erfolgreich ist, wird sie im Prototyp des Objekts fortgesetzt. <br><br>  Stellen Sie sich ein einfaches Beispiel vor, das eine Konstruktorfunktion f√ºr die <code>Component</code> Basisklasse beschreibt: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Component</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } Component.prototype.render = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content); }</code> </pre> <br>  Hier weisen wir der Prototypmethode die Funktion <code>render()</code> zu, da wir jede Instanz der <code>Component</code> Klasse ben√∂tigen, um diese Methode zu verwenden.  Wenn in einer Instanz von <code>Component</code> die <code>render</code> aufgerufen wird, beginnt ihre Suche in dem Objekt selbst, f√ºr das sie aufgerufen wird.  Anschlie√üend wird die Suche im Prototyp fortgesetzt, wo das System diese Methode findet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/553/6d8/74d/5536d874d81cc44b164174953614f725.png"></div><br>  <i><font color="#999999">Prototyp und zwei Instanzen der Component-Klasse</font></i> <br><br>  Versuchen wir nun, die <code>Component</code> Klasse zu erweitern.  Erstellen wir einen Konstruktor f√ºr eine neue Klasse - <code>InputField</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   this.content = `&lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$</span></span></span><span class="hljs-string">{value}"</span></span> /&gt;`; }</code> </pre> <br>  Wenn wir die <code>InputField</code> Klasse ben√∂tigen <code>InputField</code> um die Funktionalit√§t der <code>Component</code> Klasse zu erweitern und ihre <code>render</code> Methode aufrufen zu k√∂nnen, m√ºssen wir ihren Prototyp √§ndern.  Wenn eine Methode f√ºr eine Instanz einer untergeordneten Klasse aufgerufen wird, ist es nicht sinnvoll, sie in einem leeren Prototyp zu suchen.  Bei der Suche nach dieser Methode m√ºssen wir in der <code>Component</code> Klasse gefunden werden.  Daher m√ºssen wir Folgendes tun: <br><br><pre> <code class="hljs pgsql">InputField.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Component());</code> </pre> <br>  Wenn Sie nun mit einer Instanz der <code>InputField</code> Klasse arbeiten und die Methode der <code>Component</code> Klasse aufrufen, befindet sich diese Methode im Prototyp der <code>Component</code> Klasse.  Um das Vererbungssystem zu implementieren, m√ºssen Sie den <code>InputField</code> Prototyp mit einer Instanz der <code>Component</code> Klasse verbinden.  Viele Bibliotheken verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Object.setPrototypeOf ()</a> , um dieses Problem zu l√∂sen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/c43/ba8/f5cc43ba8e7a66cf1bb5c8aecec04572.png"></div><br>  <i><font color="#999999">Erweitern der Komponentenklasse mit der InputField-Klasse</font></i> <br><br>  Die oben genannten Ma√ünahmen reichen jedoch nicht aus, um einen Mechanismus zu implementieren, der der herk√∂mmlichen Vererbung √§hnelt.  Jedes Mal, wenn wir die Klasse erweitern, m√ºssen wir die folgenden Aktionen ausf√ºhren: <br><br><ul><li>  Machen Sie den Prototyp der untergeordneten Klasse zu einer Instanz der √ºbergeordneten Klasse. </li><li>  Rufen Sie im Konstruktor der untergeordneten Klasse den Konstruktor der √ºbergeordneten Klasse auf, um sicherzustellen, dass die √ºbergeordnete Klasse korrekt initialisiert ist. </li><li>  Stellen Sie einen Mechanismus zum Aufrufen von Methoden der √ºbergeordneten Klasse in Situationen bereit, in denen die untergeordnete Klasse die √ºbergeordnete Methode √ºberschreibt, die urspr√ºngliche Implementierung dieser Methode jedoch von der √ºbergeordneten Klasse aufgerufen werden muss. </li></ul><br>  Wie Sie sehen k√∂nnen, muss ein JS-Entwickler die oben genannten Schritte st√§ndig ausf√ºhren, wenn er die Funktionen der klassenbasierten Vererbung nutzen m√∂chte.  F√ºr den Fall, dass Sie viele Klassen erstellen m√ºssen, kann dies alles in Form von Funktionen erkannt werden, die zur Wiederverwendung geeignet sind. <br><br>  Tats√§chlich wurde die Aufgabe, die Vererbung anhand von Klassen zu organisieren, in der Praxis der JS-Entwicklung zun√§chst auf diese Weise gel√∂st.  Insbesondere unter Verwendung verschiedener Bibliotheken.  Solche L√∂sungen wurden sehr beliebt, was eindeutig darauf hinwies, dass in JavaScript eindeutig etwas fehlte.  Aus diesem Grund wurden in ECMAScript 2015 neue syntaktische Konstruktionen eingef√ºhrt, die die Arbeit mit Klassen unterst√ºtzen und die entsprechenden Vererbungsmechanismen implementieren sollen. <br><br><h2>  <font color="#3AC1EF">Klassentranspilation</font> </h2><br>  Nachdem die neuen Funktionen von ECMAScript 2015 (ES6) vorgeschlagen wurden, wollte die JS-Community sie so schnell wie m√∂glich nutzen, ohne auf den Abschluss des langen Prozesses warten zu m√ºssen, in dem diese Funktionen in JS-Engines und Browsern unterst√ºtzt werden.  Bei der L√∂sung solcher Probleme ist die Transpilation gut.  In diesem Fall reduziert sich die Kompilierung darauf, den nach den Regeln von ES6 geschriebenen JS-Code in eine Ansicht umzuwandeln, die f√ºr Browser verst√§ndlich ist, die bisher keine ES6-Funktionen unterst√ºtzen.  Auf diese Weise wird es beispielsweise m√∂glich, Klassen zu deklarieren und klassenbasierte Vererbungsmechanismen gem√§√ü ES6-Regeln zu implementieren und diese Konstrukte in Code zu konvertieren, der in jedem Browser funktioniert.  Schematisch kann dieser Prozess am Beispiel der Verarbeitung einer Pfeilfunktion durch einen Transpiler (eine weitere neue Sprachfunktion, deren Unterst√ºtzung Zeit ben√∂tigt) wie in der folgenden Abbildung dargestellt dargestellt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/37b/f2c/80237bf2c453fb8f9d7913c310a21384.png"></div><br>  <i><font color="#999999">Transpilation</font></i> <br><br>  Einer der beliebtesten JavaScript-Transpiler ist Babel.js.  Lassen Sie uns sehen, wie es funktioniert, indem Sie eine Kompilierung des <code>Component</code> Klassendeklarationscodes durchf√ºhren, √ºber den wir oben gesprochen haben.  Hier ist also der ES6-Code: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } render() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Component(<span class="hljs-string"><span class="hljs-string">'SessionStack'</span></span>); component.render();</code> </pre> <br>  Und hier ist, was dieser Code nach der Transpilation wird: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Component = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Component</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{   _classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, Component);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } _createClass(Component, [{   <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">'render'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content);   } }]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Component; }();</code> </pre> <br>  Wie Sie sehen k√∂nnen, wird ECMAScript 5-Code am Ausgang des Transpilers abgerufen, der in jeder Umgebung ausgef√ºhrt werden kann.  Au√üerdem werden hier Aufrufe einiger Funktionen hinzugef√ºgt, die Teil der Babel-Standardbibliothek sind. <br><br>  Wir sprechen √ºber die Funktionen <code>_classCallCheck()</code> und <code>_createClass()</code> , die im transpilierten Code enthalten sind.  Die erste Funktion, <code>_classCallCheck()</code> , soll verhindern, dass die Konstruktorfunktion wie eine regul√§re Funktion aufgerufen wird.  Dazu wird gepr√ºft, ob der Kontext, in dem die Funktion aufgerufen wird, der Instanzkontext der <code>Component</code> Klasse ist.  Der Code pr√ºft, ob das Schl√ºsselwort this auf eine √§hnliche Instanz verweist.  Die zweite Funktion, <code>_createClass()</code> , erstellt Objekteigenschaften, die als Array von Objekten √ºbergeben werden, die Schl√ºssel und ihre Werte enthalten. <br><br>  Um zu verstehen, wie Vererbung funktioniert, analysieren wir die <code>InputField</code> Klasse, die der Nachkomme der <code>Component</code> Klasse ist.  So kommen Klassenbeziehungen in ES6 zusammen: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   constructor(value) {       const content = `&lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"${value}"</span></span> /&gt;`;       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(content);   } }</code> </pre> <br>  Hier ist das Ergebnis der Transpilation dieses Codes mit Babel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputField = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_Component</span></span></span><span class="hljs-function">) </span></span>{ _inherits(InputField, _Component); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{   _classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, InputField);   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-string"><span class="hljs-string">'&lt;input type="text" value="'</span></span> + value + <span class="hljs-string"><span class="hljs-string">'" /&gt;'</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _possibleConstructorReturn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, (InputField.__proto__ || <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(InputField)).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, content)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InputField; }(Component);</code> </pre> <br>  In diesem Beispiel wird die Logik der Vererbungsmechanismen in einem Aufruf der Funktion <code>_inherits()</code> gekapselt.  Es f√ºhrt dieselben Aktionen aus, die wir oben beschrieben haben, insbesondere mit dem Schreiben einer Instanz der √ºbergeordneten Klasse in den Prototyp der untergeordneten Klasse. <br><br>  Um den Code zu transponieren, f√ºhrt Babel mehrere seiner Transformationen durch.  Zun√§chst wird der ES6-Code analysiert und in eine Zwischendarstellung konvertiert, die als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abstrakter Syntaxbaum bezeichnet wird</a> .  Dann wird der resultierende abstrakte Syntaxbaum in einen anderen Baum konvertiert, von dem jeder Knoten in sein ES5-√Ñquivalent transformiert wird.  Infolgedessen wird dieser Baum in JS-Code konvertiert. <br><br><h2>  <font color="#3AC1EF">Abstrakter Syntaxbaum in Babel</font> </h2><br>  Ein abstrakter Syntaxbaum enth√§lt Knoten, von denen jeder nur einen √ºbergeordneten Knoten hat.  Babel hat einen Basistyp f√ºr Knoten.  Es enth√§lt Informationen dar√ºber, was der Knoten ist und wo er im Code zu finden ist.  Es gibt verschiedene Arten von Knoten, z. B. Knoten zur Darstellung von Literalen, z. B. Zeichenfolgen, Zahlen, <code>null</code> usw.  Dar√ºber hinaus gibt es Knoten zur Darstellung von Ausdr√ºcken, die zur Steuerung des Programmausf√ºhrungsflusses verwendet werden ( <code>if</code> konstruiert), und Knoten f√ºr Schleifen ( <code>for</code> , <code>while</code> ).  Es gibt auch einen speziellen Knotentyp zur Darstellung von Klassen.  Es ist ein Nachkomme der <code>Node</code> Basisklasse.  Er erweitert diese Klasse, indem er Felder zum Speichern von Verweisen auf die Basisklasse und den Hauptteil der Klasse als separaten Knoten hinzuf√ºgt. <br>  Konvertieren Sie das folgende Codefragment in einen abstrakten Syntaxbaum: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } render() {   console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content) } }</code> </pre> <br>  So wird seine schematische Darstellung aussehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8b/4c5/c1d/a8b4c5c1d077388bac770d1b452e51ed.png"></div><br>  <i><font color="#999999">Abstrakter Syntaxbaum</font></i> <br><br>  Nach dem Erstellen eines Baums wird jeder seiner Knoten in den entsprechenden ES5-Knoten umgewandelt. Anschlie√üend wird dieser neue Baum in Code konvertiert, der dem ECMAScript 5-Standard entspricht. Suchen Sie w√§hrend des Konvertierungsprozesses zun√§chst den Knoten, der am weitesten vom Stammknoten entfernt ist, und konvertieren Sie diesen Knoten anschlie√üend in Code Verwenden von f√ºr jeden Knoten generierten Snippets.  Danach wird der Vorgang wiederholt.  Diese Technik wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tiefensuche bezeichnet</a> . <br><br>  Im obigen Beispiel wird zuerst der Code f√ºr die beiden <code>MethodDefinition</code> Knoten generiert, danach der Code f√ºr den <code>ClassBody</code> Knoten und schlie√ülich der Code f√ºr den <code>ClassDeclaration</code> Knoten. <br><br><h2>  <font color="#3AC1EF">TypeScript-Transpilation</font> </h2><br>  Ein weiteres beliebtes System, das Transpilation verwendet, ist TypeScript.  Dies ist eine Programmiersprache, deren Code in ECMAScript 5-Code umgewandelt wird, der f√ºr jede JS-Engine verst√§ndlich ist.  Es bietet eine neue Syntax zum Schreiben von JS-Anwendungen.  So implementieren Sie die <code>Component</code> Klasse in TypeScript: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   content: string;   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content: string) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content;   }   render() {       console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content)   } }</code> </pre> <br>  Hier ist der abstrakte Syntaxbaum f√ºr diesen Code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/806/ad0/332806ad0bd9882f32c58c0280a8ae40.png"></div><br>  <i><font color="#999999">Abstrakter Syntaxbaum</font></i> <br><br>  TypeScript unterst√ºtzt die Vererbung. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   constructor(value: string) {       const content = `&lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"${value}"</span></span> /&gt;`;       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(content);   } }</code> </pre> <br>  Hier ist das Ergebnis der Transpilation dieses Codes: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputField = <span class="hljs-comment"><span class="hljs-comment">/** @class */</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_super)</span></span></span><span class="hljs-function"> </span></span>{   __extends(InputField, _super);   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-string"><span class="hljs-string">"&lt;input type=\"text\" value=\""</span></span> + value + <span class="hljs-string"><span class="hljs-string">"\" /&gt;"</span></span>;       _this = _super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, content) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _this;   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InputField; }(Component));</code> </pre> <br>  Wie Sie sehen, handelt es sich wieder um einen ES5-Code, in dem zus√§tzlich zu Standardkonstruktionen einige Funktionen aus der TypeScript-Bibliothek aufgerufen werden.  Die Funktionen der Funktion <code>__extends()</code> √§hneln denen, √ºber die wir am Anfang dieses Materials gesprochen haben. <br><br>  Dank der weit verbreiteten Einf√ºhrung von Babel und TypeScript sind Mechanismen zum Deklarieren von Klassen und zum Organisieren der klassenbasierten Vererbung zu Standardwerkzeugen f√ºr die Strukturierung von JS-Anwendungen geworden.  Dies trug dazu bei, diese Mechanismen in Browsern zu unterst√ºtzen. <br><br><h2>  <font color="#3AC1EF">Unterst√ºtzung f√ºr Browserklassen</font> </h2><br>  Die Klassenunterst√ºtzung wurde 2014 im Chrome-Browser angezeigt.  Auf diese Weise kann der Browser mit Klassendeklarationen ohne Verwendung von Transpilation oder Hilfsbibliotheken arbeiten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/860/a55/ad5860a550c7956d6bbf17cd1b0afbb6.png"></div><br>  <i><font color="#999999">Arbeiten mit Klassen in der Chrome JS-Konsole</font></i> <br><br>  Tats√§chlich ist die Browserunterst√ºtzung f√ºr diese Mechanismen nichts anderes als syntaktischer Zucker.  Diese Konstrukte werden in dieselben Grundstrukturen konvertiert, die bereits von der Sprache unterst√ºtzt werden.  Selbst wenn Sie die neue Syntax auf einer niedrigeren Ebene verwenden, sieht alles so aus, als w√ºrden Konstruktoren erstellt und Prototypen von Objekten bearbeitet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b61/d1c/a5b/b61d1ca5b3d35b3b1f431ae8e82c48bd.png"></div><br>  <i><font color="#999999">Klassenunterst√ºtzung ist syntaktischer Zucker</font></i> <br><br><h2>  <font color="#3AC1EF">Klassenunterst√ºtzung in V8</font> </h2><br>  Lassen Sie uns dar√ºber sprechen, wie die Unterst√ºtzung der ES6-Klasse in der V8-JS-Engine funktioniert.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Material</a> zu abstrakten Syntaxb√§umen haben wir dar√ºber gesprochen, dass das System JS-Code bei der Vorbereitung f√ºr die Ausf√ºhrung analysiert und auf seiner Grundlage einen abstrakten Syntaxbaum bildet.  Beim Parsen von Konstruktionen von <a href="">Klassendeklarationen</a> fallen Knoten vom Typ <a href="">ClassLiteral</a> in den abstrakten Syntaxbaum. <br><br>  Diese Knoten speichern einige interessante Dinge.  Erstens ist es ein Konstruktor als separate Funktion, und zweitens ist es eine Liste von Klasseneigenschaften.  Dies k√∂nnen Methoden, Getter, Setter, √∂ffentliche oder private Felder sein.  Ein solcher Knoten speichert au√üerdem einen Verweis auf die √ºbergeordnete Klasse, der die Klasse erweitert, f√ºr die der Knoten gebildet wird, und der wiederum den Konstruktor, die Liste der Eigenschaften und eine Verkn√ºpfung zu seiner eigenen √ºbergeordneten Klasse speichert. <br><br>  Nachdem der neue <code>ClassLiteral</code> Knoten <a href="">in Code umgewandelt wurde</a> , wird er in Konstrukte konvertiert, die aus Funktionen und Prototypen bestehen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Der Autor dieses Materials sagt, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SessionStack</a> bestrebt ist, den Code seiner Bibliothek so vollst√§ndig wie m√∂glich zu optimieren, da es schwierige Aufgaben beim Sammeln von Informationen √ºber alles, was auf Webseiten passiert, l√∂sen muss.  Bei der L√∂sung dieser Probleme sollte die Bibliothek die zu analysierende Seite nicht verlangsamen.  F√ºr die Optimierung dieser Ebene m√ºssen die kleinsten Details des JavaScript-√ñkosystems ber√ºcksichtigt werden, die sich auf die Leistung auswirken, insbesondere die Merkmale der Anordnung von Klassen und Vererbungsmechanismen in ES6. <br><br>  <b>Liebe Leser!</b>  Verwenden Sie ES6-Syntaxkonstrukte f√ºr die Arbeit mit Klassen in JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415377/">https://habr.com/ru/post/de415377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415367/index.html">Was ist, wenn sich Au√üerirdische als Maschinen mit k√ºnstlicher Intelligenz herausstellen?</a></li>
<li><a href="../de415369/index.html">Refactoring Preis</a></li>
<li><a href="../de415371/index.html">Kryptow√§hrungs-Datenschutz</a></li>
<li><a href="../de415373/index.html">NumPy in Python. Teil 4</a></li>
<li><a href="../de415375/index.html">Versteckte Schafe und typografische Arch√§ologie</a></li>
<li><a href="../de415381/index.html">Spielen Sie mit Kubernetes - Service f√ºr eine praktische Bekanntschaft mit K8s</a></li>
<li><a href="../de415383/index.html">Der unerfahrene H√§ndler machte aufgrund eines Fehlers im System des britischen Maklers Gesch√§fte in H√∂he von 5,5 Milliarden Euro</a></li>
<li><a href="../de415385/index.html">Die DCIM-Situation: Wie sich das Infrastrukturmanagement von Rechenzentren in den letzten Jahren ver√§ndert hat</a></li>
<li><a href="../de415387/index.html">Jeder Entwickler m√∂chte wissen, wie man mit Phishing umgeht.</a></li>
<li><a href="../de415389/index.html">Heute ist das Zahlungssystem "VKontakte"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>