<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏿 🧜 👩🏼‍🤝‍👨🏿 Indexer in C # unter der Haube: Indizierung besser als Dow Jones 👩🏿‍💻 📃 👨🏽‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. In diesem Artikel schlage ich vor, Indexer verschiedener Typen kennenzulernen. Sehen wir uns den Assembler-Sprachcode für diese Indexer und...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indexer in C # unter der Haube: Indizierung besser als Dow Jones</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450428/">  Guten Tag.  In diesem Artikel schlage ich vor, Indexer verschiedener Typen kennenzulernen.  Sehen wir uns den Assembler-Sprachcode für diese Indexer und die Eigenschaften jedes Befehls in seiner Geschwindigkeit an.  Ich werde auch einige offensichtliche Schlussfolgerungen ziehen.  Aber was genau Sie in Ihrer speziellen Situation verwenden sollen, liegt bei Ihnen, ob Sie die Bequemlichkeit für die Geschwindigkeit opfern oder umgekehrt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/22/aw/ng/22awng79cibgcbel1r2v0ahwzc8.png" alt="Bild" width="100%"></div><a name="habracut"></a><br><h3>  Metriken </h3><br>  Assembler-Code wird für 64-Bit-Systeme angegeben.  Die folgenden Metriken wurden als Metriken für jeden Befehl ausgewählt: die Anzahl der zusammengeführten Mikrooperationen, die Gesamtzahl der Mikrooperationen, die Verzögerung, der Durchsatz und natürlich die Anzahl der Befehle.  Ich habe für den Indexer keine Zahlen als Ganzes angegeben, weil  Die Situation kann variieren, je nachdem, wie Sie mit dem indizierten Typ arbeiten und den Cache unterschiedlich beeinflussen. <br><br>  Nachfolgend finden Sie eine kurze Zusammenfassung der Terminologie, ohne tiefer zu gehen, nur konzeptionelle Konzepte.  Mein Ziel war es, alles so einfach wie möglich zu beschreiben, um ein gemeinsames Verständnis zu erreichen. <br><br>  <b>Mikrooperation (uop)</b> ist eine bestimmte Operation, aus der jeder Befehl besteht.  Das Konzept der Mikrooperationen wird für Optimierungen wie Zusammenführen, Zwischenspeichern und Neuordnen verwendet.  So besteht der MOV-Befehl beispielsweise aus 1 Mikrooperation, während der XCHG-Befehl in zwei Registern aus 3 Mikrooperationen besteht (der Ansatz erfolgt über eine „temporäre Variable“, <i>dh</i> ein internes Register, danke <i>leotsarev</i> für die Aktualisierung), dem XCHG-Befehl über dem Register und Speicher besteht aus 8 Mikrooperationen. <br><br>  <b>Zusammengeführte Mikrooperationen (Fused Uops)</b> - Wie oben erwähnt, ist das Zusammenführen von <b>Mikrooperationen</b> eine der Optimierungen.  Es besteht darin, zwei Mikrooperationen durch eine komplexere zu ersetzen. <br><br>  <b>Die Latenz</b> ist die Anzahl der Maßnahmen, nach denen die in dieser Anweisung verwendeten Daten für die Verwendung durch eine andere Anweisung verfügbar werden. <br><br>  <b>Durchsatz (reziproker Durchsatz)</b> - Die Anzahl der Taktzyklen, die zum Ausführen eines Befehls erforderlich sind, vorausgesetzt, eine Folge identischer Befehle wird ausgeführt und sie arbeiten mit unabhängigen Daten. <br><br>  Anhand dieser Indikatoren können Sie die Leistung eines bestimmten Befehlssatzes bewerten.  Bitte beachten Sie, dass wir nur "bewerten" können. Die tatsächliche Leistung hängt von vielen Faktoren ab, wie z. B. Treffer- oder Fehler-Cache, Datenabhängigkeit usw. <br><br>  Diese Zahlen gelten für die Intel-Prozessorarchitektur Skylake-X.  Dies entspricht meinem Intel Core i7-6700 Prozessor. <br><br>  Es ist auch zu beachten, dass Fastcall für 64-Bit-Systeme die Übertragung von nicht 2, sondern 4 Parametern in Registern (rcx, rdx, r8, r9) ermöglicht. <br><br><h3>  Indexer in Zahlen </h3><br><h4>  1. Array-Indexer </h4><br>  Wir werden die folgenden Methoden als Beispiel betrachten: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] array</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array[index]; }</code> </pre> <br>  Betrachten Sie den Assembler-Sprachcode für dieses Snippet. <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r8+8] 2. jae 00007ff9`07288c78 3. movsxd rax,edx 4. mov eax,dword ptr [r8+rax*4+10h]</code> </pre><br>  Die erste Zeile prüft, ob der Index die Grenzen des Arrays überschreitet.  Die zweite Zeile löst eine Ausnahme aus, wenn sie beendet wird.  Als nächstes berechnen wir die Position des Elements im Array.  Die ersten Felder im Array sind Dienstinformationen, daher müssen sie übersprungen werden (zusätzliche 10 Stunden = 16 Byte). <br><br><div class="spoiler">  <b class="spoiler_title">Informationen zur Anleitung:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Nein, nein. </th><th>  Verschmolzene Ups </th><th>  Total uops </th><th>  Latenz </th><th>  Gegenseitiger Durchsatz </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  4 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br><br><h4>  2. Favoritenliste &lt;&gt; </h4><br>  Tintencode: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; list</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list[index]; }</code> </pre><br><br>  Assembler-Code: <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r8+10h] 2. jae M00_L00 3. mov rax,qword ptr [r8+8] 4. cmp edx,dword ptr [rax+8] 5. jae 00007ff9`07268f56 6. movsxd rdx,edx 7. mov eax,dword ptr [rax+rdx*4+10h] ret M00_L00 call System.ThrowHelper.ThrowArgumentOutOfRange_IndexException()</code> </pre><br>  Hier gibt es deutlich mehr Anweisungen.  Es ist deutlich zu sehen, dass der Blattindexer den Arrayindexer umschließt.  Ein interessanter Punkt ist, dass zweimal überprüft wird, ob die Grenzen des Arrays überschritten werden.  Die erste Anweisung prüft also, ob der Index die Grenzen des Blattes überschreitet.  Wenn dies der Fall ist, springen wir (Befehl 2) zu einem sehr offensichtlichen Aufruf und lösen eine Ausnahme aus, wenn sie die Grenzen des Arrays überschreitet.  Diese Rahmenprüfung verwendet das innere Feld des Blatts, das das zweite in der Reihenfolge ist (Versatz von 10h (16) Bytes vom Anfang des Typs, 8 zum Zeiger auf die Methodentabelle und 8 zum Link zum internen Array - dem ersten Feld).  In der dritten Zeile geben wir die Adresse des internen Arrays in das Rax-Register ein - das erste Feld (analog ist ein Offset von 8 Bytes ein Zeiger auf die Methodentabelle).  Darauf folgt der bereits bekannte Abschnitt - die Indexreferenz für das Array (Zeilen 4 - 7).  Hier wird zur Überprüfung der Grenzen das interne Feld des Arrays verwendet. <br>  Ich habe versucht, Dinge zu entfernen, die nicht direkt mit der Indizierung zusammenhängen, aber hier lohnt es sich, ret zu verlassen, damit es nicht so aussieht, als ob am Ende jedes Aufrufs des Blattelements eine Ausnahme auftritt: D. <br><br>  Übrigens, um Sie nicht mit Spekulationen zu quälen, machen Sie sich bitte mit der Umsetzung des Blattes <a href="">durch Bezugnahme</a> vertraut.  Das Typgießen auf vorzeichenlose Ints wird verwendet, um die Anzahl der Vergleiche zu verringern. <br><br>  Als Ergebnis erhalten wir 7 Anweisungen für den erfolgreichen Zugriff auf den Index, 3 mehr als im Array. <br><br><div class="spoiler">  <b class="spoiler_title">Informationen zur Anleitung:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Nein, nein. </th><th>  Verschmolzene Ups </th><th>  Total uops </th><th>  Latenz </th><th>  Gegenseitiger Durchsatz </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr><tr><td>  4 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  5 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  6 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  7 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br><h4>  Neu - Spanne &lt;&gt; </h4><br>  Disc: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerSpan</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> span[index]; }</code> </pre><br>  Und in Assemblersprache: <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r8+8] 2. jae 00007ff9`07278f69 3. mov rax,qword ptr [r8] 4. movsxd rdx,edx 5. mov eax,dword ptr [rax+rdx*4]</code> </pre><br>  Als die Spannweiten angekündigt wurden, versprachen sie uns, dass sie mit Unterstützung der Laufzeit mit Bedacht erstellt wurden.  Und sie haben nicht gelogen, was sie sagen sollten.  Tatsächlich unterscheidet es sich vom klassischen Array nur in einem Befehl, einem zusätzlichen Schritt des Zugriffs auf die Adresse.  Nach diesem Code zu urteilen, ist die Adresse des Speicherorts innerhalb des Bereichs verborgen, in dem sich die Elemente befinden, die wir in Zeile 3 erhalten. Dies kann eine Adresse an eine bestimmte Stelle in einem Array, einer Zeile oder einem Speicherelement auf dem Stapel sein. <br>  Klicken Sie hier, um zum Spaß eine Einführung in den Span-Indexer zu erhalten.  Möglicherweise stellen Sie fest, dass es je nach Umgebungsvariable zwei verschiedene Implementierungen gibt.  PROJECTN ist der Codename der ersten Version von .NET Native für UWP.  Daher interessieren wir uns mehr für die zweite Version des Indexers.  Sie ist mit <a href=""><i>[Intrinsic] gekennzeichnet</i></a> .  Wenn Sie sich außerdem die statische <a href="">unsichere</a> Klasse ansehen, die bei der Implementierung dieses Indexers verwendet wird, finden Sie Informationen darüber, dass die Implementierungen der meisten Methoden in dieser Datei als <i>intrinsisch dargestellt werden</i> . <br><br>  Methodenaufrufe oder Verweise auf Felder, die mit dem Attribut <i>[Intrinsic] gekennzeichnet</i> sind, werden von der Laufzeit unterstützt. <br><br>  In <b>CoreCLR</b> werden die Körper solcher Methoden durch EE (Execution Engine) durch unsicheren Code (unsicher) ersetzt.  Wenn Sie weitere Details benötigen, können Sie mit der Methode <a href="">getILIntrinsicImplementationForUnsafe</a> mit dem <a href="">Graben beginnen</a> . <br><br>  Informationen darüber, wie dies in <b>CoreRT funktioniert</b> (was mich ein wenig interessiert), <br>  Sie können sich <a href="">Internal.IL.Stubs.UnsafeIntrinsics ansehen</a> . <br><br>  Angesichts dieser Unterstützung durch raintime ist es sinnvoll, die Anweisungen in der Assembler-Sprache zu lesen, die wir gemacht haben, um zu verstehen, was genau hinter den Kulissen passieren wird. <br><br><div class="spoiler">  <b class="spoiler_title">Informationen zur Anleitung:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Nein, nein. </th><th>  Verschmolzene Ups </th><th>  Total uops </th><th>  Latenz </th><th>  Gegenseitiger Durchsatz </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr><tr><td>  4 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  5 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br>  Alle Indexer sind stark von Daten abhängig: Anweisungen verwenden die Ergebnisse der vorherigen.  Hier gibt es keine ungewöhnlichen Ergebnisse, und das sollte es auch nicht geben.  Aber jetzt ist der Overhead, der in diesem oder jenem Fall auftritt, klar.  Einige offensichtliche Ergebnisse.  Wenn der Algorithmus sehr häufige Zugriffe nach Index beinhaltet, ist es sinnvoll, das Blatt durch ein Array zu ersetzen.  Wenn der Aufruf nicht sehr häufig ist, ist es möglicherweise bequemer, ein Blatt zu verwenden, das eine sehr praktische API bietet und keinen so großen Overhead hat (ich erinnere Sie daran, die Erweiterungen des internen Arrays zu überwachen). <br><br>  Lassen Sie uns nun versuchen, die verschiedenen Möglichkeiten zu betrachten, mit denen wir ein zweidimensionales Array angeben können: ein Array von Arrays (gezacktes Array) und ein mehrdimensionales Array (mehrdimensionales Array). <br><br><h4>  4. Mehrdimensionales Array </h4><br>  Scharfer Code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerDimensionalArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] demensionalArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> demensionalArray[index1, index2]; }</code> </pre><br>  Assemblersprache: <br><br><pre> <code class="plaintext hljs">1. mov eax,edx 2. sub eax,dword ptr [r9+18h] 3. cmp eax,dword ptr [r9+10h] 4. jae 00007ff9`00098fe6 5. mov edx,r8d 6. sub edx,dword ptr [r9+1Ch] 7. cmp edx,dword ptr [r9+14h] 8. jae 00007ff9`00098fe6 9. mov ecx,dword ptr [r9+14h] 10. imul rcx,rax 11. mov rax,rdx 12. add rax,rcx 13. mov eax,dword ptr [r9+rax*4+20h]</code> </pre><br>  Grundsätzlich ist alles verständlich - 2 prüft die Grenzen des Arrays, berechnet dann den Index und kehrt um.  Dieses Array wird in einem Fragment gespeichert. <br><br><div class="spoiler">  <b class="spoiler_title">Informationen zur Anleitung:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Nein, nein. </th><th>  Verschmolzene Ups </th><th>  Total uops </th><th>  Latenz </th><th>  Gegenseitiger Durchsatz </th></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td><td>  0-1 </td><td>  0,25 </td></tr><tr><td>  2 </td><td>  1 </td><td>  2 </td><td></td><td>  0,5 </td></tr><tr><td>  3 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  4 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  5 </td><td>  1 </td><td>  1 </td><td>  0-1 </td><td>  0,25 </td></tr><tr><td>  6 </td><td>  1 </td><td>  2 </td><td></td><td>  0,5 </td></tr><tr><td>  7 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  8 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  9 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr><tr><td>  10 </td><td>  1 </td><td>  1 </td><td>  3 </td><td>  1 </td></tr><tr><td>  11 </td><td>  1 </td><td>  1 </td><td>  0-1 </td><td>  0,25 </td></tr><tr><td>  12 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  13 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br><br><h4>  5. Array von Arrays (gezacktes Array) </h4><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerJaggedArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] jaggedArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jaggedArray[index][index2]; }</code> </pre><br>  Assembler: <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r9+8] 2. jae 00007ff9`00098f95 3. movsxd rax,edx 4. mov rax,qword ptr [r9+rax*8+10h] 5. cmp r8d,dword ptr [rax+8] 6. jae 00007ff9`00098f95 7. movsxd rdx,r8d 8. mov eax,dword ptr [rax+rdx*4+10h]</code> </pre><br>  Und das Interessanteste: Wir haben weniger Anweisungen als mit einem speziell für Mehrdimensionalität hergestellten Typ. <br><br><div class="spoiler">  <b class="spoiler_title">Informationen zur Anleitung:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Nein, nein. </th><th>  Verschmolzene Ups </th><th>  Total uops </th><th>  Latenz </th><th>  Gegenseitiger Durchsatz </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  4 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr><tr><td>  5 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  6 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  7 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  8 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br>  Aber zu den letzten beiden Beispielen rate ich Ihnen, nicht zu Schlussfolgerungen zu eilen.  Aufgrund der Tatsache, dass ein zweidimensionales Array ein einzelner Typ ist, der einmal initialisiert wird, wird der Speicher für das gesamte Array in einem großen Fragment zugewiesen.  Dies bietet einen besseren Cache, der die Situation grundlegend ändern kann.  In einem Array von Arrays wird der Speicher für jedes Array separat zugewiesen, sodass es wahrscheinlich ist, dass die Arrays im Speicher zugewiesen und an den für sie am besten geeigneten Stellen eingegeben werden. <br><br>  Für einige ist dieses Verhalten jedoch möglicherweise akzeptabler.  Vielleicht ist in einigen Situationen bekannt, dass die Lebensdauer dieses Exemplars nur von kurzer Dauer ist.  Und um nicht in eine Menge großer Objekte zu fallen (was für den Müllsammler eine Art zweite Generation ist), wo es eine Chance gibt, lange zu bleiben, viel mehr als wir möchten.  Oder nach einiger Zeit möchten wir nur mit bestimmten Zeilen arbeiten, und alles andere kann gelöscht werden.  Außerdem ist geplant, mit dem Typ zu arbeiten, indem auf zufällige inkonsistente Elemente verwiesen wird, wenn der Cache nicht normal funktionieren kann. <br><br>  Wenn Sie ein Array von Arrays verwenden, ist es auch wahrscheinlicher, dass der Garbage Collector nicht zum Komprimieren provoziert wird, sondern dass es sich um einen Sweep handelt.  Erinnerung: Beim Fragmentieren des Speichers kann die Gesamtmenge an freiem Speicherplatz für ein neues Objekt ausreichend sein, es gibt jedoch keinen durchgehenden freien Bereich mit der erforderlichen Menge.  In diesem Fall wird eine Verdichtung durchgeführt - Objekte mit dem Ziel der Defragmentierung bewegen.  Wenn wir in der Lage sind, eine kontinuierliche Strecke des freien Speichers für ein neues Objekt aufzunehmen, können wir das Objekt einfach in diesen freien Raum eingeben.  Dies wird als Sweep bezeichnet. <br><br>  Ich hoffe, diese Informationen helfen Ihnen, die richtigen Schlussfolgerungen zu ziehen und Ihre Meinung in der Diskussion über die Verwendung zu untermauern. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450428/">https://habr.com/ru/post/de450428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450416/index.html">Wie Shareware-VPN-Anbieter Ihre Daten verkaufen</a></li>
<li><a href="../de450418/index.html">Die Kunst, organische 3D-Modelle zu erstellen: Subdermale Shader</a></li>
<li><a href="../de450420/index.html">Warum Data Science-Teams Universal brauchen, keine Spezialisten</a></li>
<li><a href="../de450422/index.html">Die Einschränkungen von Bilderkennungsalgorithmen</a></li>
<li><a href="../de450426/index.html">2011 gegen AM4. Dinosaurier gegen Säugetiere</a></li>
<li><a href="../de450430/index.html">Was ist ein Staubangriff?</a></li>
<li><a href="../de450432/index.html">Nun, wo ist sie?</a></li>
<li><a href="../de450436/index.html">Was ist ein Coding Bootcamp?</a></li>
<li><a href="../de450438/index.html">Warum wäre Contact Center-Automatisierung ohne CRM eine schreckliche Dunkelheit?</a></li>
<li><a href="../de450440/index.html">Über Steine ​​vom Himmel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>