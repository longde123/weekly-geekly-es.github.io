<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘²ğŸ¿ ğŸ“† ğŸš¥ Bagaimana dan mengapa kami menulis layanan scalable yang sangat dimuat untuk 1C: Enterprise: Java, PostgreSQL, Hazelcast ğŸ‘©ğŸ»â€ğŸŒ¾ ğŸ§–ğŸ» ğŸš¹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini, kita akan berbicara tentang bagaimana dan mengapa kami mengembangkan Sistem Interaksi - mekanisme yang mentransfer informasi antara...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana dan mengapa kami menulis layanan scalable yang sangat dimuat untuk 1C: Enterprise: Java, PostgreSQL, Hazelcast</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/1c/blog/422903/">  Dalam artikel ini, kita akan berbicara tentang bagaimana dan mengapa kami mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem Interaksi</a> - mekanisme yang mentransfer informasi antara aplikasi klien dan 1C: Server perusahaan - dari menetapkan tugas hingga memikirkan arsitektur dan detail implementasi. <br><br>  Sistem Interaksi (selanjutnya disebut CB) adalah sistem pesan toleransi kesalahan yang didistribusikan dengan pengiriman yang terjamin.  CB dirancang sebagai layanan yang sangat sarat dengan skalabilitas tinggi, dan tersedia baik sebagai layanan online (disediakan oleh 1C) dan sebagai produk sirkulasi yang dapat digunakan pada kapasitas servernya. <br><br>  CB menggunakan penyimpanan terdistribusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hazelcast</a> dan mesin pencari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Elasticsearch</a> .  Kami juga akan berbicara tentang Java dan bagaimana kami skala PostgreSQL secara horizontal. <br><img src="https://habrastorage.org/webt/gh/nq/sq/ghnqsqdgkb0i4ze_7ig8blrfilk.png" alt="gambar"><br><a name="habracut"></a><br><br><h2>  Pernyataan masalah </h2><br>  Untuk menjelaskan mengapa kami membuat Sistem Interaksi, saya akan memberi tahu Anda sedikit tentang bagaimana pengembangan aplikasi bisnis dalam 1C bekerja. <br><br>  Untuk mulai dengan, sedikit tentang kami untuk mereka yang belum tahu apa yang kami lakukan :) Kami menciptakan 1C: platform teknologi perusahaan.  Platform ini mencakup alat untuk mengembangkan aplikasi bisnis, serta runtime, yang memungkinkan aplikasi bisnis untuk bekerja di lingkungan lintas platform. <br><br><h3>  Paradigma pengembangan client-server </h3><br>  Aplikasi bisnis yang dibuat di "1C: Enterprise" beroperasi dalam arsitektur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klien-server</a> tiga tingkat "DBMS - server aplikasi - klien".  Kode aplikasi yang ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahasa tertanam 1C</a> dapat dijalankan di server aplikasi atau di klien.  Semua bekerja dengan objek aplikasi (direktori, dokumen, dll.), Serta membaca dan menulis ke database, dilakukan hanya di server.  Fungsionalitas bentuk dan antarmuka perintah juga diterapkan di server.  Klien menerima, membuka dan menampilkan formulir, "berkomunikasi" dengan pengguna (peringatan, pertanyaan ...), perhitungan kecil dalam bentuk yang memerlukan reaksi cepat (misalnya, mengalikan harga dengan jumlah), bekerja dengan file lokal, bekerja dengan peralatan. <br><br>  Dalam kode aplikasi, tajuk prosedur dan fungsi harus secara eksplisit menunjukkan di mana kode akan dieksekusi - menggunakan arahan &amp; Di Klien / &amp; Di Server (&amp; AtClient / &amp; AtServer dalam versi bahasa Inggris).  Pengembang di 1C akan mengoreksi saya sekarang, mengatakan bahwa sebenarnya ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih banyak</a> arahan, tetapi bagi kami ini tidak penting sekarang. <br><br>  Kode server dapat dipanggil dari kode klien, tetapi kode klien tidak dapat dipanggil dari kode server.  Ini adalah batasan mendasar yang kami buat karena sejumlah alasan.  Secara khusus, karena kode server harus ditulis sehingga dieksekusi secara merata, di mana pun namanya - dari klien atau dari server.  Dan dalam hal memanggil kode server dari kode server lain, klien tidak ada.  Dan karena selama eksekusi kode server, klien yang menyebabkannya bisa menutup, keluar dari aplikasi, dan server tidak akan memanggil siapa pun. <br><br><img src="https://habrastorage.org/webt/3e/pb/eh/3epbeh_fc7t4yipr5halnamtbmg.png" alt="gambar"><br>  <b>Kode yang memproses klik tombol: panggilan prosedur server dari klien akan berfungsi, panggilan prosedur klien dari server tidak akan</b> <br><br>  Ini berarti bahwa jika kami ingin mentransfer beberapa pesan ke aplikasi klien dari server, misalnya, bahwa pembentukan laporan "lama bermain" telah berakhir dan laporan dapat dilihat, kami tidak memiliki metode seperti itu.  Kita harus pergi ke trik, misalnya, dari kode klien untuk polling server secara berkala.  Tetapi pendekatan ini memuat sistem dengan panggilan yang tidak perlu, dan memang tidak terlihat sangat elegan. <br><br>  Dan ada juga kebutuhan, misalnya, ketika panggilan telepon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SIP</a> tiba, beri tahu aplikasi klien tentang hal itu sehingga dengan jumlah pemanggil ia menemukannya di basis data pihak lawan dan memperlihatkan informasi pengguna tentang pihak lawan panggilan.  Atau, misalnya, setelah menerima pesanan di gudang, beri tahu aplikasi klien tentang hal ini.  Secara umum, ada banyak kasus di mana mekanisme seperti itu akan berguna. <br><br><h3>  Sebenarnya pementasan </h3><br>  Buat mesin olahpesan.  Cepat, andal, dengan pengiriman terjamin, dengan kemampuan mencari pesan secara fleksibel.  Berdasarkan mekanisme, mengimplementasikan messenger (pesan, panggilan video) yang berfungsi di dalam aplikasi 1C. <br><br>  Desain sistem yang dapat diskalakan secara horizontal.  Peningkatan beban harus ditutup dengan meningkatkan jumlah node. <br><br><h2>  Implementasi </h2><br>  Kami memutuskan untuk tidak menanamkan bagian server SV langsung ke platform 1C: Enterprise, tetapi untuk mengimplementasikannya sebagai produk terpisah, API yang dapat dipanggil dari kode aplikasi 1C.  Ini dilakukan karena sejumlah alasan, yang utamanya - saya ingin memungkinkan untuk bertukar pesan antara aplikasi 1C yang berbeda (misalnya, antara Kantor Perdagangan dan Akuntansi).  Aplikasi 1C yang berbeda dapat berjalan pada versi 1C yang berbeda: platform Enterprise, berada di server yang berbeda, dll.  Dalam kondisi seperti itu, penerapan CB sebagai produk terpisah yang terletak "di sisi" instalasi 1C adalah solusi optimal. <br><br>  Jadi, kami memutuskan untuk menjadikan CB sebagai produk terpisah.  Untuk perusahaan kecil, kami sarankan untuk menggunakan server CB yang kami instal di cloud kami (wss: //1cdialog.com) untuk menghindari overhead yang terkait dengan menginstal dan mengkonfigurasi server secara lokal.  Pelanggan besar, bagaimanapun, mungkin merasa pantas untuk menginstal server CB mereka sendiri di fasilitas mereka.  Kami menggunakan pendekatan serupa di produk SaaS berbasis cloud <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1cFresh</a> kami - dirilis sebagai produk sirkulasi untuk pemasangan oleh pelanggan dan juga digunakan di cloud kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://1cfresh.com/</a> . <br><br><h3>  Aplikasi </h3><br>  Untuk load balancing dan toleransi kesalahan, kami tidak akan menerapkan satu aplikasi Java, tetapi beberapa, kami akan menempatkan load balancer di depannya.  Jika Anda perlu mentransfer pesan dari node ke node - gunakan terbitkan / berlangganan di Hazelcast. <br><br>  Komunikasi klien dengan server - oleh websocket.  Ini sangat cocok untuk sistem waktu nyata. <br><br><h3>  Tembolok yang didistribusikan </h3><br>  Pilih antara Redis, Hazelcast dan Ehcache.  Di halaman 2015.  Redis baru saja meluncurkan cluster baru (terlalu baru, menakutkan), ada Sentinel dengan banyak pembatasan.  Ehcache tidak tahu bagaimana cara merakit menjadi sebuah cluster (fungsi ini muncul kemudian).  Kami memutuskan untuk mencoba dengan Hazelcast 3.4. <br>  Hazelcast akan pergi ke cluster di luar kotak.  Dalam mode single-node, itu tidak terlalu berguna dan hanya bisa muat sebagai cache - tidak tahu cara membuang data ke disk, kehilangan satu node - kehilangan data.  Kami menyebarkan beberapa Hazelcasts di antaranya kami mencadangkan data penting.  Cache bukan cadangan - sayang sekali. <br><br>  Bagi kami, Hazelcast adalah: <br><br><ul><li>  Repositori sesi pengguna.  Setiap kali, pergi ke database untuk suatu sesi adalah waktu yang lama, jadi kami menempatkan semua sesi di Hazelcast. </li><li>  Cache.  Mencari profil pengguna - periksa di cache.  Menulis pesan baru - taruh di cache. </li><li>  Topik untuk mengkomunikasikan instance aplikasi.  Noda menghasilkan suatu acara dan memasukkannya ke dalam topik Hazelcast.  Node aplikasi lain yang berlangganan topik ini menerima dan memproses acara tersebut. </li><li>  Kunci kluster.  Misalnya, kami membuat diskusi tentang kunci unik (diskusi-tunggal dalam kerangka kerja 1C basis data): </li></ul><br><pre><code class="java hljs">conversationKeyChecker.check(<span class="hljs-string"><span class="hljs-string">""</span></span>); doInClusterLock(<span class="hljs-string"><span class="hljs-string">""</span></span>, () -&gt; { conversationKeyChecker.check(<span class="hljs-string"><span class="hljs-string">""</span></span>); createChannel(<span class="hljs-string"><span class="hljs-string">""</span></span>); });</code> </pre> <br>  Diperiksa tidak ada saluran.  Mereka mengambil kunci, memeriksa lagi, menciptakan.  Jika Anda tidak memeriksa kunci setelah mengambilnya, maka ada kemungkinan bahwa utas lain pada saat itu juga memeriksa dan sekarang akan mencoba membuat diskusi yang sama - tetapi sudah ada.  Tidak mungkin untuk melakukan penguncian melalui java Lock yang disinkronkan atau biasa.  Melalui basis - perlahan, dan basis sangat disayangkan, melalui Hazelcast - apa yang Anda butuhkan. <br><br><h3>  Memilih DBMS </h3><br>  Kami memiliki pengalaman luas dan sukses bekerja dengan PostgreSQL dan berkolaborasi dengan pengembang DBMS ini. <br><br>  PostgreSQL tidak mudah dengan sebuah cluster - ia memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XC</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Citus</a> , tetapi, secara umum, ini bukan noSQL, yang keluar dari kotak.  NoSQL tidak dianggap sebagai repositori utama, cukup kami mengambil Hazelcast, yang belum pernah kami kerjakan sebelumnya. <br><br>  Karena Anda perlu mengukur basis data relasional, itu artinya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sharding</a> .  Seperti yang Anda ketahui, saat sharding, kami membagi basis data menjadi beberapa bagian sehingga masing-masing dapat dipindahkan ke server yang terpisah. <br><br>  Versi pertama dari sharding kami menyiratkan kemampuan untuk mendistribusikan masing-masing tabel aplikasi kami ke server yang berbeda dalam proporsi yang berbeda.  Ada banyak pesan di server A - tolong, mari kita transfer bagian dari tabel ini ke server B. Solusi semacam itu hanya berteriak tentang optimasi prematur, jadi kami memutuskan untuk membatasi diri pada pendekatan multi-tenant. <br><br>  Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membaca</a> tentang multi-tenant, misalnya, di situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Citus Data</a> . <br><br>  Dalam SV ada konsep aplikasi dan pelanggan.  Aplikasi adalah instalasi khusus aplikasi bisnis, seperti ERP atau Akuntansi, dengan penggunanya dan data bisnis.  Pelanggan adalah organisasi atau individu yang atas nama aplikasi terdaftar di server CB.  Pelanggan dapat mendaftarkan beberapa aplikasi, dan aplikasi ini dapat saling bertukar pesan.  Pelanggan juga menjadi penyewa dalam sistem kami.  Pesan dari beberapa pelanggan bisa dalam satu basis fisik;  jika kita melihat bahwa beberapa pelanggan mulai menghasilkan banyak lalu lintas - kita membawanya ke basis fisik yang terpisah (atau bahkan server database terpisah). <br><br>  Kami memiliki basis data utama tempat tabel perutean dengan informasi tentang lokasi semua basis data pelanggan disimpan. <br><br><img src="https://habrastorage.org/webt/yf/3k/bo/yf3kboqvabg3ljf791sdlpn0zay.png" alt="gambar"><br><br>  Agar basis data utama bukan hambatan, kami menyimpan tabel perutean (dan data lainnya yang sering diminta) di cache. <br><br>  Jika basis data pelanggan mulai melambat, kami akan memotongnya menjadi partisi di dalamnya.  Pada proyek lain, kami menggunakan pg_pathman untuk mempartisi tabel besar. <br><br>  Karena kehilangan pesan pengguna adalah buruk, kami mendukung basis data kami dengan replika.  Kombinasi replika sinkron dan asinkron memungkinkan Anda aman jika kehilangan basis data utama.  Kehilangan pesan hanya akan terjadi jika terjadi kegagalan simultan dari database utama dan replika sinkronnya. <br><br>  Jika replika sinkron hilang, replika asinkron menjadi sinkron. <br>  Jika database utama hilang, replika sinkron menjadi basis data utama, replika asinkron menjadi replika sinkron. <br><br><h3>  Elasticsearch untuk pencarian </h3><br>  Karena, antara lain, CB juga merupakan pembawa pesan, di sini Anda memerlukan pencarian yang cepat, nyaman dan fleksibel, dengan mempertimbangkan morfologi, dengan pertandingan yang tidak akurat.  Kami memutuskan untuk tidak menemukan kembali roda dan menggunakan mesin pencari Elasticsearch gratis, berdasarkan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lucene</a> .  Kami juga menggunakan Elasticsearch dalam sebuah cluster (master - data - data) untuk menghilangkan masalah jika terjadi kegagalan node aplikasi. <br><br>  Di github, kami menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin morfologi Rusia</a> untuk Elasticsearch dan menggunakannya.  Dalam indeks Elasticsearch, kami menyimpan akar kata-kata (yang didefinisikan oleh plugin) dan N-gram.  Saat pengguna memasukkan teks untuk mencari, kami mencari teks yang diketik di antara N-gram.  Saat disimpan dalam indeks, kata "teks" akan dibagi menjadi N-gram berikut: <br><br>  [itu, tech, tex, teks, teks, ek, ex, ekst, eksts, ks, kst, kst, st, st, you,], <br><br>  Dan juga akar kata "teks" akan disimpan.  Pendekatan ini memungkinkan Anda untuk mencari di awal, di tengah, dan di akhir kata. <br><br><h2>  Gambaran keseluruhan </h2><br><img src="https://habrastorage.org/webt/wo/w3/ke/wow3ke8dq1cqrb_ujsjm4uhevfm.png" alt="gambar"><br>  Mengulang gambar dari awal artikel, tetapi dengan penjelasan: <br><br><ul><li>  Penyeimbang internet;  kami punya nginx, bisa apa saja. </li><li>  Contoh aplikasi Java berkomunikasi satu sama lain melalui Hazelcast. </li><li>  Untuk bekerja dengan soket web kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Netty</a> . </li><li>  Aplikasi Java yang ditulis dalam Java 8, terdiri dari bundel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OSGi</a> .  Rencana - migrasi ke Java 10 dan transisi ke modul. </li></ul><br><h2>  Pengembangan dan pengujian </h2><br>  Dalam proses pengembangan dan pengujian CB, kami menemukan sejumlah fitur menarik dari produk yang digunakan oleh kami. <br><br><h3>  Muat pengujian dan kebocoran memori </h3><br>  Rilis setiap rilis CB adalah stress testing.  Itu berhasil ketika: <br><br><ul><li>  Tes bekerja selama beberapa hari dan tidak ada penolakan layanan </li><li>  Waktu respons untuk operasi utama tidak melebihi ambang batas nyaman </li><li>  Penurunan kinerja dibandingkan dengan versi sebelumnya tidak lebih dari 10% </li></ul><br>  Kami mengisi basis uji dengan data - untuk ini kami mendapatkan informasi tentang pelanggan paling aktif dari server produksi, kalikan jumlahnya dengan 5 (jumlah pesan, diskusi, pengguna) dan kami menguji. <br><br>  Kami melakukan pengujian beban sistem interaksi dalam tiga konfigurasi: <br><br><ol><li>  Tes stres </li><li>  Koneksi saja </li><li>  Registrasi Pelanggan </li></ol><br>  Selama stress test, kami memulai beberapa ratus utas, dan mereka tanpa henti memuat sistem: menulis pesan, membuat diskusi, mendapatkan daftar pesan.  Kami mensimulasikan tindakan pengguna biasa (dapatkan daftar pesan saya yang belum dibaca, menulis kepada seseorang) dan solusi perangkat lunak (mentransfer paket dengan konfigurasi yang berbeda, memproses pemberitahuan). <br><br>  Sebagai contoh, ini adalah bagian dari tes stres: <br><br><ul><li>  Pengguna masuk. <br><ul><li>  Minta Diskusi Belum Dibaca </li><li>  Kesempatan 50% untuk membaca pesan </li><li>  Dengan 50% probabilitas menulis pesan </li><li>  Pengguna selanjutnya: <br><ul><li>  Dengan 20% kemungkinan menciptakan diskusi baru. </li><li>  Secara acak memilih salah satu diskusinya </li><li>  Masuk ke dalam </li><li>  Minta pesan, profil pengguna </li><li>  Membuat lima pesan yang ditujukan kepada pengguna acak dari diskusi ini. </li><li>  Keluar dari diskusi </li><li>  Diulang 20 kali </li><li>  Logout, kembali ke awal skrip </li></ul><br></li><li>  Bot obrolan memasuki sistem (mengemulasikan pertukaran pesan dari kode solusi yang diterapkan) <br><br><ul><li>  Dengan kemungkinan 50% menciptakan saluran baru untuk pertukaran data (diskusi khusus) </li><li>  Dengan probabilitas 50% menulis pesan ke salah satu saluran yang ada </li></ul><br></li></ul><br></li></ul><br>  Skenario "Hanya Koneksi" muncul karena suatu alasan.  Ada situasi: pengguna menghubungkan sistem, tetapi belum terlibat.  Setiap pengguna di pagi hari pukul 09:00 menyalakan komputer, membuat koneksi ke server dan diam.  Orang-orang ini berbahaya, ada banyak dari mereka - dari paket mereka hanya memiliki PING / PONG, tetapi mereka menjaga koneksi ke server (mereka tidak dapat menyimpannya - tetapi tiba-tiba pesan baru).  Tes mereproduksi situasi ketika dalam setengah jam sejumlah besar pengguna tersebut mencoba masuk ke sistem.  Ini terlihat seperti tes stres, tetapi berfokus tepat pada pintu masuk pertama ini - sehingga tidak ada kegagalan (seseorang tidak menggunakan sistem, tetapi sudah jatuh - sulit untuk menemukan sesuatu yang lebih buruk). <br><br>  Skenario pendaftaran pelanggan berasal dari peluncuran pertama.  Kami melakukan tes stres dan yakin bahwa sistem tidak memperlambat korespondensi.  Tetapi pengguna pergi dan pendaftaran mulai jatuh dalam batas waktu.  Saat mendaftar, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">/ dev / random</a> , yang terkait dengan entropi sistem.  Server tidak berhasil mengakumulasi cukup entropi dan membeku selama puluhan detik ketika meminta SecureRandom baru.  Ada banyak jalan keluar dari situasi ini, misalnya: beralih ke yang kurang aman / dev / urandom, letakkan papan khusus yang menghasilkan entropi, buat angka acak terlebih dahulu dan simpan di pool.  Kami untuk sementara menutup masalah dengan kumpulan, tetapi sejak itu kami telah menjalankan tes terpisah untuk mendaftarkan pelanggan baru. <br><br>  Sebagai generator beban kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JMeter</a> .  Dia tidak tahu cara bekerja dengan soket web, diperlukan plug-in.  Yang pertama dalam hasil pencarian untuk "jmeter websocket" adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel dengan BlazeMeter</a> , yang merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin dari Maciej Zaleski</a> . <br><br>  Dengan dia kami memutuskan untuk memulai. <br><br>  Hampir segera setelah dimulainya pengujian serius, kami menemukan bahwa kebocoran memori dimulai pada JMeter. <br><br>  Plugin ini adalah cerita besar yang terpisah, dengan 176 bintang memiliki 132 garpu di github.  Penulis sendiri tidak berkomitmen untuk itu sejak 2015 (kami mengambilnya di 2015, maka ini tidak menimbulkan kecurigaan), beberapa masalah github tentang kebocoran memori, 7 permintaan tarik tertutup. <br>  Jika Anda memutuskan untuk melakukan pengujian beban dengan plugin ini, perhatikan diskusi berikut: <br><br><ol><li>  Dalam lingkungan multi-utas, LinkedList biasa digunakan, sebagai hasilnya, mereka menerima <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NPE</a> dalam runtime.  Itu diselesaikan baik dengan beralih ke ConcurrentLinkedDeque, atau dengan blok yang disinkronkan.  Mereka memilih opsi pertama untuk diri mereka sendiri ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/maciejzaleski/JMeter-WebSocketSampler/issues/43</a> ). </li><li>  Kebocoran memori, putuskan sambungan tidak menghapus informasi koneksi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/maciejzaleski/JMeter-WebSocketSampler/issues/44</a> ). </li><li>  Dalam mode streaming (ketika soket web tidak menutup pada akhir sampel, tetapi digunakan lebih lanjut dalam rencana), pola Respons ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/maciejzaleski/JMeter-WebSocketSampler/issues/19</a> ) tidak berfungsi. </li></ol><br>  Ini adalah salah satu yang ada di github.  Apa yang telah kami lakukan: <br><br><ol><li>  Mereka mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">garpu Elyran Kogan</a> (@elyrank) - masalah 1 dan 3 diperbaiki di dalamnya </li><li>  Memecahkan masalah 2 </li><li>  Dermaga diperbarui dari 9.2.14 hingga 9.3.12 </li><li>  SimpleDateFormat yang Dibungkus di ThreadLocal;  SimpleDateFormat bukan thread aman, yang menyebabkan runtime NPE </li><li>  Dieliminasi satu lagi kebocoran memori (koneksi ditutup dengan tidak benar ketika terputus) </li></ol><br>  Namun itu mengalir! <br><br>  Ingatan mulai berakhir bukan dalam sehari, melainkan dua.  Sama sekali tidak ada waktu lagi, mereka memutuskan untuk menjalankan lebih sedikit utas, tetapi pada empat agen.  Itu seharusnya sudah cukup untuk setidaknya satu minggu. <br><br>  Dua hari telah berlalu ... <br><br>  Sekarang ingatan mulai habis di Hazelcast.  Terbukti dalam log bahwa setelah beberapa hari pengujian, Hazelcast mulai mengeluh tentang kurangnya memori, dan setelah beberapa saat, cluster berantakan, dan node terus mati secara individual.  Kami menghubungkan JVisualVM ke hazelcast dan melihat "naiknya gergaji" - ia secara teratur memanggil GC, tetapi tidak dapat menghapus ingatannya. <br><br><img src="https://habrastorage.org/webt/ha/uc/5y/hauc5ydqebpmxtfirqalulaandi.png" alt="gambar"><br><br>  Ternyata di hazelcast 3.4, saat menghapus peta / multiMap (map.destroy ()), memori tidak sepenuhnya dibebaskan: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/hazelcast/hazelcast/issues/6317</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/hazelcast/hazelcast/issues/4888</a> <br><br>  Sekarang bug diperbaiki di 3.5, tapi kemudian itu masalah.  Kami membuat multi-peta baru dengan nama dinamis dan dihapus sesuai dengan logika kami.  Kode tersebut terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication auth, String sub)</span></span></span><span class="hljs-function"> </span></span>{ MultiMap&lt;UUID, Authentication&gt; sessions = instance.getMultiMap(sub); sessions.put(auth.getUserId(), auth); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication auth, String sub)</span></span></span><span class="hljs-function"> </span></span>{ MultiMap&lt;UUID, Authentication&gt; sessions = instance.getMultiMap(sub); sessions.remove(auth.getUserId(), auth); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sessions.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { sessions.destroy(); } }</code> </pre> <br>  Hubungi: <br><br><pre> <code class="java hljs">service.join(auth1, <span class="hljs-string"><span class="hljs-string">"____UUID1"</span></span>); service.join(auth2, <span class="hljs-string"><span class="hljs-string">"____UUID1"</span></span>);</code> </pre> <br>  multiMap dibuat untuk setiap langganan dan dihapus ketika tidak diperlukan.  Kami memutuskan bahwa kami akan memulai Peta &lt;String, Set&gt;, kuncinya akan menjadi nama langganan, dan nilainya akan menjadi pengidentifikasi sesi (dari mana Anda kemudian bisa mendapatkan ID pengguna, jika perlu). <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication auth, String sub)</span></span></span><span class="hljs-function"> </span></span>{ addValueToMap(sub, auth.getSessionId()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication auth, String sub)</span></span></span><span class="hljs-function"> </span></span>{ removeValueFromMap(sub, auth.getSessionId()); }</code> </pre> <br>  Grafik diluruskan. <br><br><img src="https://habrastorage.org/webt/li/_z/ai/li_zaiochcpbgvviybycfvzslz4.png" alt="gambar"><br><br><h4>  Apa lagi yang kami pelajari tentang stress testing </h4><br><ol><li>  JSR223 perlu ditulis dalam groovy dan cache kompilasi yang diaktifkan - ini jauh lebih cepat.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan</a> </li><li>  Grafik Jmeter-Plugins lebih mudah dipahami daripada standar.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan</a> </li></ol><br><br><h3>  Tentang pengalaman kami dengan Hazelcast </h3><br>  Hazelcast adalah produk baru bagi kami, kami mulai bekerja dengannya dari versi 3.4.1, sekarang server produksi kami memiliki versi 3.9.2 (pada saat penulisan, Hazelcast versi terbaru adalah 3.10). <br><br><h4>  Pembuatan ID </h4><br>  Kami mulai dengan pengidentifikasi integer.  Mari kita bayangkan bahwa kita membutuhkan Long lagi untuk entitas baru.  Urutan tidak sesuai dalam database, tabel berpartisipasi dalam sharding - ternyata ada pesan ID = 1 di DB1 dan ID pesan = 1 di DB2, Anda tidak dapat memasukkan ID seperti itu di Elasticsearch, baik di Hazelcast, tetapi yang terburuk adalah jika Anda ingin mengurangi data dari dua basis data menjadi satu (misalnya, memutuskan bahwa satu basis data cukup untuk pelanggan ini).  Anda dapat membuat beberapa AtomicLong di Hazelcast dan menyimpan penghitung di sana, maka kinerja mendapatkan ID baru adalah incrementAndGet ditambah waktu untuk permintaan di Hazelcast.  Tetapi ada sesuatu yang lebih optimal tentang Hazelcast - FlakeIdGenerator.  Setiap klien diberi rentang ID saat kontak, misalnya, yang pertama dari 1 hingga 10.000, yang kedua dari 10.001 hingga 20.000, dan seterusnya.  Sekarang klien dapat mengeluarkan pengidentifikasi baru secara mandiri hingga rentang yang dikeluarkan untuk itu berakhir.  Ini bekerja dengan cepat, tetapi ketika Anda me-restart aplikasi (dan klien Hazelcast), urutan baru dimulai - maka ada celah, dll.  Selain itu, pengembang tidak begitu jelas mengapa ID adalah integer, tetapi mereka berjalan sangat berbeda.  Kami semua menimbang dan beralih ke UUID. <br><br>  Omong-omong, bagi mereka yang ingin menjadi seperti Twitter, ada perpustakaan Snowcast - ini adalah implementasi Snowflake di atas Hazelcast.  Anda bisa melihatnya di sini: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/noctarius/snowcast</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/twitter/snowflake</a> <br><br>  Tapi kami belum meraih tangannya. <br><br><h4>  TransactionalMap.replace </h4><br>  Kejutan lain: TransactionalMap.replace tidak berfungsi.  Ini tesnya: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceInMap_putsAndGetsInsideTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ hazelcastInstance.executeTransaction(context -&gt; { HazelcastTransactionContextHolder.setContext(context); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { context.getMap(<span class="hljs-string"><span class="hljs-string">"map"</span></span>).put(<span class="hljs-string"><span class="hljs-string">"key"</span></span>, <span class="hljs-string"><span class="hljs-string">"oldValue"</span></span>); context.getMap(<span class="hljs-string"><span class="hljs-string">"map"</span></span>).replace(<span class="hljs-string"><span class="hljs-string">"key"</span></span>, <span class="hljs-string"><span class="hljs-string">"oldValue"</span></span>, <span class="hljs-string"><span class="hljs-string">"newValue"</span></span>); String value = (String) context.getMap(<span class="hljs-string"><span class="hljs-string">"map"</span></span>).get(<span class="hljs-string"><span class="hljs-string">"key"</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"newValue"</span></span>, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { HazelcastTransactionContextHolder.clearContext(); } }); } Expected : newValue Actual : oldValue</code> </pre> <br>  Saya harus menulis pengganti saya menggunakan getForUpdate: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceInMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String mapName, K key, V oldValue, V newValue)</span></span></span><span class="hljs-function"> </span></span>{ TransactionalTaskContext context = HazelcastTransactionContextHolder.getContext(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { log.trace(<span class="hljs-string"><span class="hljs-string">"[CACHE] Replacing value in a transactional map"</span></span>); TransactionalMap&lt;K, V&gt; map = context.getMap(mapName); V value = map.getForUpdate(key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldValue.equals(value)) { map.put(key, newValue); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } log.trace(<span class="hljs-string"><span class="hljs-string">"[CACHE] Replacing value in a not transactional map"</span></span>); IMap&lt;K, V&gt; map = hazelcastInstance.getMap(mapName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map.replace(key, oldValue, newValue); }</code> </pre> <br>  Uji tidak hanya struktur data reguler, tetapi juga versi transaksionalnya.  Itu terjadi bahwa IMap bekerja, tetapi TransactionalMap hilang. <br><br><h4>  Pasang JAR baru tanpa downtime </h4><br>  Pertama, kami memutuskan untuk merekam objek kelas kami di Hazelcast.  Sebagai contoh, kami memiliki Aplikasi kelas, kami ingin menyimpan dan membacanya.  Simpan: <br><br><pre> <code class="java hljs">IMap&lt;UUID, Application&gt; map = hazelcastInstance.getMap(<span class="hljs-string"><span class="hljs-string">"application"</span></span>); map.set(id, application);</code> </pre> <br>  Kami membaca: <br><br><pre> <code class="java hljs">IMap&lt;UUID, Application&gt; map = hazelcastInstance.getMap(<span class="hljs-string"><span class="hljs-string">"application"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map.get(id);</code> </pre> <br>  Semuanya berfungsi.  Kemudian kami memutuskan untuk membuat indeks di Hazelcast untuk mencarinya: <br><br><pre> <code class="java hljs">map.addIndex(<span class="hljs-string"><span class="hljs-string">"subscriberId"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>);</code> </pre> <br>  Dan ketika menulis entitas baru, mereka mulai menerima ClassNotFoundException.  Hazelcast mencoba menambah indeks, tetapi tidak tahu apa-apa tentang kelas kami dan ingin memiliki JAR dengan kelas ini.  Kami melakukannya, semuanya berfungsi, tetapi muncul masalah baru: bagaimana cara memperbarui JAR tanpa menghentikan cluster sepenuhnya?  Hazelcast tidak mengambil JAR baru selama peningkatan pod-wise.  Pada saat ini, kami memutuskan bahwa kami dapat hidup dengan baik tanpa mencari berdasarkan indeks.  Lagi pula, jika Anda menggunakan Hazelcast sebagai penyimpanan nilai kunci, apakah semuanya akan berfungsi?  Tidak juga.  Di sini sekali lagi, perilaku IMAP dan TransactionalMap berbeda.  Di mana IMap tidak masalah, TransactionalMap melempar kesalahan. <br><br>  IMap  Kami menulis 5.000 objek, membacanya.  Segalanya diharapkan. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get5000</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ IMap&lt;UUID, Application&gt; map = hazelcastInstance.getMap(<span class="hljs-string"><span class="hljs-string">"application"</span></span>); UUID subscriberId = UUID.randomUUID(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5000</span></span>; i++) { UUID id = UUID.randomUUID(); String title = RandomStringUtils.random(<span class="hljs-number"><span class="hljs-number">5</span></span>); Application application = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(id, title, subscriberId); map.set(id, application); Application retrieved = map.get(id); assertEquals(id, retrieved.getId()); } }</code> </pre> <br>  Dan itu tidak berfungsi dalam transaksi, kami mendapatkan ClassNotFoundException: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_transaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ IMap&lt;UUID, Application&gt; map = hazelcastInstance.getMap(<span class="hljs-string"><span class="hljs-string">"application_t"</span></span>); UUID subscriberId = UUID.randomUUID(); UUID id = UUID.randomUUID(); Application application = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(id, <span class="hljs-string"><span class="hljs-string">"qwer"</span></span>, subscriberId); map.set(id, application); Application retrievedOutside = map.get(id); assertEquals(id, retrievedOutside.getId()); hazelcastInstance.executeTransaction(context -&gt; { HazelcastTransactionContextHolder.setContext(context); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { TransactionalMap&lt;UUID, Application&gt; transactionalMap = context.getMap(<span class="hljs-string"><span class="hljs-string">"application_t"</span></span>); Application retrievedInside = transactionalMap.get(id); assertEquals(id, retrievedInside.getId()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { HazelcastTransactionContextHolder.clearContext(); } }); }</code> </pre> <br>  Di 3.8, mekanisme Penerapan Kelas Pengguna muncul.  Anda dapat menetapkan satu simpul utama dan memperbarui file JAR di atasnya. <br><br>  Sekarang kami telah sepenuhnya mengubah pendekatan: kami membuat serial dalam JSON dan menyimpannya di Hazelcast.  Hazelcast tidak perlu mengetahui struktur kelas kami, tetapi kami dapat memperbarui tanpa downtime.  Versi objek domain dikendalikan oleh aplikasi.  Versi aplikasi yang berbeda dapat diluncurkan secara bersamaan, dan ada kemungkinan bahwa aplikasi baru menulis objek dengan bidang baru, tetapi yang lama tidak tahu tentang bidang ini.  Dan pada saat yang sama, aplikasi baru membacakan objek yang direkam oleh aplikasi lama, di mana tidak ada bidang baru.  Kami menangani situasi seperti itu di dalam aplikasi, tetapi untuk kesederhanaan kami tidak mengubah atau menghapus bidang, kami hanya memperluas kelas dengan menambahkan bidang baru. <br><br><h3>  Bagaimana kami memberikan kinerja tinggi </h3><br><h4>  Empat perjalanan ke Hazelcast - bagus, dua ke database - buruk </h4><br>  Pergi ke cache untuk data selalu lebih baik daripada dalam database, tetapi Anda tidak ingin menyimpan catatan yang tidak diklaim.  Keputusan tentang apa yang akan di-cache, kami menunda ke tahap terakhir pengembangan.  Ketika fungsionalitas baru dikodekan, kita menyalakan PostgreSQL untuk mencatat semua pertanyaan (log_min_duration_statement ke 0) dan menjalankan pengujian beban selama 20 menit. Menggunakan log yang dikumpulkan, utilitas seperti pgFouine dan pgBadger dapat membuat laporan analitik.  Dalam laporan, kami terutama mencari kueri yang lambat dan sering.  Untuk permintaan yang lambat, kami membangun rencana eksekusi (JELASKAN) dan mengevaluasi apakah permintaan seperti itu dapat dipercepat.  Permintaan yang sering untuk data input yang sama di-cache dengan baik.  Kami mencoba untuk menjaga permintaan "flat", satu tabel per permintaan. <br><br><h2>  Operasi </h2><br>  SV sebagai layanan online diluncurkan pada musim semi 2017, sebagai produk SV terpisah dirilis pada November 2017 (saat itu dalam status beta). <br><br>  Lebih dari satu tahun beroperasi, masalah serius dalam pengoperasian layanan online CB tidak terjadi.  Kami memantau layanan online melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zabbix</a> , mengumpulkan dan menggunakan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bamboo</a> . <br><br>  Kit distribusi server CB dikirimkan dalam bentuk paket asli: RPM, DEB, MSI.  Plus untuk Windows, kami menyediakan satu penginstal dalam bentuk satu EXE, yang memasang server, Hazelcast, dan Elasticsearch pada satu mesin.  Awalnya kami menyebut versi instalasi ini "demo", tetapi sekarang menjadi jelas bahwa ini adalah opsi penyebaran yang paling populer. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422903/">https://habr.com/ru/post/id422903/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422893/index.html">Panduan Node.js, Bagian 1: Informasi Umum dan Cara Memulai</a></li>
<li><a href="../id422895/index.html">Google ingin membunuh URL</a></li>
<li><a href="../id422897/index.html">Buruk, tapi milikku: cara menulis CSS yang benar-benar buruk</a></li>
<li><a href="../id422899/index.html">Di bawah pengawasan yang waspada: cara memantau tarif kenaikan dan menjaga agar katalog VPS tetap mutakhir</a></li>
<li><a href="../id422901/index.html">Monitor detak jantung untuk Putin, atau apa itu Ritmer</a></li>
<li><a href="../id422905/index.html">Tapi katamu Ceph ... apakah dia begitu baik?</a></li>
<li><a href="../id422907/index.html">2018 Robot Vacuum Cleaner Referensi Cepat</a></li>
<li><a href="../id422909/index.html">10 video 404 Festival retro talk paling populer</a></li>
<li><a href="../id422915/index.html">Saya mencari senior tanpa kantor dan cookie: bagaimana kami mengatur pencarian karyawan yang 100% jauh</a></li>
<li><a href="../id422917/index.html">Saya tidak punya mulut, tetapi saya harus berteriak. Refleksi tentang AI dan Etika</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>