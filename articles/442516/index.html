<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèø üíø üíâ Pandas Guide to Big Data Analysis üß£ üßóüèΩ üïß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando se usa la biblioteca de pandas para analizar conjuntos de datos peque√±os, cuyo tama√±o no supera los 100 megabytes, el rendimiento rara vez se c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pandas Guide to Big Data Analysis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442516/"> Cuando se usa la biblioteca de pandas para analizar conjuntos de datos peque√±os, cuyo tama√±o no supera los 100 megabytes, el rendimiento rara vez se convierte en un problema.  Pero cuando se trata del estudio de conjuntos de datos, cuyos tama√±os pueden alcanzar varios gigabytes, los problemas de rendimiento pueden conducir a un aumento significativo en la duraci√≥n del an√°lisis de datos e incluso pueden conducir a la imposibilidad de realizar an√°lisis debido a la falta de memoria. <br><br>  Si bien las herramientas como Spark pueden procesar de manera eficiente grandes conjuntos de datos (desde cientos de gigabytes hasta varios terabytes), para utilizar plenamente sus capacidades, generalmente necesita un hardware bastante potente y costoso.  Y, en comparaci√≥n con los pandas, no difieren en un rico conjunto de herramientas para la limpieza, la investigaci√≥n y el an√°lisis de datos de alta calidad.  Para conjuntos de datos de tama√±o mediano, es mejor intentar usar pandas de manera m√°s eficiente, en lugar de cambiar a otras herramientas. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/gd/jg/60/gdjg60abxgti2otxocpd0ct2uci.jpeg"></a> <br><br>  En el art√≠culo, cuya traducci√≥n publicamos hoy, hablaremos sobre las peculiaridades de trabajar con memoria cuando se usan pandas, y c√≥mo simplemente reducir el consumo de memoria en casi un 90% simplemente seleccionando los tipos de datos apropiados almacenados en las columnas de las estructuras de datos de la tabla del <code>DataFrame</code> . <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Trabajando con datos sobre juegos de beisbol</font> </h2><br>  Trabajaremos con datos sobre juegos de b√©isbol de Grandes Ligas recopilados durante 130 a√±os y tomados de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Retrosheet</a> . <br><br>  Inicialmente, estos datos se presentaron como 127 archivos CSV, pero los combinamos en un conjunto de datos usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">csvkit</a> y agregamos, como la primera fila de la tabla resultante, una fila con nombres de columna.  Si lo desea, puede descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestra versi√≥n de</a> estos datos y experimentar con ellos, leyendo el art√≠culo. <br><br>  Comencemos importando un conjunto de datos y echemos un vistazo a sus primeras cinco l√≠neas.  Puede encontrarlos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> tabla, en el <code>   </code> hoja del <code>   </code> de <code>   </code> . <br><br><pre> <code class="plaintext hljs">import pandas as pd gl = pd.read_csv('game_logs.csv') gl.head()</code> </pre> <br>  A continuaci√≥n se muestra informaci√≥n sobre las columnas m√°s importantes de la tabla con estos datos.  Si desea leer las explicaciones para todas las columnas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> puede encontrar un diccionario de datos para todo el conjunto de datos. <br><br><ul><li>  <code>date</code> - Fecha del juego. </li><li>  <code>v_name</code> : el nombre del equipo invitado. </li><li>  <code>v_league</code> - Liga del equipo visitante. </li><li>  <code>h_name</code> : el nombre del equipo local. </li><li>  <code>h_league</code> - La liga del equipo local. </li><li>  <code>v_score</code> : puntos del equipo visitante. </li><li>  <code>h_score</code> : puntos del equipo local. </li><li>  <code>v_line_score</code> : un resumen de los puntos del equipo invitado, por ejemplo, <code>010000(10)00</code> . </li><li>  <code>h_line_score</code> : un resumen de los puntos del equipo local, por ejemplo, <code>010000(10)0X</code> . </li><li>  <code>park_id</code> : el identificador del campo en el que se jug√≥ el juego. </li><li>  <code>attendance</code> : la cantidad de espectadores. </li></ul><br>  Para encontrar informaci√≥n general sobre el objeto <code>DataFrame</code> , puede usar el m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DataFrame.info ()</a> .  Gracias a este m√©todo, puede aprender sobre el tama√±o de un objeto, sobre los tipos de datos y sobre el uso de la memoria. <br><br>  Por defecto, los pandas, en aras del ahorro de tiempo, <code>DataFrame</code> informaci√≥n aproximada sobre el uso de memoria de un <code>DataFrame</code> .  Estamos interesados ‚Äã‚Äãen informaci√≥n precisa, por lo que estableceremos el par√°metro <code>memory_usage</code> en <code>'deep'</code> . <br><br><pre> <code class="plaintext hljs">gl.info(memory_usage='deep')</code> </pre> <br>  Aqu√≠ est√° la informaci√≥n que logramos obtener: <br><br><pre> <code class="plaintext hljs">&lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 171907 entries, 0 to 171906 Columns: 161 entries, date to acquisition_info dtypes: float64(77), int64(6), object(78) memory usage: 861.6 MB</code> </pre> <br>  Al final result√≥ que, tenemos 171,907 filas y 161 columnas.  La biblioteca de pandas detect√≥ autom√°ticamente los tipos de datos.  Hay 83 columnas con datos num√©ricos y 78 columnas con objetos.  Las columnas de objeto se usan para almacenar datos de cadena y en los casos en que la columna contiene datos de diferentes tipos. <br><br>  Ahora, para comprender mejor c√≥mo puede optimizar el uso de la memoria con este <code>DataFrame</code> , hablemos sobre c√≥mo los pandas almacenan datos en la memoria. <br><br><h2>  <font color="#3AC1EF">Vista interna de un marco de datos</font> </h2><br>  Dentro de los pandas, las columnas de datos se agrupan en bloques con valores del mismo tipo.  Aqu√≠ hay un ejemplo de c√≥mo las primeras 12 columnas de un <code>DataFrame</code> se almacenan en pandas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c70/c63/d35c70c635289a5cecc520c58e662e9a.png"></div><br>  <i><font color="#999999">Representaci√≥n interna de diferentes tipos de datos en pandas</font></i> <br><br>  Puede notar que los bloques no almacenan informaci√≥n de nombre de columna.  Esto se debe al hecho de que los bloques est√°n optimizados para almacenar los valores disponibles en las celdas de la <code>DataFrame</code> objeto <code>DataFrame</code> .  La clase <code>BlockManager</code> es responsable de almacenar informaci√≥n sobre la correspondencia entre los √≠ndices de fila y columna del conjunto de datos y lo que se almacena en bloques del mismo tipo de datos.  Desempe√±a el papel de una API que proporciona acceso a datos b√°sicos.  Cuando leemos, editamos o <code>DataFrame</code> valores, la clase <code>DataFrame</code> interact√∫a con la clase <code>BlockManager</code> para convertir nuestras solicitudes en llamadas a funciones y m√©todos. <br><br>  Cada tipo de datos tiene una clase especializada en el m√≥dulo <code>pandas.core.internals</code> .  Por ejemplo, pandas usa la clase <code>ObjectBlock</code> para representar bloques que contienen columnas de cadena y la clase <code>FloatBlock</code> para representar bloques que contienen columnas que <code>FloatBlock</code> n√∫meros de punto flotante.  Para los bloques que representan valores num√©ricos que parecen n√∫meros enteros o n√∫meros de coma flotante, pandas combina las columnas y las almacena como la <code>ndarray</code> datos <code>ndarray</code> la biblioteca NumPy.  Esta estructura de datos se basa en la matriz C, los valores se almacenan en un bloque continuo de memoria.  Gracias a este esquema de almacenamiento de datos, el acceso a los fragmentos de datos es muy r√°pido. <br><br>  Dado que los datos de diferentes tipos se almacenan por separado, examinamos el uso de la memoria de diferentes tipos de datos.  Comencemos con el uso promedio de memoria para diferentes tipos de datos. <br><br><pre> <code class="plaintext hljs">for dtype in ['float','int','object']:   selected_dtype = gl.select_dtypes(include=[dtype])   mean_usage_b = selected_dtype.memory_usage(deep=True).mean()   mean_usage_mb = mean_usage_b / 1024 ** 2   print("Average memory usage for {} columns: {:03.2f} MB".format(dtype,mean_usage_mb))</code> </pre> <br>  Como resultado, resulta que los indicadores promedio de uso de memoria para datos de diferentes tipos se ven as√≠: <br><br><pre> <code class="plaintext hljs">Average memory usage for float columns: 1.29 MB Average memory usage for int columns: 1.12 MB Average memory usage for object columns: 9.53 MB</code> </pre> <br>  Esta informaci√≥n nos hace comprender que la mayor parte de la memoria se gasta en 78 columnas que almacenan valores de objetos.  Hablaremos m√°s sobre esto m√°s adelante, pero ahora pensemos si podemos mejorar el uso de la memoria con columnas que almacenan datos num√©ricos. <br><br><h2>  <font color="#3AC1EF">Subtipos</font> </h2><br>  Como ya dijimos, los pandas representan valores num√©ricos como estructuras de datos <code>ndarray</code> NumPy y los almacenan en bloques contiguos de memoria.  Este modelo de almacenamiento de datos le permite ahorrar memoria y acceder r√°pidamente a los valores.  Dado que los pandas representan cada valor del mismo tipo utilizando el mismo n√∫mero de bytes, y <code>ndarray</code> estructuras de <code>ndarray</code> almacenan informaci√≥n sobre el n√∫mero de valores, los pandas pueden <code>ndarray</code> r√°pida y precisa la cantidad de memoria consumida por las columnas que almacenan valores num√©ricos. <br><br>  Muchos tipos de datos en pandas tienen muchos subtipos que pueden usar menos bytes para representar cada valor.  Por ejemplo, el tipo <code>float</code> tiene subtipos <code>float16</code> , <code>float32</code> y <code>float64</code> .  El n√∫mero en el nombre del tipo indica el n√∫mero de bits que utiliza el subtipo para representar los valores.  Por ejemplo, en los subtipos reci√©n enumerados, se utilizan 2, 4, 8 y 16 bytes respectivamente para el almacenamiento de datos.  La siguiente tabla muestra los subtipos de los tipos de datos m√°s utilizados en pandas. <br><table><tbody><tr><td>  <sup>Uso de memoria, bytes</sup> <sup><br></sup> </td><td>  <sup>N√∫mero de coma flotante</sup> <sup><br></sup> </td><td>  <sup>Entero</sup> <sup><br></sup> </td><td>  <sup>Entero sin signo</sup> <sup><br></sup> </td><td>  <sup>Fecha y hora</sup> <sup><br></sup> </td><td>  <sup>Valor booleano</sup> <sup><br></sup> </td><td width="75">  <sup>Objeto</sup> <sup><br></sup> </td></tr><tr><td>  <sup>1</sup> <sup><br></sup> </td><td></td><td>  <sup>int8</sup> <sup><br></sup> </td><td>  <sup>uint8</sup> <sup><br></sup> </td><td></td><td>  <sup>bool</sup> <sup><br></sup> </td><td></td></tr><tr><td>  <sup>2</sup> <sup><br></sup> </td><td>  <sup>float16</sup> <sup><br></sup> </td><td>  <sup>int16</sup> <sup><br></sup> </td><td>  <sup>uint16</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>4 4</sup> <sup><br></sup> </td><td>  <sup>float32</sup> <sup><br></sup> </td><td>  <sup>int32</sup> <sup><br></sup> </td><td>  <sup>uint32</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>8</sup> <sup><br></sup> </td><td>  <sup>float64</sup> <sup><br></sup> </td><td>  <sup>int64</sup> <sup><br></sup> </td><td>  <sup>uint64</sup> <sup><br></sup> </td><td>  <sup>datetime64</sup> <sup><br></sup> </td><td></td><td></td></tr><tr><td>  <sup>Capacidad de memoria variable</sup> <sup><br></sup> </td><td></td><td></td><td></td><td></td><td></td><td>  <sup>objeto</sup> <sup><br></sup> </td></tr></tbody></table><br>  Un valor de tipo <code>int8</code> usa 1 byte (8 bits) para almacenar un n√∫mero y puede representar 256 valores binarios (potencia de 2 a 8).  Esto significa que este subtipo se puede usar para almacenar valores en el rango de -128 a 127 (incluido 0). <br><br>  Para verificar los valores m√≠nimos y m√°ximos adecuados para el almacenamiento usando cada subtipo de entero, puede usar el m√©todo <code>numpy.iinfo()</code> .  Considere un ejemplo: <br><br><pre> <code class="plaintext hljs">import numpy as np int_types = ["uint8", "int8", "int16"] for it in int_types:   print(np.iinfo(it))</code> </pre> <br>  Al ejecutar este c√≥digo, obtenemos los siguientes datos: <br><br><pre> <code class="plaintext hljs">Machine parameters for uint8 --------------------------------------------------------------- min = 0 max = 255 --------------------------------------------------------------- Machine parameters for int8 --------------------------------------------------------------- min = -128 max = 127 --------------------------------------------------------------- Machine parameters for int16 --------------------------------------------------------------- min = -32768 max = 32767 ---------------------------------------------------------------</code> </pre> <br>  Aqu√≠ puede prestar atenci√≥n a la diferencia entre los tipos <code>uint</code> (entero sin signo) e <code>int</code> (entero con signo).  Ambos tipos tienen la misma capacidad, pero cuando se almacenan solo valores positivos en columnas, los tipos sin signo permiten un uso m√°s eficiente de la memoria. <br><br><h2>  <font color="#3AC1EF">Optimizaci√≥n del almacenamiento de datos num√©ricos utilizando subtipos.</font> </h2><br>  La funci√≥n <code>pd.to_numeric()</code> se puede usar para convertir tipos num√©ricos a la baja.  Para seleccionar columnas enteras, utilizamos el m√©todo <code>DataFrame.select_dtypes()</code> , luego las optimizamos y comparamos el uso de memoria antes y despu√©s de la optimizaci√≥n. <br><br><pre> <code class="plaintext hljs">#     ,   , #   ,      . def mem_usage(pandas_obj):   if isinstance(pandas_obj,pd.DataFrame):       usage_b = pandas_obj.memory_usage(deep=True).sum()   else: #     ,     DataFrame,   Series       usage_b = pandas_obj.memory_usage(deep=True)   usage_mb = usage_b / 1024 ** 2 #       return "{:03.2f} MB".format(usage_mb) gl_int = gl.select_dtypes(include=['int']) converted_int = gl_int.apply(pd.to_numeric,downcast='unsigned') print(mem_usage(gl_int)) print(mem_usage(converted_int)) compare_ints = pd.concat([gl_int.dtypes,converted_int.dtypes],axis=1) compare_ints.columns = ['before','after'] compare_ints.apply(pd.Series.value_counts)</code> </pre> <br>  Aqu√≠ est√° el resultado de un estudio del consumo de memoria: <br><br> <code>7.87 MB <br> 1.48 MB</code> <br> <table><tbody><tr><td></td><td>  A <br></td><td>  Despues <br></td></tr><tr><td>  uint8 <br></td><td>  NaN <br></td><td>  5.0 <br></td></tr><tr><td>  uint32 <br></td><td>  NaN <br></td><td>  1.0 <br></td></tr><tr><td>  int64 <br></td><td>  6.0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Como resultado, puede ver una ca√≠da en el uso de memoria de 7.9 a 1.5 megabytes, es decir, redujimos el consumo de memoria en m√°s del 80%.  Sin embargo, el impacto general de esta optimizaci√≥n en el <code>DataFrame</code> original no es particularmente fuerte, ya que tiene muy pocas columnas enteras. <br><br>  Hagamos lo mismo con las columnas que contienen n√∫meros de coma flotante. <br><br><pre> <code class="plaintext hljs">gl_float = gl.select_dtypes(include=['float']) converted_float = gl_float.apply(pd.to_numeric,downcast='float') print(mem_usage(gl_float)) print(mem_usage(converted_float)) compare_floats = pd.concat([gl_float.dtypes,converted_float.dtypes],axis=1) compare_floats.columns = ['before','after'] compare_floats.apply(pd.Series.value_counts)</code> </pre> <br>  El resultado es el siguiente: <br><br> <code>100.99 MB <br> 50.49 MB</code> <br> <table><tbody><tr><td></td><td>  A <br></td><td>  Despues <br></td></tr><tr><td>  float32 <br></td><td>  NaN <br></td><td>  77,0 <br></td></tr><tr><td>  float64 <br></td><td>  77,0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Como resultado, todas las columnas que almacenaban n√∫meros de coma flotante con tipo de datos <code>float64</code> ahora almacenan n√∫meros de tipo <code>float32</code> , lo que nos dio una reducci√≥n del 50% en el uso de memoria. <br><br>  Cree una copia del <code>DataFrame</code> original, use estas columnas num√©ricas optimizadas en lugar de las que originalmente estaban presentes en √©l, y observe el uso general de la memoria despu√©s de la optimizaci√≥n. <br><br><pre> <code class="plaintext hljs">optimized_gl = gl.copy() optimized_gl[converted_int.columns] = converted_int optimized_gl[converted_float.columns] = converted_float print(mem_usage(gl)) print(mem_usage(optimized_gl))</code> </pre> <br>  Esto es lo que tenemos: <br><br> <code>861.57 MB <br> 804.69 MB</code> <br> <br>  Aunque redujimos significativamente el consumo de memoria mediante columnas que almacenan datos num√©ricos, en general, en todo el <code>DataFrame</code> , el consumo de memoria disminuy√≥ solo un 7%.  La optimizaci√≥n del almacenamiento de tipos de objetos puede convertirse en una fuente de mejora mucho m√°s grave de una situaci√≥n. <br><br>  Antes de hacer esta optimizaci√≥n, veremos m√°s de cerca c√≥mo se almacenan las cadenas en los pandas, y compararemos esto con c√≥mo se almacenan los n√∫meros aqu√≠. <br><br><h2>  <font color="#3AC1EF">Comparaci√≥n de mecanismos para almacenar n√∫meros y cadenas</font> </h2><br>  El tipo de <code>object</code> representa valores utilizando objetos de cadena Python.  Esto se debe en parte a que NumPy no admite la representaci√≥n de valores de cadena faltantes.  Dado que Python es un lenguaje interpretado de alto nivel, no proporciona al programador herramientas para ajustar c√≥mo se almacenan los datos en la memoria. <br><br>  Esta limitaci√≥n lleva al hecho de que las cadenas no se almacenan en fragmentos contiguos de memoria; su representaci√≥n en la memoria est√° fragmentada.  Esto conduce a un aumento en el consumo de memoria y a una desaceleraci√≥n en la velocidad de trabajo con valores de cadena.  Cada elemento en la columna que almacena el tipo de datos del objeto, de hecho, es un puntero que contiene la "direcci√≥n" en la que se encuentra el valor real en la memoria. <br><br>  El siguiente es un diagrama basado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> material que compara el almacenamiento de datos num√©ricos con los tipos de datos NumPy y el almacenamiento de cadenas con los tipos de datos integrados de Python. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/66f/54b/d8066f54b091531c120b94c90f698236.png"></div><br>  <i><font color="#999999">Almacenar datos num√©ricos y de cadena</font></i> <br><br>  Aqu√≠ puede recordar que en una de las tablas anteriores se mostr√≥ que se utiliza una cantidad variable de memoria para almacenar datos de tipos de objetos.  Aunque cada puntero ocupa 1 byte de memoria, cada valor de cadena particular ocupa la misma cantidad de memoria que se usar√≠a para almacenar una sola cadena en Python.  Para confirmar esto, utilizaremos el m√©todo <code>sys.getsizeof()</code> .  Primero, eche un vistazo a las l√≠neas individuales y luego al objeto de pandas de la <code>Series</code> que almacena los datos de la cadena. <br><br>  Entonces, primero examinamos las l√≠neas habituales: <br><br><pre> <code class="plaintext hljs">from sys import getsizeof s1 = 'working out' s2 = 'memory usage for' s3 = 'strings in python is fun!' s4 = 'strings in python is fun!' for s in [s1, s2, s3, s4]:   print(getsizeof(s))</code> </pre> <br>  Aqu√≠, los datos de uso de memoria se ven as√≠: <br><br> <code>60 <br> 65 <br> 74 <br> 74</code> <br> <br>  Ahora veamos c√≥mo se ve el uso de cadenas en el objeto <code>Series</code> : <br><br><pre> <code class="plaintext hljs">obj_series = pd.Series(['working out',                         'memory usage for',                         'strings in python is fun!',                         'strings in python is fun!']) obj_series.apply(getsizeof)</code> </pre> <br>  Aqu√≠ obtenemos lo siguiente: <br><br><pre> <code class="plaintext hljs">0    60 1    65 2    74 3    74 dtype: int64</code> </pre> <br>  Aqu√≠ puede ver que los tama√±os de las l√≠neas almacenadas en los objetos de pandas de la <code>Series</code> son similares a sus tama√±os cuando se trabaja con ellos en Python y cuando se representan como entidades separadas. <br><br><h2>  <font color="#3AC1EF">Optimizaci√≥n del almacenamiento de datos de tipo de objeto utilizando variables categ√≥ricas.</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Las variables categ√≥ricas</a> aparecieron en pandas versi√≥n 0.15.  El tipo correspondiente, <code>category</code> , utiliza valores enteros en sus mecanismos internos, en lugar de los valores originales almacenados en las columnas de la tabla.  Pandas usa un diccionario separado que establece la correspondencia de valores enteros e iniciales.  Este enfoque es √∫til cuando las columnas contienen valores de un conjunto limitado.  Cuando los datos almacenados en una columna se convierten al tipo de <code>category</code> , pandas usa el subtipo <code>int</code> , que permite el uso m√°s eficiente de la memoria y puede representar todos los valores √∫nicos encontrados en la columna. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f5/48d/59c/1f548d59c9b41fd906d038c19d3a2da2.png"></div><br>  <i><font color="#999999">Datos de origen y datos categ√≥ricos utilizando el subtipo int8</font></i> <br><br>  Para comprender exactamente d√≥nde podemos usar datos categ√≥ricos para reducir el consumo de memoria, descubrimos el n√∫mero de valores √∫nicos en las columnas que almacenan los valores de los tipos de objetos: <br><br><pre> <code class="plaintext hljs">gl_obj = gl.select_dtypes(include=['object']).copy() gl_obj.describe()</code> </pre> <br>  Puede encontrar lo que tenemos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> tabla, en la hoja <code>    </code> . <br><br>  Por ejemplo, en la columna <code>day_of_week</code> , que es el d√≠a de la semana en que se jug√≥ el juego, hay 171907 valores.  Entre ellos, solo 7 son √∫nicos.  En general, un solo vistazo a este informe es suficiente para comprender que se utilizan bastantes valores √∫nicos en muchas columnas para representar los datos de aproximadamente 172,000 juegos. <br><br>  Antes de hacer la optimizaci√≥n a gran escala, seleccionemos una columna que almacene datos de objetos, al menos <code>day_of_week</code> , y veamos qu√© sucede dentro del programa cuando se convierte a un tipo categ√≥rico. <br><br>  Como ya se mencion√≥, esta columna contiene solo 7 valores √∫nicos.  Para convertirlo a un tipo categ√≥rico, utilizamos el m√©todo <code>.astype()</code> . <br><br><pre> <code class="plaintext hljs">dow = gl_obj.day_of_week print(dow.head()) dow_cat = dow.astype('category') print(dow_cat.head())</code> </pre> <br>  Esto es lo que tenemos: <br><br><pre> <code class="plaintext hljs">0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: object 0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: category Categories (7, object): [Fri, Mon, Sat, Sun, Thu, Tue, Wed]</code> </pre> <br>  Como puede ver, aunque el tipo de columna ha cambiado, los datos almacenados en ella se ven igual que antes.  Ahora echemos un vistazo a lo que sucede dentro del programa. <br><br>  En el siguiente c√≥digo, usamos el atributo <code>Series.cat.codes</code> para averiguar qu√© valores enteros utiliza el tipo de <code>category</code> para representar cada d√≠a de la semana: <br><br><pre> <code class="plaintext hljs">dow_cat.head().cat.codes</code> </pre> <br>  Logramos descubrir lo siguiente: <br><br><pre> <code class="plaintext hljs">0    4 1    0 2    2 3    1 4    5 dtype: int8</code> </pre> <br>  Aqu√≠ puede ver que a cada valor √∫nico se le asigna un valor entero y que la columna ahora es del tipo <code>int8</code> .  No faltan valores, pero si ese fuera el caso, -1 se usar√≠a para indicar dichos valores. <br><br>  Ahora comparemos el consumo de memoria antes y despu√©s de convertir la columna <code>day_of_week</code> al tipo de <code>category</code> . <br><br><pre> <code class="plaintext hljs">print(mem_usage(dow)) print(mem_usage(dow_cat))</code> </pre> <br>  Aqu√≠ est√° el resultado: <br><br> <code>9.84 MB <br> 0.16 MB</code> <br> <br>  Como puede ver, al principio se consumieron 9.84 megabytes de memoria, y despu√©s de la optimizaci√≥n solo 0.16 megabytes, lo que significa una mejora del 98% en este indicador.  Tenga en cuenta que trabajar con esta columna probablemente demuestra uno de los escenarios de optimizaci√≥n m√°s rentables cuando solo se usan 7 valores √∫nicos en una columna que contiene aproximadamente 172,000 elementos. <br><br>  Aunque la idea de convertir todas las columnas a este tipo de datos parece atractiva, antes de hacerlo, considere los efectos secundarios negativos de dicha conversi√≥n.  Entonces, el inconveniente m√°s grave de esta transformaci√≥n es la imposibilidad de realizar operaciones aritm√©ticas en datos categ√≥ricos.  Esto tambi√©n se aplica a las operaciones aritm√©ticas ordinarias y al uso de m√©todos como <code>Series.min()</code> y <code>Series.max()</code> sin convertir primero los datos a un tipo de n√∫mero real. <br><br>  Deber√≠amos limitar el uso del tipo de <code>category</code> a columnas principalmente que almacenan datos del tipo de <code>object</code> , en el que menos del 50% de los valores son √∫nicos.  Si todos los valores de una columna son √∫nicos, el uso del tipo de <code>category</code> aumentar√° el nivel de uso de memoria.  Esto se debe al hecho de que en la memoria debe almacenar, adem√°s de los c√≥digos de categor√≠a num√©ricos, los valores de cadena originales.  Los detalles sobre las restricciones de tipo de <code>category</code> se pueden encontrar en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de</a> los pandas. <br><br>  Creemos un bucle que recorra en iteraci√≥n todas las columnas que almacenan datos del tipo de <code>object</code> , descubra si el n√∫mero de valores √∫nicos en las columnas supera el 50% y, de ser as√≠, los convierte en <code>category</code> tipo. <br><br><pre> <code class="plaintext hljs">converted_obj = pd.DataFrame() for col in gl_obj.columns:   num_unique_values = len(gl_obj[col].unique())   num_total_values = len(gl_obj[col])   if num_unique_values / num_total_values &lt; 0.5:       converted_obj.loc[:,col] = gl_obj[col].astype('category')   else:       converted_obj.loc[:,col] = gl_obj[col]</code> </pre> <br>  Ahora compare lo que sucedi√≥ despu√©s de la optimizaci√≥n con lo que sucedi√≥ antes: <br><br><pre> <code class="plaintext hljs">print(mem_usage(gl_obj)) print(mem_usage(converted_obj)) compare_obj = pd.concat([gl_obj.dtypes,converted_obj.dtypes],axis=1) compare_obj.columns = ['before','after'] compare_obj.apply(pd.Series.value_counts)</code> </pre> <br>  Obtenemos lo siguiente: <br><br> <code>752.72 MB <br> 51.67 MB</code> <br> <table><tbody><tr><td></td><td>  A <br></td><td>  Despues <br></td></tr><tr><td>  objeto <br></td><td>  78,0 <br></td><td>  NaN <br></td></tr><tr><td>  categor√≠a <br></td><td>  NaN <br></td><td>  78,0 <br></td></tr></tbody></table><br>           <code>category</code> ,     ,          , ,      ,     ,    ,  ,     . <br><br>  ,  ,     ,    <code>object</code> ,   752   52 ,    93%.     ,          .  ,       ,   ,  ,     891 . <br><br><pre> <code class="plaintext hljs">optimized_gl[converted_obj.columns] = converted_obj mem_usage(optimized_gl)</code> </pre> <br>     : <br><br> <code>'103.64 MB'</code> <br> <br>  .     - .    ,       <code>datetime</code> , ,  ,        . <br><br><pre> <code class="plaintext hljs">date = optimized_gl.date print(mem_usage(date)) date.head()</code> </pre> <br>       : <br><br> <code>0.66 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0    18710504 1    18710505 2    18710506 3    18710508 4    18710509 Name: date, dtype: uint32</code> </pre> <br>  ,               <code>uint32</code> . -       <code>datetime</code>     ,         64 .       <code>datetime</code> ,  ,  ,          . <br><br>      <code>to_datetime()</code> ,  <code>format</code>    ,      <code>YYYY-MM-DD</code> . <br><br><pre> <code class="plaintext hljs">optimized_gl['date'] = pd.to_datetime(date,format='%Y%m%d') print(mem_usage(optimized_gl)) optimized_gl.date.head()</code> </pre> <br>    : <br><br> <code>104.29 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0   1871-05-04 1   1871-05-05 2   1871-05-06 3   1871-05-08 4   1871-05-09 Name: date, dtype: datetime64[ns]</code> </pre> <br><h2> <font color="#3AC1EF">    </font> </h2><br>            <code>DataFrame</code> .        , , ,   ,  ,  ,  ,  .       ,        .    ,     ,     ,     .        ,        ,      <code>DataFrame</code> ,   . <br><br>  ,             .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pandas.read_csv()</a>   ,   . ,  <code>dtype</code>  ,   ,   ,   ,     ‚Äî  NumPy. <br><br>      ,          ,   .         ,      . <br><br><pre> <code class="plaintext hljs">dtypes = optimized_gl.drop('date',axis=1).dtypes dtypes_col = dtypes.index dtypes_type = [i.name for i in dtypes.values] column_types = dict(zip(dtypes_col, dtypes_type)) #    161 ,  #  10  /   #     preview = first2pairs = {key:value for key,value in list(column_types.items())[:10]} import pprint pp = pp = pprint.PrettyPrinter(indent=4) pp.pprint(preview)     : {   'acquisition_info': 'category',   'h_caught_stealing': 'float32',   'h_player_1_name': 'category',   'h_player_9_name': 'category',   'v_assists': 'float32',   'v_first_catcher_interference': 'float32',   'v_grounded_into_double': 'float32',   'v_player_1_id': 'category',   'v_player_3_id': 'category',   'v_player_5_id': 'category'}</code> </pre> <br>          ,      ,    . <br><br>    - : <br><br><pre> <code class="plaintext hljs">read_and_optimized = pd.read_csv('game_logs.csv',dtype=column_types,parse_dates=['date'],infer_datetime_format=True) print(mem_usage(read_and_optimized)) read_and_optimized.head()</code> </pre> <br>       : <br><br> <code>104.28 MB</code> <br> <br>    ,     <code>   </code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . <br><br>  ,    <code>   </code>  <code>   </code> ,     ,  ,       .      pandas       861.6   104.28 ,     88% . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br> ,  ,    ,     .     . <br><br><pre> <code class="plaintext hljs">optimized_gl['year'] = optimized_gl.date.dt.year games_per_day = optimized_gl.pivot_table(index='year',columns='day_of_week',values='date',aggfunc=len) games_per_day = games_per_day.divide(games_per_day.sum(axis=1),axis=0) ax = games_per_day.plot(kind='area',stacked='true') ax.legend(loc='upper right') ax.set_ylim(0,1) plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b2/699/6a2/3b26996a26b73e9a3ce87f3ff22dcf34.png"></div><br> <i><font color="#999999">,    </font></i> <br><br>  ,  1920-      ,  ,    50 ,        . <br><br>  ,  ,    ,      50 ,   . <br><br>    ,      . <br><br><pre> <code class="plaintext hljs">game_lengths = optimized_gl.pivot_table(index='year', values='length_minutes') game_lengths.reset_index().plot.scatter('year','length_minutes') plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6d/6db/5d2/a6d6db5d2e6bdb7330ac8a0ff2a6febd.png"></div><br> <i><font color="#999999"> </font></i> <br><br>   ,   1940-         . <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>            pandas,         ,     <code>DataFrame</code> ,   90%.       : <br><br><ul><li>       ,   ,   ,    , . </li><li>        . </li></ul><br>  ,            , ,         ,    ,  ,       pandas,    ,    . <br><br>  <b>Estimados lectores!</b>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">eugene_bb</a> .    -  ,    ‚Äî    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442516/">https://habr.com/ru/post/442516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442504/index.html">Proxy PHP Xdebug: cuando las caracter√≠sticas est√°ndar de Xdebug no son suficientes</a></li>
<li><a href="../442506/index.html">¬øSe castiga a Rusia por el comercio ilegal de datos personales?</a></li>
<li><a href="../442508/index.html">C√≥mo udalenka acelera la innovaci√≥n en GitLab</a></li>
<li><a href="../442512/index.html">Personalizaci√≥n de Django ORM en el ejemplo de ZomboDB</a></li>
<li><a href="../442514/index.html">Sistemas distribuidos. Patrones de dise√±o. Rese√±a del libro</a></li>
<li><a href="../442518/index.html">Las 10 mejores t√©cnicas de pirater√≠a web 2018</a></li>
<li><a href="../442520/index.html">Caso. Ahorro de 300 000 p. por mes en publicidad contextual</a></li>
<li><a href="../442522/index.html">Intuitivo RL (aprendizaje de refuerzo): Introducci√≥n a Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../442524/index.html">C√≥mo aumentar la seguridad en la identificaci√≥n personal y los sistemas de control de acceso</a></li>
<li><a href="../442526/index.html">La historia de los reproductores de cassette sovi√©ticos (segunda parte): el auge de Walkmen, un dispositivo para el KGB y las grabadoras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>