<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏿 💿 💉 Pandas Guide to Big Data Analysis 🧣 🧗🏽 🕧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando se usa la biblioteca de pandas para analizar conjuntos de datos pequeños, cuyo tamaño no supera los 100 megabytes, el rendimiento rara vez se c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pandas Guide to Big Data Analysis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442516/"> Cuando se usa la biblioteca de pandas para analizar conjuntos de datos pequeños, cuyo tamaño no supera los 100 megabytes, el rendimiento rara vez se convierte en un problema.  Pero cuando se trata del estudio de conjuntos de datos, cuyos tamaños pueden alcanzar varios gigabytes, los problemas de rendimiento pueden conducir a un aumento significativo en la duración del análisis de datos e incluso pueden conducir a la imposibilidad de realizar análisis debido a la falta de memoria. <br><br>  Si bien las herramientas como Spark pueden procesar de manera eficiente grandes conjuntos de datos (desde cientos de gigabytes hasta varios terabytes), para utilizar plenamente sus capacidades, generalmente necesita un hardware bastante potente y costoso.  Y, en comparación con los pandas, no difieren en un rico conjunto de herramientas para la limpieza, la investigación y el análisis de datos de alta calidad.  Para conjuntos de datos de tamaño mediano, es mejor intentar usar pandas de manera más eficiente, en lugar de cambiar a otras herramientas. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/gd/jg/60/gdjg60abxgti2otxocpd0ct2uci.jpeg"></a> <br><br>  En el artículo, cuya traducción publicamos hoy, hablaremos sobre las peculiaridades de trabajar con memoria cuando se usan pandas, y cómo simplemente reducir el consumo de memoria en casi un 90% simplemente seleccionando los tipos de datos apropiados almacenados en las columnas de las estructuras de datos de la tabla del <code>DataFrame</code> . <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Trabajando con datos sobre juegos de beisbol</font> </h2><br>  Trabajaremos con datos sobre juegos de béisbol de Grandes Ligas recopilados durante 130 años y tomados de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Retrosheet</a> . <br><br>  Inicialmente, estos datos se presentaron como 127 archivos CSV, pero los combinamos en un conjunto de datos usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">csvkit</a> y agregamos, como la primera fila de la tabla resultante, una fila con nombres de columna.  Si lo desea, puede descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestra versión de</a> estos datos y experimentar con ellos, leyendo el artículo. <br><br>  Comencemos importando un conjunto de datos y echemos un vistazo a sus primeras cinco líneas.  Puede encontrarlos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> tabla, en el <code>   </code> hoja del <code>   </code> de <code>   </code> . <br><br><pre> <code class="plaintext hljs">import pandas as pd gl = pd.read_csv('game_logs.csv') gl.head()</code> </pre> <br>  A continuación se muestra información sobre las columnas más importantes de la tabla con estos datos.  Si desea leer las explicaciones para todas las columnas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> puede encontrar un diccionario de datos para todo el conjunto de datos. <br><br><ul><li>  <code>date</code> - Fecha del juego. </li><li>  <code>v_name</code> : el nombre del equipo invitado. </li><li>  <code>v_league</code> - Liga del equipo visitante. </li><li>  <code>h_name</code> : el nombre del equipo local. </li><li>  <code>h_league</code> - La liga del equipo local. </li><li>  <code>v_score</code> : puntos del equipo visitante. </li><li>  <code>h_score</code> : puntos del equipo local. </li><li>  <code>v_line_score</code> : un resumen de los puntos del equipo invitado, por ejemplo, <code>010000(10)00</code> . </li><li>  <code>h_line_score</code> : un resumen de los puntos del equipo local, por ejemplo, <code>010000(10)0X</code> . </li><li>  <code>park_id</code> : el identificador del campo en el que se jugó el juego. </li><li>  <code>attendance</code> : la cantidad de espectadores. </li></ul><br>  Para encontrar información general sobre el objeto <code>DataFrame</code> , puede usar el método <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DataFrame.info ()</a> .  Gracias a este método, puede aprender sobre el tamaño de un objeto, sobre los tipos de datos y sobre el uso de la memoria. <br><br>  Por defecto, los pandas, en aras del ahorro de tiempo, <code>DataFrame</code> información aproximada sobre el uso de memoria de un <code>DataFrame</code> .  Estamos interesados ​​en información precisa, por lo que estableceremos el parámetro <code>memory_usage</code> en <code>'deep'</code> . <br><br><pre> <code class="plaintext hljs">gl.info(memory_usage='deep')</code> </pre> <br>  Aquí está la información que logramos obtener: <br><br><pre> <code class="plaintext hljs">&lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 171907 entries, 0 to 171906 Columns: 161 entries, date to acquisition_info dtypes: float64(77), int64(6), object(78) memory usage: 861.6 MB</code> </pre> <br>  Al final resultó que, tenemos 171,907 filas y 161 columnas.  La biblioteca de pandas detectó automáticamente los tipos de datos.  Hay 83 columnas con datos numéricos y 78 columnas con objetos.  Las columnas de objeto se usan para almacenar datos de cadena y en los casos en que la columna contiene datos de diferentes tipos. <br><br>  Ahora, para comprender mejor cómo puede optimizar el uso de la memoria con este <code>DataFrame</code> , hablemos sobre cómo los pandas almacenan datos en la memoria. <br><br><h2>  <font color="#3AC1EF">Vista interna de un marco de datos</font> </h2><br>  Dentro de los pandas, las columnas de datos se agrupan en bloques con valores del mismo tipo.  Aquí hay un ejemplo de cómo las primeras 12 columnas de un <code>DataFrame</code> se almacenan en pandas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c70/c63/d35c70c635289a5cecc520c58e662e9a.png"></div><br>  <i><font color="#999999">Representación interna de diferentes tipos de datos en pandas</font></i> <br><br>  Puede notar que los bloques no almacenan información de nombre de columna.  Esto se debe al hecho de que los bloques están optimizados para almacenar los valores disponibles en las celdas de la <code>DataFrame</code> objeto <code>DataFrame</code> .  La clase <code>BlockManager</code> es responsable de almacenar información sobre la correspondencia entre los índices de fila y columna del conjunto de datos y lo que se almacena en bloques del mismo tipo de datos.  Desempeña el papel de una API que proporciona acceso a datos básicos.  Cuando leemos, editamos o <code>DataFrame</code> valores, la clase <code>DataFrame</code> interactúa con la clase <code>BlockManager</code> para convertir nuestras solicitudes en llamadas a funciones y métodos. <br><br>  Cada tipo de datos tiene una clase especializada en el módulo <code>pandas.core.internals</code> .  Por ejemplo, pandas usa la clase <code>ObjectBlock</code> para representar bloques que contienen columnas de cadena y la clase <code>FloatBlock</code> para representar bloques que contienen columnas que <code>FloatBlock</code> números de punto flotante.  Para los bloques que representan valores numéricos que parecen números enteros o números de coma flotante, pandas combina las columnas y las almacena como la <code>ndarray</code> datos <code>ndarray</code> la biblioteca NumPy.  Esta estructura de datos se basa en la matriz C, los valores se almacenan en un bloque continuo de memoria.  Gracias a este esquema de almacenamiento de datos, el acceso a los fragmentos de datos es muy rápido. <br><br>  Dado que los datos de diferentes tipos se almacenan por separado, examinamos el uso de la memoria de diferentes tipos de datos.  Comencemos con el uso promedio de memoria para diferentes tipos de datos. <br><br><pre> <code class="plaintext hljs">for dtype in ['float','int','object']:   selected_dtype = gl.select_dtypes(include=[dtype])   mean_usage_b = selected_dtype.memory_usage(deep=True).mean()   mean_usage_mb = mean_usage_b / 1024 ** 2   print("Average memory usage for {} columns: {:03.2f} MB".format(dtype,mean_usage_mb))</code> </pre> <br>  Como resultado, resulta que los indicadores promedio de uso de memoria para datos de diferentes tipos se ven así: <br><br><pre> <code class="plaintext hljs">Average memory usage for float columns: 1.29 MB Average memory usage for int columns: 1.12 MB Average memory usage for object columns: 9.53 MB</code> </pre> <br>  Esta información nos hace comprender que la mayor parte de la memoria se gasta en 78 columnas que almacenan valores de objetos.  Hablaremos más sobre esto más adelante, pero ahora pensemos si podemos mejorar el uso de la memoria con columnas que almacenan datos numéricos. <br><br><h2>  <font color="#3AC1EF">Subtipos</font> </h2><br>  Como ya dijimos, los pandas representan valores numéricos como estructuras de datos <code>ndarray</code> NumPy y los almacenan en bloques contiguos de memoria.  Este modelo de almacenamiento de datos le permite ahorrar memoria y acceder rápidamente a los valores.  Dado que los pandas representan cada valor del mismo tipo utilizando el mismo número de bytes, y <code>ndarray</code> estructuras de <code>ndarray</code> almacenan información sobre el número de valores, los pandas pueden <code>ndarray</code> rápida y precisa la cantidad de memoria consumida por las columnas que almacenan valores numéricos. <br><br>  Muchos tipos de datos en pandas tienen muchos subtipos que pueden usar menos bytes para representar cada valor.  Por ejemplo, el tipo <code>float</code> tiene subtipos <code>float16</code> , <code>float32</code> y <code>float64</code> .  El número en el nombre del tipo indica el número de bits que utiliza el subtipo para representar los valores.  Por ejemplo, en los subtipos recién enumerados, se utilizan 2, 4, 8 y 16 bytes respectivamente para el almacenamiento de datos.  La siguiente tabla muestra los subtipos de los tipos de datos más utilizados en pandas. <br><table><tbody><tr><td>  <sup>Uso de memoria, bytes</sup> <sup><br></sup> </td><td>  <sup>Número de coma flotante</sup> <sup><br></sup> </td><td>  <sup>Entero</sup> <sup><br></sup> </td><td>  <sup>Entero sin signo</sup> <sup><br></sup> </td><td>  <sup>Fecha y hora</sup> <sup><br></sup> </td><td>  <sup>Valor booleano</sup> <sup><br></sup> </td><td width="75">  <sup>Objeto</sup> <sup><br></sup> </td></tr><tr><td>  <sup>1</sup> <sup><br></sup> </td><td></td><td>  <sup>int8</sup> <sup><br></sup> </td><td>  <sup>uint8</sup> <sup><br></sup> </td><td></td><td>  <sup>bool</sup> <sup><br></sup> </td><td></td></tr><tr><td>  <sup>2</sup> <sup><br></sup> </td><td>  <sup>float16</sup> <sup><br></sup> </td><td>  <sup>int16</sup> <sup><br></sup> </td><td>  <sup>uint16</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>4 4</sup> <sup><br></sup> </td><td>  <sup>float32</sup> <sup><br></sup> </td><td>  <sup>int32</sup> <sup><br></sup> </td><td>  <sup>uint32</sup> <sup><br></sup> </td><td></td><td></td><td></td></tr><tr><td>  <sup>8</sup> <sup><br></sup> </td><td>  <sup>float64</sup> <sup><br></sup> </td><td>  <sup>int64</sup> <sup><br></sup> </td><td>  <sup>uint64</sup> <sup><br></sup> </td><td>  <sup>datetime64</sup> <sup><br></sup> </td><td></td><td></td></tr><tr><td>  <sup>Capacidad de memoria variable</sup> <sup><br></sup> </td><td></td><td></td><td></td><td></td><td></td><td>  <sup>objeto</sup> <sup><br></sup> </td></tr></tbody></table><br>  Un valor de tipo <code>int8</code> usa 1 byte (8 bits) para almacenar un número y puede representar 256 valores binarios (potencia de 2 a 8).  Esto significa que este subtipo se puede usar para almacenar valores en el rango de -128 a 127 (incluido 0). <br><br>  Para verificar los valores mínimos y máximos adecuados para el almacenamiento usando cada subtipo de entero, puede usar el método <code>numpy.iinfo()</code> .  Considere un ejemplo: <br><br><pre> <code class="plaintext hljs">import numpy as np int_types = ["uint8", "int8", "int16"] for it in int_types:   print(np.iinfo(it))</code> </pre> <br>  Al ejecutar este código, obtenemos los siguientes datos: <br><br><pre> <code class="plaintext hljs">Machine parameters for uint8 --------------------------------------------------------------- min = 0 max = 255 --------------------------------------------------------------- Machine parameters for int8 --------------------------------------------------------------- min = -128 max = 127 --------------------------------------------------------------- Machine parameters for int16 --------------------------------------------------------------- min = -32768 max = 32767 ---------------------------------------------------------------</code> </pre> <br>  Aquí puede prestar atención a la diferencia entre los tipos <code>uint</code> (entero sin signo) e <code>int</code> (entero con signo).  Ambos tipos tienen la misma capacidad, pero cuando se almacenan solo valores positivos en columnas, los tipos sin signo permiten un uso más eficiente de la memoria. <br><br><h2>  <font color="#3AC1EF">Optimización del almacenamiento de datos numéricos utilizando subtipos.</font> </h2><br>  La función <code>pd.to_numeric()</code> se puede usar para convertir tipos numéricos a la baja.  Para seleccionar columnas enteras, utilizamos el método <code>DataFrame.select_dtypes()</code> , luego las optimizamos y comparamos el uso de memoria antes y después de la optimización. <br><br><pre> <code class="plaintext hljs">#     ,   , #   ,      . def mem_usage(pandas_obj):   if isinstance(pandas_obj,pd.DataFrame):       usage_b = pandas_obj.memory_usage(deep=True).sum()   else: #     ,     DataFrame,   Series       usage_b = pandas_obj.memory_usage(deep=True)   usage_mb = usage_b / 1024 ** 2 #       return "{:03.2f} MB".format(usage_mb) gl_int = gl.select_dtypes(include=['int']) converted_int = gl_int.apply(pd.to_numeric,downcast='unsigned') print(mem_usage(gl_int)) print(mem_usage(converted_int)) compare_ints = pd.concat([gl_int.dtypes,converted_int.dtypes],axis=1) compare_ints.columns = ['before','after'] compare_ints.apply(pd.Series.value_counts)</code> </pre> <br>  Aquí está el resultado de un estudio del consumo de memoria: <br><br> <code>7.87 MB <br> 1.48 MB</code> <br> <table><tbody><tr><td></td><td>  A <br></td><td>  Despues <br></td></tr><tr><td>  uint8 <br></td><td>  NaN <br></td><td>  5.0 <br></td></tr><tr><td>  uint32 <br></td><td>  NaN <br></td><td>  1.0 <br></td></tr><tr><td>  int64 <br></td><td>  6.0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Como resultado, puede ver una caída en el uso de memoria de 7.9 a 1.5 megabytes, es decir, redujimos el consumo de memoria en más del 80%.  Sin embargo, el impacto general de esta optimización en el <code>DataFrame</code> original no es particularmente fuerte, ya que tiene muy pocas columnas enteras. <br><br>  Hagamos lo mismo con las columnas que contienen números de coma flotante. <br><br><pre> <code class="plaintext hljs">gl_float = gl.select_dtypes(include=['float']) converted_float = gl_float.apply(pd.to_numeric,downcast='float') print(mem_usage(gl_float)) print(mem_usage(converted_float)) compare_floats = pd.concat([gl_float.dtypes,converted_float.dtypes],axis=1) compare_floats.columns = ['before','after'] compare_floats.apply(pd.Series.value_counts)</code> </pre> <br>  El resultado es el siguiente: <br><br> <code>100.99 MB <br> 50.49 MB</code> <br> <table><tbody><tr><td></td><td>  A <br></td><td>  Despues <br></td></tr><tr><td>  float32 <br></td><td>  NaN <br></td><td>  77,0 <br></td></tr><tr><td>  float64 <br></td><td>  77,0 <br></td><td>  NaN <br></td></tr></tbody></table><br>  Como resultado, todas las columnas que almacenaban números de coma flotante con tipo de datos <code>float64</code> ahora almacenan números de tipo <code>float32</code> , lo que nos dio una reducción del 50% en el uso de memoria. <br><br>  Cree una copia del <code>DataFrame</code> original, use estas columnas numéricas optimizadas en lugar de las que originalmente estaban presentes en él, y observe el uso general de la memoria después de la optimización. <br><br><pre> <code class="plaintext hljs">optimized_gl = gl.copy() optimized_gl[converted_int.columns] = converted_int optimized_gl[converted_float.columns] = converted_float print(mem_usage(gl)) print(mem_usage(optimized_gl))</code> </pre> <br>  Esto es lo que tenemos: <br><br> <code>861.57 MB <br> 804.69 MB</code> <br> <br>  Aunque redujimos significativamente el consumo de memoria mediante columnas que almacenan datos numéricos, en general, en todo el <code>DataFrame</code> , el consumo de memoria disminuyó solo un 7%.  La optimización del almacenamiento de tipos de objetos puede convertirse en una fuente de mejora mucho más grave de una situación. <br><br>  Antes de hacer esta optimización, veremos más de cerca cómo se almacenan las cadenas en los pandas, y compararemos esto con cómo se almacenan los números aquí. <br><br><h2>  <font color="#3AC1EF">Comparación de mecanismos para almacenar números y cadenas</font> </h2><br>  El tipo de <code>object</code> representa valores utilizando objetos de cadena Python.  Esto se debe en parte a que NumPy no admite la representación de valores de cadena faltantes.  Dado que Python es un lenguaje interpretado de alto nivel, no proporciona al programador herramientas para ajustar cómo se almacenan los datos en la memoria. <br><br>  Esta limitación lleva al hecho de que las cadenas no se almacenan en fragmentos contiguos de memoria; su representación en la memoria está fragmentada.  Esto conduce a un aumento en el consumo de memoria y a una desaceleración en la velocidad de trabajo con valores de cadena.  Cada elemento en la columna que almacena el tipo de datos del objeto, de hecho, es un puntero que contiene la "dirección" en la que se encuentra el valor real en la memoria. <br><br>  El siguiente es un diagrama basado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> material que compara el almacenamiento de datos numéricos con los tipos de datos NumPy y el almacenamiento de cadenas con los tipos de datos integrados de Python. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/66f/54b/d8066f54b091531c120b94c90f698236.png"></div><br>  <i><font color="#999999">Almacenar datos numéricos y de cadena</font></i> <br><br>  Aquí puede recordar que en una de las tablas anteriores se mostró que se utiliza una cantidad variable de memoria para almacenar datos de tipos de objetos.  Aunque cada puntero ocupa 1 byte de memoria, cada valor de cadena particular ocupa la misma cantidad de memoria que se usaría para almacenar una sola cadena en Python.  Para confirmar esto, utilizaremos el método <code>sys.getsizeof()</code> .  Primero, eche un vistazo a las líneas individuales y luego al objeto de pandas de la <code>Series</code> que almacena los datos de la cadena. <br><br>  Entonces, primero examinamos las líneas habituales: <br><br><pre> <code class="plaintext hljs">from sys import getsizeof s1 = 'working out' s2 = 'memory usage for' s3 = 'strings in python is fun!' s4 = 'strings in python is fun!' for s in [s1, s2, s3, s4]:   print(getsizeof(s))</code> </pre> <br>  Aquí, los datos de uso de memoria se ven así: <br><br> <code>60 <br> 65 <br> 74 <br> 74</code> <br> <br>  Ahora veamos cómo se ve el uso de cadenas en el objeto <code>Series</code> : <br><br><pre> <code class="plaintext hljs">obj_series = pd.Series(['working out',                         'memory usage for',                         'strings in python is fun!',                         'strings in python is fun!']) obj_series.apply(getsizeof)</code> </pre> <br>  Aquí obtenemos lo siguiente: <br><br><pre> <code class="plaintext hljs">0    60 1    65 2    74 3    74 dtype: int64</code> </pre> <br>  Aquí puede ver que los tamaños de las líneas almacenadas en los objetos de pandas de la <code>Series</code> son similares a sus tamaños cuando se trabaja con ellos en Python y cuando se representan como entidades separadas. <br><br><h2>  <font color="#3AC1EF">Optimización del almacenamiento de datos de tipo de objeto utilizando variables categóricas.</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Las variables categóricas</a> aparecieron en pandas versión 0.15.  El tipo correspondiente, <code>category</code> , utiliza valores enteros en sus mecanismos internos, en lugar de los valores originales almacenados en las columnas de la tabla.  Pandas usa un diccionario separado que establece la correspondencia de valores enteros e iniciales.  Este enfoque es útil cuando las columnas contienen valores de un conjunto limitado.  Cuando los datos almacenados en una columna se convierten al tipo de <code>category</code> , pandas usa el subtipo <code>int</code> , que permite el uso más eficiente de la memoria y puede representar todos los valores únicos encontrados en la columna. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f5/48d/59c/1f548d59c9b41fd906d038c19d3a2da2.png"></div><br>  <i><font color="#999999">Datos de origen y datos categóricos utilizando el subtipo int8</font></i> <br><br>  Para comprender exactamente dónde podemos usar datos categóricos para reducir el consumo de memoria, descubrimos el número de valores únicos en las columnas que almacenan los valores de los tipos de objetos: <br><br><pre> <code class="plaintext hljs">gl_obj = gl.select_dtypes(include=['object']).copy() gl_obj.describe()</code> </pre> <br>  Puede encontrar lo que tenemos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> tabla, en la hoja <code>    </code> . <br><br>  Por ejemplo, en la columna <code>day_of_week</code> , que es el día de la semana en que se jugó el juego, hay 171907 valores.  Entre ellos, solo 7 son únicos.  En general, un solo vistazo a este informe es suficiente para comprender que se utilizan bastantes valores únicos en muchas columnas para representar los datos de aproximadamente 172,000 juegos. <br><br>  Antes de hacer la optimización a gran escala, seleccionemos una columna que almacene datos de objetos, al menos <code>day_of_week</code> , y veamos qué sucede dentro del programa cuando se convierte a un tipo categórico. <br><br>  Como ya se mencionó, esta columna contiene solo 7 valores únicos.  Para convertirlo a un tipo categórico, utilizamos el método <code>.astype()</code> . <br><br><pre> <code class="plaintext hljs">dow = gl_obj.day_of_week print(dow.head()) dow_cat = dow.astype('category') print(dow_cat.head())</code> </pre> <br>  Esto es lo que tenemos: <br><br><pre> <code class="plaintext hljs">0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: object 0    Thu 1    Fri 2    Sat 3    Mon 4    Tue Name: day_of_week, dtype: category Categories (7, object): [Fri, Mon, Sat, Sun, Thu, Tue, Wed]</code> </pre> <br>  Como puede ver, aunque el tipo de columna ha cambiado, los datos almacenados en ella se ven igual que antes.  Ahora echemos un vistazo a lo que sucede dentro del programa. <br><br>  En el siguiente código, usamos el atributo <code>Series.cat.codes</code> para averiguar qué valores enteros utiliza el tipo de <code>category</code> para representar cada día de la semana: <br><br><pre> <code class="plaintext hljs">dow_cat.head().cat.codes</code> </pre> <br>  Logramos descubrir lo siguiente: <br><br><pre> <code class="plaintext hljs">0    4 1    0 2    2 3    1 4    5 dtype: int8</code> </pre> <br>  Aquí puede ver que a cada valor único se le asigna un valor entero y que la columna ahora es del tipo <code>int8</code> .  No faltan valores, pero si ese fuera el caso, -1 se usaría para indicar dichos valores. <br><br>  Ahora comparemos el consumo de memoria antes y después de convertir la columna <code>day_of_week</code> al tipo de <code>category</code> . <br><br><pre> <code class="plaintext hljs">print(mem_usage(dow)) print(mem_usage(dow_cat))</code> </pre> <br>  Aquí está el resultado: <br><br> <code>9.84 MB <br> 0.16 MB</code> <br> <br>  Como puede ver, al principio se consumieron 9.84 megabytes de memoria, y después de la optimización solo 0.16 megabytes, lo que significa una mejora del 98% en este indicador.  Tenga en cuenta que trabajar con esta columna probablemente demuestra uno de los escenarios de optimización más rentables cuando solo se usan 7 valores únicos en una columna que contiene aproximadamente 172,000 elementos. <br><br>  Aunque la idea de convertir todas las columnas a este tipo de datos parece atractiva, antes de hacerlo, considere los efectos secundarios negativos de dicha conversión.  Entonces, el inconveniente más grave de esta transformación es la imposibilidad de realizar operaciones aritméticas en datos categóricos.  Esto también se aplica a las operaciones aritméticas ordinarias y al uso de métodos como <code>Series.min()</code> y <code>Series.max()</code> sin convertir primero los datos a un tipo de número real. <br><br>  Deberíamos limitar el uso del tipo de <code>category</code> a columnas principalmente que almacenan datos del tipo de <code>object</code> , en el que menos del 50% de los valores son únicos.  Si todos los valores de una columna son únicos, el uso del tipo de <code>category</code> aumentará el nivel de uso de memoria.  Esto se debe al hecho de que en la memoria debe almacenar, además de los códigos de categoría numéricos, los valores de cadena originales.  Los detalles sobre las restricciones de tipo de <code>category</code> se pueden encontrar en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación de</a> los pandas. <br><br>  Creemos un bucle que recorra en iteración todas las columnas que almacenan datos del tipo de <code>object</code> , descubra si el número de valores únicos en las columnas supera el 50% y, de ser así, los convierte en <code>category</code> tipo. <br><br><pre> <code class="plaintext hljs">converted_obj = pd.DataFrame() for col in gl_obj.columns:   num_unique_values = len(gl_obj[col].unique())   num_total_values = len(gl_obj[col])   if num_unique_values / num_total_values &lt; 0.5:       converted_obj.loc[:,col] = gl_obj[col].astype('category')   else:       converted_obj.loc[:,col] = gl_obj[col]</code> </pre> <br>  Ahora compare lo que sucedió después de la optimización con lo que sucedió antes: <br><br><pre> <code class="plaintext hljs">print(mem_usage(gl_obj)) print(mem_usage(converted_obj)) compare_obj = pd.concat([gl_obj.dtypes,converted_obj.dtypes],axis=1) compare_obj.columns = ['before','after'] compare_obj.apply(pd.Series.value_counts)</code> </pre> <br>  Obtenemos lo siguiente: <br><br> <code>752.72 MB <br> 51.67 MB</code> <br> <table><tbody><tr><td></td><td>  A <br></td><td>  Despues <br></td></tr><tr><td>  objeto <br></td><td>  78,0 <br></td><td>  NaN <br></td></tr><tr><td>  categoría <br></td><td>  NaN <br></td><td>  78,0 <br></td></tr></tbody></table><br>           <code>category</code> ,     ,          , ,      ,     ,    ,  ,     . <br><br>  ,  ,     ,    <code>object</code> ,   752   52 ,    93%.     ,          .  ,       ,   ,  ,     891 . <br><br><pre> <code class="plaintext hljs">optimized_gl[converted_obj.columns] = converted_obj mem_usage(optimized_gl)</code> </pre> <br>     : <br><br> <code>'103.64 MB'</code> <br> <br>  .     - .    ,       <code>datetime</code> , ,  ,        . <br><br><pre> <code class="plaintext hljs">date = optimized_gl.date print(mem_usage(date)) date.head()</code> </pre> <br>       : <br><br> <code>0.66 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0    18710504 1    18710505 2    18710506 3    18710508 4    18710509 Name: date, dtype: uint32</code> </pre> <br>  ,               <code>uint32</code> . -       <code>datetime</code>     ,         64 .       <code>datetime</code> ,  ,  ,          . <br><br>      <code>to_datetime()</code> ,  <code>format</code>    ,      <code>YYYY-MM-DD</code> . <br><br><pre> <code class="plaintext hljs">optimized_gl['date'] = pd.to_datetime(date,format='%Y%m%d') print(mem_usage(optimized_gl)) optimized_gl.date.head()</code> </pre> <br>    : <br><br> <code>104.29 MB</code> <br> <br>    : <br><br><pre> <code class="plaintext hljs">0   1871-05-04 1   1871-05-05 2   1871-05-06 3   1871-05-08 4   1871-05-09 Name: date, dtype: datetime64[ns]</code> </pre> <br><h2> <font color="#3AC1EF">    </font> </h2><br>            <code>DataFrame</code> .        , , ,   ,  ,  ,  ,  .       ,        .    ,     ,     ,     .        ,        ,      <code>DataFrame</code> ,   . <br><br>  ,             .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pandas.read_csv()</a>   ,   . ,  <code>dtype</code>  ,   ,   ,   ,     —  NumPy. <br><br>      ,          ,   .         ,      . <br><br><pre> <code class="plaintext hljs">dtypes = optimized_gl.drop('date',axis=1).dtypes dtypes_col = dtypes.index dtypes_type = [i.name for i in dtypes.values] column_types = dict(zip(dtypes_col, dtypes_type)) #    161 ,  #  10  /   #     preview = first2pairs = {key:value for key,value in list(column_types.items())[:10]} import pprint pp = pp = pprint.PrettyPrinter(indent=4) pp.pprint(preview)     : {   'acquisition_info': 'category',   'h_caught_stealing': 'float32',   'h_player_1_name': 'category',   'h_player_9_name': 'category',   'v_assists': 'float32',   'v_first_catcher_interference': 'float32',   'v_grounded_into_double': 'float32',   'v_player_1_id': 'category',   'v_player_3_id': 'category',   'v_player_5_id': 'category'}</code> </pre> <br>          ,      ,    . <br><br>    - : <br><br><pre> <code class="plaintext hljs">read_and_optimized = pd.read_csv('game_logs.csv',dtype=column_types,parse_dates=['date'],infer_datetime_format=True) print(mem_usage(read_and_optimized)) read_and_optimized.head()</code> </pre> <br>       : <br><br> <code>104.28 MB</code> <br> <br>    ,     <code>   </code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . <br><br>  ,    <code>   </code>  <code>   </code> ,     ,  ,       .      pandas       861.6   104.28 ,     88% . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br> ,  ,    ,     .     . <br><br><pre> <code class="plaintext hljs">optimized_gl['year'] = optimized_gl.date.dt.year games_per_day = optimized_gl.pivot_table(index='year',columns='day_of_week',values='date',aggfunc=len) games_per_day = games_per_day.divide(games_per_day.sum(axis=1),axis=0) ax = games_per_day.plot(kind='area',stacked='true') ax.legend(loc='upper right') ax.set_ylim(0,1) plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b2/699/6a2/3b26996a26b73e9a3ce87f3ff22dcf34.png"></div><br> <i><font color="#999999">,    </font></i> <br><br>  ,  1920-      ,  ,    50 ,        . <br><br>  ,  ,    ,      50 ,   . <br><br>    ,      . <br><br><pre> <code class="plaintext hljs">game_lengths = optimized_gl.pivot_table(index='year', values='length_minutes') game_lengths.reset_index().plot.scatter('year','length_minutes') plt.show()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6d/6db/5d2/a6d6db5d2e6bdb7330ac8a0ff2a6febd.png"></div><br> <i><font color="#999999"> </font></i> <br><br>   ,   1940-         . <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>            pandas,         ,     <code>DataFrame</code> ,   90%.       : <br><br><ul><li>       ,   ,   ,    , . </li><li>        . </li></ul><br>  ,            , ,         ,    ,  ,       pandas,    ,    . <br><br>  <b>Estimados lectores!</b>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">eugene_bb</a> .    -  ,    —    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442516/">https://habr.com/ru/post/442516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442504/index.html">Proxy PHP Xdebug: cuando las características estándar de Xdebug no son suficientes</a></li>
<li><a href="../442506/index.html">¿Se castiga a Rusia por el comercio ilegal de datos personales?</a></li>
<li><a href="../442508/index.html">Cómo udalenka acelera la innovación en GitLab</a></li>
<li><a href="../442512/index.html">Personalización de Django ORM en el ejemplo de ZomboDB</a></li>
<li><a href="../442514/index.html">Sistemas distribuidos. Patrones de diseño. Reseña del libro</a></li>
<li><a href="../442518/index.html">Las 10 mejores técnicas de piratería web 2018</a></li>
<li><a href="../442520/index.html">Caso. Ahorro de 300 000 p. por mes en publicidad contextual</a></li>
<li><a href="../442522/index.html">Intuitivo RL (aprendizaje de refuerzo): Introducción a Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../442524/index.html">Cómo aumentar la seguridad en la identificación personal y los sistemas de control de acceso</a></li>
<li><a href="../442526/index.html">La historia de los reproductores de cassette soviéticos (segunda parte): el auge de Walkmen, un dispositivo para el KGB y las grabadoras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>