<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🍳 🅾️ 💇🏿 Bagaimana kerangka Rise of the Tomb Raider ditampilkan 🌂 🧒🏼 🍫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rise of the Tomb Raider (2015) adalah sekuel dari restart Raider (2013) yang sangat baik. Secara pribadi, saya menemukan kedua bagian menarik karena m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kerangka Rise of the Tomb Raider ditampilkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436500/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1k/5p/s6/1k5ps6qnv2soku_ymxsemz7wnxa.gif"></div><br>  Rise of the Tomb Raider (2015) adalah sekuel dari restart Raider (2013) yang sangat baik.  Secara pribadi, saya menemukan kedua bagian menarik karena mereka pindah dari seri asli stagnan dan menceritakan kisah Lara lagi.  Dalam permainan ini, seperti dalam prekuel, plot mengambil panggung utama, menyediakan mekanisme menarik kerajinan, perburuan dan pendakian / penelitian. <br><br>  Tomb Raider menggunakan Crystal Engine, yang dikembangkan oleh Crystal Dynamics, juga digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deus Ex: Human Revolution</a> .  Sekuel ini menggunakan mesin baru bernama Foundation, yang sebelumnya dikembangkan untuk Lara Croft dan Kuil Osiris (2014).  Rendernya secara umum dapat digambarkan sebagai mesin ubin dengan pas pencahayaan awal, dan kemudian kita akan mengetahui apa artinya ini.  Engine memungkinkan Anda untuk memilih antara penyaji DX11 dan DX12;  Saya memilih yang terakhir, untuk alasan yang kita diskusikan di bawah ini.  Untuk menangkap frame, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Renderdoc</a> 1.2 digunakan pada Geforce 980 Ti, game ini mencakup semua fungsi dan dekorasi. <br><br><h2>  Bingkai yang dianalisis </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/254/df9/0bb/254df90bbbfd5498710f37624e12d1f4.jpg"></div><br>  Untuk menghindari spoiler, saya akan mengatakan bahwa dalam frame ini orang jahat mengejar Lara, karena dia mencari artefak yang mereka cari.  Konflik kepentingan ini tidak dapat diselesaikan tanpa senjata.  Lara menyelinap ke markas musuh di malam hari.  Saya memilih bingkai dengan pencahayaan atmosfer dan kontras, di mana mesin dapat menunjukkan dirinya. <a name="habracut"></a><br><br><h4>  Kedalaman muka </h4><br>  Di sini, optimasi biasa untuk banyak game dilakukan - operan awal yang kecil (sekitar 100 panggilan undian).  Gim ini menjadikan objek terbesar (dan bukan obyek yang mengambil lebih banyak ruang di layar) untuk memanfaatkan fitur prosesor video Early-Z.  Baca lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel Intel</a> .  Singkatnya, GPU dapat menghindari mengeksekusi pixel shader jika mereka dapat menentukan bahwa itu tumpang tindih dengan pixel sebelumnya.  Ini adalah bagian yang cukup murah, pra-mengisi Z-buffer dengan nilai kedalaman. <br><br>  Pada titik ini, saya menemukan teknik level detail (LOD) yang menarik yang disebut "fizzle" atau "checkerboard".  Ini adalah cara umum untuk secara bertahap menampilkan atau menyembunyikan objek di kejauhan, sehingga nantinya mereka dapat diganti dengan mesh berkualitas lebih rendah, atau sepenuhnya menyembunyikannya.  Lihat truk ini.  Sepertinya itu rendering dua kali, tetapi sebenarnya rendering dengan LOD tinggi dan LOD rendah di posisi yang sama.  Masing-masing level membuat piksel yang tidak dirender oleh yang lainnya.  LOD pertama memiliki 182226 simpul, dan LOD kedua memiliki 47250. Pada jarak yang sangat jauh mereka tidak bisa dibedakan, tetapi salah satunya tiga kali lebih murah.  Dalam bingkai ini, LOD 0 hampir menghilang, dan LOD 1 hampir sepenuhnya ditampilkan.  Setelah penghilangan lengkap LOD 0, hanya LOD 1 yang akan diberikan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/d8d/24e/c31d8d24e58229c27fb4edf6f635974d.png"></div><br>  <i>LOD 0</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bf/3b4/5bb/7bf3b45bbe13521b4bae010f72a702a7.png"></div><br>  <i>LOD 1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/7r/it/jy7rit_bwqm4n0lwpzzlydyx5rs.gif"></div><br>  Tekstur pseudo-acak dan koefisien probabilitas memungkinkan kita untuk membuang piksel yang belum melewati nilai ambang batas.  Tekstur ini digunakan dalam ROTR.  Orang mungkin bertanya-tanya mengapa alpha blending tidak digunakan.  Alpha blending memiliki banyak kelemahan dibandingkan fizzle fading. <br><br><ol><li>  <strong>Kemudahan untuk bagian awal kedalaman:</strong> berkat rendering dari objek buram dengan lubang yang dibuat di dalamnya, kita dapat membuat bagian awal dan menggunakan awal-z.  Objek dengan alpha blending pada tahap awal tidak akan dirender ke buffer kedalaman karena masalah pengurutan. </li><li>  <strong>Kebutuhan akan shader tambahan</strong> : jika penyaji yang ditangguhkan digunakan, shader objek buram tidak mengandung pencahayaan apa pun.  Jika Anda perlu mengganti objek yang buram dengan yang transparan, maka Anda memerlukan opsi terpisah di mana ada pencahayaan.  Selain meningkatkan jumlah memori yang dibutuhkan dan kompleksitas karena setidaknya satu shader tambahan untuk semua objek buram, mereka harus akurat untuk menghindari objek bergerak maju.  Ini rumit karena banyak alasan, tetapi semuanya bermuara pada kenyataan bahwa rendering sekarang dilakukan dalam jalur kode yang berbeda. </li><li>  <strong>Redraw yang lebih besar</strong> : alpha blending dapat membuat redraw besar, dan pada tingkat kerumitan objek tertentu, sebagian besar dari bandwidth mungkin diperlukan untuk menaungi LOD. </li><li>  <strong>Konflik-Z</strong> : <strong>konflik-</strong> z adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">efek kedipan</a> ketika dua poligon dirender pada kedalaman yang sangat dekat satu sama lain.  Dalam hal ini, ketidakakuratan perhitungan titik apung memaksa mereka untuk diberikan pada gilirannya.  Jika kita membuat dua LOD berturut-turut, secara bertahap menyembunyikan satu dan menunjukkan yang kedua, maka mereka dapat menyebabkan z-konflik, karena mereka sangat dekat satu sama lain.  Selalu ada cara untuk menyiasatinya, misalnya, lebih suka satu poligon ke poligon lain, tetapi sistem seperti itu kompleks. </li><li>  <strong>Z-Buffer Effects</strong> : Banyak efek seperti SSAO hanya menggunakan buffer kedalaman.  Jika kami memberikan objek transparan di ujung pipa ketika oklusi ambien telah selesai, kami tidak dapat memperhitungkannya. </li></ol><br>  Kerugian dari teknik ini adalah bahwa itu terlihat lebih buruk daripada alpha blending, tetapi pola kebisingan yang baik, kabur setelah gagal, atau anti-aliasing sementara hampir sepenuhnya dapat menyembunyikannya.  Dalam hal ini, ROTR tidak melakukan sesuatu yang tidak biasa. <br><br><h4>  Pass Normal </h4><br>  Crystal Dynamics menggunakan pola pencahayaan yang agak tidak biasa dalam permainannya, yang akan kita bahas di lorong pencahayaan.  Untuk saat ini, cukup untuk mengatakan bahwa mesin tidak memiliki pass G-buffer;  setidaknya sejauh yang akrab di gim lain.  Pada bagian ini, objek hanya mengirimkan informasi tentang kedalaman dan normals ke output.  Normal dicatat dalam target render format RGBA16_SNORM di ruang dunia.  Sangat aneh bahwa mesin ini menggunakan skema Z-up, bukan Y-up (sumbu Z diarahkan ke atas, bukan sumbu Y), yang lebih sering digunakan dalam mesin / paket pemodelan lainnya.  Saluran alfa berisi glossiness, yang kemudian dibongkar sebagai <code>exp2(glossiness * 12 + 1.0)</code> .  Nilai kilau juga bisa negatif, karena tanda digunakan sebagai bendera yang menunjukkan apakah permukaannya metalik.  Ini bisa diperhatikan sendiri, karena semua warna gelap di saluran alpha terkait dengan benda logam. <br><br><table><tbody><tr><td>  <strong><font color="#ff0000">R</font></strong> </td><td>  <strong><font color="#00ff00">G</font></strong> </td><td>  <strong><font color="0000ff">B</font></strong> </td><td></td></tr><tr><td>  <strong>Normal.x</strong> </td><td>  <strong>Normal</strong> </td><td>  <strong>Normal.z</strong> </td><td>  <b>Glossiness + Metalness</b> </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e8/209/484/1e8209484fe730d178c4afffef4c8f93.jpg"></div><br>  <i>Normal</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/dd3/b2d/8fbdd3b2d2ddbce3111a4c017e7daef3.jpg"></div><br>  <i>Glossiness / metalness</i> <br><br>  <strong>Keuntungan Keberangkatan</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/b15/52b/aa1b1552b0f81c2122d094441e531f3f.jpg"></div><br>  Ingat bahwa di bagian "Kedalaman Awal", kami berbicara tentang menghemat biaya piksel?  Saya akan kembali sedikit untuk menggambarkannya.  Ambil gambar berikut.  Ini membuat bagian detail gunung ke buffer normal.  Renderdoc dengan baik hati menyorot piksel yang lulus uji kedalaman dengan warna hijau, dan piksel yang tidak lulus warna merah (tidak akan ditampilkan).  Jumlah piksel yang akan diberikan tanpa lintasan pendahuluan ini kira-kira sama dengan 104518 (dihitung dalam Photoshop).  Jumlah piksel yang benar-benar render adalah 23858 (dihitung oleh Renderdoc).  Hemat sekitar 77%!  Seperti yang kita lihat, dengan penggunaan yang cerdas, kartu pendahuluan ini dapat memberikan keuntungan besar, dan hanya membutuhkan sekitar seratus panggilan draw. <br><br>  <strong>Merekam perintah multithreaded</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/5d0/623/9195d06236fd6247cea6e6065f05e9e8.png"></div><br>  Perlu dicatat satu aspek yang menarik, karena itu saya memilih renderer DX12 - merekam perintah multi-utas.  Di API sebelumnya, seperti DX11, rendering biasanya dilakukan dalam satu utas.  Driver grafis menerima perintah rendering dari game dan terus-menerus mengirimkan permintaan GPU, tetapi game tidak tahu kapan ini akan terjadi.  Ini mengarah ke inefisiensi, karena pengemudi entah bagaimana harus menebak apa yang coba dilakukan aplikasi, dan tidak menskala ke beberapa utas.  API yang lebih baru seperti DX12 menyerahkan kendali kepada pengembang yang dapat memutuskan cara menulis perintah dan kapan mengirimnya.  Meskipun Renderdoc tidak dapat menunjukkan bagaimana perekaman dilakukan, Anda akan melihat bahwa ada tujuh lintasan warna yang ditandai sebagai Color Pass N, dan masing-masing dibungkus dengan sepasang ExecuteCommandList: Reset / Tutup.  Ini menandai awal dan akhir daftar perintah.  Daftar menyumbang sekitar 100-200 panggilan imbang.  Ini tidak berarti bahwa mereka direkam menggunakan beberapa aliran, tetapi mengisinya. <br><br>  <strong>Jejak kaki di salju</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca6/d21/2e8/ca6d212e89b61f52738dfbd01363e366.jpg"></div><br>  Jika Anda melihat Lara, Anda dapat melihat bahwa ketika bergerak di depan tangkapan layar ia meninggalkan jejak di salju.  Di setiap frame, penghitung bayangan dijalankan, yang merekam deformasi di area tertentu dan menerapkannya berdasarkan jenis dan ketinggian permukaan.  Di sini, hanya peta normal yang diterapkan pada salju (mis. Geometri tidak berubah), tetapi di beberapa daerah di mana salju lebih tebal, deformasi sebenarnya dilakukan!  Anda juga dapat melihat bagaimana salju "jatuh" ke tempatnya dan mengisi jejak yang ditinggalkan oleh Lara.  Teknik ini dijelaskan lebih detail dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GPU Pro 7</a> .  Tekstur salju lusi adalah sejenis peta ketinggian yang melacak gerakan Lara dan menempel di tepinya sehingga shader pengambilan sampel dapat memanfaatkan lipatan ini. <br><br><h4>  Atlas of Shadows </h4><br>  Saat membuat pemetaan bayangan, pendekatan yang cukup umum digunakan - mengemas kartu bayangan sebanyak mungkin menjadi tekstur bayangan yang umum.  Atlas bayangan seperti itu sebenarnya merupakan tekstur 16-bit besar dengan ukuran 16384 × 8196.  Ini memungkinkan Anda untuk secara fleksibel menggunakan kembali dan skala peta bayangan di atlas.  Dalam bingkai yang kami analisis, 8 peta bayangan dicatat di atlas.  Empat dari mereka berhubungan dengan sumber utama penerangan terarah (bulan, karena itu terjadi di malam hari), karena mereka menggunakan peta bayangan mengalir - teknik bayangan jarak jauh yang cukup standar untuk penerangan terarah, yang sudah saya jelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> .  Lebih menarik lagi, beberapa sumber proyeksi dan sorotan juga termasuk dalam penangkapan frame ini.  Fakta bahwa 8 peta bayangan direkam dalam bingkai ini tidak berarti bahwa hanya ada 8 sumber pencahayaan bayangan bayangan di dalamnya.  Gim ini dapat melakukan cache perhitungan bayangan, yaitu pencahayaan yang tidak mengubah posisi sumber atau geometri dalam ruang lingkup seharusnya tidak memperbarui peta bayangannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/8d9/169/f008d9169bd3490c26f923bcc4ea8e85.jpg"></div><br>  Tampaknya rendering bayangan peta juga mendapat manfaat dari penulisan perintah multi-threaded ke daftar, dan dalam hal ini, sebanyak 19 daftar perintah ditulis untuk membuat peta bayangan. <br><br>  <strong>Bayangan dari pencahayaan terarah</strong> <br><br>  Bayangan dari pencahayaan terarah dihitung sebelum diteruskannya pencahayaan dan kemudian disampel.  Saya tidak tahu apa yang akan terjadi jika ada beberapa sumber pencahayaan terarah di tempat kejadian. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/209/845/cef209845628db5e68588f07880542eb.jpg"></div><br><h4>  Oklusi ambien </h4><br>  Untuk oklusi ambien, ROTR memungkinkan Anda untuk menggunakan HBAO atau varian HBAO + (teknik ini awalnya diterbitkan oleh NVIDIA).  Ada beberapa variasi dari algoritma ini, jadi saya akan mempertimbangkan salah satu yang saya temukan di ROTR.  Pertama, buffer kedalaman dibagi menjadi 16 tekstur, yang masing-masing berisi 1/16 dari semua nilai kedalaman.  Pemisahan dilakukan sedemikian rupa sehingga setiap tekstur mengandung satu nilai dari blok 4 × 4 dari tekstur asli yang ditunjukkan pada gambar di bawah ini.  Tekstur pertama berisi semua nilai yang ditandai dengan warna merah (1), yang kedua berisi nilai yang ditandai dengan warna biru (2), dan seterusnya.  Jika Anda ingin tahu lebih banyak tentang teknik ini, berikut adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel oleh</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Louis Bavoil</a> , yang juga merupakan salah satu penulis artikel tentang HBAO. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c9/2dc/60f/1c92dc60fe369caed766efe18dd2739d.png"></div><br>  Langkah selanjutnya menghitung oklusi ambien untuk setiap tekstur, yang memberi kita 16 tekstur AO.  Oklusi ambien dihasilkan sebagai berikut: buffer kedalaman disampel beberapa kali, menciptakan kembali posisi dan mengakumulasikan hasil perhitungan untuk masing-masing sampel.  Setiap tekstur oklusi ambien dihitung menggunakan koordinat pengambilan sampel yang berbeda, yaitu, dalam blok 4x4 piksel, masing-masing piksel menceritakan bagiannya sendiri dari cerita.  Ini dilakukan karena alasan kinerja.  Setiap piksel telah mengambil sampel kedalaman buffer 32 kali, dan efek penuh akan membutuhkan 16 × 32 = 512 sampel, yang merupakan bust bahkan untuk GPU paling kuat.  Kemudian mereka bergabung kembali menjadi satu tekstur layar penuh, yang ternyata cukup berisik, sehingga untuk memperlancar hasilnya setelah itu, dilakukan blur pass layar penuh.  Kami melihat solusi yang sangat mirip di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shadow of Mordor</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25f/e57/dd8/25fe57dd8001f561e9a971b36b57085e.png" alt="gambar"></div><br>  <i>Bagian HBAO</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/113/e1b/7d0/113e1b7d065a25b8f4dfb8dce29c808c.png" alt="gambar"></div><br>  <i>HBAO penuh dengan kebisingan</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/bfe/cd1/063bfecd15cdf8d62a0b6221fddfe4ee.png" alt="gambar"></div><br>  <i>Blur horizontal HBAO penuh</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/af9/8e2/51daf98e295b549a57089b4d17df1975.png" alt="gambar"></div><br>  <i>HBAO siap</i> <br><br><h4>  Pra-pass pencahayaan ubin </h4><br>  Persiapan Cahaya adalah teknik yang agak tidak biasa.  Sebagian besar tim pengembangan menggunakan kombinasi perhitungan pencahayaan langsung + ditangguhkan (dengan variasi, misalnya, dengan ubin, klaster) atau sepenuhnya langsung untuk beberapa efek dari ruang layar.  Teknik pra-pencahayaan sangat tidak biasa sehingga layak mendapat penjelasan.  Jika konsep pencahayaan yang ditangguhkan tradisional adalah untuk memisahkan sifat-sifat bahan dari pencahayaan, maka gagasan untuk memisahkan pencahayaan dari sifat-sifat material adalah landasan dari bagian awal pencahayaan.  Meskipun kata-kata ini terlihat sedikit konyol, perbedaan dari pencahayaan tradisional yang ditangguhkan adalah bahwa kami menyimpan semua sifat material (seperti albedo, warna specular, kekasaran, logam, mikro-oklusi, emisif) dalam buffer-G besar, dan menggunakannya nanti sebagai input data untuk melewati penerangan selanjutnya.  Penerangan tradisional yang ditangguhkan dapat menghadirkan beban besar pada throughput;  semakin kompleks bahannya, semakin banyak informasi dan operasi diperlukan dalam buffer-G.  Namun, dalam izin pencahayaan pendahuluan, pertama-tama kami mengakumulasikan semua pencahayaan secara terpisah, menggunakan jumlah data minimum, dan kemudian menerapkannya pada izin berikutnya pada material.  Dalam hal ini, pencahayaan hanya cukup untuk normals, roughness dan metalness.  Shader (dua lintasan digunakan di sini) menghasilkan data dalam tiga format render target RGBA16F.  Satu berisi pencahayaan difus, yang kedua berisi pencahayaan specular, dan yang ketiga berisi pencahayaan sekitar.  Pada titik ini, semua data bayangan diperhitungkan.  Sangat mengherankan bahwa pada lintasan pertama (pencahayaan bercermin + cermin) untuk lintasan layar penuh, digunakan quadrangle dua segitiga, dan pada efek lainnya, satu segitiga layar penuh digunakan (mengapa ini penting, Anda dapat menemukannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Dari sudut pandang ini, seluruh bingkai tidak terpisahkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/6ba/a3b/41d6baa3b45cc3e0df1423eaf015d416.jpg" alt="gambar"></div><br>  <i>Pencahayaan baur</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cd/0c5/137/9cd0c513782787daa220b7627b11b28e.jpg" alt="gambar"></div><br>  <i>Pencahayaan Cermin</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33d/ed9/cbc/33ded9cbc62470319b7729b542b7e830.jpg" alt="gambar"></div><br>  <i>Pencahayaan sekitar</i> <br><br>  <strong>Pengoptimalan ubin</strong> <br><br>  Pencahayaan genteng adalah teknik pengoptimalan yang dirancang untuk menghasilkan sejumlah besar sumber cahaya.  ROTR membagi layar menjadi 16 × 16 ubin, dan kemudian menyimpan informasi tentang sumber mana yang melintasi setiap ubin, yaitu, perhitungan pencahayaan hanya akan dilakukan untuk sumber-sumber yang terkait dengan ubin tersebut.  Pada awal frame, serangkaian shader komputasi diluncurkan, yang menentukan sumber mana yang berhubungan dengan ubin.  Pada tahap pencahayaan, setiap piksel menentukan ubin yang ada di dalamnya dan loop melalui setiap sumber cahaya di ubin, melakukan semua perhitungan pencahayaan.  Jika sumber ditautkan ke ubin secara efisien, Anda dapat menyimpan banyak perhitungan dan sebagian besar bandwidth, serta meningkatkan produktivitas. <br><br>  <strong>Zoom Kedalaman</strong> <br><br>  Upampling berbasis kedalaman adalah teknik menarik yang berguna dalam operan ini dan selanjutnya.  Kadang-kadang algoritma yang mahal secara komputasi tidak dapat dirender pada resolusi penuh, sehingga mereka diberikan pada resolusi yang lebih rendah, dan kemudian ditingkatkan.  Dalam kasus kami, pencahayaan sekitar dihitung dalam setengah resolusi, yaitu, setelah perhitungan, pencahayaan harus dibuat kembali dengan benar.  Dalam bentuk paling sederhana, 4 piksel resolusi rendah diambil dan diinterpolasi untuk mendapatkan sesuatu yang menyerupai gambar asli.  Ini berfungsi untuk transisi yang mulus, tetapi tidak terlihat bagus pada diskontinuitas, karena di sana kami mencampur nilai-nilai yang tidak terkait yang dapat berdekatan dalam ruang layar, tetapi jauh dari satu sama lain di ruang dunia.  Dalam solusi untuk masalah ini, beberapa sampel buffer kedalaman biasanya diambil dan dibandingkan dengan sampel kedalaman yang ingin kami buat ulang.  Jika sampel terlalu jauh, maka kami tidak memperhitungkannya saat merekonstruksi.  Skema semacam itu bekerja dengan baik, tetapi itu berarti bahwa shader rekreasi sangat intensif bandwidth. <br><br>  ROTR membuat langkah rumit dengan membuang stensil awal.  Setelah melewati normals, buffer kedalaman benar-benar penuh, sehingga mesin melakukan operan layar penuh, menandai semua piksel yang terputus dalam buffer stensil.  Ketika tiba saatnya untuk menciptakan kembali buffer pencahayaan sekitar, mesin menggunakan dua shader: satu sangat sederhana untuk area tanpa kesenjangan kedalaman, yang lain lebih kompleks untuk piksel dengan celah.  Stensil awal membuang piksel jika tidak termasuk wilayah yang sesuai, mis. Ada biaya hanya di wilayah yang diperlukan.  Gambar-gambar berikut ini jauh lebih jelas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/747/912/729/747912729abfecffd281c72e8ca4e258.jpg" alt="gambar"></div><br>  <i>Pencahayaan Ambient Setengah Resolusi</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0d/e46/b7e/f0de46b7e19ace552377d1a39d86ed22.png" alt="gambar"></div><br>  <i>Menskalakan kedalaman interior</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d64/354/63b/d6435463b209e7361831b279abcf1ae1.jpg" alt="gambar"></div><br>  <i>Pencahayaan ambient resolusi penuh, tanpa tulang rusuk</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/e12/702/db5e1270220121c5ca9c2a9277d519ed.png" alt="gambar"></div><br>  <i>Meningkatkan kedalaman tulang rusuk</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/971/5cf/3ea9715cf0c57785d926b0711808b256.jpg" alt="gambar"></div><br>  <i>Pencahayaan ambient yang siap</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a5/5d2/128/4a55d2128ab191fb120ca3c1c4310c95.jpg" alt="gambar"></div><br>  <i>Tampilan setengah resolusi</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd4/eaa/a07/cd4eaaa0719a527bcdd1add09f00597b.jpg" alt="gambar"></div><br>  <i>Tampilan close-up dari gambar yang dibuat ulang</i> <br><br>  Setelah bagian awal pencahayaan, geometri dipindahkan ke konveyor, hanya kali ini masing-masing objek sampel tekstur pencahayaan, tekstur oklusi ambien dan sifat-sifat lain dari bahan yang kita tidak menulis ke buffer-G dari awal.  Ini bagus, karena bandwidth sangat disimpan di sini karena Anda tidak perlu membaca banyak tekstur untuk menulisnya ke buffer-G besar, kemudian membaca / mendekodekannya lagi.  Kelemahan yang jelas dari pendekatan ini adalah bahwa semua geometri perlu ditransmisikan kembali, dan tekstur bagian awal pencahayaan itu sendiri merupakan beban besar pada throughput.  Saya bertanya-tanya mengapa tidak menggunakan format yang lebih ringan, misalnya R11G11B10F, untuk tekstur lulus pencahayaan awal, tetapi ada informasi tambahan di saluran alpha, jadi ini tidak mungkin.  Bagaimanapun, ini adalah solusi teknis yang menarik.  Pada titik ini, semua geometri buram sudah dirender dan menyala.  Perhatikan bahwa itu termasuk objek yang memancarkan cahaya seperti langit dan layar laptop. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2eb/3cb/0a3/2eb3cb0a3f58c521079fc2bbd1b3fd67.jpg"></div><br><h4>  Refleksi </h4><br>  Adegan ini bukan contoh yang baik untuk menunjukkan refleksi, jadi saya memilih yang lain.  Reflektor bayangan adalah kombinasi yang agak rumit dari siklus yang dapat direduksi menjadi dua bagian: satu sampel peta kubik, dan yang lainnya melakukan SSR (Refleksi ruang layar - perhitungan refleksi di ruang layar);  semua ini dilakukan dalam satu pass dan pada akhirnya dicampur dengan memperhitungkan koefisien yang menentukan apakah SSR mendeteksi refleksi (mungkin koefisien tersebut bukan biner, tetapi merupakan nilai dalam interval [0, 1]).  SSR bekerja dengan cara standar untuk banyak gim - ini berulang kali melacak buffer kedalaman, mencoba menemukan persimpangan terbaik antara sinar yang dipantulkan oleh permukaan yang diarsir dan permukaan lain di layar.  SSR bekerja dengan rantai mip dari skala yang sebelumnya dikurangi dari buffer HDR saat ini, dan tidak dengan seluruh buffer. <br><br>  Ada juga faktor-faktor koreksi seperti kecerahan pantulan, serta tekstur Fresnel yang aneh, yang dihitung sebelum bagian ini, berdasarkan pada normals dan kekasaran.  Saya tidak sepenuhnya yakin, tetapi setelah mempelajari kode perakitan, menurut saya ROTR hanya dapat menghitung SSR untuk permukaan yang halus.  Mesin tidak memiliki rantai mip blur setelah tahap SSR, yang ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin</a> lain, dan bahkan tidak ada yang seperti melacak buffer kedalaman menggunakan sinar, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bervariasi berdasarkan kekasaran</a> .  Secara umum, permukaan yang lebih kasar menerima pantulan dari peta kubik, atau tidak menerimanya sama sekali.  Namun demikian, di mana SSR bekerja, kualitasnya sangat tinggi dan stabil, dengan mempertimbangkan fakta bahwa SSR tidak menumpuk dari waktu ke waktu dan pengaburan spasial tidak dilakukan untuk itu.  Data alfa juga mendukung SSR (di beberapa kuil Anda dapat melihat pantulan yang sangat indah di dalam air) dan ini merupakan tambahan yang baik yang tidak sering Anda lihat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/b6f/093/5afb6f0937fe9b172b8e38d3f0459b9b.jpg" alt="gambar"></div><br>  <i>Refleksi untuk</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/66d/c6c/ecc66dc6ca98108593b9a5ec4695dc63.jpg" alt="gambar"></div><br>  <i>Buffer refleksi</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec9/6ff/e57/ec96ffe5730e775b678a47ae23906b73.jpg" alt="gambar"></div><br>  <i>Refleksi sesudahnya</i> <br><br><h4>  Kabut menyala </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/578/565/d2a/578565d2af38eac19d8aff86b82cf710.jpg"></div><br>  Dalam adegan kami, kabut kurang terwakili karena ia menggelapkan latar belakang dan karena itu dibuat oleh partikel, sehingga kami kembali menggunakan contoh dengan refleksi.  Kabutnya relatif sederhana, tetapi cukup efektif.  Ada dua mode: global, warna umum kabut, dan warna hamburan ke dalam yang diperoleh dari peta kubik.  Mungkin peta kubik sekali lagi diambil dari peta refleksi kubik, atau mungkin dibuat baru.  Dalam kedua mode, penghalusan kabut diambil dari tekstur penghalusan global, di mana kurva penghalusan dikemas untuk beberapa efek.  Dalam skema semacam itu, sungguh luar biasa bahwa kabut ini memberikan kabut yang sangat murah, mis.  hamburan perubahan dalam ruang, menciptakan ilusi interaksi kabut dengan pencahayaan jauh.  Pendekatan ini juga dapat digunakan untuk hamburan atmosfer dalam di dekat langit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e33/e0e/c3a/e33e0ec3aee95a3cd5a669b332946083.jpg" alt="gambar"></div><br>  <i>Kabut ke</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/5ed/c78/acb5edc78ab74eb97b9350c1e7aba261.jpg" alt="gambar"></div><br>  <i>Kabut setelah</i> <br><br><h4>  Pencahayaan volumetrik </h4><br>  Pada tahap awal frame, beberapa operasi dilakukan untuk mempersiapkan pencahayaan volumetrik.  Dua buffer disalin dari CPU ke GPU: indeks sumber cahaya dan data sumber cahaya.  Keduanya dibaca oleh shader komputasi yang menghasilkan tekstur 3D 40x23x16 dari tampilan kamera yang berisi jumlah sumber cahaya yang melintasi area ini.  Teksturnya adalah 40 × 23 karena setiap ubin menempati 32 × 32 piksel (1280/32 = 40, 720/32 = 22.5), dan 16 adalah jumlah piksel secara mendalam.  Teksturnya tidak termasuk semua sumber cahaya, tetapi hanya yang ditandai sebagai banyak (ada tiga di adegan kami).  Seperti yang akan kita lihat di bawah, ada efek volumetrik palsu lainnya yang dibuat oleh tekstur datar.  Tekstur yang ditampilkan memiliki resolusi lebih tinggi - 160x90x64.  Setelah menentukan jumlah sumber cahaya per ubin dan indeksnya, tiga shader komputasi dieksekusi secara berurutan, melakukan operasi berikut: <br><br><ol><li>  Lintasan pertama menentukan jumlah cahaya yang memasuki sel dalam volume dalam bentuk piramida visibilitas.  Setiap sel mengakumulasikan pengaruh semua sumber cahaya, seolah-olah mereka memiliki partikel yang bereaksi terhadap cahaya dan mengembalikan sebagiannya ke kamera. </li><li>  Lintasan kedua mengaburkan pencahayaan dengan radius kecil.  Ini mungkin perlu untuk menghindari kedipan saat menggerakkan kamera, karena resolusinya sangat rendah. </li><li>  Lewat ketiga melewati tekstur volume dari depan ke belakang, secara bertahap menambahkan pengaruh masing-masing sumber dan memberikan tekstur jadi.  Bahkan, ini mensimulasikan jumlah total pencahayaan yang masuk sepanjang balok ke jarak tertentu.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena setiap sel berisi bagian cahaya yang dipantulkan oleh partikel-partikel ke arah kamera, di masing-masingnya kita akan menerima kontribusi gabungan dari semua sel yang sebelumnya dilewati. </font><font style="vertical-align: inherit;">Bagian ini juga tidak kabur.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika semua ini selesai, kami mendapatkan tekstur 3D yang melaporkan seberapa banyak cahaya yang diterima posisi tertentu dibandingkan dengan kamera. </font><font style="vertical-align: inherit;">Semua yang masih harus dilakukan dalam bagian layar penuh adalah menentukan posisi ini, menemukan voxel yang sesuai dari tekstur dan menambahkannya ke buffer HDR. </font><font style="vertical-align: inherit;">Shader pencahayaan itu sendiri sangat sederhana dan hanya berisi sekitar 16 instruksi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/939/e8a/b58939e8ae5abf2320c519abc51f6e8a.jpg" alt="gambar"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volumetrik menyala</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ab/006/e9d/1ab006e9d0b62e0ea0470751185ffe41.jpg" alt="gambar"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencahayaan volumetrik setelah</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendering rambut </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika fungsi PureHair tidak diaktifkan, maka lapisan standar rambut diberikan di atas satu sama lain. </font><font style="vertical-align: inherit;">Solusi ini masih terlihat bagus, tetapi saya ingin fokus pada teknologi terbaru. </font><font style="vertical-align: inherit;">Jika fungsi ini diaktifkan, frame dimulai dengan simulasi rambut Lara dengan urutan shader komputasi. </font><font style="vertical-align: inherit;">Bagian pertama dari Tomb Raider menggunakan teknologi yang disebut TressFX, dan dalam sekuel Crystal Dynamics menerapkan teknologi yang ditingkatkan. </font><font style="vertical-align: inherit;">Setelah perhitungan awal, kami mendapatkan sebanyak 7 buffer. </font><font style="vertical-align: inherit;">Semuanya digunakan untuk mengendalikan rambut Lara. </font><font style="vertical-align: inherit;">Prosesnya adalah sebagai berikut:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luncurkan shader komputasi untuk menghitung nilai gerak berdasarkan posisi sebelumnya dan saat ini (untuk blur gerakan) </font></font></li><li>          1×1        () </li><li>   122       (Triangle Strip) (   —  ).     ,         .    7 ,      .     ,      ,  .      « ». </li><li>  /   quad    ,     ,     .  ,          ,    . </li><li>       4,      (    « ») </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda tertarik mempelajari lebih lanjut tentang ini, maka AMD memiliki banyak </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sumber daya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena ini adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perpustakaan umum yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dibuat oleh perusahaan </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saya bingung dengan tahap sebelum tahap 1, di mana draw call yang sama dilakukan seperti pada tahap 3, dikatakan bahwa itu hanya memberikan nilai kedalaman, tetapi sebenarnya isinya tidak dirender, dan ini menarik; </font><font style="vertical-align: inherit;">mungkin Renderdoc tidak memberitahuku apa-apa. </font><font style="vertical-align: inherit;">Saya menduga bahwa dia mungkin telah mencoba menjalankan permintaan rendering bersyarat, tetapi saya tidak melihat panggilan prediksi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21f/127/76f/21f12776f41f0893c37a677deca12529.jpg" alt="gambar"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rambut</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/f49/ecd/832f49ecd96406db87ee99f3b1089de0.jpg" alt="gambar"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixel rambut yang terlihat</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/33e/030/28933e0309107cfcb3120564d55fd412.jpg" alt="gambar"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rambut yang diarsir</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Render ubin dari data alfa dan partikel </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek transparan lagi menggunakan klasifikasi ubin sumber cahaya dihitung untuk lulus pencahayaan awal ubin. Setiap objek transparan menghitung pencahayaannya sendiri dalam satu lintasan, yaitu, jumlah instruksi dan siklus menjadi cukup menakutkan (itulah sebabnya lintasan awal pencahayaan digunakan untuk objek buram). Objek transparan bahkan dapat melakukan pantulan di ruang layar jika dihidupkan! Setiap objek disajikan dalam urutan penyortiran dari belakang ke depan langsung ke buffer HDR, termasuk kaca, api, air bekas, dll. Bagian alfa juga menjadikan tepi disorot ketika Lara berfokus pada beberapa objek (misalnya, botol dengan campuran yang mudah terbakar pada kotak di sebelah kiri).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/4a8/311/4454a83115f4118ab092fc1ff3bcaaf1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akan tetapi, partikel-partikel tersebut dibuat menjadi penyangga setengah-resolusi untuk memperlancar beban yang sangat besar pada bandwidth yang diciptakan oleh pengecatan ulang mereka, terutama ketika banyak partikel besar yang menutupi layar digunakan untuk membuat kabut, kabut, api, dll. Oleh karena itu, penyangga HDR dan penyangga kedalaman berkurang setengahnya di setiap sisi, setelah itu rendering partikel dimulai. Partikel membuat jumlah besar redrawing, beberapa piksel diarsir sekitar 40 kali. Peta panas menunjukkan apa yang saya maksud. Karena partikel-partikel tersebut dibuat dalam resolusi setengah, trik zoom pintar yang sama digunakan di sini seperti pada pencahayaan sekitar (celah ditandai dalam stensil, pass pertama merender ke dalam piksel internal, yang kedua menciptakan kembali tepi). Anda mungkin memperhatikan bahwa partikel menghasilkan beberapa efek alfa lain, seperti nyala api,bersinar, dll. Ini diperlukan agar alpha dapat diurutkan dengan benar relatif terhadap, misalnya, asap. Anda juga dapat melihat bahwa sinar "volumetrik" muncul di sini, berasal dari lampu sorot keamanan. Mereka ditambahkan di sini, dan tidak dibuat pada tahap pencahayaan volumetrik. Ini adalah cara murah namun realistis untuk membuatnya dari jarak jauh.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e78/0f1/c77/e780f1c77d8c9031e10b1ddc6faf6b20.jpg" alt="gambar"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/409/09c/1db40909cea712bec3b9f1d4eab109d7.jpg" alt="gambar"></div><br> <i> -</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/8f2/80a/2c18f280ab65f272470ff711def4b89e.jpg" alt="gambar"></div><br> <i>   1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/098/e29/66c/098e2966cf5d8bdc62a7d76bfdc2344e.jpg" alt="gambar"></div><br> <i>   2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/c73/f5a/e0bc73f5ab35af88840eebe45f175074.jpg" alt="gambar"></div><br> <i>   3</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb0/6ef/e9e/eb06efe9eb6fe1db3e749e6b1a6c1c9c.jpg" alt="gambar"><br> <i>   </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56e/263/ba6/56e263ba63ae60ee5af108c172711410.jpg" alt="gambar"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8f/564/288/e8f564288ae2310272be7ac9899409d9.jpg" alt="gambar"></div><br> <i> -</i> <br><br><h4>     </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROTR melakukan kecepatan rana dan koreksi nada dalam satu lintasan. Namun, meskipun kami biasanya percaya bahwa koreksi gamma terjadi dengan koreksi nada, ini tidak terjadi di sini. Ada banyak cara untuk menerapkan pencahayaan, seperti yang telah kita lihat dengan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">game </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lain</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Perhitungan pencahayaan dalam ROTR sangat menarik dan hampir tidak memerlukan data perantara atau lintasan, jadi kami akan menjelaskan proses ini secara lebih rinci. Seluruh layar dibagi menjadi 64 × 64 ubin, setelah itu perhitungan kelompok (20, 12, 1) dari 256 aliran di setiap mulai mengisi seluruh layar. Setiap utas pada dasarnya melakukan tugas berikut (pseudo-code disajikan di bawah):</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; ++i) { uint2 iCoord = CalculateCoord(threadID, i, j); <span class="hljs-comment"><span class="hljs-comment">// Obtain coordinate float3 hdrValue = Load(hdrTexture, iCoord.xyz); // Read HDR float maxHDRValue = max3(hdrValue); // Find max component float minHDRValue = min3(hdrValue); // Find min component float clampedAverage = max(0.0, (maxHDRValue + minHDRValue) / 2.0); float logAverage = log(clampedAverage); // Natural logarithm sumLogAverage += logAverage; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap kelompok menghitung jumlah logaritmik dari semua 64 piksel (256 utas, yang masing-masing memproses 16 nilai). Alih-alih menyimpan nilai rata-rata, ia menyimpan jumlah dan jumlah piksel yang benar-benar diproses (tidak semua grup memproses dengan tepat 64 × 64 piksel, karena, misalnya, mereka dapat melampaui tepi layar). Shader dengan bijak menggunakan penyimpanan utas lokal untuk membagi jumlahnya; masing-masing aliran pertama-tama bekerja dengan 16 nilai horisontal, dan kemudian memisahkan aliran meringkas semua nilai-nilai ini secara vertikal, dan akhirnya aliran kontrol grup ini (aliran 0) menambahkan hasilnya dan menyimpan semuanya ke buffer. Buffer ini berisi 240 elemen, yang pada dasarnya memberi kita kecerahan rata-rata banyak area layar. Perintah berikut memulai 64 utas yang melingkari semua nilai ini dan menambahkannya,untuk mendapatkan kecerahan layar akhir. Ini juga mengembalikan kembali dari logaritma ke unit linier.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak punya banyak pengalaman dengan teknik paparan, tetapi membaca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posting ini oleh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Krzysztof Narkovic mengklarifikasi beberapa hal. Menyimpan ke array 64 elemen diperlukan untuk menghitung rata-rata bergerak, di mana Anda dapat melihat nilai-nilai yang dihitung sebelumnya dan memuluskan kurva untuk menghindari perubahan kecerahan yang sangat tajam, menciptakan perubahan tajam dalam kecepatan rana. Ini adalah shader yang sangat kompleks dan saya masih belum menemukan semua detailnya, tetapi hasil akhirnya adalah nilai kecepatan rana yang sesuai dengan bingkai saat ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menemukan kecepatan rana yang memadai, satu lintasan melakukan kecepatan rana terakhir plus koreksi nada. ROTR tampaknya menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tonemapping Fotografi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang menjelaskan penggunaan cara logaritmik alih-alih cara biasa. </font><font style="vertical-align: inherit;">Formula koreksi tonal dalam shader (setelah paparan) dapat diperluas sebagai berikut:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/yv/-k/bzyv-kjhv-hs6lj3mh4yfrh427w.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/zn/1d/idzn1d3rn-3qs7vrokrn94d9z1m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penjelasan singkat dapat ditemukan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saya tidak bisa mencari tahu mengapa pembagian tambahan oleh Lm diperlukan, karena itu membatalkan pengaruh perkalian. </font><font style="vertical-align: inherit;">Dalam kasus apa pun, whitePoint adalah 1.0, jadi prosesnya tidak banyak membantu dalam bingkai ini, gambar hanya mengubah kecepatan rana. </font><font style="vertical-align: inherit;">Bahkan tidak ada batas untuk nilai-nilai interval LDR! </font><font style="vertical-align: inherit;">Itu terjadi selama penilaian warna, ketika kubus warna secara tidak langsung membatasi nilai lebih dari 1.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1a/92f/2e8/e1a92f2e852892aa137c170a56718f8e.jpg" alt="gambar"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paparan terhadap</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/c4f/905/788c4f905eecffaa8d5dbd12d1c8972d.jpg" alt="gambar"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paparan Setelah</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lensa menyala </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suar lensa ditampilkan dengan cara yang menarik. Lulus pendahuluan kecil menghitung tekstur 1xN (di mana N adalah jumlah total elemen silau yang akan dirender sebagai suar lensa, dalam kasus kami ada 28). Tekstur ini berisi nilai alfa untuk partikel dan beberapa informasi lain yang tidak digunakan, tetapi alih-alih menghitungnya dari permintaan visibilitas atau sesuatu yang serupa, mesin menghitungnya dengan menganalisis buffer kedalaman di sekitar partikel dalam lingkaran. Untuk melakukan ini, informasi tentang simpul disimpan dalam buffer yang tersedia untuk pixel shader.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/604/e96/8a0604e96d5a4fe4ebf691719f03d75f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian setiap elemen diberikan sebagai pesawat rata-rata bidang yang dipancarkan dari sumber cahaya. </font><font style="vertical-align: inherit;">Jika nilai alfa kurang dari 0,01, maka nilai NaN ditugaskan ke posisi sehingga partikel ini tidak dirasterisasi. </font><font style="vertical-align: inherit;">Mereka sedikit seperti efek mekar dan menambahkan cahaya, tetapi efek ini sendiri dibuat kemudian.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/526/da9/a18/526da9a184f303dc8e3bfd82cd16034a.jpg" alt="gambar"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lensa menyala</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/465/440/335/4654403353e5b94dc7bae2a68b95ed88.jpg" alt="gambar"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elemen Flare Lensa</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c1/f10/c43/5c1f10c4396cbd6a8502a28b5a53fe0f.jpg" alt="gambar"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lensa menyala setelah</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloom </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom menggunakan pendekatan standar: downsampling buffer HDR dilakukan, piksel cerah diisolasi, dan kemudian skalanya ditingkatkan secara berurutan dengan blur untuk memperluas area pengaruhnya. Hasilnya diperbesar ke resolusi layar dan pengomposisian ditumpangkan di atasnya. Ada beberapa poin menarik yang perlu dijelajahi. Seluruh proses dilakukan dengan menggunakan 7 komputasi shader: 2 untuk downsampling, 1 untuk pengaburan sederhana, 4 untuk memperbesar.</font></font><br><br><ol><li>                  target   (mip 1).        .  ,   mip-    ,           0.02. </li><li>     mip      mip 2, 3, 4  5. </li><li>       mip 5.        ,    .       ,             . </li><li>   —   .  3          ,   mip N    mip N + 1,       ,     .     bloom      ,     . </li><li>     mip 1      HDR-,      bloom. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/478/bc7/b0c478bc7ccc0c4774cea8b2aaa4ec8b.jpg" alt="gambar"></div><br> <i>Bloom </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f77/b74/99b/f77b7499b451e0f232b06d183ccc04f4.jpg"></div><br> <i>MIP 1   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/ae2/875/c65ae2875487b8a9b441a9ce0b137430.jpg"></div><br> <i>MIP 2   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/9a4/757/55b9a4757f48867201dc76df90ea0dd1.jpg"></div><br> <i>MIP 3   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba5/17d/a6f/ba517da6f179cca1067a08115579c155.jpg"></div><br> <i>MIP 4   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/91f/44d/33f91f44dcc1f9a395375fce8535ac2d.jpg" alt="gambar"></div><br> <i>MIP 5   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/561/33d/ecb56133d1965bcc93024c5cded95ec7.jpg"></div><br> <i> MIP 5  Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/0ed/474/2350ed47490101cda12baffbd61fc8f0.jpg"></div><br> <i>MIP 4   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff0/cfb/4df/ff0cfb4dfeea995b8666d4b8aec057a1.jpg"></div><br> <i>MIP 3   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/980/7ca/a31/9807caa31251495050af2e2fd32b5e90.jpg" alt="gambar"></div><br> <i>MIP 2   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/857/4be/854/8574be854f2526857ef9b6854d6f7235.jpg"></div><br> <i>MIP 1   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9be/aa8/8a1/9beaa88a1bf00876801bb103ef85dd16.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom after</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aspek yang aneh adalah bahwa tekstur skala dikurangi mengubah rasio aspek. </font><font style="vertical-align: inherit;">Demi visualisasi, saya mengoreksi mereka, dan saya hanya bisa menebak alasannya; </font><font style="vertical-align: inherit;">mungkin ini dilakukan agar ukuran tekstur adalah kelipatan dari 16. Poin menarik lainnya: karena shader ini biasanya sangat terbatas dalam bandwidth, nilai-nilai yang disimpan dalam memori bersama grup dikonversi dari float32 ke float16! </font><font style="vertical-align: inherit;">Ini memungkinkan shader untuk bertukar operasi matematika untuk menggandakan memori bebas dan bandwidth. </font><font style="vertical-align: inherit;">Agar ini menjadi masalah, rentang nilai harus menjadi cukup besar.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fxaa </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROTR mendukung berbagai teknik anti-aliasing yang berbeda, seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FXAA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Fast Approximate AA) dan SSAA (Super Sampling AA). </font><font style="vertical-align: inherit;">Perlu dicatat bahwa opsi untuk mengaktifkan AA sementara tidak ada, karena untuk sebagian besar game AAA modern, ini menjadi standar. </font><font style="vertical-align: inherit;">Meskipun demikian, FXAA mengatasi tugasnya dengan luar biasa, SSAA juga bekerja dengan baik, ini adalah opsi yang agak "berat" jika permainan tidak memiliki kinerja.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Motion blur </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampaknya Motion blur menggunakan pendekatan yang sangat mirip dengan solusi di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadows of Mordor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Setelah merender pencahayaan volumetrik, pass rendering yang terpisah menampilkan vektor gerakan dari objek animasi ke buffer gerakan. Kemudian buffer ini dikombinasikan dengan gerakan yang disebabkan oleh kamera, dan buffer gerakan akhir menjadi input ke blur pass, yang melakukan blur ke arah yang ditunjukkan oleh vektor gerakan ruang layar. Untuk memperkirakan radius blur dalam beberapa lintasan, tekstur vektor gerakan pada skala tereduksi dihitung sehingga setiap piksel memiliki gagasan perkiraan tentang jenis gerakan apa yang ada di sekitarnya. Pengaburan dilakukan dalam beberapa lintasan pada resolusi setengah dan, seperti yang kita lihat, kemudian skalanya dengan bantuan stensil meningkat dalam dua lintasan. Beberapa operan dilakukan karena dua alasan: pertama,untuk mengurangi jumlah pembacaan tekstur yang diperlukan untuk membuat blur dengan radius yang berpotensi sangat besar, dan kedua karena berbagai jenis blur dilakukan. Itu tergantung pada apakah karakter animasi itu pada piksel saat ini.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/91d/df6/3f491ddf60c6a1a6b9caeaec316eab4f.jpg" alt="gambar"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerak kabur ke</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e5/eb5/d42/2e5eb5d42d4e0c36c4c96e764538f8c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kecepatan Gerak Gerak</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edf/3ed/2e7/edf3ed2e7144ec27ba21b3b16e606c7f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 1</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/c65/931/7c5c6593183900a85a3d0372fce9eb03.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 2</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/bc5/bcc/8a3bc5bcc85c92d698fc081e49c0f318.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 3</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/5e1/a7e/04f5e1a7e722d9818c8a23ef5759c172.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 4</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/98f/579/f9d98f579e02acec8e3ef99e90bdd0c0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 5</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/3ca/b5c/99e3cab5cbf5d25b2eea0d3311eae7cf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 6</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/042/af0/5bd/042af05bd488751c53bd97c73cb037fc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur, memperbesar dan memperkecil</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/26d/c47/e1026dc47d9035e8713422ad8210e6a7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur, tepi zoom</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fitur dan Detail Tambahan </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ada beberapa hal lagi yang layak disebutkan tanpa banyak detail. </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pembekuan kamera: dalam cuaca dingin, tambahkan kepingan salju dan embun beku ke kamera </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kamera Kotor: Menambahkan kotoran ke kamera. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koreksi warna: di ujung bingkai, koreksi warna kecil dilakukan, menggunakan kubus warna yang cukup standar untuk melakukan koreksi warna, seperti dijelaskan di atas, dan juga menambahkan noise untuk membuat beberapa adegan lebih parah </font></font></li></ol><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI diimplementasikan sedikit tidak biasa - ini membuat semua elemen dalam ruang linear. </font><font style="vertical-align: inherit;">Biasanya, pada saat rendering, UI sudah melakukan koreksi nada dan koreksi gamma. </font><font style="vertical-align: inherit;">Namun, ROTR menggunakan ruang linear hingga akhir frame. </font><font style="vertical-align: inherit;">Ini masuk akal, karena gim ini menggunakan UI 3D yang mengingatkan; </font><font style="vertical-align: inherit;">namun, sebelum merekam gambar sRGB ke dalam buffer HDR, gambar tersebut harus dikonversi ke ruang linear sehingga operasi terbaru (koreksi gamma) tidak mengubah warna.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk meringkas </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harap Anda menikmati membaca analisis ini dengan cara yang sama seperti saya melakukannya. </font><font style="vertical-align: inherit;">Secara pribadi, saya pasti belajar banyak dari itu. </font><font style="vertical-align: inherit;">Selamat kepada pengembang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crystal Dynamics yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berbakat </font><font style="vertical-align: inherit;">atas kerja luar biasa yang dilakukan untuk menciptakan mesin ini. </font><font style="vertical-align: inherit;">Saya juga ingin berterima kasih kepada Baldur Karlsson untuk karyanya yang luar biasa di Renderdoc. </font><font style="vertical-align: inherit;">Karyanya membuat men-debug gambar pada PC menjadi proses yang jauh lebih nyaman. </font><font style="vertical-align: inherit;">Saya pikir satu-satunya hal yang sedikit rumit dalam analisis ini adalah pelacakan peluncuran shader sendiri, karena pada saat penulisan fitur ini tidak tersedia untuk DX12. </font><font style="vertical-align: inherit;">Saya berharap bahwa seiring waktu akan muncul dan kita semua akan sangat senang.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436500/">https://habr.com/ru/post/id436500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436490/index.html">Motorola berencana untuk memperkenalkan inkarnasi Razr v3</a></li>
<li><a href="../id436492/index.html">Kami mencari pembicara di Mitap DIY ke-10 17 Februari 2019</a></li>
<li><a href="../id436494/index.html">Mengganti disk sambil mempertahankan penomoran yang tepat dalam CEPH</a></li>
<li><a href="../id436496/index.html">PVS-Studio untuk Java</a></li>
<li><a href="../id436498/index.html">Perangkat Lunak AG: Tidak Hanya ARIS</a></li>
<li><a href="../id436502/index.html">Pampers Berlangganan atau Cara Menjual Lebih Banyak ke Pelanggan yang Sama</a></li>
<li><a href="../id436504/index.html">Sistem dalam Paket, atau Penutup Paket Apa Yang Ada Dalam Chip?</a></li>
<li><a href="../id436506/index.html">Cara membuat AI-rasis tanpa banyak usaha</a></li>
<li><a href="../id436508/index.html">Investasi $ 10 juta dan pujian Wozniak - menciptakan komputer pendidikan untuk anak-anak</a></li>
<li><a href="../id436510/index.html">Data inti secara detail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>