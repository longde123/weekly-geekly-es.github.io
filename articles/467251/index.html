<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèΩ üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üé¶ Rehenes COBOL y Matem√°ticas. Parte 1 üõ∑ üë©üèº‚Äçü§ù‚Äçüë©üèª üéüÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seamos realistas: a nadie le gustan los n√∫meros fraccionarios, incluso las computadoras. 

 Cuando se trata del lenguaje de programaci√≥n COBOL, la pri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rehenes COBOL y Matem√°ticas. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467251/">  Seamos realistas: a nadie le gustan los n√∫meros fraccionarios, incluso las computadoras. <br><br>  Cuando se trata del lenguaje de programaci√≥n COBOL, la primera pregunta que surge en la cabeza de todos siempre se ve as√≠: "¬øPor qu√© la humanidad todav√≠a usa este lenguaje en muchas √°reas vitales?"  Los bancos todav√≠a usan COBOL.  Alrededor del 7% del PIB de los Estados Unidos depende de COBOL en el procesamiento de pagos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CMS</a> .  El Servicio de Impuestos Internos (IRS) de los Estados Unidos, como todos saben, todav√≠a usa COBOL.  Este lenguaje tambi√©n se usa en la aviaci√≥n ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde aqu√≠</a> aprend√≠ algo interesante sobre este tema: el n√∫mero de reserva en los boletos a√©reos sol√≠a ser un puntero habitual).  Se puede decir que muchas organizaciones muy serias, ya sea un sector privado o p√∫blico, todav√≠a est√°n usando COBOL. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/q1/m_/gs/q1m_gsyxbbwdk32ng3w1foeckgc.jpeg"></a> <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La segunda parte</a> <br><br>  El autor del material, cuya primera parte de la traducci√≥n que publicamos hoy, encontrar√° una respuesta a la pregunta de por qu√© COBOL, el lenguaje que apareci√≥ en 1959, todav√≠a est√° tan extendido. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">¬øPor qu√© COBOL sigue vivo?</font> </h2><br>  La respuesta tradicional a esta pregunta es profundamente c√≠nica.  Las organizaciones son pereza, incompetencia y estupidez.  Persiguen lo barato y no est√°n dispuestos a invertir en reescribir sus sistemas de software en algo moderno.  En general, se puede suponer que la raz√≥n por la cual el trabajo de un n√∫mero tan significativo de organizaciones depende de COBOL es una combinaci√≥n de inercia y miop√≠a.  Y en esto, por supuesto, hay algo de verdad.  Reescribir grandes cantidades de c√≥digo confuso es una tarea enorme.  Es caro  Esto es complicado  Y si el software existente parece funcionar bien, la organizaci√≥n no tendr√° una motivaci√≥n particularmente fuerte para invertir en un proyecto para actualizar este software. <br><br>  Todo esto es as√≠.  Pero cuando trabajaba en el IRS, los veteranos de COBOL hablaron sobre c√≥mo trataron de reescribir el c√≥digo en Java y result√≥ que Java no pod√≠a realizar los c√°lculos correctamente. <br><br>  Me son√≥ extremadamente extra√±o.  Es tan extra√±o que inmediatamente pens√© en el alarmista: "¬°Se√±or, eso significa que el IRS ha estado redondeando los pagos de impuestos a todos por 50 a√±os!"  Simplemente no pod√≠a creer que COBOL sea capaz de sortear Java en t√©rminos de los c√°lculos matem√°ticos que necesita el IRS.  Al final, no lanzaron personas al espacio. <br><br>  Uno de los efectos secundarios interesantes de aprender COBOL en el verano es que comenc√© a entender lo siguiente.  El punto no es que Java no pueda realizar correctamente c√°lculos matem√°ticos.  El punto es exactamente c√≥mo Java hace los c√°lculos correctos.  Y cuando comprende c√≥mo se realizan los c√°lculos en Java y c√≥mo se hace lo mismo en COBOL, comienza a comprender por qu√© a muchas organizaciones les resulta tan dif√≠cil deshacerse de su legado inform√°tico. <br><br><h2>  <font color="#3AC1EF">¬øQu√© "i" debe estar punteado?</font> </h2><br>  Voy a alejarme un poco de la historia de COBOL y hablar sobre c√≥mo las computadoras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">almacenaron informaci√≥n</a> antes de que la representaci√≥n binaria de datos se convirtiera en el est√°ndar de facto (pero el material sobre c√≥mo usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la interfaz</a> z / OS; esto es algo especial).  Creo que al considerar nuestro problema, ser√° √∫til desviarse del tema principal en esta direcci√≥n.  En el material anterior, habl√© sobre varias formas de usar interruptores binarios para almacenar n√∫meros en sistemas binarios, ternarios, decimales, para almacenar n√∫meros negativos, y as√≠ sucesivamente.  Lo √∫nico a lo que no le prest√© suficiente atenci√≥n fue c√≥mo se almacenan los n√∫meros decimales. <br><br>  Si dise√±√≥ su propia computadora binaria, entonces podr√≠a comenzar decidiendo que usar√° el sistema de n√∫meros binarios.  Los bits a la izquierda del punto representan enteros - 1, 2, 4, 8. Y los bits a la derecha - n√∫meros fraccionarios - 1/2, 1/4, 1/8 ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/2eb/182/c872eb1825dc1d6b456ae11cbcc3325d.png"></div><br>  <i><font color="#999999">2,75 en representaci√≥n binaria</font></i> <br><br>  El problema aqu√≠ es entender c√≥mo almacenar el punto decimal en s√≠ mismo (de hecho, deber√≠a decir "punto binario", porque, despu√©s de todo, estamos hablando de n√∫meros binarios).  Esto no es una especie de "alquimia inform√°tica", por lo que puede adivinar de qu√© estoy hablando de n√∫meros de punto flotante y n√∫meros de punto fijo.  En los n√∫meros de coma flotante, un punto binario se puede colocar en cualquier lugar (es decir, puede "flotar").  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La posici√≥n del</a> punto se almacena como un exponente.  La capacidad de mover un punto hace posible almacenar un rango de n√∫meros m√°s amplio que el que est√° disponible en ausencia de tal oportunidad.  El punto decimal se puede mover a la parte posterior del n√∫mero y seleccionar todos los bits para almacenar valores enteros, que representan n√∫meros muy grandes.  El punto puede desplazarse al frente del n√∫mero y expresar valores muy peque√±os.  Pero esta libertad tiene un precio de precisi√≥n.  Echemos otro vistazo a la representaci√≥n binaria de 2.75 del ejemplo anterior.  Una transici√≥n de cuatro a ocho es mucho m√°s que una transici√≥n de un cuarto a un octavo.  Puede ser m√°s f√°cil para nosotros imaginar esto si reescribimos el ejemplo como se muestra a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/894/ec9/8aa/894ec98aa1715609e45d95ede3b865b1.png"></div><br>  <i><font color="#999999">Eleg√≠ la distancia entre los n√∫meros a simple vista, solo para demostrar mi idea.</font></i> <br><br>  La diferencia entre los n√∫meros es f√°cil de calcular por su cuenta.  Por ejemplo, la distancia entre 1/16 y 1/32 es 0.03125, pero la distancia entre 1/2 y 1/4 ya es 0.25. <br><br>  ¬øPor qu√© es esto importante?  En el caso de una representaci√≥n binaria de enteros, esto no importa: la distancia entre los n√∫meros adyacentes de un registro binario se puede compensar f√°cilmente llen√°ndolos con las combinaciones apropiadas de bits y sin perder precisi√≥n.  Pero en el caso de la representaci√≥n de n√∫meros fraccionarios, no es tan simple.  Si intenta "llenar" los "agujeros" entre n√∫meros adyacentes, algo puede "caer" (y en realidad caer) en estos agujeros.  Esto lleva al hecho de que en formato binario no es posible obtener representaciones exactas de n√∫meros fraccionarios. <br><br>  Esto se ilustra con el ejemplo cl√°sico del n√∫mero 0.1 (una d√©cima).  ¬øC√≥mo representar este n√∫mero en formato binario?  2 <sup>-1</sup> es 1/2, o 0.5.  Esto es demasiado  1/16 es 0.0635.  Esto es muy poco.  1/16 + 1/32 ya est√° m√°s cerca (0.09375), pero 1/16 + 1/32 + 1/64 ya es m√°s de lo que necesitamos (0.109375). <br><br>  Si cree que este razonamiento puede continuar indefinidamente, entonces tiene raz√≥n, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tal como est√°</a> . <br><br>  Aqu√≠ puede decirse a s√≠ mismo: ‚Äú¬øPor qu√© no ahorramos 0.1 de la misma manera que almacenamos el n√∫mero 1?  Podemos guardar el n√∫mero 1 sin ning√∫n problema, as√≠ que simplemente eliminemos el punto decimal y almacenemos cualquier n√∫mero de la misma manera que almacenamos enteros ". <br><br>  Esta es una excelente soluci√≥n a este problema, excepto que requiere fijar el punto binario / decimal en una ubicaci√≥n predeterminada.  De lo contrario, los n√∫meros 10.00001 y 100000.1 se ver√°n exactamente iguales.  Pero si el punto es fijo de modo que, digamos, se asignan 2 d√≠gitos a la parte fraccionaria del n√∫mero, entonces podemos redondear 10.00001 a 10.00, y 100000.1 dar√° vuelta 100000.10. <br><br>  Acabamos de "inventar" n√∫meros de punto fijo. <br><br>  Con la representaci√≥n de diferentes valores usando n√∫meros de punto fijo, simplemente lo descubrimos.  Es facil de hacer.  ¬øEs posible, utilizando n√∫meros de punto fijo, facilitar la soluci√≥n de otros problemas?  Recordemos aqu√≠ sobre nuestros buenos amigos, sobre n√∫meros decimales binarios (Binary Coded Decimal, BCD).  Por cierto, para hacerle saber, estos n√∫meros se usan en la mayor√≠a de las calculadoras cient√≠ficas y gr√°ficas.  De estos dispositivos, que es bastante claro, esperan los resultados correctos de los c√°lculos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/102/020/d31/102020d313c5627bb37fc6dee57954a4.jpg"></div><br>  <i><font color="#999999">Calculadora TI-84 Plus</font></i> <br><br><h2>  <font color="#3AC1EF">Relaci√≥n de recurrencia de Muller y Python</font> </h2><br>  Los n√∫meros de punto fijo se consideran m√°s precisos debido al hecho de que los "agujeros" entre los n√∫meros son constantes, y porque el redondeo ocurre solo cuando necesita imaginar un n√∫mero para el que simplemente no hay suficiente espacio.  Pero cuando usamos n√∫meros de coma flotante, podemos representar n√∫meros muy grandes y muy peque√±os usando la misma cantidad de memoria.  Es cierto que con su ayuda es imposible representar todos los n√∫meros en el rango accesible con precisi√≥n y nos vemos obligados a recurrir al redondeo para llenar los "agujeros". <br><br>  COBOL se cre√≥ como un idioma en el que, por defecto, se utilizan n√∫meros de punto fijo.  ¬øPero esto significa que COBOL es mejor que los lenguajes modernos para realizar c√°lculos matem√°ticos?  Si nos damos cuenta de un problema como el resultado del c√°lculo del valor 0.1 + 0.2, puede parecer que la pregunta anterior deber√≠a responderse "s√≠".  Pero ser√° aburrido.  As√≠ que sigamos adelante. <br><br>  Vamos a experimentar con COBOL utilizando la llamada relaci√≥n de recurrencia de Muller.  Jean-Michel Muller es un cient√≠fico franc√©s que pudo haber realizado un importante descubrimiento cient√≠fico en el campo de la tecnolog√≠a de la informaci√≥n.  Encontr√≥ una manera de romper el funcionamiento correcto de las computadoras usando las matem√°ticas.  Estoy seguro de que dir√≠a que estudia los problemas de fiabilidad y precisi√≥n, pero no y no otra vez: crea problemas matem√°ticos que "rompen" las computadoras.  Una de estas tareas es su f√≥rmula de recurrencia.  Se ve as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fa/1d8/56c/8fa1d856cfe581c272fc25a8c55e8938.png"></div><br>  <i><font color="#999999">Este ejemplo est√° tomado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de aqu√≠.</a></font></i> <br><br>  La f√≥rmula no parece aterradora en absoluto.  Derecho?  Esta tarea es adecuada para nuestros prop√≥sitos por las siguientes razones: <br><br><ul><li>  Aqu√≠ solo se usan reglas simples de matem√°ticas: no hay f√≥rmulas complicadas ni ideas profundas. </li><li>  Comenzamos con un n√∫mero que tiene dos d√≠gitos despu√©s del punto decimal.  Como resultado, es f√°cil imaginar que estamos trabajando con valores que representan ciertas cantidades de dinero. </li><li>  El error que resulta de los c√°lculos no es un peque√±o error de redondeo.  Esta es una desviaci√≥n del resultado correcto en √≥rdenes de magnitud completas. </li></ul><br>  Aqu√≠ hay un peque√±o script de Python que calcula los resultados de la relaci√≥n de recurrencia de Mueller usando n√∫meros de punto flotante y de punto fijo: <br><br><pre><code class="plaintext hljs">from decimal import Decimal def rec(y, z):  return 108 - ((815-1500/z)/y)  def floatpt(N):  x = [4, 4.25]  for i in range(2, N+1):   x.append(rec(x[i-1], x[i-2]))  return x  def fixedpt(N):  x = [Decimal(4), Decimal(17)/Decimal(4)]  for i in range(2, N+1):   x.append(rec(x[i-1], x[i-2]))  return x N = 20 flt = floatpt(N) fxd = fixedpt(N) for i in range(N):  print str(i) + ' | '+str(flt[i])+' | '+str(fxd[i])</code> </pre> <br>  Aqu√≠ est√° el resultado de este script: <br><br><pre> <code class="plaintext hljs">i | floating pt  | fixed pt -- | -------------- | --------------------------- 0 | 4       | 4 1 | 4.25      | 4.25 2 | 4.47058823529 | 4.4705882352941176470588235 3 | 4.64473684211 | 4.6447368421052631578947362 4 | 4.77053824363 | 4.7705382436260623229461618 5 | 4.85570071257 | 4.8557007125890736342039857 6 | 4.91084749866 | 4.9108474990827932004342938 7 | 4.94553739553 | 4.9455374041239167246519529 8 | 4.96696240804 | 4.9669625817627005962571288 9 | 4.98004220429 | 4.9800457013556311118526582 10 | 4.9879092328  | 4.9879794484783912679439415 11 | 4.99136264131 | 4.9927702880620482067468253 12 | 4.96745509555 | 4.9956558915062356478184985 13 | 4.42969049831 | 4.9973912683733697540253088 14 | -7.81723657846 | 4.9984339437852482376781601 15 | 168.939167671 | 4.9990600687785413938424188 16 | 102.039963152 | 4.9994358732880376990501184 17 | 100.099947516 | 4.9996602467866575821700634 18 | 100.004992041 | 4.9997713526716167817979714 19 | 100.000249579 | 4.9993671517118171375788238</code> </pre> <br>  Hasta la iteraci√≥n 12, el error de redondeo parece m√°s o menos insignificante, pero luego comienza el verdadero infierno.  Los c√°lculos de punto flotante convergen a un n√∫mero que es veinte veces mayor que el resultado de los c√°lculos de punto fijo. <br><br>  Quiz√°s piense que es poco probable que alguien realice c√°lculos recursivos a gran escala.  Pero esto es precisamente lo que caus√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el desastre de</a> 1991, que provoc√≥ la muerte de 28 personas, cuando el sistema de control de misiles Patriot calcul√≥ incorrectamente el tiempo.  Result√≥ que los c√°lculos de coma flotante causaron mucho da√±o accidentalmente.  Aqu√≠ hay algunas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cosas</a> excelentes que tal vez la inform√°tica de alto rendimiento es solo una forma m√°s r√°pida de obtener las respuestas incorrectas.  Lea este trabajo si desea obtener m√°s informaci√≥n sobre el problema discutido aqu√≠ y vea m√°s ejemplos. <br><br>  El problema es que la cantidad de RAM que tienen las computadoras no es infinita.  Por lo tanto, es imposible almacenar un n√∫mero infinito de posiciones decimales (o binarias).  Los c√°lculos de punto fijo pueden ser m√°s precisos que los c√°lculos de punto flotante si existe la confianza de que es menos probable que se necesiten m√°s n√∫meros despu√©s del punto que el formato utilizado.  Si el n√∫mero no cabe en este formato, se redondear√°.  Cabe se√±alar que ni los c√°lculos de punto fijo ni los de punto flotante est√°n protegidos del problema que demuestra la relaci√≥n de recurrencia de Mueller.  Tanto eso como otros como resultado dan resultados incorrectos.  La pregunta es cu√°ndo sucede esto.  Si aumenta el n√∫mero de iteraciones en un script de Python, por ejemplo, de 20 a 22, el n√∫mero final obtenido en los c√°lculos con un punto fijo ser√° 0.728107.  23 iteraciones?  -501.7081261.  24?  105.8598187. <br><br>  En diferentes idiomas, este problema se manifiesta de diferentes maneras.  Algunos, como COBOL, le permiten trabajar con n√∫meros cuyos par√°metros est√°n bien ajustados.  Y en Python, por ejemplo, hay valores predeterminados que se pueden configurar si la computadora tiene suficiente memoria.  Si agregamos la l√≠nea <code>getcontext().prec = 60</code> a nuestro programa, dici√©ndole al m√≥dulo decimal de Python que usar√≠a 60 posiciones despu√©s del per√≠odo, y no 28, como se hace por defecto, el programa podr√° realizar 40 iteraciones de la relaci√≥n de recurrencia sin errores Mueller <br><br>  Continuar√° ... <br><br>  <b>Estimados lectores!</b>  ¬øHa encontrado serios problemas derivados de la naturaleza de los c√°lculos de coma flotante? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467251/">https://habr.com/ru/post/467251/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467239/index.html">La diferencia entre Data Scientist y un adolescente en un auto deportivo</a></li>
<li><a href="../467241/index.html">Carro para camiones ROS. Parte 4. Crear una simulaci√≥n de robot usando los editores rviz y gazebo</a></li>
<li><a href="../467245/index.html">Dmitry Matskevich, Dbrain: sobre el emprendimiento como una discapacidad mental, IA y seguridad emocional</a></li>
<li><a href="../467247/index.html">Una historia sobre V8, React y una ca√≠da en el rendimiento. Parte 1</a></li>
<li><a href="../467249/index.html">Una historia sobre V8, React y una ca√≠da en el rendimiento. Parte 2</a></li>
<li><a href="../467253/index.html">Rehenes COBOL y Matem√°ticas. Parte 2</a></li>
<li><a href="../467255/index.html">Tres errores de seguridad comunes que todo desarrollador de React debe conocer</a></li>
<li><a href="../467257/index.html">No guardes todos tus huevos en una canasta a la vez</a></li>
<li><a href="../467259/index.html">DPI (inspecci√≥n SSL) contradice el significado de la criptograf√≠a, pero las empresas la implementan</a></li>
<li><a href="../467261/index.html">Roscado adecuado en Qt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>