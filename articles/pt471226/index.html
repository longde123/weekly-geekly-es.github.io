<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòä üêü ‚òÆÔ∏è O Linux tem muitas faces: como trabalhar em qualquer distribui√ß√£o üìå üë≤üèΩ üßÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Criar um aplicativo de backup que seja executado em qualquer distribui√ß√£o n√£o √© uma tarefa f√°cil. Para garantir que o Veeam Agent for Linux funcione n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O Linux tem muitas faces: como trabalhar em qualquer distribui√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/471226/"><img src="https://habrastorage.org/webt/ry/zz/2e/ryzz2enp795e4whkxs9rgxbmwsm.jpeg"><br><br>  Criar um aplicativo de backup que seja executado em qualquer distribui√ß√£o n√£o √© uma tarefa f√°cil.  Para garantir que o Veeam Agent for Linux funcione nas distribui√ß√µes do RHEL 6 e Debian 6, at√© o openSUSE Leap 15.1 e Ubuntu 19.04, voc√™ deve resolver uma s√©rie de problemas, principalmente quando considerar que o m√≥dulo do kernel faz parte do produto de software. <br><br>  Este artigo √© baseado em uma apresenta√ß√£o na confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LinuxPiter 2019</a> . <br><a name="habracut"></a><br>  O Linux n√£o √© apenas um dos sistemas operacionais mais populares.  De fato, esta √© uma plataforma com base na qual voc√™ pode fazer algo √∫nico, algo seu.  Por esse motivo, o Linux possui muitas distribui√ß√µes que diferem em um conjunto de componentes de software.  E aqui surge o problema: para que o produto de software funcione em qualquer distribui√ß√£o, √© necess√°rio levar em considera√ß√£o as caracter√≠sticas de cada uma. <br><br><h2>  Gerenciadores de pacotes.  .deb vs .rpm </h2><br>  Vamos come√ßar com o problema √≥bvio de distribuir o produto para diferentes distribui√ß√µes. <br>  A maneira mais comum de distribuir produtos de software √© colocar o pacote no reposit√≥rio para que o gerenciador de pacotes embutido no sistema possa instal√°-lo a partir da√≠. <br>  No entanto, temos dois formatos populares de pacotes: <i>rpm</i> e <i>deb</i> .  Ent√£o, todos ter√£o que apoiar. <br><br>  No mundo dos pacotes deb, o n√≠vel de compatibilidade √© incr√≠vel.  O mesmo pacote instala-se igualmente bem e funciona no Debian 6 e no Ubuntu 19.04.  Os padr√µes para o processo de compila√ß√£o de pacotes e seu trabalho, estabelecidos nas antigas distribui√ß√µes Debian, permanecem relevantes no novo Linux Mint e no SO elementar.  Portanto, no caso do Veeam Agent for Linux, um pacote deb para cada plataforma de hardware √© suficiente. <br><br>  Mas no mundo dos pacotes rpm, as diferen√ßas s√£o grandes.  Em primeiro lugar, devido ao fato de haver dois distribuidores completamente independentes do Red Hat e do SUSE, para os quais a compatibilidade n√£o √© absolutamente necess√°ria.  Em segundo lugar, esses distribuidores t√™m distribui√ß√µes desses.  suporte e experimental.  Entre eles, a compatibilidade tamb√©m n√£o √© necess√°ria.  Descobriu-se que para el6, el7 e el8 seus pr√≥prios pacotes.  Pacote separado para o Fedora.  Pacotes para SLES11 e 12 e separados para openSUSE.  O principal problema s√£o depend√™ncias e nomes de pacotes. <br><br><h2>  Problema de depend√™ncia </h2><br>  Infelizmente, os mesmos pacotes geralmente acabam com nomes diferentes em diferentes distribui√ß√µes.  Abaixo est√° uma lista parcial das depend√™ncias do pacote veeam. <br><div class="scrollable-table"><table><tbody><tr><th>  Para EL7: </th><th>  Para o SLES 12: </th></tr><tr><td><ul><li>  libblkid </li><li>  libgcc </li><li>  libstdc ++ </li><li>  ncurses-libs </li><li>  bibliotecas de fus√≠veis </li><li>  libs de arquivo </li><li>  veeamsnap = 3.0.2.1185 </li></ul></td><td><ul><li>  libblkid1 </li><li>  libgcc_s1 </li><li>  libstdc ++ 6 </li><li>  libmagic1 </li><li>  libfuse2 </li><li>  veeamsnap-kmp = 3.0.2.1185 </li></ul></td></tr></tbody></table></div><br>  Como resultado, a lista de depend√™ncias √© exclusiva para a distribui√ß√£o. <br><br>  Fica pior quando uma vers√£o atualizada come√ßa a se esconder sob o nome do pacote antigo. <br><br>  <b>Um exemplo:</b> <br><br>  O Fedora 24 atualizou o pacote <i>ncurses</i> da vers√£o 5 para a vers√£o 6. Nosso produto foi constru√≠do com a vers√£o 5 para garantir a compatibilidade com distribui√ß√µes mais antigas.  Para usar a antiga vers√£o 5 da biblioteca no Fedora 24, eu tive que usar o pacote <i>ncurses-compat-libs</i> . <br><br>  Como resultado, dois pacotes aparecem para o Fedora, com diferentes depend√™ncias. <br><br>  Mais interessante.  Ap√≥s a pr√≥xima atualiza√ß√£o do pacote de distribui√ß√£o, o pacote <i>ncurses-compat-libs</i> com a 5¬™ vers√£o da biblioteca fica indispon√≠vel.  N√£o √© rent√°vel para um distribuidor atrair bibliotecas antigas para uma nova vers√£o de distribui√ß√£o.  Depois de algum tempo, o problema foi repetido nas distribui√ß√µes do SUSE. <br><br>  Como resultado, em algumas distribui√ß√µes, tive que abandonar a depend√™ncia expl√≠cita de <i>ncurses-libs</i> e corrigir o produto para que ele pudesse funcionar com qualquer vers√£o da biblioteca. <br><br>  A prop√≥sito, na 8¬™ vers√£o do Red Hat, n√£o h√° mais um meta-pacote <i>python</i> que fa√ßa refer√™ncia ao bom e velho <i>python 2.7</i> .  Existem <i>python2</i> e <i>python</i> 3. <br><br><h2>  Alternativa aos gerenciadores de pacotes </h2><br>  O problema com depend√™ncias √© antigo e h√° muito √≥bvio.  Apenas lembre-se do inferno da Depend√™ncia. <br>  Combine v√°rias bibliotecas e aplicativos para que todos funcionem de maneira est√°vel e n√£o entrem em conflito - de fato, qualquer distribuidor Linux est√° tentando resolver esse problema. <br><br>  O gerenciador de pacotes Canonical <b>Snappy est√°</b> tentando resolver esse problema de maneira bastante diferente.  A id√©ia principal: o aplicativo √© executado em uma caixa de prote√ß√£o isolada e protegida do sistema principal.  Se o aplicativo precisar de bibliotecas, elas ser√£o entregues com o pr√≥prio aplicativo. <br><br>  <b>O Flatpak</b> tamb√©m permite executar aplicativos na sandbox usando o Linux Containers.  H√° tamb√©m o <b>AppImage</b> , que permite criar imagens port√°teis de programas. <br><br>  Essas solu√ß√µes permitem criar um pacote para qualquer distribui√ß√£o.  No caso do <b>Flatpak</b> e <b>AppImage, a</b> instala√ß√£o e o lan√ßamento do aplicativo s√£o poss√≠veis mesmo sem o conhecimento do administrador. <br><br>  O principal problema √© que nem todos os aplicativos podem ser executados na sandbox e sem privil√©gios de <i>root</i> .  Alguns precisam de acesso direto √† plataforma.  N√£o estou falando de m√≥dulos do kernel, que s√£o altamente dependentes do kernel e n√£o se encaixam no conceito de sandbox. <br><br>  O segundo problema √© que as distribui√ß√µes populares da Red Hat e SUSE no ambiente corporativo ainda n√£o oferecem suporte ao Snappy e Flatpak. <br><br>  Nesse sentido, o Veeam Agent for Linux n√£o est√° no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">snapcraft.io</a> nem no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">flathub.org</a> . <br><br>  No final da pergunta sobre gerenciadores de pacotes, observo que h√° uma op√ß√£o para abandonar completamente os gerenciadores de pacotes combinando arquivos bin√°rios e um script para instal√°-los em um pacote. <br><br>  Esse pacote permite criar um pacote comum para diferentes distribui√ß√µes e plataformas, para executar um processo de instala√ß√£o interativa, executando a customiza√ß√£o necess√°ria.  Me deparei com esses pacotes apenas para Linux da VMware. <br><br><h2>  Problema de atualiza√ß√£o </h2><br><img src="https://habrastorage.org/webt/ny/8c/-k/ny8c-kdpc74mgrym0nszgkd0d04.png"><br>  Mesmo se todos os problemas de depend√™ncia forem resolvidos, o programa poder√° funcionar de maneira diferente na mesma distribui√ß√£o.  O ponto est√° nas atualiza√ß√µes. <br><br>  Existem tr√™s estrat√©gias de atualiza√ß√£o: <br><br><ul><li>  O mais f√°cil √© nunca atualizar.  Configurou o servidor e esqueceu.  Por que atualiza√ß√µes se tudo funciona?  Os problemas come√ßam na primeira vez em que voc√™ entra em contato com o suporte.  O criador da distribui√ß√£o suporta apenas uma vers√£o atualizada. </li><li>  Voc√™ pode confiar no distribuidor e configurar atualiza√ß√µes autom√°ticas.  Nesse caso, √© prov√°vel que haja uma chamada para o suporte imediatamente ap√≥s uma atualiza√ß√£o sem √™xito. </li><li>  A op√ß√£o de atualiza√ß√£o manual somente ap√≥s execut√°-la na infraestrutura de teste √© a mais fiel, mas cara e demorada.  Nem todo mundo √© capaz de pagar. </li></ul><br>  Como usu√°rios diferentes usam estrat√©gias de atualiza√ß√£o diferentes, √© necess√°rio oferecer suporte √† vers√£o mais recente e a todas as vers√µes anteriores.  Isso complica o processo de desenvolvimento e o processo de teste, adiciona uma dor de cabe√ßa ao servi√ßo de suporte. <br><br><h2>  Variedade de plataformas de hardware </h2><br>  V√°rias plataformas de hardware s√£o um problema amplamente espec√≠fico ao c√≥digo nativo.  No m√≠nimo, voc√™ deve coletar bin√°rios para cada plataforma suportada. <br><br>  No projeto Veeam Agent for Linux, ainda n√£o podemos oferecer suporte a pelo menos algo semelhante ao RISC. <br><br>  N√£o vou me debru√ßar sobre essa quest√£o em detalhes.  Vou descrever apenas os principais problemas: tipos dependentes da plataforma, como <code>size_t</code> , alinhamento de estruturas e ordem de bytes. <br><br><h2>  Liga√ß√£o est√°tica e / ou din√¢mica </h2><br><img src="https://habrastorage.org/webt/x7/im/9v/x7im9v9gtvi7lkwmodbajd0au_g.jpeg"><br>  E aqui est√° a pergunta "Como vincular √†s bibliotecas - din√¢mica ou estaticamente?"  vale a pena discutir. <br><br>  Normalmente, os aplicativos Linux C / C ++ usam vincula√ß√£o din√¢mica.  Isso funciona muito bem se o aplicativo for criado especificamente para uma distribui√ß√£o espec√≠fica. <br><br>  Se a tarefa √© abranger uma variedade de distribui√ß√µes com um arquivo bin√°rio, voc√™ deve se concentrar na distribui√ß√£o suportada mais antiga.  Para n√≥s, esse √© o Red Hat 6. Ele cont√©m o gcc 4.4, que nem o padr√£o C ++ 11 oferece suporte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">completo</a> . <br><br>  Estamos construindo nosso projeto usando o gcc 6.3, que suporta totalmente o C ++ 14.  Naturalmente, neste caso no Red Hat 6, a biblioteca libstdc ++ e boost precisam ser arrastadas.  A maneira mais f√°cil de vincular a eles √© estaticamente. <br><br>  Mas, infelizmente, nem todas as bibliotecas podem ser vinculadas estaticamente. <br><br>  Primeiro, as bibliotecas do sistema, como <i>libfuse</i> , <i>libblkid,</i> precisam ser vinculadas dinamicamente para garantir que sejam compat√≠veis com o kernel e seus m√≥dulos. <br><br>  Em segundo lugar, h√° uma sutileza com licen√ßas. <br><br>  O licenciamento GPL basicamente permite vincular bibliotecas apenas ao c√≥digo de c√≥digo-fonte aberto.  O MIT e o BSD permitem a vincula√ß√£o est√°tica e permitem a inclus√£o de bibliotecas no projeto.  Mas a LGPL n√£o parece contradizer a vincula√ß√£o est√°tica, mas exige o compartilhamento dos arquivos necess√°rios para a vincula√ß√£o. <br><br>  Em geral, o uso de links din√¢micos proteger√° contra a necessidade de fornecer algo. <br><br><h2>  Criando aplicativos C / C ++ </h2><br>  Para criar aplicativos C / C ++ para diferentes plataformas e distribui√ß√µes, basta selecionar ou compilar uma vers√£o adequada do gcc e usar compiladores cruzados para arquiteturas espec√≠ficas, para coletar todo o conjunto de bibliotecas.  Este trabalho √© bastante vi√°vel, mas bastante problem√°tico.  E n√£o h√° garantias de que o compilador e as bibliotecas selecionados fornecer√£o uma op√ß√£o vi√°vel. <br><br>  Uma vantagem √≥bvia: a infraestrutura √© bastante simplificada, pois todo o processo de montagem pode ser realizado em uma m√°quina.  Al√©m disso, √© suficiente coletar um conjunto de arquivos bin√°rios para uma arquitetura e voc√™ pode empacot√°-los em pacotes para diferentes distribui√ß√µes.  √â assim que os pacotes veeam para o Veeam Agent for Linux s√£o criados. <br><br>  Em contraste com essa op√ß√£o, voc√™ pode simplesmente preparar o farm de constru√ß√£o, ou seja, v√°rias m√°quinas para montagem.  Cada uma dessas m√°quinas fornecer√° a compila√ß√£o da aplica√ß√£o e montagem do pacote para uma distribui√ß√£o espec√≠fica e uma arquitetura espec√≠fica.  Nesse caso, a compila√ß√£o √© realizada pelos meios que o distribuidor preparou.  Ou seja, o est√°gio de prepara√ß√£o do compilador e a sele√ß√£o de bibliotecas n√£o s√£o mais necess√°rios.  Al√©m disso, o processo de montagem pode ser facilmente paralelizado. <br><br>  No entanto, h√° um ponto negativo nessa abordagem: para cada distribui√ß√£o dentro da mesma arquitetura, voc√™ precisar√° montar seu pr√≥prio conjunto de arquivos bin√°rios.  Um ponto negativo √© que muitas m√°quinas precisam ser mantidas, para alocar uma grande quantidade de espa√ßo em disco e RAM. <br><br>  Dessa maneira, os pacotes KMOD do m√≥dulo do kernel veeamsnap para distribui√ß√µes do Red Hat s√£o montados. <br><br><h2>  Servi√ßo de compila√ß√£o aberto </h2><br>  Os colegas do SUSE tentaram implementar um meio termo como um servi√ßo especial para compilar aplicativos e criar pacotes - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">openbuildservice</a> . <br><br>  De fato, √© um hipervisor que cria uma m√°quina virtual, instala todos os pacotes necess√°rios, compila o aplicativo e compila o pacote nesse ambiente isolado, ap√≥s o qual a m√°quina virtual √© liberada. <br><br><img src="https://habrastorage.org/webt/y0/4p/uy/y04puyokz_w-fexue3zcgpvhcgc.png"><br><br>  O planejador implementado no OpenBuildService determinar√° quantas m√°quinas virtuais ele pode executar para obter a velocidade ideal de compila√ß√£o de pacotes.  O pr√≥prio mecanismo de assinatura interno assinar√° os pacotes e os colocar√° no reposit√≥rio interno.  O sistema de controle de vers√£o embutido salvar√° o hist√≥rico de altera√ß√µes e montagens.  Resta simplesmente adicionar seu c√≥digo-fonte a este sistema.  Mesmo o servidor em si n√£o √© necess√°rio para aumentar, mas voc√™ pode usar o aberto. <br><br>  Aqui, no entanto, existe um problema: √© dif√≠cil adaptar essa combina√ß√£o √† infraestrutura existente.  Por exemplo, o controle de vers√£o n√£o √© necess√°rio, j√° temos o nosso pr√≥prio para as fontes.  O mecanismo de assinatura √© diferente: um servidor especial √© usado.  O reposit√≥rio tamb√©m n√£o √© necess√°rio. <br><br>  Al√©m disso, o suporte a outras distribui√ß√µes - por exemplo, Red Hat - √© implementado pouco, o que √© compreens√≠vel. <br><br>  A vantagem desse servi√ßo √© o suporte r√°pido da pr√≥xima vers√£o da distribui√ß√£o do SUSE.  Antes do an√∫ncio oficial do lan√ßamento, os pacotes necess√°rios para a montagem s√£o carregados no reposit√≥rio p√∫blico.  Um novo aparece na lista de distribui√ß√µes dispon√≠veis no OpenBuildService.  Colocamos uma marca e ela √© adicionada ao plano de montagem.  Assim, a adi√ß√£o de uma nova vers√£o da distribui√ß√£o √© realizada em quase um clique. <br><br>  Em nossa infraestrutura, usando o OpenBuildService, reunimos toda a variedade de pacotes KMP do m√≥dulo do kernel do veeamsnap para distribui√ß√µes do SUSE. <br><br>  Al√©m disso, gostaria de me concentrar em quest√µes espec√≠ficas dos m√≥dulos do kernel. <br><br><h2>  ABI do kernel </h2><br>  Os m√≥dulos do kernel do Linux historicamente foram distribu√≠dos na forma de origem.  O fato √© que os criadores do kernel n√£o se sobrecarregam com o cuidado de manter uma API est√°vel para os m√≥dulos do kernel, e mais ainda no n√≠vel bin√°rio, do que o kABI. <br><br>  Para criar um m√≥dulo para o kernel vanilla, s√£o necess√°rios cabe√ßalhos desse kernel espec√≠fico, e ele funcionar√° apenas nesse n√∫cleo. <br><br>  O DKMS permite automatizar o processo de montagem de m√≥dulos ao atualizar o kernel.  Como resultado, os usu√°rios do reposit√≥rio Debian (e seus muitos parentes) usam m√≥dulos do kernel no reposit√≥rio do distribuidor ou montados na fonte usando o DKMS. <br><br>  No entanto, essa situa√ß√£o n√£o √© particularmente confort√°vel com o segmento corporativo.  Os distribuidores de c√≥digos propriet√°rios desejam distribuir o produto na forma de bin√°rios compilados. <br><br>  Os administradores n√£o desejam manter ferramentas de desenvolvimento nos servidores de produ√ß√£o por motivos de seguran√ßa.  Os distribuidores Enterprise Linux - como Red Hat e SUSE - decidiram que podem manter o kABI est√°vel para seus usu√°rios.  Como resultado, os pacotes KMOD para Red Hat e KMP para SUSE apareceram. <br><br>  A ess√™ncia desta solu√ß√£o √© bastante simples.  A API do kernel √© congelada para uma vers√£o espec√≠fica da distribui√ß√£o.  O distribuidor declara que ele usa o kernel, por exemplo, 3.10, e faz apenas corre√ß√µes e melhorias que n√£o afetam as interfaces do kernel, e os m√≥dulos montados para o primeiro kernel podem ser usados ‚Äã‚Äãpara todos os subseq√ºentes sem recompila√ß√£o. <br><br>  A Red Hat anuncia a compatibilidade do kABI para a distribui√ß√£o ao longo do ciclo de vida.  Ou seja, o m√≥dulo montado para o rhel 6.0 (vers√£o de novembro de 2010) tamb√©m deve funcionar na vers√£o 6.10 (vers√£o de junho de 2018).  E isso √© quase 8 anos.  Naturalmente, a tarefa √© bastante complicada. <br>  Registramos v√°rios casos em que, devido a problemas de compatibilidade com o kABI, o m√≥dulo veeamsnap parou de funcionar. <br><br>  Ap√≥s o m√≥dulo veeamsnap compilado para o RHEL 7.0 ser incompat√≠vel com o kernel do RHEL 7.5, mas ele carregou e garantiu a queda do servidor, recusamos o uso da compatibilidade do kABI para o RHEL 7 em geral. <br><br>  Atualmente, o pacote KMOD para RHEL 7 cont√©m um assembly para cada vers√£o do release e um script que fornece o carregamento do m√≥dulo. <br><br>  O SUSE abordou a tarefa de compatibilidade do kABI com mais cuidado.  Eles fornecem compatibilidade com kABI em apenas um service pack. <br><br>  Por exemplo, o lan√ßamento do SLES 12 ocorreu em setembro de 2014. E o SLES 12 SP1 j√° est√° em dezembro de 2015, ou seja, pouco mais de um ano se passou.  Embora ambas as vers√µes usem o kernel 3.12, elas n√£o s√£o compat√≠veis com o kABI.  Obviamente, manter a compatibilidade do kABI por apenas um ano √© muito mais f√°cil.  O ciclo anual de atualiza√ß√£o do m√≥dulo principal n√£o deve causar problemas para os criadores dos m√≥dulos. <br><br>  Como resultado dessa pol√≠tica do SUSE, n√£o corrigimos nenhum problema com a compatibilidade do kABI em nosso m√≥dulo veeamsnap.  √â verdade que o n√∫mero de pacotes para o SUSE √© quase uma ordem de magnitude maior. <br><br><h2>  Patches e backports </h2><br>  Apesar do fato de os distribuidores estarem tentando garantir a compatibilidade com o kABI e a estabilidade do kernel, eles tamb√©m est√£o tentando melhorar o desempenho e eliminar defeitos nesse kernel est√°vel. <br><br>  Al√©m disso, al√©m do seu pr√≥prio "trabalho sobre erros", os desenvolvedores do kernel linux corporativo rastreiam as altera√ß√µes no kernel vanilla e as transferem para o "est√°vel". <br><br>  √Äs vezes, isso leva a novos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">erros</a> . <br><br>  A vers√£o mais recente do Red Hat 6 cometeu um erro em uma das pequenas atualiza√ß√µes.  Isso levou ao fato de que o m√≥dulo veeamsnap estava garantido para travar o sistema quando o instant√¢neo foi lan√ßado.  Comparando as fontes do kernel antes e depois da atualiza√ß√£o, descobrimos que o backport era o culpado.  Uma corre√ß√£o semelhante foi feita no kernel vanilla vers√£o 4.19.  Mas apenas no n√∫cleo da baunilha, essa corre√ß√£o funcionou bem e, ao transferi-la para o "est√°vel" 2.6.32, houve um problema com o bloqueio de rota√ß√£o. <br><br>  Claro, todo mundo sempre tem erros, mas valeu a pena arrastar o c√≥digo de 4.19 para 2.6.32, arriscando a estabilidade? .. N√£o tenho certeza ... <br><br>  O pior de tudo √© que quando o marketing est√° atrelado ao cabo-de-guerra "estabilidade" &lt;-&gt; "moderniza√ß√£o".  O departamento de marketing precisa que o n√∫cleo da distribui√ß√£o atualizada seja est√°vel, por um lado, e ao mesmo tempo tenha melhor desempenho e tenha novos recursos.  Isso leva a compromissos estranhos. <br><br>  Quando tentei criar um m√≥dulo no kernel 4.4 do SLES 12 SP3, fiquei surpreso ao encontrar a funcionalidade do vanilla 4.8 nele.  Na minha opini√£o, a implementa√ß√£o do bloco de E / S do kernel 4.4 do SLES 12 SP3 √© mais como um kernel 4.8 do que a vers√£o anterior do kernel 4.4 est√°vel do SLES12 SP2.  N√£o posso julgar qual porcentagem de c√≥digo foi transferida do kernel 4.8 para o SLES 4.4 para SP3, mas ainda n√£o tenho chance de chamar o kernel como o mesmo 4.4 est√°vel. <br><br>  A coisa mais desagrad√°vel √© que, ao escrever um m√≥dulo que funciona igualmente bem em n√∫cleos diferentes, voc√™ n√£o pode mais confiar na vers√£o do kernel.  Tamb√©m temos que levar em conta a distribui√ß√£o.  √â bom que, √†s vezes, voc√™ possa se envolver em uma defini√ß√£o que aparece junto com a nova funcionalidade, mas esse recurso nem sempre aparece. <br><br>  Como resultado, o c√≥digo √© cercado por diretivas sofisticadas para compila√ß√£o condicional. <br><br>  Tamb√©m h√° patches que alteram a API do kernel documentada. <br>  Encontrei um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">kit de</a> distribui√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">KDE neon</a> 5.16 e fiquei muito surpreso ao ver que a chamada lookup_bdev nesta vers√£o do kernel mudou a lista de par√¢metros de entrada. <br><br>  Para nos reunirmos, tivemos que adicionar um script no makefile que verifica se a fun√ß√£o lookup_bdev possui um par√¢metro de m√°scara. <br><br><h2>  Assinatura de m√≥dulos do kernel </h2><br>  Mas voltando √† quest√£o da distribui√ß√£o de pacotes. <br><br>  Uma das vantagens do kABI est√°vel √© que os m√≥dulos do kernel podem ser assinados como um arquivo bin√°rio.  Nesse caso, o desenvolvedor pode ter certeza de que o m√≥dulo n√£o foi acidentalmente danificado ou intencionalmente alterado.  Voc√™ pode verificar isso com o comando modinfo. <br><br>  As distribui√ß√µes da Red Hat e do SUSE permitem verificar a assinatura de um m√≥dulo e fazer o download apenas se o certificado apropriado estiver registrado no sistema.  O certificado √© a chave p√∫blica pela qual o m√≥dulo √© assinado.  N√≥s o distribu√≠mos como um pacote separado. <br><br>  O problema aqui √© que os certificados podem ser incorporados ao kernel (s√£o usados ‚Äã‚Äãpelos distribuidores) ou devem ser gravados na mem√≥ria EFI n√£o vol√°til usando o utilit√°rio <i>mokutil</i> .  Ao instalar o certificado, o utilit√°rio <i>mokutil</i> requer uma reinicializa√ß√£o do sistema e, mesmo antes do carregamento do kernel do sistema operacional, ele oferece ao administrador a permiss√£o para baixar o novo certificado. <br><br>  Portanto, a adi√ß√£o de um certificado requer acesso f√≠sico do administrador ao sistema.  Se a m√°quina estiver localizada em algum lugar na nuvem ou apenas em uma sala de servidores remotos e o acesso for somente via rede (por exemplo, via ssh), ser√° imposs√≠vel adicionar um certificado. <br><br><h2>  EFI em m√°quinas virtuais </h2><br>  Apesar do fato de a EFI ter sido suportada por quase todos os criadores da placa-m√£e, ao instalar o sistema, o administrador pode n√£o pensar na necessidade da EFI e pode ser desativada. <br><br>  Nem todos os hipervisores suportam EFI.  O VMWare vSphere suporta EFI desde a vers√£o 5. <br>  O Microsoft Hyper-V tamb√©m recebeu suporte de EFI, come√ßando com o Hyper-V para Windows Server 2012R2. <br><br>  No entanto, na configura√ß√£o padr√£o, essa funcionalidade est√° desabilitada para m√°quinas Linux, o que significa que o certificado n√£o pode ser instalado. <br><br>  No vSphere 6.5, voc√™ pode definir a op√ß√£o <b>Inicializa√ß√£o segura</b> apenas na vers√£o antiga da interface da web que funciona via Flash.  A interface da Web da Web no HTML-5 est√° muito atrasada. <br><br><h2>  Distribui√ß√µes Experimentais </h2><br>  E, finalmente, considere a quest√£o das distribui√ß√µes experimentais e distribui√ß√µes sem suporte oficial.  Por um lado, √© improv√°vel que essas distribui√ß√µes sejam encontradas nos servidores de organiza√ß√µes s√©rias.  N√£o h√° suporte oficial para essas distribui√ß√µes.  Portanto, para fornecer aqueles.  o suporte ao produto em tal distribui√ß√£o n√£o √© poss√≠vel. <br><br>  No entanto, essas distribui√ß√µes se tornam uma plataforma conveniente para testar novas solu√ß√µes experimentais.  Por exemplo, Fedora, OpenSUSE Tumbleweed ou a vers√£o Inst√°vel do Debian.  Eles s√£o bem est√°veis.  Eles sempre t√™m novas vers√µes de programas e sempre um novo kernel.  Ap√≥s um ano, essa funcionalidade experimental pode estar no RHEL, SLES ou Ubuntu atualizado. <br><br>  Portanto, se algo n√£o funcionar no kit de distribui√ß√£o experimental, esta √© uma ocasi√£o para resolver o problema e resolv√™-lo.  Voc√™ precisa estar preparado para o fato de que essa funcionalidade aparecer√° em breve nos servidores de produ√ß√£o dos usu√°rios. <br><br>  A lista atual de distribui√ß√µes oficialmente suportadas para a vers√£o 3.0 pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Mas a lista real de distribui√ß√µes nas quais nosso produto pode trabalhar √© muito mais ampla. <br><br>  Pessoalmente, eu estava interessado em um experimento com o Elbrus OS.  Ap√≥s a atualiza√ß√£o do pacote veeam, nosso produto foi instalado e adquirido.  Sobre esse experimento, escrevi sobre Habr√© no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> . <br><br>  Bem, o suporte para novas distribui√ß√µes continua.  Estamos aguardando o lan√ßamento da vers√£o 4.0.  A vers√£o beta est√° prestes a aparecer, portanto, fique atento √†s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">novidades</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471226/">https://habr.com/ru/post/pt471226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471210/index.html">Deus ... Balada sobre um programador</a></li>
<li><a href="../pt471212/index.html">10 dicas e truques para ajudar voc√™ a se tornar o melhor desenvolvedor do VueJS</a></li>
<li><a href="../pt471216/index.html">A longa hist√≥ria do guia - como eu escrevi um servi√ßo para trilhas inteligentes por 5 anos</a></li>
<li><a href="../pt471220/index.html">Cockpit - simplifique tarefas administrativas t√≠picas no Linux atrav√©s de uma interface web conveniente</a></li>
<li><a href="../pt471222/index.html">Compreender as pol√≠ticas de privacidade de aplicativos e servi√ßos ajudar√° redes neurais</a></li>
<li><a href="../pt471228/index.html">Grokay PyTorch</a></li>
<li><a href="../pt471232/index.html">Minha experi√™ncia conectando o LPS331AP ao Omega Onion2</a></li>
<li><a href="../pt471236/index.html">Dos√≠metro para Seryozha. Parte III Radi√≥metro nacional</a></li>
<li><a href="../pt471240/index.html">‚ÄúBitchy Betty‚Äù e interfaces de √°udio modernas: por que eles falam com uma voz feminina?</a></li>
<li><a href="../pt471242/index.html">Introdu√ß√£o ao Bash Shell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>