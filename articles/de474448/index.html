<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👑 🍳 👸🏾 Was das Gehirn eines Studenten in der Computerwelt kann 👩‍🏫 👌🏾 👨🏽‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. 

 Nachdem ich ein weiteres Skript über Bash geschrieben hatte, wurde mir klar, dass alles völlig anders sein sollte, aber alles funktionie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was das Gehirn eines Studenten in der Computerwelt kann</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474448/">  Guten Tag. <br><br>  Nachdem ich ein weiteres Skript über Bash geschrieben hatte, wurde mir klar, dass alles völlig anders sein sollte, aber alles funktionierte.  Ich möchte Ihnen zeigen, welche Schimpfwörter und Krücken ich geschrieben habe, um das Problem zu lösen, aber bisher ohne ein Auto des Wissens.  Mit anderen Worten, eine Karikatur der Programmierung. <br><a name="habracut"></a><br><h1>  <font color="#4682B4"><b>Herausforderung</b></font> </h1><br>  Etwas wurde notwendig, um: <br><ul><li>  Es wurden viele Reime für ein Wort gedruckt, außer für Quadrate </li><li>  Kreuzte viele Reime von zwei Wörtern </li></ul><br>  Wofür?  Nun, hier ist es - und das war's. <br>  Wer nicht weiß, ein quadratischer Reim (im allgemeinen Sprachgebrauch - ein Quadrat) ist zwei Wörter, die die letzten beiden Buchstaben in der Schreibweise haben, was sie (oft nur dies) zu einem Reim macht.  Zum Beispiel Rosen - Frost;  Der Reifen ist ein Auto.  Die Verwendung von Quadraten in der modernen Versifikation wird von Menschen aufgrund ihrer Primitivität nicht besonders gebilligt. <br><br><h1>  <font color="#4682B4"><b>Lösung</b></font> </h1><br>  Die einfachste Lösung schien mir, ein Skript auf Bash zu schreiben, das den bereits existierenden Reimgenerator - HOST - verwendet, der sie zuallererst nach Harmonien auswählt und nicht durch Rechtschreibung.  Was ist ein Host?  Denn wenn Sie den tatsächlichen Namen der Website angeben, wird diese Werbung angezeigt.  Warum nicht weiterverwenden?  Erstens erzeugt es trotz seines Vorteils bei der Auswahl von Reimen nach Harmonien häufig Quadrate.  Zweitens müssen Sie immer noch mit Ihrem Gehirn nachdenken, Zeit damit verbringen, zwischen Registerkarten zu wechseln, und sich daran erinnern, Wörter in Listen wiederholt zu haben, um Reime für zwei Wörter zu finden. <br><br><h2>  <font color="#4682B4"><b>Starke Reime bekommen</b></font> </h2><br>  Was weiß ich  Ich kenne das Dienstprogramm <b>wget</b> , das die Seite unter der angegebenen URL herunterlädt.  Nun, wir erfüllen die Anfrage - wir bekommen die HTML-Seite in der Datei, die ein Wort für Reim genannt wird.  Suchen Sie beispielsweise nach dem Wort "hier": <br><br><pre><code class="bash hljs">wget https://HOST/rifma/</code> </pre> <br>  Aber ich brauche nur eine Liste von Wörtern, wie man alles andere loswird?  Wir schauen und sehen, dass die Liste der Wörter in Form einer Liste angeordnet ist, wie seltsam es auch erscheinen mag, und die Wörter befinden sich in den &lt;li&gt; &lt;/ li&gt; -Tags.  Nun, wir haben ein wunderbares <b>sed-</b> Utility - und schreiben es auf: <br><a name="Filters"></a><br><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$word</span></span> | grep <span class="hljs-string"><span class="hljs-string">'&lt;li&gt;'</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">"s%&lt;li&gt;%%"</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">"s%&lt;/li&gt;%%"</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">"s/ //g"</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">"/^$/d"</span></span> 1&gt; <span class="hljs-variable"><span class="hljs-variable">$word</span></span></code> </pre> <br>  Wählen Sie zunächst aus der Wortdatei die Zeilen aus, die das &lt;li&gt; -Tag enthalten. Wir erhalten eine Reihe leerer Tags und Zeilen mit Wörtern.  Wir entfernen das Tag selbst und sein schließendes - hier werden Prozentzeichen anstelle von Schrägstrichen verwendet, da das &lt;/ li&gt; -Tag bereits einen Schrägstrich enthält, weshalb <b>sed</b> Sie nicht ein bisschen versteht.  Und mit Interesse ist alles in Ordnung.  Wir entfernen alle Leerzeichen aus der Datei, löschen leere Zeilen.  Voila - eine vollständige Liste der Wörter. <br><br>  Um Wörter zu entfernen, die sich aufgrund der letzten Buchstaben reimen, wählen Sie die letzten beiden Buchstaben aus dem ursprünglichen Wort aus und bereinigen Sie die Liste: <br><br><pre> <code class="bash hljs">squad=<span class="hljs-variable"><span class="hljs-variable">${word:((${#word}</span></span>-2)):2} cat <span class="hljs-variable"><span class="hljs-variable">$word</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">"/.</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$squad</span></span></span><span class="hljs-string">$/d"</span></span> 1&gt; <span class="hljs-variable"><span class="hljs-variable">$word</span></span></code> </pre> <br>  Wir schauen, versuchen - alles funktioniert ... also, aber wo ist die Liste für das Wort "spielen"?  Und für das Wort "Ich komme"?  Die Datei ist leer!  Und das alles, weil diese Wörter Verben sind und wir wissen, was sie mit denen machen, die sich zu Verben reimen.  Der Verbreim ist für die meisten Verben in der russischen Sprache und sogar für alle mit denselben Endungen noch schlechter als der quadratische, weshalb sie nach Überprüfung der Endungen nicht in der endgültigen Datei enthalten waren. <br><br>  Allerdings nicht in Eile.  Für jedes Wort gibt es nicht nur Reime, sondern auch Assonanzen, die manchmal viel besser klingen als Reime - dafür sind sie auch Assonanzen (französische Assonanz, aus dem lateinischen assono - ich klinge gut). <br><br><h2>  <font color="#4682B4"><b>Bekomme Assonanzen</b></font> </h2><br>  Hier beginnt der Spaß: Die Assonanzen werden auf einer separaten URL und auf derselben Seite angezeigt, indem ein Skript ausgeführt, eine HTTP-Anfrage gesendet und eine Antwort empfangen wird.  Wie kann ich <b>wget anweisen</b> , auf eine Schaltfläche zu klicken?  Aber in irgendeiner Weise.  Es ist traurig. <br><br>  Als ich bemerkte, dass sich die URL in der Zeichenfolge immer noch irgendwie ändert, kopierte ich das, was nach dem Wechsel zu Assonanzen vorhanden war, und fügte es in einen neuen Browser-Tab ein - starke Reime wurden geöffnet.  Nicht das. <br><br>  Tatsächlich, dachte ich, sollte es dem Server egal sein, ob das Skript, das die Anfrage sendet, ausgeführt wird oder ob die Person sie manuell eingibt.  Also?  Und wer weiß, lass uns nachsehen. <br><br>  Wohin senden?  Was soll ich senden?  Bei einer HTTP-Anfrage an die IP des Servers gibt es so etwas wie GET ... dann gibt es etwas HTTP / 1.1 ... Wir müssen sehen, was und wohin der Browser sendet.  Installiere <b>wireshark</b> , sieh dir den Verkehr an: <br><br> <code>0040 37 5d a3 84 27 e7 fb 13 6d 93 ed cd 56 04 9d 82 7]£.'çû.m.íÍV... <br> 0050 32 7c fb 67 46 71 dd 36 4d 42 3d f3 62 1b e0 ad 2|ûgFqÝ6MB=ób.à. <br> 0060 ef 87 be 05 6a f9 e1 01 41 fc 25 5b c0 77 d3 94 ï.¾.jùá.Aü%[ÀwÓ. <br></code> <br>  Ähm ... was?  Oh ja, wir haben HTTPS.  Was zu tun ist?  Einen MITM-Angriff auf sich selbst arrangieren?  Im Idealfall hilft uns das Opfer selbst. <br><br>  Im Allgemeinen habe ich beim Erraten des Browsers immer noch die Anfrage selbst und den Empfänger gefunden.  Lass uns gehen: <br><br><div class="spoiler">  <b class="spoiler_title">Dialog mit dem Terminal</b> <div class="spoiler_text"><pre> <code class="xml hljs">telnet IP PORT Trying IP... Connected to IP. Escape character is '^]'. GET /rifma/%D0%BC%D0%B0%D1%82%D1%8C?mode=block&amp;type=asn HTTP/1.1 Host: HOST Accept-Language: en-US,en;q=0.5 X-Requested-With: XMLHttpRequest Connection: close HTTP/1.1 400 Bad Request Server: nginx/1.8.0 Date: Sun, 03 Nov 2019 20:06:59 GMT Content-Type: text/html; charset=utf-8 Content-Length: 270 Connection: close <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>400 The plain HTTP request was sent to HTTPS port<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bgcolor</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"white"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">center</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>400 Bad Request<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">center</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">center</span></span></span><span class="hljs-tag">&gt;</span></span>The plain HTTP request was sent to HTTPS port<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">center</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">center</span></span></span><span class="hljs-tag">&gt;</span></span>nginx/1.8.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">center</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> Connection closed by foreign host.</code> </pre> </div></div>  Huh.  Hey hey  In der Tat, was ich erwartet hatte, indem ich eine reine HTTP-Anfrage an einen HTTPS-Port gesendet habe.  Ist es jetzt verschlüsselt?  All diese Aufregung mit RSA-Schlüsseln, dann mit SHA256.  Und warum gibt es <b>OpenSSL</b> für solche Angelegenheiten.  Nun, wir wissen bereits, was zu tun ist. Entfernen Sie zuerst die Felder Referer und Cookie. Ich denke, sie werden die Angelegenheit nicht wesentlich beeinflussen: <br><br><div class="spoiler">  <b class="spoiler_title">Dialog mit dem Terminal</b> <div class="spoiler_text"><pre> <code class="bash hljs">openssl s_client -connect IP:PORT { , } GET /rifma/%D0%B7%D0%B4%D0%B5%D1%81%D1%8C?mode=block&amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>=asn HTTP/1.1 Host: HOST User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/javascript,text/html,application/xml,text/xml,*/* Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate, br X-Requested-With: XMLHttpRequest Connection: keep-alive HTTP/1.1 200 OK Content-Type: text/html;charset=utf-8 Transfer-Encoding: chunked Connection: keep-alive Vary: Accept-Encoding Status: 200 OK Date: Sun, 03 Nov 2019 20:34:33 GMT Set-Cookie: COOKIE X-Powered-By: Phusion Passenger 5.0.16 Server: nginx/1.8.0 + Phusion Passenger 5.0.16 Expires: Thu, 01 Jan 1970 00:00:01 GMT Cache-Control: no-cache Strict-Transport-Security: max-age=31536000 Content-Security-Policy: block-all-mixed-content Content-Encoding: gzip</code> </pre><br><img src="https://habrastorage.org/webt/em/5g/ad/em5gadtuwjrl7hr3crjozgutiug.png"><br></div></div><br>  Ist das ein Schachmatt auf dem Server?  Nun, mindestens 200 OK haben mir geantwortet, was bedeutet, dass Cookies und Referrer nichts beeinflussen.  Gzip-Komprimierung, aber ASCII-Zeichen werden beim Kopieren kopiert.  Ebenso können Sie die <b>Accept-Codierungszeile</b> entfernen.  Alles ist in Ordnung - wir bekommen ein HTML-Dokument, jetzt mit Assonanzen.  Aber hier sind zwei Fragen: Wie kann man OpenSSL ausführen und Daten mit einem Skript an dieses übergeben?  Und wie liest man die Ausgabe, wenn wir nach Erhalt der Antwort wie in der „Shell“ von OpenSSL bleiben?  Wenn Ihnen mit dem zweiten etwas einfällt, aber mit dem ersten ... <br><br>  Es ist gut, dass es einen <font color="#4682B4"><b>Habr gibt</b></font> , in dem ich über das <b>Expect-</b> Dienstprogramm lese, das den Prozess der Interaktion mit Programmen automatisiert, die auf menschliche Interaktion warten.  Noch attraktiver ist das Vorhandensein des <b>Befehls autoexpect</b> , der ein <b>Expect-</b> Skript für Ihre Aktionen generiert.  Nun, lauf, mach alles und hier ist das fertige Skript.  Nur ist es sehr groß und alles, weil <b>OpenSSL</b> Zertifikate und Schlüssel anzeigt und erwartet, dass all dies angezeigt wird.  Brauchen wir das  Nein.  Wir zerstören die erste Eingabeaufforderung und lassen nur den letzten Zeilenumbruch '\ r'.  Wir entfernen auch die Felder User-Agent und Accept aus unserer Anfrage - sie haben keine Auswirkungen.  Also, fangen wir an.  Das Skript wird ausgeführt, aber wo befindet sich das begehrte HTML-Dokument?  <b>Erwarten Sie es</b> gegessen.  Um ihn dazu zu bringen, es auszuspucken, müssen Sie Folgendes sagen: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> results <span class="hljs-variable"><span class="hljs-variable">$expect_out</span></span>(buffer)</code> </pre> <br>  vor dem Ende des Skripts - auf diese Weise wird die Ausgabe des ausgeführten <b>Befehls</b> await geschrieben und angezeigt.  Zusammenfassend so etwas wie: <br><br><div class="spoiler">  <b class="spoiler_title">Erwarten Sie ein Skript</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/expect -f set timeout -1 spawn openssl s_client -connect IP:PORT match_max 100000 expect -exact " ---\r " send -- "GET /rifma/%d0%b7%d0%b4%d0%b5%d1%81%d1%8c?mode=block&amp;type=asn HTTP/1.1\rHost: HOST\rAccept-Language: en-US,en;q=0.5\rX-Requested-With: XMLHttpRequest\rConnection: close" expect -exact "GET /rifma/%d0%b7%d0%b4%d0%b5%d1%81%d1%8c?mode=block&amp;type=asn HTTP/1.1\r Host: HOST\r Accept-Language: en-US,en;q=0.5\r X-Requested-With: XMLHttpRequest\r Connection: close" send -- "\r" set results $expect_out(buffer) expect -exact "\r " send -- "\r" expect eof</span></span></code> </pre> </div></div><br>  Aber das ist noch nicht alles!  Wie Sie sehen können, war die Anforderungs-URL in allen Beispielen statisch. Er ist jedoch dafür verantwortlich, für welches Wort die Assonanzen angezeigt werden.  Und so stellt sich heraus, dass wir ständig nach dem Wort "% d0% b7% d0% b4% d0% b5% d1% 81% d1% 8c" in ASCII oder "hier" in UTF-8 suchen.  Was zu tun ist?  Natürlich einfach jedes Mal ein neues Drehbuch generieren, Freunde!  Nur nicht <b>automatisch</b> Ohm <b>erwarten</b> , sondern mit <b>Echo</b> , weil  In unserem Land ändert sich nichts außer dem Wort.  Und es lebe das neue Problem: Wie würden wir ein Wort aus dem Kyrillischen irgendwie intelligent in ein URL-Format übersetzen?  Etwas für das Terminal ist auch nichts Besonderes.  Na ja, nichts, können wir?  Wir können: <br><br><div class="spoiler">  <b class="spoiler_title">Schau was ich kann!</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> furl { furl=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$word</span></span></span><span class="hljs-string">"</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s::%d0%90:g;s::%d0%91:g;s::%d0%92:g;s::%d0%93:g;s::%d0%94:g;s::%d0%95:g;s::%d0%96:g;s::%d0%97:g;s::%d0%98:g;s::%d0%99:g;s::%d0%9a:g;s::%d0%9b:g;s::%d0%9c:g;s::%d0%9d:g;s::%d0%9e:g;s::%d0%9f:g;s::%d0%a0:g;s::%d0%a1:g;s::%d0%a2:g;s::%d0%a3:g;s::%d0%a4:g;s::%d0%a5:g;s::%d0%a6:g;s::%d0%a7:g;s::%d0%a8:g;s::%d0%a9:g;s::%d0%aa:g;s::%d0%ab:g;s::%d0%ac:g;s::%d0%ad:g;s::%d0%ae:g;s::%d0%af:g;s::%d0%b0:g;s::%d0%b1:g;s::%d0%b2:g;s::%d0%b3:g;s::%d0%b4:g;s::%d0%b5:g;s::%d0%b6:g;s::%d0%b7:g;s::%d0%b8:g;s::%d0%b9:g;s::%d0%ba:g;s::%d0%bb:g;s::%d0%bc:g;s::%d0%bd:g;s::%d0%be:g;s::%d0%bf:g;s::%d1%80:g;s::%d1%81:g;s::%d1%82:g;s::%d1%83:g;s::%d1%84:g;s::%d1%85:g;s::%d1%86:g;s::%d1%87:g;s::%d1%88:g;s::%d1%89:g;s::%d1%8a:g;s::%d1%8b:g;s::%d1%8c:g;s::%d1%8d:g;s::%d1%8e:g;s::%d1%8f:g;s::%d1%91:g;s::%d0%81:g'</span></span>)}</code> </pre> </div></div><br>  Insgesamt haben wir ein Skript, das das Wort in ASCII-Text konvertiert und ein weiteres Skript generiert, das mit den Assonanzen über die OpenSSL-Serverseite der Site anfordert.  Und dann leiten wir die Ausgabe des letzten Skripts in die Datei um und leiten sie auf die alte Weise durch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Filter" der</a> überschüssigen Quadrate und fügen sie der Datei hinzu. <br><br><h2>  <font color="#4682B4"><b>Schnittmenge von Mengen.</b></font>  <font color="#4682B4"><b>Zusammenfassung</b></font> </h2><br>  Genau das verursacht die geringsten Probleme.  Wir führen die obigen Prozeduren für zwei Wörter durch, vergleichen dann aus zwei Listen jedes Wort mit jedem und wenn es eine Übereinstimmung findet, zeigen wir es an.  Jetzt haben wir ein Skript, das zwei Wörter zur Eingabe verwendet und eine Liste von Wörtern anzeigt, die sich mit beiden reimen, wobei die Assonanzen berücksichtigt werden, und dies alles, ohne manuell zwischen den vier Registerkarten zu wechseln und sich die Wörter „per Auge“ zu merken - das ist alles automatisch gesammelt, aufgezeichnet und verworfen.  Großartig. <br><br>  Der Zweck dieser Veröffentlichung war es zu zeigen, dass eine Person, die etwas braucht, es trotzdem tun wird.  Sehr ineffizient, krumm, gruselig, aber das wird funktionieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474448/">https://habr.com/ru/post/de474448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474436/index.html">GitLab beendet aufgrund von Richtlinien die Einstellung von Ingenieuren aus Russland und China</a></li>
<li><a href="../de474438/index.html">Einfach und in C ++. Userver Basics - Ein Framework zum Schreiben von asynchronen Microservices</a></li>
<li><a href="../de474440/index.html">Schwierigkeiten bei der Berechnung der Einnahmen aus Abonnements mit automatischer Verlängerung in iOS-Anwendungen</a></li>
<li><a href="../de474442/index.html">Irish Life Extension Story</a></li>
<li><a href="../de474444/index.html">5 weitere gewagte Trainingsprojekte für den Entwickler (Layer, Squoosh, Rechner, Website Crawler, Music Player)</a></li>
<li><a href="../de474450/index.html">Verwenden Sie keine lächerlich kleinen TTL mehr für DNS</a></li>
<li><a href="../de474452/index.html">Haxe Herbst Statusbericht</a></li>
<li><a href="../de474458/index.html">Kumulative Summe in SQL</a></li>
<li><a href="../de474460/index.html">Beschreibung der Prozessorarchitekturen in LLVM mit TableGen</a></li>
<li><a href="../de474462/index.html">Riesiger offener Datensatz der russischen Sprachversion 1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>