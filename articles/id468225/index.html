<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👭 😴 🤣 Mengurangi ukuran bundel dengan Webpack Analyzer dan React Lazy / Suspense 👩🏽‍🤝‍👨🏾 👨🏽‍🍳 🕵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seiring meningkatnya kompleksitas aplikasi klien, ukuran bundel mereka menjadi semakin banyak. Dalam situasi ini, orang yang paling menderita, dipaksa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengurangi ukuran bundel dengan Webpack Analyzer dan React Lazy / Suspense</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/468225/">  Seiring meningkatnya kompleksitas aplikasi klien, ukuran bundel mereka menjadi semakin banyak.  Dalam situasi ini, orang yang paling menderita, dipaksa, karena berbagai alasan, menggunakan koneksi internet yang lambat.  Apalagi setiap hari justru semakin memburuk. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/yp/wc/u-/ypwcu-trdbiswrdeltqb677yqxk.jpeg"></a> <br><br>  Penulis artikel, terjemahan yang kami terbitkan hari ini, bekerja di Wix.  Dia ingin berbicara tentang bagaimana dia dapat mengurangi ukuran satu bundel sekitar 80%, menggunakan Webpack Analyzer dan React Lazy / Suspense. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Seberapa awal optimasi dimulai?</font> </h2><br>  Jika Anda baru saja mulai bekerja pada aplikasi web baru Anda, maka Anda mungkin mencoba untuk fokus membuatnya, sehingga untuk berbicara, "lepas landas", mencoba membuatnya bekerja.  Anda mungkin tidak terlalu memperhatikan kinerja atau ukuran bundel.  Saya bisa mengerti itu.  Namun, pengalaman saya menunjukkan bahwa kinerja dan ukuran bundel harus diurus sejak awal.  Arsitektur aplikasi yang baik dan "refleksi masa depan proyek" yang tepat waktu akan menghemat banyak waktu dan membantu Anda untuk tidak menumpuk utang teknis yang serius.  Jelas, sulit untuk "meramalkan" segalanya di muka, tetapi Anda harus berusaha sangat keras untuk melakukan semuanya dengan benar sejak hari pertama bekerja di proyek. <br><br>  Berikut adalah beberapa alat hebat yang menurut saya harus digunakan sejak awal.  Alat-alat ini akan membantu Anda mengenali paket NPM "bermasalah" bahkan sebelum mereka menempati tempat penting dalam aplikasi. <br><br><h3>  <font color="#3AC1EF">UndBundlephobia</font> </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bundlephobia</a> adalah situs yang memberi tahu Anda seberapa banyak paket NPM tertentu akan meningkatkan ukuran bundel.  Ini adalah alat yang hebat untuk membantu programmer membuat keputusan yang tepat mengenai pilihan paket pihak ketiga yang mungkin ia butuhkan.  Bundlephobia membantu mendesain arsitektur aplikasi sehingga ukurannya tidak terlalu besar.  Gambar berikut menunjukkan hasil memeriksa perpustakaan populer untuk bekerja dengan waktu, yang disebut momen.  Anda dapat melihat bahwa perpustakaan ini cukup besar - hampir 66 Kb dalam bentuk terkompresi.  Bagi banyak pengguna yang bekerja di Internet berkecepatan tinggi, ini bukan apa-apa.  Namun, perlu diperhatikan waktu pengunduhan paket ini di jaringan 2G / 3G.  Ini, masing-masing, adalah 2,2 dan 1,32 detik.  Dan, perhatikan, kita hanya membicarakan paket yang satu ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c1/298/eed/1c1298eed8992918c5314e651ea04032.png"></div><br>  <i><font color="#999999">Hasil analisis paket momen Bundlephobia</font></i> <br><br><h3>  <font color="#3AC1EF">Cost Biaya Impor</font> </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Biaya Impor</a> adalah ekstensi yang sangat menarik bagi banyak editor kode populer (memiliki lebih dari satu juta unduhan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode VS</a> ).  Itu dapat menunjukkan "biaya" dari paket impor.  Saya terutama menyukainya karena membantu mengidentifikasi area masalah pada aplikasi saat mengerjakannya.  Gambar berikut (diambil dari halaman Biaya Impor GitHub) menunjukkan contoh yang sangat baik dari dampak pada dimensi proyek dari pendekatan yang berbeda untuk mengimpor entitas.  Jadi, mengimpor satu-satunya properti <code>uniqueId</code> dari Lodash mengarah ke impor seluruh perpustakaan ke proyek (70 Kb).  Dan jika Anda langsung mengimpor fungsi <code>uniqueId</code> , maka hanya 2 Kb yang akan ditambahkan ke ukuran proyek.  Baca lebih lanjut tentang Biaya Impor di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d1/488/bbb/8d1488bbb04afc1739a0a94967f74c2b.gif"></div><br>  <i><font color="#999999">"Biaya" mengimpor seluruh perpustakaan Lodash ke proyek dan hanya satu fungsi spesifik dari perpustakaan ini</font></i> <br><br><h2>  <font color="#3AC1EF">Kasus bundel besar yang tidak masuk akal</font> </h2><br>  Jadi, Anda telah membuat aplikasi luar biasa.  Ini bekerja sangat baik di Internet kecepatan tinggi Anda dan di komputer Anda yang paling kuat, penuh dengan RAM.  Anda merilisnya ke dunia nyata.  Setelah beberapa waktu, keluhan mulai datang dari Anda atau dari analis Anda sendiri.  Keluhan ini terkait dengan waktu muat aplikasi.  Sesuatu yang serupa baru-baru ini terjadi pada saya ketika kami, di Wix, meluncurkan fitur baru yang sedang saya kerjakan. <br><br>  Untuk mempercepat Anda, mari bicarakan peluang baru ini.  Ini adalah bilah kemajuan baru yang terletak di bagian atas panel samping dari antarmuka pengaturan situs pengguna.  Tujuan dari mekanisme ini adalah untuk menarik perhatian pengguna ke berbagai langkah yang perlu dia lakukan agar proyek bisnisnya memiliki peluang keberhasilan yang lebih baik (terhubung ke SEO, menambah wilayah pengiriman barang, menambahkan produk pertama , dan sebagainya). <br><br>  Bilah kemajuan diperbarui secara otomatis dengan menghubungkan ke server menggunakan soket web.  Saat pengguna menyelesaikan semua langkah yang disarankan, jendela sembulan akan muncul dengan selamat.  Setelah jendela ini ditutup, bilah progres disembunyikan dan tidak pernah ditampilkan lagi ketika bekerja dengan situs tempat Anda menggunakannya.  Inilah yang baru saja kita bicarakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2eb/b42/282/2ebb4228298df39e9b83358aaa7ebaac.gif"></div><br>  <i><font color="#999999">Progress Bar dan Jendela Selamat</font></i> <br><br>  Apa yang terjadi  Mengapa analis kami mengeluh kepada saya bahwa waktu buka halaman telah meningkat?  Ketika saya memeriksa keadaan hubungan menggunakan tab Jaringan alat pengembang Chrome, segera menjadi jelas bagi saya bahwa bundel saya cukup besar.  Yakni, ukurannya 190 Kb. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/0ce/631/f130ce631ea4399322aa95583c7b2fa5.png"></div><br>  <i><font color="#999999">Ukuran bundel ditemukan menggunakan Alat Pengembang Chrome</font></i> <br><br>  "Mengapa benda kecil ini membutuhkan bungkusan yang relatif besar?"  Tapi kebenarannya - mengapa? <br><br><h3>  <font color="#3AC1EF">▍ Mencari titik-titik masalah dalam bundel</font> </h3><br>  Setelah saya menyadari bahwa ukuran bundel itu terlalu besar, sekarang saatnya untuk mencari tahu alasannya.  Di sinilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Webpack Bundle Analyzer</a> berguna - alat yang hebat untuk mengidentifikasi bidang masalah bundel.  Ini membuka tab browser baru dan menampilkan informasi ketergantungan. <br><br>  Inilah yang terjadi setelah saya menganalisis bundel dengan alat ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f17/465/f5f/f17465f5f21c29bbbb57f37373b0c92e.png"></div><br>  <i><font color="#999999">Hasil Analisis Webpack Bundle</font></i> <br><br>  Dengan bantuan penganalisa, saya dapat mendeteksi "penjahat".  Paket lottie-web digunakan di sini, yang menambahkan 61,45 Kb ke ukuran bundel.  Lottie adalah pustaka JavaScript yang sangat bagus yang memungkinkan penggunaan alat peramban standar untuk menghasilkan animasi yang dibuat di Adobe After Effect.  Dalam kasus saya, itu sehingga desainer kami membutuhkan animasi yang bagus, yang dilakukan ketika jendela dengan selamat muncul.  Dia membuat animasi ini dan memberikannya kepada saya dalam bentuk file JSON, yang saya transfer ke paket Lottie dan mendapatkan animasi yang indah.  Selain paket lottie-web, saya juga punya file JSON dengan deskripsi animasi.  Ukuran file ini adalah 26 Kb.  Akibatnya, perpustakaan Lottie, file JSON, dan juga beberapa dependensi kecil tambahan "menelan biaya" sekitar 94 Kb.  Dan ini hanya sebuah animasi dari jendela dengan selamat kepada pengguna.  Pengguna, ketika dia melihat ucapan selamat ini, seharusnya senang.  Semua ini membuatku sedih. <br><br><h2>  <font color="#3AC1EF">React Lazy / Suspense technology hadir untuk menyelamatkan</font> </h2><br>  Setelah saya menemukan penyebab masalahnya, sekarang saatnya untuk menyelesaikan masalah ini.  Jelas bahwa tidak perlu memuat di awal pekerjaan semua yang diperlukan untuk animasi.  Bahkan, ada kemungkinan besar bahwa selama sesi pengguna saat ini, dia tidak perlu menunjukkan jendela dengan selamat.  Kemudian saya berkenalan dengan teknologi React Lazy / Suspense yang baru muncul dan berpikir bahwa sekarang saya mungkin memiliki kesempatan yang baik untuk mengujinya. <br><br>  Jika Anda tidak terbiasa dengan konsep komponen "lazy" (malas), maka ketahuilah bahwa artinya adalah membagi aplikasi menjadi potongan-potongan kecil kode.  Mengunduh fragmen ini dilakukan hanya saat dibutuhkan.  Dalam kasus saya, ini dinyatakan dalam fakta bahwa saya perlu memilih dari fungsional utama progress bar komponen yang bertanggung jawab untuk menunjukkan ucapan selamat.  Itu perlu memuat komponen ini hanya ketika pengguna menyelesaikan urutan langkah yang direkomendasikan. <br><br>  Bereaksi 16.6.0 (dan versi yang lebih baru) memiliki API sederhana yang dirancang untuk membuat komponen malas.  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React.lazy dan React.Suspense</a> .  Pertimbangkan sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OtherComponent = React.lazy(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./OtherComponent'</span></span>)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">      </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">React.Suspense</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fallback</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Loading...</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">}&gt;        </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">OtherComponent</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">      </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">React.Suspense</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">    </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">  ); }</span></span></code> </pre> <br>  Kami memiliki komponen yang menampilkan elemen <code>&lt;div&gt;</code> , dan di dalamnya ada komponen <code>Suspense</code> yang membungkus komponen <code>OtherComponent</code> .  Jika Anda melihat baris pertama dari contoh ini, Anda dapat melihat bahwa <code>OtherComponent</code> tidak diimpor langsung ke dalam kode.  Biasanya, impor seperti ini terlihat seperti <code>import OtherComponent from './OtherComponent';</code>  . <br><br>  Sebaliknya, perintah impor dibingkai sebagai fungsi yang mengambil jalur file.  Mekanisme ini berfungsi karena Webpack memiliki alat pemisah kode bawaan.  Ketika konstruksi yang sama hadir dalam kode, janji dikembalikan, yang, setelah mengunduh file, diselesaikan dengan konten file ini.  Tim impor kami dibungkus dalam fungsi <code>React.lazy</code> . <br><br>  Dalam materi render yang dikembalikan oleh <code>MyComponent</code> , <code>OtherComponent</code> dibungkus dalam komponen <code>React.Suspense</code> yang memiliki properti <code>fallback</code> .  Dalam kasus kami, ternyata ketika rendering mencapai <code>OtherComponent</code> , pemuatan komponen yang sesuai dimulai.  Sementara itu, apa yang ditulis ke properti <code>fallback</code> diberikan.  Dalam contoh ini, ini adalah teks <code>Loading…</code>  Faktanya, itu saja.  Mekanisme ini hanya melakukan pekerjaan mereka. <br><br>  Benar, ada beberapa fitur yang perlu Anda pertimbangkan saat bekerja dengan Lazy / Suspense. <br><br><ol><li>  Komponen yang diimpor dengan cara "malas" harus mengandung ekspor default, yang akan menjadi titik masuk komponen.  Ekspor yang disebutkan tidak dapat digunakan di sini. </li><li>  Anda perlu membungkus komponen yang diimpor menggunakan fungsi <code>React.lazy</code> di komponen <code>React.Suspense</code> .  Komponen <code>React.Suspense</code> menyediakan properti <code>fallback</code> .  Kalau tidak, kesalahan akan terjadi.  Namun, jika Anda tidak ingin membuat apa pun hingga komponen selesai pemuatan malas, Anda dapat menulis <code>null</code> pada <code>fallback</code> tanpa berusaha mengelak dari keharusan untuk menulis sesuatu di properti ini dengan cara yang rumit. </li></ol><br><h2>  <font color="#3AC1EF">Apakah menggunakan React Lazy / Suspense membantu saya?</font> </h2><br>  Ya, itu membantu!  Pemecahan kode bekerja dengan luar biasa.  Mari kita lihat hasil menganalisis bundel baru menggunakan Webpack. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21e/502/fff/21e502fffa9544e33a750a8d23c33ede.png"></div><br>  <i><font color="#999999">Hasil Webpack Bundle Analyzer setelah Pemecahan Kode</font></i> <br><br>  Seperti yang Anda lihat, ukuran bundel saya berkurang sekitar 50% - hingga 96 Kb.  Hebat! <br><br>  Lantas apa, sekarang masalahnya selesai?  Tidak, sayangnya.  Ketika saya melihat halaman, ternyata pop-up dengan selamat kehilangan posisi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b9/4a0/25d/3b94a025d8577c55a2d973928acf7c5f.png"></div><br>  <i><font color="#999999">Jendela ucapan selamat tidak muncul di tempat Anda membutuhkannya</font></i> <br><br>  Masalahnya adalah saya “meminta” jendela untuk membuka dengan mengubah status komponen Bereaksi.  Sementara itu, saya telah membuat <code>null</code> (yaitu, saya belum memberikan apa pun) menggunakan komponen <code>React.Suspense</code> .  Setelah malas memuat data yang diperlukan, materi yang relevan ditambahkan ke DOM.  Namun, penentuan posisi popup sudah dilakukan.  Akibatnya, karena fakta bahwa sifat-sifat komponen yang sesuai tidak berubah, komponen ini “tidak tahu” bahwa ia perlu menyelesaikan masalah mengenai penentuan posisi.  Jika saya mengubah ukuran jendela browser, jendela pop-up muncul di tempat yang tepat karena fakta bahwa komponen yang sesuai mengamati perubahan dalam properti dan peristiwa mengubah ukuran jendela, memulai, jika perlu, memposisikan ulang. <br><br>  Bagaimana cara mengatasi masalah ini?  Solusinya adalah menghilangkan "perantara". <br><br>  Saya pertama-tama harus memuat komponen "malas", dan baru kemudian menulis ke negara yang akan memberi tahu jendela dengan selamat bahwa itu perlu dibuka.  Saya bisa melakukan ini menggunakan mekanisme berbagi kode Webpack yang sama, tapi sekarang - tanpa menerapkan impor menggunakan <code>React.lazy</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> loadAndSetHappyMoment() {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(    <span class="hljs-string"><span class="hljs-string">'../SidebarHappyMoment/SidebarHappyMoment.component'</span></span>  );  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SidebarHappyMoment = component.SidebarHappyMoment;  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({    <span class="hljs-attr"><span class="hljs-attr">tooltipLevel</span></span>: TooltipLevel.happyMoment,  }); }</code> </pre> <br>  Fungsi ini dipanggil setelah komponen saya, melalui mekanisme soket web, diberitahu bahwa ia perlu menampilkan jendela dengan selamat.  Saya menggunakan fungsi <code>import</code> Webpack (baris kode kedua).  Jika Anda ingat, saya katakan di atas bahwa fungsi ini mengembalikan janji, akibatnya saya dapat menggunakan konstruk <code>async/await</code> . <br><br>  Setelah komponen selesai dimuat, saya menuliskannya ke instance komponen saya (dengan perintah <code>this.SidebarHappyMoment = component.SidebarHappyMoment;</code> ).  Ini memberi saya kesempatan untuk menggunakannya nanti saat rendering.  Harap perhatikan bahwa sekarang saya dapat menggunakan ekspor yang diberi nama.  Dalam kasus saya, saya menggunakan, pada baris di atas, nama <code>SidebarHappyMoment</code> .  Dan akhirnya, dan ini tidak kalah pentingnya dari yang lainnya, saya "menginformasikan" jendela yang perlu dibuka, mengubah keadaannya setelah saya tahu bahwa komponen siap untuk operasi. <br><br>  Akibatnya, kode rendering sekarang terlihat seperti ini: <br><br><pre> <code class="javascript hljs">renderTooltip() {  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.tooltipLevel === TooltipLevel.happyMoment) {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">this.SidebarHappyMoment</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">;  }  // ... }</span></span></code> </pre> <br>  Perhatikan bahwa perintah <code>return &lt;this.SidebarHappyMoment /&gt;;</code>  mengembalikan <code>this.SidebarHappyMoment</code> - apa yang saya tulis sebelumnya ke instance komponen saya.  Sekarang ini adalah fungsi render sinkron normal, sama seperti yang telah Anda gunakan jutaan kali.  Dan sekarang jendela dengan selamat ditampilkan di tempat yang seharusnya.  Dan masalahnya adalah ia terbuka hanya setelah isinya siap digunakan. <br><br><h2>  <font color="#3AC1EF">Produk mendefinisikan arsitektur</font> </h2><br>  Jika gagasan dalam judul bagian ini membangkitkan tanda tanya yang kuat dalam imajinasi Anda, maka ketahuilah bahwa inilah masalahnya.  Produk mendefinisikan arsitektur. <br><br>  Ini adalah tentang fakta bahwa produk menentukan apa yang harus terlihat dan interaktif ketika komponen pertama kali diberikan.  Ini membantu pengembang untuk mencari tahu apa sebenarnya yang dapat ia pisahkan dari kode utama dan memuatnya nanti, bila perlu.  Saya memikirkan situasinya dan "mengingat" bahwa setelah pengguna menyelesaikan langkah-langkah yang disarankan untuk menyiapkan situs, atau jika dia bukan administrator situs, saya tidak perlu menunjukkan kepadanya bilah kemajuan dan apa yang terjadi dengannya. terhubung.  Sekarang, menggunakan informasi ini, saya dapat terus berbagi bungkusan.  Itu yang saya dapat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36f/5f2/eb9/36f5f2eb91ead3a7188f5d5162d75b3e.png"></div><br>  <i><font color="#999999">Pemisahan bundel yang berlanjut</font></i> <br><br>  Setelah itu, ukuran bundel itu hanya 38 Kb.  Dan saya mengingatkan Anda bahwa kami mulai dengan 190 Kb.  Ada pengurangan ukuran bundel sebesar 80%.  Dan omong-omong, saya sudah melihat kemungkinan lain untuk pemisahan kode.  Saya tidak sabar untuk terus mengoptimalkan bundel. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pengembang memiliki kemampuan untuk berusaha untuk tetap berada di "zona nyaman" mereka dan tidak mempelajari apa pun selain perangkat kode itu sendiri dan fungsinya.  Namun, seorang programmer yang menggunakan alat yang dijelaskan di atas, berpikir kreatif dan bekerja sama dengan spesialis lain, mungkin dapat meningkatkan kinerja aplikasinya dengan secara signifikan mengurangi ukuran bundel yang berisi apa yang diperlukan untuk mulai bekerja dengan aplikasi ini. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan pemisahan kode untuk mempercepat pemuatan aplikasi web Anda? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468225/">https://habr.com/ru/post/id468225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468211/index.html">“Saya hanya ingin membuat lelucon, tetapi tidak ada yang mengerti” atau bagaimana tidak mengubur diri saya pada presentasi proyek</a></li>
<li><a href="../id468213/index.html">tinc-boot - jaringan full-mesh tanpa rasa sakit</a></li>
<li><a href="../id468217/index.html">Jekyll dan Mr. Hyde Corporate Culture</a></li>
<li><a href="../id468219/index.html">Mekanisme Ekstensibilitas yang Dapat Diperpanjang dalam JavaScript</a></li>
<li><a href="../id468223/index.html">Habr Weekly # 19 / BT-pintu untuk kucing, mengapa AI curang, apa yang harus ditanyakan majikan masa depan, sehari dengan iPhone 11 Pro</a></li>
<li><a href="../id468227/index.html">Akselerasi instagram.com. Bagian 1</a></li>
<li><a href="../id468229/index.html">Catatan kosong pada JavaScript dan TypeScript</a></li>
<li><a href="../id468231/index.html">Apakah keamanan dalam AEM platform atau masalah implementasi?</a></li>
<li><a href="../id468233/index.html">Cara mengetik memeriksa 4 juta baris kode Python. Bagian 1</a></li>
<li><a href="../id468235/index.html">Cara mengetik memeriksa 4 juta baris kode Python. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>