<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜò üë©üèΩ‚Äçüè≠ üåó M√™me les enfants comprendront: une explication simple de l'async / wait et des promesses en JavaScript üë®üèæ‚Äçüöí ‚Ü™Ô∏è üôãüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article ¬´JavaScript Async / Await and Promises: Explained like you're five years¬ª par Jack Pordi. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√™me les enfants comprendront: une explication simple de l'async / wait et des promesses en JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474726/">  Bonjour, Habr!  Je vous pr√©sente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´JavaScript Async / Await and Promises: Explained like you're five years¬ª</a> par Jack Pordi. <br><br>  Quiconque se consid√®re comme un d√©veloppeur JavaScript, √† un moment donn√©, aurait d√ª rencontrer des fonctions de rappel, des promesses ou, plus r√©cemment, la syntaxe async / wait.  Si vous √™tes dans le jeu depuis assez longtemps, vous avez probablement rencontr√© des moments o√π les fonctions de rappel imbriqu√©es √©taient le seul moyen de r√©aliser l'asynchronie en JavaScript. <br><br>  Lorsque j'ai commenc√© √† apprendre et √† √©crire en JavaScript, il y avait d√©j√† un milliard de tutoriels et de tutoriels expliquant comment r√©aliser l'asynchronie en JavaScript.  Cependant, beaucoup d'entre eux ont simplement expliqu√© comment convertir les fonctions de rappel en promesses ou promesses en async / wait.  Pour beaucoup, c'est probablement plus que suffisant pour s'entendre avec eux et commencer √† les utiliser dans leur code. <br><br>  Cependant, si vous, comme moi, voulez vraiment comprendre la programmation asynchrone (et pas seulement la syntaxe JavaScript!), Alors vous serez peut-√™tre d'accord avec moi qu'il y a une p√©nurie de documents expliquant la programmation asynchrone √† partir de z√©ro. <a name="habracut"></a><br><br><h2>  Que signifie asynchrone? </h2><br><img src="https://habrastorage.org/webt/sk/ml/pc/skmlpcgi3gmhov77moxcfyengek.jpeg" alt="l'image montre une personne qui pense"><br><br>  En r√®gle g√©n√©rale, en posant cette question, vous pouvez entendre quelque chose de ce qui suit: <br><br><ul><li>  Il existe plusieurs threads qui ex√©cutent du code en m√™me temps. </li><li>  Plus d'un morceau de code est ex√©cut√© √† la fois. </li><li>  C'est la simultan√©it√©. </li></ul><br>  Dans une certaine mesure, toutes les options sont correctes.  Mais au lieu de vous donner une d√©finition technique que vous risquez d'oublier bient√¥t, je vais vous donner <b>un exemple que m√™me un enfant peut comprendre</b> . <br><br><h2>  Exemple de vie </h2><br><img src="https://habrastorage.org/webt/lu/gq/ww/lugqwwbgniupu-afgs3oxavro9a.jpeg" alt="la photo montre des l√©gumes et un couteau de cuisine"><br><br>  Imaginez que vous cuisinez une soupe aux l√©gumes.  Pour une bonne et simple analogie, supposons qu'une soupe de l√©gumes ne se compose que d'oignons et de carottes.  La recette d'une telle soupe peut √™tre la suivante: <br><br><ol><li>  Hacher les carottes. </li><li>  Hachez l'oignon. </li><li>  Ajoutez de l'eau dans la casserole, allumez la cuisini√®re et attendez qu'elle bout. </li><li>  Ajouter les carottes dans la po√™le et laisser reposer 5 minutes. </li><li>  Ajouter les oignons dans la po√™le et cuire encore 10 minutes. </li></ol><br>  Ces instructions sont simples et compr√©hensibles, mais si l'un d'entre vous, en lisant ceci, sait vraiment cuisiner, vous pouvez dire que ce n'est pas la fa√ßon la plus efficace de cuisiner.  Et vous aurez raison, c'est pourquoi: <br><br><ul><li>  Les √©tapes 3, 4 et 5 ne vous <i><b>obligent</b></i> pas en tant que chef √† faire quoi que ce soit, sauf pour observer le processus et suivre le temps. </li><li>  Les √©tapes 1 et 2 vous <i><b>obligent</b></i> √† faire quelque chose activement. </li></ul><br>  Par cons√©quent, la recette d'un cuisinier plus exp√©riment√© peut √™tre la suivante: <br><br><ol><li>  Commencez √† faire bouillir une casserole d'eau. </li><li>  <b>En attendant que la casserole</b> bout <b>,</b> commencez √† couper les carottes. </li><li>  <b>Au moment o√π vous avez fini de</b> hacher les carottes, l'eau doit bouillir, alors ajoutez les carottes. </li><li>  <b>Pendant que les carottes sont cuites dans une po√™le,</b> hachez les oignons. </li><li>  Ajouter les oignons et cuire encore 10 minutes. </li></ol><br>  Malgr√© le fait que toutes les actions sont rest√©es les m√™mes, vous avez le droit de vous attendre √† ce que cette option soit beaucoup plus rapide et plus efficace.  C'est exactement le principe de la programmation asynchrone: <b>vous ne voulez jamais vous asseoir, juste attendre quelque chose, alors que vous pouvez passer votre temps sur d'autres choses utiles.</b> <b><br></b> <br>  Nous savons tous qu'en programmation, <b>attendre</b> quelque chose se produit assez souvent - que ce soit en attente d'une r√©ponse HTTP d'un serveur ou d'une action d'un utilisateur ou autre chose.  Mais les cycles d'ex√©cution de votre processeur sont pr√©cieux et doivent <b>toujours</b> √™tre utilis√©s activement, faire quelque chose et ne pas s'attendre: cela vous donne <b>une programmation asynchrone</b> . <br><br><h2>  Passons maintenant √† JavaScript, d'accord? </h2><br>  Donc, en suivant le m√™me exemple de soupe aux l√©gumes, j'√©crirai quelques fonctions pour repr√©senter les √©tapes de la recette d√©crite ci-dessus. <br><br>  Tout d'abord, √©crivons des fonctions synchrones qui repr√©sentent des t√¢ches qui ne prennent pas de temps.  Ce sont les bonnes vieilles fonctions JavaScript, mais notez que j'ai d√©crit les fonctions <b><code>chopCarrots</code></b> et <b><code>chopOnions</code></b> comme des t√¢ches qui n√©cessitent un travail actif (et du temps), leur permettant de faire de longs calculs.  Le code complet est disponible √† la fin de l'article [1]. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chopCarrots</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chopOnions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addOnions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addCarrots</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }</code> </pre><br>  Avant de passer aux fonctions asynchrones, je vais d'abord expliquer rapidement comment le syst√®me de type JavaScript g√®re l'asynchronie: fondamentalement, <b>tous les r√©sultats (y compris les erreurs) des op√©rations asynchrones doivent √™tre inclus dans la ou les promesses</b> . <br><br>  Pour qu'une fonction renvoie une promesse, vous pouvez: <br><br><ul><li>  retourner explicitement la promesse, c.-√†-d.  <b><code>return new Promise(‚Ä¶)</code></b> ; </li><li>  renvoie implicitement une promesse - ajoutez le <b><code>async</code></b> √† la d√©claration de fonction, c'est-√†-dire  <b><code>async function foo()</code></b> ; </li><li>  <i>utilisez les deux options</i> . </li></ul><br>  Il existe un excellent article [2], qui parle de la diff√©rence entre les fonctions asynchrones et les fonctions qui renvoient une promesse.  Par cons√©quent, dans mon article, je ne m'attarderai pas sur ce sujet, la principale chose √† retenir: vous devez <i><b>toujours</b></i> utiliser le <b><code>async</code></b> dans les fonctions asynchrones. <br><br>  Ainsi, nos fonctions asynchrones, repr√©sentant les √©tapes 3 √† 5 de la pr√©paration de soupe aux l√©gumes, sont les suivantes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">letPotKeepBoiling</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">time</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,      } async function boilPot() { return; //  ,       }</span></span></code> </pre><br>  Encore une fois, j'ai supprim√© les d√©tails d'impl√©mentation afin de ne pas √™tre distrait par eux, mais ils sont publi√©s √† la fin de l'article [1]. <br><br>  Il est important de savoir que pour attendre le r√©sultat de la promesse, afin que plus tard vous puissiez en faire quelque chose, vous pouvez simplement utiliser le mot-cl√© wait: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*  ... */</span></span> } result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncFunction();</code> </pre><br>  Donc, maintenant nous avons juste besoin de tout rassembler: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pot = boilPot(); chopCarrots(); chopOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pot; addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } makeSoup();</code> </pre><br>  Mais attends!  √áa ne marche pas!  Vous verrez le <b><code>SyntaxError: await is only valid in async functions</code></b> .  Pourquoi?  Parce que si vous ne d√©clarez pas une fonction en utilisant le <b><code>async</code></b> - <b><code>async</code></b> , alors par d√©faut JavaScript la d√©finit comme une fonction synchrone - et synchrone signifie pas d'attente!  [3].  Cela signifie √©galement que vous ne pouvez pas utiliser l' <b><code>await</code></b> dehors d'une fonction. <br><br>  Par cons√©quent, nous ajoutons simplement le <b><code>async</code></b> √† la fonction <b><code>makeSoup</code></b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pot = boilPot(); chopCarrots(); chopOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pot; addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } makeSoup();</code> </pre><br>  Et le tour est jou√©!  Notez que dans la deuxi√®me ligne, j'appelle la fonction asynchrone <b><code>boilPot</code></b> sans le mot-cl√© wait, car nous ne voulons pas attendre que la casserole bouillonne avant de commencer √† couper les carottes.  Nous n'attendons que la promesse d'un <b><code>pot</code></b> en cinqui√®me ligne avant de devoir mettre les carottes dans la casserole, car nous ne voulons pas le faire avant que l'eau ne bout. <br><br>  Que se passe-t-il pendant les appels en <b><code>await</code></b> ?  Eh bien, rien ... en quelque sorte ... <br><br>  Dans le contexte de la fonction <b><code>makeSoup</code></b> vous pouvez simplement y penser comme si vous vous attendiez √† ce que quelque chose se produise (ou un r√©sultat qui sera finalement retourn√©). <br><br>  Mais rappelez- <b>vous</b> : <b>vous (comme votre processeur) ne voudrez jamais rester assis l√† et attendre quelque chose, pendant que vous pouvez consacrer votre temps √† d'autres choses</b> . <br><br>  Par cons√©quent, au lieu de simplement cuisiner de la soupe, nous pourrions cuisiner autre chose en parall√®le: <br><br><pre> <code class="javascript hljs">makeSoup(); makePasta();</code> </pre><br>  Pendant que nous attendons <b><code>letPotKeepBoiling</code></b> , nous pouvons par exemple cuisiner des p√¢tes. <br><br>  Tu vois?  La syntaxe async / attente est en fait assez facile √† utiliser, si vous la comprenez, d'accord? <br><br><h2>  Et les promesses manifestes? </h2><br>  Eh bien, si vous insistez, je me tournerai vers l'utilisation de promesses explicites ( <i>environ. Transl.: Par promesses explicites, l'auteur implique directement la syntaxe des promesses, et par promesses implicites la syntaxe async / wait, car elle renvoie la promesse implicitement - pas besoin d'√©crire <code>return new Promise(‚Ä¶)</code></i> ).  Gardez √† l'esprit que les m√©thodes asynchrones / attendent <b>sont bas√©es sur les promesses elles-m√™mes et que les deux options sont donc enti√®rement compatibles</b> . <br><br>  Les promesses explicites, √† mon avis, se situent entre les rappels √† l'ancienne et la nouvelle syntaxe sexuelle asynchrone / wait.  Alternativement, vous pouvez √©galement consid√©rer la syntaxe sexuelle asynchrone / wait comme rien de plus que des promesses implicites.  En fin de compte, la construction async / wait est venue apr√®s les promesses, qui √† leur tour sont venues apr√®s les fonctions de rappel. <br><br>  Utilisez notre machine √† remonter le temps pour aller au enfer des rappels [4]: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callbackHell</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ boilPot( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addCarrots(); letPotKeepBoiling(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addOnions(); letPotKeepBoiling(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>, chopCarrots(), chopOnions() ); }</code> </pre><br>  Je ne vais pas mentir, j'ai √©crit cet exemple √† la vol√©e lorsque je travaillais sur cet article, et cela m'a pris beaucoup plus de temps que je ne voudrais l'admettre.  Beaucoup d'entre vous ne savent peut-√™tre m√™me pas ce qui se passe ici.  <i><b>Mon cher ami, toutes ces fonctions de rappel ne sont-elles pas affreuses?</b></i>  <i><b>Que ce soit une le√ßon de ne plus jamais utiliser les fonctions de rappel ...</b></i> <br><br>  Et, comme promis, le m√™me exemple avec des promesses explicites: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reject, resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { chopCarrots(); chopOnions(); resolve(); }), boilPot() ]) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }); }</code> </pre><br>  Comme vous pouvez le voir, les promesses sont toujours similaires aux fonctions de rappel. <br>  Je n'entrerai pas dans les d√©tails, mais surtout: <br><br><ul><li>  <b><code>.then</code></b> est une m√©thode promise qui prend son r√©sultat et le passe √† la fonction argument (essentiellement, √† une fonction de rappel ...) </li><li>  Vous ne pouvez jamais utiliser le r√©sultat d'une promesse en dehors du contexte de <b><code>.then</code></b> .  En substance, .then est comme un bloc asynchrone qui attend un r√©sultat et le transmet ensuite √† une fonction de rappel. </li><li>  En plus de la m√©thode <b><code>.then</code></b> , il y a une autre m√©thode dans les <b><code>.catch</code></b> - <b><code>.catch</code></b> .  Il est n√©cessaire pour g√©rer les erreurs dans les promesses.  Mais je n'entrerai pas dans les d√©tails, car il y a d√©j√† un milliard d'articles et de tutoriels sur ce sujet. </li></ul><br><h2>  Conclusion </h2><br>  J'esp√®re que vous avez eu une id√©e des promesses et de la programmation asynchrone de cet article, ou peut-√™tre avez-vous au moins appris un bon exemple de la vie pour l'expliquer √† quelqu'un d'autre. <br><br>  <b>Alors, quelle voie utilisez-vous: promesses ou async / attente?</b> <br>  La r√©ponse d√©pend enti√®rement de vous - et je dirais que les combiner n'est pas si mal, car les deux approches sont compl√®tement compatibles l'une avec l'autre. <br><br>  Cependant, je suis personnellement √† 100% dans le camp asynchrone / attendent, car pour moi le code est beaucoup plus compr√©hensible et refl√®te mieux le v√©ritable multit√¢che de la programmation asynchrone. <br><br><hr><br>  <b>[1]</b> : Le code source complet est disponible <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a></u> . <br>  <b>[2]</b> : Article original <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Fonction asynchrone vs.</a></u>  <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une fonction qui renvoie une promesse "</a></u> , traduction de l'article <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">" La diff√©rence entre une fonction asynchrone et une fonction qui renvoie une promesse</a></u> . <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"</a></u> <br>  <b>[3]</b> : Vous pouvez faire valoir que JavaScript peut probablement d√©terminer le type asynchrone / attente par corps de fonction et v√©rifier r√©cursivement, mais JavaScript n'a pas √©t√© con√ßu pour prendre en charge la s√©curit√© du type statique au moment de la compilation, sans parler de qu'il est beaucoup plus pratique pour les d√©veloppeurs de voir explicitement le type de fonction. <br>  <b>[4]</b> : J'ai √©crit des fonctions ¬´asynchrones¬ª, en supposant qu'elles fonctionnent sous la m√™me interface que <b><code>setTimeout</code></b> .  Notez que les rappels ne sont pas compatibles avec les promesses et vice versa. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474726/">https://habr.com/ru/post/fr474726/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474716/index.html">Bugs C ++ 20. R√©sultats de la r√©union √† Belfast</a></li>
<li><a href="../fr474718/index.html">S√©curit√© dans l'√©lectronique automobile - Hello World sur le contr√¥leur de tableau de bord</a></li>
<li><a href="../fr474720/index.html">Laboratoire radio de Nizhny Novgorod et ¬´cristadins¬ª de Losev</a></li>
<li><a href="../fr474722/index.html">¬´Personne ne dit aux autres ce qu'ils doivent faire¬ª: Nicol√≤ Ribaudo sur le d√©veloppement de Babel et plus</a></li>
<li><a href="../fr474724/index.html">Qu'adviendra-t-il de PHP dans 5 ans: nous avons demand√© aux intervenants du mitap de Moscou le plus proche</a></li>
<li><a href="../fr474732/index.html">Travailler avec la liste des broches, en C ++ pour les microcontr√¥leurs (en utilisant CortexM comme exemple)</a></li>
<li><a href="../fr474738/index.html">Mod√©lisation g√©om√©trique des surfaces de cong√©</a></li>
<li><a href="../fr474740/index.html">Le meilleur du mus√©e d'histoire de l'ordinateur √† Mountain View</a></li>
<li><a href="../fr474744/index.html">Uber entre sur le march√© des services financiers et lance la division Uber Money</a></li>
<li><a href="../fr474746/index.html">Stockage d'objets dans l'arri√®re-boutique ou Comment devenir votre propre fournisseur de services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>