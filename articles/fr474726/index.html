<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆘 👩🏽‍🏭 🌗 Même les enfants comprendront: une explication simple de l'async / wait et des promesses en JavaScript 👨🏾‍🚒 ↪️ 🙋🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article «JavaScript Async / Await and Promises: Explained like you're five years» par Jack Pordi. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Même les enfants comprendront: une explication simple de l'async / wait et des promesses en JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474726/">  Bonjour, Habr!  Je vous présente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«JavaScript Async / Await and Promises: Explained like you're five years»</a> par Jack Pordi. <br><br>  Quiconque se considère comme un développeur JavaScript, à un moment donné, aurait dû rencontrer des fonctions de rappel, des promesses ou, plus récemment, la syntaxe async / wait.  Si vous êtes dans le jeu depuis assez longtemps, vous avez probablement rencontré des moments où les fonctions de rappel imbriquées étaient le seul moyen de réaliser l'asynchronie en JavaScript. <br><br>  Lorsque j'ai commencé à apprendre et à écrire en JavaScript, il y avait déjà un milliard de tutoriels et de tutoriels expliquant comment réaliser l'asynchronie en JavaScript.  Cependant, beaucoup d'entre eux ont simplement expliqué comment convertir les fonctions de rappel en promesses ou promesses en async / wait.  Pour beaucoup, c'est probablement plus que suffisant pour s'entendre avec eux et commencer à les utiliser dans leur code. <br><br>  Cependant, si vous, comme moi, voulez vraiment comprendre la programmation asynchrone (et pas seulement la syntaxe JavaScript!), Alors vous serez peut-être d'accord avec moi qu'il y a une pénurie de documents expliquant la programmation asynchrone à partir de zéro. <a name="habracut"></a><br><br><h2>  Que signifie asynchrone? </h2><br><img src="https://habrastorage.org/webt/sk/ml/pc/skmlpcgi3gmhov77moxcfyengek.jpeg" alt="l'image montre une personne qui pense"><br><br>  En règle générale, en posant cette question, vous pouvez entendre quelque chose de ce qui suit: <br><br><ul><li>  Il existe plusieurs threads qui exécutent du code en même temps. </li><li>  Plus d'un morceau de code est exécuté à la fois. </li><li>  C'est la simultanéité. </li></ul><br>  Dans une certaine mesure, toutes les options sont correctes.  Mais au lieu de vous donner une définition technique que vous risquez d'oublier bientôt, je vais vous donner <b>un exemple que même un enfant peut comprendre</b> . <br><br><h2>  Exemple de vie </h2><br><img src="https://habrastorage.org/webt/lu/gq/ww/lugqwwbgniupu-afgs3oxavro9a.jpeg" alt="la photo montre des légumes et un couteau de cuisine"><br><br>  Imaginez que vous cuisinez une soupe aux légumes.  Pour une bonne et simple analogie, supposons qu'une soupe de légumes ne se compose que d'oignons et de carottes.  La recette d'une telle soupe peut être la suivante: <br><br><ol><li>  Hacher les carottes. </li><li>  Hachez l'oignon. </li><li>  Ajoutez de l'eau dans la casserole, allumez la cuisinière et attendez qu'elle bout. </li><li>  Ajouter les carottes dans la poêle et laisser reposer 5 minutes. </li><li>  Ajouter les oignons dans la poêle et cuire encore 10 minutes. </li></ol><br>  Ces instructions sont simples et compréhensibles, mais si l'un d'entre vous, en lisant ceci, sait vraiment cuisiner, vous pouvez dire que ce n'est pas la façon la plus efficace de cuisiner.  Et vous aurez raison, c'est pourquoi: <br><br><ul><li>  Les étapes 3, 4 et 5 ne vous <i><b>obligent</b></i> pas en tant que chef à faire quoi que ce soit, sauf pour observer le processus et suivre le temps. </li><li>  Les étapes 1 et 2 vous <i><b>obligent</b></i> à faire quelque chose activement. </li></ul><br>  Par conséquent, la recette d'un cuisinier plus expérimenté peut être la suivante: <br><br><ol><li>  Commencez à faire bouillir une casserole d'eau. </li><li>  <b>En attendant que la casserole</b> bout <b>,</b> commencez à couper les carottes. </li><li>  <b>Au moment où vous avez fini de</b> hacher les carottes, l'eau doit bouillir, alors ajoutez les carottes. </li><li>  <b>Pendant que les carottes sont cuites dans une poêle,</b> hachez les oignons. </li><li>  Ajouter les oignons et cuire encore 10 minutes. </li></ol><br>  Malgré le fait que toutes les actions sont restées les mêmes, vous avez le droit de vous attendre à ce que cette option soit beaucoup plus rapide et plus efficace.  C'est exactement le principe de la programmation asynchrone: <b>vous ne voulez jamais vous asseoir, juste attendre quelque chose, alors que vous pouvez passer votre temps sur d'autres choses utiles.</b> <b><br></b> <br>  Nous savons tous qu'en programmation, <b>attendre</b> quelque chose se produit assez souvent - que ce soit en attente d'une réponse HTTP d'un serveur ou d'une action d'un utilisateur ou autre chose.  Mais les cycles d'exécution de votre processeur sont précieux et doivent <b>toujours</b> être utilisés activement, faire quelque chose et ne pas s'attendre: cela vous donne <b>une programmation asynchrone</b> . <br><br><h2>  Passons maintenant à JavaScript, d'accord? </h2><br>  Donc, en suivant le même exemple de soupe aux légumes, j'écrirai quelques fonctions pour représenter les étapes de la recette décrite ci-dessus. <br><br>  Tout d'abord, écrivons des fonctions synchrones qui représentent des tâches qui ne prennent pas de temps.  Ce sont les bonnes vieilles fonctions JavaScript, mais notez que j'ai décrit les fonctions <b><code>chopCarrots</code></b> et <b><code>chopOnions</code></b> comme des tâches qui nécessitent un travail actif (et du temps), leur permettant de faire de longs calculs.  Le code complet est disponible à la fin de l'article [1]. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chopCarrots</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chopOnions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addOnions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addCarrots</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }</code> </pre><br>  Avant de passer aux fonctions asynchrones, je vais d'abord expliquer rapidement comment le système de type JavaScript gère l'asynchronie: fondamentalement, <b>tous les résultats (y compris les erreurs) des opérations asynchrones doivent être inclus dans la ou les promesses</b> . <br><br>  Pour qu'une fonction renvoie une promesse, vous pouvez: <br><br><ul><li>  retourner explicitement la promesse, c.-à-d.  <b><code>return new Promise(…)</code></b> ; </li><li>  renvoie implicitement une promesse - ajoutez le <b><code>async</code></b> à la déclaration de fonction, c'est-à-dire  <b><code>async function foo()</code></b> ; </li><li>  <i>utilisez les deux options</i> . </li></ul><br>  Il existe un excellent article [2], qui parle de la différence entre les fonctions asynchrones et les fonctions qui renvoient une promesse.  Par conséquent, dans mon article, je ne m'attarderai pas sur ce sujet, la principale chose à retenir: vous devez <i><b>toujours</b></i> utiliser le <b><code>async</code></b> dans les fonctions asynchrones. <br><br>  Ainsi, nos fonctions asynchrones, représentant les étapes 3 à 5 de la préparation de soupe aux légumes, sont les suivantes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">letPotKeepBoiling</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">time</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,      } async function boilPot() { return; //  ,       }</span></span></code> </pre><br>  Encore une fois, j'ai supprimé les détails d'implémentation afin de ne pas être distrait par eux, mais ils sont publiés à la fin de l'article [1]. <br><br>  Il est important de savoir que pour attendre le résultat de la promesse, afin que plus tard vous puissiez en faire quelque chose, vous pouvez simplement utiliser le mot-clé wait: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*  ... */</span></span> } result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncFunction();</code> </pre><br>  Donc, maintenant nous avons juste besoin de tout rassembler: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pot = boilPot(); chopCarrots(); chopOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pot; addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } makeSoup();</code> </pre><br>  Mais attends!  Ça ne marche pas!  Vous verrez le <b><code>SyntaxError: await is only valid in async functions</code></b> .  Pourquoi?  Parce que si vous ne déclarez pas une fonction en utilisant le <b><code>async</code></b> - <b><code>async</code></b> , alors par défaut JavaScript la définit comme une fonction synchrone - et synchrone signifie pas d'attente!  [3].  Cela signifie également que vous ne pouvez pas utiliser l' <b><code>await</code></b> dehors d'une fonction. <br><br>  Par conséquent, nous ajoutons simplement le <b><code>async</code></b> à la fonction <b><code>makeSoup</code></b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pot = boilPot(); chopCarrots(); chopOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pot; addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); } makeSoup();</code> </pre><br>  Et le tour est joué!  Notez que dans la deuxième ligne, j'appelle la fonction asynchrone <b><code>boilPot</code></b> sans le mot-clé wait, car nous ne voulons pas attendre que la casserole bouillonne avant de commencer à couper les carottes.  Nous n'attendons que la promesse d'un <b><code>pot</code></b> en cinquième ligne avant de devoir mettre les carottes dans la casserole, car nous ne voulons pas le faire avant que l'eau ne bout. <br><br>  Que se passe-t-il pendant les appels en <b><code>await</code></b> ?  Eh bien, rien ... en quelque sorte ... <br><br>  Dans le contexte de la fonction <b><code>makeSoup</code></b> vous pouvez simplement y penser comme si vous vous attendiez à ce que quelque chose se produise (ou un résultat qui sera finalement retourné). <br><br>  Mais rappelez- <b>vous</b> : <b>vous (comme votre processeur) ne voudrez jamais rester assis là et attendre quelque chose, pendant que vous pouvez consacrer votre temps à d'autres choses</b> . <br><br>  Par conséquent, au lieu de simplement cuisiner de la soupe, nous pourrions cuisiner autre chose en parallèle: <br><br><pre> <code class="javascript hljs">makeSoup(); makePasta();</code> </pre><br>  Pendant que nous attendons <b><code>letPotKeepBoiling</code></b> , nous pouvons par exemple cuisiner des pâtes. <br><br>  Tu vois?  La syntaxe async / attente est en fait assez facile à utiliser, si vous la comprenez, d'accord? <br><br><h2>  Et les promesses manifestes? </h2><br>  Eh bien, si vous insistez, je me tournerai vers l'utilisation de promesses explicites ( <i>environ. Transl.: Par promesses explicites, l'auteur implique directement la syntaxe des promesses, et par promesses implicites la syntaxe async / wait, car elle renvoie la promesse implicitement - pas besoin d'écrire <code>return new Promise(…)</code></i> ).  Gardez à l'esprit que les méthodes asynchrones / attendent <b>sont basées sur les promesses elles-mêmes et que les deux options sont donc entièrement compatibles</b> . <br><br>  Les promesses explicites, à mon avis, se situent entre les rappels à l'ancienne et la nouvelle syntaxe sexuelle asynchrone / wait.  Alternativement, vous pouvez également considérer la syntaxe sexuelle asynchrone / wait comme rien de plus que des promesses implicites.  En fin de compte, la construction async / wait est venue après les promesses, qui à leur tour sont venues après les fonctions de rappel. <br><br>  Utilisez notre machine à remonter le temps pour aller au enfer des rappels [4]: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callbackHell</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ boilPot( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addCarrots(); letPotKeepBoiling(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addOnions(); letPotKeepBoiling(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>, chopCarrots(), chopOnions() ); }</code> </pre><br>  Je ne vais pas mentir, j'ai écrit cet exemple à la volée lorsque je travaillais sur cet article, et cela m'a pris beaucoup plus de temps que je ne voudrais l'admettre.  Beaucoup d'entre vous ne savent peut-être même pas ce qui se passe ici.  <i><b>Mon cher ami, toutes ces fonctions de rappel ne sont-elles pas affreuses?</b></i>  <i><b>Que ce soit une leçon de ne plus jamais utiliser les fonctions de rappel ...</b></i> <br><br>  Et, comme promis, le même exemple avec des promesses explicites: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSoup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reject, resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { chopCarrots(); chopOnions(); resolve(); }), boilPot() ]) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addCarrots(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">5</span></span>); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { addOnions(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> letPotKeepBoiling(<span class="hljs-number"><span class="hljs-number">10</span></span>); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>); }); }</code> </pre><br>  Comme vous pouvez le voir, les promesses sont toujours similaires aux fonctions de rappel. <br>  Je n'entrerai pas dans les détails, mais surtout: <br><br><ul><li>  <b><code>.then</code></b> est une méthode promise qui prend son résultat et le passe à la fonction argument (essentiellement, à une fonction de rappel ...) </li><li>  Vous ne pouvez jamais utiliser le résultat d'une promesse en dehors du contexte de <b><code>.then</code></b> .  En substance, .then est comme un bloc asynchrone qui attend un résultat et le transmet ensuite à une fonction de rappel. </li><li>  En plus de la méthode <b><code>.then</code></b> , il y a une autre méthode dans les <b><code>.catch</code></b> - <b><code>.catch</code></b> .  Il est nécessaire pour gérer les erreurs dans les promesses.  Mais je n'entrerai pas dans les détails, car il y a déjà un milliard d'articles et de tutoriels sur ce sujet. </li></ul><br><h2>  Conclusion </h2><br>  J'espère que vous avez eu une idée des promesses et de la programmation asynchrone de cet article, ou peut-être avez-vous au moins appris un bon exemple de la vie pour l'expliquer à quelqu'un d'autre. <br><br>  <b>Alors, quelle voie utilisez-vous: promesses ou async / attente?</b> <br>  La réponse dépend entièrement de vous - et je dirais que les combiner n'est pas si mal, car les deux approches sont complètement compatibles l'une avec l'autre. <br><br>  Cependant, je suis personnellement à 100% dans le camp asynchrone / attendent, car pour moi le code est beaucoup plus compréhensible et reflète mieux le véritable multitâche de la programmation asynchrone. <br><br><hr><br>  <b>[1]</b> : Le code source complet est disponible <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a></u> . <br>  <b>[2]</b> : Article original <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Fonction asynchrone vs.</a></u>  <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une fonction qui renvoie une promesse "</a></u> , traduction de l'article <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">" La différence entre une fonction asynchrone et une fonction qui renvoie une promesse</a></u> . <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"</a></u> <br>  <b>[3]</b> : Vous pouvez faire valoir que JavaScript peut probablement déterminer le type asynchrone / attente par corps de fonction et vérifier récursivement, mais JavaScript n'a pas été conçu pour prendre en charge la sécurité du type statique au moment de la compilation, sans parler de qu'il est beaucoup plus pratique pour les développeurs de voir explicitement le type de fonction. <br>  <b>[4]</b> : J'ai écrit des fonctions «asynchrones», en supposant qu'elles fonctionnent sous la même interface que <b><code>setTimeout</code></b> .  Notez que les rappels ne sont pas compatibles avec les promesses et vice versa. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474726/">https://habr.com/ru/post/fr474726/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474716/index.html">Bugs C ++ 20. Résultats de la réunion à Belfast</a></li>
<li><a href="../fr474718/index.html">Sécurité dans l'électronique automobile - Hello World sur le contrôleur de tableau de bord</a></li>
<li><a href="../fr474720/index.html">Laboratoire radio de Nizhny Novgorod et «cristadins» de Losev</a></li>
<li><a href="../fr474722/index.html">«Personne ne dit aux autres ce qu'ils doivent faire»: Nicolò Ribaudo sur le développement de Babel et plus</a></li>
<li><a href="../fr474724/index.html">Qu'adviendra-t-il de PHP dans 5 ans: nous avons demandé aux intervenants du mitap de Moscou le plus proche</a></li>
<li><a href="../fr474732/index.html">Travailler avec la liste des broches, en C ++ pour les microcontrôleurs (en utilisant CortexM comme exemple)</a></li>
<li><a href="../fr474738/index.html">Modélisation géométrique des surfaces de congé</a></li>
<li><a href="../fr474740/index.html">Le meilleur du musée d'histoire de l'ordinateur à Mountain View</a></li>
<li><a href="../fr474744/index.html">Uber entre sur le marché des services financiers et lance la division Uber Money</a></li>
<li><a href="../fr474746/index.html">Stockage d'objets dans l'arrière-boutique ou Comment devenir votre propre fournisseur de services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>