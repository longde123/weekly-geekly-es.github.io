<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚ÄçüöÄ üë®üèø‚Äçüè´ üëª Introducci√≥n a los ELF de Linux: comprensi√≥n y an√°lisis ü§ì üõÅ ‚ôíÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay cosas en el mundo que damos por sentado, aunque son verdaderas obras maestras. Una de esas cosas son las utilidades de Linux como ls y ps. Aunque ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducci√≥n a los ELF de Linux: comprensi√≥n y an√°lisis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480642/"> Hay cosas en el mundo que damos por sentado, aunque son verdaderas obras maestras.  Una de esas cosas son las utilidades de Linux como ls y ps.  Aunque generalmente se perciben como simples, esto est√° lejos de ser el caso si miramos hacia adentro.  Y tambi√©n lo hace ELF, formato ejecutable y enlazable.  Un formato de archivo que se usa universalmente, pero pocos lo entienden.  Esta gu√≠a r√°pida lo ayudar√° a comprender. <br><br><img src="https://habrastorage.org/webt/ka/0m/em/ka0memy9zppvjiut58hua0_cyt8.jpeg"><br><br>  Despu√©s de leer esta gu√≠a, aprender√°: <br><br><ul><li>  ¬øPor qu√© se necesita el formato ELF y para qu√© tipo de archivos se utiliza? </li><li>  Estructura de archivos ELF y detalles de formato </li><li>  C√≥mo leer y analizar contenido binario de un archivo ELF </li><li>  ¬øQu√© herramientas se utilizan para analizar archivos binarios? </li></ul><a name="habracut"></a><br><h2>  ¬øQu√© es un archivo ELF? </h2><br>  ELF significa formato ejecutable y enlazable, y define la estructura de archivos binarios, bibliotecas y archivos principales.  La especificaci√≥n de formato permite que el sistema operativo interprete correctamente las instrucciones de la m√°quina contenidas en el archivo.  Un archivo ELF suele ser el archivo de salida de un compilador o enlazador y tiene un formato binario.  Usando herramientas adecuadas, puede ser analizado y estudiado. <br><br><h3>  ¬øPor qu√© estudiar ELF en detalle? </h3><br>  Antes de sumergirse en los detalles t√©cnicos, no estar√° mal explicar por qu√© es √∫til comprender el formato ELF.  En primer lugar, le permite estudiar el funcionamiento interno del sistema operativo.  Cuando algo sali√≥ mal, este conocimiento lo ayudar√° a comprender mejor qu√© sucedi√≥ exactamente y por qu√© motivo.  Adem√°s, la capacidad de examinar archivos ELF puede ser valiosa para encontrar agujeros de seguridad y detectar archivos sospechosos.  Y finalmente, para una mejor comprensi√≥n del proceso de desarrollo.  Incluso si programa en un lenguaje de alto nivel como Go, sabr√° mejor lo que sucede detr√°s de escena. <br><br>  Entonces, ¬øpor qu√© estudiar ELF? <br><br><ul><li>  Para una comprensi√≥n general del sistema operativo </li><li>  Para el desarrollo de software </li><li>  An√°lisis forense digital y respuesta a incidentes (DFIR) </li><li>  Investigaci√≥n de malware (an√°lisis binario) </li></ul><br><h3>  De la fuente al proceso </h3><br>  Independientemente del sistema operativo que utilicemos, es necesario traducir de alguna manera las funciones del c√≥digo fuente al lenguaje de la CPU: c√≥digo de m√°quina.  Las funciones pueden ser las m√°s b√°sicas, por ejemplo, abrir un archivo en el disco o mostrar algo en la pantalla.  En lugar de usar el lenguaje de la CPU directamente, usamos un lenguaje de programaci√≥n que tiene caracter√≠sticas est√°ndar.  El compilador luego traduce estas funciones en c√≥digo objeto.  Este c√≥digo de objeto se vincula al programa completo, utilizando el vinculador.  El resultado es un archivo binario que se puede ejecutar en una plataforma espec√≠fica y un tipo espec√≠fico de CPU. <br><br><h3>  Antes de empezar </h3><br>  Esta publicaci√≥n contiene muchos equipos.  Es mejor ejecutarlos en una m√°quina de prueba.  Copie los archivos binarios existentes antes de ejecutar estos comandos en ellos.  Tambi√©n escribiremos un peque√±o programa en C que puede compilar.  En definitiva, la pr√°ctica es la mejor manera de aprender algo. <br><br><h2>  Anatom√≠a de un archivo ELF </h2><br>  Un error com√∫n es que los archivos ELF son solo para archivos binarios o ejecutables.  Ya hemos dicho que pueden usarse para partes de archivos ejecutables (c√≥digo objeto).  Otro ejemplo son los archivos de biblioteca y los volcados de n√∫cleo (archivos de n√∫cleo y archivos a.out).  La especificaci√≥n ELF tambi√©n se usa en Linux para kernel y m√≥dulos de kernel. <br><br><img src="https://habrastorage.org/webt/dt/5y/vq/dt5yvqm-oju3s6todxbbd6ivzw0.png"><br><br><h3>  Estructura </h3><br>  Debido a la extensibilidad de los archivos ELF, la estructura puede variar para diferentes archivos.  El archivo ELF consta de: <br><br><ol><li>  Encabezado ELF </li><li>  datos </li></ol><br>  Con el comando readelf, podemos ver la estructura del archivo, y se ver√° m√°s o menos as√≠: <br><br><img src="https://habrastorage.org/webt/vo/ng/w-/vongw-d8cy_mvkf9jgcizbdpq0c.png"><br><br><h3>  Encabezado ELF </h3><br>  Como puede ver en la captura de pantalla, el encabezado ELF comienza con un "n√∫mero m√°gico".  Este "n√∫mero m√°gico" proporciona informaci√≥n sobre el archivo.  Los primeros 4 bytes determinan que este es un archivo ELF (45 = E, 4c = L, 46 = F, est√°n precedidos por 7f). <br><br>  Se requiere el encabezado ELF.  Es necesario para que los datos se interpreten correctamente durante el enlace y la ejecuci√≥n.  Para una mejor comprensi√≥n del funcionamiento interno de un archivo ELF, es √∫til saber para qu√© se utiliza esta informaci√≥n. <br><br><h3>  Clase </h3><br>  Despu√©s de declarar un tipo ELF, sigue un campo de clase.  Este valor significa la arquitectura a la que est√° destinado el archivo.  Puede ser 01 (arquitectura de 32 bits) o 02 (64 bits).  Aqu√≠ vemos 02, que es traducido por el comando readelf como un archivo ELF64, es decir, este archivo usa una arquitectura de 64 bits.  Esto no es sorprendente, hay un procesador moderno instalado en mi autom√≥vil. <br><br><h3>  Datos </h3><br>  Luego viene el campo "datos", que tiene dos opciones: 01 - LSB (bit menos significativo), tambi√©n conocido como little-endian, o 02 - MSB (bit m√°s significativo, big-endian).  Estos valores ayudan a interpretar el resto de los objetos en el archivo.  Esto es importante porque los diferentes tipos de procesadores manejan las estructuras de datos de manera diferente.  En nuestro caso, se utiliza LSB, ya que el procesador tiene una arquitectura AMD64. <br><br>  El efecto LSB se hace visible cuando se usa la utilidad hexdump en un archivo binario.  Veamos el encabezado ELF para / bin / ps. <br><br><pre><code class="bash hljs">$ hexdump -n 16 /bin/ps 0000000 457f 464c 0102 0001 0000 0000 0000 0000 0000010</code> </pre> <br>  Vemos que los pares de valores son diferentes, debido a la interpretaci√≥n del orden de los datos. <br><br><h3>  Versi√≥n </h3><br>  Luego sigue otro valor m√°gico "01", que es el n√∫mero de versi√≥n.  Actualmente solo est√° disponible la versi√≥n 01, por lo que este n√∫mero no significa nada interesante. <br><br><h3>  OS / ABI </h3><br>  Cada sistema operativo tiene su propia forma de llamar a las funciones, tienen mucho en com√∫n, pero, adem√°s, cada sistema tiene peque√±as diferencias.  El orden de la llamada de funci√≥n est√° determinado por la interfaz binaria de aplicaci√≥n (ABI).  Los campos OS / ABI describen qu√© ABI se usa y su versi√≥n.  En nuestro caso, el valor es 00, lo que significa que no se utilizan extensiones espec√≠ficas.  En la salida, esto se muestra como Sistema V. <br><br><h3>  Versi√≥n ABI </h3><br>  Si es necesario, se puede indicar una versi√≥n ABI. <br><br><h3>  Coche </h3><br>  El t√≠tulo tambi√©n indica el tipo esperado de m√°quina (AMD64). <br><br><h3>  Tipo </h3><br>  El campo de tipo indica para qu√© es el archivo.  Aqu√≠ hay algunos tipos de archivos comunes. <br><br>  N√öCLEO (valor 4) <br>  DYN (archivo de objeto compartido), biblioteca (valor 3) <br>  EXEC (archivo ejecutable), archivo ejecutable (valor 2) <br>  REL (archivo reubicable), archivo antes de vincular (valor 1) <br><br><h3>  Ver el t√≠tulo completo </h3><br>  Aunque algunos campos se pueden ver a trav√©s de readelf, en realidad hay m√°s.  Por ejemplo, puede averiguar para qu√© procesador es el archivo.  Use hexdump para ver el encabezado ELF completo y todos los valores. <br><br><pre> <code class="bash hljs">7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 |.ELF............| 02 00 3e 00 01 00 00 00 a8 2b 40 00 00 00 00 00 |..&gt;......+@.....| 40 00 00 00 00 00 00 00 30 65 01 00 00 00 00 00 |@.......0e......| 00 00 00 00 40 00 38 00 09 00 40 00 1c 00 1b 00 |....@.8...@.....|</code> </pre> <br>  (salida hexdump -C -n 64 / bin / ps) <br><br>  El campo resaltado determina el tipo de m√°quina.  El valor 3e es el decimal 62, que corresponde a AMD64.  Para tener una idea de todos los tipos de archivos, vea <a href="" rel="nofollow">este</a> archivo de encabezado. <br><br>  Aunque puede hacer todo esto en un volcado hexadecimal, tiene sentido usar una herramienta que haga el trabajo por usted.  La utilidad dumpelf puede ser √∫til.  Muestra resultados formateados que coinciden con el encabezado ELF.  Ser√° bueno estudiar qu√© campos se utilizan y cu√°les son sus valores t√≠picos. <br><br>  Ahora, donde hemos explicado el significado de estos campos, ¬°es hora de ver qu√© magia real hay detr√°s de ellos y pasar a los siguientes encabezados! <br><br><h3>  Datos de archivo </h3><br>  Adem√°s del encabezado, los archivos ELF constan de tres partes. <br><br><ul><li>  Encabezados o segmentos del programa </li><li>  Secci√≥n o encabezados de secci√≥n </li><li>  Datos </li></ul><br>  Antes de sumergirnos en estos encabezados, ser√≠a √∫til saber que el archivo ELF tiene dos "tipos" diferentes.  Uno de ellos est√° dise√±ado para el enlazador y permite la ejecuci√≥n de c√≥digo (segmentos).  El otro es para comandos y datos (secciones).  Dependiendo del prop√≥sito, se usa el tipo de encabezado apropiado.  Comencemos con el encabezado del programa, que se encuentra en los archivos ejecutables ELF. <br><br><h3>  T√≠tulos de programa </h3><br>  Un archivo ELF consta de cero o m√°s segmentos, y describe c√≥mo crear un proceso, una imagen de memoria para la ejecuci√≥n en tiempo de ejecuci√≥n.  Cuando el n√∫cleo ve estos segmentos, los coloca en el espacio de direcciones virtuales utilizando la llamada al sistema mmap (2).  En otras palabras, convierte las instrucciones preparadas previamente en una imagen en la memoria.  Si el archivo ELF es un binario regular, requiere estos encabezados de programa, de lo contrario simplemente no funcionar√°.  Estos encabezados se utilizan, junto con las estructuras de datos correspondientes, para formar el proceso.  Para las bibliotecas compartidas, el proceso es similar. <br><br><img src="https://habrastorage.org/webt/p4/ja/c_/p4jac_lojwvn9movhy8w5rad1g0.png"><br>  Encabezado de programa en archivo binario ELF <br><br>  Vemos 9 t√≠tulos de programas en este ejemplo.  Al principio es dif√≠cil entender lo que significan.  Vamos a sumergirnos en los detalles. <br><br><h3>  GNU_EH_FRAME </h3><br>  Esta es la cola ordenada utilizada por el compilador GCC.  Almacena manejadores de excepciones.  Si algo sali√≥ mal, se utilizan para manejar correctamente la situaci√≥n. <br><br><h3>  GNU_STACK </h3><br>  Este encabezado se utiliza para guardar la informaci√≥n de la pila.  Una caracter√≠stica interesante es que la pila no tiene que ser ejecutable, ya que esto podr√≠a implicar vulnerabilidades de seguridad. <br><br>  Si falta el segmento GNU_STACK, se utiliza la pila ejecutable.  Las utilidades scanelf y execstack muestran los detalles del dispositivo de pila. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># scanelf -e /bin/ps TYPE STK/REL/PTL FILE ET_EXEC RW- R-- RW- /bin/ps # execstack -q /bin/ps - /bin/ps</span></span></code> </pre> <br>  Comandos para ver el encabezado del programa: <br><br><ul><li>  dumpelf (pax-utils) </li><li>  elfos -S / bin / ps </li><li>  eu-readelf ‚Äìprogram-headers / bin / ps </li></ul><br><h3>  Secciones ELF </h3><br><h4>  Encabezados de secci√≥n </h4><br>  Los encabezados de secci√≥n definen todas las secciones de un archivo.  Como ya se mencion√≥, esta informaci√≥n se utiliza para vincular y reubicar. <br><br>  Las secciones aparecen en un archivo ELF despu√©s de que el compilador GNU C convierte el c√≥digo C en ensamblador, y el ensamblador GNU crea objetos. <br><br>  Como se muestra en la figura anterior, un segmento puede tener 0 o m√°s secciones.  Hay cuatro secciones principales para archivos ejecutables: .text, .data, .rodata y .bss.  Cada una de estas secciones arranca con diferentes permisos, que se pueden ver con readelf -S. <br><br><h4>  .text </h4><br>  Contiene c√≥digo ejecutable.  Se empaquetar√° en un segmento con derechos de lectura y ejecuci√≥n.  Se descarga una vez y su contenido no cambia.  Esto se puede ver con la utilidad objdump. <br><br><pre> <code class="bash hljs">12 .text 0000a3e9 0000000000402120 0000000000402120 00002120 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE</code> </pre> <br><h4>  .data </h4><br>  Datos inicializados con permisos de lectura y escritura. <br><br><h4>  .rodata </h4><br>  Datos inicializados con permisos de solo lectura.  (= A). <br><br><h4>  .bss </h4><br>  Datos no inicializados con permisos de lectura / escritura.  (= WA) <br><br><pre> <code class="bash hljs">[24] .data PROGBITS 00000000006172e0 000172e0 0000000000000100 0000000000000000 WA 0 0 8 [25] .bss NOBITS 00000000006173e0 000173e0 0000000000021110 0000000000000000 WA 0 0 32</code> </pre> <br><br>  Comandos para ver secciones y t√≠tulos. <br><br><ul><li>  dumpelf </li><li>  elfls -p / bin / ps </li><li>  eu-readelf ‚Äìsection-headers / bin / ps </li><li>  readelf -S / bin / ps </li><li>  objdump -h / bin / ps </li></ul><br><h4>  Grupos de secciones </h4><br>  Algunas secciones se pueden agrupar como si formaran un todo √∫nico.  Los nuevos vinculadores admiten esta funcionalidad.  Pero si bien esto no es com√∫n. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># readelf -g /bin/ps There are no section groups in this file.</span></span></code> </pre> <br>  Aunque esto puede no parecer muy interesante, el conocimiento de las herramientas de an√°lisis de archivos ELF proporciona grandes beneficios.  Por esta raz√≥n, se proporciona una descripci√≥n general de estas herramientas y su prop√≥sito al final del art√≠culo. <br><br><h3>  Binarios est√°ticos y din√°micos. </h3><br>  Cuando se trata de archivos binarios ELF, ser√° √∫til saber c√≥mo est√°n vinculados estos dos tipos de archivos.  Pueden ser est√°ticos y din√°micos, y esto se aplica a las bibliotecas que usan.  Si el binario es "din√°mico", significa que utiliza bibliotecas externas que contienen algunas funciones comunes, como abrir un archivo o crear un socket de red.  Los binarios est√°ticos, por el contrario, incluyen todas las bibliotecas necesarias. <br><br>  Si desea verificar si el archivo es est√°tico o din√°mico, use el comando de archivo.  Ella mostrar√° algo como esto: <br><br><pre> <code class="bash hljs">$ file /bin/ps /bin/ps: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), &lt;b&gt;dynamically linked (uses shared libs)&lt;/b&gt;, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.24, BuildID[sha1]=2053194ca4ee8754c695f5a7a7cff2fb8fdd297e, stripped</code> </pre> <br>  Para determinar qu√© bibliotecas externas se usan, simplemente use ldd en el mismo binario: <br><br><pre> <code class="bash hljs">$ ldd /bin/ps linux-vdso.so.1 =&gt; (0x00007ffe5ef0d000) libprocps.so.3 =&gt; /lib/x86_64-linux-gnu/libprocps.so.3 (0x00007f8959711000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f895934c000) /lib64/ld-linux-x86-64.so.2 (0x00007f8959935000)</code> </pre> <br>  Consejo: Para ver m√°s dependencias, es mejor usar la utilidad lddtree. <br><br><h2>  Herramientas de an√°lisis binario </h2><br>  Si desea analizar archivos ELF, definitivamente ser√° √∫til mirar primero las herramientas existentes.  Hay kits de herramientas para el desarrollo inverso de binarios y c√≥digo ejecutable.  Si es nuevo en el an√°lisis de archivos ELF, comience con el an√°lisis est√°tico.  El an√°lisis est√°tico implica que examinamos los archivos sin iniciarlos.  Cuando comience a comprender mejor su trabajo, pase al an√°lisis din√°mico.  Ejecute los ejemplos y observe su comportamiento real. <br><br><h3>  Herramientas populares </h3><br><h4>  Radare2 </h4><br>  El kit de herramientas Radare2 fue creado por Sergi Alvarez.  El n√∫mero 2 implica que el c√≥digo ha sido reescrito completamente en comparaci√≥n con la primera versi√≥n.  Ahora muchos investigadores lo utilizan para estudiar el funcionamiento del c√≥digo. <br><br><h4>  Paquetes de software </h4><br>  La mayor√≠a de los sistemas Linux tienen binutils instalados.  Otros paquetes pueden ayudarlo a ver m√°s informaci√≥n.  El kit de herramientas correcto simplificar√° su trabajo, especialmente si est√° analizando archivos ELF.  He compilado aqu√≠ una lista de paquetes y utilidades para analizar archivos ELF. <br><br>  <b>elfutils</b> <br>  / usr / bin / eu-addr2line <br>  / usr / bin / eu-ar: una alternativa a ar, para crear y procesar archivos de almacenamiento <br>  / usr / bin / eu-elfcmp <br>  / usr / bin / eu-elflint: compruebe el cumplimiento de las especificaciones gABI y psABI <br>  / usr / bin / eu-findtextrel - busca reubicaciones de texto <br>  / usr / bin / eu-ld - combina objetos y archivos de almacenamiento <br>  / usr / bin / eu-make-debug-archive <br>  / usr / bin / eu-nm: muestra los s√≠mbolos del objeto y los archivos ejecutables <br>  / usr / bin / eu-objdump - muestra informaci√≥n del archivo objeto <br>  / usr / bin / eu-ranlib: crea un √≠ndice de archivos <br>  / usr / bin / eu-readelf - muestra el archivo ELF en forma legible <br>  / usr / bin / eu-size: muestra el tama√±o de cada secci√≥n (texto, datos, bss, etc.) <br>  / usr / bin / eu-stack: muestra la pila del proceso actual o el volcado del kernel <br>  / usr / bin / eu-strings: muestra cadenas de texto (como la utilidad de cadenas) <br>  / usr / bin / eu-strip: elimina la tabla de caracteres del archivo ELF <br>  / usr / bin / eu-unstrip: agrega s√≠mbolos e informaci√≥n de depuraci√≥n al binario <br>  Nota: el paquete elfutils ser√° un buen comienzo, contiene la mayor√≠a de las herramientas de an√°lisis <br><br>  <b>elfkickers</b> <br>  / usr / bin / ebfc - compilador de lenguaje Brainfuck <br>  / usr / bin / elfls: muestra encabezados de programa y encabezados de secci√≥n con banderas <br>  / usr / bin / elftoc - convierte un programa binario en un programa en C <br>  / usr / bin / infect: una utilidad que inyecta un cuentagotas crea un archivo setuid en / tmp <br>  / usr / bin / objres: crea un objeto a partir de datos regulares o binarios <br>  / usr / bin / rebind: cambia el enlace y la visibilidad de los caracteres en los archivos ELF <br>  / usr / bin / sstrip: elimina componentes innecesarios de un archivo ELF <br>  Nota: el autor del paquete ELFKickers se centra en manipular archivos ELF, lo que le permite obtener m√°s informaci√≥n cuando trabaja con los archivos binarios ELF "incorrectos" <br><br>  <b>pax-utils</b> <br>  / usr / bin / dumpelf - volcado de la estructura ELF interna <br>  / usr / bin / lddtree - como ldd, con la configuraci√≥n del nivel de dependencias que se muestra <br>  / usr / bin / pspax - muestra informaci√≥n ELF / PaX sobre procesos en ejecuci√≥n <br>  / usr / bin / scanelf: una amplia gama de informaci√≥n, incluidos detalles de PaX <br>  / usr / bin / scanmacho: muestra detalles de los binarios de Mach-O (Mac OS X) <br>  / usr / bin / symtree - muestra los caracteres del √°rbol <br>  Nota: algunas utilidades en este paquete pueden escanear directorios de forma recursiva y son ideales para analizar todo el contenido de un directorio.  El foco est√° en las herramientas de investigaci√≥n de PaX.  Adem√°s de admitir ELF, puede extraer informaci√≥n de los binarios de Mach-O. <br><br>  Ejemplo de salida <br><pre> <code class="bash hljs">scanelf -a /bin/ps TYPE PAX PERM ENDIAN STK/REL/PTL TEXTREL RPATH BIND FILE ET_EXEC PeMRxS 0755 LE RW- R-- RW- - - LAZY /bin/ps</code> </pre> <br><br>  <b>preenlace</b> <br>  / usr / bin / execstack: puede ver o cambiar informaci√≥n sobre si la pila es ejecutable <br>  / usr / bin / prelink: reubica llamadas en archivos ELF para acelerar el proceso <br><br><h2>  Preguntas frecuentes </h2><br><h3>  ¬øQu√© es un ABI? </h3><br>  ABI es la interfaz binaria de aplicaci√≥n y define una interfaz de bajo nivel entre el sistema operativo y el c√≥digo ejecutable. <br><br><h3>  ¬øQu√© es el ELF? </h3><br>  ELF es un formato ejecutable y enlazable.  Esta es una especificaci√≥n de formato que define c√≥mo se escriben las instrucciones en c√≥digo ejecutable. <br><br><h3>  ¬øC√≥mo puedo ver el tipo de archivo? </h3><br>  Use el comando de archivo para la primera etapa de an√°lisis.  Este comando puede mostrar los detalles extra√≠dos de los n√∫meros y encabezados "m√°gicos". <br><br><h2>  Conclusi√≥n </h2><br>  Los archivos ELF son para ejecuci√≥n y vinculaci√≥n.  Dependiendo del prop√≥sito, contienen los segmentos y secciones necesarios.  El n√∫cleo del sistema operativo escanea los segmentos y los asigna a la memoria (usando mmap).  Las secciones son vistas por un enlazador que crea un archivo ejecutable u objeto compartido. <br><br>  Los archivos ELF son muy flexibles y admiten varios tipos de CPU, arquitecturas de m√°quinas y sistemas operativos.  Tambi√©n es extensible, cada archivo est√° dise√±ado de manera diferente, dependiendo de las partes requeridas.  Mediante el uso de las herramientas adecuadas, puede averiguar el prop√≥sito del archivo y examinar el contenido de los archivos binarios.  Puede ver las funciones y l√≠neas contenidas en el archivo.  Un buen comienzo para aquellos que investigan malware o para entender por qu√© el proceso se comporta (o no) de cierta manera. <br><br><h2>  Recursos para estudios posteriores </h2><br>  Si desea saber m√°s sobre ELF y la ingenier√≠a inversa, puede ver el trabajo que hacemos en Linux Security Expert.  Como parte del plan de estudios, tenemos <a href="https://linuxsecurity.expert/training/domains/reverse-engineering" rel="nofollow">un m√≥dulo de ingenier√≠a inversa</a> con trabajo pr√°ctico de laboratorio. <br><br>  Para aquellos de ustedes que aman leer, un documento bueno y profundo: <a href="http://www.skyfree.org/linux/references/ELF_Format.pdf" rel="nofollow">Formato ELF</a> y un <a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt" rel="nofollow">documento escrito por</a> Brian Raiter, tambi√©n conocido como ELFkickers.  Para aquellos a quienes les gusta entender la fuente, miren el <a href="" rel="nofollow">encabezado ELF documentado</a> de Apple. <br><br>  Consejo: <br>  Si desea mejorar en el an√°lisis de archivos, comience a usar las <a href="https://linuxsecurity.expert/security-tools/binary-analysis-tools" rel="nofollow">herramientas de an√°lisis populares</a> que est√°n disponibles actualmente. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480642/">https://habr.com/ru/post/480642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480614/index.html">ENUM r√°pido</a></li>
<li><a href="../480618/index.html">Juego electr√≥nico Tic Tac Toe. ¬øA qu√© he venido?</a></li>
<li><a href="../480620/index.html">SD-WAN y DNA para ayudar al administrador: caracter√≠sticas de arquitecturas y pr√°ctica</a></li>
<li><a href="../480622/index.html">C√≥mo usar la capacidad de almacenamiento disponible correctamente</a></li>
<li><a href="../480626/index.html">Herencia de sistemas y procesos heredados o Los primeros 90 d√≠as en el rol de CTO</a></li>
<li><a href="../480646/index.html">Habr - mejores art√≠culos, autores y estad√≠sticas 2019</a></li>
<li><a href="../480650/index.html">Cuyo cabello es m√°s fuerte: morfolog√≠a capilar</a></li>
<li><a href="../480652/index.html">C√°mara PoE de 250 metros sobre cable: es posible</a></li>
<li><a href="../480654/index.html">¬øJulia vencer√° a Python al igual que Python hizo Java</a></li>
<li><a href="../480658/index.html">1C - Bien y mal. Colocaci√≥n de puntos en holivares alrededor de 1C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>