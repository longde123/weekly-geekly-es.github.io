<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚úàÔ∏è üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ üëß Eine kurze Tour durch GraphQL üë©üèª‚Äçüç≥ üë®‚Äçüíª ü§úüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 


 Das Buch von Alex Banks und Eva Porsello, das wir vor einigen Tagen der √úbersetzung gegeben haben, dient Ihnen als kurzer Exkurs in di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine kurze Tour durch GraphQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/424037/">  Hallo Habr! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fq/02/xc/fq02xcxho24foozvi0yg3k35km4.jpeg"></div><br>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch von</a> Alex Banks und Eva Porsello, das wir vor einigen Tagen der √úbersetzung gegeben haben, dient Ihnen als kurzer Exkurs in die GraphQL-Abfragesprache.  Das Buch der gleichen Autoren √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React und Redux</a> wurde zu einem echten Bestseller (wir warten auf die 5. Auflage der Druckerei).  √úbrigens, danke an alle, die uns auf Ungenauigkeiten im Code und in den Begriffen hingewiesen haben;) Wir haben das Buch √ºber so schnell veraltete Technologie zu schnell gemacht. <br><br>  Der Autor des heutigen Artikels, Robin Viruch, arbeitet ebenfalls an einem Buch √ºber GraphQL und Bibliotheken f√ºr diese Sprache und erkl√§rt im heutigen Artikel kurz die Vorteile und Eigenschaften von GraphQL als Alternative zu REST <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/ud/um/yb/udumybonjvas4ywnznkpeedukpm.jpeg"><br><br>  Wenn es um Netzwerkanforderungen zwischen Client- und Serveranwendungen geht, wird REST am h√§ufigsten als Br√ºcke zwischen der Client- und der Serverwelt ausgew√§hlt.  In REST dreht sich alles um die Idee "Wir brauchen Ressourcen, auf die √ºber URL zugegriffen werden kann".  Sie k√∂nnen eine Ressource mithilfe einer <code>HTTP GET</code> lesen, eine Ressource mithilfe einer <code>HTTP POST</code> Anforderung erstellen und sie mithilfe von <code>HTTP PUT</code> und <code>DELETE</code> Anforderungen aktualisieren und l√∂schen.  Diese Vorg√§nge werden als CRUD (Erstellen, Lesen, Aktualisieren, L√∂schen) bezeichnet.  Die Ressource kann jeder Inhalt sein, der von Autoren, Benutzern oder aus Artikeln stammt.  Bei Verwendung von REST ist das Daten√ºbertragungsformat nicht fest codiert, aber meistens wird JSON f√ºr diesen Zweck verwendet.  Am Ende erm√∂glicht REST die Kommunikation zwischen Anwendungen √ºber das normale HTTP-Protokoll mithilfe von URLs und HTTP-Methoden. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    REST GET https://api.domain.com/authors/7 //   JSON { "id": "7", "name": "Robin Wieruch", "avatarUrl": "https://domain.com/authors/7", "firstName": "Robin", "lastName": "Wieruch" }</span></span></code> </pre> <br>  Obwohl REST eine ganze Weile ein De-facto-Standard blieb, hat in den letzten Jahren eine andere von Facebook entwickelte Technologie an Popularit√§t gewonnen: Sie hei√üt GraphQL.  Dieser Artikel, eine Einf√ºhrung in GraphQL, beschreibt die Vor- und Nachteile dieser Abfragesprache. <br><br>  <b>Was ist GraphQL?</b> <br><br>  Bevor wir uns mit den St√§rken und Schw√§chen von GraphQL befassen, beantworten wir zun√§chst die folgende Frage: Was ist GraphQL?  GraphQL ist eine Freeware- <b>Abfragesprache,</b> die 2012 von Facebook erstellt wurde.  Bereits vor der √úbermittlung des Produkts an Open Source wurde die Sprache auf Facebook als interne Technologie f√ºr die Arbeit mit mobilen Anwendungen verwendet.  Warum mit mobilen Apps?  GraphQL wurde als Alternative zur typischen REST-Architektur entwickelt.  Der Client kann nur die gew√ºnschten Daten anfordern - nicht mehr und nicht weniger.  Der Kunde ist f√ºr alles verantwortlich, also f√ºr Sie.  In diesem Fall treten Schwierigkeiten in der REST-Architektur auf, da die Datenbankschnittstelle bestimmt, welche Informationen f√ºr jede Ressource unter jeder URL verf√ºgbar sind.  Datenabtastung wird im Client-Teil nicht angefordert.  Daher sollte das Frontend auf jeden Fall alle Informationen √ºber die Ressource anfordern, auch wenn es nur einen Teil dieser Daten ben√∂tigt.  Dieses Problem wird als "erneutes Abtasten" bezeichnet.  Im schlimmsten Fall muss die Clientanwendung nicht nur eine, sondern viele Ressourcen lesen, f√ºr deren Zugriff viele Netzwerkanforderungen ausgef√ºhrt werden m√ºssen.  Dies f√ºhrt nicht nur zu einer erneuten Probenahme, sondern auch zu Lawinenanforderungen √ºber das Netzwerk.  Mit einer Abfragesprache wie GraphQL, die nicht nur auf dem Server, sondern auch auf der Clientseite verwendet wird, entscheidet der Client, welche Daten er ben√∂tigt - und sendet daf√ºr nur eine Anfrage an den Server.  Als Facebook mobile Anwendungen mit der GraphQL-Sprache entwickelte, konnte die Netzwerklast drastisch reduziert werden, da viel weniger Daten √ºber Facebook √ºbertragen wurden. <br><br>  Facebook hat die GraphQL-Spezifikation und ihre Referenzimplementierung in JavaScript f√ºr den freien Zugriff ver√∂ffentlicht.  Seitdem wurde diese Spezifikation in vielen anderen wichtigen Programmiersprachen implementiert.  Dar√ºber hinaus w√§chst das √ñkosystem, das sich um GraphQL herum entwickelt hat, nicht nur horizontal und breitet sich auch auf andere Programmiersprachen aus, sondern auch vertikal (Bibliotheken bauen auf GraphQL auf, z. B. Apollo, Relay). <br><br>  GraphQL bietet die folgenden Arten von Operationen: Anforderung (Lesen), √Ñndern (Schreiben) oder Abonnement (kontinuierliches Lesen).  Jede dieser Operationen ist nur eine Zeichenfolge, die gem√§√ü der Spezifikation der GraphQL-Abfragesprache zusammengestellt werden muss.  Sobald eine solche GraphQL-Operation von der Client-Anwendung zur Datenbankanwendung gelangt, kann sie im Vergleich zum gesamten GraphQL-Schema im Backend interpretiert und f√ºr die Client-Anwendung unter Verwendung der verf√ºgbaren Daten zugelassen werden.  GraphQL funktioniert mit jeder Netzwerkschicht (die h√§ufig √ºber HTTP organisiert ist) ebenso gut wie mit jedem Nutzdatenformat (h√§ufig JSON).  Er befasst sich auch vollst√§ndig nicht mit der Anwendungsarchitektur (die in den meisten F√§llen aus dem Client-Teil und der Datenbankschnittstelle besteht).  Es ist nur eine Abfragesprache. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  GraphQL author(id: "7") { id name avatarUrl articles(limit: 2) { name urlSlug } } //   GraphQL { "data": { "author": { "id": "7", "name": "Robin Wieruch", "avatarUrl": "https://domain.com/authors/7", "articles": [ { "name": "The Road to learn React", "urlSlug": "the-road-to-learn-react" }, { "name": "React Testing Tutorial", "urlSlug": "react-testing-tutorial" } ] } } }</span></span></code> </pre> <br>  Wie Sie sehen k√∂nnen, gilt die Abfrage bereits f√ºr viele Ressourcen (Autor, Artikel), die in GraphQL als Felder bezeichnet werden, und nur f√ºr einen bestimmten Satz verschachtelter Felder f√ºr diese Felder (Name, URLSlug f√ºr den Artikel), obwohl andere Daten im GraphQL-Datenschema selbst bereitgestellt werden k√∂nnen Informationen (zum Beispiel f√ºr einen Artikel - eine Beschreibung, Erscheinungsdatum).  W√§hrend in einer REST-Architektur mindestens zwei kaskadierende Abfragen erforderlich sind, um den Autor und die Artikel dieses Autors abzurufen, l√∂st GraphQL dieses Problem in einer Abfrage.  Dar√ºber hinaus w√§hlt die Abfrage nur die erforderlichen Felder und nicht die gesamte Entit√§t aus. <br><br>  Dies ist die Essenz von GraphQL.  In dem Fall, in dem die Serveranwendung das GraphQL-Schema bereitstellt, in dem sie alle verf√ºgbaren Daten mit ihrer Hierarchie und ihren Typen definiert, fordert die Clientanwendung nur die Daten an, die sie ben√∂tigt. <br><br>  <b>GraphQL-Vorteile</b> <br><br>  Im Folgenden sind die Hauptvorteile der Verwendung von GraphQL in einer Anwendung aufgef√ºhrt. <br><br>  <i><b>Deklarative Datenerfassung</b></i> <br><br>  Wie Sie sehen k√∂nnen, verwendet GraphQL in seinen Abfragen deklarative Datenstichproben.  Der Client w√§hlt die Daten, ihre Entit√§ten und alle Felder aus, zwischen denen verschiedene Beziehungen bestehen, und f√ºr all dies wird eine einzelne Anforderung angewendet.  Der Client entscheidet, welche Felder f√ºr diese Benutzeroberfl√§che ben√∂tigt werden.  Oft kann man fast √ºber UI-orientierte Datenerfassung sprechen.  So verwendet Airbnb beispielsweise GraphQL.  Eine Airbnb-Suchmaschine liefert h√§ufig Ergebnisse f√ºr H√§user, Impressionen und andere Kategorien, die f√ºr einen bestimmten Themenbereich spezifisch sind.  Um alle Daten auf einmal zu extrahieren, wird eine GraphQL-Abfrage ausgef√ºhrt, die nur die Informationen aufnimmt, die in einer bestimmten Benutzeroberfl√§che definitiv ben√∂tigt werden.  Letztendlich hat GraphQL eine sehr gut organisierte Aufgabenteilung: Der Client kennt die Datenanforderungen, der Server kennt die Datenstruktur und wei√ü, wie Daten aus einer vorhandenen Quelle aufgel√∂st werden (sei es eine Datenbank, ein Microservice oder eine Drittanbieter-API). <br><br>  <i><b>Kein erneutes Abtasten bei der Arbeit mit GraphQL</b></i> <br><br>  Bei der Arbeit mit GraphQL erfolgt keine erneute Auswahl.  W√§hrend ein mobiler Client wahrscheinlich einen erneuten Abruf mit derselben API wie ein Webclient mit einer REST-API durchf√ºhrt.  Bei der Arbeit mit GraphQL k√∂nnen der mobile Client und der Webclient mithilfe derselben GraphQL-API unterschiedliche Feldgruppen f√ºr sich ausw√§hlen.  Folglich kann der mobile Client weniger Informationen ausw√§hlen, da auf dem kleinen Bildschirm m√∂glicherweise keine unn√∂tigen Informationen ben√∂tigt werden (im Gegensatz zu dem gro√üen Monitor, von dem aus die Webversion der Anwendung angezeigt wird).  GraphQL minimiert die √ºber das Netzwerk √ºbertragene Datenmenge, w√§hlt sie selektiv aus und orientiert sich in diesem Fall in erster Linie an den Anforderungen der Clientanwendung. <br><br>  <i><b>GraphQL f√ºr React, Angular, Node usw.</b></i> <br><br>  GraphQL ist eine vielversprechende L√∂sung nicht nur f√ºr React-Entwickler.  Sei es Facebook, das GraphQL √ºbertrumpft, und auf der Client-Seite verwendet Facebook React. Tats√§chlich ist diese Sprache an keine L√∂sung f√ºr das Frontend oder Backend gebunden.  Die Referenzimplementierung von GraphQL ist in JavaScript geschrieben, sodass GraphQL mit Angular-, Vue-, Express-, Hapi-, Koa- und anderen JavaScript-Bibliotheken in den Client- und Serverteilen kombiniert werden kann.  Dar√ºber hinaus gilt dies nicht nur f√ºr das JavaScript-√ñkosystem.  GraphQL imitiert REST in einem Aspekt, aufgrund dessen es popul√§r geworden ist: Die GraphQL-Schnittstelle ist unabh√§ngig von der Programmiersprache (Abfragesprache), die zur Kommunikation von zwei Objekten (z. B. Client und Server) verwendet wird.  Daher kann seine Spezifikation in jeder Programmiersprache reproduziert werden. <br><br>  <i><b>Wer nutzt GraphQL?</b></i> <br><br>  Facebook verwendet GraphQL seit 2012, bevor diese Sprache Open Source wurde.  Facebook ist die treibende Kraft f√ºr die Entwicklung der GraphQL-Spezifikation und deren Referenzimplementierung in JavaScript.  Wenn Sie also mit GraphQL arbeiten, stehen Sie bereits auf den Schultern von Riesen.  Andere bekannte Unternehmen verwenden diese Sprache jedoch in ihren Anwendungen.  Sie investieren in das GraphQL-√ñkosystem, weil moderne Anwendungen eine solche Sprache dringend ben√∂tigen.  Sie werden also nicht nur von Facebook unterst√ºtzt, sondern auch von folgenden Unternehmen: <br><br><ul><li>  GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[1]</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[2]</a> </li><li>  Shopify <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[1]</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[2]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coursera</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yelp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wordpress</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">D ie New Yorker Zeiten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Samsara</a> </li><li>  und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere</a> ... </li></ul><br>  Als Facebook GraphQL entwickelte und √∂ffentlich zug√§nglich machte, standen auch andere Unternehmen f√ºr mobile Apps vor √§hnlichen Problemen.  Auf diese Weise hat Netflix das Falcor-Projekt erstellt, das als Alternative zu GraphQL angesehen werden kann.  Dies best√§tigt einmal mehr, dass Sie f√ºr moderne Anwendungen genau solche L√∂sungen wie GraphQL und Falcor ben√∂tigen. <br><br>  <i><b>Die eine Quelle der Wahrheit</b></i> <br><br>  In GraphQL-Anwendungen existiert die ultimative Wahrheit: Dies ist das GraphQL-Schema.  Sie ist es - die zentrale Quelle, die alle verf√ºgbaren Daten beschreibt.  W√§hrend das GraphQL-Schema normalerweise auf der Serverseite definiert wird, k√∂nnen Clients Daten basierend auf diesem Schema lesen (abfragen) und schreiben (√§ndern).  Daher stellt die Serveranwendung im Wesentlichen die auf dem Server verf√ºgbaren umfassenden Informationen bereit, und die Clientseite fragt nur, was f√ºr die Formulierung von Abfragen in GraphQL erforderlich ist, oder √§ndert kleine Informationsfragmente mithilfe der √Ñnderungen in GraphQL. <br><br>  <i><b>GraphQL folgt aktuellen Trends</b></i> <br><br>  GraphQL folgt aktuellen Trends in der Anwendungsentwicklung.  Sie k√∂nnen nur eine Anwendung im Backend haben, aber es kommt h√§ufig vor, dass viele verschiedene Clients dieses Backend verwenden (Webclient, Mobilger√§t, Smartwatches ...) und alle von den in der Backendanwendung gespeicherten Daten abh√§ngen.  Daher kann GraphQL nicht nur dazu beitragen, Freunde aus beiden Welten zu finden, sondern auch die Anforderungen jedes Clients zu erf√ºllen (z. B. √ºber das Netzwerk, verschachtelte Datenbeziehungen, nur die erforderlichen Daten ausw√§hlen), ohne dass f√ºr jeden Client-Typ eine dedizierte API erstellt werden muss. <br><br>  Andererseits k√∂nnen wir auf dem Server keine einzige interne Schnittstelle erwarten, sondern eine Gruppe von Mikrodiensten, von denen jeder seine eigene spezifische Funktionalit√§t bietet.  F√ºr einen solchen Fall ist das GraphQL-Schema ideal geeignet, dessen Struktur so ist, dass in einem solchen GraphQL-Schema alle Arten von Funktionen aggregiert werden k√∂nnen. <br><br>  <i><b>Wie das GraphQL-Schema sticht</b></i> <br><br>  Dank des N√§hens k√∂nnen Sie ein Schema aus vielen anderen zusammensetzen.  Wann kann ich in diese Situation geraten?  Angenommen, Ihr Backend wird mithilfe einer Microservice-Architektur implementiert.  Jeder Microservice verarbeitet Gesch√§ftslogik und Daten zu einem bestimmten Themenbereich.  Daher kann jeder Mikrodienst sein eigenes GraphQL-Schema definieren.  Danach m√ºssen Sie sie zusammenn√§hen, um eines der Schemata zusammenzustellen, auf die die Clientanwendung zugreifen wird.  Am Ende kann jeder Mikrodienst ein eigenes GraphQL-Terminal haben, und ein GraphQL-API-Gateway konsolidiert alle Schemata in einem globalen, um es f√ºr Clientanwendungen bereitzustellen. <br><br>  <i><b>Introspection GraphQL</b></i> <br><br>  GraphQL Introspection ist die F√§higkeit, ein GraphQL-Schema mit der GraphQL-API zu extrahieren.  Da das Schema alle Informationen zu allen √ºber die GraphQL-API verf√ºgbaren Daten enth√§lt, kann es mit gro√üem Erfolg f√ºr die automatische Generierung der API-Dokumentation verwendet werden.  Die Angelegenheit ist jedoch nicht auf die Dokumentation der API beschr√§nkt.  Introspection kann auch verwendet werden, um GraphQL-Schemas in einer Client-Anwendung zu simulieren (zu Testzwecken) oder um Schemas von mehreren Microservices abzurufen und sie dann zusammenzuf√ºgen. <br><br>  <i><b>Stark typisiertes GraphQL</b></i> <br><br>  GraphQL ist eine stark typisierte Abfragesprache, die in der ausdrucksstarken Schema Definition Language (SDL) f√ºr GraphQL geschrieben ist.  Diese Sprache hat die gleichen Vorteile wie jede stark typisierte Programmiersprache.  Es ist weniger fehleranf√§llig, kann zur Kompilierungszeit validiert werden und kann f√ºr die Integration in unterst√ºtzte IDE / Editor-Funktionen wie Autovervollst√§ndigung und Eingabeunterst√ºtzung verwendet werden. <br><br>  <i><b>Versionierung von GraphQL</b></i> <br><br>  GraphQL verf√ºgt nicht √ºber solche API-Versionen, die wir in REST gewohnt sind.  In REST ist es normal, mehrere Versionen derselben API anzubieten (z. B. api.domain.com/v1/, api.domain.com/v2/), da sich Ressourcen oder ihre Struktur im Laufe der Zeit √§ndern k√∂nnen.  In GraphQL k√∂nnen Sie APIs auf Feldebene in nicht empfohlene APIs √ºbersetzen.  Daher erh√§lt der Client eine Warnung, wenn er auf ein nicht empfohlenes Feld zugreift.  Nach einiger Zeit kann das nicht empfohlene Feld aus dem Schema ausgeschlossen werden, dann wird es von keinen Clients mehr verwendet.  Somit kann die GraphQL-API entwickelt werden, ohne dass eine Versionierung erforderlich ist. <br><br>  <i><b>Wachsendes GraphQL-√ñkosystem</b></i> <br><br>  Das GraphQL-√ñkosystem w√§chst.  Es geht nicht nur um Integrationen mit Editoren und IDEs, die mit der stark typisierten Natur von GraphQL zusammenh√§ngen.  F√ºr GraphQL als solches gibt es neue vollwertige Anwendungen.  Sie k√∂nnen sich beispielsweise an Postman erinnern, das bei der Arbeit mit der REST-API verwendet wurde und jetzt f√ºr denselben Zweck, jedoch mit der GraphQL-API, GraphiQL oder GraphQL Playground verwendet wird.  Es gibt auch verschiedene Bibliotheken f√ºr Sie, zum Beispiel Gatsby.js, einen statischen Website-Generator f√ºr React, der GraphQL verwendet.  Mit Gatsby.js k√∂nnen Sie beispielsweise eine Blog-Engine schreiben, die Ihr Blog w√§hrend der Erstellung √ºber die GraphQL-API mit Inhalten f√ºllt.  Daher verf√ºgen Sie auch √ºber CMS ohne Client-Teil (z. B. GraphCMS), der Inhalte (f√ºr ein Blog) √ºber GraphQL bereitstellt.  API  In diesem Bereich entwickeln sich jedoch nicht nur technologische Komponenten.  Da nach dem Regen Pilze wachsen, sind Konferenzen, Mitaps und Communities, die sich GraphQL widmen, auch in Newslettern und Podcasts leicht zu finden. <br><br>  <i><b>Wenn ich zu GraphQL wechsle - gehe ich All-In?</b></i> <br><br>  Wenn wir GraphQL zum vorhandenen technologischen Stack hinzuf√ºgen, gehen wir nat√ºrlich nicht all-in.  Bei der Migration von einer monolithischen Back-End-Anwendung zu einer Microservice-Architektur ist es am wichtigsten, neue Microservices durch die GraphQL-API zu ersetzen.  Genau in Gegenwart vieler Microservices k√∂nnen Sie und Ihr Team das GraphQL-Gateway sicher implementieren, Schemata zusammenf√ºgen und zu einem globalen Schema zusammenfassen.  Das API-Gateway kann jedoch nicht nur mit Microservices, sondern auch mit einer monolithischen REST-Anwendung verwendet werden.  Auf diese Weise k√∂nnen Sie alle Ihre APIs auf einem Gateway kombinieren und Schritt f√ºr Schritt auf GraphQL migrieren. <br><br>  <b>Nachteile von GraphQL</b> <br><br>  Als n√§chstes diskutieren wir einige der Nachteile, die mit der Verwendung von GraphQL verbunden sind. <br><br>  <i><b>GraphQL-Abfragekomplexit√§t</b></i> <br><br>  Manchmal wird GraphQL falsch verwendet, ich versuche es durch eine serverseitige Datenbank zu ersetzen.  Nein, das geht nicht.  GraphQL ist nur eine Abfragesprache.  Wenn auf der Serverseite die Anforderung mit Daten aufgel√∂st werden muss, gibt es normalerweise eine GraphQL-unabh√§ngige Implementierung, die den Zugriff auf die Datenbank erm√∂glicht.  GraphQL ist in diesem Fall gleichg√ºltig.  Dar√ºber hinaus beseitigt GraphQL keine Leistungsengp√§sse, wenn Sie viele Felder (Autoren, Artikel, Kommentare) in einer Abfrage behandeln m√ºssen.  Unabh√§ngig von der Architektur, in der die Anforderung gestellt wurde - RESTful oder GraphQL - m√ºssen Sie immer noch verschiedene Felder aus der Quelle extrahieren. <br><br>  Daher tritt ein Problem auf, wenn der Client eine Reihe von Anforderungen sofort an die verschachtelten Felder sendet.  H√§ufig wissen die clientseitigen Entwickler nicht, wie viele verschiedene Datenbankabfragen in der Serveranwendung verarbeitet werden m√ºssen, wenn Massendatenaufrufe beginnen.  In solchen F√§llen ist ein Mechanismus erforderlich (z. B. maximale Abfragetiefe, Gewichtung der Komplexit√§t von Abfragen, Vermeidung von Rekursionen, konstante Abfragen), um den Fluss zu teurer Abfragen vom Client zu verhindern. <br><br>  <i><b>Geschwindigkeitsbegrenzung in GraphQL</b></i> <br><br>  Ein weiteres Problem ist die Geschwindigkeitsbegrenzung.  W√§hrend in REST relativ einfach zu sagen ist, dass nicht mehr als so viele Abfragen pro Tag zul√§ssig sind, ist es schwierig, eine solche Anweisung f√ºr einzelne GraphQL-Operationen zu formulieren, da es nicht nur "kostspielige" und "nicht kostspielige" Operationen gibt, sondern auch viele Zwischenabstufungen.  In solchen F√§llen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bieten</a> Unternehmen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die √∂ffentliche GraphQL-APIs bereitstellen, ihre eigenen Geschwindigkeitsbegrenzungsberechnungen an</a> , die h√§ufig auf die oben genannten Maximalwerte f√ºr die Abfragetiefe und die Gewichtung der Abfragekomplexit√§t reduziert werden. <br><br>  <i><b>GraphQL-Caching</b></i> <br><br>  Bei der Arbeit mit GraphQL ist die Implementierung eines vereinfachten Caches viel komplizierter als in REST.  Bei der Arbeit mit REST greifen wir √ºber die URL auf Ressourcen zu und k√∂nnen daher das Caching auf Ressourcenebene organisieren, da die Ressourcen-URL als Kennung dienen kann.  In GraphQL ist dies kompliziert, da alle Abfragen unterschiedlich sein k√∂nnen, obwohl alle mit demselben Objekt arbeiten.  In einer Anfrage k√∂nnen Sie den Namen des Autors und in der n√§chsten nicht nur den Namen des Autors, sondern auch seine E-Mail-Adresse anfordern.  In solchen F√§llen ben√∂tigen Sie einen filigraneren Cache auf Feldebene, und die Implementierung ist nicht so einfach.  Die meisten Bibliotheken, die auf GraphQL aufbauen, bieten solche Caching-Mechanismen jedoch sofort an. <br><br>  <b>Warum nicht REST?</b> <br><br> GraphQL ‚Äì      REST,     .     REST ‚Äì      GraphQL,      REST? <br>   REST  URL   ,       .     ¬´¬ª,   id,       ,   id.  GraphQL        ,       .  ,       ,      ,  GraphQL       ,   . <br><br>          ,    REST.        Airbnb.   ,       .        REST-,   REST-       .    , ,  GraphQL API,          GraphQL,      (,   ),      (.,   ). <br><br>   , GraphQL     ;   ,    ,    ,      .          GraphQL ‚Äì    Facebook   ,  -. <br><br> ,    ,   REST ‚Äì       .       ,             GraphQL. ,     GraphQL,        - . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424037/">https://habr.com/ru/post/de424037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424027/index.html">Lernen Sie kontroverse Taktiken, Techniken und allgemeines Wissen (ATT @ CK). Unternehmenstaktik. Teil 2</a></li>
<li><a href="../de424029/index.html">Und wieder √ºber Faulheit</a></li>
<li><a href="../de424031/index.html">Reaktive Programmierung mit JAX-RS</a></li>
<li><a href="../de424033/index.html">Was macht Kotlin: ein Interview mit Andrei Breslav</a></li>
<li><a href="../de424035/index.html">2019 ist das Jahr, in dem Intel aufgeh√∂rt hat</a></li>
<li><a href="../de424039/index.html">Kryptographie nach der Landung von Au√üerirdischen</a></li>
<li><a href="../de424041/index.html">Eine kurze Einf√ºhrung in die Zellbiologie</a></li>
<li><a href="../de424043/index.html">Sonniger Hattrick. Es gibt drei D√∂rfer von Dobrovlyany in der Ukraine. Und alle drei haben leistungsstarke Solarkraftwerke</a></li>
<li><a href="../de424045/index.html">Manchmal sind ein paar Tricks n√∂tig, wenn man mit Git arbeitet</a></li>
<li><a href="../de424049/index.html">Wir pr√§sentieren der Olympiade das Buch "Harry Potter und die Methoden des rationalen Denkens"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>