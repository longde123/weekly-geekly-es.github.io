<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ•Ô∏è üë®‚Äçüëß‚Äçüëß üè¶ Le livre ¬´Learning Java EE. Programmation moderne pour les grandes entreprises " üë®üèø‚Äç‚öñÔ∏è üôÜüèø üêé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut Habr! 

 Ce livre d√©crit la nouvelle g√©n√©ration de Java EE. Vous embarquerez pour un voyage √† travers Java EE dans le contexte du monde moderne ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre ¬´Learning Java EE. Programmation moderne pour les grandes entreprises "</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/418025/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ct/ac/t4/ctact4noq-x7eg0x5gqj_8kbm7g.jpeg" align="left" alt="image"></a>  Salut Habr! <br><br>  Ce livre d√©crit la nouvelle g√©n√©ration de Java EE.  Vous embarquerez pour un voyage √† travers Java EE dans le contexte du monde moderne des microservices et conteneurs.  Il ne s'agit pas d'un guide de r√©f√©rence sur la syntaxe de l'API - les concepts et techniques pr√©sent√©s ici refl√®tent l'exp√©rience r√©elle d'une personne qui a r√©cemment parcouru ce chemin, en accordant une attention particuli√®re aux obstacles qui se posent et est pr√™te √† partager ses connaissances.  Dans une vari√©t√© de situations, de la cr√©ation d'un package pour les tests et l'utilisation du cloud, ce livre sera un compagnon id√©al pour les d√©butants et les d√©veloppeurs exp√©riment√©s cherchant √† comprendre plus qu'une simple API, et les aidera √† reconstruire leur r√©flexion pour cr√©er une architecture d'application moderne en Java EE . <br><a name="habracut"></a><br><h3>  S√©quence d'ex√©cution </h3><br>  Les processus m√©tier mis en ≈ìuvre dans les applications d'entreprise d√©crivent des flux de processus sp√©cifiques.  Pour les sc√©narios d'entreprise impliqu√©s, il s'agit soit d'un processus de demande et de r√©ponse synchrone, soit d'un traitement asynchrone d'un processus initi√©. <br><br>  Les sc√©narios d'entreprise sont appel√©s dans des threads s√©par√©s, un thread par demande ou appel.  Les flux sont cr√©√©s par le conteneur et plac√©s dans le lecteur pour √™tre r√©utilis√©s une fois l'appel correctement trait√©.  Par d√©faut, les processus m√©tier d√©finis dans les classes d'application, ainsi que les t√¢ches transversales telles que les transactions, sont ex√©cut√©s s√©quentiellement. <br><br><h3>  Ex√©cution synchrone </h3><br>  Un sc√©nario typique lorsqu'une demande HTTP n√©cessite une r√©ponse de la base de donn√©es est impl√©ment√© comme suit.  Un thread traite la requ√™te arrivant √† la boucle, par exemple, le JAX-RS UsersResource, en inversant le principe de contr√¥le;  La m√©thode de ressource JAX-RS est appel√©e par le conteneur.  La ressource impl√©mente et utilise l'EJB UserManagement, qui est √©galement implicitement appel√© par le conteneur.  Toutes les op√©rations sont effectu√©es par des interm√©diaires de mani√®re synchrone.  L'utilisateur EJB utilisera le gestionnaire d'entit√©s pour stocker la nouvelle entit√© et d√®s que la m√©thode m√©tier qui a initi√© la transaction actuellement active se termine, le conteneur tentera de valider la transaction dans la base de donn√©es.  En fonction du r√©sultat de la transaction, la m√©thode de ressource du circuit reprend son fonctionnement et g√©n√®re une r√©ponse au client.  Tout se passe de mani√®re synchrone, √† ce moment le client est bloqu√© et attend une r√©ponse. <br><br>  L'ex√©cution synchrone comprend le traitement des √©v√©nements CDI synchrones.  Ils s√©parent le d√©clenchement des √©v√©nements de domaine de leur traitement, cependant, les √©v√©nements sont trait√©s de mani√®re synchrone.  Il existe plusieurs m√©thodes pour surveiller les transactions.  Si une √©tape de transaction est indiqu√©e, l'√©v√©nement peut √™tre trait√© √† ce stade - pendant la fixation de la transaction, avant son ach√®vement, apr√®s l'ach√®vement, en cas de transaction infructueuse ou r√©ussie.  Par d√©faut, ou si la transaction est inactive, les √©v√©nements CDI sont trait√©s imm√©diatement lorsqu'ils se produisent.  Cela permet aux ing√©nieurs d'impl√©menter des solutions complexes - par exemple, en utilisant des √©v√©nements qui ne se produisent qu'apr√®s l'ajout r√©ussi d'entit√©s √† la base de donn√©es.  Quoi qu'il en soit, dans tous les cas, le traitement est effectu√© de mani√®re synchrone. <br><br><h3>  Ex√©cution asynchrone </h3><br>  L'ex√©cution synchronis√©e des t√¢ches r√©pond aux exigences de nombreux sc√©narios d'entreprise, mais il y a des moments o√π vous avez besoin d'un comportement asynchrone.  Il existe un certain nombre de restrictions sur l'utilisation des threads par l'environnement Java EE.  Le conteneur g√®re les ressources et les flux et les place dans le lecteur.  Les utilitaires de contr√¥le d'acc√®s concurrentiels externes sont situ√©s √† l'ext√©rieur du conteneur et ne connaissent pas ces flux.  Par cons√©quent, le code d'application ne doit pas s'ex√©cuter et contr√¥ler ses threads.  Pour ce faire, il utilise les fonctionnalit√©s Java EE.  Il existe plusieurs API avec prise en charge asynchrone int√©gr√©e. <br><br>  <b>M√©thodes EJB asynchrones</b> <br><br>  La mani√®re la plus simple d'impl√©menter un comportement asynchrone consiste √† utiliser l'annotation @Asynchronous pour une m√©thode m√©tier de classe EJB ou EJB.  Les appels √† ces m√©thodes reviennent imm√©diatement, parfois avec une r√©ponse de type Future.  Ils s'ex√©cutent dans un thread s√©par√© contr√¥l√© par le conteneur.  Cette m√©thode fonctionne bien pour des sc√©narios simples, mais est limit√©e aux EJB: <br><br><pre><code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Asynchronous</span></span> <span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> decimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      } }</span></span></code> </pre> <br>  <b>Service de gestion des performances</b> <br><br>  Pour l'ex√©cution asynchrone de t√¢ches dans des objets CDI g√©r√©s ou √† l'aide des utilitaires de contr√¥le de concurrence Java SE, Java EE inclut des versions g√©r√©es par conteneur des fonctions ExecutorService et ScheduledExecutorService.  Ils sont utilis√©s pour impl√©menter des t√¢ches asynchrones dans les threads pilot√©s par conteneur.  Les instances ManagedExecutorService et ManagedScheduledExecutorService sont incorpor√©es dans le code d'application.  Ils peuvent √™tre utilis√©s pour ex√©cuter leur propre logique, mais sont plus efficaces lorsqu'ils sont combin√©s avec des utilitaires de contr√¥le de concurrence Java SE, tels que des valeurs futures compl√©mentaires.  L'exemple suivant montre comment cr√©er des valeurs futures remplies √† l'aide de threads pilot√©s par conteneur: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.annotation.Resource; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.enterprise.concurrent.ManagedExecutorService; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Random; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.CompletableFuture; <span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CompletableFuture&lt;Double&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateRandomPi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxDecimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random().nextInt(maxDecimalPlaces) + <span class="hljs-number"><span class="hljs-number">1</span></span>, mes) .thenApply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::calculatePi); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> decimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre> <br>  L'objet Calculatrice renvoie la valeur future compl√©t√©e du type double, qui peut toujours √™tre calcul√©e lorsque le contexte appelant reprend.  Il peut √™tre demand√© lorsque les calculs sont termin√©s, ainsi que combin√© avec les calculs ult√©rieurs.  Peu importe o√π de nouveaux threads sont requis dans l'application d'entreprise, vous devez utiliser la fonctionnalit√© Java EE pour les g√©rer. <br><br>  <b>√âv√©nements CDI asynchrones</b> <br><br>  Les √©v√©nements CDI peuvent √©galement √™tre trait√©s de mani√®re asynchrone.  Dans ce cas, le conteneur fournit √©galement un flux pour g√©rer les √©v√©nements.  Pour d√©crire un gestionnaire d'√©v√©nements asynchrone, la m√©thode est annot√©e avec @ObservesAsync et l'√©v√©nement est activ√© √† l'aide de la m√©thode fireAsync ().  Les extraits de code suivants illustrent les √©v√©nements CDI asynchrones: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarManufacturer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CarFactory carFactory; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Event&lt;CarCreated&gt; carCreated; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Car </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manufactureCar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Specification spec)</span></span></span><span class="hljs-function"> </span></span>{ Car car = carFactory.createCar(spec); carCreated.fireAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CarCreated(spec)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> car; } }</code> </pre> <br>  Le gestionnaire d'√©v√©nements est appel√© dans son propre thread g√©r√© par conteneur: <br><br><pre> <code class="hljs cs">import javax.enterprise.<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.ObservesAsync; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedCarListener</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCarCreated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">@ObservesAsync CarCreated </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    } }</span></span></code> </pre> <br>  Pour des raisons de compatibilit√© descendante, les √©v√©nements CDI synchrones peuvent √©galement √™tre trait√©s dans la m√©thode EJB asynchrone.  Ainsi, les √©v√©nements et les gestionnaires sont d√©finis comme synchrones, et la m√©thode du gestionnaire est une m√©thode m√©tier EJB avec annotation @Asynchronous.  Avant l'introduction des √©v√©nements asynchrones dans la norme CDI pour Java EE 8, c'√©tait le seul moyen d'impl√©menter cette fonctionnalit√©.  Pour √©viter toute confusion dans Java EE 8 et versions ult√©rieures, il est pr√©f√©rable d'√©viter cette impl√©mentation. <br><br>  <b>√âtendues de traitement asynchrones</b> <br><br>  √âtant donn√© que le conteneur ne contient pas d'informations sur la dur√©e des t√¢ches asynchrones, l'utilisation des √©tendues dans ce cas est limit√©e.  Les objets ayant une port√©e dans la demande ou la session qui √©taient disponibles lorsque la t√¢che asynchrone a √©t√© lanc√©e ne seront pas n√©cessairement actifs tout au long de son impl√©mentation - la demande et la session peuvent se terminer bien avant son ach√®vement.  Ainsi, les threads effectuant des t√¢ches asynchrones, telles que celles fournies par le service d'ex√©cuteur programm√© ou les √©v√©nements asynchrones, peuvent ne pas avoir acc√®s aux instances d'objets g√©r√©s avec port√©e dans la demande ou la session qui √©taient actives pendant l'appel.  Il en va de m√™me pour l'acc√®s aux liens vers des instances int√©gr√©es, par exemple dans les m√©thodes lambda qui font partie d'une ex√©cution synchrone. <br><br>  Ceci doit √™tre pris en compte lors de la mod√©lisation des t√¢ches asynchrones.  Toutes les informations sur un appel particulier doivent √™tre fournies au d√©but de la t√¢che.  Cependant, une t√¢che asynchrone peut avoir ses propres instances d'objets g√©r√©s avec une port√©e limit√©e. <br><br>  <b>D√©finir l'ex√©cution du temps</b> <br><br>  Les sc√©narios d'entreprise peuvent √™tre appel√©s non seulement de l'ext√©rieur, par exemple via une requ√™te HTTP, mais √©galement √† partir de l'application - une t√¢che qui s'ex√©cute √† un moment pr√©cis. <br><br>  Dans le monde Unix, la fonctionnalit√© d'ex√©cution de travaux p√©riodiques est populaire - ce sont les t√¢ches du planificateur.  Les EJB offrent des capacit√©s similaires √† l'aide de minuteries EJB.  Les temporisateurs invoquent des m√©thodes m√©tier √† des intervalles sp√©cifi√©s ou apr√®s une heure sp√©cifi√©e.  L'exemple suivant d√©crit une minuterie cyclique qui d√©marre toutes les dix minutes: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.ejb.Schedule; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.ejb.Startup; <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-meta"><span class="hljs-meta">@Startup</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PeriodicJob</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Schedule</span></span>(minute = <span class="hljs-string"><span class="hljs-string">"*/10"</span></span>, hour = <span class="hljs-string"><span class="hljs-string">"*"</span></span>, persistent = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executeJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   10  } }</span></span></code> </pre> <br>  Tous les EJB - singletones, objets g√©r√©s avec ou sans persistance d'√©tat - peuvent cr√©er des temporisations.  Cependant, dans la plupart des sc√©narios, il est logique de cr√©er des temporisateurs pour singleton uniquement.  Le d√©lai est d√©fini pour tous les objets actifs.  Habituellement, il est n√©cessaire de lancer les t√¢ches planifi√©es √† temps, c'est pourquoi il est utilis√© dans singleton.  Pour la m√™me raison, dans cet exemple, l'objet EJB doit √™tre actif au d√©marrage de l'application.  Cela garantit que la minuterie commence √† fonctionner imm√©diatement. <br><br>  Si vous d√©crivez le temporisateur comme une constante, sa dur√©e de vie s'√©tend √† l'ensemble du cycle de vie de la machine virtuelle Java.  Le conteneur est responsable du stockage des temporisateurs persistants, g√©n√©ralement dans la base de donn√©es.  Les minuteries permanentes, qui devraient fonctionner lorsque l'application n'est pas disponible, s'activent au d√©marrage.  Il vous permet √©galement d'utiliser les m√™mes minuteries avec plusieurs instances de l'objet.  Des minuteries constantes avec une configuration de serveur appropri√©e sont une solution appropri√©e si vous devez ex√©cuter un processus m√©tier exactement une fois sur plusieurs serveurs. <br><br>  Les temporisateurs cr√©√©s automatiquement √† l'aide de l'annotation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Schedule</a> sont d√©crits √† l'aide d'expressions cron de type Unix.  Pour plus de flexibilit√©, les temporisateurs EJB sont d√©crits par programme √† l'aide du service de temporisation fourni par le conteneur, qui cr√©e les m√©thodes de rappel Timers et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Timeout</a> . <br><br>  Les t√¢ches p√©riodiques et diff√©r√©es peuvent √©galement √™tre d√©crites en dehors des EJB √† l'aide du service de planificateur g√©r√© par conteneur.  Une instance de ManagedScheduledExecutorService qui ex√©cute des t√¢ches apr√®s le d√©lai sp√©cifi√© ou √† des intervalles sp√©cifi√©s est impl√©ment√©e dans les composants g√©r√©s.  Ces t√¢ches seront impl√©ment√©es dans des unit√©s d'ex√©cution pilot√©es par conteneur: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@ApplicationScoped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Periodic</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedScheduledExecutorService mses; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startAsyncJobs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mses.schedule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::execute, <span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.SECONDS); mses.scheduleAtFixedRate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::execute, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.SECONDS); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre> <br>  L'appel de la m√©thode startAsyncJobs () ex√©cutera la fonction execute () sur le thread g√©r√© dix secondes apr√®s l'appel, puis toutes les dix secondes apr√®s la premi√®re minute. <br><br>  <b>Asynchronie et r√©activit√© dans JAX-RS</b> <br><br>  JAX-RS prend en charge le comportement asynchrone afin de ne pas bloquer inutilement les flux de requ√™tes c√¥t√© serveur.  M√™me si une connexion HTTP attend une r√©ponse, le flux de demandes peut continuer √† traiter d'autres demandes pendant qu'un long processus s'ex√©cute sur le serveur.  Les flux de demandes sont agr√©g√©s dans un conteneur, et ce r√©f√©rentiel de demandes a une certaine taille.  Afin de ne pas gaspiller le flux de demandes, les m√©thodes de ressources asynchrones JAX-RS cr√©ent des t√¢ches qui sont ex√©cut√©es lorsque le flux de demandes revient et peuvent √™tre r√©utilis√©es.  La connexion HTTP reprend et donne une r√©ponse apr√®s la fin de la t√¢che asynchrone ou apr√®s un d√©lai d'expiration.  L'exemple suivant montre la m√©thode de ressource asynchrone JAX-RS: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Path(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"users"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-meta"><span class="hljs-meta">@Consumes(MediaType.APPLICATION_JSON)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; ‚Ä¶ <span class="hljs-meta"><span class="hljs-meta">@POST</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletionStage&lt;Response&gt; createUserAsync(User user) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.supplyAsync(() -&gt; createUser(user), mes); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Response createUser(User user) { userStore.create(user); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.accepted().build(); } }</code> </pre> <br>  Pour garder le flux de demandes occup√© trop longtemps, la m√©thode JAX-RS doit se terminer rapidement.  Cela est d√ª au fait que la m√©thode des ressources est appel√©e √† partir du conteneur au moyen d'une inversion de contr√¥le.  Le r√©sultat obtenu √† l'√©tape d'ach√®vement sera utilis√© pour reprendre la connexion client √† la fin du traitement. <br><br>  Le retour des √©tapes d'ach√®vement est une technologie relativement nouvelle dans l'API JAX-RS.  Si vous devez d√©crire le retard et en m√™me temps offrir une plus grande flexibilit√© avec une r√©ponse asynchrone, vous pouvez inclure le type AsyncResponse dans la m√©thode.  Cette approche est illustr√©e dans l'exemple suivant: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">javax</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ws</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.container</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AsyncResponse</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">javax</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ws</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.container</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Suspended</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">Path</span></span>("<span class="hljs-keyword"><span class="hljs-keyword">users</span></span>") @Consumes(MediaType.APPLICATION_JSON) public class UsersResource { @<span class="hljs-keyword"><span class="hljs-keyword">Resource</span></span> ManagedExecutorService mes; ‚Ä¶ @<span class="hljs-keyword"><span class="hljs-keyword">POST</span></span> public void createUserAsync(User user, @Suspended AsyncResponse response) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setTimeout</span></span>(5, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TimeUnit</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SECONDS</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setTimeoutHandler</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.resume</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.status</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Status</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SERVICE_UNAVAILABLE</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.build</span></span>())); <span class="hljs-selector-tag"><span class="hljs-selector-tag">mes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.execute</span></span>(() <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.resume</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">createUser</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">user</span></span>))); } }</code> </pre> <br>  Gr√¢ce aux d√©lais d'attente cr√©√©s, la demande du client n'attendra pas ind√©finiment, mais seulement jusqu'√† ce que le r√©sultat soit re√ßu ou que le d√©lai d'appel expire.  Cependant, les calculs continueront car ils sont effectu√©s de mani√®re asynchrone.  Pour les ressources JAX-RS impl√©ment√©es en tant qu'EJB, vous pouvez appliquer l'annotation @Asynchronous afin de ne pas appeler explicitement les m√©thodes m√©tier asynchrones via l'ex√©cuteur de service. <br><br>  Le client JAX-RS prend √©galement en charge le comportement asynchrone.  Selon les besoins, il est judicieux de ne pas le bloquer lors des appels HTTP.  L'exemple pr√©c√©dent montre comment d√©finir des d√©lais pour les demandes des clients.  Pour les appels syst√®me externes de longue dur√©e et en particulier parall√®les, il est pr√©f√©rable d'utiliser un comportement asynchrone et r√©actif. <br><br>  Consid√©rez plusieurs applications serveur qui fournissent des informations m√©t√©orologiques.  Le composant client acc√®de √† toutes ces applications et calcule les pr√©visions m√©t√©orologiques moyennes.  Id√©alement, vous pourriez rendre l'acc√®s aux syst√®mes parall√®le: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.stream.Collectors; <span class="hljs-meta"><span class="hljs-meta">@ApplicationScoped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherForecast</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Client client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;WebTarget&gt; targets; <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; <span class="hljs-meta"><span class="hljs-meta">@PostConstruct</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ client = ClientBuilder.newClient(); targets = ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Forecast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAverageForecast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invokeTargetsAsync() .stream() .map(CompletableFuture::join) .reduce(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::calculateAverage) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"   "</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CompletableFuture&lt;Forecast&gt;&gt; invokeTargetsAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targets.stream() .map(t -&gt; CompletableFuture.supplyAsync(() -&gt; t .request(MediaType.APPLICATION_JSON_TYPE) .get(Forecast.class), mes)) .collect(Collectors.toList()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Forecast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateAverage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Forecast first, Forecast second)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } <span class="hljs-meta"><span class="hljs-meta">@PreDestroy</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ client.close(); } }</code> </pre> <br>  La m√©thode invokeTargetsAsync () appelle les objets disponibles de mani√®re asynchrone, en invoquant le service d'ex√©cuteur planifi√©.  Les descripteurs CompletableFuture sont renvoy√©s et utilis√©s pour calculer les r√©sultats moyens.  Le d√©but de la m√©thode join () sera bloqu√© jusqu'√† la fin de l'appel et la r√©ception des r√©sultats. <br><br>  Les objets appel√©s de mani√®re asynchrone d√©marrent et attendent une r√©ponse de plusieurs ressources √† la fois, peut-√™tre plus lentement.  Dans ce cas, l'attente des r√©ponses des ressources du service m√©t√©o prend autant de temps que l'attente de la r√©ponse la plus lente, et pas toutes les r√©ponses ensemble. <br><br>  La derni√®re version de JAX-RS a un support int√©gr√© pour les √©tapes d'ach√®vement, ce qui r√©duit le code st√©r√©otyp√© dans les applications.  Comme pour les valeurs remplies, l'appel renvoie imm√©diatement le code de la phase d'ach√®vement pour r√©f√©rence future.  L'exemple suivant montre les fonctions client r√©actives JAX-RS utilisant l'appel rx (): <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">Forecast</span></span> getAverageForecast() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invokeTargetsAsync() .stream() .<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>((l, r) -&gt; l.thenCombine(r, this::calculateAverage)) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(s -&gt; s.toCompletableFuture().<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>()) .orElseThrow(() -&gt; new <span class="hljs-type"><span class="hljs-type">IllegalStateException</span></span>(<span class="hljs-string"><span class="hljs-string">"   "</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CompletionStage</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Forecast</span></span>&gt;&gt; invokeTargetsAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targets.stream() .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(t -&gt; t .request(<span class="hljs-type"><span class="hljs-type">MediaType</span></span>.<span class="hljs-type"><span class="hljs-type">APPLICATION_JSON_TYPE</span></span>) .rx() .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-type"><span class="hljs-type">Forecast</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>)) .collect(<span class="hljs-type"><span class="hljs-type">Collectors</span></span>.toList()); }</code> </pre> <br>  Dans l'exemple ci-dessus, vous n'avez pas besoin de rechercher le service des ex√©cuteurs programm√©s - le client JAX-RS le g√©rera lui-m√™me.  Avant l'apparition de la m√©thode rx (), les clients utilisaient un appel async () explicite.  Cette m√©thode s'est comport√©e de la m√™me mani√®re, mais n'a renvoy√© que les objets Future.  L'utilisation d'une approche r√©active chez les clients est optimale pour la plupart des projets. <br>  Comme vous pouvez le voir, Java EE utilise un service d'artiste g√©r√© par conteneur. <br><br><h3>  Concevoir des concepts et des principes dans Java EE moderne </h3><br>  L'API Java EE est bas√©e sur des conventions et des principes de conception √©nonc√©s comme des normes.  Les ing√©nieurs logiciels y trouveront des mod√®les d'API et des approches de d√©veloppement d'applications familiers.  Le but de Java EE est de promouvoir une utilisation coh√©rente de l'API. <br><br>  Le principe principal des applications ax√©es principalement sur la mise en ≈ìuvre de sc√©narios commerciaux est le suivant: la technologie ne doit pas interf√©rer.  Comme d√©j√† mentionn√©, les ing√©nieurs devraient pouvoir se concentrer sur la mise en ≈ìuvre de la logique m√©tier sans passer la plupart du temps sur des questions technologiques et d'infrastructure.  Id√©alement, la logique du domaine est impl√©ment√©e en Java simple et est compl√©t√©e par des annotations et d'autres propri√©t√©s prises en charge par l'environnement de l'entreprise, sans affecter le code de domaine ni le compliquer.  Cela signifie que la technologie ne n√©cessite pas beaucoup d'attention des ing√©nieurs et n'impose pas de restrictions trop importantes.  L'environnement J2EE n√©cessitait auparavant de nombreuses solutions tr√®s complexes.  Pour impl√©menter les interfaces et √©tendre les classes de base, nous avons d√ª utiliser des objets g√©r√©s et des objets de stockage persistants.  Cela a compliqu√© la logique du sujet et rendu les tests difficiles. <br><br>  En Java EE, la logique du domaine est impl√©ment√©e sous forme de classes Java simples √©quip√©es d'annotations, selon lesquelles le conteneur r√©sout certaines t√¢ches de l'entreprise lors de l'ex√©cution de l'application.  La pratique de la cr√©ation de code propre implique souvent l'√©criture d'un code plus beau que pratique √† r√©utiliser.  Java EE prend en charge cette approche.  Si, pour une raison quelconque, vous devez supprimer la technologie et laisser la logique pure du sujet, cela se fait en supprimant simplement les annotations correspondantes. <br><br>  Comme nous le verrons au chapitre 7, cette approche de programmation implique la n√©cessit√© de tests, car pour les programmeurs, la plupart des sp√©cifications Java EE ne sont rien d'autre que des annotations. <br><br>  Tout au long de l'API, un principe de conception appel√© inversion de contr√¥le (IoC) a √©t√© adopt√© - en d'autres termes, "ne nous appelez pas, nous nous appellerons".  Cela est particuli√®rement visible dans les circuits d'application, tels que les ressources JAX-RS.  Les m√©thodes de ressource sont d√©crites √† l'aide d'annotations de m√©thode Java, qui sont ensuite appel√©es par le conteneur dans le contexte appropri√©.  Il en va de m√™me pour l'injection de d√©pendances, dans laquelle vous devez choisir des g√©n√©rateurs ou prendre en compte des t√¢ches transversales telles que les intercepteurs.  Les d√©veloppeurs d'applications peuvent se concentrer sur l'impl√©mentation de la logique et la description des relations, laissant l'impl√©mentation des d√©tails techniques dans un conteneur.  Un autre exemple, moins √©vident, est la description de la conversion d'objets Java en JSON et vice versa via des annotations JSON-B.  Les objets sont transform√©s non seulement sous une forme explicite et programm√©e, mais aussi implicitement, dans un style d√©claratif. <br><br>  Un autre principe qui permet aux ing√©nieurs d'appliquer efficacement cette technologie est la programmation par accord.  Par d√©faut, Java EE d√©finit un comportement sp√©cifique qui correspond √† la plupart des sc√©narios d'utilisation.  S'il ne suffit pas ou s'il ne r√©pond pas aux exigences, le comportement peut √™tre red√©fini, souvent √† plusieurs niveaux. <br>  Il existe de nombreux exemples de programmation de convention.  L'un d'eux est l'utilisation de m√©thodes de ressources JAX-RS qui convertissent la fonctionnalit√© Java en r√©ponses HTTP.  Si le comportement standard de JAX-RS en ce qui concerne les r√©ponses ne satisfait pas aux exigences, vous pouvez appliquer le type de r√©ponse R√©ponse.  Un autre exemple est la sp√©cification d'objets g√©r√©s, qui est g√©n√©ralement impl√©ment√©e √† l'aide d'annotations.  Pour modifier ce comportement, vous pouvez utiliser le descripteur XML beans.xml.  Il est tr√®s pratique pour les programmeurs que dans le monde moderne de Java EE, les applications d'entreprise soient d√©velopp√©es de mani√®re pragmatique et hautes performances qui ne n√©cessitent g√©n√©ralement pas une utilisation intensive de XML comme auparavant. <br><br>  Quant √† la productivit√© des programmeurs, un autre principe important du d√©veloppement sur Java EE est que cette plate-forme n√©cessite une int√©gration dans le conteneur de diff√©rents standards.  √âtant donn√© que les conteneurs prennent en charge un ensemble sp√©cifique d'API - et si l'int√©gralit√© de l'API Java EE est prise en charge, c'est exactement le cas -, il n√©cessite √©galement des impl√©mentations d'API pour fournir une int√©gration transparente des autres API.  L'avantage de cette approche est la possibilit√© d'utiliser les ressources JAX-RS de la conversion JSON-B et de la technologie de validation de bean sans configuration explicite suppl√©mentaire, √† l'exception des annotations.  Dans les exemples pr√©c√©dents, nous avons vu comment les fonctions d√©finies dans les normes individuelles peuvent √™tre utilis√©es ensemble sans effort suppl√©mentaire.  C'est l'un des plus grands avantages de la plate-forme Java EE.  Une sp√©cification g√©n√©rique garantit une combinaison de normes individuelles.  Les programmeurs peuvent compter sur certaines fonctionnalit√©s et impl√©mentations fournies par le serveur d'applications. <br><br><h3>  Code de haute qualit√© facile √† utiliser </h3><br>  Les programmeurs conviennent g√©n√©ralement que vous devez vous efforcer d'√©crire du code de haute qualit√©.  Cependant, toutes les technologies ne sont pas aussi bien adapt√©es √† cela. <br><br>  Comme mentionn√© au d√©but du livre, l'accent sur le d√©veloppement d'applications devrait √™tre la logique m√©tier.  En cas de changement de logique m√©tier ou d'√©mergence de nouvelles connaissances, il est n√©cessaire de mettre √† jour le mod√®le de domaine, ainsi que le code source.  Une refactorisation it√©rative est n√©cessaire pour cr√©er et maintenir un mod√®le de domaine et un code source de haute qualit√© dans leur ensemble.  Les efforts pour approfondir la compr√©hension du sujet sont d√©crits dans le concept de conception orient√©e probl√®me. <br><br>  Il existe de nombreuses publications sur le refactoring au niveau du code.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fois que la logique m√©tier est pr√©sent√©e sous forme de code et v√©rifi√©e par des tests, les programmeurs doivent consacrer du temps et faire des efforts pour repenser et am√©liorer la premi√®re option. Cela s'applique aux identificateurs de noms, de m√©thodes et de classes. Le choix des noms, des niveaux d'abstraction et des points de responsabilit√© communs est particuli√®rement important.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selon la d√©finition de la conception orient√©e probl√®me, le domaine devrait correspondre autant que possible √† sa repr√©sentation sous forme de code. Cela inclut, en particulier, la langue du domaine - en d'autres termes, la fa√ßon dont les programmeurs et les experts commerciaux parlent de certaines fonctions. L'objectif de toute l'√©quipe est de trouver un langage commun universel qui sera efficacement utilis√© non seulement dans les discussions et sur les diapositives de pr√©sentation, mais aussi dans le code. Le perfectionnement des connaissances dans le domaine des affaires se fera de fa√ßon cyclique. Comme la refactorisation au niveau du code, cette approche implique que le mod√®le d'origine ne r√©pondra pas pleinement √† toutes les exigences. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, la technologie appliqu√©e devrait prendre en charge les modifications de mod√®le et de code. S'il y a trop de restrictions, il sera difficile d'apporter des modifications plus tard.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour le d√©veloppement d'applications en g√©n√©ral, et notamment pour le refactoring, il est imp√©ratif que le logiciel soit suffisamment couvert par des tests automatis√©s. Le code √©tant en constante √©volution, les tests de r√©gression garantissent qu'aucune des fonctions m√©tier n'est accidentellement endommag√©e. Ainsi, un nombre suffisant de tests de contr√¥le prend en charge le refactoring, permettant aux ing√©nieurs de comprendre clairement qu'apr√®s avoir apport√© des modifications, toutes les fonctionnalit√©s fonctionnent toujours comme pr√©vu. Id√©alement, la technologie devrait permettre de tester sans imposer de restrictions sur la structure du code. Nous en discuterons plus en d√©tail au chapitre 7.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour permettre le refactoring, une liaison faible est pr√©f√©rable √† une liaison √©troite. La modification d'un composant affecte toutes les fonctions qui l'appellent explicitement et tous les composants dont il a besoin. Java EE prend en charge plusieurs options de liaison faibles: injection de d√©pendances, √©v√©nements et t√¢ches de bout en bout telles que les hooks. Tout cela simplifie les changements de code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe un certain nombre d'outils et de m√©thodes pour mesurer la qualit√©. En particulier, l'analyse de code statique vous permet de collecter des informations sur la complexit√©, la connectivit√©, les d√©pendances entre les classes et les packages, et l'impl√©mentation dans son ensemble. Ces outils aident les ing√©nieurs √† identifier les probl√®mes potentiels et √† cr√©er une vue d'ensemble du projet logiciel. Le chapitre 6 vous montrera comment v√©rifier automatiquement la qualit√© du code.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En g√©n√©ral, il est recommand√© de r√©organiser constamment le code et d'am√©liorer sa qualit√©. Les projets logiciels sont souvent cr√©√©s pour introduire de nouvelles fonctions g√©n√©ratrices de revenus et non pour am√©liorer les fonctionnalit√©s existantes. Le probl√®me est que le refactoring et l'am√©lioration de la qualit√© du code √† premi√®re vue n'apportent pas d'avantages √† l'entreprise. Ce n'est bien s√ªr pas le cas. Afin d'atteindre une vitesse stable et d'int√©grer de nouvelles fonctions avec une qualit√© satisfaisante, il est n√©cessaire de revoir les fonctions existantes. Id√©alement, les boucles de refactorisation doivent √™tre int√©gr√©es dans le diagramme de projet. L'exp√©rience montre que les chefs de projet ignorent souvent ce probl√®me. Cependant, une √©quipe d'ing√©nieurs logiciels est responsable du maintien de la qualit√©.</font></font><br><br><h3>  √Ä propos de l'auteur </h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebastian Daschner</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un pigiste Java qui travaille comme consultant et enseignant, un passionn√© de programmation et Java (EE). Il participe √† JCP, contribue √† la cr√©ation de nouvelles normes Java EE, sert les groupes d'experts 37SR et 374 dans JSR et travaille dans divers projets open source. Pour sa contribution √† la communaut√© et √† l'√©cosyst√®me Java, il a re√ßu le titre de champion du d√©veloppement Java et Oracle.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebastian intervient r√©guli√®rement lors de conf√©rences internationales sur l'informatique telles que JavaLand, JavaOne et Jfokus. </font><font style="vertical-align: inherit;">Il a re√ßu le JavaOne Rockstar Award lors de la conf√©rence JavaOne 2016. Avec le directeur de la communaut√© Java Steve Chin, il a assist√© √† des dizaines de conf√©rences Java et de groupes d'utilisateurs tout en voyageant √† moto. </font><font style="vertical-align: inherit;">Steve et Sebastian ont cr√©√© JOnsen, une non-conf√©rence Java tenue dans une source thermale dans le Japon rural.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ä propos de Reviewer </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melissa McKay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une d√©veloppeur de logiciels avec 15 ans d'exp√©rience dans la cr√©ation de diff√©rents types d'applications pour les clients priv√©s et les entreprises. Maintenant, elle est principalement engag√©e dans les applications Java c√¥t√© serveur qui sont utilis√©es dans le domaine des communications et de la t√©l√©vision. Ses int√©r√™ts incluent les syst√®mes de cluster, elle a une passion particuli√®re pour la r√©solution de probl√®mes associ√©s aux applications parall√®les et multi-thread. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melissa assiste r√©guli√®rement √† la non-conf√©rence JCrete en Cr√®te, en Gr√®ce, et a √©t√© heureuse d'assister √† l'ouverture de la non-conf√©rence JOnsen au Japon. Elle aime participer √† des conf√©rences informatiques b√©n√©voles pour les enfants, telles que JavaOne4Kids et JCrete4Kids. Elle √©tait membre du comit√© de contenu de JavaOne 2017 et est un membre actif du Denver Java User Group.</font></font><br><br>  ¬ªPlus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'√©diteur</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrozhiteley √† 20% de </font><font style="vertical-align: inherit;">r√©duction sur le coupon - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java EE</font></font></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418025/">https://habr.com/ru/post/fr418025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418011/index.html">Pages uniques et r√©f√©rencement. Secrets d'optimisation</a></li>
<li><a href="../fr418013/index.html">Intel Core i7-8086K (partie 3)</a></li>
<li><a href="../fr418015/index.html">Nouveau Vasyuki. D√©veloppement innovant de Moscou jusqu'en 2100</a></li>
<li><a href="../fr418017/index.html">Analyse du comportement du cheval de Troie Pegasus sur le r√©seau</a></li>
<li><a href="../fr418023/index.html">Les pointeurs en C sont plus abstraits que vous ne le pensez</a></li>
<li><a href="../fr418027/index.html">Microservice Blitz</a></li>
<li><a href="../fr418029/index.html">ReactOS 0.4.9: les ennemis devront chercher de nouveaux arguments</a></li>
<li><a href="../fr418031/index.html">Empilement de masse des mod√®les ML en production: r√©el ou non?</a></li>
<li><a href="../fr418035/index.html">Pr√©sentation de Timeline chez Unity</a></li>
<li><a href="../fr418037/index.html">Testeur mobile pr√©parez-vous. Bienvenue dans le Meetup Avito Mobile Testing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>