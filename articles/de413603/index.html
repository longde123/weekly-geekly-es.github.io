<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐚 🚶 🛤️ Codegenerierung in Uber ⭐️ 👩🏿‍🤝‍👨🏽 🔥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jeder von uns erledigt eine Hausarbeit. Jeder schreibt Boilerplate-Code. Warum? Ist es nicht besser, diesen Prozess zu automatisieren und nur an inter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Codegenerierung in Uber</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/413603/">  Jeder von uns erledigt eine Hausarbeit.  Jeder schreibt Boilerplate-Code.  Warum?  Ist es nicht besser, diesen Prozess zu automatisieren und nur an interessanten Aufgaben zu arbeiten?  Lesen Sie diesen Artikel, wenn der Computer solche Arbeiten für Sie ausführen soll. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/144/cb5/052/144cb5052ca1830f2aac609dc3cc93c0.jpg" alt="Bild"></a> <br><br>  <i>Dieser Artikel basiert auf einer Abschrift eines Berichts von Zack Sweers, einem Entwickler von Uber Mobile Apps, der 2017 auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MBLT DEV-</a> Konferenz sprach.</i> <i><br></i> <br><a name="habracut"></a>  Uber hat rund 300 Entwickler von mobilen Apps.  Ich arbeite in einem Team namens "Mobile Platform".  Die Arbeit meines Teams besteht darin, den Prozess der Entwicklung mobiler Anwendungen so weit wie möglich zu vereinfachen und zu verbessern.  Wir arbeiten hauptsächlich an internen Frameworks, Bibliotheken, Architekturen usw.  Aufgrund des großen Personals müssen wir Großprojekte durchführen, die unsere Ingenieure in Zukunft benötigen werden.  Es kann morgen sein oder vielleicht nächsten Monat oder sogar ein Jahr. <br><br><h3>  Codegenerierung zur Automatisierung </h3><br>  Ich möchte den Wert des Codegenerierungsprozesses demonstrieren und einige praktische Beispiele betrachten.  Der Prozess selbst sieht ungefähr so ​​aus: <br><br><pre><code class="hljs python">FileSpec.builder(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"Presentation"</span></span>) .addComment(<span class="hljs-string"><span class="hljs-string">"Code generating your way to happiness."</span></span>) .addAnnotation(AnnotationSpec.builder(Author::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addMember</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-class"><span class="hljs-params"><span class="hljs-string">"name"</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-class"><span class="hljs-params"><span class="hljs-string">"%S"</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-class"><span class="hljs-params"><span class="hljs-string">"Zac Sweers"</span></span></span></span><span class="hljs-class"><span class="hljs-params">)</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useSiteTarget</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(FILE)</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Dies ist ein Beispiel für die Verwendung von Kotlin Poet.  Kotlin Poet ist eine Bibliothek mit einer guten API, die Kotlin-Code generiert.  Was sehen wir hier? <br><br><ol><li>  <b>FileSpec.builder</b> erstellt eine Datei mit dem Namen " <b>Präsentation</b> ". </li><li>  <b>.addComment ()</b> - Fügt dem generierten Code einen Kommentar hinzu. </li><li>  <b>.addAnnotation ()</b> - Fügt eine Anmerkung vom Typ <b>Autor hinzu</b> . </li><li>  <b>.addMember ()</b> - fügt eine Variable " <b>name</b> " mit einem Parameter hinzu, in unserem Fall " <b>Zac Sweers</b> ".  <b>% S</b> - Parametertyp. </li><li>  <b>.useSiteTarget ()</b> - Installiert SiteTarget. </li><li>  <b>.build ()</b> - Vervollständigt die Beschreibung des Codes, der generiert wird. </li></ol><br>  Nach der Codegenerierung wird Folgendes erhalten: <br><br><pre> <code class="hljs pgsql">Presentation.kt // Code generating your way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> happiness. @file:Author(<span class="hljs-type"><span class="hljs-type">name</span></span> = "Zac Sweers")</code> </pre> <br>  Das Ergebnis der Codegenerierung ist eine Datei mit dem Namen, dem Kommentar, der Anmerkung und dem Namen des Autors.  Es stellt sich sofort die Frage: "Warum muss ich diesen Code generieren, wenn ich dies in ein paar einfachen Schritten tun kann?"  Ja, Sie haben Recht, aber was ist, wenn ich tausend dieser Dateien mit unterschiedlichen Konfigurationsoptionen benötige?  Was passiert, wenn wir die Werte in diesem Code ändern?  Was ist, wenn wir viele Präsentationen haben?  Was ist, wenn wir viele Konferenzen haben? <br><br><pre> <code class="hljs pgsql">conferences .flatMap { it.presentations } .onEach { (presentationName, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, author) -&gt; FileSpec.builder("", presentationName) .addComment(<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>) .addAnnotation(AnnotationSpec.builder(Author::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>) .addMember("name", "%S", author) .useSiteTarget(FILE) .build()) .build() }</code> </pre><br>  Infolgedessen werden wir zu dem Schluss kommen, dass es einfach unmöglich ist, eine solche Anzahl von Dateien manuell zu verwalten - es ist notwendig, zu automatisieren.  Daher besteht der erste Vorteil der Codegenerierung darin, Routinearbeiten zu vermeiden. <br><br><h3>  Fehlerfreie Codegenerierung </h3><br>  Der zweite wichtige Vorteil der Automatisierung ist der fehlerfreie Betrieb.  Alle Menschen machen Fehler.  Dies passiert besonders oft, wenn wir dasselbe tun.  Computer hingegen machen einen solchen Job perfekt. <br><br>  Betrachten Sie ein einfaches Beispiel.  Es gibt eine Personenklasse: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String)</code> </pre><br>  Angenommen, wir möchten die Serialisierung in JSON hinzufügen.  Wir werden dies mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Moshi-</b></a> Bibliothek tun, da diese recht einfach ist und sich hervorragend zur Demonstration eignet.  Erstellen Sie einen PersonJsonAdapter und erben Sie von JsonAdapter mit einem Parameter vom Typ Person: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { }</code> </pre><br>  Als nächstes implementieren wir die fromJson-Methode.  Es bietet einen Leser zum Lesen von Informationen, die schließlich an Person zurückgegeben werden.  Dann füllen wir die Felder mit dem Vor- und Nachnamen aus und erhalten den neuen Wert Person: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JsonReader</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Person? { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Person(firstName, lastName) } }</code> </pre><br>  Als nächstes betrachten wir die Daten im JSON-Format, überprüfen sie und geben sie in die erforderlichen Felder ein: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JsonReader</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Person? { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (reader.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (reader.nextName()) { <span class="hljs-string"><span class="hljs-string">"firstName"</span></span> -&gt; firstName = reader.nextString() <span class="hljs-string"><span class="hljs-string">"lastName"</span></span> -&gt; lastName = reader.nextString() } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Person(firstName, lastName) } }</code> </pre><br>  Wird das funktionieren?  Ja, aber es gibt eine Nuance: Die Objekte, die wir lesen, müssen in JSON enthalten sein.  Fügen Sie eine weitere Codezeile hinzu, um überschüssige Daten herauszufiltern, die möglicherweise vom Server stammen: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JsonReader</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Person? { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (reader.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (reader.nextName()) { <span class="hljs-string"><span class="hljs-string">"firstName"</span></span> -&gt; firstName = reader.nextString() <span class="hljs-string"><span class="hljs-string">"lastName"</span></span> -&gt; lastName = reader.nextString() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; reader.skipValue() } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Person(firstName, lastName) } }</code> </pre><br>  Zu diesem Zeitpunkt umgehen wir erfolgreich den Bereich des Routinecodes.  In diesem Beispiel nur zwei Wertefelder.  Dieser Code enthält jedoch eine Reihe verschiedener Abschnitte, in denen Sie plötzlich abstürzen können.  Plötzlich haben wir einen Fehler im Code gemacht? <br><br>  Betrachten Sie ein anderes Beispiel: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> country: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vehicle</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> licensePlate: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Restaurant</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> type: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> address: Address) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Payment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardNumber: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> type: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TipAmount</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rating</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numStars: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Correctness</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> confidence: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>)</code> </pre><br>  Wenn Sie mindestens alle 10 Modelle ein Problem haben, bedeutet dies, dass Sie in diesem Bereich definitiv Schwierigkeiten haben werden.  Und dies ist der Fall, wenn die Codegenerierung Ihnen wirklich helfen kann.  Wenn es viele Klassen gibt, können Sie ohne Automatisierung nicht arbeiten, da alle Personen Tippfehler zulassen.  Bei der Codegenerierung werden alle Aufgaben automatisch und fehlerfrei ausgeführt. <br><br>  Die Codegenerierung bietet weitere Vorteile.  Zum Beispiel gibt es Informationen über den Code aus oder sagt Ihnen, wenn etwas schief geht.  Die Codegenerierung ist während der Testphase hilfreich.  Wenn Sie den generierten Code verwenden, können Sie sehen, wie der Arbeitscode wirklich aussehen wird.  Sie können sogar die Codegenerierung während der Tests ausführen, um Ihre Arbeit zu vereinfachen. <br><br>  Fazit: Es lohnt sich, die Codegenerierung als mögliche Lösung in Betracht zu ziehen, um Fehler zu beseitigen. <br><br>  Schauen wir uns nun Software-Tools an, die bei der Codegenerierung helfen. <br><br><h3>  Die Werkzeuge </h3><br><ol><li>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>JavaPoet-</b></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>KotlinPoet-Bibliotheken</b></a> für Java bzw. Kotlin.  Dies sind die Standards für die Codegenerierung. </li><li>  Musterung.  Ein beliebtes Beispiel für Vorlagen für Java ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Apache Velocity</b></a> und für iOS- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Lenker</b></a> . </li><li>  <b>SPI</b> - Service Processor Interface.  Es ist in Java integriert und ermöglicht es Ihnen, eine Schnittstelle zu erstellen, anzuwenden und anschließend in einer JAR zu deklarieren.  Wenn das Programm ausgeführt wird, können Sie alle vorgefertigten Implementierungen der Schnittstelle erhalten. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Compile Testing</b></a> ist eine Bibliothek von Google, die beim Testen der Kompilierung hilft.  In Bezug auf die Codegenerierung bedeutet dies: "Hier ist, was ich erwartet habe, aber hier ist, was ich schließlich bekommen habe."  Die Kompilierung wird im Speicher gestartet, und das System teilt Ihnen mit, ob dieser Vorgang abgeschlossen wurde oder welche Fehler aufgetreten sind.  Wenn die Kompilierung abgeschlossen ist, werden Sie aufgefordert, das Ergebnis mit Ihren Erwartungen zu vergleichen.  Der Vergleich basiert auf kompiliertem Code. Machen Sie sich also keine Gedanken über Codeformatierungen oder andere Dinge. </li></ol><br><h3>  Code-Build-Tools </h3><br>  Es gibt zwei Hauptwerkzeuge zum Erstellen von Code: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Anmerkungsverarbeitung</b></a> - Sie können Anmerkungen in den Code schreiben und das Programm um zusätzliche Informationen bitten.  Der Compiler gibt Informationen aus, noch bevor er mit dem Quellcode fertig ist. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Gradle</b></a> ist ein Anwendungsassemblierungssystem mit vielen Hooks (Hook-Interception von Funktionsaufrufen) in seinem Code-Assembly-Lebenszyklus.  Es ist weit verbreitet in der Android-Entwicklung.  Außerdem können Sie die Codegenerierung auf den Quellcode anwenden, der von der aktuellen Quelle unabhängig ist. </li></ol><br>  Betrachten Sie nun einige Beispiele. <br><br><h3>  Buttermesser </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Butter Knife</b></a> ist eine von Jake Wharton entwickelte Bibliothek.  Er ist eine bekannte Persönlichkeit in der Entwicklergemeinde.  Die Bibliothek ist bei Android-Entwicklern sehr beliebt, da sie dazu beiträgt, die große Menge an Routinearbeit zu vermeiden, mit der fast jeder konfrontiert ist. <br><br>  Normalerweise initialisieren wir die Ansicht folgendermaßen: <br><br><pre> <code class="java hljs">TextView title; ImageView icon; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ title = findViewById(R.id.title); icon = findViewById(R.id.icon); }</code> </pre><br>  Mit Butterknife sieht es so aus: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.title) TextView title; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.icon) ImageView icon; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ ButterKnife.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br>  Und wir können problemlos eine beliebige Anzahl von Ansichten hinzufügen, während die onCreate-Methode den Boilerplate-Code nicht vergrößert: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.title) TextView title; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.text) TextView text; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.icon) ImageView icon; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.button) Button button; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.next) Button next; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.back) Button back; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.open) Button open; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ ButterKnife.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br>  Anstatt diese Bindung jedes Mal manuell durchzuführen, fügen Sie diesen Feldern einfach @ BondView-Anmerkungen sowie Bezeichner (IDs) hinzu, denen sie zugewiesen sind. <br><br>  Das Coole an Butter Knife ist, dass es den Code analysiert und alle ähnlichen Abschnitte für Sie generiert.  Es hat auch eine hervorragende Skalierbarkeit für neue Daten.  Wenn neue Daten angezeigt werden, müssen Sie onCreate daher nicht erneut anwenden oder manuell verfolgen.  Diese Bibliothek eignet sich auch hervorragend zum Löschen von Daten. <br><br>  Wie sieht dieses System von innen aus?  Die Ansicht wird durch Codeerkennung durchsucht, und dieser Prozess wird in der Annotationsverarbeitungsphase ausgeführt. <br><br>  Wir haben dieses Feld: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.title) TextView title;</code> </pre><br>  Nach diesen Daten zu urteilen, werden sie in einer bestimmten FooActivity verwendet: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// FooActivity @BindView(R.id.title) TextView title;</span></span></code> </pre><br>  Sie hat ihre eigene Bedeutung (R.id.title), die als Ziel fungiert.  Bitte beachten Sie, dass dieses Objekt während der Datenverarbeitung innerhalb des Systems zu einem konstanten Wert wird: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// FooActivity @BindView(2131361859) TextView title;</span></span></code> </pre><br>  Es ist in Ordnung.  Darauf sollte Butter Knife sowieso Zugriff haben.  Es gibt eine TextView-Komponente als Typ.  Das Feld selbst heißt Titel.  Wenn wir zum Beispiel aus diesen Daten eine Containerklasse erstellen, erhalten wir ungefähr Folgendes: <br><br><pre> <code class="java hljs">ViewBinding( target = <span class="hljs-string"><span class="hljs-string">"FooActivity"</span></span>, id = <span class="hljs-number"><span class="hljs-number">2131361859</span></span>, name = <span class="hljs-string"><span class="hljs-string">"title"</span></span>, type = <span class="hljs-string"><span class="hljs-string">"field"</span></span>, viewType = TextView.class )</code> </pre><br>  So können alle diese Daten während ihrer Verarbeitung leicht erhalten werden.  Es ist auch sehr ähnlich zu dem, was Butter Knife im System macht. <br><br>  Infolgedessen wird diese Klasse hier generiert: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooActivity_ViewBinding</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unbinder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FooActivity target; <span class="hljs-meta"><span class="hljs-meta">@UiThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooActivity_ViewBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FooActivity target, View source)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target = target; target.title = Utils.findRequiredViewAsType(source, <span class="hljs-number"><span class="hljs-number">2131361859</span></span>, <span class="hljs-comment"><span class="hljs-comment">// R.id.title "field 'title'", TextView.class); } }</span></span></code> </pre><br>  Hier sehen wir, dass all diese Daten zusammengetragen werden.  Als Ergebnis haben wir die ViewBinding-Zielklasse aus der Java-Bibliothek Underscore.  Im Inneren ist dieses System so angeordnet, dass jedes Mal, wenn Sie eine Instanz der Klasse erstellen, die gesamte Bindung an die von Ihnen generierten Informationen (Code) sofort ausgeführt wird.  Und all dies wurde zuvor statisch während der Verarbeitung von Anmerkungen generiert, was bedeutet, dass es technisch korrekt ist. <br><br>  Kehren wir zu unserer Software-Pipeline zurück: <br><br><img src="https://habrastorage.org/webt/t3/d3/jv/t3d3jv5bxgx5q3occc3ldovxfjm.png"><br><br>  Während der Annotationsverarbeitung liest das System diese Annotationen und generiert die ViewBinding-Klasse.  Und dann führen wir während der Bindemethode auf einfache Weise eine identische Suche nach derselben Klasse durch: Wir nehmen ihren Namen und hängen die ViewBinding am Ende an.  Ein Abschnitt mit einer ViewBinding während der Verarbeitung wird im angegebenen Bereich mit JavaPoet überschrieben. <br><br><h3>  Rxbindings </h3><br>  RxBindings allein ist nicht für die Codegenerierung verantwortlich.  Es verarbeitet keine Anmerkungen und ist kein Gradle-Plugin.  Dies ist eine gewöhnliche Bibliothek.  Es bietet statische Fabriken, die auf dem Prinzip der reaktiven Programmierung für die Android-API basieren.  Dies bedeutet, dass beispielsweise, wenn Sie setOnClickListener haben, eine Klickmethode angezeigt wird, die einen Stream von (beobachtbaren) Ereignissen zurückgibt.  Es fungiert als Brücke (Entwurfsmuster). <br><br>  Tatsächlich gibt es in RxBinding jedoch Codegenerierung: <br><br><img src="https://habrastorage.org/webt/ju/ty/bv/jutybv1ayxqhcfrs9l4virsivb8.png"><br><br>  In diesem Verzeichnis namens buildSrc gibt es eine Gradle-Task namens KotlinGenTask.  Dies bedeutet, dass all dies tatsächlich durch Codegenerierung erstellt wird.  RxBinding verfügt über Java-Implementierungen.  Sie hat auch Kotlin-Artefakte, die Erweiterungsfunktionen für alle Zieltypen enthalten.  Und das alles unterliegt sehr streng den Regeln.  Sie können beispielsweise alle Kotlin-Erweiterungsfunktionen generieren und müssen diese nicht einzeln steuern. <br><br>  Wie sieht es wirklich aus? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View view)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewClickObservable(view); }</code> </pre><br>  Hier ist eine völlig klassische RxBinding-Methode.  Beobachtbare Objekte werden hier zurückgegeben.  Die Methode heißt Klicks.  Die Arbeit mit Klickereignissen findet „unter der Haube“ statt.  Wir lassen die zusätzlichen Codefragmente weg, um die Lesbarkeit des Beispiels zu gewährleisten.  In Kotlin sieht es so aus: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;Object&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br>  Diese Erweiterungsfunktion gibt Observable-Objekte zurück.  In der internen Struktur des Programms ruft es direkt die für uns übliche Java-Schnittstelle auf.  In Kotlin müssen Sie dies in Einheitentyp ändern: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br>  Das heißt, in Java sieht es so aus: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View view)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewClickObservable(view); }</code> </pre><br>  Und so ist der Kotlin-Code: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br>  Wir haben eine RxView-Klasse, die diese Methode enthält.  Wir können die entsprechenden Daten im Zielattribut, im Namensattribut durch den Namen der Methode und in dem Typ, den wir erweitern, sowie im Typ des Rückgabewerts ersetzen.  All diese Informationen reichen aus, um diese Methoden zu schreiben: <br><br><pre> <code class="hljs pgsql">BindingMethod( target = "RxView", <span class="hljs-type"><span class="hljs-type">name</span></span> = "clicks", <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, returnType = "Observable&lt;Unit&gt;" )</code> </pre><br>  Jetzt können wir diese Fragmente direkt in den generierten Kotlin-Code innerhalb des Programms einsetzen.  Hier ist das Ergebnis: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br><h3>  Service gen </h3><br>  Wir arbeiten bei Uber an Service Gen.  Wenn Sie in einem Unternehmen arbeiten und sich mit allgemeinen Merkmalen und einer gemeinsamen Softwareschnittstelle sowohl für das Backend als auch für die Client-Seite befassen, ist es unabhängig davon, ob Sie Android-, iOS- oder Webanwendungen entwickeln, nicht sinnvoll, Modelle und Dienste manuell zu erstellen für die Teamarbeit. <br><br>  Wir verwenden die <a href=""><b>AutoValue-</b></a> Bibliothek von Google für Objektmodelle.  Es verarbeitet Anmerkungen, analysiert Daten und generiert einen zweizeiligen Hashcode, die equals () -Methode und andere Implementierungen.  Sie ist auch für die Unterstützung von Erweiterungen verantwortlich. <br><br>  Wir haben ein Objekt vom Typ Rider: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AutoValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Address </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Wir haben Zeilen mit ID, Vorname, Nachname und Adresse.  Um mit dem Netzwerk zu arbeiten, verwenden wir die Bibliotheken Retrofit und OkHttp sowie JSON als Datenformat.  Wir verwenden RxJava auch für die reaktive Programmierung.  So sieht unser generierter API-Service aus: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UberService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/rider"</span></span></span><span class="hljs-meta">)</span></span> Rider getRider() }</code> </pre><br>  Wir können dies alles manuell schreiben, wenn wir dies wünschen.  Und das haben wir lange Zeit getan.  Aber es braucht viel Zeit.  Am Ende kostet es viel Zeit und Geld. <br><br><h3>  Was und wie macht Uber heute? </h3><br>  Die letzte Aufgabe meines Teams ist es, einen Texteditor von Grund auf neu zu erstellen.  Wir haben uns entschieden, keinen Code mehr manuell zu schreiben, der anschließend ins Netzwerk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>gelangt</b></a> , und verwenden daher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Thrift</b></a> .  Es ist so etwas wie eine Programmiersprache und ein Protokoll zugleich.  Uber verwendet Thrift als Sprache für technische Spezifikationen. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> string uuid; <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> string firstName; <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> string lastName; <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">optional</span></span> <span class="hljs-type"><span class="hljs-type">Address</span></span> address; }</code> </pre><br>  In Thrift definieren wir API-Verträge zwischen dem Backend und der Client-Seite und generieren dann einfach den entsprechenden Code.  Wir verwenden die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Thrifty-</b></a> Bibliothek zum Parsen von Daten und JavaPoet zum Generieren von Code.  Am Ende generieren wir Implementierungen mit AutoValue: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AutoValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Address </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Wir erledigen die ganze Arbeit in JSON.  Es gibt eine Erweiterung namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>AutoValue Moshi</b></a> , die mit der statischen jsonAdapter-Methode zu AutoValue-Klassen hinzugefügt werden kann: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AutoValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Address </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> JsonAdapter&lt;Rider&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jsonAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Moshi moshi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoValue_Rider.JsonAdapter(moshi); } }</code> </pre> <br>  Sparsamkeit hilft auch bei der Entwicklung von Dienstleistungen: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">service</span></span> UberService { <span class="hljs-attribute"><span class="hljs-attribute">Rider</span></span> getRider() }</code> </pre><br>  Wir müssen hier auch einige Metadaten hinzufügen, um uns mitzuteilen, welches Endergebnis wir erzielen möchten: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">service</span></span> UberService { <span class="hljs-attribute"><span class="hljs-attribute">Rider</span></span> getRider() (path=<span class="hljs-string"><span class="hljs-string">"/rider"</span></span>) }</code> </pre><br>  Nach der Codegenerierung erhalten wir unseren Service: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UberService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">"/rider"</span></span>) <span class="hljs-function"><span class="hljs-function">Single&lt;Rider&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Dies ist jedoch nur eines der möglichen Ergebnisse.  Ein Modell.  Wie wir aus Erfahrung wissen, hat noch niemand nur ein Modell verwendet.  Wir haben viele Modelle, die Code für unsere Dienste generieren: <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vehicle</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Restaurant</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Payment</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TipAmount</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rating</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// And 6000 more</span></span></code> </pre><br>  Im Moment haben wir ungefähr 5-6 Bewerbungen.  Und sie haben viele Dienste.  Und jeder durchläuft dieselbe Software-Pipeline.  Das alles von Hand zu schreiben wäre verrückt. <br><br>  Bei der Serialisierung in JSON muss der „Adapter“ nicht in Moshi registriert sein. Wenn Sie JSON verwenden, müssen Sie sich nicht in JSON registrieren.  Es ist auch zweifelhaft, Mitarbeitern vorzuschlagen, eine Deserialisierung durchzuführen, indem Code über ein DI-Diagramm neu geschrieben wird. <br><br>  Wir arbeiten jedoch mit Java, sodass wir das Factory-Muster verwenden können, das wir über die <b>Fractory-</b> Bibliothek generieren.  Wir können dies generieren, da wir diese Typen kennen, bevor die Kompilierung stattgefunden hat.  Fractory generiert einen Adapter wie folgt: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelsAdapterFactory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonAdapter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> JsonAdapter&lt;?&gt; create(Type type, Set&lt;? extends Annotation&gt; annotations, Moshi moshi) { Class&lt;?&gt; rawType = Types.getRawType(type); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rawType.isAssignableFrom(Rider.class)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Rider.adapter(moshi); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rawType.isAssignableFrom(City.class)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> City.adapter(moshi); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rawType.isAssignableFrom(Vehicle.class)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vehicle.adapter(moshi); } <span class="hljs-comment"><span class="hljs-comment">// Etc etc return null; } }</span></span></code> </pre><br>  Der generierte Code sieht nicht sehr gut aus.  Wenn es das Auge verletzt, kann es manuell umgeschrieben werden. <br><br>  Hier sehen Sie die zuvor genannten Typen mit den Namen der Dienste.  Das System ermittelt automatisch, welche Adapter ausgewählt und aufgerufen werden sollen.  Aber hier stehen wir vor einem anderen Problem.  Wir haben 6000 dieser Adapter.  Selbst wenn Sie sie innerhalb derselben Vorlage untereinander aufteilen, fällt das Modell „Eats“ oder „Driver“ in das Modell „Rider“ oder befindet sich in seiner Anwendung.  Der Code wird gedehnt.  Ab einem bestimmten Punkt kann es nicht einmal mehr in eine .dex-Datei passen.  Daher müssen Sie die Adapter irgendwie trennen: <br><br><img src="https://habrastorage.org/webt/ds/ul/tg/dsultg8mrgkboye3dvwmfcepdou.png"><br><br>  Letztendlich werden wir den Code im Voraus analysieren und ein funktionierendes Teilprojekt dafür erstellen, wie in Gradle: <br><br><img src="https://habrastorage.org/webt/-4/pj/fz/-4pjfzwuq-cwmdl8lil_cia4-pi.png"><br><br>  In der internen Struktur werden diese Abhängigkeiten zu Gradle-Abhängigkeiten.  Elemente, die die Rider-Anwendung verwenden, hängen jetzt davon ab.  Damit bilden sie die Modelle, die sie brauchen.  Infolgedessen wird unsere Aufgabe gelöst und all dies wird durch das Code-Assemblierungssystem innerhalb des Programms geregelt. <br><br>  Aber hier stehen wir vor einem anderen Problem: Jetzt haben wir eine n-Anzahl von Fabrikmodellen.  Alle von ihnen sind in verschiedene Objekte kompiliert: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RiderModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> GiftCardModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PricingModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> DriverModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> EATSModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaymentsModelFactory</code> </pre><br>  Während der Verarbeitung von Annotationen ist es nicht möglich, nur Annotationen zu externen Abhängigkeiten zu lesen und zusätzliche Codegenerierung nur für diese durchzuführen. <br><br>  Lösung: Wir haben Unterstützung in der Fractory-Bibliothek, die uns auf eine schwierige Weise hilft.  Es ist im Datenbindungsprozess enthalten.  Wir führen Metadaten mit dem Parameter classpath im Java-Archiv für ihre weitere Speicherung ein: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RiderModelFactory // -&gt; <span class="hljs-type"><span class="hljs-type">json</span></span> // -&gt; ridermodelfactory-fractory.bin <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyAppGlobalFactory // Delegates <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> discovered fractories</code> </pre><br>  Gehen Sie jetzt jedes Mal, wenn Sie sie in der Anwendung verwenden müssen, zum Filter des Klassenpfadverzeichnisses mit diesen Dateien und extrahieren Sie sie von dort im JSON-Format, um herauszufinden, welche der Abhängigkeiten verfügbar sind. <br><br><h3>  Wie alles zusammen passt </h3><br><br><img src="https://habrastorage.org/webt/ih/nj/7i/ihnj7i5j631gcjbkgt-8u64h7l8.jpeg"><br><br>  Wir haben eine <b>Sparsamkeit</b> .  Die Daten von dort gehen an <b>Thrifty</b> und werden analysiert.  Sie durchlaufen dann ein Codegenerierungsprogramm, das wir <b>Jenga</b> nennen.  Es werden Dateien im Java-Format erstellt.  All dies geschieht bereits vor der Vorstufe der Verarbeitung oder vor der Kompilierung.  Während des Kompilierungsprozesses werden Anmerkungen verarbeitet.  Es ist an <b>AutoValue,</b> eine Implementierung <b>zu</b> generieren.  Außerdem wird <b>AutoValue Moshi aufgerufen</b> , um JSON-Unterstützung bereitzustellen.  <b>Fractory ist</b> ebenfalls <b>beteiligt</b> .  Alles passiert während des Kompilierungsprozesses.  Dem Prozess geht eine Komponente zum Erstellen des Projekts selbst voraus, die hauptsächlich <b>Gradle-</b> Teilprojekte generiert. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem Sie das vollständige Bild gesehen haben, bemerken Sie die zuvor erwähnten Tools. </font><font style="vertical-align: inherit;">So gibt es beispielsweise Gradle, der Vorlagen erstellt, AutoValue und JavaPoet für die Codegenerierung. </font><font style="vertical-align: inherit;">Alle Werkzeuge sind nicht nur für sich allein nützlich, sondern auch in Kombination miteinander.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachteile der Codegenerierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist notwendig, über Fallstricke zu berichten. </font><font style="vertical-align: inherit;">Das offensichtlichste Minus ist, den Code aufzublähen und die Kontrolle darüber zu verlieren. </font><font style="vertical-align: inherit;">Zum Beispiel nimmt Dolch ungefähr 10% des gesamten Codes in der Anwendung ein. </font><font style="vertical-align: inherit;">Modelle nehmen mit rund 25% einen deutlich größeren Anteil ein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Uber versuchen wir, das Problem zu lösen, indem wir unnötigen Code wegwerfen. </font><font style="vertical-align: inherit;">Wir müssen eine statistische Analyse des Codes durchführen und verstehen, welche Bereiche wirklich an der Arbeit beteiligt sind. </font><font style="vertical-align: inherit;">Wenn wir es herausfinden, können wir einige Transformationen vornehmen und sehen, was passiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir gehen davon aus, dass wir die Anzahl der generierten Modelle um ca. 40% reduzieren können. </font><font style="vertical-align: inherit;">Dies beschleunigt die Installation und den Betrieb von Anwendungen und spart uns Geld.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie sich die Codegenerierung auf die Zeitpläne für die Projektentwicklung auswirkt </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Codegenerierung beschleunigt natürlich die Entwicklung, aber das Timing hängt von den Tools ab, die das Team verwendet. </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise in Gradle arbeiten, tun Sie dies höchstwahrscheinlich in einem gemessenen Tempo. </font><font style="vertical-align: inherit;">Tatsache ist, dass Gradle einmal am Tag Modelle generiert und nicht, wenn der Entwickler dies wünscht.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erfahren Sie mehr über die Entwicklung bei Uber und anderen Top-Unternehmen. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am 28. September startet in Moskau die 5. Internationale Konferenz der mobilen Entwickler </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MBLT DEV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">800 Teilnehmer, Top-Sprecher, Quiz und Rätsel für diejenigen, die an der Entwicklung von Android und iOS interessiert sind. </font><font style="vertical-align: inherit;">Die Organisatoren der Konferenz sind e-Legion und RAEC. </font><font style="vertical-align: inherit;">Sie können Teilnehmer oder Partner von MBLT DEV 2018 </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">auf der Konferenzwebsite werden</font></a><font style="vertical-align: inherit;"> .</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://"><img src="https://habrastorage.org/webt/yr/u2/x0/yru2x0-bqpghfoa6zqfrkyluuhq.jpeg"></a> <br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Video melden </font></font></h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GpMR_Zjnn_Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413603/">https://habr.com/ru/post/de413603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413591/index.html">Industrierobotik - 57 Jahre! Erinnern Sie sich, woher die Zählung kommt</a></li>
<li><a href="../de413593/index.html">Weiter den Meeresboden erobern. Microsoft und sein Unterwasser-Rechenzentrumsprojekt Natick 2</a></li>
<li><a href="../de413597/index.html">"Last Resort" oder warum Database First Design benötigt wird</a></li>
<li><a href="../de413599/index.html">Es gibt S.L.O.N.a in Teilen. ITAM einführen und nicht ersticken</a></li>
<li><a href="../de413601/index.html">Erwärmt das Rechenzentrum von Microsoft das Meer?</a></li>
<li><a href="../de413605/index.html">Fragen Sie Ethan: Was passiert, wenn ein Stern das Sonnensystem passiert?</a></li>
<li><a href="../de413607/index.html">Fintech Digest: Digitale Währungen bedrohen das Finanzsystem der Russischen Föderation nicht. PayPal hat herausgefunden, wie viel Spieler für Spiele ausgeben</a></li>
<li><a href="../de413609/index.html">Impostor-Syndrom: Was ist das und wie kann man es loswerden?</a></li>
<li><a href="../de413611/index.html">Wie CCTV Positive Hack Days angriff: CAMBreaker-Wettbewerb</a></li>
<li><a href="../de413613/index.html">Dieses Raumschiff wird der Sonne näher kommen als alles, was davor war, und wird nicht schmelzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>