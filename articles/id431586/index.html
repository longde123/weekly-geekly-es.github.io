<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•‰ï¸ ğŸ½ ğŸ’ Cara menangani kesalahan pada JVM lebih cepat ğŸŒ ğŸ™ƒ ğŸŒ´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada berbagai cara untuk menangani kesalahan dalam bahasa pemrograman: 


- pengecualian standar untuk banyak bahasa (Java, Scala dan JVM lainnya, pyth...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menangani kesalahan pada JVM lebih cepat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431586/"><p>  Ada berbagai cara untuk menangani kesalahan dalam bahasa pemrograman: </p><br><ul><li>  pengecualian standar untuk banyak bahasa (Java, Scala dan JVM lainnya, python, dan banyak lainnya) </li><li>  kode status atau bendera (Go, bash) </li><li>  berbagai struktur data aljabar, yang nilainya dapat berupa hasil yang berhasil dan deskripsi kesalahan (Scala, haskell dan bahasa fungsional lainnya) </li></ul><br><p>  Pengecualian digunakan sangat luas, di sisi lain mereka sering dikatakan lambat.  Tetapi lawan dari pendekatan fungsional sering menarik kinerja. </p><br><p>  Baru-baru ini, saya telah bekerja dengan Scala, di mana saya dapat menggunakan pengecualian dan berbagai tipe data untuk penanganan kesalahan, jadi saya ingin tahu pendekatan mana yang akan lebih mudah dan lebih cepat. </p><br><p> Kami akan segera membuang penggunaan kode dan bendera, karena pendekatan ini tidak diterima dalam bahasa JVM dan, menurut pendapat saya, terlalu rentan kesalahan (saya minta maaf atas permainan kata-kata).  Karenanya, kami akan membandingkan pengecualian dan berbagai jenis ADT.  Selain itu, ADT dapat dianggap sebagai penggunaan kode kesalahan dalam gaya fungsional. </p><br><p>  <strong>UPDATE</strong> : pengecualian tanpa jejak tumpukan ditambahkan ke perbandingan </p><a name="habracut"></a><br><h3 id="konkursanty">  Kontestan </h3><br><div class="spoiler">  <b class="spoiler_title">Sedikit lebih banyak tentang tipe data aljabar</b> <div class="spoiler_text"><p>  Bagi mereka yang tidak terlalu terbiasa dengan ADT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ADT</a> ) - tipe aljabar terdiri dari beberapa nilai yang mungkin, yang masing-masing dapat menjadi nilai majemuk (struktur, catatan). </p><br><p> Contohnya adalah tipe <code>Option[T] = Some(value: T) | None</code>  <code>Option[T] = Some(value: T) | None</code> , yang digunakan sebagai pengganti nol: nilai dari jenis ini dapat berupa <code>Some(t)</code> jika ada nilai, atau <code>None</code> jika tidak. </p><br><p>  Contoh lain adalah <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> , yang menjelaskan hasil perhitungan yang dapat diselesaikan dengan sukses atau dengan kesalahan. </p><br><p>  Jadi para kontestan kami: </p></div></div><br><ul><li>  Pengecualian lama yang <em>bagus</em> </li><li>  Pengecualian tanpa jejak tumpukan, karena mengisi jejak tumpukan adalah operasi yang sangat lambat </li><li> <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> - pengecualian yang sama, tetapi dalam pembungkus fungsional </li><li> <code>Either[String, T] = Left(error: String) | Right(value: T)</code>  <code>Either[String, T] = Left(error: String) | Right(value: T)</code> - jenis yang berisi hasil atau deskripsi kesalahan </li><li> <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code>  <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code> - jenis dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka Kucing</a> , yang dalam hal kesalahan dapat berisi beberapa pesan tentang kesalahan yang berbeda (tidak cukup <code>List</code> digunakan di sana, tetapi itu tidak masalah) </li></ul><br><p>  <strong>CATATAN</strong> pada dasarnya, pengecualian dibandingkan dengan jejak tumpukan, tanpa dan ATD, tetapi beberapa jenis dipilih, karena Scala tidak memiliki pendekatan tunggal dan menarik untuk membandingkan beberapa. </p><br><p>  Selain pengecualian, string digunakan untuk menggambarkan kesalahan, tetapi dengan keberhasilan yang sama dalam situasi nyata, kelas yang berbeda akan digunakan ( <code>Either[Failure, T]</code> ). </p><br><h3 id="problema">  Masalah </h3><br><p>  Untuk menguji penanganan kesalahan, kami mengambil masalah penguraian dan validasi data: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, isMale: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] }</code> </pre> <br><p>  yaitu  memiliki data mentah <code>Map[String, String]</code> Anda harus mendapatkan <code>Person</code> atau kesalahan jika data tidak valid. </p><br><h4 id="throw">  Lempar </h4><br><p>  Sebuah solusi <em>untuk dahi</em> menggunakan pengecualian (selanjutnya saya hanya akan memberikan fungsi <code>person</code> , Anda dapat melihat kode lengkap di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> ): <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Throwparser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Person</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = string(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age = integer(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"age"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale = boolean(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale) }</code> </pre> <br><p>  di sini <code>string</code> , <code>integer</code> dan <code>boolean</code> memvalidasi keberadaan dan format tipe sederhana dan melakukan konversi. <br>  Secara umum, ini cukup sederhana dan dapat dimengerti. </p><br><h4 id="thrownst-no-stack-trace">  ThrowNST (Tanpa Jejak Jejak) </h4><br><p>  Kode ini sama seperti pada kasus sebelumnya, tetapi pengecualian digunakan tanpa jejak stack jika memungkinkan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ThrowNSTParser.scala</a> </p><br><h4 id="try">  Coba </h4><br><p>  Solusi menangkap pengecualian sebelumnya dan memungkinkan menggabungkan hasil via <code>for</code> (jangan bingung dengan loop dalam bahasa lain): <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TryParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p>  sedikit lebih tidak biasa untuk mata yang rapuh, tetapi karena penggunaan <code>for</code> , ini sangat mirip dengan versi dengan pengecualian, di samping itu, validasi kehadiran bidang dan penguraian jenis yang diinginkan terjadi secara terpisah ( <code>flatMap</code> dapat dibaca di sini saat <code>and then</code> ) </p><br><h4 id="either">  Baik </h4><br><p>  Di sini, tipe <code>Either</code> tersembunyi di belakang alias <code>Result</code> karena jenis kesalahan diperbaiki: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EitherParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p>  Karena standar <code>Either</code> seperti <code>Try</code> membentuk monad di Scala, kode keluar persis sama, perbedaannya di sini adalah bahwa string muncul di sini sebagai kesalahan dan pengecualian minimal digunakan (hanya untuk menangani kesalahan ketika mengurai angka) </p><br><h4 id="validated">  Divalidasi </h4><br><p>  Di sini pustaka Kucing digunakan untuk mendapatkan bukan hal pertama yang terjadi, tetapi sebanyak mungkin (misalnya, jika beberapa bidang tidak valid, hasilnya akan berisi kesalahan parsing untuk semua bidang ini) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ValidatedParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) .ensure(one(<span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>))(_.nonEmpty) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) .andThen(integer) .ensure(one(<span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>))(_ &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Boolean</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) .andThen(boolean) (name, age, isMale).mapN(<span class="hljs-type"><span class="hljs-type">Person</span></span>) }</code> </pre> <br><p>  kode ini sudah kurang mirip dengan versi aslinya dengan pengecualian, tetapi verifikasi pembatasan tambahan tidak diceraikan dari bidang parsing dan kami masih mendapatkan beberapa kesalahan, bukan satu, sepadan! </p><br><h3 id="testirovanie">  Pengujian </h3><br><p>  Untuk pengujian, kumpulan data dihasilkan dengan persentase kesalahan yang berbeda dan diuraikan dalam masing-masing cara. </p><br><p>  Hasil pada semua persentase kesalahan: <br><img src="https://habrastorage.org/webt/hj/la/-8/hjla-8vnb-pa7jgyiwghmhwwhxk.png"></p><br><p>  Secara lebih rinci, dengan persentase kesalahan yang rendah (waktunya berbeda di sini karena sampel yang lebih besar digunakan): <br><img src="https://habrastorage.org/webt/4s/8r/ca/4s8rcaqkm4gke5o_2fim1dxx9y0.png"></p><br><p>  Jika beberapa bagian dari kesalahan masih merupakan pengecualian dengan jejak tumpukan (dalam kasus kami, kesalahan penguraian nomor akan menjadi pengecualian yang tidak kami kontrol), maka tentu saja kinerja metode penanganan kesalahan "cepat" akan menurun secara signifikan.  <code>Validated</code> sangat terpengaruh, karena mengumpulkan semua kesalahan dan sebagai hasilnya menerima pengecualian lambat lebih dari yang lain: <br><img src="https://habrastorage.org/webt/gy/x-/ve/gyx-veyf2w3kexn4oa56vrbfuvw.png"></p><br><h3 id="vyvody">  Kesimpulan </h3><br><p>  Seperti yang ditunjukkan percobaan, pengecualian dengan jejak tumpukan benar-benar sangat lambat (100% kesalahannya adalah perbedaan antara <code>Throw</code> dan <code>Either</code> lebih dari 50 kali!), Dan ketika hampir tidak ada pengecualian, menggunakan ADT memiliki harga.  Namun, menggunakan pengecualian tanpa jejak tumpukan sama cepat (dan dengan persentase kesalahan yang rendah lebih cepat) seperti ADT, namun, jika pengecualian tersebut melampaui batas validasi yang sama, melacak sumbernya tidak akan mudah. </p><br><p>  Secara total, jika probabilitas pengecualian lebih dari 1%, maka pengecualian tanpa jejak tumpukan bekerja paling cepat, <code>Validated</code> atau reguler. <code>Either</code> hampir sama cepat.  Dengan sejumlah besar kesalahan, <code>Either</code> bisa sedikit lebih cepat daripada <code>Validated</code> hanya karena semantik gagal-cepat. </p><br><p>  Menggunakan ADT untuk penanganan kesalahan memberikan keuntungan lain dari pengecualian: kemungkinan kesalahan ditransfer ke dalam tipe itu sendiri dan lebih sulit untuk dilewatkan, seperti ketika menggunakan <code>Option</code> bukan nol. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431586/">https://habr.com/ru/post/id431586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431572/index.html">Cara menulis persyaratan fungsional</a></li>
<li><a href="../id431574/index.html">Antarmuka Neuro hari ini</a></li>
<li><a href="../id431576/index.html">Latar Belakang: Observatorium Luar Angkasa Kepler - besi, komunikasi dengan Bumi, perangkat lunak, dan hasil</a></li>
<li><a href="../id431582/index.html">Sejarah perlindungan data pribadi: bagaimana GDPR terjadi?</a></li>
<li><a href="../id431584/index.html">Ruang dan pengujian: campur, tapi jangan goyang</a></li>
<li><a href="../id431588/index.html">UU Wiraswasta. Informasi untuk dipertimbangkan</a></li>
<li><a href="../id431590/index.html">Modernisasi peternakan angin Inggris yang usang akan meningkatkan pembangkit energi sebesar 171%</a></li>
<li><a href="../id431596/index.html">Pengujian Beban Cadangan & Replikasi Veeam</a></li>
<li><a href="../id431598/index.html">Kami membawa ke mesin virtual QEMU publik ke internet tanpa kartu jaringan dan mencoba menambang</a></li>
<li><a href="../id431600/index.html">Naikkan IDS / NMS: Mikrotik dan Suricata dengan antarmuka web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>