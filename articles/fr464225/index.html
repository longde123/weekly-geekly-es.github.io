<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🎤 📽️ 👃🏻 REST assuré: ce que nous avons appris de cinq ans d'utilisation de l'outil 🕯️ 👩🏼‍🔬 👨‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="REST assuré - DSL pour tester les services REST, qui est intégré aux tests Java. Cette solution est apparue il y a plus de neuf ans et est devenue pop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>REST assuré: ce que nous avons appris de cinq ans d'utilisation de l'outil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/464225/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">REST assuré</a> - DSL pour tester les services REST, qui est intégré aux tests Java.  Cette solution est apparue il y a plus de neuf ans et est devenue populaire en raison de sa simplicité et de sa fonctionnalité pratique. </p><br><p>  Dans DINS, nous avons écrit plus de 17000 tests avec lui et au cours des cinq années d'utilisation, nous avons rencontré de nombreux pièges qui ne peuvent pas être découverts juste après l'importation de la bibliothèque dans le projet: un contexte statique, une confusion dans l'ordre dans lequel les filtres sont appliqués à la requête, des difficultés à structurer le test. </p><br><p>  Cet article concerne ces fonctionnalités implicites de REST Assured.  Ils doivent être pris en compte s'il y a une chance que le nombre de tests dans le projet augmente rapidement - afin que vous n'ayez pas à les réécrire plus tard. </p><br><p><img src="https://habrastorage.org/webt/yr/xi/jp/yrxijpz_m48cyfek2-0czo55bqc.png" alt="image"></p><a name="habracut"></a><br><h3 id="chto-testiruem">  Que testons-nous </h3><br><p>  DINS participe au développement de la plateforme UCaaS.  En particulier, nous développons et testons l'API que RingCentral utilise elle-même et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fournit aux développeurs tiers</a> . </p><br><p>  Lors du développement d'une API, il est important de s'assurer qu'elle fonctionne correctement, mais lorsque vous la distribuez, vous devez vérifier beaucoup plus de cas.  Par conséquent, des dizaines et des centaines de tests sont ajoutés à chaque nouveau point de terminaison.  Les tests sont écrits en Java, TestNG est sélectionné comme cadre de test et REST Assured est utilisé pour les demandes d'API. </p><br><h3 id="kogda-rest-assured-prineset-polzu">  Quand REST Assured en bénéficiera </h3><br><p>  Si votre objectif n'est pas de tester minutieusement l'intégralité de l'API, la manière la plus simple de le faire est d'utiliser REST Assured.  Il est bien adapté pour vérifier la structure de réponse, le PVD et les tests de fumée. </p><br><p>  Voici à quoi ressemble un test simple, qui vérifiera que le point de terminaison donne le statut 200 OK lors de l'accès: </p><br><pre><code class="java hljs">given() .baseUri(<span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>) .when() .get(<span class="hljs-string"><span class="hljs-string">"/cookies"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>);</code> </pre> <br><p>  Les mots-clés <code>given</code> , <code>when</code> et <code>then</code> forment la demande: <code>given</code> détermine ce qui sera envoyé dans la demande, <code>when</code> –– avec quelle méthode et à quel noeud final nous envoyons la demande, <code>then</code> –– comment la réponse reçue est vérifiée.  De plus, vous pouvez extraire le corps de la réponse sous la forme d'un objet de type <code>JsonPath</code> ou <code>XmlPath</code> , puis utiliser les données reçues. </p><br><p>  Les vrais tests sont généralement plus gros et plus compliqués.  Des en-têtes, cookies, autorisation, corps de requête sont ajoutés aux requêtes.  Et si l'API testée ne se compose pas de dizaines de ressources uniques, chacune nécessitant des paramètres spéciaux, vous souhaiterez stocker des modèles prêts à l'emploi quelque part pour les ajouter plus tard à un appel spécifique du test. </p><br><p>  Pour cela, dans REST Assured il y a: </p><br><ul><li>  <code>RequestSpecification</code> / <code>ResponseSpecification</code> ; </li><li>  configuration de base; </li><li>  filtres. </li></ul><br><h3 id="requestspecification-i-responsespecification">  RequestSpecification et ResponseSpecification </h3><br><p>  Ces deux classes vous permettent de déterminer les paramètres de demande et les attentes de la réponse: </p><br><pre> <code class="java hljs">RequestSpecification requestSpec = given() .baseUri(<span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>) .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>); requestSpec.when() .get(<span class="hljs-string"><span class="hljs-string">"/cookiesformonster"</span></span>) .then() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>); requestSpec.when() .get(<span class="hljs-string"><span class="hljs-string">"/soup"</span></span>) .then() .statusCode(<span class="hljs-number"><span class="hljs-number">400</span></span>);</code> </pre> <br><pre> <code class="java hljs">ResponseSpecification responseSpec = expect() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>); given() .expect() .spec(responseSpec) .when() .get(<span class="hljs-string"><span class="hljs-string">"/hello"</span></span>); given() .expect() .spec(responseSpec) .when() .get(<span class="hljs-string"><span class="hljs-string">"/goodbye"</span></span>);</code> </pre> <br><p>  Une spécification est utilisée dans plusieurs appels, tests et classes de test, selon l'endroit où elle est définie - il n'y a aucune restriction.  Vous pouvez même ajouter plusieurs spécifications à une seule demande.  Cependant, c'est une <strong>source</strong> potentielle <strong>de problèmes</strong> : </p><br><pre> <code class="java hljs">RequestSpecification requestSpec = given() .baseUri(<span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>) .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>); RequestSpecification yetAnotherRequestSpec = given() .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"fr"</span></span>); given() .spec(requestSpec) .spec(yetAnotherRequestSpec) .when() .get(<span class="hljs-string"><span class="hljs-string">"/cookies"</span></span>) .then() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>);</code> </pre> <br><p>  Journal des appels: </p><br><pre> <code class="plaintext hljs">Request method: GET Request URI: http://localhost:8080/ Headers: Language=en Language=fr Accept=*/* Cookies: &lt;none&gt; Multiparts: &lt;none&gt; Body: &lt;none&gt; java.net.ConnectException: Connection refused (Connection refused)</code> </pre> <br><p>  Il s'est avéré que tous les en-têtes ont été ajoutés à l'appel, mais l'URI est soudainement devenu localhost - bien qu'il ait été ajouté dans la première spécification. </p><br><p>  Cela est dû au fait que REST Assured gère les remplacements pour les paramètres de demande différemment (il en va de même pour la réponse).  Des en-têtes ou des filtres sont ajoutés à la liste, puis appliqués à leur tour.  Il ne peut y avoir qu'un seul URI, donc le dernier est appliqué.  Elle n'était pas spécifiée dans la dernière spécification ajoutée - par conséquent, REST Assured la remplace par la valeur par défaut (localhost). </p><br><p>  <strong>Si vous ajoutez une spécification à la demande, ajoutez-en une</strong> .  Le conseil semble évident, mais lorsque le projet avec des tests se développe, des classes d'assistance et des classes de test de base apparaissent, des méthodes avant apparaissent à l'intérieur.  Il devient difficile de suivre ce qui se passe réellement avec votre demande, surtout si plusieurs personnes écrivent des tests à la fois. </p><br><h3 id="bazovaya-konfiguraciya-rest-assured">  Configuration de base REST assurée </h3><br><p>  Un autre moyen de modèle de requêtes dans REST Assured consiste à configurer la configuration de base et à définir les champs statiques de la classe RestAssured: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BeforeMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureRestAssured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ RestAssured.baseURI = <span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>; RestAssured.requestSpecification = given() .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>); RestAssured.filters(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResponseLoggingFilter()); ... }</code> </pre> <br><p>  Des valeurs seront automatiquement ajoutées à la demande à chaque fois.  La configuration est combinée avec les annotations <code>@BeforeMethod</code> dans TestNG et <code>@BeforeEach</code> dans JUnit - vous pouvez donc être sûr que chaque test que vous exécutez commencera avec les mêmes paramètres. </p><br><p>  Cependant, la <strong>configuration sera une source potentielle de problèmes, car elle est statique</strong> . </p><br><p>  Exemple: avant chaque test, nous prenons un utilisateur de test, obtenons un jeton d'autorisation pour lui, puis l'ajoutons via AuthenticationScheme ou un filtre d'autorisation à la configuration de base.  Tant que les tests s'exécuteront sur un seul thread, tout fonctionnera. <br>  Lorsqu'il y a trop de tests, la décision habituelle de diviser leur exécution en plusieurs threads conduira à réécrire un morceau de code afin que le jeton d'un thread ne tombe pas dans le voisin. </p><br><h3 id="filtry-rest-assured">  Filtres assurés REST </h3><br><p>  Les filtres modifient les demandes avant l'envoi et les réponses avant de vérifier la conformité aux attentes spécifiées.  Exemple d'application - ajout de journalisation ou d'autorisation: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OAuth2Filter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthFilter</span></span></span><span class="hljs-class"> </span></span>{ String accessToken; OAuth2Filter(String accessToken) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.accessToken = accessToken; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FilterableRequestSpecification requestSpec, FilterableResponseSpecification responseSpec, FilterContext ctx)</span></span></span><span class="hljs-function"> </span></span>{ requestSpec.replaceHeader(<span class="hljs-string"><span class="hljs-string">"Authorization"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bearer "</span></span> + accessToken); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx.next(requestSpec, responseSpec); } }</code> </pre> <br><pre> <code class="java hljs">String accessToken = getAccessToken(username, password); OAuth2Filter auth = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OAuth2Filter(accessToken); given() .filter(auth) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResponseLoggingFilter()) ...</code> </pre> <br><p>  Les filtres ajoutés à la demande sont stockés dans <code>LinkedList</code> .  Avant de faire une demande, REST Assured la modifie en parcourant la liste et en appliquant un filtre après l'autre.  Ensuite, la même chose se fait avec la réponse qui est venue. </p><br><p>  <strong>L'ordre des filtres est important</strong> .  Ces deux requêtes mèneront à des journaux différents: le premier indiquera l'en-tête d'autorisation, le second - non.  Dans ce cas, l'en-tête sera ajouté aux deux demandes - juste dans le premier cas, REST Assured ajoutera d'abord l'autorisation avant de s'inscrire, et dans le second - vice versa. </p><br><pre> <code class="java hljs">given() .filter(auth) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()) … given() .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()) .filter(auth)</code> </pre> <br><p>  En plus de la règle habituelle selon laquelle les filtres sont appliqués dans l'ordre dans lequel ils sont ajoutés, il est toujours possible de hiérarchiser votre filtre en implémentant l'interface <code>OrderedFilter</code> .  Il vous permet de définir une priorité numérique spéciale pour le filtre, au-dessus ou en dessous de la valeur par défaut (1000).  Les filtres avec une priorité supérieure seront exécutés plus tôt que d'habitude, avec une priorité inférieure - après eux. </p><br><p>  Bien sûr, ici, vous pouvez être confus et définir accidentellement les deux filtres sur la même priorité, par exemple, à 999. Ensuite, celui qui a été ajouté avant sera appliqué à la demande en premier. </p><br><h3 id="ne-tolko-filtry">  Pas seulement des filtres </h3><br><p>  La procédure d'autorisation via les filtres est indiquée ci-dessus.  Mais en plus de cette méthode dans REST Assured, il y en a une autre, via <code>AuthenticationScheme</code> : </p><br><pre> <code class="java hljs">String accessToken = getAccessToken(username, password); OAuth2Scheme scheme = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OAuth2Scheme(); scheme.setAccessToken(accessToken); RestAssured.authentication = scheme;</code> </pre> <br><p>  Il s'agit d'une méthode obsolète.  Au lieu de cela, vous devez choisir celui illustré ci-dessus.  Il y a deux raisons: </p><br><p>  <strong>Problème de dépendance</strong> </p><br><p>  La documentation de REST Assured <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">indique</a> que pour utiliser Oauth1 ou Oauth2 (en spécifiant un jeton comme paramètre de requête), des autorisations doivent être ajoutées en fonction du scribe.  Cependant, l'importation de la dernière version ne vous aidera pas - vous rencontrerez une erreur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décrite dans l'un des problèmes ouverts</a> .  Vous ne pouvez le résoudre qu'en important l'ancienne version de la bibliothèque, 2.5.3.  Cependant, dans ce cas, vous rencontrerez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un autre problème</a> . </p><br><p>  En général, aucune autre version de Scribe ne fonctionne avec Oauth2 REST Assured version 3.0.3 et supérieure (et la récente version 4.0.0 ne l'a pas corrigé). </p><br><p>  <strong>La journalisation ne fonctionne pas</strong> </p><br><p>  Les filtres sont appliqués aux requêtes dans un ordre spécifique.  Et <code>AuthenticationScheme</code> est appliqué après eux.  Cela signifie qu'il sera difficile de détecter un problème d'autorisation dans le test - il n'est pas promis. </p><br><h3 id="esche-o-sintaksise-rest-assured">  En savoir plus sur la syntaxe REST Assured </h3><br><p>  Un grand nombre de tests signifie généralement qu'ils sont également complexes.  Et si l'API est le principal sujet de test, et que vous devez vérifier non seulement les champs json, mais la logique métier, alors avec REST Assured, le test se transforme en feuille: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldCorrectlyCountAddedCookies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Integer addNumber = <span class="hljs-number"><span class="hljs-number">10</span></span>; JsonPath beforeCookies = given() .when() .get(<span class="hljs-string"><span class="hljs-string">"/latestcookies"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) .extract() .jsonPath(); String beforeId = beforeCookies.getString(<span class="hljs-string"><span class="hljs-string">"id"</span></span>); JsonPath afterCookies = given() .body(String.format(<span class="hljs-string"><span class="hljs-string">"{number: %s}"</span></span>, addNumber)) .when() .put(<span class="hljs-string"><span class="hljs-string">"/cookies"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) .extract() .jsonPath(); Integer afterNumber = afterCookies.getInt(<span class="hljs-string"><span class="hljs-string">"number"</span></span>); String afterId = afterCookies.getString(<span class="hljs-string"><span class="hljs-string">"id"</span></span>); JsonPath history = given() .when() .get(<span class="hljs-string"><span class="hljs-string">"/history"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) .extract() .jsonPath(); assertThat(history.getInt(String.format(<span class="hljs-string"><span class="hljs-string">"records.find{r -&gt; r.id == %s}.number"</span></span>, beforeId))) .isEqualTo(afterNumber - addNumber); assertThat(history.getInt(String.format(<span class="hljs-string"><span class="hljs-string">"records.find{r -&gt; r.id == %s}.number"</span></span>, afterId))) .isEqualTo(afterNumber); }</code> </pre> <br><p>  Ce test vérifie que lorsque nous nourrissons un cookie monstre, nous calculons correctement le nombre de cookies qui lui ont été donnés et l'indiquons dans l'histoire.  Mais à première vue, cela ne peut pas être compris - toutes les demandes se ressemblent et il n'est pas clair où se termine la préparation des données via l'API et où la demande de test est envoyée. </p><br><p>  <code>given()</code> , <code>when()</code> <code>then()</code> REST Assured prend de BDD, comme Spock ou Cucumber.  Cependant, dans les tests complexes, leur signification est perdue, car l'échelle du test devient beaucoup plus grande qu'une demande - il s'agit d'une petite action qui doit être indiquée par une ligne.  Et pour cela, vous pouvez transférer les appels REST Assurés vers des classes auxiliaires: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CookieMonsterHelper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> JsonPath </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCookies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> given() .when() .get(<span class="hljs-string"><span class="hljs-string">"/cookiesformonster"</span></span>) .then() .extract() .jsonPath(); } ... }</code> </pre> <br><p>  Et appelez au test: </p><br><pre> <code class="java hljs">JsonPath response = CookieMonsterHelper.getCookies();</code> </pre> <br><p>  C'est bien quand de telles classes auxiliaires sont universelles de sorte qu'un appel à une méthode peut être incorporé dans un grand nombre de tests - puis ils peuvent être placés dans une bibliothèque distincte en général: tout d'un coup, vous devez appeler la méthode à un moment donné dans un autre projet.  Ce n'est que dans ce cas que vous devrez supprimer toute la vérification de la réponse que Rest Assured peut faire - après tout, des données très différentes peuvent souvent être retournées en réponse à la même demande. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  REST Assured est une bibliothèque de test.  Elle sait faire deux choses: envoyer des demandes et vérifier les réponses.  Si nous essayons de le supprimer des tests et de supprimer toute validation, alors il <strong>se transforme en client HTTP</strong> . </p><br><p>  Si vous devez écrire un grand nombre de tests et continuer à les prendre en charge, demandez-vous si vous avez besoin d'un client HTTP avec une syntaxe encombrante, une configuration statique, une confusion dans l'ordre d'application des filtres et des spécifications et une journalisation qui peut être facilement interrompue?  Il y a peut-être neuf ans, REST Assured était l'outil le plus pratique, mais pendant ce temps, des alternatives sont apparues - Retrofit, Feign, Unirest, etc. - qui n'ont pas de telles fonctionnalités. </p><br><p>  La plupart des problèmes décrits dans l'article se manifestent dans de grands projets.  Si vous devez écrire rapidement quelques tests et les oublier pour toujours, et Retrofit ne l'aime pas, REST Assured est la meilleure option. </p><br><p>  Si vous écrivez déjà des tests à l'aide de REST Assured, il n'est pas nécessaire de se précipiter pour tout réécrire.  S'ils sont stables et rapides, cela passera plus de temps que cela n'apportera des avantages pratiques.  Sinon, REST Assured n'est pas votre principal problème. </p><br><p>  Chaque jour, le nombre de tests écrits en DINS pour l'API RingCentral augmente, et ils utilisent toujours REST Assured.  Le temps qui devra être passé pour basculer vers un autre client HTTP, au moins dans les nouveaux tests, est trop important, et les classes et méthodes d'assistance créées qui configurent la configuration de test résolvent la plupart des problèmes.  Dans ce cas, maintenir l'intégrité du projet avec des tests est plus important que d'utiliser le client le plus beau et le plus à la mode.  REST Assured, malgré ses lacunes, fait son travail principal. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464225/">https://habr.com/ru/post/fr464225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464209/index.html">Gutenberg Editor, comment rendre les éditeurs et les typographes pratiques</a></li>
<li><a href="../fr464217/index.html">Comment visualiser le son sur le web: une sélection de supports thématiques et de conférences vidéo avec théorie et pratique</a></li>
<li><a href="../fr464219/index.html">Boîte à outils Timlid de l'e-mail aux tableaux Kanban</a></li>
<li><a href="../fr464221/index.html">Apprendre à travailler avec une équipe à Saint TeamLead Conf</a></li>
<li><a href="../fr464223/index.html">Développement de la sensibilisation à Saint TeamLead Conf</a></li>
<li><a href="../fr464227/index.html">Comment ils vivent et travaillent à Krasnodar</a></li>
<li><a href="../fr464233/index.html">Chaos Constructions 2019 arrive ...</a></li>
<li><a href="../fr464235/index.html">«Slurm» crée une forte dépendance. Comment transformer une cabale en projet global</a></li>
<li><a href="../fr464237/index.html">Pascal Tanchiki: comment les enfants apprenaient la programmation dans les années 90 et ce qui n'allait pas</a></li>
<li><a href="../fr464245/index.html">Configuration de Out-Of-Memory Killer sous Linux pour PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>