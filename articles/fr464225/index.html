<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüé§ üìΩÔ∏è üëÉüèª REST assur√©: ce que nous avons appris de cinq ans d'utilisation de l'outil üïØÔ∏è üë©üèº‚Äçüî¨ üë®‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="REST assur√© - DSL pour tester les services REST, qui est int√©gr√© aux tests Java. Cette solution est apparue il y a plus de neuf ans et est devenue pop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>REST assur√©: ce que nous avons appris de cinq ans d'utilisation de l'outil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/464225/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">REST assur√©</a> - DSL pour tester les services REST, qui est int√©gr√© aux tests Java.  Cette solution est apparue il y a plus de neuf ans et est devenue populaire en raison de sa simplicit√© et de sa fonctionnalit√© pratique. </p><br><p>  Dans DINS, nous avons √©crit plus de 17000 tests avec lui et au cours des cinq ann√©es d'utilisation, nous avons rencontr√© de nombreux pi√®ges qui ne peuvent pas √™tre d√©couverts juste apr√®s l'importation de la biblioth√®que dans le projet: un contexte statique, une confusion dans l'ordre dans lequel les filtres sont appliqu√©s √† la requ√™te, des difficult√©s √† structurer le test. </p><br><p>  Cet article concerne ces fonctionnalit√©s implicites de REST Assured.  Ils doivent √™tre pris en compte s'il y a une chance que le nombre de tests dans le projet augmente rapidement - afin que vous n'ayez pas √† les r√©√©crire plus tard. </p><br><p><img src="https://habrastorage.org/webt/yr/xi/jp/yrxijpz_m48cyfek2-0czo55bqc.png" alt="image"></p><a name="habracut"></a><br><h3 id="chto-testiruem">  Que testons-nous </h3><br><p>  DINS participe au d√©veloppement de la plateforme UCaaS.  En particulier, nous d√©veloppons et testons l'API que RingCentral utilise elle-m√™me et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fournit aux d√©veloppeurs tiers</a> . </p><br><p>  Lors du d√©veloppement d'une API, il est important de s'assurer qu'elle fonctionne correctement, mais lorsque vous la distribuez, vous devez v√©rifier beaucoup plus de cas.  Par cons√©quent, des dizaines et des centaines de tests sont ajout√©s √† chaque nouveau point de terminaison.  Les tests sont √©crits en Java, TestNG est s√©lectionn√© comme cadre de test et REST Assured est utilis√© pour les demandes d'API. </p><br><h3 id="kogda-rest-assured-prineset-polzu">  Quand REST Assured en b√©n√©ficiera </h3><br><p>  Si votre objectif n'est pas de tester minutieusement l'int√©gralit√© de l'API, la mani√®re la plus simple de le faire est d'utiliser REST Assured.  Il est bien adapt√© pour v√©rifier la structure de r√©ponse, le PVD et les tests de fum√©e. </p><br><p>  Voici √† quoi ressemble un test simple, qui v√©rifiera que le point de terminaison donne le statut 200 OK lors de l'acc√®s: </p><br><pre><code class="java hljs">given() .baseUri(<span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>) .when() .get(<span class="hljs-string"><span class="hljs-string">"/cookies"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>);</code> </pre> <br><p>  Les mots-cl√©s <code>given</code> , <code>when</code> et <code>then</code> forment la demande: <code>given</code> d√©termine ce qui sera envoy√© dans la demande, <code>when</code> ‚Äì‚Äì avec quelle m√©thode et √† quel noeud final nous envoyons la demande, <code>then</code> ‚Äì‚Äì comment la r√©ponse re√ßue est v√©rifi√©e.  De plus, vous pouvez extraire le corps de la r√©ponse sous la forme d'un objet de type <code>JsonPath</code> ou <code>XmlPath</code> , puis utiliser les donn√©es re√ßues. </p><br><p>  Les vrais tests sont g√©n√©ralement plus gros et plus compliqu√©s.  Des en-t√™tes, cookies, autorisation, corps de requ√™te sont ajout√©s aux requ√™tes.  Et si l'API test√©e ne se compose pas de dizaines de ressources uniques, chacune n√©cessitant des param√®tres sp√©ciaux, vous souhaiterez stocker des mod√®les pr√™ts √† l'emploi quelque part pour les ajouter plus tard √† un appel sp√©cifique du test. </p><br><p>  Pour cela, dans REST Assured il y a: </p><br><ul><li>  <code>RequestSpecification</code> / <code>ResponseSpecification</code> ; </li><li>  configuration de base; </li><li>  filtres. </li></ul><br><h3 id="requestspecification-i-responsespecification">  RequestSpecification et ResponseSpecification </h3><br><p>  Ces deux classes vous permettent de d√©terminer les param√®tres de demande et les attentes de la r√©ponse: </p><br><pre> <code class="java hljs">RequestSpecification requestSpec = given() .baseUri(<span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>) .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>); requestSpec.when() .get(<span class="hljs-string"><span class="hljs-string">"/cookiesformonster"</span></span>) .then() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>); requestSpec.when() .get(<span class="hljs-string"><span class="hljs-string">"/soup"</span></span>) .then() .statusCode(<span class="hljs-number"><span class="hljs-number">400</span></span>);</code> </pre> <br><pre> <code class="java hljs">ResponseSpecification responseSpec = expect() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>); given() .expect() .spec(responseSpec) .when() .get(<span class="hljs-string"><span class="hljs-string">"/hello"</span></span>); given() .expect() .spec(responseSpec) .when() .get(<span class="hljs-string"><span class="hljs-string">"/goodbye"</span></span>);</code> </pre> <br><p>  Une sp√©cification est utilis√©e dans plusieurs appels, tests et classes de test, selon l'endroit o√π elle est d√©finie - il n'y a aucune restriction.  Vous pouvez m√™me ajouter plusieurs sp√©cifications √† une seule demande.  Cependant, c'est une <strong>source</strong> potentielle <strong>de probl√®mes</strong> : </p><br><pre> <code class="java hljs">RequestSpecification requestSpec = given() .baseUri(<span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>) .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>); RequestSpecification yetAnotherRequestSpec = given() .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"fr"</span></span>); given() .spec(requestSpec) .spec(yetAnotherRequestSpec) .when() .get(<span class="hljs-string"><span class="hljs-string">"/cookies"</span></span>) .then() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>);</code> </pre> <br><p>  Journal des appels: </p><br><pre> <code class="plaintext hljs">Request method: GET Request URI: http://localhost:8080/ Headers: Language=en Language=fr Accept=*/* Cookies: &lt;none&gt; Multiparts: &lt;none&gt; Body: &lt;none&gt; java.net.ConnectException: Connection refused (Connection refused)</code> </pre> <br><p>  Il s'est av√©r√© que tous les en-t√™tes ont √©t√© ajout√©s √† l'appel, mais l'URI est soudainement devenu localhost - bien qu'il ait √©t√© ajout√© dans la premi√®re sp√©cification. </p><br><p>  Cela est d√ª au fait que REST Assured g√®re les remplacements pour les param√®tres de demande diff√©remment (il en va de m√™me pour la r√©ponse).  Des en-t√™tes ou des filtres sont ajout√©s √† la liste, puis appliqu√©s √† leur tour.  Il ne peut y avoir qu'un seul URI, donc le dernier est appliqu√©.  Elle n'√©tait pas sp√©cifi√©e dans la derni√®re sp√©cification ajout√©e - par cons√©quent, REST Assured la remplace par la valeur par d√©faut (localhost). </p><br><p>  <strong>Si vous ajoutez une sp√©cification √† la demande, ajoutez-en une</strong> .  Le conseil semble √©vident, mais lorsque le projet avec des tests se d√©veloppe, des classes d'assistance et des classes de test de base apparaissent, des m√©thodes avant apparaissent √† l'int√©rieur.  Il devient difficile de suivre ce qui se passe r√©ellement avec votre demande, surtout si plusieurs personnes √©crivent des tests √† la fois. </p><br><h3 id="bazovaya-konfiguraciya-rest-assured">  Configuration de base REST assur√©e </h3><br><p>  Un autre moyen de mod√®le de requ√™tes dans REST Assured consiste √† configurer la configuration de base et √† d√©finir les champs statiques de la classe RestAssured: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BeforeMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureRestAssured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ RestAssured.baseURI = <span class="hljs-string"><span class="hljs-string">"http://cookiemonster.com"</span></span>; RestAssured.requestSpecification = given() .header(<span class="hljs-string"><span class="hljs-string">"Language"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>); RestAssured.filters(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResponseLoggingFilter()); ... }</code> </pre> <br><p>  Des valeurs seront automatiquement ajout√©es √† la demande √† chaque fois.  La configuration est combin√©e avec les annotations <code>@BeforeMethod</code> dans TestNG et <code>@BeforeEach</code> dans JUnit - vous pouvez donc √™tre s√ªr que chaque test que vous ex√©cutez commencera avec les m√™mes param√®tres. </p><br><p>  Cependant, la <strong>configuration sera une source potentielle de probl√®mes, car elle est statique</strong> . </p><br><p>  Exemple: avant chaque test, nous prenons un utilisateur de test, obtenons un jeton d'autorisation pour lui, puis l'ajoutons via AuthenticationScheme ou un filtre d'autorisation √† la configuration de base.  Tant que les tests s'ex√©cuteront sur un seul thread, tout fonctionnera. <br>  Lorsqu'il y a trop de tests, la d√©cision habituelle de diviser leur ex√©cution en plusieurs threads conduira √† r√©√©crire un morceau de code afin que le jeton d'un thread ne tombe pas dans le voisin. </p><br><h3 id="filtry-rest-assured">  Filtres assur√©s REST </h3><br><p>  Les filtres modifient les demandes avant l'envoi et les r√©ponses avant de v√©rifier la conformit√© aux attentes sp√©cifi√©es.  Exemple d'application - ajout de journalisation ou d'autorisation: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OAuth2Filter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthFilter</span></span></span><span class="hljs-class"> </span></span>{ String accessToken; OAuth2Filter(String accessToken) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.accessToken = accessToken; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Response </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FilterableRequestSpecification requestSpec, FilterableResponseSpecification responseSpec, FilterContext ctx)</span></span></span><span class="hljs-function"> </span></span>{ requestSpec.replaceHeader(<span class="hljs-string"><span class="hljs-string">"Authorization"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bearer "</span></span> + accessToken); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx.next(requestSpec, responseSpec); } }</code> </pre> <br><pre> <code class="java hljs">String accessToken = getAccessToken(username, password); OAuth2Filter auth = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OAuth2Filter(accessToken); given() .filter(auth) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResponseLoggingFilter()) ...</code> </pre> <br><p>  Les filtres ajout√©s √† la demande sont stock√©s dans <code>LinkedList</code> .  Avant de faire une demande, REST Assured la modifie en parcourant la liste et en appliquant un filtre apr√®s l'autre.  Ensuite, la m√™me chose se fait avec la r√©ponse qui est venue. </p><br><p>  <strong>L'ordre des filtres est important</strong> .  Ces deux requ√™tes m√®neront √† des journaux diff√©rents: le premier indiquera l'en-t√™te d'autorisation, le second - non.  Dans ce cas, l'en-t√™te sera ajout√© aux deux demandes - juste dans le premier cas, REST Assured ajoutera d'abord l'autorisation avant de s'inscrire, et dans le second - vice versa. </p><br><pre> <code class="java hljs">given() .filter(auth) .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()) ‚Ä¶ given() .filter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()) .filter(auth)</code> </pre> <br><p>  En plus de la r√®gle habituelle selon laquelle les filtres sont appliqu√©s dans l'ordre dans lequel ils sont ajout√©s, il est toujours possible de hi√©rarchiser votre filtre en impl√©mentant l'interface <code>OrderedFilter</code> .  Il vous permet de d√©finir une priorit√© num√©rique sp√©ciale pour le filtre, au-dessus ou en dessous de la valeur par d√©faut (1000).  Les filtres avec une priorit√© sup√©rieure seront ex√©cut√©s plus t√¥t que d'habitude, avec une priorit√© inf√©rieure - apr√®s eux. </p><br><p>  Bien s√ªr, ici, vous pouvez √™tre confus et d√©finir accidentellement les deux filtres sur la m√™me priorit√©, par exemple, √† 999. Ensuite, celui qui a √©t√© ajout√© avant sera appliqu√© √† la demande en premier. </p><br><h3 id="ne-tolko-filtry">  Pas seulement des filtres </h3><br><p>  La proc√©dure d'autorisation via les filtres est indiqu√©e ci-dessus.  Mais en plus de cette m√©thode dans REST Assured, il y en a une autre, via <code>AuthenticationScheme</code> : </p><br><pre> <code class="java hljs">String accessToken = getAccessToken(username, password); OAuth2Scheme scheme = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OAuth2Scheme(); scheme.setAccessToken(accessToken); RestAssured.authentication = scheme;</code> </pre> <br><p>  Il s'agit d'une m√©thode obsol√®te.  Au lieu de cela, vous devez choisir celui illustr√© ci-dessus.  Il y a deux raisons: </p><br><p>  <strong>Probl√®me de d√©pendance</strong> </p><br><p>  La documentation de REST Assured <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">indique</a> que pour utiliser Oauth1 ou Oauth2 (en sp√©cifiant un jeton comme param√®tre de requ√™te), des autorisations doivent √™tre ajout√©es en fonction du scribe.  Cependant, l'importation de la derni√®re version ne vous aidera pas - vous rencontrerez une erreur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©crite dans l'un des probl√®mes ouverts</a> .  Vous ne pouvez le r√©soudre qu'en important l'ancienne version de la biblioth√®que, 2.5.3.  Cependant, dans ce cas, vous rencontrerez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un autre probl√®me</a> . </p><br><p>  En g√©n√©ral, aucune autre version de Scribe ne fonctionne avec Oauth2 REST Assured version 3.0.3 et sup√©rieure (et la r√©cente version 4.0.0 ne l'a pas corrig√©). </p><br><p>  <strong>La journalisation ne fonctionne pas</strong> </p><br><p>  Les filtres sont appliqu√©s aux requ√™tes dans un ordre sp√©cifique.  Et <code>AuthenticationScheme</code> est appliqu√© apr√®s eux.  Cela signifie qu'il sera difficile de d√©tecter un probl√®me d'autorisation dans le test - il n'est pas promis. </p><br><h3 id="esche-o-sintaksise-rest-assured">  En savoir plus sur la syntaxe REST Assured </h3><br><p>  Un grand nombre de tests signifie g√©n√©ralement qu'ils sont √©galement complexes.  Et si l'API est le principal sujet de test, et que vous devez v√©rifier non seulement les champs json, mais la logique m√©tier, alors avec REST Assured, le test se transforme en feuille: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldCorrectlyCountAddedCookies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Integer addNumber = <span class="hljs-number"><span class="hljs-number">10</span></span>; JsonPath beforeCookies = given() .when() .get(<span class="hljs-string"><span class="hljs-string">"/latestcookies"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) .extract() .jsonPath(); String beforeId = beforeCookies.getString(<span class="hljs-string"><span class="hljs-string">"id"</span></span>); JsonPath afterCookies = given() .body(String.format(<span class="hljs-string"><span class="hljs-string">"{number: %s}"</span></span>, addNumber)) .when() .put(<span class="hljs-string"><span class="hljs-string">"/cookies"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) .extract() .jsonPath(); Integer afterNumber = afterCookies.getInt(<span class="hljs-string"><span class="hljs-string">"number"</span></span>); String afterId = afterCookies.getString(<span class="hljs-string"><span class="hljs-string">"id"</span></span>); JsonPath history = given() .when() .get(<span class="hljs-string"><span class="hljs-string">"/history"</span></span>) .then() .assertThat() .statusCode(<span class="hljs-number"><span class="hljs-number">200</span></span>) .extract() .jsonPath(); assertThat(history.getInt(String.format(<span class="hljs-string"><span class="hljs-string">"records.find{r -&gt; r.id == %s}.number"</span></span>, beforeId))) .isEqualTo(afterNumber - addNumber); assertThat(history.getInt(String.format(<span class="hljs-string"><span class="hljs-string">"records.find{r -&gt; r.id == %s}.number"</span></span>, afterId))) .isEqualTo(afterNumber); }</code> </pre> <br><p>  Ce test v√©rifie que lorsque nous nourrissons un cookie monstre, nous calculons correctement le nombre de cookies qui lui ont √©t√© donn√©s et l'indiquons dans l'histoire.  Mais √† premi√®re vue, cela ne peut pas √™tre compris - toutes les demandes se ressemblent et il n'est pas clair o√π se termine la pr√©paration des donn√©es via l'API et o√π la demande de test est envoy√©e. </p><br><p>  <code>given()</code> , <code>when()</code> <code>then()</code> REST Assured prend de BDD, comme Spock ou Cucumber.  Cependant, dans les tests complexes, leur signification est perdue, car l'√©chelle du test devient beaucoup plus grande qu'une demande - il s'agit d'une petite action qui doit √™tre indiqu√©e par une ligne.  Et pour cela, vous pouvez transf√©rer les appels REST Assur√©s vers des classes auxiliaires: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CookieMonsterHelper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> JsonPath </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCookies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> given() .when() .get(<span class="hljs-string"><span class="hljs-string">"/cookiesformonster"</span></span>) .then() .extract() .jsonPath(); } ... }</code> </pre> <br><p>  Et appelez au test: </p><br><pre> <code class="java hljs">JsonPath response = CookieMonsterHelper.getCookies();</code> </pre> <br><p>  C'est bien quand de telles classes auxiliaires sont universelles de sorte qu'un appel √† une m√©thode peut √™tre incorpor√© dans un grand nombre de tests - puis ils peuvent √™tre plac√©s dans une biblioth√®que distincte en g√©n√©ral: tout d'un coup, vous devez appeler la m√©thode √† un moment donn√© dans un autre projet.  Ce n'est que dans ce cas que vous devrez supprimer toute la v√©rification de la r√©ponse que Rest Assured peut faire - apr√®s tout, des donn√©es tr√®s diff√©rentes peuvent souvent √™tre retourn√©es en r√©ponse √† la m√™me demande. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  REST Assured est une biblioth√®que de test.  Elle sait faire deux choses: envoyer des demandes et v√©rifier les r√©ponses.  Si nous essayons de le supprimer des tests et de supprimer toute validation, alors il <strong>se transforme en client HTTP</strong> . </p><br><p>  Si vous devez √©crire un grand nombre de tests et continuer √† les prendre en charge, demandez-vous si vous avez besoin d'un client HTTP avec une syntaxe encombrante, une configuration statique, une confusion dans l'ordre d'application des filtres et des sp√©cifications et une journalisation qui peut √™tre facilement interrompue?  Il y a peut-√™tre neuf ans, REST Assured √©tait l'outil le plus pratique, mais pendant ce temps, des alternatives sont apparues - Retrofit, Feign, Unirest, etc. - qui n'ont pas de telles fonctionnalit√©s. </p><br><p>  La plupart des probl√®mes d√©crits dans l'article se manifestent dans de grands projets.  Si vous devez √©crire rapidement quelques tests et les oublier pour toujours, et Retrofit ne l'aime pas, REST Assured est la meilleure option. </p><br><p>  Si vous √©crivez d√©j√† des tests √† l'aide de REST Assured, il n'est pas n√©cessaire de se pr√©cipiter pour tout r√©√©crire.  S'ils sont stables et rapides, cela passera plus de temps que cela n'apportera des avantages pratiques.  Sinon, REST Assured n'est pas votre principal probl√®me. </p><br><p>  Chaque jour, le nombre de tests √©crits en DINS pour l'API RingCentral augmente, et ils utilisent toujours REST Assured.  Le temps qui devra √™tre pass√© pour basculer vers un autre client HTTP, au moins dans les nouveaux tests, est trop important, et les classes et m√©thodes d'assistance cr√©√©es qui configurent la configuration de test r√©solvent la plupart des probl√®mes.  Dans ce cas, maintenir l'int√©grit√© du projet avec des tests est plus important que d'utiliser le client le plus beau et le plus √† la mode.  REST Assured, malgr√© ses lacunes, fait son travail principal. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464225/">https://habr.com/ru/post/fr464225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464209/index.html">Gutenberg Editor, comment rendre les √©diteurs et les typographes pratiques</a></li>
<li><a href="../fr464217/index.html">Comment visualiser le son sur le web: une s√©lection de supports th√©matiques et de conf√©rences vid√©o avec th√©orie et pratique</a></li>
<li><a href="../fr464219/index.html">Bo√Æte √† outils Timlid de l'e-mail aux tableaux Kanban</a></li>
<li><a href="../fr464221/index.html">Apprendre √† travailler avec une √©quipe √† Saint TeamLead Conf</a></li>
<li><a href="../fr464223/index.html">D√©veloppement de la sensibilisation √† Saint TeamLead Conf</a></li>
<li><a href="../fr464227/index.html">Comment ils vivent et travaillent √† Krasnodar</a></li>
<li><a href="../fr464233/index.html">Chaos Constructions 2019 arrive ...</a></li>
<li><a href="../fr464235/index.html">¬´Slurm¬ª cr√©e une forte d√©pendance. Comment transformer une cabale en projet global</a></li>
<li><a href="../fr464237/index.html">Pascal Tanchiki: comment les enfants apprenaient la programmation dans les ann√©es 90 et ce qui n'allait pas</a></li>
<li><a href="../fr464245/index.html">Configuration de Out-Of-Memory Killer sous Linux pour PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>