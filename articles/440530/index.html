<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤠 🧘🏼 🍇 Más funciones con patrones en C # 8.0 🗺️ 👨‍👦‍👦 🔝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Más recientemente, se lanzó Visual Studio 2019 Preview 2. Y con él, un par de características adicionales de C # 8.0 están listas para que las pruebe....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Más funciones con patrones en C # 8.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/440530/"><p>  Más recientemente, se lanzó Visual Studio 2019 Preview 2. Y con él, un par de características adicionales de C # 8.0 están listas para que las pruebe.  Esto es principalmente una comparación con la muestra, aunque al final tocaré algunas otras noticias y cambios. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Este artículo está en inglés.</a> </p><br><img src="https://habrastorage.org/webt/_p/dm/49/_pdm493ww_lspasjjtw5abi-eoa.jpeg"><a name="habracut"></a><br><br>  Gracias por traducir nuestro MSP, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lev Bulanov</a> . <br><br><h2></h2><p>  Más patrones en más lugares. </p><br><p>  Cuando apareció la coincidencia de patrones en C # 7.0, notamos que se espera un aumento en el número de patrones en más lugares en el futuro.  Esta vez ha llegado!  Estamos agregando lo que llamamos patrones recursivos, así como una forma más compacta de expresiones de <strong>cambio</strong> llamadas (lo has adivinado) expresiones de cambio. </p><br><p>  Para comenzar, aquí hay un ejemplo simple de patrones de C # 7.0: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Point</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; (X, Y) = (x, y); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deconstruct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; (x, y) = (X, Y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>; } }</code> </pre> <br><p></p><h2>  Cambiar expresiones </h2><br><p>  Primero, tenga en cuenta que muchas expresiones de <strong>cambio</strong> , de hecho, no hacen mucho trabajo interesante en los cuerpos de los <strong>casos</strong> .  A menudo, todos ellos simplemente crean un valor, ya sea asignándolo a una variable o devolviéndolo (como se indicó anteriormente).  En todas estas situaciones, el cambio parece estar fuera de lugar.  Esto es similar a una característica del lenguaje de cincuenta años. </p><br><p>  Decidimos que era hora de agregar un formulario de <strong>declaración de cambio</strong> .  Se aplica al siguiente ejemplo: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> }; }</code> </pre> <br><p>  Hay algunas cosas que han cambiado en comparación con las declaraciones de cambio.  Vamos a enumerarlos: </p><br><ul><li>  La palabra clave de <strong>cambio</strong> es "infijo" entre el valor probado y la lista de <strong>{...}</strong> casos.  Esto lo hace más compositivo con otras expresiones, y también más fácil de distinguir visualmente de la declaración de cambio. </li><li>  La palabra clave y el símbolo de caso: han sido reemplazados por la flecha lambda <strong>=&gt;</strong> para abreviar. </li><li>  <strong>El valor predeterminado</strong> para brevedad ha sido reemplazado por el patrón <strong>_</strong> reset. </li><li>  Los cuerpos son expresiones.  El resultado del cuerpo seleccionado se convierte en el resultado de la declaración de cambio. </li></ul><br><p>  Debido a que la expresión debe importar o lanzar una excepción, una expresión de selección que termina sin una coincidencia arrojará una excepción.  El compilador le avisará cuando esto pueda suceder, pero no lo obligará a finalizar todas las instrucciones select con la función catch-all. </p><br><p>  Dado que nuestro método de <strong>visualización</strong> ahora consiste en una única declaración de retorno, podemos simplificarlo para la expresión: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p>  Independientemente de las recomendaciones de formato que se den, deben ser extremadamente claras y concisas.  Brevity le permite formatear el interruptor de forma "tabular", como se describió anteriormente, con patrones y cuerpo en la misma línea, y <strong>=&gt;</strong> alineados uno debajo del otro. </p><br><p>  Por cierto, planeamos permitir el uso de una coma después del último caso de acuerdo con todas las demás "listas separadas por comas entre llaves" en C #, pero esto aún no está permitido en la Vista previa 2. </p><br><h2></h2><p>  Propiedades del patrón </p><br><p>  Hablando de brevedad, los patrones de repente se convierten en los elementos más difíciles de las expresiones de elección.  Hagamos algo al respecto. </p><br><p>  Tenga en cuenta que la expresión select utiliza un patrón de tipo <strong>Punto p</strong> (dos veces), así como <strong>cuándo</strong> agregar condiciones adicionales en el primer <strong>caso</strong> . </p><br><p>  En C # 8.0, agregamos elementos opcionales adicionales al tipo de patrones, lo que permite que el patrón mismo profundice en el valor que se asigna al patrón.  Puede convertirlo en un patrón de propiedad agregando <strong>{...} que</strong> contenga patrones anidados, aplicando valores a las propiedades o campos disponibles.  Esto nos permite reescribir la expresión de cambio de la siguiente manera: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } p =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, Y: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y } p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p>  Ambos casos aún verifican que <strong>o</strong> es <strong>Point</strong> .  En el primer caso, el patrón de la constante <strong>0 se</strong> aplica de <strong>forma</strong> recursiva a las propiedades <strong>X</strong> e <strong>Y de la</strong> variable <strong>p</strong> , verificando si tienen este valor.  Por lo tanto, podemos eliminar la condición <strong>when</strong> en este y otros casos similares. </p><br><p>  En el segundo caso, el patrón <strong>var</strong> se aplica a cada uno de <strong>X</strong> e <strong>Y.</strong>  Recuerde que el patrón <strong>var</strong> en C # 7.0 siempre tiene éxito y simplemente declara una nueva variable para contener el valor.  Entonces <strong>x</strong> e <strong>y</strong> contienen valores int para <strong>pX</strong> y <strong>pY</strong> . </p><br><p>  Nunca usamos <strong>p</strong> y en realidad podemos omitirlo aquí: </p><br><pre> <code class="cs hljs"> Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, Y: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y } =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span></code> </pre> <br><p>  Una cosa sigue siendo la misma para todos los tipos de patrones, incluidos los patrones de propiedad, este es un requisito para que el valor sea distinto de cero.  Esto abre la posibilidad de usar el patrón de propiedades "vacías" <strong>{}</strong> como un patrón compacto "distinto de cero".  Por ejemplo  podríamos reemplazar la alternativa con los siguientes dos casos: </p><br><pre> <code class="cs hljs"> {} =&gt; o.ToString(), <span class="hljs-literal"><span class="hljs-literal">null</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"null"</span></span></code> </pre> <br><p>  <strong>{} Se</strong> ocupa de los objetos restantes distintos de cero, y <strong>nulo</strong> obtiene ceros, por lo que el interruptor es exhaustivo y el compilador no se quejará de los valores faltantes. </p><br><h2></h2><p>  Patrones posicionales </p><br><p>  El patrón de propiedad no acorta el segundo caso de <strong>Punto.</strong>  No necesita preocuparse por esto, puede hacer aún más. </p><br><p>  Tenga en cuenta que la clase <strong>Point</strong> tiene un método <strong>Deconstruct</strong> , el llamado deconstructor.  En C # 7.0, los deconstructores le permiten "deconstruir" un valor cuando se le asigna, para que pueda escribir, por ejemplo: </p><br><pre> <code class="cs hljs">(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) = GetPoint(); <span class="hljs-comment"><span class="hljs-comment">// split up the Point according to its deconstructor</span></span></code> </pre> <br><p>  C # 7.0 no integró la deconstrucción con patrones.  Esto cambia con los patrones posicionales, que son una forma adicional de extender los tipos de patrones en C # 8.0.  Si el tipo coincidente es un tipo de tupla o tiene un deconstructor, podemos usar patrones posicionales como una forma compacta de aplicar patrones recursivos sin tener que nombrar las propiedades: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y) =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p>  Después de hacer coincidir el objeto con <strong>Point</strong> , se aplica el deconstructor y los patrones anidados se aplican a los valores resultantes. </p><br><p>  Los deconstructores no siempre son apropiados.  Deben agregarse solo a aquellos tipos donde está realmente claro cuál de los valores es cuál.  Por ejemplo, para la clase <strong>Point</strong> , puede suponer que el primer valor es <strong>X</strong> y el segundo es <strong>Y</strong> , por lo que la expresión de cambio anterior es clara y fácil de leer. </p><br><h2></h2><p>  Patrones de tuplas </p><br><p>  Un caso especial muy útil de patrones posicionales es su aplicación a las tuplas.  Si la instrucción switch se aplica directamente a la expresión de tupla, incluso permitimos omitir el conjunto adicional de paréntesis, como en <strong>switch (x, y, z) en</strong> lugar de <strong>switch ((x, y, z))</strong> . </p><br><p>  Los patrones de tupla son excelentes para probar múltiples entradas al mismo tiempo.  Aquí hay una implementación simple de la máquina de estado: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey</span></span></span><span class="hljs-function">)</span></span> =&gt; (current, transition) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close) =&gt; Closed, (Closed, Open) =&gt; Opened, (Closed, Lock) when hasKey =&gt; Locked, (Locked, Unlock) when hasKey =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"Invalid transition"</span></span>) };</code> </pre> <br><p>  Por supuesto, podríamos incluir <strong>hasKey</strong> en la tupla en lugar de usar las cláusulas <strong>when</strong> , es cuestión de gustos: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey</span></span></span><span class="hljs-function">)</span></span> =&gt; (current, transition, hasKey) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close, _) =&gt; Closed, (Closed, Open, _) =&gt; Opened, (Closed, Lock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Locked, (Locked, Unlock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"Invalid transition"</span></span>) };</code> </pre> <br><p>  En general, verá que los patrones recursivos y las expresiones de cambio pueden conducir a una lógica de programa más clara y declarativa. </p><br><h2></h2><p>  Otras características de C # 8.0 en la Vista previa 2 </p><br><p>  A pesar de que en VS 2019 Preview 2 las funciones principales para trabajar con patrones son las más importantes, hay varias más pequeñas que, espero, también encuentren útiles e interesantes.  No entraré en detalles, solo daré una breve descripción de cada uno. </p><br><h4></h4><p>  Usando anuncios </p><br><p>  En el <strong>uso de</strong> C # <strong>, los</strong> operadores siempre aumentan el nivel de anidamiento, lo que puede ser muy molesto y de poca legibilidad.  En casos simples, cuando solo necesita borrar el recurso al final del alcance, se utilizan declaraciones de uso.  Las declaraciones de uso son simplemente declaraciones de variables locales con la palabra clave de <strong>uso</strong> delante de ellas, y sus contenidos se colocan al final del bloque actual de instrucciones.  Por lo tanto, en lugar de: </p><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = Parse(args)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } ... } <span class="hljs-comment"><span class="hljs-comment">// options disposed here }</span></span></code> </pre> <br><p>  Solo puedes escribir </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = Parse(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">// options disposed here</span></span></code> </pre> <br><h4></h4><p>  Estructuras de referencia desechables </p><br><p>  Las estructuras de referencia se introdujeron en C # 7.2, y parece que no hay lugar para repetirlas aquí.  Pero aún así, vale la pena señalar algo: tienen algunas limitaciones, como la imposibilidad de implementar interfaces.  Las estructuras de referencia ahora se pueden usar sin implementar la interfaz <strong>IDisposable</strong> , simplemente usando el método <strong>Dispose</strong> en ellas. </p><br><h4></h4><p>  Funciones locales estáticas </p><br><p>  Si desea asegurarse de que su función local no incurra en costos de tiempo de ejecución asociados con la “captura” (referencia) de variables del ámbito, puede declararla como estática.  Luego, el compilador evitará el enlace a todo lo que se declara en las funciones adjuntas, ¡excepto otras funciones locales estáticas! </p><br><h4></h4><p>  Cambios desde la vista previa 1 </p><br><p>  Las funciones principales de Preview 1 eran tipos de referencia anulables y flujos asíncronos.  Ambas funciones han cambiado un poco en la Vista previa 2, por lo que si comenzó a usarlas, es útil saber lo siguiente. </p><br><h4></h4><p>  Tipos de referencia anulables </p><br><p>  Hemos agregado más opciones para administrar advertencias anulables tanto en la fuente (a través de las directivas de <strong>advertencia</strong> <strong>#nullable</strong> y <strong>#pragma</strong> ) como a nivel de proyecto.  También cambiamos la suscripción al archivo del proyecto a <strong>&lt;NullableContextOptions&gt; enable &lt;/ NullableContextOptions&gt;</strong> . </p><br><h4></h4><p>  Hilos asincrónicos </p><br><p>  Cambiamos la forma de la <strong>interfaz IAsyncEnumerable &lt;T&gt; que el</strong> compilador espera.  Esto lleva al hecho de que el compilador no se sincroniza con la interfaz proporcionada en .NET Core 3.0 Preview 1, lo que puede causar algunos problemas.  Sin embargo, .NET Core 3.0 Preview 2 se lanzará pronto y esto devolverá la sincronización. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440530/">https://habr.com/ru/post/440530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440520/index.html">Cómo obtener la certificación de desarrolladores de Google: Especialista en Web móvil</a></li>
<li><a href="../440522/index.html">Experiencia en la implementación de una PBX virtual. Comunicación y software en diferentes canastas.</a></li>
<li><a href="../440524/index.html">Sobreescritura o reductores de nivel 80: la ruta de cambio de mayúsculas a clases</a></li>
<li><a href="../440526/index.html">La ciudad japonesa recurre a la tecnología digital después de una gran nevada</a></li>
<li><a href="../440528/index.html">"Muéstrame tus zapatillas y te diré quién eres": nuevo podcast sobre proyectos de medios temáticos</a></li>
<li><a href="../440534/index.html">Traducción de vocabulario políticamente correcto del inglés al ruso</a></li>
<li><a href="../440536/index.html">Cómo Facebook Project Infer ayuda a encontrar errores en las aplicaciones móviles antes de la implementación</a></li>
<li><a href="../440540/index.html">La capitalización de Reddit alcanzó los $ 3 mil millones después de atraer una inversión de $ 300 millones</a></li>
<li><a href="../440542/index.html">Vuex: uso excesivo de captadores en la aplicación. Error al analizar</a></li>
<li><a href="../440544/index.html">La versión experimental de Blazor 0.8.0 ya está disponible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>