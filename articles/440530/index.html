<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§† üßòüèº üçá M√°s funciones con patrones en C # 8.0 üó∫Ô∏è üë®‚Äçüë¶‚Äçüë¶ üîù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="M√°s recientemente, se lanz√≥ Visual Studio 2019 Preview 2. Y con √©l, un par de caracter√≠sticas adicionales de C # 8.0 est√°n listas para que las pruebe....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√°s funciones con patrones en C # 8.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/440530/"><p>  M√°s recientemente, se lanz√≥ Visual Studio 2019 Preview 2. Y con √©l, un par de caracter√≠sticas adicionales de C # 8.0 est√°n listas para que las pruebe.  Esto es principalmente una comparaci√≥n con la muestra, aunque al final tocar√© algunas otras noticias y cambios. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Este art√≠culo est√° en ingl√©s.</a> </p><br><img src="https://habrastorage.org/webt/_p/dm/49/_pdm493ww_lspasjjtw5abi-eoa.jpeg"><a name="habracut"></a><br><br>  Gracias por traducir nuestro MSP, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lev Bulanov</a> . <br><br><h2></h2><p>  M√°s patrones en m√°s lugares. </p><br><p>  Cuando apareci√≥ la coincidencia de patrones en C # 7.0, notamos que se espera un aumento en el n√∫mero de patrones en m√°s lugares en el futuro.  Esta vez ha llegado!  Estamos agregando lo que llamamos patrones recursivos, as√≠ como una forma m√°s compacta de expresiones de <strong>cambio</strong> llamadas (lo has adivinado) expresiones de cambio. </p><br><p>  Para comenzar, aqu√≠ hay un ejemplo simple de patrones de C # 7.0: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Point</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; (X, Y) = (x, y); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deconstruct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; (x, y) = (X, Y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (o) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"origin"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Point p: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>; } }</code> </pre> <br><p></p><h2>  Cambiar expresiones </h2><br><p>  Primero, tenga en cuenta que muchas expresiones de <strong>cambio</strong> , de hecho, no hacen mucho trabajo interesante en los cuerpos de los <strong>casos</strong> .  A menudo, todos ellos simplemente crean un valor, ya sea asign√°ndolo a una variable o devolvi√©ndolo (como se indic√≥ anteriormente).  En todas estas situaciones, el cambio parece estar fuera de lugar.  Esto es similar a una caracter√≠stica del lenguaje de cincuenta a√±os. </p><br><p>  Decidimos que era hora de agregar un formulario de <strong>declaraci√≥n de cambio</strong> .  Se aplica al siguiente ejemplo: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> }; }</code> </pre> <br><p>  Hay algunas cosas que han cambiado en comparaci√≥n con las declaraciones de cambio.  Vamos a enumerarlos: </p><br><ul><li>  La palabra clave de <strong>cambio</strong> es "infijo" entre el valor probado y la lista de <strong>{...}</strong> casos.  Esto lo hace m√°s compositivo con otras expresiones, y tambi√©n m√°s f√°cil de distinguir visualmente de la declaraci√≥n de cambio. </li><li>  La palabra clave y el s√≠mbolo de caso: han sido reemplazados por la flecha lambda <strong>=&gt;</strong> para abreviar. </li><li>  <strong>El valor predeterminado</strong> para brevedad ha sido reemplazado por el patr√≥n <strong>_</strong> reset. </li><li>  Los cuerpos son expresiones.  El resultado del cuerpo seleccionado se convierte en el resultado de la declaraci√≥n de cambio. </li></ul><br><p>  Debido a que la expresi√≥n debe importar o lanzar una excepci√≥n, una expresi√≥n de selecci√≥n que termina sin una coincidencia arrojar√° una excepci√≥n.  El compilador le avisar√° cuando esto pueda suceder, pero no lo obligar√° a finalizar todas las instrucciones select con la funci√≥n catch-all. </p><br><p>  Dado que nuestro m√©todo de <strong>visualizaci√≥n</strong> ahora consiste en una √∫nica declaraci√≥n de retorno, podemos simplificarlo para la expresi√≥n: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point p when pX == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; pY == <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pX}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{pY}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p>  Independientemente de las recomendaciones de formato que se den, deben ser extremadamente claras y concisas.  Brevity le permite formatear el interruptor de forma "tabular", como se describi√≥ anteriormente, con patrones y cuerpo en la misma l√≠nea, y <strong>=&gt;</strong> alineados uno debajo del otro. </p><br><p>  Por cierto, planeamos permitir el uso de una coma despu√©s del √∫ltimo caso de acuerdo con todas las dem√°s "listas separadas por comas entre llaves" en C #, pero esto a√∫n no est√° permitido en la Vista previa 2. </p><br><h2></h2><p>  Propiedades del patr√≥n </p><br><p>  Hablando de brevedad, los patrones de repente se convierten en los elementos m√°s dif√≠ciles de las expresiones de elecci√≥n.  Hagamos algo al respecto. </p><br><p>  Tenga en cuenta que la expresi√≥n select utiliza un patr√≥n de tipo <strong>Punto p</strong> (dos veces), as√≠ como <strong>cu√°ndo</strong> agregar condiciones adicionales en el primer <strong>caso</strong> . </p><br><p>  En C # 8.0, agregamos elementos opcionales adicionales al tipo de patrones, lo que permite que el patr√≥n mismo profundice en el valor que se asigna al patr√≥n.  Puede convertirlo en un patr√≥n de propiedad agregando <strong>{...} que</strong> contenga patrones anidados, aplicando valores a las propiedades o campos disponibles.  Esto nos permite reescribir la expresi√≥n de cambio de la siguiente manera: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } p =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, Y: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y } p =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p>  Ambos casos a√∫n verifican que <strong>o</strong> es <strong>Point</strong> .  En el primer caso, el patr√≥n de la constante <strong>0 se</strong> aplica de <strong>forma</strong> recursiva a las propiedades <strong>X</strong> e <strong>Y de la</strong> variable <strong>p</strong> , verificando si tienen este valor.  Por lo tanto, podemos eliminar la condici√≥n <strong>when</strong> en este y otros casos similares. </p><br><p>  En el segundo caso, el patr√≥n <strong>var</strong> se aplica a cada uno de <strong>X</strong> e <strong>Y.</strong>  Recuerde que el patr√≥n <strong>var</strong> en C # 7.0 siempre tiene √©xito y simplemente declara una nueva variable para contener el valor.  Entonces <strong>x</strong> e <strong>y</strong> contienen valores int para <strong>pX</strong> y <strong>pY</strong> . </p><br><p>  Nunca usamos <strong>p</strong> y en realidad podemos omitirlo aqu√≠: </p><br><pre> <code class="cs hljs"> Point { X: <span class="hljs-number"><span class="hljs-number">0</span></span>, Y: <span class="hljs-number"><span class="hljs-number">0</span></span> } =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point { X: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, Y: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y } =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span></code> </pre> <br><p>  Una cosa sigue siendo la misma para todos los tipos de patrones, incluidos los patrones de propiedad, este es un requisito para que el valor sea distinto de cero.  Esto abre la posibilidad de usar el patr√≥n de propiedades "vac√≠as" <strong>{}</strong> como un patr√≥n compacto "distinto de cero".  Por ejemplo  podr√≠amos reemplazar la alternativa con los siguientes dos casos: </p><br><pre> <code class="cs hljs"> {} =&gt; o.ToString(), <span class="hljs-literal"><span class="hljs-literal">null</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"null"</span></span></code> </pre> <br><p>  <strong>{} Se</strong> ocupa de los objetos restantes distintos de cero, y <strong>nulo</strong> obtiene ceros, por lo que el interruptor es exhaustivo y el compilador no se quejar√° de los valores faltantes. </p><br><h2></h2><p>  Patrones posicionales </p><br><p>  El patr√≥n de propiedad no acorta el segundo caso de <strong>Punto.</strong>  No necesita preocuparse por esto, puede hacer a√∫n m√°s. </p><br><p>  Tenga en cuenta que la clase <strong>Point</strong> tiene un m√©todo <strong>Deconstruct</strong> , el llamado deconstructor.  En C # 7.0, los deconstructores le permiten "deconstruir" un valor cuando se le asigna, para que pueda escribir, por ejemplo: </p><br><pre> <code class="cs hljs">(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) = GetPoint(); <span class="hljs-comment"><span class="hljs-comment">// split up the Point according to its deconstructor</span></span></code> </pre> <br><p>  C # 7.0 no integr√≥ la deconstrucci√≥n con patrones.  Esto cambia con los patrones posicionales, que son una forma adicional de extender los tipos de patrones en C # 8.0.  Si el tipo coincidente es un tipo de tupla o tiene un deconstructor, podemos usar patrones posicionales como una forma compacta de aplicar patrones recursivos sin tener que nombrar las propiedades: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Display</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> =&gt; o <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Point(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) =&gt; <span class="hljs-string"><span class="hljs-string">"origin"</span></span>, Point(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y) =&gt; <span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"unknown"</span></span> };</code> </pre> <br><p>  Despu√©s de hacer coincidir el objeto con <strong>Point</strong> , se aplica el deconstructor y los patrones anidados se aplican a los valores resultantes. </p><br><p>  Los deconstructores no siempre son apropiados.  Deben agregarse solo a aquellos tipos donde est√° realmente claro cu√°l de los valores es cu√°l.  Por ejemplo, para la clase <strong>Point</strong> , puede suponer que el primer valor es <strong>X</strong> y el segundo es <strong>Y</strong> , por lo que la expresi√≥n de cambio anterior es clara y f√°cil de leer. </p><br><h2></h2><p>  Patrones de tuplas </p><br><p>  Un caso especial muy √∫til de patrones posicionales es su aplicaci√≥n a las tuplas.  Si la instrucci√≥n switch se aplica directamente a la expresi√≥n de tupla, incluso permitimos omitir el conjunto adicional de par√©ntesis, como en <strong>switch (x, y, z) en</strong> lugar de <strong>switch ((x, y, z))</strong> . </p><br><p>  Los patrones de tupla son excelentes para probar m√∫ltiples entradas al mismo tiempo.  Aqu√≠ hay una implementaci√≥n simple de la m√°quina de estado: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey</span></span></span><span class="hljs-function">)</span></span> =&gt; (current, transition) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close) =&gt; Closed, (Closed, Open) =&gt; Opened, (Closed, Lock) when hasKey =&gt; Locked, (Locked, Unlock) when hasKey =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"Invalid transition"</span></span>) };</code> </pre> <br><p>  Por supuesto, podr√≠amos incluir <strong>hasKey</strong> en la tupla en lugar de usar las cl√°usulas <strong>when</strong> , es cuesti√≥n de gustos: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">State current, Transition transition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasKey</span></span></span><span class="hljs-function">)</span></span> =&gt; (current, transition, hasKey) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { (Opened, Close, _) =&gt; Closed, (Closed, Open, _) =&gt; Opened, (Closed, Lock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Locked, (Locked, Unlock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) =&gt; Closed, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"Invalid transition"</span></span>) };</code> </pre> <br><p>  En general, ver√° que los patrones recursivos y las expresiones de cambio pueden conducir a una l√≥gica de programa m√°s clara y declarativa. </p><br><h2></h2><p>  Otras caracter√≠sticas de C # 8.0 en la Vista previa 2 </p><br><p>  A pesar de que en VS 2019 Preview 2 las funciones principales para trabajar con patrones son las m√°s importantes, hay varias m√°s peque√±as que, espero, tambi√©n encuentren √∫tiles e interesantes.  No entrar√© en detalles, solo dar√© una breve descripci√≥n de cada uno. </p><br><h4></h4><p>  Usando anuncios </p><br><p>  En el <strong>uso de</strong> C # <strong>, los</strong> operadores siempre aumentan el nivel de anidamiento, lo que puede ser muy molesto y de poca legibilidad.  En casos simples, cuando solo necesita borrar el recurso al final del alcance, se utilizan declaraciones de uso.  Las declaraciones de uso son simplemente declaraciones de variables locales con la palabra clave de <strong>uso</strong> delante de ellas, y sus contenidos se colocan al final del bloque actual de instrucciones.  Por lo tanto, en lugar de: </p><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = Parse(args)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } ... } <span class="hljs-comment"><span class="hljs-comment">// options disposed here }</span></span></code> </pre> <br><p>  Solo puedes escribir </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = Parse(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (options[<span class="hljs-string"><span class="hljs-string">"verbose"</span></span>]) { WriteLine(<span class="hljs-string"><span class="hljs-string">"Logging..."</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">// options disposed here</span></span></code> </pre> <br><h4></h4><p>  Estructuras de referencia desechables </p><br><p>  Las estructuras de referencia se introdujeron en C # 7.2, y parece que no hay lugar para repetirlas aqu√≠.  Pero a√∫n as√≠, vale la pena se√±alar algo: tienen algunas limitaciones, como la imposibilidad de implementar interfaces.  Las estructuras de referencia ahora se pueden usar sin implementar la interfaz <strong>IDisposable</strong> , simplemente usando el m√©todo <strong>Dispose</strong> en ellas. </p><br><h4></h4><p>  Funciones locales est√°ticas </p><br><p>  Si desea asegurarse de que su funci√≥n local no incurra en costos de tiempo de ejecuci√≥n asociados con la ‚Äúcaptura‚Äù (referencia) de variables del √°mbito, puede declararla como est√°tica.  Luego, el compilador evitar√° el enlace a todo lo que se declara en las funciones adjuntas, ¬°excepto otras funciones locales est√°ticas! </p><br><h4></h4><p>  Cambios desde la vista previa 1 </p><br><p>  Las funciones principales de Preview 1 eran tipos de referencia anulables y flujos as√≠ncronos.  Ambas funciones han cambiado un poco en la Vista previa 2, por lo que si comenz√≥ a usarlas, es √∫til saber lo siguiente. </p><br><h4></h4><p>  Tipos de referencia anulables </p><br><p>  Hemos agregado m√°s opciones para administrar advertencias anulables tanto en la fuente (a trav√©s de las directivas de <strong>advertencia</strong> <strong>#nullable</strong> y <strong>#pragma</strong> ) como a nivel de proyecto.  Tambi√©n cambiamos la suscripci√≥n al archivo del proyecto a <strong>&lt;NullableContextOptions&gt; enable &lt;/ NullableContextOptions&gt;</strong> . </p><br><h4></h4><p>  Hilos asincr√≥nicos </p><br><p>  Cambiamos la forma de la <strong>interfaz IAsyncEnumerable &lt;T&gt; que el</strong> compilador espera.  Esto lleva al hecho de que el compilador no se sincroniza con la interfaz proporcionada en .NET Core 3.0 Preview 1, lo que puede causar algunos problemas.  Sin embargo, .NET Core 3.0 Preview 2 se lanzar√° pronto y esto devolver√° la sincronizaci√≥n. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440530/">https://habr.com/ru/post/440530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440520/index.html">C√≥mo obtener la certificaci√≥n de desarrolladores de Google: Especialista en Web m√≥vil</a></li>
<li><a href="../440522/index.html">Experiencia en la implementaci√≥n de una PBX virtual. Comunicaci√≥n y software en diferentes canastas.</a></li>
<li><a href="../440524/index.html">Sobreescritura o reductores de nivel 80: la ruta de cambio de may√∫sculas a clases</a></li>
<li><a href="../440526/index.html">La ciudad japonesa recurre a la tecnolog√≠a digital despu√©s de una gran nevada</a></li>
<li><a href="../440528/index.html">"Mu√©strame tus zapatillas y te dir√© qui√©n eres": nuevo podcast sobre proyectos de medios tem√°ticos</a></li>
<li><a href="../440534/index.html">Traducci√≥n de vocabulario pol√≠ticamente correcto del ingl√©s al ruso</a></li>
<li><a href="../440536/index.html">C√≥mo Facebook Project Infer ayuda a encontrar errores en las aplicaciones m√≥viles antes de la implementaci√≥n</a></li>
<li><a href="../440540/index.html">La capitalizaci√≥n de Reddit alcanz√≥ los $ 3 mil millones despu√©s de atraer una inversi√≥n de $ 300 millones</a></li>
<li><a href="../440542/index.html">Vuex: uso excesivo de captadores en la aplicaci√≥n. Error al analizar</a></li>
<li><a href="../440544/index.html">La versi√≥n experimental de Blazor 0.8.0 ya est√° disponible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>