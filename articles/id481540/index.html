<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🔧 ⚖️ 👨🏿‍💼 Memuat ulang tekstur OpenGLESv2 melalui DMABUF 👓 👬 🐀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini saya ingin berbicara tentang betapa mudahnya memperbarui tekstur OpenGLES melalui DMABUF. Saya mencari di Habr dan, yang mengejutkan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memuat ulang tekstur OpenGLESv2 melalui DMABUF</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481540/"><iframe width="560" height="315" src="https://www.youtube.com/embed/Cz2cywrC1ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Pada artikel ini saya ingin berbicara tentang betapa mudahnya memperbarui tekstur OpenGLES melalui DMABUF.  Saya mencari di Habr dan, yang mengejutkan saya, tidak menemukan satu artikel pun tentang topik ini.  Dalam Habr, T&amp;J juga tidak menemukan ini.  Dan ini agak aneh bagi saya.  Teknologi ini muncul beberapa waktu yang lalu, meskipun sebenarnya tidak banyak informasi tentang itu di jaringan, semua itu tidak jelas dan kontradiktif. <br><br>  Saya mengumpulkan semua informasi ini sedikit demi sedikit dari sumber yang berbeda sebelum saya dapat menulis pemutar video seperti pada demo di atas.  Di sini, pada sebuah demo, pemutar video buatan saya berdasarkan pustaka gstreamer memuat bingkai video ke dalam tekstur OpenGLESv2 setiap kali sebelum rendering.  Didukung oleh Raspberry Pi4.  Frame hanya disalin ke memori yang dialokasikan khusus - dan DMA mentransfernya ke memori GPU, ke tekstur.  Selanjutnya, saya akan memberi tahu Anda bagaimana saya melakukannya. <br><a name="habracut"></a><br>  Biasanya, seorang programmer yang menggunakan OpenGLESv2 menciptakan tekstur hanya sekali dan kemudian membuatnya menjadi objek adegan.  Ini terjadi, karena kostum karakter jarang berubah dan terkadang memuat ulang tekstur dengan glTexSubImage2D () tidak sulit.  Namun, masalah sebenarnya dimulai ketika teksturnya dinamis, ketika Anda perlu memperbarui hampir setiap frame selama rendering.  Fungsi glTexSubImage2D () sangat lambat.  Nah, seberapa lambat - tentu saja, semua itu tergantung pada komputer dan kartu grafis.  Saya ingin menemukan solusi yang berfungsi bahkan pada kartu papan tunggal yang lemah seperti Raspberry. <br><br>  Arsitektur banyak komputer modern, termasuk SoC single-board, sedemikian rupa sehingga memori prosesor terpisah dari memori GPU.  Biasanya, program pengguna tidak memiliki akses langsung ke memori GPU dan Anda perlu menggunakan berbagai fungsi API seperti glTexSubImage2D () yang sama.  Selain itu, saya membaca di suatu tempat bahwa representasi internal tekstur mungkin berbeda dari representasi tradisional gambar sebagai urutan piksel.  Saya tidak tahu seberapa benar ini.  Mungkin <br><br>  Jadi apa yang diberikan teknologi DMABUF kepada saya?  Memori dialokasikan secara khusus dan sebuah proses dari utas apa saja dapat menulis piksel di sana kapan pun diinginkan.  DMA sendiri akan mentransfer semua perubahan pada tekstur di memori GPU.  Bukankah itu cantik? <br><br>  Saya harus segera mengatakan bahwa saya tahu tentang PBO - Pixel Buffer Object, biasanya dengan bantuan PBO, pembaruan tekstur dinamis dilakukan, DMA tampaknya juga digunakan di sana, tetapi PBO hanya muncul di OpenGLESv3 dan tidak di semua implementasi.  Jadi tidak - sayangnya, ini bukan cara saya. <br><br>  Artikel ini mungkin menarik bagi programmer Raspberry dan pengembang game, dan mungkin bahkan programmer Android, karena OpenGLES juga digunakan di sana dan saya yakin bahwa teknologi DMABUF ini juga ada di sana (setidaknya saya yakin Anda dapat menggunakannya dari Android NDK). <br><br>  Saya akan menulis sebuah program menggunakan DMABUF pada Raspberry Pi4.  Program ini juga harus (dan akan) bekerja pada komputer Intel x86 / x86_64 biasa, katakan di bawah ubuntu. <br><br>  Pada artikel ini, saya berasumsi bahwa Anda sudah tahu cara memprogram grafik dengan OpenGLESv2 API.  Meskipun, tidak akan banyak tantangan ini.  Sebagian besar kita akan memiliki sihir ioctl. <br><br>  Jadi, hal pertama yang harus dilakukan adalah memastikan bahwa API yang tersedia di platform harus mendukung DMABUF.  Untuk melakukan ini, periksa daftar ekstensi EGL: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* EglExtString = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)eglQueryString( esContext-&gt;eglDisplay, EGL_EXTENSIONS ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>( EglExtString, <span class="hljs-string"><span class="hljs-string">"EGL_EXT_image_dma_buf_import"</span></span>) ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF feature must be supported!!!\n"</span></span>; }</code> </pre> <br>  Jadi kita akan segera mengerti jika ada harapan untuk menggunakan DMABUF atau jika tidak ada harapan.  Misalnya, di Raspberry Pi3 dan semua papan sebelumnya tidak ada harapan.  Di sana, secara umum, bahkan OpenGLESv2 entah bagaimana dilucuti, melalui perpustakaan khusus dengan bros BRCM.  Dan sekarang di Raspberry Pi4 ada OpenGLES nyata, ekstensi EGL_EXT_image_dma_buf_import adalah, hore. <br><br>  Saya akan segera mencatat OS apa yang saya miliki pada Pi4 papan tunggal, jika tidak, mungkin ada masalah dengan ini: <br><br><pre> <code class="plaintext hljs">pi@raspberrypi:~ $ lsb_release -a No LSB modules are available. Distributor ID: Raspbian Description: Raspbian GNU/Linux 10 (buster) Release: 10 Codename: buster pi@raspberrypi:~ $ uname -a Linux raspberrypi 4.19.75-v7l+ #1270 SMP Tue Sep 24 18:51:41 BST 2019 armv7l GNU/Linux</code> </pre><br>  Saya juga mencatat bahwa ekstensi EGL_EXT_image_dma_buf_import ada di Orange Pi PC (Mali-400) / PC2 (Mali-450), kecuali tentu saja Anda dapat menjalankan GPU Mali di papan ini (di majelis resmi tidak ada di sana, saya menginstalnya di Armbian, ditambah saya melakukannya sendiri di Armbian, plus saya melakukannya sendiri rakitan driver kernel).  Artinya, DMABUF hampir di mana-mana.  Hanya perlu untuk mengambil dan menggunakan. <br><br>  Selanjutnya, Anda perlu membuka file / dev / dri / card0 atau / dev / dri / card1 - salah satunya, itu tergantung pada platform, itu terjadi secara berbeda, Anda perlu mencari file yang mendukung DRM_CAP_DUMB_BUFFER: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenDrm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(<span class="hljs-string"><span class="hljs-string">"/dev/dri/card0"</span></span>, O_RDWR | O_CLOEXEC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"cannot open /dev/dri/card0\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> hasDumb = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { close( fd ); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"/dev/dri/card0 has no support for DUMB_BUFFER\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//maybe Raspberry Pi4 or other platform fd = open("/dev/dri/card1", O_RDWR | O_CLOEXEC); if( fd &lt; 0 ) { cout &lt;&lt; "cannot open /dev/dri/card1\n"; return -1; } hasDumb = 0; if( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; 0 ) { close( fd ); cout &lt;&lt; "/dev/dri/card1 has no support for DUMB_BUFFER\n"; return -1; } } if( !hasDumb ) { close( fd ); cout &lt;&lt; "no support for DUMB_BUFFER\n"; return -1; } //Get DRM authorization drm_magic_t magic; if( drmGetMagic(fd, &amp;magic) ) { cout &lt;&lt; "no DRM magic\n"; close( fd ); return -1; } Window root = DefaultRootWindow( x_display ); if( !DRI2Authenticate( x_display, root, magic ) ) { close( fd ); cout &lt;&lt; "Failed DRI2Authenticate\n"; return -1; } cout &lt;&lt; "DRM fd "&lt;&lt; fd &lt;&lt;"\n"; return fd; }</span></span></code> </pre><br>  Di sini omong-omong ada kehalusan yang tak bisa dijelaskan untuk saya.  Beberapa platform tidak memiliki perpustakaan yang menyediakan fungsi DRI2Authenticate ().  Sebagai contoh, itu tidak di celah dan dalam versi 32-bit untuk Orange Pi PC.  Semua ini aneh.  Tapi saya menemukan repositori di GITHUB: <a href="https://github.com/robclark/libdri2">github.com/robclark/libdri2</a> dapat diambil, dirakit dan diinstal, maka semuanya baik-baik saja.  Sungguh aneh bahwa di Ubuntu 18 (64 bit) saya di laptop tidak ada masalah. <br><br>  Jika Anda dapat menemukan dan membuka / dev / dri / cardX Anda dapat melanjutkan.  Anda perlu mengakses tiga fungsi yang sangat penting dari KHR (Khronos): <br><br><pre> <code class="cpp hljs">PFNEGLCREATEIMAGEKHRPROC funcEglCreateImageKHR = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PFNEGLDESTROYIMAGEKHRPROC funcEglDestroyImageKHR = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PFNGLEGLIMAGETARGETTEXTURE2DOESPROC funcGlEGLImageTargetTexture2DOES = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; ... funcEglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"eglCreateImageKHR"</span></span>); funcEglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"eglDestroyImageKHR"</span></span>); funcGlEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"glEGLImageTargetTexture2DOES"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( funcEglCreateImageKHR &amp;&amp; funcEglDestroyImageKHR &amp;&amp; funcGlEGLImageTargetTexture2DOES ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF feature supported!!!\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CloseDrm(); }</code> </pre><br>  Sekarang kita membutuhkan fungsi yang menciptakan area memori untuk DMABUF.  Fungsi mengambil parameter sebagai lebar bitmap, tinggi, serta pointer ke mana penangan deskriptor file DmaFd dan pointer ke memori bitmap Plane akan dikembalikan. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">nt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDmaBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* DmaFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">** Plane )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dmaFd = *DmaFd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pplane = *Plane = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create dumb buffer drm_mode_create_dumb buffer = { 0 }; buffer.width = Width; buffer.height = Height; buffer.handle = 0; buffer.bpp = 32; //Bits per pixel buffer.flags = 0; int ret = drmIoctl( DriCardFd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;buffer); cout &lt;&lt; "DRM_IOCTL_MODE_CREATE_DUMB " &lt;&lt; buffer.handle &lt;&lt; " " &lt;&lt; ret &lt;&lt; "\n"; if (ret &lt; 0) { cout &lt;&lt; "Error cannot DRM_IOCTL_MODE_CREATE_DUMB\n"; return -1; } // Get the dmabuf for the buffer drm_prime_handle prime; memset(&amp;prime, 0, sizeof prime); prime.handle = buffer.handle; prime.flags = /*DRM_CLOEXEC |*/ DRM_RDWR; ret = drmIoctl( DriCardFd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &amp;prime); if (ret &lt; 0) { cout &lt;&lt; "Error cannot DRM_IOCTL_PRIME_HANDLE_TO_FD " &lt;&lt; errno &lt;&lt; " " &lt;&lt; ret &lt;&lt;"\n"; return -1; } dmaFd = prime.fd; // Map the buffer to userspace int Bpp = 32; pplane = mmap(NULL, Width*Height*Bpp/8, PROT_READ | PROT_WRITE, MAP_SHARED, dmaFd, 0); if( pplane == MAP_FAILED ) { cout &lt;&lt; "Error cannot mmap\n"; return -1; } //return valid values *DmaFd = dmaFd; *Plane = pplane; cout &lt;&lt; "DMABUF created "&lt;&lt; dmaFd &lt;&lt; " " &lt;&lt; (void*)Plane &lt;&lt;"\n"; return 0; }</span></span></code> </pre><br>  Sekarang kita perlu membuat gambar EGL yang terkait dengan penangan DmaFd: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDmaBufferImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ESContext* esContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* DmaFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">** Plane, EGLImageKHR* Image )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dmaFd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* planePtr = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Bpp = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret0 = CreateDmaBuf( Width, Height, &amp;dmaFd, &amp;planePtr ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ret0&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; EGLint img_attrs[] = { EGL_WIDTH, Width, EGL_HEIGHT, Height, EGL_LINUX_DRM_FOURCC_EXT, DRM_FORMAT_ABGR8888, EGL_DMA_BUF_PLANE0_FD_EXT, dmaFd, EGL_DMA_BUF_PLANE0_OFFSET_EXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, EGL_DMA_BUF_PLANE0_PITCH_EXT, Width * Bpp / <span class="hljs-number"><span class="hljs-number">8</span></span>, EGL_NONE }; EGLImageKHR image = funcEglCreateImageKHR( esContext-&gt;eglDisplay, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;img_attrs[<span class="hljs-number"><span class="hljs-number">0</span></span>] ); *Plane = planePtr; *DmaFd = dmaFd; *Image = image; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF pointer "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)planePtr &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF fd "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dmaFd &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EGLImageKHR "</span></span> &lt;&lt; image &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Dan akhirnya, cobaan kita hampir berakhir, dan kita harus menautkan gambar EGL dan gambar OpenGLESv2.  Fungsi mengembalikan pointer ke memori di ruang alamat proses.  Di sana Anda cukup menulis dari utas prosesor apa pun dan semua perubahan dari waktu ke waktu secara otomatis muncul dalam tekstur GPU melalui DMABUF. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideoTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ESContext* esContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height )</span></span></span><span class="hljs-function"> </span></span>{ CreateDmaBufferImage( esContext, Width, Height, &amp;esContext-&gt;DmaFd, &amp;esContext-&gt;Plane, &amp;esContext-&gt;ImageKHR ); GLuint texId; glGenTextures ( <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texId ); glBindTexture ( GL_TEXTURE_2D, texId ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE ); funcGlEGLImageTargetTexture2DOES(GL_TEXTURE_2D, esContext-&gt;ImageKHR ); checkGlError( __LINE__ ); UserData *userData = (UserData*)esContext-&gt;userData; userData-&gt;textureV = texId; userData-&gt;textureV_ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> esContext-&gt;Plane; }</code> </pre><br>  Fungsi GlEGLImageTargetTexture2DOES (..) hanya melakukan pengikatan ini.  Ini menggunakan id pembuatan tekstur normal glGenTextures (..) dan menghubungkannya dengan esContext-&gt; ImageKHR EGL gambar yang dibuat sebelumnya.  Setelah itu, tekstur userData-&gt; teksturV dapat digunakan dalam shader biasa.  Dan pointer esContext-&gt; Plane adalah pointer ke area di memori di mana Anda perlu menulis untuk memperbarui tekstur. <br><br>  Berikut ini cuplikan kode yang menyalin bingkai video: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GstFlowReturn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_new_sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( GstAppSink *pAppsink, gpointer pParam )</span></span></span><span class="hljs-function"> </span></span>{ GstFlowReturn ret = GST_FLOW_OK; GstSample *Sample = gst_app_sink_pull_sample(pAppsink); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Sample ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( VideoWidth==<span class="hljs-number"><span class="hljs-number">0</span></span> || VideoHeight==<span class="hljs-number"><span class="hljs-number">0</span></span> ) { GstCaps* caps = gst_sample_get_caps( Sample ); GstStructure* structure = gst_caps_get_structure (caps, <span class="hljs-number"><span class="hljs-number">0</span></span>); gst_structure_get_int (structure, <span class="hljs-string"><span class="hljs-string">"width"</span></span>, &amp;VideoWidth); gst_structure_get_int (structure, <span class="hljs-string"><span class="hljs-string">"height"</span></span>, &amp;VideoHeight); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Stream Resolution "</span></span> &lt;&lt; VideoWidth &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; VideoHeight &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } GstBuffer *Buffer = gst_sample_get_buffer( Sample ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Buffer ) { GstMapInfo MapInfo; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;MapInfo, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MapInfo)); gboolean Mapped = gst_buffer_map( Buffer, &amp;MapInfo, GST_MAP_READ ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Mapped ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( dmabuf_ptr ) <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( dmabuf_ptr, MapInfo.data, MapInfo.size ); gst_buffer_unmap( Buffer, &amp;MapInfo); frame_ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; update_cv.notify_one(); } } gst_sample_unref( Sample ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  Fungsi ini disebut oleh gstreamer sendiri setiap kali bingkai video baru muncul.  Kami mengambilnya menggunakan gst_app_sink_pull_sample ().  Fungsi ini memiliki memcpy (), yang menyalin bingkai ke memori DMABUF.  Kemudian flag frame_ready diatur dan melalui std :: condition_variable update_cv.notify_one (), aliran yang dirender dibangunkan. <br><br>  Itu mungkin saja ... <br><br>  Meski tidak, saya bohong.  Masih ada masalah sinkronisasi. <br><br>  Yang pertama adalah bahwa prosesor menulis ke memori, tetapi catatan ini mungkin berakhir di cache prosesor dan ditahan di sana, Anda harus membuat cache cache setelah merekam.  Yang kedua - tidak akan buruk untuk mengetahui secara pasti kapan DMA telah bekerja dan Anda dapat mulai render.  Jujur, jika yang pertama saya masih membayangkan bagaimana melakukannya, maka yang kedua - tidak.  Jika Anda punya ide, tulis di komentar. <br><br>  Dan satu hal lagi.  Saya menggunakan gstreamer, yang memutar file video.  Saya menambahkan tautan aplikasi generik ke pipa, yang menerima bingkai video.  Saya mengambil piksel dari bingkai video dan cukup menyalinnya memcpy () ke area memori DMABUF.  Rendering ada di utas terpisah, main ().  Tetapi saya ingin menyingkirkan salinan ini.  Setiap salinan itu jahat.  Bahkan ada istilah zero-copy.  Dan dilihat dari dokumentasi, tampaknya gstreamer itu sendiri dapat membuat frame langsung di DMABUF.  Sayangnya, saya belum menemukan satu pun contoh nyata.  Saya melihat sumber-sumber gstreamer - ada sesuatu tentangnya, tetapi bagaimana menggunakannya sebenarnya tidak jelas.  Jika Anda tahu cara membuat frame zero-copy nyata dengan gstreamer dalam tekstur OpenGLESv2 - tulis. <br><br>  Mungkin poin terakhir: dalam proyek saya, saya menggunakan bitmap 32-bit, yang tidak bagus dalam kasus saya.  Akan jauh lebih masuk akal untuk mengambil YUV dari gstreamer, maka ukuran bingkai videonya jauh lebih kecil, tetapi logikanya rumit - saya harus melakukan 3 DMABUF untuk tiga tekstur secara terpisah Y, U, V. Nah, shader juga rumit, Anda perlu mengonversi YUV ke ARGB tepat di shader. <br><br>  Anda dapat melihat keseluruhan proyek <a href="https://github.com/random-prj/video-cube">di github</a> .  Namun, saya mohon maaf sebelumnya kepada pecinta kode / gaya yang bersih dan benar.  Saya akui itu ditulis dengan sembrono dengan bantuan Google-mine-paste. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481540/">https://habr.com/ru/post/id481540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481530/index.html">Nevanger: Umpan untuk kecepatan</a></li>
<li><a href="../id481532/index.html">Forensik memori, Bebek Karet dan kata sandi GPO. Pemecahan masalah dengan r0ot-mi. Bagian 2</a></li>
<li><a href="../id481534/index.html">Is Delphi Dying - False</a></li>
<li><a href="../id481536/index.html">Sejarah sistem nama domain: protokol "perang"</a></li>
<li><a href="../id481538/index.html">20 mitos SEO untuk mati pada tahun 2020</a></li>
<li><a href="../id481542/index.html">Verifikasi sirkuit digital. Ulasan</a></li>
<li><a href="../id481544/index.html">Menggunakan jaringan saraf convolutional untuk memainkan Life (on Keras)</a></li>
<li><a href="../id481546/index.html">Sejarah mikroprosesor dan komputer pribadi: 1947-1974</a></li>
<li><a href="../id481548/index.html">Symbol.iterator dalam Javascript</a></li>
<li><a href="../id481550/index.html">Inmarsat: menerima dan mendekode sinyal satelit di rumah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>