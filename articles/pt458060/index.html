<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚ù§Ô∏è‚Äçüë® üë®üèæ‚Äçüíº üîß Criando um shader de grama no mecanismo Unity üêí üé∏ üöú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este tutorial mostrar√° como escrever um sombreador geom√©trico para gerar l√¢minas de grama a partir dos topos da malha de entrada e usar o mosaico para...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando um shader de grama no mecanismo Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458060/"><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Este tutorial mostrar√° como escrever um sombreador geom√©trico para gerar l√¢minas de grama a partir dos topos da malha de entrada e usar o mosaico para controlar a densidade da grama. <br><br>  O artigo descreve o processo passo a passo de escrever um shader de grama no Unity.  O shader recebe a malha de entrada e, de cada v√©rtice da malha, gera uma folha de grama usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">shader geom√©trico</a> .  Por uma quest√£o de interesse e realismo, as l√¢minas de grama ter√£o um <strong>tamanho</strong> e <strong>rota√ß√£o</strong> <strong>aleat√≥rios</strong> e tamb√©m ser√£o afetadas pelo <strong>vento</strong> .  Para controlar a densidade da grama, usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mosaico</a> para separar a malha de entrada.  A grama poder√° <strong>projetar</strong> e <strong>receber</strong> sombras. <br><br>  <strong>O projeto finalizado</strong> √© publicado no final do artigo.  O arquivo sombreador gerado cont√©m um grande n√∫mero de coment√°rios que facilitam o entendimento. <br><a name="habracut"></a><br><h3>  Exig√™ncias </h3><br>  Para concluir este tutorial, voc√™ precisar√° de conhecimentos pr√°ticos sobre o mecanismo do Unity e um entendimento inicial da sintaxe e da funcionalidade dos shaders. <br><br>  <a href="">Fa√ßa o download do rascunho do projeto (.zip)</a> . <br><br><h2>  Come√ßando a trabalhar </h2><br>  Fa√ßa o download do rascunho do projeto e abra-o no editor do Unity.  Abra a cena <code>Main</code> e, em seguida, abra o shader <code>Grass</code> no seu editor de c√≥digo. <br><br>  Este arquivo cont√©m um sombreador que produz a cor branca, bem como algumas fun√ß√µes que usaremos neste tutorial.  Voc√™ notar√° que essas fun√ß√µes, juntamente com o sombreador de v√©rtice, est√£o inclu√≠das no bloco <code>CGINCLUDE</code> localizado <em>fora do</em> <code>SubShader</code> .  O c√≥digo colocado neste bloco ser√° <strong>automaticamente inclu√≠do em todas as passagens</strong> no shader;  isso ser√° √∫til mais tarde, porque nosso shader ter√° v√°rios passes. <br><br>  Come√ßaremos escrevendo um <strong>shader geom√©trico</strong> que gera tri√¢ngulos de cada v√©rtice na superf√≠cie da nossa malha. <br><br><h2>  1. Shaders geom√©tricos </h2><br>  Os shaders geom√©tricos s√£o uma parte opcional do pipeline de renderiza√ß√£o.  Eles s√£o executados <strong>ap√≥s o</strong> sombreador de v√©rtice (ou sombreamento de mosaico, se for utilizado mosaico) e antes de os v√©rtices serem processados ‚Äã‚Äãpara o sombreador de fragmento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef7/c01/458/ef7c01458cadf7cd0cf46695d7114f96.jpg"></div><br>  <i>Pipeline de gr√°ficos do Direct3D 11. Observe que neste diagrama o sombreador de fragmento √© chamado de <em>sombreador de pixel</em> .</i> <br><br>  Os sombreadores geom√©tricos recebem uma √∫nica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primitiva</a> na entrada e podem gerar zero, uma ou muitas primitivas.  Come√ßaremos escrevendo um shader geom√©trico que recebe um <strong>v√©rtice</strong> (ou <em>ponto</em> ) na entrada e que alimenta <strong>um tri√¢ngulo</strong> representando uma folha de grama. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block. struct geometryOutput { float4 pos : SV_POSITION; }; [maxvertexcount(3)] void geo(triangle float4 IN[3] : SV_POSITION, inout TriangleStream&lt;geometryOutput&gt; triStream) { } ‚Ä¶ // Add inside the SubShader Pass, just below the #pragma fragment frag line. #pragma geometry geo</span></span></code> </pre> <br>  O c√≥digo acima declara um sombreador geom√©trico chamado <code>geo</code> com dois par√¢metros.  O primeiro, <code>triangle float4 IN[3]</code> , relata que ser√° necess√°rio um tri√¢ngulo (composto por tr√™s pontos).  O segundo, como <code>TriangleStream</code> , configura um sombreador para gerar um fluxo de tri√¢ngulos, para que cada v√©rtice use a estrutura <code>geometryOutput</code> para transmitir seus dados. <br><br><div class="spoiler">  <b class="spoiler_title">Dissemos acima que o shader receber√° um v√©rtice e produzir√° uma folha de grama.</b>  <b class="spoiler_title">Por que ent√£o temos um tri√¢ngulo?</b> <div class="spoiler_text">  Ser√° mais barato considerar um <code></code> como entrada.  Isso pode ser feito da seguinte maneira. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">geo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point vertexOutput IN[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">], inout TriangleStream&lt;geometryOutput&gt; triStream)</span></span></span></span></code> </pre> <br>  No entanto, como nossa malha de entrada (neste caso <code>GrassPlane10x10</code> , localizada na pasta <code>Mesh</code> ) possui uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">topologia de tri√¢ngulo</a> , isso causar√° uma incompatibilidade entre a topologia de malha de entrada e a primitiva de entrada necess√°ria.  Embora isso seja <strong>permitido</strong> no DirectX HLSL, n√£o √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">permitido no OpenGL</a> , portanto, um erro ser√° exibido. </div></div><br>  Al√©m disso, adicionamos o √∫ltimo par√¢metro entre colchetes acima da declara√ß√£o da fun√ß√£o: <code>[maxvertexcount(3)]</code> .  Ele diz √† GPU que produziremos (mas n√£o somos <strong>obrigados</strong> a faz√™-lo) <em>n√£o mais que</em> 3 v√©rtices.  Tamb√©m fazemos com que o <code>SubShader</code> use um shader geom√©trico, declarando-o dentro do <code>Pass</code> . <br><br>  Nosso shader geom√©trico ainda n√£o est√° fazendo nada;  para desenhar um tri√¢ngulo, adicione o seguinte c√≥digo dentro do shader geom√©trico. <br><br><pre> <code class="cpp hljs">geometryOutput o; o.pos = float4(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0db/534/ac1/0db534ac10c125955829fd53b9923cd7.gif"></div><br>  Isso deu resultados muito estranhos.  Quando voc√™ move a c√¢mera, fica claro que o tri√¢ngulo √© renderizado no <strong>espa√ßo</strong> da <strong>tela</strong> .  Isso √© l√≥gico: como o sombreador geom√©trico √© executado imediatamente antes do processamento dos v√©rtices, ele retira a responsabilidade pelos v√©rtices a serem exibidos no <strong>espa√ßo de truncamento</strong> .  Alteraremos nosso c√≥digo para refletir isso. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the return call in the vertex shader. //return UnityObjectToClipPos(vertex); return vertex; ‚Ä¶ // Update each assignment of o.pos in the geometry shader. o.pos = UnityObjectToClipPos(float4(0.5, 0, 0, 1)); ‚Ä¶ o.pos = UnityObjectToClipPos(float4(-0.5, 0, 0, 1)); ‚Ä¶ o.pos = UnityObjectToClipPos(float4(0, 1, 0, 1));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/221/912/b3e/221912b3e6bc0581126a0f415b6e79c5.png"></div><br>  Agora nosso tri√¢ngulo √© renderizado corretamente no mundo.  No entanto, parece que apenas um √© criado.  De fato, um tri√¢ngulo √© <em>desenhado</em> para cada v√©rtice de nossa malha, mas as posi√ß√µes atribu√≠das aos v√©rtices do tri√¢ngulo s√£o <strong>constantes</strong> - elas n√£o mudam para cada v√©rtice recebido.  Portanto, todos os tri√¢ngulos est√£o localizados um em cima do outro. <br><br>  Vamos corrigir isso, fazendo com que as posi√ß√µes dos v√©rtices de sa√≠da sejam <strong>compensadas em</strong> rela√ß√£o ao ponto de entrada. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the top of the geometry shader. float3 pos = IN[0]; ‚Ä¶ // Update each assignment of o.pos. o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); ‚Ä¶ o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); ‚Ä¶ o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/ac4/84c/6b2ac484c5a033b18e88400e10191779.png"></div><br><div class="spoiler">  <b class="spoiler_title">Por que alguns v√©rtices n√£o criam um tri√¢ngulo?</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cab/447/d9c/cab447d9c4c82d8208a28e7cee2f7807.png"></div><br>  Embora tenhamos determinado que a primitiva de entrada ser√° um <strong>tri√¢ngulo</strong> , uma folha de grama √© transmitida apenas de <strong>um</strong> dos pontos do tri√¢ngulo, descartando os outros dois.  √â claro que podemos transferir uma folha de grama dos tr√™s pontos de entrada, mas isso levar√° ao fato de que os tri√¢ngulos vizinhos criam excessivamente folhas de grama uma sobre a outra. <br><br>  Ou voc√™ pode resolver esse problema usando malhas com o tipo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pontos</a> de topologia como malhas de entrada do sombreador geom√©trico. </div></div><br>  Os tri√¢ngulos agora est√£o desenhados corretamente e sua base est√° localizada no pico que os emite.  Antes de <code>GrassPlane</code> , torne o objeto <code>GrassPlane</code> <strong>inativo</strong> na cena e <code>GrassBall</code> objeto <code>GrassBall</code> .  Queremos que a grama gere corretamente em diferentes tipos de superf√≠cies, por isso √© importante test√°-la em malhas de diferentes formas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19b/f67/8fb/19bf678fbb6ce3c03956dbdf068004f0.png"></div><br>  At√© agora, todos os tri√¢ngulos s√£o emitidos em uma dire√ß√£o, e n√£o para fora da superf√≠cie da esfera.  Para resolver esse problema, criaremos l√¢minas de grama em um <strong>espa√ßo tangente</strong> . <br><br><h2>  2. Espa√ßo tangente </h2><br>  Idealmente, gostar√≠amos de criar l√¢minas de grama, definindo uma largura, altura, curvatura e rota√ß√£o diferentes, sem levar em considera√ß√£o o √¢ngulo da superf√≠cie a partir da qual a l√¢mina de grama √© emitida.  Simplificando, definimos uma folha de grama em um espa√ßo <strong>local para o v√©rtice que a emite</strong> e depois a transformamos para que seja <strong>local na malha</strong> .  Esse espa√ßo √© chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">espa√ßo tangente</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/8f7/c39/3fd8f7c394bf4eb18cb988aceafe342b.png"></div><br>  <i>No espa√ßo tangente, os eixos <strong>X</strong> , <strong>Y</strong> e <strong>Z</strong> s√£o definidos em rela√ß√£o ao normal e √† posi√ß√£o da superf√≠cie (no nosso caso, os v√©rtices).</i> <br><br>  Como qualquer outro espa√ßo, podemos definir o espa√ßo tangente de um v√©rtice com tr√™s vetores: <strong>direita</strong> , <strong>frente</strong> e <strong>cima</strong> .  Usando esses vetores, podemos criar uma matriz para transformar a folha de grama da tangente para o espa√ßo local. <br><br>  Voc√™ pode acessar os vetores <strong>diretamente</strong> e adicionando novos dados de v√©rtice de entrada. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; ‚Ä¶ // Modify the vertex shader. vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; } ‚Ä¶ // Modify the input for the geometry shader. Note that the SV_POSITION semantic is removed. void geo(triangle vertexOutput IN[3], inout TriangleStream&lt;geometryOutput&gt; triStream) ‚Ä¶ // Modify the existing line declaring pos. float3 pos = IN[0].vertex;</span></span></code> </pre> <br>  O terceiro vetor pode ser calculado levando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">produto vetorial</a> entre dois outros.  Um produto vetorial retorna um vetor <strong>perpendicular</strong> a dois vetores recebidos. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Place in the geometry shader, below the line declaring float3 pos. float3 vNormal = IN[0].normal; float4 vTangent = IN[0].tangent; float3 vBinormal = cross(vNormal, vTangent) * vTangent.w;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Por que o resultado do produto vetorial √© multiplicado pela coordenada da tangente w?</b> <div class="spoiler_text">  Ao exportar uma malha de um editor 3D, ele geralmente possui binormais (tamb√©m chamados <em>tangentes a dois pontos</em> ) j√° armazenados nos dados da malha.  Em vez de importar esses binormais, o Unity simplesmente toma a dire√ß√£o de cada binormal e os atribui √† coordenada da tangente <strong>w</strong> .  Isso permite economizar mem√≥ria e, ao mesmo tempo, fornecer a capacidade de recriar o binormal correto.  Uma discuss√£o detalhada deste t√≥pico pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </div></div><br>  Tendo todos os tr√™s vetores, podemos criar uma matriz para a transforma√ß√£o entre os espa√ßos tangente e local.  Multiplicaremos cada v√©rtice da folha de grama por essa matriz antes de pass√°-lo para o <code>UnityObjectToClipPos</code> , que espera um v√©rtice no espa√ßo local. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the lines declaring the three vectors. float3x3 tangentToLocal = float3x3( vTangent.x, vBinormal.x, vNormal.x, vTangent.y, vBinormal.y, vNormal.y, vTangent.z, vBinormal.z, vNormal.z );</span></span></code> </pre> <br>  Antes de usar a matriz, transferimos o c√≥digo de sa√≠da do v√©rtice para a fun√ß√£o, para n√£o escrever as mesmas linhas de c√≥digo repetidamente.  Isso √© chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">princ√≠pio DRY</a> ou <strong>n√£o se repita</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. geometryOutput VertexOutput(float3 pos) { geometryOutput o; o.pos = UnityObjectToClipPos(pos); return o; } ‚Ä¶ // Remove the following from the geometry shader. //geometryOutput o; //o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0)); //triStream.Append(o); // ...and replace it with the code below. triStream.Append(VertexOutput(pos + float3(0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(-0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(0, 1, 0)));</span></span></code> </pre> <br>  Finalmente, multiplicamos os v√©rtices de sa√≠da pela matriz <code>tangentToLocal</code> , alinhando-os corretamente com o normal do ponto de entrada. <br><br><pre> <code class="cpp hljs">triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/3f8/286/c953f828675a9d4e202c0c9349d37f9d.png" alt="imagem"></div><br>  √â mais como o que precisamos, mas n√£o exatamente.  O problema aqui √© que, inicialmente, atribu√≠mos a dire√ß√£o "para cima" (para cima) do eixo <strong>Y</strong> ;  no entanto, no espa√ßo tangente, a dire√ß√£o para cima geralmente est√° localizada ao longo do eixo <strong>Z.</strong>  Agora vamos fazer essas altera√ß√µes. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the position of the third vertex being emitted. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1))));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/f51/ddb/0cff51ddbea12280cb78a1db9ada1786.png"></div><br><h2>  3. Apar√™ncia de grama </h2><br>  Para fazer com que os tri√¢ngulos pare√ßam mais com folhas de grama, voc√™ precisa adicionar cores e varia√ß√µes.  Come√ßamos adicionando um <strong>gradiente</strong> descendo do topo da folha de grama. <br><br><h3>  3.1 gradiente de cor </h3><br>  Nosso objetivo √© permitir que o artista defina duas cores - superior e inferior e interpole entre essas duas cores que ele inclina para a base da folha da grama.  Essas cores j√° est√£o definidas no arquivo shader como <code>_TopColor</code> e <code>_BottomColor</code> .  Para uma amostragem adequada, voc√™ precisa passar as <strong>coordenadas UV</strong> para o shader do fragmento. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. float2 uv : TEXCOORD0; ‚Ä¶ // Modify the VertexOutput function signature. geometryOutput VertexOutput(float3 pos, float2 uv) ‚Ä¶ // Add to VertexOutput, just below the line assigning o.pos. o.uv = uv; ‚Ä¶ // Modify the existing lines in the geometry shader. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br>  Criamos coordenadas UV para uma folha de grama na forma de um tri√¢ngulo, cujos dois v√©rtices est√£o localizados na parte inferior esquerda e direita e a parte superior da ponta est√° localizada no centro na parte superior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/165/e39/932/165e399323aaa07e7c4cee728c0c9988.png"></div><br>  <i>Coordenadas UV dos tr√™s v√©rtices das l√¢minas de grama.</i>  <i>Embora pintemos as l√¢minas de grama com um gradiente simples, um arranjo semelhante de texturas permite sobrepor texturas.</i> <br><br>  Agora podemos provar as cores superior e inferior no shader de fragmentos com UV e, em seguida, interpolar com o <code>lerp</code> .  Tamb√©m precisaremos modificar os par√¢metros do shader de fragmento, tornando <code>geometryOutput</code> como entrada, e n√£o apenas a posi√ß√£o do <code>float4</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the function signature of the fragment shader. float4 frag (geometryOutput i, fixed facing : VFACE) : SV_Target ‚Ä¶ // Replace the existing return call. return float4(1, 1, 1, 1); return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/510/51f/59651051f474907a88740e83bc9d4532.png"></div><br><h3>  3.2 Dire√ß√£o aleat√≥ria da l√¢mina </h3><br>  Para criar variabilidade e dar √† grama uma apar√™ncia mais natural, faremos com que cada l√¢mina de grama pare√ßa em uma dire√ß√£o aleat√≥ria.  Para fazer isso, precisamos criar uma matriz de rota√ß√£o que gire a folha de grama uma quantidade aleat√≥ria em torno de seu eixo <strong>superior</strong> . <br><br>  Existem duas fun√ß√µes no arquivo shader que nos ajudar√£o a fazer isso: <code>rand</code> , que gera um n√∫mero aleat√≥rio a partir da entrada tridimensional, e <code>AngleAxis3x3</code> , que recebe o √¢ngulo (em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">radianos</a> ) e retorna uma matriz que gira esse valor em torno do eixo especificado.  A √∫ltima fun√ß√£o funciona exatamente da mesma forma que a fun√ß√£o C # <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quaternion.AngleAxis</a> (somente <code>AngleAxis3x3</code> retorna uma matriz, n√£o um quaternion). <br><br>  A fun√ß√£o <code>rand</code> retorna um n√∫mero no intervalo de 0 a 1;  multiplicamos por <strong>2 Pi</strong> para obter toda a gama de valores angulares. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring the tangentToLocal matrix. float3x3 facingRotationMatrix = AngleAxis3x3(rand(pos) * UNITY_TWO_PI, float3(0, 0, 1));</span></span></code> </pre> <br>  Usamos a posi√ß√£o <code>pos</code> entrada como semente para uma rota√ß√£o aleat√≥ria.  Devido a isso, cada folha de grama ter√° sua pr√≥pria rota√ß√£o, constante em cada quadro. <br><br>  A rota√ß√£o pode ser aplicada √† folha de grama multiplicando-a pela matriz <code>tangentToLocal</code> criada.  Observe que a multiplica√ß√£o da matriz <strong>n√£o</strong> √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comutativa</a> ;  a ordem dos operandos √© <strong>importante</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring facingRotationMatrix. float3x3 transformationMatrix = mul(tangentToLocal, facingRotationMatrix); ‚Ä¶ // Replace the multiplication matrix operand with our new transformationMatrix. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09f/c2f/e80/09fc2fe8028b51f78989954e65812cd3.png"></div><br><h3>  3.3 Curvatura aleat√≥ria </h3><br>  Se todas as l√¢minas de grama estiverem perfeitamente alinhadas, elas aparecer√£o iguais.  Isso pode ser adequado para grama bem cuidada, por exemplo, em um gramado aparado, mas na natureza a grama n√£o cresce assim.  Criaremos uma nova matriz para girar a grama ao longo do eixo <strong>X</strong> , bem como uma propriedade para controlar essa rota√ß√£o. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _BendRotationRandom("Bend Rotation Random", Range(0, 1)) = 0.2 ‚Ä¶ // Add to the CGINCLUDE block. float _BendRotationRandom; ‚Ä¶ // Add to the geometry shader, below the line declaring facingRotationMatrix. float3x3 bendRotationMatrix = AngleAxis3x3(rand(pos.zzx) * _BendRotationRandom * UNITY_PI * 0.5, float3(-1, 0, 0));</span></span></code> </pre> <br>  Novamente, usamos a posi√ß√£o da folha de grama como uma semente aleat√≥ria, desta vez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">varrendo-a</a> para criar uma semente √∫nica.  Tamb√©m multiplicaremos <code>UNITY_PI</code> por <strong>0,5</strong> ;  isso nos dar√° um intervalo aleat√≥rio de 0 a 90 graus. <br><br>  Novamente, aplicamos essa matriz por rota√ß√£o, multiplicando tudo na ordem correta. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line. float3x3 transformationMatrix = mul(mul(tangentToLocal, facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49c/122/534/49c122534d7298c0f9c646501a708daa.gif"></div><br><h3>  3.4 Largura e altura </h3><br>  Enquanto o tamanho da folha de grama √© limitado a uma largura de 1 unidade e a uma altura de 1 unidade.  Adicionaremos propriedades para controlar o tamanho, bem como propriedades para adicionar varia√ß√£o aleat√≥ria. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeWidth("Blade Width", Float) = 0.05 _BladeWidthRandom("Blade Width Random", Float) = 0.02 _BladeHeight("Blade Height", Float) = 0.5 _BladeHeightRandom("Blade Height Random", Float) = 0.3 ‚Ä¶ // Add to the CGINCLUDE block. float _BladeHeight; float _BladeHeightRandom; float _BladeWidth; float _BladeWidthRandom; ‚Ä¶ // Add to the geometry shader, above the triStream.Append calls. float height = (rand(pos.zyx) * 2 - 1) * _BladeHeightRandom + _BladeHeight; float width = (rand(pos.xzy) * 2 - 1) * _BladeWidthRandom + _BladeWidth; ‚Ä¶ // Modify the existing positions with our new height and width. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-width, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, height)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35b/22e/f34/35b22ef34945a576100a152a0e25eec5.png"></div><br>  Os tri√¢ngulos agora s√£o muito mais parecidos com folhas de grama, mas tamb√©m muito pouco.  Simplesmente n√£o h√° picos suficientes na malha de entrada para criar a impress√£o de um campo densamente coberto de vegeta√ß√£o. <br><br>  Uma solu√ß√£o √© criar uma nova malha mais densa, usando C # ou em um editor 3D.  Isso funcionar√°, mas n√£o nos permitir√° controlar dinamicamente a densidade da grama.  Em vez disso, dividiremos a malha de entrada usando <strong>mosaico</strong> . <br><br><h2>  4. Mosaico </h2><br>  <strong>O mosaico</strong> √© um est√°gio opcional do pipeline de renderiza√ß√£o, executado ap√≥s o shader de v√©rtice e antes do shader geom√©trico (se houver).  Sua tarefa √© subdividir uma superf√≠cie de entrada em muitas primitivas.  O mosaico √© implementado em duas etapas program√°veis: sombreadores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">casco</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dom√≠nio</a> . <br><br>  Para shaders de superf√≠cie, o Unity possui uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementa√ß√£o de mosaico embutida</a> .  No entanto, como <strong>n√£o usamos</strong> shaders de superf√≠cie, teremos que implementar nossos pr√≥prios shaders de dom√≠nio e shell.  Neste artigo, n√£o discutirei a implementa√ß√£o do mosaico em detalhes e simplesmente usamos o arquivo <code>CustomTessellation.cginc</code> existente.  Este arquivo foi adaptado do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo Catlike Coding</a> , que √© uma excelente fonte de informa√ß√µes sobre a implementa√ß√£o de mosaico no Unity. <br><br>  Se incluirmos o objeto <code>TessellationExample</code> na cena, veremos que ele j√° possui material que implementa o mosaico.  Alterar a propriedade <strong>Uniforme de mosaico</strong> demonstra o efeito de subdivis√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d8/8a7/f01/2d88a7f01e3a7462ffd0c8f20953b5ca.gif"></div><br>  Implementamos mosaico no shader de grama para controlar a densidade do avi√£o e, portanto, controlar o n√∫mero de l√¢minas de grama geradas.  Primeiro, voc√™ precisa adicionar o arquivo <code>CustomTessellation.cginc</code> .  Vamos nos referir a ele por seu caminho <em>relativo</em> para o sombreador. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block, below the other #include statements. #include "Shaders/CustomTessellation.cginc"</span></span></code> </pre> <br>  Se voc√™ abrir <code>CustomTessellation.cginc</code> , notar√° que as <code>vertexOutput</code> e <code>vertexOutput</code> , bem como os shaders de v√©rtice, j√° est√£o definidos nela.  N√£o h√° necessidade de redefini-las em nosso shader de grama;  eles podem ser exclu√≠dos. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; }*/</span></span></code> </pre> <br>  Observe que o sombreador de v√©rtice <code>vert</code> no <code>CustomTessellation.cginc</code> simplesmente passa a entrada diretamente para o est√°gio de mosaico;  a fun√ß√£o <code>vertexOutput</code> , chamada dentro do sombreador de dom√≠nio, assume a tarefa de criar a estrutura <code>vertexOutput</code> . <br><br>  Agora podemos adicionar sombreadores de <strong>concha</strong> e <strong>dom√≠nio</strong> ao sombreador de grama.  Tamb√©m adicionaremos uma nova propriedade <code>_TessellationUniform</code> para controlar o tamanho da unidade - a vari√°vel correspondente a essa propriedade j√° foi declarada em <code>CustomTessellation.cginc</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _TessellationUniform("Tessellation Uniform", Range(1, 64)) = 1 ‚Ä¶ // Add below the other #pragma statements in the SubShader Pass. #pragma hull hull #pragma domain domain</span></span></code> </pre> <br>  Agora, alterar a propriedade <strong>Uniforme de mosaico</strong> nos permite controlar a densidade da grama.  Descobri que bons resultados s√£o obtidos com o valor <strong>5</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/280/d93/c14/280d93c1420a9744bd56f2d2496f96ab.gif"></div><br><h2>  5. O vento </h2><br>  Implementamos o vento amostrando a <strong>textura</strong> da <strong>distor√ß√£o</strong> .  Essa textura parecer√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um mapa normal</a> , apenas nele haver√° apenas dois em vez de tr√™s canais.  Usaremos esses dois canais como dire√ß√µes do vento ao longo de <strong>X</strong> e <strong>Y.</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/aaa/687/a58aaa68742934ff1bddf1cbaf9564f5.png"></div><br>  Antes de amostrar a textura do vento, precisamos criar uma coordenada UV.  Em vez de usar as coordenadas de textura atribu√≠das √† malha, aplicamos a posi√ß√£o do ponto de entrada.  Gra√ßas a isso, se houver v√°rias malhas de grama no mundo, ser√° criada a ilus√£o de que elas fazem parte do mesmo sistema e√≥lico.  Tamb√©m usamos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vari√°vel</a> <code>_Time</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">shader</a> para rolar a textura do vento ao longo da superf√≠cie da grama. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _WindDistortionMap("Wind Distortion Map", 2D) = "white" {} _WindFrequency("Wind Frequency", Vector) = (0.05, 0.05, 0, 0) ‚Ä¶ // Add to the CGINCLUDE block. sampler2D _WindDistortionMap; float4 _WindDistortionMap_ST; float2 _WindFrequency; ‚Ä¶ // Add to the geometry shader, just above the line declaring the transformationMatrix. float2 uv = pos.xz * _WindDistortionMap_ST.xy + _WindDistortionMap_ST.zw + _WindFrequency * _Time.y;</span></span></code> </pre> <br>  Aplicamos a escala e o deslocamento de <code>_WindDistortionMap</code> √† posi√ß√£o e depois o deslocamos para <code>_Time.y</code> , dimensionado para <code>_WindFrequency</code> .  Agora, usaremos esses UVs para provar a textura e criar uma propriedade para controlar a for√ßa do vento. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _WindStrength("Wind Strength", Float) = 1 ‚Ä¶ // Add to the CGINCLUDE block. float _WindStrength; ‚Ä¶ // Add below the line declaring float2 uv. float2 windSample = (tex2Dlod(_WindDistortionMap, float4(uv, 0, 0)).xy * 2 - 1) * _WindStrength;</span></span></code> </pre> <br>  Observe que escalamos o valor amostrado da textura do intervalo 0 ... 1 para o intervalo -1 ... 1.  Em seguida, podemos criar um vetor normalizado que denota a dire√ß√£o do vento. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float2 windSample. float3 wind = normalize(float3(windSample.x, windSample.y, 0));</span></span></code> </pre> <br>  Agora podemos criar uma matriz para girar em torno desse vetor e multiplic√°-la pela nossa <code>transformationMatrix</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3 wind. float3x3 windRotation = AngleAxis3x3(UNITY_PI * windSample, wind); ‚Ä¶ // Modify the existing line. float3x3 transformationMatrix = mul(mul(mul(tangentToLocal, windRotation), facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br>  Finalmente, transferimos a textura <code>Wind</code> (localizada na raiz do projeto) para o campo <strong>Mapa de distor√ß√£o</strong> do <strong>vento</strong> do material da grama no editor Unity.  Tamb√©m definimos o par√¢metro lado a lado da textura como <code>0.01, 0.01</code> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Se a grama n√£o estiver animando na janela <strong>Cena</strong> , clique no bot√£o <strong>Alternar skybox, neblina e v√°rios outros efeitos</strong> para ativar materiais animados. <br><br>    ,      ,  ,    , -       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/148/51e/6e914851e888c448c30080a7abefae33.png"></div><br> <i>      ,     ( <strong></strong> ),      ( <strong></strong> ).</i> <br><br>   ,    ,       .    <strong> </strong>   <code>windRotation</code>  <code>bendRotationMatrix</code> ,        . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3x3 transformationMatrix. float3x3 transformationMatrixFacing = mul(tangentToLocal, facingRotationMatrix); ‚Ä¶ // Modify the existing lines outputting the base vertex positions. triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(-width, 0, 0)), float2(1, 0)));</span></span></code> </pre> <br><h2> 6.   </h2><br>      .      ,        ,     .   ,          <strong></strong> . <br><br>       <strong></strong> .           ,     ‚Äî    ,   . <br><br>      ,   .          ,        ?      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tira triangular</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Os tr√™s primeiros v√©rtices se unem e formam um tri√¢ngulo, e cada novo v√©rtice forma um tri√¢ngulo com os dois anteriores.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/871/8ec/676/8718ec676d7efd819718bd25d5b27b54.gif"></div><br> <i> ,    triangle strip       .              .</i> <br><br>          ,           .        ,      <code>TriangleStream</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RestartStrip</a> . <br><br>          ,    <code>maxvertexcount</code> .    <code>#define</code> ,              . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. #define BLADE_SEGMENTS 3 ‚Ä¶ // Modify the existing line defining the maxvertexcount. [maxvertexcount(BLADE_SEGMENTS * 2 + 1)]</span></span></code> </pre> <br>       <strong>3</strong>   <code>maxvertexcount</code> ,        . <br><br>        <code>for</code> .       <strong> </strong> : <strong></strong>  <strong></strong> .          . <br><br>     ,           ,              .    <code>CGINCLUDE</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">geometryOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGrassVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 vertexPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, float2 uv, float3x3 transformMatrix)</span></span></span><span class="hljs-function"> </span></span>{ float3 tangentPoint = float3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, height); float3 localPosition = vertexPosition + mul(transformMatrix, tangentPoint); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VertexOutput(localPosition, uv); }</code> </pre> <br>      ,     ,     <code>VertexOutput</code>    .  ,   ,            UV-.        . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the existing code outputting the vertices. triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br>    ,          <code>for</code> .    <code>float width</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; BLADE_SEGMENTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = i / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)BLADE_SEGMENTS; }</code> </pre> <br>   ,         .     <code>t</code> .        0...1, ,      .              . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float t. float segmentHeight = height * t; float segmentWidth = width * (1 - t);</span></span></code> </pre> <br>       ,   .        <code>GenerateGrassVertex</code> ,      .      <code>GenerateGrassVertex</code>   ,     . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float segmentWidth. float3x3 transformMatrix = i == 0 ? transformationMatrixFacing : transformationMatrix; triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, float2(1, t), transformMatrix)); ‚Ä¶ // Add just below the loop to insert the vertex at the tip of the blade. triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix)); ‚Ä¶ // Remove the existing calls to triStream.Append. //triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br>      <code>float3x3 transformMatrix</code> ‚Äî        :  <code>transformationMatrixFacing</code>     <code>transformationMatrix</code>   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/211/61c/02b21161cd4afc0cca35ae71ffe2570e.png"></div><br>      ,    -  ‚Äî     .    ,     <strong>Y</strong> . -,     <code>GenerateGrassVertex</code> ,      <strong>Y</strong> ,    <code>forward</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the function signature of GenerateGrassVertex. geometryOutput GenerateGrassVertex(float3 vertexPosition, float width, float height, float forward, float2 uv, float3x3 transformMatrix) ‚Ä¶ // Modify the Y coordinate assignment of tangentPoint. float3 tangentPoint = float3(width, forward, height);</span></span></code> </pre> <br>          <code>pow</code>  <code>t</code> .   <code>t</code>       forward  <em></em>     . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeForward("Blade Forward Amount", Float) = 0.38 _BladeCurve("Blade Curvature Amount", Range(1, 4)) = 2 ‚Ä¶ // Add to the CGINCLUDE block. float _BladeForward; float _BladeCurve; ‚Ä¶ // Add inside the geometry shader, below the line declaring float width. float forward = rand(pos.yyz) * _BladeForward; ‚Ä¶ // Add inside the loop, below the line declaring segmentWidth. float segmentForward = pow(t, _BladeCurve) * forward; ‚Ä¶ // Modify the GenerateGrassVertex calls inside the loop. triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, segmentForward, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, segmentForward, float2(1, t), transformMatrix)); ‚Ä¶ // Modify the GenerateGrassVertex calls outside the loop. triStream.Append(GenerateGrassVertex(pos, 0, height, forward, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br>     ,      ,       .    <code>_BladeForward</code>  <code>_BladeCurve</code>   ,  ,      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/cbc/e43/c1fcbce43fa5e1c1be319dc1f5190f3d.png"></div><br><h2> 7.    </h2><br>           <strong></strong>  <strong></strong> .     ,      . <br><br><h3> 7.1   </h3><br>     Unity      .                 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> .  ,         ,     . <br><br>       <code>CGINCLUDE</code> ,        .   ,      ,   ,     ‚Äî   ,    ,   . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the existing Pass. Pass { Tags { "LightMode" = "ShadowCaster" } CGPROGRAM #pragma vertex vert #pragma geometry geo #pragma fragment frag #pragma hull hull #pragma domain domain #pragma target 4.6 #pragma multi_compile_shadowcaster float4 frag(geometryOutput i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG }</span></span></code> </pre> <br>     ,        .  <code>LightMode</code>   <code>ShadowCaster</code> ,   <code>ForwardBase</code> ‚Äî   Unity,           .      <code>multi_compile_shadowcaster</code> .  ,      ,    . <br><br>    <code>Fence</code> <strong></strong>  ;    ,      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c57/640/6cf/c576406cf284fe41e4b04d8af264d96e.png"></div><br><h3> 7.2   </h3><br>  ,  Unity          ,   , ¬´¬ª    <strong> </strong> .                   . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. unityShadowCoord4 _ShadowCoord : TEXCOORD1; ‚Ä¶ // Add to the VertexOutput function, just above the return call. o._ShadowCoord = ComputeScreenPos(o.pos);</span></span></code> </pre> <br>     <code>ForwardBase</code>        <code>float</code> , ,     ,  .      0...1,  0 ‚Äî  , 1 ‚Äî  . <br><br><div class="spoiler"> <b class="spoiler_title"> UV-    _ShadowCoord?      </b> <div class="spoiler_text">    Unity           (       ).          <code>SHADOW_ATTENUATION</code> .         <code>Autolight.cginc</code> ,  ,       . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SHADOW_ATTENUATION(a) unitySampleShadow(a._ShadowCoord)</span></span></code> </pre> <br>              -    ,            . </div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's fragment shader, replacing the existing return call. return SHADOW_ATTENUATION(i); //return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br> ,    ,        .       <code>ForwardBase</code>  ,       . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's preprocessor directives, below #pragma target 4.6. #pragma multi_compile_fwdbase</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90a/491/468/90a491468a1ad129d35bea03b0b51898.png"></div><br>  ,       ;   ,        .    ,  <em> </em>           .       Unity      <code>#if</code> ,       . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add at the end of the VertexOutput function, just above the return call. #if UNITY_PASS_SHADOWCASTER // Applying the bias prevents artifacts from appearing on the surface. o.pos = UnityApplyLinearShadowBias(o.pos); #endif</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dca/ec0/d88/dcaec0d88eea1893b6a07eb45724a0b6.gif"></div><br> <i>             .</i> <br><br><div class="spoiler"> <b class="spoiler_title">      ?</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08a/12e/af1/08a12eaf1af17fc9b35de7d07a64afca.png"></div><br>      (multisample anti-aliasing <strong>MSAA</strong> ) Unity <em> </em>     ,        .        ,  . <br><br>    ‚Äî  ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  Unity</a> .      (     );     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    Unity</a> . </div></div><br><h3> 7.3  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementaremos a ilumina√ß√£o usando um algoritmo de c√°lculo de ilumina√ß√£o difusa muito simples e comum.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/3ae/452/4043ae452046c0b4b405aa88afe8d2b7.gif"></div><br> ‚Ä¶  <strong>N</strong> ‚Äî   , <strong>L</strong> ‚Äî      ,  <strong>I</strong> ‚Äî  .     <strong> </strong>   . <br><br>        .       ,      <strong> </strong> ,      . <br><br>  <strong>Blade Curvature Amount</strong>   <strong>1</strong> ,         :    <strong>Y</strong> .         ,   . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the GenerateGrassVertex function, belowing the line declaring tangentPoint. float3 tangentNormal = float3(0, -1, 0); float3 localNormal = mul(transformMatrix, tangentNormal);</span></span></code> </pre> <br> <code>tangentNormal</code> ,      <strong>Y</strong> ,    ,          .        <code>VertexOutput</code> ,     <code>geometryOutput</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the return call in GenerateGrassVertex. return VertexOutput(localPosition, uv, localNormal); ‚Ä¶ // Add to the geometryOutput struct. float3 normal : NORMAL; ‚Ä¶ // Modify the existing function signature. geometryOutput VertexOutput(float3 pos, float2 uv, float3 normal) ‚Ä¶ // Add to the VertexOutput function to pass the normal through to the fragment shader. o.normal = UnityObjectToWorldNormal(normal);</span></span></code> </pre> <br> ,        <strong> </strong> ; Unity          ,    . <br><br>         <code>ForwardBase</code> ,     . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader. float3 normal = facing &gt; 0 ? i.normal : -i.normal; return float4(normal * 0.5 + 0.5, 1); // Remove the existing return call. //return SHADOW_ATTENUATION(i);</span></span></code> </pre> <br>      <code>Cull</code>   <code>Off</code> ,    .       ,     <code>VFACE</code> ,     . <br><br>  <code>fixed facing</code>   <strong></strong> ,      ,  <strong></strong> ,  .      ,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/8ca/965/e1b8ca965ed8e80b539a9773d1adeb0c.png"></div><br>  <strong>Blade Curvature Amount</strong>  1,   <strong>Z</strong>       <code>forward</code> ,   <code>GenerateGrassVertex</code> .         <strong>Z</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line in GenerateGrassVertex. float3 tangentNormal = normalize(float3(0, -1, forward));</span></span></code> </pre> <br> ,     ,   ,     .              <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  toon-</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader, below the line declaring float3 normal. float shadow = SHADOW_ATTENUATION(i); float NdotL = saturate(saturate(dot(normal, _WorldSpaceLightPos0)) + _TranslucentGain) * shadow; float3 ambient = ShadeSH9(float4(normal, 1)); float4 lightIntensity = NdotL * _LightColor0 + float4(ambient, 1); float4 col = lerp(_BottomColor, _TopColor * lightIntensity, i.uv.y); return col; // Remove the existing return call. //return float4(normal * 0.5 + 0.5, 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/894/d14/c14894d14edc336b770f4b94bedd3708.png"></div><br><h2>  Conclus√£o </h2><br>         10x10 .           ,   .      ,       .  ,                 . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/a05/e86/5a7a05e8690c152f9196bb3c94fada19.png"></div><br> <i> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Standard Assets</a>  Unity.      ,      .</i> <br><br>            ,               Unity   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  GitHub</a> ,           G-. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     GitHub</a> <br><br><h3> :  </h3><br>           .       ,            . <br><br>        :    ,  <strong> </strong>  ,   ,      ,      <strong></strong>  . <br><br>  ,      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> .       ;     ,   ,        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458060/">https://habr.com/ru/post/pt458060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458046/index.html">Folha de dicas de Gradle</a></li>
<li><a href="../pt458048/index.html">Delega√ß√£o como ferramenta de gerente</a></li>
<li><a href="../pt458050/index.html">Como foi o Mobius 2019 Piter (e um pouco sobre o pr√≥ximo Mobius)</a></li>
<li><a href="../pt458052/index.html">AMA com Habr.10. √öltima * Edi√ß√£o</a></li>
<li><a href="../pt458056/index.html">A grande entrevista com Martin Kleppmann: ‚ÄúDescobrindo o futuro dos sistemas de dados distribu√≠dos‚Äù</a></li>
<li><a href="../pt458062/index.html">Vis√£o geral da plataforma UserGate</a></li>
<li><a href="../pt458064/index.html">PVS-Studio nas nuvens - Executando a an√°lise no Travis CI</a></li>
<li><a href="../pt458068/index.html">PVS-Studio para Visual Studio</a></li>
<li><a href="../pt458070/index.html">PVS-Studio para Visual Studio</a></li>
<li><a href="../pt458072/index.html">PVS-Studio vai para as nuvens - an√°lise de lan√ßamento no Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>