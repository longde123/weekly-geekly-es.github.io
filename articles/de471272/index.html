<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèø ‚è≠Ô∏è üéÖüèø Die Vorteile einer starken Eingabe in C ++: praktische Erfahrung ü§û üë¥üèΩ ‚è∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unser Programm verarbeitet Netzwerkpakete, insbesondere TCP / IP / etc-Header. In ihnen werden numerische Werte - Offsets, Z√§hler, Adressen - in der R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Vorteile einer starken Eingabe in C ++: praktische Erfahrung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471272/"> Unser Programm verarbeitet Netzwerkpakete, insbesondere TCP / IP / etc-Header.  In ihnen werden numerische Werte - Offsets, Z√§hler, Adressen - in der Reihenfolge der Netzwerkbytes (Big-Endian) dargestellt.  Wir arbeiten an x86 (Little-Endian).  In Standardstrukturen, die Header beschreiben, werden diese Felder durch einfache Ganzzahltypen ( <code>uint32_t</code> , <code>uint16_t</code> ) dargestellt.  Nach mehreren Fehlern aufgrund der Tatsache, dass wir vergessen haben, die Bytereihenfolge zu konvertieren, haben wir beschlossen, die Feldtypen durch Klassen zu ersetzen, die implizite Konvertierungen und atypische Operationen verbieten.  Unter dem Schnitt befindet sich ein n√ºtzlicher Code und spezifische Beispiele f√ºr Fehler, die durch strikte Eingabe aufgedeckt wurden. <br><a name="habracut"></a><br><h2>  Bytereihenfolge </h2><br>  Likbez f√ºr diejenigen, die die Bytereihenfolge nicht kennen (Endianness, Bytereihenfolge).  Im Detail war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schon auf "Habr√©"</a> . <br><br>  In der √ºblichen Notation von Zahlen gehen sie vom √§ltesten (links) zum j√ºngsten (rechts) links: 432 <sub>10</sub> = 4 √ó 10 <sup>2</sup> + 3 √ó 10 <sup>1</sup> + 2 √ó 10 <sup>0</sup> .  Ganzzahlige Datentypen haben eine feste Gr√∂√üe, z. B. 16 Bit (Zahlen von 0 bis 65535).  Sie werden als zwei Bytes im Speicher gespeichert, beispielsweise 432 <sub>10</sub> = 01b0 <sub>16</sub> , dh Bytes 01 und b0. <br><br>  Drucken Sie die Bytes dieser Nummer: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdio&gt; // printf() #include &lt;cstdint&gt; // uint8_t, uint16_t int main() { uint16_t value = 0x01b0; printf("%04x\n", value); const auto bytes = reinterpret_cast&lt;const uint8_t*&gt;(&amp;value); for (auto i = 0; i &lt; sizeof(value); i++) { printf("%02x ", bytes[i]); } }</span></span></span></span></code> </pre><br>  Auf normalen Intel- oder AMD (x86) -Prozessoren erhalten wir Folgendes: <br><br><pre> <code class="plaintext hljs">01b0 b0 01</code> </pre><br>  Bytes im Speicher befinden sich vom j√ºngsten zum √§ltesten und nicht wie beim Schreiben von Zahlen.  Diese Reihenfolge wird <i>Little-Endian (LE) genannt.</i>  Gleiches gilt f√ºr 4-Byte-Zahlen.  Die Bytereihenfolge wird durch die Prozessorarchitektur bestimmt.  Die "native" Reihenfolge f√ºr den Prozessor wird auch als <i>Reihenfolge der CPU oder des Hosts (CPU / Host-Bytereihenfolge) bezeichnet.</i>  In unserem Fall ist die Host-Bytereihenfolge Little-Endian. <br><br>  Das Internet wurde jedoch nicht auf x86 geboren, und dort war die Bytereihenfolge unterschiedlich - <i>vom √§ltesten zum j√ºngsten (Big-Endian, BE).</i>  Sie begannen, es in den Headern von Netzwerkprotokollen (IP, TCP, UDP) zu verwenden, daher wird der Big-Endian auch als <i>Netzwerkbyte-Reihenfolge bezeichnet.</i> <br><br>  Beispiel: Port 443 (1bb <sub>16</sub> ), der HTTPS verwendet, wird in die TCP-Header-Bytes bb 01 geschrieben, die beim Lesen bb01 <sub>16</sub> = 47873 ergeben. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  uint16_t  uint32_t     . struct tcp_hdr { uint16_t th_sport; uint16_t th_dport; uint32_t th_seq; uint32_t th_ack; uint32_t th_flags2 : 4; uint32_t th_off : 4; uint8_t th_flags; uint16_t th_win; uint16_t th_sum; uint16_t th_urp; } __attribute__((__packed__)); tcp_hdr* tcp = ...; //      // : dst_port  BE,  443  LE. if (tcp-&gt;dst_port == 443) { ... } // : ++  LE,  sent_seq  BE. tcp-&gt;sent_seq++;</span></span></code> </pre><br>  Die Bytereihenfolge einer Zahl kann konvertiert werden.  F√ºr <code>uint16_t</code> gibt es beispielsweise eine Standardfunktion <code>htons()</code> ( <b>h</b> ost <b>bis</b> <b>n</b> etwork f√ºr eine kurze Ganzzahl - von der <code>ntohs()</code> zur Netzwerkreihenfolge f√ºr kurze Ganzzahlen) und die umgekehrte <code>ntohs()</code> .  In √§hnlicher Weise gibt es f√ºr <code>uint32_t</code> <code>htonl()</code> und <code>ntohl()</code> (long ist eine lange ganze Zahl). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// :  BE    BE . if (tcp-&gt;dst_port == htons(443)) { ... } //   BE     LE,   1, //   LE    BE. tcp-&gt;sent_seq = htonl(ntohl(tcp-&gt;sent_seq) + 1);</span></span></code> </pre><br>  Leider wei√ü der Compiler nicht, woher der spezifische Wert einer Variablen vom Typ <code>uint32_t</code> stammt, und warnt nicht, wenn Sie Werte mit unterschiedlichen Bytereihenfolgen mischen und ein falsches Ergebnis erhalten. <br><br><h2>  Starkes Tippen </h2><br>  Das Risiko einer Verwechslung der Bytereihenfolge liegt auf der Hand. Wie geht man damit um? <br><br><ul><li>  <b>Code√ºberpr√ºfung.</b>  Dies ist ein obligatorisches Verfahren in unserem Projekt.  Leider wollen die Tester am allerwenigsten in den Code <code>htons()</code> , der Bytes manipuliert: ‚ÄûIch sehe <code>htons()</code> - wahrscheinlich hat der Autor √ºber alles nachgedacht‚Äú. </li><li>  <b>Disziplin,</b> Regeln wie: BE nur in Paketen, alle Variablen in LE.  Es ist beispielsweise nicht immer sinnvoll, Ports anhand einer Hash-Tabelle zu √ºberpr√ºfen. Es ist effizienter, sie in der Reihenfolge der Netzwerkbytes zu speichern und "wie sie sind" zu suchen. </li><li>  <b>Tests.</b>  Wie Sie wissen, garantieren sie nicht die Abwesenheit von Fehlern.  Daten k√∂nnen schlecht √ºbereinstimmen (1.1.1.1 √§ndert sich beim Konvertieren der Bytereihenfolge nicht) oder an das Ergebnis angepasst werden. </li></ul><br>  Wenn Sie mit einem Netzwerk arbeiten, k√∂nnen Sie die Bytereihenfolge nicht ignorieren, daher m√∂chte ich es unm√∂glich machen, sie beim Schreiben von Code zu ignorieren.  Dar√ºber hinaus haben wir nicht nur eine Nummer in BE - es ist eine Portnummer, IP-Adresse, TCP-Sequenznummer, Pr√ºfsumme.  Eines kann keinem anderen zugewiesen werden, selbst wenn die Anzahl der Bits √ºbereinstimmt. <br><br>  Die L√∂sung ist bekannt - strikte Typisierung, dh separate Typen f√ºr Ports, Adressen, Nummern.  Dar√ºber hinaus m√ºssen diese Typen die BE / LE-Konvertierung unterst√ºtzen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost.Endian</a> passt nicht zu uns, da das Projekt keinen Boost enth√§lt. <br><br>  Die Projektgr√∂√üe betr√§gt in C ++ 17 ungef√§hr 40.000 Zeilen.  Wenn Sie sichere Wrapper-Typen erstellen und Header-Strukturen √ºberschreiben, werden alle Stellen, an denen mit BE gearbeitet wird, automatisch nicht mehr kompiliert.  Wir m√ºssen sie alle einmal durchgehen, aber der neue Code ist nur sicher. <br><br><div class="spoiler">  <b class="spoiler_title">Big-Endian-Klassennummer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdint&gt; #include &lt;iosfwd&gt; #define PACKED __attribute__((packed)) constexpr auto bswap(uint16_t value) noexcept { return __builtin_bswap16(value); } constexpr auto bswap(uint32_t value) noexcept { return __builtin_bswap32(value); } template&lt;typename T&gt; struct Raw { T value; }; template&lt;typename T&gt; Raw(T) -&gt; Raw&lt;T&gt;; template&lt;typename T&gt; struct BigEndian { using Underlying = T; using Native = T; constexpr BigEndian() noexcept = default; constexpr explicit BigEndian(Native value) noexcept : _value{bswap(value)} {} constexpr BigEndian(Raw&lt;Underlying&gt; raw) noexcept : _value{raw.value} {} constexpr Underlying raw() const { return _value; } constexpr Native native() const { return bswap(_value); } explicit operator bool() const { return static_cast&lt;bool&gt;(_value); } bool operator==(const BigEndian&amp; other) const { return raw() == other.raw(); } bool operator!=(const BigEndian&amp; other) const { return raw() != other.raw(); } friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const BigEndian&amp; value) { return out &lt;&lt; value.native(); } private: Underlying _value{}; } PACKED;</span></span></span></span></code> </pre><br></div></div><br><ul><li>  Eine Header-Datei dieses Typs wird √ºberall enthalten sein, sodass anstelle eines schweren <code>&lt;iostream&gt;</code> ein leichtes <code>&lt;iosfwd&gt;</code> . </li><li>  Anstelle von <code>htons()</code> usw. - schnelle Compiler-Eigenschaften.  Insbesondere sind sie <code>constexpr</code> konstanten Ausbreitung <code>constexpr</code> , daher <code>constexpr</code> Konstruktoren. </li><li>  Manchmal befindet sich in BE bereits ein Wert f√ºr <code>uint16_t</code> / <code>uint32_t</code> .  Mit der <code>Raw&lt;T&gt;</code> -Struktur mit dem <code>BigEndian&lt;T&gt;</code> k√∂nnen Sie bequem einen <code>BigEndian&lt;T&gt;</code> daraus erstellen. </li></ul><br>  Der umstrittene Punkt hier ist <code>PACKED</code> : <code>PACKED</code> Strukturen werden als weniger optimierbar angesehen.  Die einzige Antwort ist zu messen.  Unsere Code-Benchmarks zeigten keine Verlangsamungen.  Au√üerdem ist bei Netzwerkpaketen die Position der Felder im Header immer noch fest. <br><br>  In den meisten F√§llen ben√∂tigt BE keine anderen Operationen als den Vergleich.  Sequenznummern m√ºssen mit LE korrekt gefaltet werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE16 = BigEndian&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE32 = BigEndian&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Seqnum</span></span></span><span class="hljs-class"> :</span></span> BE32 { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE32::BE32; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Integral&gt; Seqnum <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Integral increment) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_integral_v&lt;Integral&gt;); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Seqnum{<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(native() + increment)}; } } PACKED; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IP</span></span></span><span class="hljs-class"> :</span></span> BE32 { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE32::BE32; } PACKED; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">L4Port</span></span></span><span class="hljs-class"> :</span></span> BE16 { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BE16::BE16; } PACKED;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Sichere TCP-Header-Struktur</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TCPFlag : <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> { TH_FIN = <span class="hljs-number"><span class="hljs-number">0x01</span></span>, TH_SYN = <span class="hljs-number"><span class="hljs-number">0x02</span></span>, TH_RST = <span class="hljs-number"><span class="hljs-number">0x04</span></span>, TH_PUSH = <span class="hljs-number"><span class="hljs-number">0x08</span></span>, TH_ACK = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, TH_URG = <span class="hljs-number"><span class="hljs-number">0x20</span></span>, TH_ECE = <span class="hljs-number"><span class="hljs-number">0x40</span></span>, TH_CWR = <span class="hljs-number"><span class="hljs-number">0x80</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCPFlags = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">underlying_type_t</span></span>&lt;TCPFlag&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCPHeader</span></span></span><span class="hljs-class"> {</span></span> L4Port th_sport; L4Port th_dport; Seqnum th_seq; Seqnum th_ack; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> th_flags2 : <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> th_off : <span class="hljs-number"><span class="hljs-number">4</span></span>; TCPFlags th_flags; BE16 th_win; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> th_sum; BE16 th_urp; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> header_length() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> th_off &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_header_length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ th_off = len &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* payload() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) + header_length(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> uint8_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) + header_length(); } }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(TCPHeader) == <span class="hljs-number"><span class="hljs-number">20</span></span>);</code> </pre></div></div><br><ul><li>  <code>TCPFlag</code> k√∂nnte zu einer <code>enum class</code> , aber in der Praxis werden nur zwei Operationen an Flags ausgef√ºhrt: √úberpr√ºfen des Eintrags ( <code>&amp;</code> ) oder Ersetzen der Flags durch eine Kombination ( <code>|</code> ) - es gibt keine Verwirrung. </li><li>  Bitfelder bleiben primitiv, es werden jedoch sichere Zugriffsmethoden erstellt. </li><li>  Feldnamen bleiben klassisch. </li></ul><br><h2>  Ergebnisse </h2><br>  Die meisten √Ñnderungen waren trivial.  Der Code ist sauberer: <br><br><pre> <code class="diff hljs"> auto tcp = packet-&gt;tcp_header(); - return make_response(packet, - cookie_make(packet, rte_be_to_cpu_32(tcp-&gt;th_seq)), - rte_cpu_to_be_32(rte_be_to_cpu_32(tcp-&gt;th_seq) + 1), - TH_SYN | TH_ACK); + return make_response(packet, cookie_make(packet, tcp-&gt;th_seq.native()), + tcp-&gt;th_seq + 1, TH_SYN | TH_ACK); }</code> </pre><br>  Zum Teil dokumentierten die Typen den Code: <br><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- void check_packet(int64_t, int64_t, uint8_t, bool); + void check_packet(std::optional&lt;Seqnum&gt;, std::optional&lt;Seqnum&gt;, TCPFlags, bool);</span></span></code> </pre><br>  Pl√∂tzlich stellte sich heraus, dass Sie die Gr√∂√üe des TCP-Fensters falsch lesen k√∂nnen, w√§hrend Unit-Tests bestanden werden und sogar der Datenverkehr verfolgt wird: <br><br><pre> <code class="diff hljs"> //  window size auto wscale_ratio = options().wscale_dst - options().wscale_src; if (wscale_ratio &lt; 0) { - auto window_size = header.window_size() / (1 &lt;&lt; (-wscale_ratio)); + auto window_size = header.window_size().native() / (1 &lt;&lt; (-wscale_ratio)); if (header.window_size() &amp;&amp; window_size &lt; 1) { window_size = WINDOW_SIZE_MIN; } header_out.window_size(window_size); } else { - auto window_size = header.window_size() * (1 &lt;&lt; (wscale_ratio)); + auto window_size = header.window_size().native() * (1 &lt;&lt; (wscale_ratio)); if (window_size &gt; WINDOW_SIZE_MAX) { window_size = WINDOW_SIZE_MAX; }</code> </pre><br>  Beispiel f√ºr einen logischen Fehler: Der Entwickler des urspr√ºnglichen Codes dachte, dass die Funktion BE akzeptiert, obwohl dies tats√§chlich nicht der Fall ist.  Beim Versuch, <code>Raw{}</code> anstelle von <code>0</code> Programm einfach nicht kompiliert (zum Gl√ºck ist dies nur ein Komponententest).  Sofort sehen wir eine erfolglose Auswahl von Daten: Der Fehler w√§re fr√ºher gefunden worden, wenn er nicht 0 verwendet worden w√§re, was in jeder Bytereihenfolge gleich ist. <br><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- auto cookie = cookie_make_inner(tuple, rte_be_to_cpu_32(0)); + auto cookie = cookie_make_inner(tuple, 0);</span></span></code> </pre><br>  Ein √§hnliches Beispiel: Zuerst wies der Compiler auf die <code>def_seq</code> zwischen den Typen <code>def_seq</code> und <code>cookie</code> , dann wurde klar, warum der Test fr√ºher bestanden wurde - solche Konstanten. <br><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- const uint32_t def_seq = 0xA7A7A7A7; - const uint32_t def_ack = 0xA8A8A8A8; + const Seqnum def_seq{0x12345678}; + const Seqnum def_ack{0x90abcdef}; ... - auto cookie = rte_be_to_cpu_32(_tcph-&gt;th_ack); + auto cookie = _tcph-&gt;th_ack; ASSERT_NE(def_seq, cookie);</span></span></code> </pre><br><h2>  Zusammenfassung </h2><br>  Das Fazit lautet: <br><br><ul><li>  In Unit-Tests wurden ein Fehler und mehrere logische Fehler gefunden. </li><li>  Durch das Refactoring konnte ich zweifelhafte Stellen aussortieren und die Lesbarkeit verbessern. </li><li>  Die Leistung wurde beibehalten, h√§tte aber sinken k√∂nnen - Benchmarks sind erforderlich. </li></ul><br>  Alle drei Punkte sind uns wichtig, daher denken wir, dass sich das Refactoring gelohnt hat. <br><br>  Versichern Sie sich gegen Fehler mit strengen Typen? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471272/">https://habr.com/ru/post/de471272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471262/index.html">Holivar. Geschichte von Runet. Teil 5. Trolle: Lernen, hektischer Drucker, Kupfer</a></li>
<li><a href="../de471264/index.html">Eine Alternative zu Mailchimp w√§hlen: Warum wechseln und welches Produkt w√§hlen?</a></li>
<li><a href="../de471266/index.html">Die Zukunft ist hier oder direkt im Browser verschl√ºsselt</a></li>
<li><a href="../de471268/index.html">Nachrichtenbroker verstehen. Erlernen der Mechanismen des Messaging √ºber ActiveMQ und Kafka. Kapitel 2. ActiveMQ</a></li>
<li><a href="../de471270/index.html">Automatisieren Sie den Empfang von Daten √ºber die Geschwindigkeit des Ladens einer Website aus Google PageSpeed ‚Äã‚ÄãInsights [Vorlage]</a></li>
<li><a href="../de471278/index.html">Texterzeugung in russischer Sprache durch Vorlagen</a></li>
<li><a href="../de471282/index.html">Auf der Suche nach Lungenentz√ºndung bei R√∂ntgenaufnahmen mit Fast.ai</a></li>
<li><a href="../de471288/index.html">Das Gesicht eines Charakters f√ºr das Spiel "OnAir" erstellen</a></li>
<li><a href="../de471294/index.html">Gedichte √ºber Haskell, C ++ und Programmierer</a></li>
<li><a href="../de471296/index.html">Lean Manufacturing - Ein Werkzeug f√ºr Effizienz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>