<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏼 ✍🏽 👇 Kubernetes网络：入口 🤹🏾 🌤️ 🤘🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，我们正在发布《 Kubernetes网络指南》第三部分的翻译。 第一部分是有关Pod的内容， 第二部分是有关服务的内容，今天我们将讨论Ingress类型的负载平衡和Kubernetes资源。 

 路由不平衡负载 
 在本系列的上一篇文章中，我们考虑了由一对炉床和一个服务组成的配置，该服务分配...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes网络：入口</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442646/"> 今天，我们正在发布《 Kubernetes网络指南》第三部分的翻译。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一</a>部分是有关Pod的内容， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二</a>部分是有关服务的内容，今天我们将讨论Ingress类型的负载平衡和Kubernetes资源。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/te/wp/ce/tewpcee5cggzqu97irog_mj_qgo.png"></div><a name="habracut"></a><h2>  <font color="#3AC1EF">路由不平衡负载</font> </h2><br> 在本系列的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上</a>一篇文章中，我们考虑了由一对炉床和一个服务组成的配置，该服务分配有一个称为“集群IP”的IP地址。 针对炉膛的查询已发送到该地址。 从上次毕业的地方开始，我们将在这里继续研究我们的培训系统。 回想一下，该服务的群集IP地址<code>10.3.241.152</code>属于一个IP地址范围，该IP地址范围不同于在炉床网络中使用的IP地址和在节点所在的网络中使用的IP地址。 我将由该地址空间定义的网络称为“服务网络”，尽管几乎没有一个特别的名字，因为没有设备连接到该网络，并且其地址空间实际上完全由路由规则组成。 先前已演示了如何在称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kube-proxy</a>的Kubernetes组件的基础上实现该网络<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>并与Linux内核模块<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">netfilter</a>交互以拦截和重定向发送到IP群集的流量以在其下工作。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/615/35f/1ec/61535f1ec0169dbd13732aba4c9a5621.png"></div><br>  <i><font color="#999999">网络图</font></i> <br><br> 到目前为止，我们讨论了“连接”和“请求”，甚至使用了难以理解的“流量”概念，但是为了理解Kubernetes Ingress机制的特征，我们需要使用更精确的术语。 因此，连接和请求可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OSI模型</a>的第4级（tcp）或第7级（http，rpc等）上工作。  Netfilter规则是路由规则，它们与第三级的IP数据包一起使用。 所有路由器，包括netfilter，都仅根据数据包中包含的信息来或多或少地做出决策。 通常，他们对数据包的来源和去向感兴趣。 因此，为了用OSI模型的第三级来描述此行为，必须说到达<code>eth0</code>节点接口的，位于<code>10.3.241.152:80</code>的服务的每个数据包都由netfilter处理，并根据为我们的服务设置的规则将重定向到可行的壁炉的IP地址。 <br><br> 显然，我们用来允许外部客户端访问Pod的任何机制都应使用相同的路由基础结构。 结果，这些外部客户端将访问群集的IP地址和端口，因为它们是到目前为止我们所讨论的所有机制的“访问点”。 它们使我们不必担心在特定时间点将在何处准确执行它。 但是，如何使它们全部工作还不是很明显。 <br><br> 群集IP服务仅可通过节点的以太网接口访问。 群集外的任何人都不知道该地址所属范围内的地址该怎么做。 仅当数据包已经到达主机时，如何才能将流量从公共IP地址重定向到可访问的地址？ <br><br> 如果我们尝试找到此问题的解决方案，那么寻找解决方案的过程中可以做的一件事情就是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">iptables</a>实用工具研究netfilter规则。 如果这样做，乍看之下可能会发现一些不寻常的发现：服务规则不仅限于特定的源网络。 这意味着，在节点的以太网接口上到达任何地方且目的地地址为<code>10.3.241.152:80</code>任何数据包都将被视为符合规则，并将被重定向到子节点。 我们是否可以给客户一个IP群集，也许是通过将它绑定到一个合适的域名，然后建立一条路由，使我们能够将这些数据包组织到一个节点上呢？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f3/6ba/ea7/5f36baea7589e3559632de385f3f2bf6.png"></div><br>  <i><font color="#999999">外部客户端和集群</font></i> <br><br> 如果一切都以这种方式进行设置，那么这样的设计将可以正常工作。 客户端访问群集IP，数据包遵循通向主机的路由，然后将它们重定向到底部。 目前，您似乎可以限制这种解决方案，但是却遇到了一些严重的问题。 首先是节点，实际上是短暂的概念，它们在这方面与炉膛没有特别的区别。 当然，它们比Pod更加接近于物料世界，但是它们可以迁移到新的虚拟机，集群可以向上或向下扩展，依此类推。 路由器在OSI模型的第三层上工作，数据包无法区分正常工作的服务和不能正常工作的服务。 他们希望路线中的下一个过渡路段容易到达且稳定。 如果该节点不可达，则该路由将无法使用，并且在大多数情况下将保持大量时间。 即使路由能够抵抗故障，这种方案也会导致所有外部流量都流经单个节点这一事实，这可能不是最佳选择。 <br><br> 无论我们如何将客户端流量带入系统，我们都需要这样做，以使其不依赖于任何单个群集节点的状态。 而且，实际上，没有可靠的方法仅使用路由来执行此操作，而没有一些主动管理路由器的方法。 实际上，正是kube-proxy相对于netfilter扮演着这个角色，即控制系统的角色。 对于系统架构师而言，将Kubernetes的职责扩展到管理外部路由器可能没有多大意义，尤其是因为我们已经拥有成熟的工具来在多台服务器之间分配客户端流量。 它们被称为负载平衡器，毫不奇怪，它们是Kubernetes Ingress真正可靠的解决方案。 为了确切地了解这是如何发生的，我们需要从OSI的第三级起步并再次讨论连接。 <br><br> 为了使用负载平衡器在群集节点之间分配客户端流量，我们需要客户端可以连接到的公共IP地址，还需要负载平衡器可以将请求重定向到的节点本身的地址。 由于上述原因，我们不能简单地使用基于服务的网络（IP群集）在网关路由器和节点之间创建稳定的静态路由。 <br><br> 在您可以使用的其他地址中，只有节点的以太网接口所连接的网络地址，即本例中的<code>10.100.0.0/24</code> ，可以被记录<code>10.100.0.0/24</code> 。 路由器已经知道如何将数据包转发到这些接口，并且从负载平衡器发送到路由器的连接将到达它们应该到达的位置。 但是，如果客户端要通过端口80连接到我们的服务，则我们不能只是将数据包发送到节点的网络接口上的该端口。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4cd/c77/40b/4cdc7740be5ecfc3069a8b3fb157c605.png"></div><br>  <i><font color="#999999">负载均衡器，尝试访问主机网络接口的端口80失败</font></i> <br><br> 无法做到这一点的原因是完全显而易见的。 也就是说，我们正在谈论的事实是，没有进程在<code>10.100.0.3:80</code>等待连接（如果存在，则肯定不是同一进程），并且netfilter规则（正如我们希望的那样）将拦截请求并他们会将其发送给他，但无法在该目标地址使用。 它们仅响应基于服务的群集IP网络，即地址<code>10.3.241.152:80</code> 。 结果，这些数据包一到达，就无法传递到目标地址，内核将发出<code>ECONNREFUSED</code>响应。 这使我们处于一个混乱的境地：在将数据从网关重定向到节点时，很难与网络一起工作以将数据包重定向到netfilter配置到的网络，并且易于配置路由的网络不是netfilter将数据包重定向到的网络。 为了解决此问题，您可以在这些网络之间建立桥梁。 这正是Kubernetes使用NodePort之类的服务所做的事情。 <br><br><h2>  <font color="#3AC1EF">像NodePort这样的服务</font> </h2><br> 例如，我们在上一篇文章中创建的服务未分配类型，因此它采用了默认类型<code>ClusterIP</code> 。 还有两种类型的服务在附加功能方面有所不同，而我们现在感兴趣的一种是<code>NodePort</code> 。 这是对此类型的服务的描述示例： <br><br><pre> <code class="plaintext hljs">kind: Service apiVersion: v1 metadata: name: service-test spec: type: NodePort selector:   app: service_test_pod ports: - port: 80   targetPort: http</code> </pre> <br>  <code>NodePort</code>类型的服务是具有额外机会的<code>ClusterIP</code>类型的服务：可以通过分配给主机的IP地址和服务网络中分配给集群的地址来访问它们。 这可以通过一种非常简单的方式来实现：当Kubernetes创建NodePort服务时，kube-proxy会在30000-32767范围内分配一个端口，并在每个节点的<code>eth0</code>接口上打开该端口（因此，服务类型的名称为<code>NodePort</code> ）。 与此端口（我们称为此类<code>NodePort</code>端口）建立的连接将重定向到服务的群集IP。 如果我们创建上述服务并运行<code>kubectl get svc service-test</code>命令，我们可以看到为其分配的端口。 <br><br><pre> <code class="plaintext hljs">$ kubectl get svc service-test NAME           CLUSTER-IP EXTERNAL-IP   PORT(S) AGE service-test   10.3.241.152 &lt;none&gt;        80:32213/TCP 1m</code> </pre> <br> 在这种情况下，将为该服务分配NodePort <code>32213</code> 。 这意味着我们现在可以通过实验集群中位于<code>10.100.0.2:32213</code>或<code>10.100.0.3:32213</code>任何节点连接到服务。 在这种情况下，流量将被重定向到服务。 <br><br> 在系统的这一部分取代之后，我们就拥有了管道的所有片段，用于平衡客户端请求对集群所有节点产生的负载。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da5/78e/735/da578e735e468dce8077f8a1d27d8490.png"></div><br>  <i><font color="#999999">NodePort服务</font></i> <br><br> 在上图中，客户端通过公共IP地址连接到负载均衡器，负载均衡器选择节点并以<code>10.100.0.3:32213</code>连接到该节点，kube-proxy接受此连接并将其重定向到可通过群集IP <code>10.3.241.152:80</code>访问的服务。 。 在此，根据netfilter设置的规则成功处理了请求，并将其重定向到地址为<code>10.0.2.2:8080</code>的服务器pod。 也许所有这些看起来都有些复杂，并且在某种程度上看起来有些复杂，但是要想找到一个简单的解决方案来支持我们的Pod和基于服务的网络的所有重要功能，这并不容易。 <br><br> 但是，这种机制并非没有其自身的问题。 使用诸如<code>NodePort</code>服务，可使客户使用非标准端口访问服务。 通常这不是问题，因为负载平衡器可以为它们提供常规端口， <code>NodePort</code>最终用户隐藏<code>NodePort</code> 。 但是在某些情况下，例如，当使用外部Google Cloud平台负载平衡器时，可能有必要将<code>NodePort</code>部署<code>NodePort</code>客户端。 应该注意的是，尽管即使对于最大的群集来说，2768个端口也可能足够，但此类端口还代表有限的资源。 在大多数情况下，您可以让Kubernetes随机选择端口号，但必要时可以自行设置。 另一个问题是有关请求中源IP地址存储的一些限制。 为了找到解决这些问题的方法，您可以从Kubernetes文档中参考<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该</a>材料。 <br><br> 端口<code>NodePorts</code>是所有外部流量进入Kubernetes集群的基本机制。 但是，他们自己并没有为我们提供现成的解决方案。 由于上述原因，在群集之前，无论客户端是位于公共网络中的内部还是外部实体，始终都需要具有某种负载平衡器。 <br><br> 平台架构师意识到了这一点，提供了两种从Kubernetes平台本身配置负载均衡器的方法。 让我们讨论一下。 <br><br><h2>  <font color="#3AC1EF">诸如LoadBalancer之类的服务和Ingress类型的资源</font> </h2><br> 诸如<code>LoadBalancer</code>服务和<code>Ingress</code>类型的资源是一些最复杂的Kubernetes机制。 但是，我们不会在它们上花费太多时间，因为到目前为止，我们所谈论的一切并不会导致根本改变。 与以前一样，所有外部流量都通过<code>NodePort</code>进入集群。 <br><br> 架构师可以在这里停下来，让创建群集的人员只关心公共IP地址和负载平衡器。 实际上，在某些情况下，例如在常规服务器上或在家中启动集群，这正是它们所做的。 但是在支持API控制的网络资源配置的环境中，Kubernetes允许您在一处配置所需的一切。 <br><br> 最简单的解决此问题的方法是使用Kubernetes服务，例如<code>LoadBalancer</code> 。 此类服务具有<code>NodePort</code>等服务的所有功能，此外还具有基于群集运行在通过API支持网络资源配置的GCP或AWS等环境中的假设来为传入流量创建完整路径的能力。 <br><br><pre> <code class="plaintext hljs">kind: Service apiVersion: v1 metadata: name: service-test spec: type: LoadBalancer selector:   app: service_test_pod ports: - port: 80   targetPort: http</code> </pre> <br> 如果我们从Google Kubernetes Engine中的示例中删除并重新创建该服务，则此后不久，使用<code>kubectl get svc service-test</code>命令，我们可以验证是否已分配了外部IP。 <br><br><pre> <code class="plaintext hljs">$ kubectl get svc service-test NAME      CLUSTER-IP      EXTERNAL-IP PORT(S)          AGE openvpn   10.3.241.52     35.184.97.156 80:32213/TCP     5m</code> </pre> <br> 上面已经说过，尽管需要将外部IP地址分配到健康状态，但分配外部IP可能要花费几分钟，因此我们将能够验证“很快”分配外部IP地址的事实。 例如，在GCP平台上，这要求系统创建外部IP地址，流量重定向规则，目标代理服务器，后端服务以及可能的组实例。 分配外部IP地址后，您可以通过该地址连接到服务，为其分配域名并通知客户端。 在销毁并重新创建服务之前（为了这样做，很少有充分的理由），IP地址不会更改。 <br><br> 诸如<code>LoadBalancer</code>服务有一些限制。 无法将此类服务配置为解密HTTPS通信。 您无法创建虚拟主机或配置基于路径的路由，因此，不能通过实际配置将单个负载均衡器与许多服务一起使用。 这些限制导致引入了Kubernetes 1.1。 用于配置负载均衡器的特殊资源。 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ingress</a>类型的资源。 诸如<code>LoadBalancer</code>类的服务旨在扩展单个服务的功能以支持外部客户端。 相反， <code>Ingress</code>资源是特殊资源，可让您灵活地配置负载均衡器。  Ingress API支持TLS流量，虚拟主机和基于路径的路由的解密。 使用此API，可以轻松配置负载平衡器以与多个后端服务一起使用。 <br><br>  <code>Ingress</code>类型的资源API太大，无法在此处讨论其功能；此外，它不会特别影响Ingress资源在网络级别的工作方式。 该资源的实现遵循通常的Kubernetes模式：存在一个资源类型和一个控制该类型的控制器。 在这种情况下，资源是<code>Ingress</code>资源，它描述对网络资源的请求。 这是<code>Ingress</code>资源的描述可能会是什么样的。 <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Ingress metadata: name: test-ingress annotations:   kubernetes.io/ingress.class: "gce" spec: tls:   - secretName: my-ssl-secret rules: - host: testhost.com   http:     paths:     - path: /*       backend:         serviceName: service-test         servicePort: 80</code> </pre> <br> 入口控制器负责通过将其他资源置于所需状态来执行这些请求。 使用Ingress时，会创建诸如<code>NodePort</code>类的服务，然后允许Ingress控制器决定如何将流量定向到节点。 对于GCE负载平衡器，AWS平衡器，流行的代理服务器（例如nginx和haproxy），有一个Ingress控制器实现。 请注意，在某些环境中，混合使用Ingress资源和服务（例如<code>LoadBalancer</code>可能会引起较小的问题。 它们易于处理，但是通常，即使是简单的服务，也最好只使用Ingress。 <br><br><h2>  <font color="#3AC1EF">HostPort和HostNetwork</font> </h2><br> 我们现在要谈论的内容，即<code>HostPort</code>和<code>HostNetwork</code> ，可以归因于有趣的稀有类别，而不是有用的工具。 实际上，我承诺断言，在99.99％的情况下，可以将它们的使用视为反模式，并且使用它们的任何系统都必须对其结构进行强制检查。 <br><br> 我认为根本不值得讨论它们，但是它们就像Ingress资源用来处理传入流量的工具一样，因此我认为至少值得一提。 <br><br> 首先， <code>HostPort</code>谈谈<code>HostPort</code> 。 这是一个容器属性（在<code>ContainerPort</code>结构中声明）。 当在其中写入端口号时，这将导致该端口在节点上打开并直接重定向到容器。 没有代理机制，并且端口仅在运行容器的节点上打开。 在该平台的早期，在出现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DaemonSet</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">StatefulSet</a>机制之前， <code>HostPort</code>是一种技巧，它使得在任何节点上仅启动一个特定类型的容器成为可能。 例如，我曾经通过将<code>HostPort</code>设置为<code>9200</code>并指定与节点数一样多的副本来创建Elasticsearch集群。       ,          Kubernetes,    -     <code>HostPort</code> . <br><br>   <code>NostNetwork</code> , ,   Kubernetes    ,  <code>HostPort</code> .       <code>true</code> ,       - <code>network=host</code>  <code>docker run</code> .    ,           .            <code>eth0</code>    .  ,             .      ,  ,  ,    Kubernetes,     - . <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br>        Kubernetes,   ,          Ingress. ,  ,    ,       Kubernetes. <br><br>  <b>亲爱的读者们！</b>     Ingress? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN442646/">https://habr.com/ru/post/zh-CN442646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN442636/index.html">您会给管理层带来坏消息吗？</a></li>
<li><a href="../zh-CN442638/index.html">基于Prometheus指标的Kubernetes应用扩展</a></li>
<li><a href="../zh-CN442640/index.html">完美的错误：在Flash中使用类型混淆。 第一部分</a></li>
<li><a href="../zh-CN442642/index.html">三月份阅读内容：针对营销人员，管理人员，开发人员和设计师的22本新书</a></li>
<li><a href="../zh-CN442644/index.html">大多数非编程技能可提高开发人员价值</a></li>
<li><a href="../zh-CN442648/index.html">去分配机制</a></li>
<li><a href="../zh-CN442650/index.html">React应用程序的分析和优化</a></li>
<li><a href="../zh-CN442652/index.html">使用Fastify和Preact快速原型化Web应用程序</a></li>
<li><a href="../zh-CN442654/index.html">切换到Next.js并加快歧管网站首页的加载7.5倍</a></li>
<li><a href="../zh-CN442658/index.html">使用CSS的8个技巧：视差，粘页脚等</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>