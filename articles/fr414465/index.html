<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèª üè¢ üëèüèº Meta Crush Saga: jeu de compilation üë©üèΩ‚ÄçüöÄ ‚ÜòÔ∏è üèòÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le processus de transition vers le titre tant attendu de Lead Senior C ++ Over-Engineer , l'ann√©e derni√®re, j'ai d√©cid√© de r√©√©crire le jeu que je...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta Crush Saga: jeu de compilation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414465/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif" alt="image"></div><br>  Dans le processus de transition vers le titre tant attendu de <strong>Lead Senior C ++ Over-Engineer</strong> , l'ann√©e derni√®re, j'ai d√©cid√© de r√©√©crire le jeu que je d√©veloppe pendant les heures de travail (Candy Crush Saga), en utilisant la quintessence du C ++ moderne (C ++ 17).  Et c'est ainsi que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Meta Crush Saga</a> est n√©e: un <strong>jeu qui tourne au stade de la compilation</strong> .  J'ai √©t√© tr√®s inspir√© par le jeu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nibbler de</a> Matt Birner, qui utilisait de la m√©taprogrammation pure sur des mod√®les pour recr√©er le c√©l√®bre Snake avec le Nokia 3310. <br><br>  "Quel type de <strong>jeu ex√©cute-t-il au stade de la compilation</strong> ?", "A quoi cela ressemble-t-il?", "Quelles fonctionnalit√©s de <strong>C ++ 17</strong> avez-vous utilis√©es dans ce projet?", "Qu'avez-vous appris?"  - Des questions similaires peuvent vous venir √† l'esprit.  Pour y r√©pondre, vous devrez soit lire l'int√©gralit√© du message, soit supporter votre paresse int√©rieure et regarder une version vid√©o du message - mon rapport de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©v√©nement Meetup</a> √† Stockholm: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XV1lXtB3sqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Remarque: dans l'int√©r√™t de votre sant√© mentale et parce que <em>errare humanum est</em> , certains faits alternatifs sont donn√©s dans cet article. <br><a name="habracut"></a><br><h2>  Un jeu qui tourne au moment de la compilation? </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61c/1ab/166/61c1ab166775d7f49e32620b72abb6e4.png"></div><br>  Je pense que pour comprendre ce que j'entends par le "concept" d'un <strong>jeu ex√©cut√© au stade de la compilation</strong> , il faut comparer le cycle de vie d'un tel jeu avec le cycle de vie d'un jeu ordinaire. <br><br><h3>  Le cycle de vie d'un jeu r√©gulier: </h3><br>  En tant que d√©veloppeur r√©gulier de jeux avec une vie normale, travaillant sur un travail r√©gulier avec un niveau de sant√© mentale normal, vous commencez g√©n√©ralement par √©crire la <strong>logique du jeu</strong> dans votre langue pr√©f√©r√©e (en C ++, bien s√ªr!), Puis ex√©cutez le <strong>compilateur</strong> pour convertir trop souvent ces spaghettis logique dans un <strong>fichier ex√©cutable</strong> .  Apr√®s avoir double-cliqu√© sur le <strong>fichier ex√©cutable</strong> (ou √† partir de la console), le syst√®me d'exploitation g√©n√®re un <strong>processus</strong> .  Ce <strong>processus</strong> ex√©cutera la <strong>logique</strong> du <strong>jeu</strong> , qui consiste en un <strong>cycle de jeu</strong> dans 99,42% du temps.  <strong>Le cycle de jeu</strong> <strong>met √† jour l'</strong> √©tat du jeu conform√©ment √† certaines r√®gles et √† <strong>l'entr√©e de l'utilisateur</strong> , <strong>rend le</strong> nouvel √©tat calcul√© du jeu en pixels, encore et encore et encore. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/e6c/3b2/7bce6c3b238299f98b6c16e339aa5b10.png"></div><br><h3>  Le cycle de vie d'un jeu en cours de compilation: </h3><br>  En tant que sur-ing√©nieur qui cr√©e son nouveau jeu de compilation sympa, vous utilisez toujours votre langage pr√©f√©r√© (toujours en C ++, bien s√ªr!) Pour √©crire la <strong>logique du jeu</strong> .  Puis, comme pr√©c√©demment, <strong>la phase de compilation se</strong> poursuit, mais il y a une torsion de l'intrigue: vous <strong>ex√©cutez</strong> votre <strong>logique de jeu</strong> au stade de la compilation.  Vous pouvez l'appeler ¬´ex√©cution¬ª (compilation).  Et ici, C ++ est tr√®s utile;  il a des fonctionnalit√©s telles que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Template Meta Programming (TMP)</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">constexpr</a> qui vous permettent d'effectuer des <strong>calculs</strong> dans la <strong>phase de compilation</strong> .  Plus tard, nous consid√©rerons les fonctionnalit√©s qui peuvent √™tre utilis√©es pour cela.  √âtant donn√© qu'√† ce stade, nous ex√©cutons la <strong>logique du</strong> jeu, nous devons √©galement ins√©rer √† ce moment <strong>-l√† l'entr√©e du joueur</strong> .  √âvidemment, notre compilateur cr√©era toujours un <strong>fichier ex√©cutable</strong> en sortie.  √Ä quoi peut-il servir?  Le fichier ex√©cutable ne contiendra plus <strong>la boucle du jeu</strong> , mais il a une mission tr√®s simple: afficher un nouvel <strong>√©tat calcul√©</strong> .  Appelons ce <strong>fichier ex√©cutable le</strong> <strong>rendu</strong> , et <strong>les donn√©es qu'il</strong> <strong>rend</strong> sont <strong>rendues</strong> .  Dans notre <strong>rendu,</strong> ni beaux effets de particules ni ombres d'occlusion ambiante ne seront contenus, ce sera ASCII.  Le <strong>rendu</strong> ASCII <strong>du</strong> nouvel <strong>√©tat</strong> calcul√© est une propri√©t√© pratique qui peut √™tre facilement d√©montr√©e au lecteur, mais en plus, nous le copions dans un fichier texte.  Pourquoi un fichier texte?  √âvidemment, car il peut √™tre en quelque sorte combin√© avec le <strong>code</strong> et r√©p√©ter toutes les √©tapes pr√©c√©dentes, obtenant ainsi une <strong>boucle</strong> . <br><br>  Comme vous pouvez d√©j√† le comprendre, le jeu <strong>ex√©cut√© pendant le processus de compilation</strong> consiste en un <strong>cycle de jeu</strong> dans lequel chaque <strong>image du</strong> jeu est une <strong>√©tape de compilation</strong> .  Chaque <strong>√©tape de la compilation</strong> calcule un nouvel <strong>√©tat du</strong> jeu, qui peut √™tre montr√© au joueur et ins√©r√© dans la <strong>trame</strong> / <strong>√©tape suivante de la compilation</strong> . <br><br>  Vous pouvez contempler ce magnifique diagramme autant que vous le souhaitez jusqu'√† ce que vous compreniez ce que je viens d'√©crire: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/2b8/d88/95c2b8d88aa04173139e82f9b4410cd9.png"></div><br>  Avant d'entrer dans les d√©tails de la mise en ≈ìuvre d'un tel cycle, je suis s√ªr que vous voulez me poser la seule question ... <br><br><h3>  "Pourquoi s'emb√™ter √† faire √ßa?" </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/695/1db/ec8/6951dbec8feeb002a132f801ea6866ed.png"></div><br>  Pensez-vous vraiment que ruiner mon idylle de m√©taprogrammation C ++ est une question si fondamentale?  Oui, pour rien dans la vie! <br><br><ul><li>  La premi√®re chose et la plus importante est <strong>que le jeu ex√©cut√© au stade de la compilation</strong> aura une vitesse d'ex√©cution incroyable, car la majeure partie des calculs sont effectu√©s pendant la <strong>phase de compilation</strong> .  La vitesse d'ex√©cution est la cl√© du succ√®s de notre jeu AAA avec des graphismes ASCII! </li><li>  Vous r√©duisez la probabilit√© que certains crustac√©s apparaissent dans votre r√©f√©rentiel et vous demandez de r√©√©crire le jeu dans <strong>Rust</strong> .  Son discours bien pr√©par√© s'effondrera d√®s que vous lui expliquerez qu'un pointeur invalide ne peut pas exister au moment de la compilation.  <strong>Les</strong> programmeurs confiants <strong>de Haskell</strong> peuvent m√™me confirmer la <strong>s√©curit√© des types</strong> dans votre code. </li><li>  Vous gagnerez le respect du royaume <strong>Javascript</strong> hipster, dans lequel tout cadre repens√© avec un fort syndrome NIH peut r√©gner, √† condition qu'il trouve un nom sympa. </li><li>  Un de mes amis disait que n'importe quelle ligne de code Perl peut √™tre utilis√©e de facto comme un mot de passe tr√®s fort.  Je suis s√ªr qu'il n'a jamais essay√© de g√©n√©rer des mots de passe √† partir de la <strong>compilation C ++</strong> . </li></ul><br>  Comment?  √ätes-vous satisfait de mes r√©ponses?  Alors peut-√™tre que votre question devrait √™tre: "Comment r√©ussissez-vous m√™me √† faire cela?" <br><br>  En fait, je voulais vraiment exp√©rimenter avec les fonctionnalit√©s ajout√©es en <strong>C ++ 17</strong> .  Un certain nombre de fonctionnalit√©s sont destin√©es √† augmenter l'efficacit√© du langage, ainsi que pour la m√©taprogrammation (principalement constexpr).  J'ai pens√© qu'au lieu d'√©crire de petits exemples de code, il serait beaucoup plus int√©ressant de transformer tout cela en jeu.  Les projets pour animaux de compagnie sont un excellent moyen d'apprendre des concepts que vous n'avez pas souvent √† utiliser dans votre travail.  La possibilit√© d'ex√©cuter la logique de jeu de base au moment de la compilation prouve √† nouveau que les mod√®les et constepxr sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des sous-</a> ensembles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Turing-complets</a> du langage C ++. <br><br><h2>  Revue du jeu Meta Crush Saga </h2><br><h3>  Match 3: </h3><br>  <strong>Meta Crush Saga</strong> est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeu de jonction de tuiles</a> similaire √† <strong>Bejeweled</strong> et <strong>Candy Crush Saga</strong> .  Le c≈ìur des r√®gles du jeu est de connecter trois tuiles avec le m√™me motif pour obtenir des points.  Voici un bref aper√ßu de l' <strong>√©tat du jeu</strong> que j'ai ¬´vid√©¬ª (le dumping en ASCII est sacr√©ment facile √† obtenir): <br><br><pre>  R "(
     Saga Meta Crush      
 ------------------------  
 |  | 
 |  RBGBBYGR | 
 |  | 
 |  | 
 |  YYGRBGBR | 
 |  | 
 |  | 
 |  RBYRGRYG | 
 |  | 
 |  | 
 |  RYBY (R) YGY | 
 |  | 
 |  | 
 |  BGYRYGGR | 
 |  | 
 |  | 
 |  RYBGYBBG | 
 |  | 
 ------------------------  
 &gt; score: 9009
 &gt; coups: 27
 ) " </pre><br><br>  Le gameplay de ce jeu Match-3 lui-m√™me n'est pas particuli√®rement int√©ressant, mais qu'en est-il de l'architecture sur laquelle tout cela fonctionne?  Pour que vous puissiez le comprendre, je vais essayer d'expliquer chaque partie du cycle de vie de ce jeu √† la <strong>compilation</strong> en termes de code. <br><br><h3>  Injection de l'√©tat du jeu: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/20f/ffa/94220fffabe5eca432d47b90491fe7e7.png"></div><br>  Si vous √™tes un passionn√© ou un amateur de C ++, vous avez peut-√™tre remarqu√© que le vidage de l'√©tat du jeu pr√©c√©dent commence par le mod√®le suivant: <strong>R "(</strong> . En fait, il s'agit d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">litt√©ral de cha√Æne C ++ 11 brut</a> , ce qui signifie que je n'ai pas besoin d'√©chapper les caract√®res sp√©ciaux, par exemple, la <strong>traduction cha√Ænes</strong> : le litt√©ral de cha√Æne brut est stock√© dans un fichier appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">current_state.txt</a> . <br><br>  Comment injecter cet √©tat actuel du jeu dans un √©tat de compilation?  Ajoutons-le simplement aux entr√©es de boucle! <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr KeyboardInput keyboard_input = KeyboardInput::KEYBOARD_INPUT; //       constexpr auto get_game_state_string = []() constexpr { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  Qu'il s'agisse d'un fichier <em>.txt</em> ou d'un fichier <em>.h</em> , la directive <strong>include</strong> du pr√©processeur C fonctionnera de la m√™me mani√®re: elle copie le contenu du fichier √† son emplacement.  Ici, je copie le litt√©ral de cha√Æne brut de l'√©tat du jeu dans ascii dans une variable appel√©e <strong>game_state_string</strong> . <br><br>  Notez que le <a href="">fichier d'en-</a> t√™te <a href="">loop_inputs.hpp</a> √©tend √©galement la saisie au clavier √† l'√©tape de trame / compilation actuelle.  Contrairement √† l'√©tat du jeu, l'√©tat du clavier est assez petit et peut facilement √™tre obtenu comme d√©finition d'un pr√©processeur. <br><br><h3>  Calcul d'un nouvel √©tat au moment de la compilation: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/adb/e44/b1aadbe44035019fdc8bdb89a02b31b1.png"></div><br>  Maintenant que nous avons collect√© suffisamment de donn√©es, nous pouvons calculer le nouvel √©tat.  Enfin, nous avons atteint le point o√π nous devons √©crire le fichier <a href="">main.cpp</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include "loop_inputs.hpp" //   ,   . // :    . constexpr auto current_state = parse_game_state(get_game_state_string); //      . constexpr auto new_state = game_engine(current_state) //    , .update(keyboard_input); //  ,    . constexpr auto array = print_game_state(new_state); //      std::array&lt;char&gt;. // :    . //  :   . for (const char&amp; c : array) { std::cout &lt;&lt; c; }</span></span></code> </pre> <br>  √âtrange, mais ce code C ++ ne semble pas si d√©routant compte tenu de ce qu'il fait.  La plupart du code est ex√©cut√© dans la phase de compilation, cependant, il suit les paradigmes traditionnels de programmation POO et proc√©durale.  Seule la derni√®re ligne - le rendu - est un obstacle pour effectuer pleinement les calculs au moment de la compilation.  Comme nous le verrons ci-dessous, en jetant un peu de constexpr aux bons endroits, nous pouvons obtenir une m√©taprogrammation assez √©l√©gante en C ++ 17.  Je trouve d√©licieuse la libert√© que C ++ nous donne quand il s'agit d'une ex√©cution mixte lors de l'ex√©cution et de la compilation. <br><br>  Vous remarquerez √©galement que ce code n'ex√©cute qu'une seule trame, il n'y a pas de <strong>boucle de jeu</strong> .  R√©solvons ce probl√®me! <br><br><h3>  Nous collons tout ensemble: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d0/c65/870/8d0c65870264bfff26fde91c230bb8db.png"></div><br>  Si vous d√©go√ªtez mes astuces avec <strong>C ++</strong> , alors j'esp√®re que cela ne vous d√©rangera pas de voir mes comp√©tences <strong>Bash</strong> .  En fait, ma <strong>boucle de jeu</strong> n'est rien de plus qu'un <a href="">script bash</a> qui compile constamment. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  !  ,    !!! while; do : #      G++ g++ -o renderer main.cpp -DKEYBOARD_INPUT="$keypressed" keypressed=get_key_pressed() #  . clear #   current_state=$(./renderer) echo $current_state #    #     current_state.txt file       . echo "R\"(" &gt; current_state.txt echo $current_state &gt;&gt; current_state.txt echo ")\"" &gt;&gt; current_state.txt done</span></span></code> </pre> <br>  En fait, j'avais un peu de mal √† obtenir une entr√©e clavier depuis la console.  Au d√©part, je voulais me mettre en parall√®le avec la compilation.  Apr√®s de nombreux essais et erreurs, j'ai r√©ussi √† faire fonctionner plus ou moins quelque chose avec la commande de <code>read</code> de <strong>Bash</strong> .  Je n'ose jamais combattre le magicien <strong>Bash</strong> en duel - cette langue est trop sinistre! <br><br>  Donc, je dois admettre que pour g√©rer le cycle de jeu, j'ai d√ª recourir √† une autre langue.  Bien que techniquement rien ne m'emp√™che d'√©crire cette partie du code en C ++.  De plus, cela ne nie pas le fait que 90% de la logique de mon jeu est ex√©cut√©e au sein de l'√©quipe de compilation <strong>g ++</strong> , ce qui est assez √©tonnant! <br><br><h3>  Un petit gameplay pour se reposer les yeux: </h3><br>  Maintenant que vous avez √©prouv√© le tourment d'expliquer l'architecture du jeu, le temps est venu pour des peintures accrocheuses: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif"></div><br>  Ce gif pixelis√© est un enregistrement de la fa√ßon dont je joue √† <strong>Meta Crush Saga</strong> .  Comme vous pouvez le voir, le jeu fonctionne assez bien pour √™tre jouable en temps r√©el.  De toute √©vidence, elle n'est pas si attirante que je peux diffuser son Twitch et devenir la nouvelle Pewdiepie, mais elle fonctionne! <br><br>  L'un des aspects amusants du stockage de l' <strong>√©tat d'un jeu</strong> dans un fichier <em>.txt</em> est la possibilit√© de tricher ou de tester des cas extr√™mes tr√®s facilement. <br><br>  Maintenant que je vous ai bri√®vement pr√©sent√© l'architecture, nous allons nous plonger dans la fonctionnalit√© C ++ 17 utilis√©e dans ce projet.  Je ne consid√©rerai pas la logique du jeu en d√©tail, car elle se r√©f√®re exclusivement au Match-3, mais je parlerai plut√¥t des aspects de C ++ qui peuvent √™tre appliqu√©s dans d'autres projets. <br><br><h2>  Mes tutoriels sur C ++ 17: </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3f/325/d96/c3f325d9618c2a89dadb2873c61a7921.png"></div><br>  Contrairement √† C ++ 14, qui contenait principalement des correctifs mineurs, le nouveau standard C ++ 17 peut nous offrir beaucoup.  On esp√©rait que finalement les fonctionnalit√©s tant attendues (modules, coroutines, concepts ...) feraient enfin leur apparition, mais ... en g√©n√©ral ... elles n'apparaissent pas;  cela a boulevers√© beaucoup d'entre nous.  Mais apr√®s avoir lev√© le deuil, nous avons trouv√© de nombreux petits tr√©sors inattendus qui sont n√©anmoins tomb√©s dans la norme. <br><br>  J'ose dire que les enfants qui aiment la m√©taprogrammation sont trop g√¢t√©s cette ann√©e!  Des modifications et des ajouts mineurs s√©par√©s √† la langue vous permettent d√©sormais d'√©crire du code qui fonctionne tr√®s bien au moment de la compilation et apr√®s, au moment de l'ex√©cution. <br><br><h3>  Constepxr dans tous les domaines: </h3><br>  Comme Ben Dean et Jason Turner l'avaient pr√©dit dans leur rapport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ 14</a> , C ++ vous permet d'am√©liorer rapidement la compilation des valeurs au moment de la compilation avec le mot-cl√© omnipotent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">constexpr</a> .  En localisant ce mot cl√© aux bons endroits, vous pouvez indiquer au compilateur que l'expression est constante et <strong>peut √™tre</strong> √©valu√©e directement au moment de la compilation.  En <strong>C ++ 11,</strong> nous pouvions d√©j√† √©crire ce code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    constexpr       . { return n &lt;= 1? 1 : (n * factorial(n - 1)); } int i = factorial(5); //  constexpr-. //      : // int i = 120;</span></span></span></span></code> </pre> <br>  Bien que le mot cl√© <strong>constexpr</strong> soit tr√®s puissant, il a un certain nombre de restrictions d'utilisation, ce qui rend difficile l'√©criture de code expressif de cette mani√®re. <br><br>  <strong>C ++ 14 a</strong> consid√©rablement r√©duit les exigences de <strong>constexpr</strong> et est devenu beaucoup plus naturel √† utiliser.  Notre fonction factorielle pr√©c√©dente peut √™tre r√©√©crite comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  <strong>C ++ 14</strong> s'est d√©barrass√© de la r√®gle selon laquelle une <strong>fonction constexpr ne</strong> devrait comprendre qu'une seule instruction return, ce qui nous a oblig√©s √† utiliser l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">op√©rateur ternaire</a> comme bloc de construction principal.  Maintenant, <strong>C ++ 17</strong> apporte encore plus d'applications de mots cl√©s <strong>constexpr</strong> que nous pouvons explorer! <br><br><h4>  Branchement au moment de la compilation: </h4><br>  Avez-vous d√©j√† √©t√© dans une situation o√π vous devez obtenir un comportement diff√©rent en fonction du param√®tre de mod√®le que vous manipulez?  Supposons que nous ayons besoin d'une fonction param√©tr√©e <code>serialize</code> , qui appellera <code>.serialize()</code> si l'objet le fournit, sinon il aura recours √† <code>to_string</code> pour cela.  Comme expliqu√© plus en d√©tail dans cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article sur SFINAE</a> , vous devrez probablement √©crire un tel code √©tranger: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.serialize(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(obj); }</code> </pre> <br>  Ce n'est que dans un r√™ve que vous pourriez r√©√©crire cette <strong>astuce</strong> laide de l' <strong>astuce SFINAE</strong> en <strong>C ++ 14</strong> dans un code aussi magnifique: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize -  constexpr-,  serialize  . // .    SFINAE,  ,    . template &lt;class T&gt; constexpr bool has_serialize(const T&amp; /*t*/); template &lt;class T&gt; std::string serialize(const T&amp; obj) { //  ,  constexpr    . if (has_serialize(obj)) { return obj.serialize(); } else { return std::to_string(obj); } }</span></span></code> </pre> <br>  Malheureusement, lorsque vous vous √™tes r√©veill√© et avez commenc√© √† √©crire du vrai <strong>code C ++ 14</strong> , votre compilateur a √©mis un message d√©sagr√©able concernant l'appel √† <code>serialize(42);</code>  .  Il a expliqu√© qu'un <code>obj</code> type <code>int</code> n'a pas de fonction membre <code>serialize()</code> .  Peu importe comment cela vous exasp√®re, le compilateur a raison!  Avec ce code, il essaiera toujours de compiler les deux branches - <code>return obj.serialize();</code>  et <br> <code>return std::to_string(obj);</code>  .  Pour la branche <code>int</code> , <code>return obj.serialize();</code>  Cela pourrait bien se r√©v√©ler √™tre une sorte de code mort, car <code>has_serialize(obj)</code> retournera toujours <code>false</code> , mais le compilateur devra toujours le compiler. <br><br>  Comme vous l'avez probablement devin√©, <strong>C ++ 17</strong> nous sauve d'une situation aussi d√©sagr√©able, car il a permis d'ajouter <strong>constexpr</strong> apr√®s l'instruction if pour ¬´forcer¬ª la ramification au moment de la compilation et √©liminer les constructions inutilis√©es: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize... // ... template &lt;class T&gt; std::string serialize(const T&amp; obj) if constexpr (has_serialize(obj)) { //     constexpr   'if'. return obj.serialize(); //    ,    ,  obj  int. } else { return std::to_string(obj);branch } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/ae3/4d8/6deae34d807b14eb8ac178647abce09d.png"></div><br>  √âvidemment, c'est une √©norme am√©lioration par <strong>rapport √† l'astuce SFINAE que</strong> nous avons d√ª appliquer auparavant.  Apr√®s cela, nous avons commenc√© √† <strong>ressentir</strong> la m√™me d√©pendance que Ben et Jason - nous avons commenc√© √† utiliser <strong>constexpr</strong> partout et toujours.  H√©las, il existe un autre endroit o√π le mot-cl√© <strong>constexpr</strong> conviendrait, mais pas encore utilis√©: les <strong>param√®tres constexpr</strong> . <br><br><h4>  Param√®tres Constexpr: </h4><br>  Si vous faites attention, vous remarquerez peut-√™tre un motif √©trange dans l'exemple de code pr√©c√©dent.  Je parle des entr√©es de boucle: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr auto get_game_state_string = []() constexpr // ? { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  Pourquoi la variable <strong>game_state_string</strong> est- <strong>elle</strong> encapsul√©e dans un lambda constexpr?  Pourquoi ne fait-elle pas d'elle une <strong>variable globale constexpr</strong> ? <br><br>  Je voulais transmettre cette variable et son contenu profond√©ment dans certaines fonctions.  Par exemple, <strong>vous</strong> devez le passer √† mon <strong>parse_board</strong> et l'utiliser dans certaines expressions constantes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;GemType, parse_board_size(game_state_string)&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^ 'game_state_string' -   - // ... } parse_board(‚Äú...something...‚Äù);</span></span></code> </pre> <br>  Si nous proc√©dons de cette fa√ßon, le compilateur grincheux se plaindra que le param√®tre <strong>game_state_string n'est</strong> pas une expression constante.  Lorsque je cr√©e mon tableau de tuiles, je dois calculer directement sa capacit√© fixe (nous ne pouvons pas utiliser de vecteurs au moment de la compilation car ils n√©cessitent une allocation de m√©moire) et le passer comme argument au mod√®le de valeur dans <strong>std :: array</strong> .  Par cons√©quent, l' <strong>expression parse_board_size (game_state_string)</strong> doit √™tre une expression constante.  Bien que <strong>parse_board_size soit</strong> explicitement marqu√© comme <strong>constexpr</strong> , <strong>game_state_string</strong> ne l'est pas et ne peut pas l'√™tre!  Dans ce cas, deux r√®gles interf√®rent avec nous: <br><br><ul><li>  Les arguments d'une fonction constexpr ne sont pas constexpr! </li><li>  Et nous ne pouvons pas ajouter constexpr devant eux! </li></ul><br>  Tout cela se r√©sume au fait que les <strong>fonctions constexpr</strong> DOIVENT √™tre applicables dans le calcul √† la fois du temps d'ex√©cution et du temps de compilation.  En supposant l'existence de <strong>param√®tres constexpr</strong> , cela ne permettra pas leur utilisation au moment de l'ex√©cution. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/9a7/1be/02f9a71be0409a96415fd5b4a542e70d.jpg"></div><br>  Heureusement, il existe un moyen de r√©gler ce probl√®me.  Au lieu d'accepter la valeur comme param√®tre r√©gulier d'une fonction, nous pouvons encapsuler cette valeur dans un type et passer ce type comme param√®tre de mod√®le: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&amp;&amp;) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(GameStringType::value())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ... } struct GameString { static constexpr auto value() { return "...something..."; } }; parse_board(GameString{});</span></span></code> </pre> <br>  Dans cet exemple de code, je cr√©e un type structurel <strong>GameString</strong> qui a une fonction de membre statique constexpr <strong>value ()</strong> qui renvoie le litt√©ral de cha√Æne que je veux transmettre √† <strong>parse_board</strong> .  Dans <strong>parse_board,</strong> j'obtiens ce type via le <strong>param√®tre de</strong> mod√®le <strong>GameStringType</strong> , en utilisant les r√®gles d'extraction des arguments de mod√®le.  Ayant un <strong>GameStringType</strong> , √©tant donn√© que <strong>value ()</strong> est constexpr, je peux simplement appeler la <strong>valeur de la</strong> fonction membre statique <strong>()</strong> au bon moment pour obtenir un litt√©ral de cha√Æne m√™me dans les endroits o√π des expressions constantes sont n√©cessaires. <br><br>  Nous avons r√©ussi √† encapsuler le litt√©ral afin de le transmettre en quelque sorte √† <strong>parse_board en</strong> utilisant constexpr.  Cependant, il est tr√®s ennuyeux de devoir d√©finir un nouveau type chaque fois que vous devez envoyer un nouveau litt√©ral <strong>parse_board</strong> : "... quelque <strong>chose1</strong> ...", "... quelque <strong>chose2</strong> ...".  Pour r√©soudre ce probl√®me en <strong>C ++ 11</strong> , vous pouvez appliquer des macros laides et des adressages indirects en utilisant l'union anonyme et lambda.  Michael Park a bien expliqu√© ce sujet dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un de ses articles</a> . <br><br>  En <strong>C ++ 17, la</strong> situation est encore meilleure.  Si nous listons les exigences pour passer notre litt√©ral de cha√Æne, nous obtenons ce qui suit: <br><br><ul><li>  Fonction g√©n√©r√©e </li><li>  C'est constexpr </li><li>  Avec un nom unique ou anonyme </li></ul><br>  Ces exigences devraient vous donner un indice.  Nous avons besoin de <strong>constexpr lambda</strong> !  Et en <strong>C ++ 17, ils ont</strong> naturellement ajout√© la possibilit√© d'utiliser le <strong>mot cl√© constexpr</strong> pour les fonctions lambda.  Nous pouvons r√©√©crire notre exemple de code comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_game_state_string</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(get_game_state_string())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^      constexpr-. } parse_board([]() constexpr -&gt; { return ‚Äú...something...‚Äù; }); // ^    constexpr.</span></span></code> </pre> <br>  Croyez-moi, cela semble d√©j√† beaucoup plus pratique que le piratage pr√©c√©dent en <strong>C ++ 11 √† l'</strong> aide de macros.  J'ai d√©couvert ce truc g√©nial gr√¢ce √† <strong>Bjorn Fahler</strong> , un membre du groupe mitap C ++ auquel je participe.  En savoir plus sur cette astuce dans son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blog</a> .  Il convient √©galement de consid√©rer qu'en fait le mot cl√© <strong>constexpr</strong> est facultatif dans ce cas: tous les <strong>lambdas</strong> ayant la capacit√© de devenir <strong>constexpr le</strong> seront par d√©faut.  L'ajout explicite de <strong>constexpr</strong> est une signature qui simplifie notre d√©pannage. <br><br>  Vous devez maintenant comprendre pourquoi j'ai √©t√© oblig√© d'utiliser un lambda <strong>constexpr</strong> pour transmettre une cha√Æne repr√©sentant l'√©tat du jeu.  Regardez cette fonction lambda et vous aurez √† nouveau une autre question.  Quel est ce type <strong>constexpr_string</strong> que j'utilise √©galement pour envelopper le stock litt√©ral? <br><br><h5>  constexpr_string et constexpr_string_view: </h5><br>  Lorsque vous travaillez avec des cha√Ænes, vous ne devez pas les traiter dans le style C. Vous devez oublier tous ces algorithmes ennuyeux qui effectuent des it√©rations brutes et v√©rifier la compl√©tion z√©ro!  L'alternative offerte par <strong>C ++</strong> est les <strong>algorithmes</strong> omnipotents <strong>std :: string</strong> et <strong>STL</strong> .  Malheureusement, <strong>std :: string</strong> peut n√©cessiter une allocation de m√©moire sur le tas (m√™me avec Small String Optimization) pour stocker son contenu.  Une ou deux normes en arri√®re, nous pourrions utiliser <strong>constexpr new / delete</strong> ou nous pourrions passer des <strong>allocateurs constexpr</strong> √† <strong>std :: string</strong> , mais maintenant nous devons trouver une autre solution. <br><br>  Mon approche √©tait d'√©crire une classe <strong>constexpr_string</strong> avec une capacit√© fixe.  Cette capacit√© est transmise en tant que param√®tre au mod√®le de valeur.  Voici un bref aper√ßu de ma classe: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { private: std::array&lt;char, N&gt; data_; //  N char   -. std::size_t size_; //   . public: constexpr constexpr_string(const char(&amp;a)[N]): data_{}, size_(N -1) { //   data_ } // ... constexpr iterator begin() { return data_; } //    . constexpr iterator end() { return data_ + size_; } //     . // ... };</span></span></code> </pre> <br>  Ma classe <a href="">constexpr_string s'efforce</a> d'imiter l'interface <strong>std :: string le</strong> plus pr√®s possible (pour les op√©rations dont j'ai besoin): nous pouvons demander des <strong>it√©rateurs du d√©but et de la fin</strong> , obtenir la <strong>taille (taille)</strong> , acc√©der aux <strong>donn√©es (donn√©es)</strong> , <strong>supprimer (effacer) une</strong> partie d'entre elles, obtenir sous-cha√Æne en utilisant <strong>substr</strong> et ainsi de suite.  Cela facilite la conversion d'un morceau de code de <strong>std :: string</strong> en <strong>constexpr_string</strong> .  Vous vous demandez peut-√™tre ce qui se passe lorsque nous devons utiliser des op√©rations qui n√©cessitent g√©n√©ralement une mise en √©vidence dans <strong>std :: string</strong> .  Dans de tels cas, j'ai √©t√© oblig√© de les convertir en <strong>op√©rations immuables</strong> qui cr√©ent une nouvelle instance de <strong>constexpr_string</strong> . <br><br>  Jetons un coup d'≈ìil √† l'op√©ration d' <strong>ajout</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { // ... template &lt;std::size_t M&gt; // M -    . constexpr auto append(const constexpr_string&lt;M&gt;&amp; other) { constexpr_string&lt;N + M&gt; output(*this, size() + other.size()); // ^    . ^     output. for (std::size_t i = 0; i &lt; other.size(); ++i) { output[size() + i] = other[i]; ^     output. } return output; } // ... };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/481/745/1d0/4817451d03f8a4214afad8896e71b2b3.jpg"></div><br>  Vous n'avez pas besoin d'avoir un prix Fields pour supposer que si nous avons une cha√Æne de taille <strong>N</strong> et une cha√Æne de taille <strong>M</strong> , alors une cha√Æne de taille <strong>N + M</strong> sera suffisante pour stocker leur concat√©nation.  Nous pouvons gaspiller une partie du ¬´r√©f√©rentiel de compilation¬ª, car les deux lignes peuvent ne pas utiliser toute la capacit√©, mais c'est un prix plut√¥t petit pour plus de commodit√©.  √âvidemment, j'ai √©galement √©crit un doublon de <strong>std :: string_view</strong> , qui s'appelait <a href="">constexpr_string_view</a> . <br><br>  Avec ces deux classes, j'√©tais pr√™t √† √©crire un code √©l√©gant pour analyser mon <strong>√©tat de jeu</strong> .  Pensez √† quelque chose comme √ßa: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> game_state = constexpr_string(‚Äú...something...‚Äù); <span class="hljs-comment"><span class="hljs-comment">//          : constexpr auto blue_gem = find_if(game_state.begin(), game_state.end(), [](char c) constexpr -&gt; { return c == 'B'; } );</span></span></code> </pre> <br>  Il √©tait assez facile de parcourir les joyaux du terrain de jeu - au fait, avez-vous remarqu√© une autre caract√©ristique pr√©cieuse de <strong>C ++ 17</strong> dans cet exemple de code? <br><br>  Oui!  Je n'ai pas eu √† sp√©cifier explicitement la capacit√© de <strong>constexpr_string</strong> lors de sa construction.  Auparavant, lors de l'utilisation d'un <strong>mod√®le de classe</strong> , nous devions indiquer explicitement ses arguments.  Pour √©viter ces <em>pangs</em> , nous cr√©ons des fonctions <em>make_xxx</em> car les param√®tres <strong>des mod√®les de fonction</strong> peuvent √™tre trac√©s.  D√©couvrez comment le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suivi des arguments des mod√®les de classe</a> change nos vies pour le mieux: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr_string</span></span></span><span class="hljs-class"> {</span></span> constexpr_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>(&amp;a)[N]) {} <span class="hljs-comment"><span class="hljs-comment">// .. }; // ****  C++17 **** template &lt;int N&gt; constexpr_string&lt;N&gt; make_constexpr_string(const char(&amp;a)[N]) { //      N ^   return constexpr_string&lt;N&gt;(a); // ^    . } auto test2 = make_constexpr_string("blablabla"); // ^      . constexpr_string&lt;7&gt; test("blabla"); // ^      ,    . // ****  C++17 **** constexpr_string test("blabla"); // ^    ,  .</span></span></code> </pre> <br>  Dans certaines situations difficiles, vous devrez aider le compilateur √† calculer correctement les arguments.  Si vous rencontrez un tel probl√®me, √©tudiez les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuels pour les calculs d'arguments d√©finis par l'utilisateur</a> . <br><br><h4>  Nourriture gratuite de STL: </h4><br>  Eh bien, nous pouvons toujours tout r√©√©crire par nous-m√™mes.  Mais peut-√™tre que les membres du comit√© ont g√©n√©reusement pr√©par√© quelque chose pour nous dans la biblioth√®que standard? <br><br><h5>  Nouveaux types d'assistance: </h5><br>  En <strong>C ++ 17</strong> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: variant</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: optional sont</a> ajout√©s aux types de dictionnaire standard, bas√©s sur <strong>constexpr</strong> .  Le premier est tr√®s int√©ressant car il nous permet d'exprimer des associations de type s√ªr, mais l'impl√©mentation dans la <strong>biblioth√®que libstdc ++</strong> avec <strong>GCC 7.2</strong> a des probl√®mes lors de l'utilisation d'expressions constantes.  Par cons√©quent, j'ai abandonn√© l'id√©e d'ajouter <strong>std :: variant</strong> √† mon code et d'utiliser uniquement <strong>std :: optional</strong> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec le type </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T, le</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: optional</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous permet de cr√©er un nouveau type </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: optional &lt;T&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui peut contenir soit une valeur de type </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> soit rien. Ceci est assez similaire aux </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">types significatifs qui autorisent une valeur ind√©finie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C #</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Regardons la fonction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_in_board</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui retourne la position du premier √©l√©ment sur un champ qui confirme que le pr√©dicat est correct. Il n'y a peut-√™tre pas un tel √©l√©ment sur le terrain. Pour g√©rer cette situation, le type de position doit √™tre facultatif:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Predicate</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; find_in_board(GameBoard&amp;&amp; g, Predicate&amp;&amp; p) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> item : g.items()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(item)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {item.x, item.y}; } <span class="hljs-comment"><span class="hljs-comment">//   ,     . } return std::nullopt; //      . } auto item = find_in_board(g, [](const auto&amp; item) { return true; }); if (item) { // ,   optional. do_something(*item); //    optional, ""   *. /* ... */ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auparavant, nous devions recourir √† la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√©mantique des pointeurs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou ajouter un ¬´√©tat vide¬ª directement au type de position, ou renvoyer un bool√©en et prendre le </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param√®tre de sortie</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Certes, c'√©tait assez g√™nant! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certains types pr√©existants ont √©galement re√ßu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> support </font><strong><font style="vertical-align: inherit;">constexpr</font></strong><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pair</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Je ne vais pas expliquer en d√©tail leur utilisation, car beaucoup a d√©j√† √©t√© √©crit √† leur sujet, mais je partagerai une de mes d√©ceptions. Le comit√© a ajout√© </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">du sucre syntaxique</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† la </font><font style="vertical-align: inherit;">norme </font><font style="vertical-align: inherit;">pour extraire les valeurs contenues dans un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuple</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paire</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ce nouveau type de d√©claration appel√© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liaison structur√©e</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, utilise des parenth√®ses pour sp√©cifier dans quelles variables stocker le </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuple</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paire</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> divis√© </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">1337</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// x = 42, y = 1337.</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tr√®s intelligent! </font><font style="vertical-align: inherit;">Mais il est dommage que les membres du comit√© [n'aient pas pu, ne voulaient pas, n'aient pas trouv√© le temps, aient oubli√©] de les rendre amicaux avec </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Je m'attendrais √† quelque chose comme √ßa:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// OR auto [x, y] constexpr = foo();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous avons maintenant des conteneurs et des types d'assistance complexes, mais comment pouvons-nous les manipuler facilement? </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmes: </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mise √† niveau d'un conteneur pour le traitement de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une t√¢che assez monotone. </font><font style="vertical-align: inherit;">Par rapport √† cela, le portage de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vers des </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algorithmes non </font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">modificateurs</font></strong><font style="vertical-align: inherit;"> semble assez simple. </font><font style="vertical-align: inherit;">Mais il est plut√¥t √©trange qu'en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous n'ayons pas vu de progr√®s dans ce domaine, il n'appara√Ætra qu'en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Par exemple, les merveilleux algorithmes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: find</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'ont pas re√ßu de signatures </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais n'ayez pas peur! </font><font style="vertical-align: inherit;">Comme Ben et Jason l'ont expliqu√©, vous pouvez facilement transformer l'algorithme en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en copiant simplement l'impl√©mentation actuelle (mais n'oubliez pas les droits d'auteur); </font><font style="vertical-align: inherit;">cppreference est bon. </font><font style="vertical-align: inherit;">Mesdames et messieurs, je pr√©sente √† votre attention</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr std :: find</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) // ^ !!!    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class">. {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; first != last; ++first) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*first == value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> last; } <span class="hljs-comment"><span class="hljs-comment">//  http://en.cppreference.com/w/cpp/algorithm/find</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'entends d√©j√† depuis les tribunes les cris des fans d'optimisation! </font><font style="vertical-align: inherit;">Oui, le simple fait d'ajouter </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devant l'exemple de code aimablement fourni par </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pourrait ne pas nous donner une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vitesse</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> id√©ale </font><strong><font style="vertical-align: inherit;">lors de l'ex√©cution</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mais si nous devons am√©liorer cet algorithme, il sera n√©cessaire pour la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vitesse au moment de la compilation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pour autant que je sache, en ce qui concerne la vitesse de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compilation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , les solutions simples sont les meilleures.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vitesse et bugs: </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les d√©veloppeurs de tout jeu AAA devraient investir dans la r√©solution de ces probl√®mes, non? </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vitesse: </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque j'ai r√©ussi √† cr√©er une version √† moiti√© fonctionnelle de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le travail s'est d√©roul√© plus facilement. En fait, j'ai r√©ussi √† atteindre un peu plus de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (images par seconde) sur mon ancien portable avec i5 overclock√© √† 1,80 GHz (la fr√©quence est importante dans ce cas). Comme dans tout projet, j'ai rapidement r√©alis√© que le code pr√©c√©demment √©crit √©tait d√©go√ªtant et j'ai commenc√© √† r√©√©crire l'analyse de l'√©tat du jeu en utilisant </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr_string</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et des algorithmes standard. Bien que cela ait rendu le code beaucoup plus pratique √† maintenir, les changements ont s√©rieusement affect√© la vitesse; le nouveau plafond est de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malgr√© le vieil adage √† propos de C ++, les ¬´abstractions z√©ro-t√™te¬ª ne sont pas applicables aux </font><strong><font style="vertical-align: inherit;">calculs au moment</font></strong><font style="vertical-align: inherit;"> de la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compilation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ceci est tout √† fait logique si nous consid√©rons le compilateur comme un interpr√®te d'un ¬´code temporel de compilation¬ª. </font><font style="vertical-align: inherit;">Des am√©liorations pour divers compilateurs sont encore possibles, mais il existe √©galement des opportunit√©s de croissance pour nous, les auteurs de ce code. </font><font style="vertical-align: inherit;">Voici une liste incompl√®te d'observations et de conseils que j'ai trouv√©s, peut-√™tre sp√©cifiques √† GCC:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les tableaux C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonctionnent beaucoup mieux que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un peu de cosm√©tiques C ++ modernes au-dessus </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'un tableau de style C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et vous devez payer un prix pour l'utiliser dans de telles conditions.</font></font></li><li>  ,  <strong> </strong>   (   )     <strong>  </strong> .  ,   ,          ,    .    :  ,         ,     ,    ,   (  )      ,        . </li><li>      ,      .        ,        . </li><li>         .            GCC.  ,     ¬´¬ª. </li></ul><br><h4> : </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78c/000/4e9/78c0004e91d753a658fa8190626c3be9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plusieurs fois, mon compilateur a crach√© de terribles erreurs de compilation et ma logique de code a souffert. Mais comment trouver l'endroit o√π se cache le bug? Sans </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©bogueur</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf, les</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> choses se compliquent. Si votre "barbe de programmeur" m√©taphorique ne s'est pas encore mise √† genoux (la barbe m√©taphorique et ma vraie barbe sont encore loin de ces attentes), alors vous n'avez peut-√™tre pas la motivation d'utiliser </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">templight</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou de d√©boguer le compilateur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre premier ami sera </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui nous donne la possibilit√© de v√©rifier la valeur bool√©enne du temps de compilation. Notre deuxi√®me ami sera une macro qui </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">active</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et d√©sactive </font><strong><font style="vertical-align: inherit;">constexpr dans la</font></strong><font style="vertical-align: inherit;"> mesure du possible:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONSTEXPR constexpr </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      //  #define CONSTEXPR //    </span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avec cette macro, nous pouvons faire fonctionner la logique au moment de l'ex√©cution, ce qui signifie que nous pouvons y attacher un d√©bogueur. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meta Crush Saga II - efforcez-vous de jouer compl√®tement au moment de l'ex√©cution: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De toute √©vidence, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne remportera pas les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game Awards</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cette ann√©e </font><font style="vertical-align: inherit;">. Il a un grand potentiel, mais le gameplay n'est pas enti√®rement ex√©cut√© </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au moment de la compilation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela peut ennuyer les joueurs hardcore ... Je ne peux pas me d√©barrasser du script bash √† moins que quelqu'un ajoute une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entr√©e au clavier</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et une logique impure dans la phase de compilation (et c'est une folie franche!). Mais je pense qu'un jour je pourrai abandonner compl√®tement le fichier ex√©cutable du </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moteur de rendu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et afficher l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©tat du jeu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moment de la compilation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/661/efc/26d/661efc26dbb41f0b8800916058993a56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le fou avec l'alias </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saarraz a </font></font></strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©tendu GCC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour ajouter la construction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_print</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> au langage </font><font style="vertical-align: inherit;">. Cette construction doit prendre plusieurs expressions constantes ou litt√©raux de cha√Æne et les afficher au stade de la compilation. Je serais heureux si un tel outil √©tait ajout√© au standard, ou au moins √©tendu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin qu'il </font><strong><font style="vertical-align: inherit;">accepte</font></strong><font style="vertical-align: inherit;"> des expressions constantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17, il</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut </font><strong><font style="vertical-align: inherit;">y</font></strong><font style="vertical-align: inherit;"> avoir un moyen d'obtenir ce r√©sultat. Les compilateurs produisent d√©j√† deux choses - des </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erreurs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et des </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avertissements</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! Si nous pouvons en quelque sorte g√©rer ou modifier les </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avertissements</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selon nos besoins, nous recevrons d√©j√† une conclusion valable. J'ai essay√© plusieurs solutions, notamment</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attribut obsol√®te</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... words&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useless</span></span></span><span class="hljs-class"> {</span></span> [[deprecated]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// Will trigger a warning. }; template &lt;char... words&gt; void output_as_warning() { useless&lt;words...&gt;().call(); } output_as_warning&lt;'a', 'b', 'c'&gt;(); // warning: 'void useless&lt;words&gt;::call() [with char ...words = {'a', 'b', 'c'}]' is deprecated // [-Wdeprecated-declarations]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que la sortie soit √©videmment pr√©sente et qu'elle puisse √™tre analys√©e, malheureusement, le code est injouable! </font><font style="vertical-align: inherit;">Si, par pure co√Øncidence, vous √™tes membre d'une soci√©t√© secr√®te de programmeurs C ++ qui peuvent effectuer une sortie pendant la compilation, alors je serai heureux de vous embaucher dans mon √©quipe pour cr√©er la parfaite </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga II</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusions: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai fini par vous vendre mon </font><font style="vertical-align: inherit;">jeu d' </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arnaque</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">J'esp√®re que vous trouverez ce post curieux et apprendrez quelque chose de nouveau dans le processus de lecture. </font><font style="vertical-align: inherit;">Si vous trouvez des erreurs ou des moyens d'am√©liorer l'article, contactez-moi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je tiens √† remercier l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©quipe de SwedenCpp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de m'avoir </font><strong><font style="vertical-align: inherit;">permis de</font></strong><font style="vertical-align: inherit;"> r√©aliser mon rapport de projet lors d'un de leurs √©v√©nements. </font><font style="vertical-align: inherit;">En outre, je tiens √† exprimer ma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profonde</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gratitude √† </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Alexander Gurdeev</font></a><font style="vertical-align: inherit;"> , qui m'a aid√© √† am√©liorer les aspects importants de la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saga Meta Crush</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414465/">https://habr.com/ru/post/fr414465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414451/index.html">"Calendrier des testeurs" pour juin. Le testeur doit attraper le bug, lire Caner et organiser le d√©placement.</a></li>
<li><a href="../fr414453/index.html">Impl√©menter Path Finder pour les agents AI avec NavMesh</a></li>
<li><a href="../fr414455/index.html">Algorithme de g√©n√©ration de palette de couleurs</a></li>
<li><a href="../fr414459/index.html">D√©tecteurs et descripteurs de points singuliers FAST, BRIEF, ORB</a></li>
<li><a href="../fr414463/index.html">L'IA elle-m√™me a appris √† construire un Rubik's Cube</a></li>
<li><a href="../fr414467/index.html">Articles de la conf√©rence Minsk C ++ CoreHard Spring 2018</a></li>
<li><a href="../fr414469/index.html">Semaine de la s√©curit√© 22: Deux secondes de verrouillage intelligent</a></li>
<li><a href="../fr414471/index.html">11 cercles d'enfer pour ceux qui manquent d'exp√©rience dans un nouvel emploi</a></li>
<li><a href="../fr414473/index.html">DVR Ninja: examen Neoline G-Tech X27 Dual</a></li>
<li><a href="../fr414475/index.html">¬´Utilisateurs finaux - nous sommes avec vous¬ª: √† propos du d√©veloppement Android dans CFT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>